Walking from GO.link/src to GO.link/src/archive
Processing archive:
Walking from GO.link/src to GO.link/src/archive/tar
Processing archive/tar:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/archive/tar/stat_actime2.go) => true <nil>
Matchfile(GO.link/src/archive/tar/format.go) => true <nil>
Matchfile(GO.link/src/archive/tar/writer.go) => true <nil>
Ignoring test code in tar_test.go
Matchfile(GO.link/src/archive/tar/common.go) => true <nil>
Matchfile(GO.link/src/archive/tar/stat_unix.go) => true <nil>
Matchfile(GO.link/src/archive/tar/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/tar/strconv.go) => true <nil>
Matchfile(GO.link/src/archive/tar/stat_actime1.go) => false <nil>
Ignoring test code in strconv_test.go
Processing package=archive/tar:
Excluding GO.link/src/archive/tar/testdata
Walking from GO.link/src to GO.link/src/archive/zip
Processing archive/zip:
Matchfile(GO.link/src/archive/zip/register.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in zip_test.go
Matchfile(GO.link/src/archive/zip/writer.go) => true <nil>
Matchfile(GO.link/src/archive/zip/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/zip/struct.go) => true <nil>
Processing package=archive/zip:
Excluding GO.link/src/archive/zip/testdata
Walking from GO.link/src to GO.link/src/bufio
Processing bufio:
Ignoring test code in example_test.go
Ignoring test code in bufio_test.go
Matchfile(GO.link/src/bufio/scan.go) => true <nil>
Matchfile(GO.link/src/bufio/bufio.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in scan_test.go
Processing package=bufio:
Excluding GO.link/src/builtin
Walking from GO.link/src to GO.link/src/bytes
Processing bytes:
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/bytes/bytes_decl.go) => true <nil>
Ignoring test code in boundary_test.go
Ignoring test code in buffer_test.go
Matchfile(GO.link/src/bytes/buffer.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/bytes/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/bytes/bytes.go) => true <nil>
Ignoring test code in bytes_test.go
Processing package=bytes:
Excluding GO.link/src/cmd
Walking from GO.link/src to GO.link/src/compress
Processing compress:
Walking from GO.link/src to GO.link/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(GO.link/src/compress/bzip2/huffman.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/bit_reader.go) => true <nil>
Processing package=compress/bzip2:
Excluding GO.link/src/compress/bzip2/testdata
Walking from GO.link/src to GO.link/src/compress/flate
Processing compress/flate:
Ignoring test code in flate_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/compress/flate/token.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/flate/inflate.go) => true <nil>
Matchfile(GO.link/src/compress/flate/deflate.go) => true <nil>
Ignoring test code in huffman_bit_writer_test.go
Ignoring test code in dict_decoder_test.go
Ignoring test code in deflate_test.go
Matchfile(GO.link/src/compress/flate/deflatefast.go) => true <nil>
Ignoring test code in inflate_test.go
Matchfile(GO.link/src/compress/flate/huffman_bit_writer.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/compress/flate/dict_decoder.go) => true <nil>
Matchfile(GO.link/src/compress/flate/huffman_code.go) => true <nil>
Processing package=compress/flate:
Excluding GO.link/src/compress/flate/testdata
Walking from GO.link/src to GO.link/src/compress/gzip
Processing compress/gzip:
Ignoring test code in example_test.go
Matchfile(GO.link/src/compress/gzip/gzip.go) => true <nil>
Matchfile(GO.link/src/compress/gzip/gunzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Ignoring test code in gunzip_test.go
Processing package=compress/gzip:
Excluding GO.link/src/compress/gzip/testdata
Walking from GO.link/src to GO.link/src/compress/lzw
Processing compress/lzw:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/lzw/writer.go) => true <nil>
Matchfile(GO.link/src/compress/lzw/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=compress/lzw:
Excluding GO.link/src/compress/testdata
Walking from GO.link/src to GO.link/src/compress/zlib
Processing compress/zlib:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/zlib/writer.go) => true <nil>
Matchfile(GO.link/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=compress/zlib:
Walking from GO.link/src to GO.link/src/container
Processing container:
Walking from GO.link/src to GO.link/src/container/heap
Processing container/heap:
Matchfile(GO.link/src/container/heap/heap.go) => true <nil>
Ignoring test code in example_pq_test.go
Ignoring test code in example_intheap_test.go
Ignoring test code in heap_test.go
Processing package=container/heap:
Walking from GO.link/src to GO.link/src/container/list
Processing container/list:
Matchfile(GO.link/src/container/list/list.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in list_test.go
Processing package=container/list:
Walking from GO.link/src to GO.link/src/container/ring
Processing container/ring:
Ignoring test code in example_test.go
Matchfile(GO.link/src/container/ring/ring.go) => true <nil>
Ignoring test code in ring_test.go
Processing package=container/ring:
Walking from GO.link/src to GO.link/src/context
Processing context:
Ignoring test code in example_test.go
Ignoring test code in net_test.go
Ignoring test code in context_test.go
Matchfile(GO.link/src/context/context.go) => true <nil>
Ignoring test code in x_test.go
Ignoring test code in benchmark_test.go
Processing package=context:
Walking from GO.link/src to GO.link/src/crypto
Processing crypto:
Ignoring test code in issue21104_test.go
Matchfile(GO.link/src/crypto/crypto.go) => true <nil>
Processing package=crypto:
Walking from GO.link/src to GO.link/src/crypto/aes
Processing crypto/aes:
Matchfile(GO.link/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/ctr_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/aes_gcm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/modes.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_generic.go) => false <nil>
Ignoring test code in modes_test.go
Ignoring test code in aes_test.go
Matchfile(GO.link/src/crypto/aes/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/const.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/block.go) => true <nil>
Processing package=crypto/aes:
Walking from GO.link/src to GO.link/src/crypto/cipher
Processing crypto/cipher:
Matchfile(GO.link/src/crypto/cipher/cfb.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/cbc.go) => true <nil>
Ignoring test code in ctr_aes_test.go
Ignoring test code in xor_test.go
Matchfile(GO.link/src/crypto/cipher/ofb.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in ctr_test.go
Ignoring test code in cipher_test.go
Ignoring test code in cbc_aes_test.go
Ignoring test code in gcm_test.go
Matchfile(GO.link/src/crypto/cipher/io.go) => true <nil>
Ignoring test code in common_test.go
Ignoring test code in cfb_test.go
Matchfile(GO.link/src/crypto/cipher/xor.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/ctr.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in benchmark_test.go
Ignoring test code in ofb_test.go
Processing package=crypto/cipher:
Walking from GO.link/src to GO.link/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Ignoring test code in des_test.go
Matchfile(GO.link/src/crypto/des/cipher.go) => true <nil>
Matchfile(GO.link/src/crypto/des/const.go) => true <nil>
Matchfile(GO.link/src/crypto/des/block.go) => true <nil>
Processing package=crypto/des:
Walking from GO.link/src to GO.link/src/crypto/dsa
Processing crypto/dsa:
Ignoring test code in dsa_test.go
Matchfile(GO.link/src/crypto/dsa/dsa.go) => true <nil>
Processing package=crypto/dsa:
Walking from GO.link/src to GO.link/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in example_test.go
Ignoring test code in ecdsa_test.go
Matchfile(GO.link/src/crypto/ecdsa/ecdsa.go) => true <nil>
Processing package=crypto/ecdsa:
Excluding GO.link/src/crypto/ecdsa/testdata
Walking from GO.link/src to GO.link/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(GO.link/src/crypto/elliptic/p224.go) => true <nil>
Ignoring test code in fuzz_test.go
Ignoring test code in p224_test.go
Matchfile(GO.link/src/crypto/elliptic/elliptic.go) => true <nil>
Ignoring test code in elliptic_test.go
Matchfile(GO.link/src/crypto/elliptic/p256_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/elliptic/p256.go) => false <nil>
Processing package=crypto/elliptic:
Walking from GO.link/src to GO.link/src/crypto/hmac
Processing crypto/hmac:
Ignoring test code in hmac_test.go
Matchfile(GO.link/src/crypto/hmac/hmac.go) => true <nil>
Processing package=crypto/hmac:
Excluding GO.link/src/crypto/internal
Walking from GO.link/src to GO.link/src/crypto/md5
Processing crypto/md5:
Matchfile(GO.link/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/md5/gen.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/md5/md5block.go) => true <nil>
Matchfile(GO.link/src/crypto/md5/md5block_generic.go) => false <nil>
Ignoring test code in md5_test.go
Matchfile(GO.link/src/crypto/md5/md5.go) => true <nil>
Processing package=crypto/md5:
Walking from GO.link/src to GO.link/src/crypto/rand
Processing crypto/rand:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/rand/rand_unix.go) => true <nil>
Ignoring test code in rand_linux_test.go
Matchfile(GO.link/src/crypto/rand/rand_openbsd.go) => false <nil>
Ignoring test code in util_test.go
Ignoring test code in rand_test.go
Matchfile(GO.link/src/crypto/rand/util.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_js.go) => false <nil>
Matchfile(GO.link/src/crypto/rand/rand_linux.go) => false <nil>
Matchfile(GO.link/src/crypto/rand/rand.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/eagain.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_windows.go) => false <nil>
Processing package=crypto/rand:
Walking from GO.link/src to GO.link/src/crypto/rc4
Processing crypto/rc4:
Matchfile(GO.link/src/crypto/rc4/rc4_ref.go) => false <nil>
Matchfile(GO.link/src/crypto/rc4/rc4_asm.go) => true <nil>
Ignoring test code in rc4_test.go
Matchfile(GO.link/src/crypto/rc4/rc4.go) => true <nil>
Processing package=crypto/rc4:
Walking from GO.link/src to GO.link/src/crypto/rsa
Processing crypto/rsa:
Ignoring test code in pkcs1v15_test.go
Ignoring test code in example_test.go
Ignoring test code in pss_test.go
Ignoring test code in rsa_test.go
Matchfile(GO.link/src/crypto/rsa/rsa.go) => true <nil>
Matchfile(GO.link/src/crypto/rsa/pkcs1v15.go) => true <nil>
Matchfile(GO.link/src/crypto/rsa/pss.go) => true <nil>
Processing package=crypto/rsa:
Excluding GO.link/src/crypto/rsa/testdata
Walking from GO.link/src to GO.link/src/crypto/sha1
Processing crypto/sha1:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in sha1_test.go
Matchfile(GO.link/src/crypto/sha1/sha1.go) => true <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_decl.go) => false <nil>
Ignoring test code in issue15617_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Processing package=crypto/sha1:
Walking from GO.link/src to GO.link/src/crypto/sha256
Processing crypto/sha256:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/sha256/sha256.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Ignoring test code in sha256_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block.go) => true <nil>
Processing package=crypto/sha256:
Walking from GO.link/src to GO.link/src/crypto/sha512
Processing crypto/sha512:
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha512/sha512.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_decl.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Ignoring test code in sha512_test.go
Matchfile(GO.link/src/crypto/sha512/sha512block_generic.go) => false <nil>
Processing package=crypto/sha512:
Walking from GO.link/src to GO.link/src/crypto/subtle
Processing crypto/subtle:
Ignoring test code in constant_time_test.go
Matchfile(GO.link/src/crypto/subtle/constant_time.go) => true <nil>
Processing package=crypto/subtle:
Walking from GO.link/src to GO.link/src/crypto/tls
Processing crypto/tls:
Ignoring test code in example_test.go
Ignoring test code in handshake_test.go
Ignoring test code in handshake_messages_test.go
Matchfile(GO.link/src/crypto/tls/ticket.go) => true <nil>
Ignoring test code in auth_test.go
Matchfile(GO.link/src/crypto/tls/handshake_client.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in prf_test.go
Ignoring test code in handshake_server_test.go
Matchfile(GO.link/src/crypto/tls/prf.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/handshake_server.go) => true <nil>
Ignoring test code in handshake_client_test.go
Matchfile(GO.link/src/crypto/tls/handshake_messages.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/common.go) => true <nil>
Ignoring test code in conn_test.go
Matchfile(GO.link/src/crypto/tls/key_agreement.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/cipher_suites.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/tls.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/alert.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/generate_cert.go) => false <nil>
Ignoring test code in tls_test.go
Matchfile(GO.link/src/crypto/tls/conn.go) => true <nil>
Processing package=crypto/tls:
Excluding GO.link/src/crypto/tls/testdata
Walking from GO.link/src to GO.link/src/crypto/x509
Processing crypto/x509:
Matchfile(GO.link/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_js.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_unix.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/x509.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/pem_decrypt.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in name_constraints_test.go
Ignoring test code in root_unix_test.go
Ignoring test code in x509_test.go
Ignoring test code in pkcs8_test.go
Matchfile(GO.link/src/crypto/x509/x509_test_import.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/sec1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/cert_pool.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Ignoring test code in pem_decrypt_test.go
Matchfile(GO.link/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_cgo_darwin.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_bsd.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_armx.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_nacl.go) => false <nil>
Ignoring test code in verify_test.go
Matchfile(GO.link/src/crypto/x509/root_plan9.go) => false <nil>
Ignoring test code in root_darwin_test.go
Matchfile(GO.link/src/crypto/x509/pkcs8.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_linux.go) => false <nil>
Ignoring test code in sec1_test.go
Matchfile(GO.link/src/crypto/x509/root.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/verify.go) => true <nil>
Processing package=crypto/x509:
Walking from GO.link/src to GO.link/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(GO.link/src/crypto/x509/pkix/pkix.go) => true <nil>
Processing package=crypto/x509/pkix:
Excluding GO.link/src/crypto/x509/testdata
Walking from GO.link/src to GO.link/src/database
Processing database:
Walking from GO.link/src to GO.link/src/database/sql
Processing database/sql:
Ignoring test code in example_test.go
Matchfile(GO.link/src/database/sql/convert.go) => true <nil>
Ignoring test code in sql_test.go
Ignoring test code in fakedb_test.go
Ignoring test code in convert_test.go
Matchfile(GO.link/src/database/sql/ctxutil.go) => true <nil>
Matchfile(GO.link/src/database/sql/sql.go) => true <nil>
Processing package=database/sql:
Walking from GO.link/src to GO.link/src/database/sql/driver
Processing database/sql/driver:
Ignoring test code in types_test.go
Matchfile(GO.link/src/database/sql/driver/types.go) => true <nil>
Matchfile(GO.link/src/database/sql/driver/driver.go) => true <nil>
Processing package=database/sql/driver:
Walking from GO.link/src to GO.link/src/debug
Processing debug:
Walking from GO.link/src to GO.link/src/debug/dwarf
Processing debug/dwarf:
Matchfile(GO.link/src/debug/dwarf/buf.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/type.go) => true <nil>
Ignoring test code in entry_test.go
Matchfile(GO.link/src/debug/dwarf/line.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/tag_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/open.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/entry.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/unit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/attr_string.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in type_test.go
Ignoring test code in line_test.go
Matchfile(GO.link/src/debug/dwarf/const.go) => true <nil>
Processing package=debug/dwarf:
Excluding GO.link/src/debug/dwarf/testdata
Walking from GO.link/src to GO.link/src/debug/elf
Processing debug/elf:
Ignoring test code in symbols_test.go
Ignoring test code in file_test.go
Ignoring test code in elf_test.go
Matchfile(GO.link/src/debug/elf/elf.go) => true <nil>
Matchfile(GO.link/src/debug/elf/file.go) => true <nil>
Matchfile(GO.link/src/debug/elf/reader.go) => true <nil>
Processing package=debug/elf:
Excluding GO.link/src/debug/elf/testdata
Walking from GO.link/src to GO.link/src/debug/gosym
Processing debug/gosym:
Matchfile(GO.link/src/debug/gosym/symtab.go) => true <nil>
Matchfile(GO.link/src/debug/gosym/pclntab.go) => true <nil>
Ignoring test code in symtab_test.go
Ignoring test code in pclntab_test.go
Processing package=debug/gosym:
Walking from GO.link/src to GO.link/src/debug/macho
Processing debug/macho:
Matchfile(GO.link/src/debug/macho/reloctype.go) => true <nil>
Matchfile(GO.link/src/debug/macho/macho.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/macho/file.go) => true <nil>
Matchfile(GO.link/src/debug/macho/fat.go) => true <nil>
Matchfile(GO.link/src/debug/macho/reloctype_string.go) => true <nil>
Processing package=debug/macho:
Excluding GO.link/src/debug/macho/testdata
Walking from GO.link/src to GO.link/src/debug/pe
Processing debug/pe:
Matchfile(GO.link/src/debug/pe/section.go) => true <nil>
Matchfile(GO.link/src/debug/pe/symbol.go) => true <nil>
Ignoring test code in file_test.go
Ignoring test code in file_cgo_test.go
Matchfile(GO.link/src/debug/pe/file.go) => true <nil>
Matchfile(GO.link/src/debug/pe/pe.go) => true <nil>
Matchfile(GO.link/src/debug/pe/string.go) => true <nil>
Processing package=debug/pe:
Excluding GO.link/src/debug/pe/testdata
Walking from GO.link/src to GO.link/src/debug/plan9obj
Processing debug/plan9obj:
Matchfile(GO.link/src/debug/plan9obj/plan9obj.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/plan9obj/file.go) => true <nil>
Processing package=debug/plan9obj:
Excluding GO.link/src/debug/plan9obj/testdata
Walking from GO.link/src to GO.link/src/encoding
Processing encoding:
Matchfile(GO.link/src/encoding/encoding.go) => true <nil>
Processing package=encoding:
Walking from GO.link/src to GO.link/src/encoding/ascii85
Processing encoding/ascii85:
Ignoring test code in ascii85_test.go
Matchfile(GO.link/src/encoding/ascii85/ascii85.go) => true <nil>
Processing package=encoding/ascii85:
Walking from GO.link/src to GO.link/src/encoding/asn1
Processing encoding/asn1:
Matchfile(GO.link/src/encoding/asn1/marshal.go) => true <nil>
Matchfile(GO.link/src/encoding/asn1/common.go) => true <nil>
Matchfile(GO.link/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in marshal_test.go
Ignoring test code in asn1_test.go
Processing package=encoding/asn1:
Walking from GO.link/src to GO.link/src/encoding/base32
Processing encoding/base32:
Ignoring test code in base32_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/base32/base32.go) => true <nil>
Processing package=encoding/base32:
Walking from GO.link/src to GO.link/src/encoding/base64
Processing encoding/base64:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/base64/base64.go) => true <nil>
Ignoring test code in base64_test.go
Processing package=encoding/base64:
Walking from GO.link/src to GO.link/src/encoding/binary
Processing encoding/binary:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in binary_test.go
Ignoring test code in varint_test.go
Matchfile(GO.link/src/encoding/binary/varint.go) => true <nil>
Processing package=encoding/binary:
Walking from GO.link/src to GO.link/src/encoding/csv
Processing encoding/csv:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/encoding/csv/writer.go) => true <nil>
Matchfile(GO.link/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=encoding/csv:
Walking from GO.link/src to GO.link/src/encoding/gob
Processing encoding/gob:
Ignoring test code in timing_test.go
Matchfile(GO.link/src/encoding/gob/decgen.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/encode.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/error.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in gobencdec_test.go
Matchfile(GO.link/src/encoding/gob/decoder.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/dec_helpers.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/encoder.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(GO.link/src/encoding/gob/type.go) => true <nil>
Ignoring test code in codec_test.go
Matchfile(GO.link/src/encoding/gob/debug.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/doc.go) => true <nil>
Ignoring test code in type_test.go
Ignoring test code in encoder_test.go
Matchfile(GO.link/src/encoding/gob/dump.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/enc_helpers.go) => true <nil>
Ignoring test code in example_encdec_test.go
Matchfile(GO.link/src/encoding/gob/decode.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/encgen.go) => false <nil>
Processing package=encoding/gob:
Walking from GO.link/src to GO.link/src/encoding/hex
Processing encoding/hex:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/hex/hex.go) => true <nil>
Ignoring test code in hex_test.go
Processing package=encoding/hex:
Walking from GO.link/src to GO.link/src/encoding/json
Processing encoding/json:
Ignoring test code in decode_test.go
Matchfile(GO.link/src/encoding/json/encode.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in tagkey_test.go
Matchfile(GO.link/src/encoding/json/tags.go) => true <nil>
Matchfile(GO.link/src/encoding/json/stream.go) => true <nil>
Ignoring test code in tags_test.go
Ignoring test code in fold_test.go
Matchfile(GO.link/src/encoding/json/tables.go) => true <nil>
Ignoring test code in number_test.go
Ignoring test code in stream_test.go
Matchfile(GO.link/src/encoding/json/indent.go) => true <nil>
Ignoring test code in bench_test.go
Ignoring test code in example_marshaling_test.go
Matchfile(GO.link/src/encoding/json/fold.go) => true <nil>
Matchfile(GO.link/src/encoding/json/decode.go) => true <nil>
Ignoring test code in scanner_test.go
Ignoring test code in encode_test.go
Processing package=encoding/json:
Excluding GO.link/src/encoding/json/testdata
Walking from GO.link/src to GO.link/src/encoding/pem
Processing encoding/pem:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/pem/pem.go) => true <nil>
Ignoring test code in pem_test.go
Processing package=encoding/pem:
Walking from GO.link/src to GO.link/src/encoding/xml
Processing encoding/xml:
Ignoring test code in read_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/xml/marshal.go) => true <nil>
Matchfile(GO.link/src/encoding/xml/typeinfo.go) => true <nil>
Matchfile(GO.link/src/encoding/xml/xml.go) => true <nil>
Ignoring test code in atom_test.go
Matchfile(GO.link/src/encoding/xml/read.go) => true <nil>
Ignoring test code in xml_test.go
Ignoring test code in marshal_test.go
Processing package=encoding/xml:
Walking from GO.link/src to GO.link/src/errors
Processing errors:
Ignoring test code in example_test.go
Ignoring test code in errors_test.go
Matchfile(GO.link/src/errors/errors.go) => true <nil>
Processing package=errors:
Walking from GO.link/src to GO.link/src/expvar
Processing expvar:
Ignoring test code in expvar_test.go
Matchfile(GO.link/src/expvar/expvar.go) => true <nil>
Processing package=expvar:
Walking from GO.link/src to GO.link/src/flag
Processing flag:
Ignoring test code in example_test.go
Matchfile(GO.link/src/flag/flag.go) => true <nil>
Ignoring test code in flag_test.go
Ignoring test code in export_test.go
Ignoring test code in example_value_test.go
Processing package=flag:
Walking from GO.link/src to GO.link/src/fmt
Processing fmt:
Ignoring test code in example_test.go
Ignoring test code in fmt_test.go
Matchfile(GO.link/src/fmt/format.go) => true <nil>
Matchfile(GO.link/src/fmt/scan.go) => true <nil>
Matchfile(GO.link/src/fmt/doc.go) => true <nil>
Matchfile(GO.link/src/fmt/print.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in stringer_test.go
Ignoring test code in scan_test.go
Processing package=fmt:
Walking from GO.link/src to GO.link/src/go
Processing go:
Walking from GO.link/src to GO.link/src/go/ast
Processing go/ast:
Matchfile(GO.link/src/go/ast/resolve.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in filter_test.go
Matchfile(GO.link/src/go/ast/import.go) => true <nil>
Ignoring test code in ast_test.go
Matchfile(GO.link/src/go/ast/filter.go) => true <nil>
Matchfile(GO.link/src/go/ast/ast.go) => true <nil>
Matchfile(GO.link/src/go/ast/print.go) => true <nil>
Ignoring test code in commentmap_test.go
Matchfile(GO.link/src/go/ast/walk.go) => true <nil>
Ignoring test code in print_test.go
Matchfile(GO.link/src/go/ast/scope.go) => true <nil>
Matchfile(GO.link/src/go/ast/commentmap.go) => true <nil>
Processing package=go/ast:
Walking from GO.link/src to GO.link/src/go/build
Processing go/build:
Matchfile(GO.link/src/go/build/zcgo.go) => true <nil>
Matchfile(GO.link/src/go/build/gc.go) => true <nil>
Ignoring test code in read_test.go
Matchfile(GO.link/src/go/build/build.go) => true <nil>
Matchfile(GO.link/src/go/build/syslist.go) => true <nil>
Ignoring test code in build_test.go
Ignoring test code in syslist_test.go
Matchfile(GO.link/src/go/build/gccgo.go) => false <nil>
Matchfile(GO.link/src/go/build/doc.go) => true <nil>
Ignoring test code in deps_test.go
Matchfile(GO.link/src/go/build/read.go) => true <nil>
Processing package=go/build:
Excluding GO.link/src/go/build/testdata
Walking from GO.link/src to GO.link/src/go/constant
Processing go/constant:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(GO.link/src/go/constant/value.go) => true <nil>
Processing package=go/constant:
Walking from GO.link/src to GO.link/src/go/doc
Processing go/doc:
Ignoring test code in comment_test.go
Ignoring test code in example_test.go
Ignoring test code in synopsis_test.go
Matchfile(GO.link/src/go/doc/comment.go) => true <nil>
Matchfile(GO.link/src/go/doc/exports.go) => true <nil>
Matchfile(GO.link/src/go/doc/headscan.go) => false <nil>
Matchfile(GO.link/src/go/doc/synopsis.go) => true <nil>
Ignoring test code in doc_test.go
Matchfile(GO.link/src/go/doc/filter.go) => true <nil>
Matchfile(GO.link/src/go/doc/doc.go) => true <nil>
Matchfile(GO.link/src/go/doc/example.go) => true <nil>
Matchfile(GO.link/src/go/doc/reader.go) => true <nil>
Processing package=go/doc:
Excluding GO.link/src/go/doc/testdata
Walking from GO.link/src to GO.link/src/go/format
Processing go/format:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/format/internal.go) => true <nil>
Ignoring test code in format_test.go
Matchfile(GO.link/src/go/format/format.go) => true <nil>
Processing package=go/format:
Walking from GO.link/src to GO.link/src/go/importer
Processing go/importer:
Matchfile(GO.link/src/go/importer/importer.go) => true <nil>
Ignoring test code in importer_test.go
Processing package=go/importer:
Excluding GO.link/src/go/internal
Walking from GO.link/src to GO.link/src/go/parser
Processing go/parser:
Ignoring test code in example_test.go
Ignoring test code in parser_test.go
Matchfile(GO.link/src/go/parser/interface.go) => true <nil>
Ignoring test code in short_test.go
Ignoring test code in performance_test.go
Matchfile(GO.link/src/go/parser/parser.go) => true <nil>
Ignoring test code in error_test.go
Processing package=go/parser:
Excluding GO.link/src/go/parser/testdata
Walking from GO.link/src to GO.link/src/go/printer
Processing go/printer:
Ignoring test code in example_test.go
Ignoring test code in printer_test.go
Ignoring test code in performance_test.go
Matchfile(GO.link/src/go/printer/printer.go) => true <nil>
Matchfile(GO.link/src/go/printer/nodes.go) => true <nil>
Processing package=go/printer:
Excluding GO.link/src/go/printer/testdata
Walking from GO.link/src to GO.link/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(GO.link/src/go/scanner/errors.go) => true <nil>
Processing package=go/scanner:
Walking from GO.link/src to GO.link/src/go/token
Processing go/token:
Ignoring test code in serialize_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/token/token.go) => true <nil>
Matchfile(GO.link/src/go/token/serialize.go) => true <nil>
Ignoring test code in position_test.go
Matchfile(GO.link/src/go/token/position.go) => true <nil>
Processing package=go/token:
Walking from GO.link/src to GO.link/src/go/types
Processing go/types:
Matchfile(GO.link/src/go/types/object.go) => true <nil>
Ignoring test code in check_test.go
Matchfile(GO.link/src/go/types/check.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in exprstring_test.go
Matchfile(GO.link/src/go/types/methodset.go) => true <nil>
Matchfile(GO.link/src/go/types/predicates.go) => true <nil>
Matchfile(GO.link/src/go/types/labels.go) => true <nil>
Matchfile(GO.link/src/go/types/interfaces.go) => true <nil>
Ignoring test code in stdlib_test.go
Ignoring test code in builtins_test.go
Ignoring test code in sizes_test.go
Matchfile(GO.link/src/go/types/package.go) => true <nil>
Matchfile(GO.link/src/go/types/sizes.go) => true <nil>
Matchfile(GO.link/src/go/types/type.go) => true <nil>
Ignoring test code in issues_test.go
Ignoring test code in resolver_test.go
Matchfile(GO.link/src/go/types/lookup.go) => true <nil>
Matchfile(GO.link/src/go/types/typestring.go) => true <nil>
Matchfile(GO.link/src/go/types/stmt.go) => true <nil>
Matchfile(GO.link/src/go/types/typexpr.go) => true <nil>
Matchfile(GO.link/src/go/types/conversions.go) => true <nil>
Matchfile(GO.link/src/go/types/operand.go) => true <nil>
Matchfile(GO.link/src/go/types/builtins.go) => true <nil>
Matchfile(GO.link/src/go/types/initorder.go) => true <nil>
Matchfile(GO.link/src/go/types/resolver.go) => true <nil>
Ignoring test code in token_test.go
Ignoring test code in eval_test.go
Ignoring test code in self_test.go
Matchfile(GO.link/src/go/types/universe.go) => true <nil>
Matchfile(GO.link/src/go/types/api.go) => true <nil>
Matchfile(GO.link/src/go/types/exprstring.go) => true <nil>
Matchfile(GO.link/src/go/types/assignments.go) => true <nil>
Ignoring test code in hilbert_test.go
Matchfile(GO.link/src/go/types/expr.go) => true <nil>
Ignoring test code in typestring_test.go
Matchfile(GO.link/src/go/types/scope.go) => true <nil>
Matchfile(GO.link/src/go/types/objset.go) => true <nil>
Matchfile(GO.link/src/go/types/return.go) => true <nil>
Matchfile(GO.link/src/go/types/decl.go) => true <nil>
Ignoring test code in api_test.go
Matchfile(GO.link/src/go/types/call.go) => true <nil>
Matchfile(GO.link/src/go/types/eval.go) => true <nil>
Matchfile(GO.link/src/go/types/selection.go) => true <nil>
Matchfile(GO.link/src/go/types/errors.go) => true <nil>
Ignoring test code in object_test.go
Matchfile(GO.link/src/go/types/gotype.go) => false <nil>
Processing package=go/types:
Excluding GO.link/src/go/types/testdata
Walking from GO.link/src to GO.link/src/hash
Processing hash:
Ignoring test code in example_test.go
Matchfile(GO.link/src/hash/hash.go) => true <nil>
Ignoring test code in marshal_test.go
Processing package=hash:
Walking from GO.link/src to GO.link/src/hash/adler32
Processing hash/adler32:
Matchfile(GO.link/src/hash/adler32/adler32.go) => true <nil>
Ignoring test code in adler32_test.go
Processing package=hash/adler32:
Walking from GO.link/src to GO.link/src/hash/crc32
Processing hash/crc32:
Matchfile(GO.link/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_amd64.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/hash/crc32/crc32_otherarch.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32.go) => true <nil>
Ignoring test code in crc32_test.go
Matchfile(GO.link/src/hash/crc32/crc32_arm64.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_generic.go) => true <nil>
Matchfile(GO.link/src/hash/crc32/crc32_s390x.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Processing package=hash/crc32:
Walking from GO.link/src to GO.link/src/hash/crc64
Processing hash/crc64:
Ignoring test code in crc64_test.go
Matchfile(GO.link/src/hash/crc64/crc64.go) => true <nil>
Processing package=hash/crc64:
Walking from GO.link/src to GO.link/src/hash/fnv
Processing hash/fnv:
Matchfile(GO.link/src/hash/fnv/fnv.go) => true <nil>
Ignoring test code in fnv_test.go
Processing package=hash/fnv:
Walking from GO.link/src to GO.link/src/html
Processing html:
Ignoring test code in example_test.go
Matchfile(GO.link/src/html/escape.go) => true <nil>
Matchfile(GO.link/src/html/entity.go) => true <nil>
Ignoring test code in entity_test.go
Ignoring test code in escape_test.go
Processing package=html:
Walking from GO.link/src to GO.link/src/html/template
Processing html/template:
Ignoring test code in clone_test.go
Matchfile(GO.link/src/html/template/error.go) => true <nil>
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in content_test.go
Matchfile(GO.link/src/html/template/escape.go) => true <nil>
Ignoring test code in transition_test.go
Ignoring test code in js_test.go
Matchfile(GO.link/src/html/template/element_string.go) => true <nil>
Matchfile(GO.link/src/html/template/urlpart_string.go) => true <nil>
Matchfile(GO.link/src/html/template/transition.go) => true <nil>
Ignoring test code in css_test.go
Ignoring test code in template_test.go
Matchfile(GO.link/src/html/template/html.go) => true <nil>
Matchfile(GO.link/src/html/template/state_string.go) => true <nil>
Matchfile(GO.link/src/html/template/js.go) => true <nil>
Ignoring test code in html_test.go
Matchfile(GO.link/src/html/template/delim_string.go) => true <nil>
Matchfile(GO.link/src/html/template/template.go) => true <nil>
Matchfile(GO.link/src/html/template/doc.go) => true <nil>
Matchfile(GO.link/src/html/template/context.go) => true <nil>
Matchfile(GO.link/src/html/template/attr_string.go) => true <nil>
Matchfile(GO.link/src/html/template/content.go) => true <nil>
Matchfile(GO.link/src/html/template/css.go) => true <nil>
Matchfile(GO.link/src/html/template/url.go) => true <nil>
Ignoring test code in escape_test.go
Matchfile(GO.link/src/html/template/attr.go) => true <nil>
Ignoring test code in url_test.go
Matchfile(GO.link/src/html/template/jsctx_string.go) => true <nil>
Processing package=html/template:
Walking from GO.link/src to GO.link/src/image
Processing image:
Ignoring test code in geom_test.go
Ignoring test code in decode_test.go
Matchfile(GO.link/src/image/format.go) => true <nil>
Matchfile(GO.link/src/image/geom.go) => true <nil>
Ignoring test code in ycbcr_test.go
Ignoring test code in image_test.go
Matchfile(GO.link/src/image/names.go) => true <nil>
Matchfile(GO.link/src/image/image.go) => true <nil>
Matchfile(GO.link/src/image/ycbcr.go) => true <nil>
Ignoring test code in decode_example_test.go
Processing package=image:
Walking from GO.link/src to GO.link/src/image/color
Processing image/color:
Matchfile(GO.link/src/image/color/color.go) => true <nil>
Ignoring test code in color_test.go
Ignoring test code in ycbcr_test.go
Matchfile(GO.link/src/image/color/ycbcr.go) => true <nil>
Processing package=image/color:
Walking from GO.link/src to GO.link/src/image/color/palette
Processing image/color/palette:
Matchfile(GO.link/src/image/color/palette/generate.go) => true <nil>
Matchfile(GO.link/src/image/color/palette/gen.go) => false <nil>
Matchfile(GO.link/src/image/color/palette/palette.go) => true <nil>
Processing package=image/color/palette:
Walking from GO.link/src to GO.link/src/image/draw
Processing image/draw:
Ignoring test code in draw_test.go
Ignoring test code in example_test.go
Ignoring test code in clip_test.go
Ignoring test code in bench_test.go
Matchfile(GO.link/src/image/draw/draw.go) => true <nil>
Processing package=image/draw:
Walking from GO.link/src to GO.link/src/image/gif
Processing image/gif:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/gif/writer.go) => true <nil>
Matchfile(GO.link/src/image/gif/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=image/gif:
Excluding GO.link/src/image/internal
Walking from GO.link/src to GO.link/src/image/jpeg
Processing image/jpeg:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/jpeg/huffman.go) => true <nil>
Ignoring test code in dct_test.go
Matchfile(GO.link/src/image/jpeg/idct.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/scan.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/writer.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/image/jpeg/fdct.go) => true <nil>
Processing package=image/jpeg:
Walking from GO.link/src to GO.link/src/image/png
Processing image/png:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in paeth_test.go
Matchfile(GO.link/src/image/png/writer.go) => true <nil>
Matchfile(GO.link/src/image/png/paeth.go) => true <nil>
Matchfile(GO.link/src/image/png/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=image/png:
Excluding GO.link/src/image/png/testdata
Excluding GO.link/src/image/testdata
Walking from GO.link/src to GO.link/src/index
Processing index:
Walking from GO.link/src to GO.link/src/index/suffixarray
Processing index/suffixarray:
Ignoring test code in example_test.go
Ignoring test code in suffixarray_test.go
Matchfile(GO.link/src/index/suffixarray/suffixarray.go) => true <nil>
Matchfile(GO.link/src/index/suffixarray/qsufsort.go) => true <nil>
Processing package=index/suffixarray:
Excluding GO.link/src/internal
Walking from GO.link/src to GO.link/src/io
Processing io:
Ignoring test code in example_test.go
Ignoring test code in multi_test.go
Matchfile(GO.link/src/io/io.go) => true <nil>
Matchfile(GO.link/src/io/multi.go) => true <nil>
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/io/pipe.go) => true <nil>
Ignoring test code in io_test.go
Processing package=io:
Walking from GO.link/src to GO.link/src/io/ioutil
Processing io/ioutil:
Ignoring test code in example_test.go
Matchfile(GO.link/src/io/ioutil/tempfile.go) => true <nil>
Matchfile(GO.link/src/io/ioutil/ioutil.go) => true <nil>
Ignoring test code in ioutil_test.go
Ignoring test code in tempfile_test.go
Processing package=io/ioutil:
Excluding GO.link/src/io/ioutil/testdata
Walking from GO.link/src to GO.link/src/log
Processing log:
Matchfile(GO.link/src/log/log.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in log_test.go
Processing package=log:
Walking from GO.link/src to GO.link/src/log/syslog
Processing log/syslog:
Ignoring test code in example_test.go
Matchfile(GO.link/src/log/syslog/syslog.go) => true <nil>
Matchfile(GO.link/src/log/syslog/doc.go) => true <nil>
Ignoring test code in syslog_test.go
Matchfile(GO.link/src/log/syslog/syslog_unix.go) => true <nil>
Processing package=log/syslog:
Walking from GO.link/src to GO.link/src/math
Processing math:
Matchfile(GO.link/src/math/arith_s390x.go) => false <nil>
Matchfile(GO.link/src/math/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/log.go) => true <nil>
Matchfile(GO.link/src/math/hypot.go) => true <nil>
Matchfile(GO.link/src/math/logb.go) => true <nil>
Matchfile(GO.link/src/math/nextafter.go) => true <nil>
Matchfile(GO.link/src/math/exp_asm.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/signbit.go) => true <nil>
Matchfile(GO.link/src/math/tanh.go) => true <nil>
Matchfile(GO.link/src/math/pow.go) => true <nil>
Matchfile(GO.link/src/math/acosh.go) => true <nil>
Matchfile(GO.link/src/math/bits.go) => true <nil>
Matchfile(GO.link/src/math/asinh.go) => true <nil>
Matchfile(GO.link/src/math/copysign.go) => true <nil>
Matchfile(GO.link/src/math/jn.go) => true <nil>
Matchfile(GO.link/src/math/erf.go) => true <nil>
Matchfile(GO.link/src/math/floor.go) => true <nil>
Matchfile(GO.link/src/math/modf.go) => true <nil>
Matchfile(GO.link/src/math/ldexp.go) => true <nil>
Matchfile(GO.link/src/math/abs.go) => true <nil>
Matchfile(GO.link/src/math/tan.go) => true <nil>
Matchfile(GO.link/src/math/atan2.go) => true <nil>
Matchfile(GO.link/src/math/asin.go) => true <nil>
Matchfile(GO.link/src/math/remainder.go) => true <nil>
Matchfile(GO.link/src/math/pow10.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/math/expm1.go) => true <nil>
Matchfile(GO.link/src/math/unsafe.go) => true <nil>
Matchfile(GO.link/src/math/sincos_386.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/math/frexp.go) => true <nil>
Matchfile(GO.link/src/math/log10.go) => true <nil>
Matchfile(GO.link/src/math/sincos.go) => true <nil>
Matchfile(GO.link/src/math/const.go) => true <nil>
Matchfile(GO.link/src/math/gamma.go) => true <nil>
Matchfile(GO.link/src/math/sin.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(GO.link/src/math/atanh.go) => true <nil>
Matchfile(GO.link/src/math/cbrt.go) => true <nil>
Matchfile(GO.link/src/math/log1p.go) => true <nil>
Matchfile(GO.link/src/math/atan.go) => true <nil>
Matchfile(GO.link/src/math/mod.go) => true <nil>
Matchfile(GO.link/src/math/j1.go) => true <nil>
Matchfile(GO.link/src/math/exp.go) => true <nil>
Matchfile(GO.link/src/math/sinh.go) => true <nil>
Ignoring test code in export_s390x_test.go
Matchfile(GO.link/src/math/erfinv.go) => true <nil>
Matchfile(GO.link/src/math/j0.go) => true <nil>
Matchfile(GO.link/src/math/dim.go) => true <nil>
Matchfile(GO.link/src/math/lgamma.go) => true <nil>
Processing package=math:
Walking from GO.link/src to GO.link/src/math/big
Processing math/big:
Matchfile(GO.link/src/math/big/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/big/natconv.go) => true <nil>
Matchfile(GO.link/src/math/big/ratmarsh.go) => true <nil>
Ignoring test code in int_test.go
Ignoring test code in ratconv_test.go
Ignoring test code in example_test.go
Ignoring test code in rat_test.go
Matchfile(GO.link/src/math/big/intmarsh.go) => true <nil>
Matchfile(GO.link/src/math/big/prime.go) => true <nil>
Matchfile(GO.link/src/math/big/ftoa.go) => true <nil>
Matchfile(GO.link/src/math/big/roundingmode_string.go) => true <nil>
Ignoring test code in float_test.go
Ignoring test code in ratmarsh_test.go
Matchfile(GO.link/src/math/big/floatmarsh.go) => true <nil>
Ignoring test code in natconv_test.go
Ignoring test code in sqrt_test.go
Ignoring test code in intmarsh_test.go
Matchfile(GO.link/src/math/big/decimal.go) => true <nil>
Matchfile(GO.link/src/math/big/nat.go) => true <nil>
Ignoring test code in gcd_test.go
Ignoring test code in floatmarsh_test.go
Matchfile(GO.link/src/math/big/arith_decl_pure.go) => false <nil>
Matchfile(GO.link/src/math/big/arith_decl_s390x.go) => false <nil>
Matchfile(GO.link/src/math/big/arith_decl.go) => true <nil>
Matchfile(GO.link/src/math/big/float.go) => true <nil>
Ignoring test code in calibrate_test.go
Matchfile(GO.link/src/math/big/arith.go) => true <nil>
Matchfile(GO.link/src/math/big/ratconv.go) => true <nil>
Matchfile(GO.link/src/math/big/arith_amd64.go) => true <nil>
Ignoring test code in floatconv_test.go
Matchfile(GO.link/src/math/big/doc.go) => true <nil>
Ignoring test code in nat_test.go
Ignoring test code in floatexample_test.go
Ignoring test code in prime_test.go
Ignoring test code in arith_test.go
Ignoring test code in hilbert_test.go
Ignoring test code in arith_s390x_test.go
Ignoring test code in decimal_test.go
Matchfile(GO.link/src/math/big/int.go) => true <nil>
Matchfile(GO.link/src/math/big/intconv.go) => true <nil>
Matchfile(GO.link/src/math/big/accuracy_string.go) => true <nil>
Ignoring test code in example_rat_test.go
Matchfile(GO.link/src/math/big/rat.go) => true <nil>
Ignoring test code in intconv_test.go
Matchfile(GO.link/src/math/big/floatconv.go) => true <nil>
Ignoring test code in bits_test.go
Processing package=math/big:
Walking from GO.link/src to GO.link/src/math/bits
Processing math/bits:
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/bits/bits.go) => true <nil>
Matchfile(GO.link/src/math/bits/bits_tables.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/math/bits/make_examples.go) => false <nil>
Matchfile(GO.link/src/math/bits/make_tables.go) => false <nil>
Ignoring test code in bits_test.go
Processing package=math/bits:
Walking from GO.link/src to GO.link/src/math/cmplx
Processing math/cmplx:
Matchfile(GO.link/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/log.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isnan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isinf.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/cmplx/pow.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/phase.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/polar.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/rect.go) => true <nil>
Ignoring test code in cmath_test.go
Matchfile(GO.link/src/math/cmplx/abs.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/tan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/asin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/sin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/exp.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/conj.go) => true <nil>
Processing package=math/cmplx:
Walking from GO.link/src to GO.link/src/math/rand
Processing math/rand:
Matchfile(GO.link/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in race_test.go
Ignoring test code in rand_test.go
Matchfile(GO.link/src/math/rand/rng.go) => true <nil>
Matchfile(GO.link/src/math/rand/normal.go) => true <nil>
Ignoring test code in regress_test.go
Matchfile(GO.link/src/math/rand/rand.go) => true <nil>
Matchfile(GO.link/src/math/rand/exp.go) => true <nil>
Matchfile(GO.link/src/math/rand/zipf.go) => true <nil>
Processing package=math/rand:
Walking from GO.link/src to GO.link/src/mime
Processing mime:
Ignoring test code in encodedword_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/mime/type_windows.go) => false <nil>
Matchfile(GO.link/src/mime/grammar.go) => true <nil>
Matchfile(GO.link/src/mime/type.go) => true <nil>
Matchfile(GO.link/src/mime/type_plan9.go) => false <nil>
Ignoring test code in mediatype_test.go
Matchfile(GO.link/src/mime/mediatype.go) => true <nil>
Matchfile(GO.link/src/mime/encodedword.go) => true <nil>
Matchfile(GO.link/src/mime/type_freebsd.go) => false <nil>
Ignoring test code in type_test.go
Matchfile(GO.link/src/mime/type_unix.go) => true <nil>
Matchfile(GO.link/src/mime/type_dragonfly.go) => false <nil>
Matchfile(GO.link/src/mime/type_openbsd.go) => false <nil>
Processing package=mime:
Walking from GO.link/src to GO.link/src/mime/multipart
Processing mime/multipart:
Ignoring test code in example_test.go
Ignoring test code in multipart_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/multipart/multipart.go) => true <nil>
Matchfile(GO.link/src/mime/multipart/writer.go) => true <nil>
Matchfile(GO.link/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in formdata_test.go
Processing package=mime/multipart:
Excluding GO.link/src/mime/multipart/testdata
Walking from GO.link/src to GO.link/src/mime/quotedprintable
Processing mime/quotedprintable:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/quotedprintable/writer.go) => true <nil>
Matchfile(GO.link/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=mime/quotedprintable:
Excluding GO.link/src/mime/testdata
Walking from GO.link/src to GO.link/src/net
Processing net:
Matchfile(GO.link/src/net/fd_windows.go) => false <nil>
Ignoring test code in ipsock_test.go
Matchfile(GO.link/src/net/fd_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(GO.link/src/net/cgo_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_solaris.go) => false <nil>
Matchfile(GO.link/src/net/fd_unix.go) => true <nil>
Matchfile(GO.link/src/net/error_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_stub.go) => false <nil>
Ignoring test code in mac_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in lookup_test.go
Matchfile(GO.link/src/net/sockoptip_stub.go) => false <nil>
Matchfile(GO.link/src/net/sock_cloexec.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Matchfile(GO.link/src/net/error_windows.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_unix.go) => false <nil>
Matchfile(GO.link/src/net/sockaddr_posix.go) => true <nil>
Ignoring test code in dnsclient_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/interface_freebsd.go) => false <nil>
Ignoring test code in iprawsock_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(GO.link/src/net/cgo_socknew.go) => false <nil>
Matchfile(GO.link/src/net/error_nacl.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_windows.go) => false <nil>
Matchfile(GO.link/src/net/udpsock.go) => true <nil>
Matchfile(GO.link/src/net/udpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sock_linux.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_linux.go) => false <nil>
Ignoring test code in hosts_test.go
Matchfile(GO.link/src/net/cgo_resold.go) => false <nil>
Matchfile(GO.link/src/net/splice_linux.go) => false <nil>
Ignoring test code in main_windows_test.go
Matchfile(GO.link/src/net/unixsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/rawconn.go) => true <nil>
Matchfile(GO.link/src/net/hook_windows.go) => false <nil>
Ignoring test code in interface_test.go
Matchfile(GO.link/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_linux.go) => false <nil>
Matchfile(GO.link/src/net/cgo_android.go) => false <nil>
Matchfile(GO.link/src/net/addrselect.go) => true <nil>
Matchfile(GO.link/src/net/net_fake.go) => false <nil>
Ignoring test code in interface_bsd_test.go
Matchfile(GO.link/src/net/file_unix.go) => true <nil>
Matchfile(GO.link/src/net/interface_plan9.go) => false <nil>
Matchfile(GO.link/src/net/port.go) => true <nil>
Matchfile(GO.link/src/net/sock_posix.go) => true <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(GO.link/src/net/sockopt_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_stub.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(GO.link/src/net/lookup_unix.go) => true <nil>
Matchfile(GO.link/src/net/dnsclient_unix.go) => true <nil>
Ignoring test code in rawconn_windows_test.go
Ignoring test code in error_plan9_test.go
Matchfile(GO.link/src/net/lookup_windows.go) => false <nil>
Ignoring test code in timeout_test.go
Matchfile(GO.link/src/net/dnsconfig_unix.go) => true <nil>
Ignoring test code in dial_test.go
Matchfile(GO.link/src/net/hosts.go) => true <nil>
Matchfile(GO.link/src/net/lookup_fake.go) => false <nil>
Matchfile(GO.link/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in error_unix_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in platform_test.go
Matchfile(GO.link/src/net/sock_stub.go) => false <nil>
Matchfile(GO.link/src/net/error_posix.go) => true <nil>
Matchfile(GO.link/src/net/hook.go) => true <nil>
Matchfile(GO.link/src/net/ipsock.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in parse_test.go
Matchfile(GO.link/src/net/iprawsock.go) => true <nil>
Matchfile(GO.link/src/net/sock_windows.go) => false <nil>
Matchfile(GO.link/src/net/net.go) => true <nil>
Ignoring test code in error_posix_test.go
Matchfile(GO.link/src/net/lookup.go) => true <nil>
Matchfile(GO.link/src/net/interface.go) => true <nil>
Matchfile(GO.link/src/net/sys_cloexec.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/net/conf.go) => true <nil>
Matchfile(GO.link/src/net/sockopt_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_windows.go) => false <nil>
Matchfile(GO.link/src/net/splice_stub.go) => true <nil>
Matchfile(GO.link/src/net/sock_plan9.go) => false <nil>
Ignoring test code in interface_linux_test.go
Ignoring test code in net_test.go
Matchfile(GO.link/src/net/udpsock_posix.go) => true <nil>
Ignoring test code in packetconn_test.go
Matchfile(GO.link/src/net/sockopt_linux.go) => false <nil>
Matchfile(GO.link/src/net/tcpsock_posix.go) => true <nil>
Ignoring test code in nss_test.go
Matchfile(GO.link/src/net/sendfile_windows.go) => false <nil>
Matchfile(GO.link/src/net/interface_linux.go) => false <nil>
Matchfile(GO.link/src/net/iprawsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/unixsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_bsd.go) => true <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in main_posix_test.go
Matchfile(GO.link/src/net/interface_windows.go) => false <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(GO.link/src/net/file_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in port_test.go
Matchfile(GO.link/src/net/dnsclient.go) => true <nil>
Matchfile(GO.link/src/net/error_unix.go) => true <nil>
Ignoring test code in error_windows_test.go
Matchfile(GO.link/src/net/tcpsockopt_posix.go) => true <nil>
Ignoring test code in conf_test.go
Matchfile(GO.link/src/net/ip.go) => true <nil>
Matchfile(GO.link/src/net/nss.go) => true <nil>
Matchfile(GO.link/src/net/ipsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_bsd.go) => true <nil>
Matchfile(GO.link/src/net/cgo_sockold.go) => true <nil>
Ignoring test code in sendfile_test.go
Matchfile(GO.link/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(GO.link/src/net/writev_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_netbsd.go) => false <nil>
Matchfile(GO.link/src/net/file.go) => true <nil>
Matchfile(GO.link/src/net/interface_bsd.go) => true <nil>
Ignoring test code in ip_test.go
Ignoring test code in main_plan9_test.go
Matchfile(GO.link/src/net/cgo_resnew.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(GO.link/src/net/sockopt_solaris.go) => false <nil>
Matchfile(GO.link/src/net/interface_stub.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(GO.link/src/net/tcpsock.go) => true <nil>
Matchfile(GO.link/src/net/hook_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in main_conf_test.go
Matchfile(GO.link/src/net/cgo_openbsd.go) => false <nil>
Ignoring test code in rawconn_unix_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in external_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in pipe_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in net_windows_test.go
Matchfile(GO.link/src/net/port_unix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_stub.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(GO.link/src/net/mac.go) => true <nil>
Ignoring test code in unixsock_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in error_test.go
Matchfile(GO.link/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_linux.go) => false <nil>
Matchfile(GO.link/src/net/unixsock.go) => true <nil>
Matchfile(GO.link/src/net/lookup_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_windows.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_posix.go) => true <nil>
Matchfile(GO.link/src/net/sockoptip_bsdvar.go) => true <nil>
Matchfile(GO.link/src/net/pipe.go) => true <nil>
Matchfile(GO.link/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(GO.link/src/net/hook_unix.go) => true <nil>
Matchfile(GO.link/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_darwin.go) => true <nil>
Ignoring test code in udpsock_test.go
Matchfile(GO.link/src/net/interface_solaris.go) => false <nil>
Ignoring test code in listen_test.go
Matchfile(GO.link/src/net/sock_bsd.go) => true <nil>
Matchfile(GO.link/src/net/interface_darwin.go) => true <nil>
Matchfile(GO.link/src/net/dial.go) => true <nil>
Ignoring test code in server_test.go
Matchfile(GO.link/src/net/file_windows.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in addrselect_test.go
Matchfile(GO.link/src/net/ipsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/parse.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Matchfile(GO.link/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in main_test.go
Ignoring test code in dnsclient_unix_test.go
Matchfile(GO.link/src/net/file_stub.go) => false <nil>
Processing package=net:
Walking from GO.link/src to GO.link/src/net/http
Processing net/http:
Matchfile(GO.link/src/net/http/jar.go) => true <nil>
Ignoring test code in cookie_test.go
Matchfile(GO.link/src/net/http/transport.go) => true <nil>
Matchfile(GO.link/src/net/http/header.go) => true <nil>
Ignoring test code in requestwrite_test.go
Ignoring test code in range_test.go
Ignoring test code in example_test.go
Ignoring test code in transfer_test.go
Matchfile(GO.link/src/net/http/server.go) => true <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in fs_test.go
Ignoring test code in http_test.go
Matchfile(GO.link/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in header_test.go
Matchfile(GO.link/src/net/http/response.go) => true <nil>
Ignoring test code in request_test.go
Matchfile(GO.link/src/net/http/request.go) => true <nil>
Ignoring test code in serve_test.go
Ignoring test code in response_test.go
Matchfile(GO.link/src/net/http/client.go) => true <nil>
Matchfile(GO.link/src/net/http/race.go) => false <nil>
Matchfile(GO.link/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in responsewrite_test.go
Matchfile(GO.link/src/net/http/method.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(GO.link/src/net/http/http.go) => true <nil>
Ignoring test code in filetransport_test.go
Matchfile(GO.link/src/net/http/doc.go) => true <nil>
Matchfile(GO.link/src/net/http/fs.go) => true <nil>
Matchfile(GO.link/src/net/http/triv.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/net/http/transfer.go) => true <nil>
Matchfile(GO.link/src/net/http/cookie.go) => true <nil>
Ignoring test code in proxy_test.go
Matchfile(GO.link/src/net/http/sniff.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(GO.link/src/net/http/status.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in client_test.go
Matchfile(GO.link/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in npn_test.go
Ignoring test code in readrequest_test.go
Matchfile(GO.link/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in main_test.go
Matchfile(GO.link/src/net/http/filetransport.go) => true <nil>
Processing package=net/http:
Walking from GO.link/src to GO.link/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in plan9_test.go
Ignoring test code in child_test.go
Ignoring test code in posix_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Matchfile(GO.link/src/net/http/cgi/host.go) => true <nil>
Matchfile(GO.link/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding GO.link/src/net/http/cgi/testdata
Walking from GO.link/src to GO.link/src/net/http/cookiejar
Processing net/http/cookiejar:
Matchfile(GO.link/src/net/http/cookiejar/jar.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Processing package=net/http/cookiejar:
Walking from GO.link/src to GO.link/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(GO.link/src/net/http/fcgi/child.go) => true <nil>
Matchfile(GO.link/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Processing package=net/http/fcgi:
Walking from GO.link/src to GO.link/src/net/http/httptest
Processing net/http/httptest:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httptest/server.go) => true <nil>
Matchfile(GO.link/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in httptest_test.go
Matchfile(GO.link/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in recorder_test.go
Ignoring test code in server_test.go
Processing package=net/http/httptest:
Walking from GO.link/src to GO.link/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httptrace/trace.go) => true <nil>
Processing package=net/http/httptrace:
Walking from GO.link/src to GO.link/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(GO.link/src/net/http/httputil/persist.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(GO.link/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(GO.link/src/net/http/httputil/reverseproxy.go) => true <nil>
Processing package=net/http/httputil:
Excluding GO.link/src/net/http/internal
Walking from GO.link/src to GO.link/src/net/http/pprof
Processing net/http/pprof:
Matchfile(GO.link/src/net/http/pprof/pprof.go) => true <nil>
Ignoring test code in pprof_test.go
Processing package=net/http/pprof:
Excluding GO.link/src/net/http/testdata
Excluding GO.link/src/net/internal
Walking from GO.link/src to GO.link/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/mail/message.go) => true <nil>
Ignoring test code in message_test.go
Processing package=net/mail:
Walking from GO.link/src to GO.link/src/net/rpc
Processing net/rpc:
Matchfile(GO.link/src/net/rpc/server.go) => true <nil>
Matchfile(GO.link/src/net/rpc/client.go) => true <nil>
Matchfile(GO.link/src/net/rpc/debug.go) => true <nil>
Ignoring test code in client_test.go
Ignoring test code in server_test.go
Processing package=net/rpc:
Walking from GO.link/src to GO.link/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(GO.link/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(GO.link/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Processing package=net/rpc/jsonrpc:
Walking from GO.link/src to GO.link/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/smtp/auth.go) => true <nil>
Ignoring test code in smtp_test.go
Matchfile(GO.link/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding GO.link/src/net/testdata
Walking from GO.link/src to GO.link/src/net/textproto
Processing net/textproto:
Matchfile(GO.link/src/net/textproto/header.go) => true <nil>
Matchfile(GO.link/src/net/textproto/textproto.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(GO.link/src/net/textproto/writer.go) => true <nil>
Matchfile(GO.link/src/net/textproto/pipeline.go) => true <nil>
Matchfile(GO.link/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=net/textproto:
Walking from GO.link/src to GO.link/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/url/url.go) => true <nil>
Ignoring test code in url_test.go
Processing package=net/url:
Walking from GO.link/src to GO.link/src/os
Processing os:
Matchfile(GO.link/src/os/stat_openbsd.go) => false <nil>
Matchfile(GO.link/src/os/sticky_bsd.go) => true <nil>
Matchfile(GO.link/src/os/executable_procfs.go) => false <nil>
Ignoring test code in env_unix_test.go
Matchfile(GO.link/src/os/str.go) => true <nil>
Matchfile(GO.link/src/os/proc.go) => true <nil>
Matchfile(GO.link/src/os/error_plan9.go) => false <nil>
Matchfile(GO.link/src/os/pipe2_bsd.go) => false <nil>
Matchfile(GO.link/src/os/dir.go) => true <nil>
Matchfile(GO.link/src/os/env.go) => true <nil>
Matchfile(GO.link/src/os/types_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat_dragonfly.go) => false <nil>
Matchfile(GO.link/src/os/error_windows.go) => false <nil>
Matchfile(GO.link/src/os/error.go) => true <nil>
Matchfile(GO.link/src/os/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in executable_test.go
Matchfile(GO.link/src/os/exec_posix.go) => true <nil>
Matchfile(GO.link/src/os/executable_darwin.go) => true <nil>
Matchfile(GO.link/src/os/wait_wait6.go) => false <nil>
Matchfile(GO.link/src/os/sticky_notbsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_darwin.go) => true <nil>
Ignoring test code in fifo_test.go
Matchfile(GO.link/src/os/sys_plan9.go) => false <nil>
Matchfile(GO.link/src/os/executable_windows.go) => false <nil>
Matchfile(GO.link/src/os/file_unix.go) => true <nil>
Ignoring test code in os_unix_test.go
Matchfile(GO.link/src/os/getwd.go) => true <nil>
Matchfile(GO.link/src/os/types_windows.go) => false <nil>
Ignoring test code in env_test.go
Ignoring test code in path_test.go
Matchfile(GO.link/src/os/types.go) => true <nil>
Ignoring test code in timeout_test.go
Matchfile(GO.link/src/os/sys_bsd.go) => true <nil>
Matchfile(GO.link/src/os/types_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/executable_solaris.go) => false <nil>
Matchfile(GO.link/src/os/dir_plan9.go) => false <nil>
Ignoring test code in error_unix_test.go
Matchfile(GO.link/src/os/error_posix.go) => true <nil>
Matchfile(GO.link/src/os/stat_nacljs.go) => false <nil>
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/os/pipe_linux.go) => false <nil>
Matchfile(GO.link/src/os/dir_windows.go) => false <nil>
Matchfile(GO.link/src/os/path_unix.go) => true <nil>
Matchfile(GO.link/src/os/exec.go) => true <nil>
Matchfile(GO.link/src/os/sys_nacl.go) => false <nil>
Matchfile(GO.link/src/os/sys_solaris.go) => false <nil>
Matchfile(GO.link/src/os/exec_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec_unix.go) => true <nil>
Matchfile(GO.link/src/os/sys_linux.go) => false <nil>
Matchfile(GO.link/src/os/dir_unix.go) => true <nil>
Matchfile(GO.link/src/os/executable_path.go) => false <nil>
Matchfile(GO.link/src/os/file_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_netbsd.go) => false <nil>
Matchfile(GO.link/src/os/sys_js.go) => false <nil>
Ignoring test code in os_test.go
Matchfile(GO.link/src/os/executable.go) => true <nil>
Matchfile(GO.link/src/os/error_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat.go) => true <nil>
Ignoring test code in error_windows_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/os/path_windows.go) => false <nil>
Matchfile(GO.link/src/os/exec_windows.go) => false <nil>
Matchfile(GO.link/src/os/file.go) => true <nil>
Matchfile(GO.link/src/os/stat_linux.go) => false <nil>
Matchfile(GO.link/src/os/executable_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_solaris.go) => false <nil>
Matchfile(GO.link/src/os/stat_unix.go) => true <nil>
Matchfile(GO.link/src/os/wait_waitid.go) => false <nil>
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/os/sys_unix.go) => true <nil>
Ignoring test code in os_windows_test.go
Ignoring test code in error_test.go
Matchfile(GO.link/src/os/sys.go) => true <nil>
Matchfile(GO.link/src/os/stat_windows.go) => false <nil>
Matchfile(GO.link/src/os/path.go) => true <nil>
Matchfile(GO.link/src/os/path_plan9.go) => false <nil>
Matchfile(GO.link/src/os/pipe_bsd.go) => true <nil>
Matchfile(GO.link/src/os/file_posix.go) => true <nil>
Matchfile(GO.link/src/os/stat_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/os/wait_unimp.go) => true <nil>
Matchfile(GO.link/src/os/file_windows.go) => false <nil>
Matchfile(GO.link/src/os/executable_plan9.go) => false <nil>
Matchfile(GO.link/src/os/getwd_darwin.go) => true <nil>
Processing package=os:
Walking from GO.link/src to GO.link/src/os/exec
Processing os/exec:
Matchfile(GO.link/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Matchfile(GO.link/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in env_test.go
Matchfile(GO.link/src/os/exec/lp_js.go) => false <nil>
Matchfile(GO.link/src/os/exec/lp_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec/exec.go) => true <nil>
Matchfile(GO.link/src/os/exec/exec_unix.go) => true <nil>
Ignoring test code in lp_test.go
Matchfile(GO.link/src/os/exec/exec_windows.go) => false <nil>
Ignoring test code in lp_windows_test.go
Ignoring test code in internal_test.go
Ignoring test code in lp_unix_test.go
Ignoring test code in exec_posix_test.go
Processing package=os/exec:
Walking from GO.link/src to GO.link/src/os/signal
Processing os/signal:
Matchfile(GO.link/src/os/signal/signal.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in signal_plan9_test.go
Ignoring test code in signal_windows_test.go
Matchfile(GO.link/src/os/signal/doc.go) => true <nil>
Ignoring test code in signal_test.go
Ignoring test code in signal_cgo_test.go
Matchfile(GO.link/src/os/signal/signal_plan9.go) => false <nil>
Matchfile(GO.link/src/os/signal/signal_unix.go) => true <nil>
Processing package=os/signal:
Excluding GO.link/src/os/signal/internal
Walking from GO.link/src to GO.link/src/os/user
Processing os/user:
Matchfile(GO.link/src/os/user/lookup_android.go) => false <nil>
Matchfile(GO.link/src/os/user/user.go) => true <nil>
Ignoring test code in user_test.go
Matchfile(GO.link/src/os/user/lookup_unix.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_windows.go) => false <nil>
Matchfile(GO.link/src/os/user/getgrouplist_unix.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(GO.link/src/os/user/lookup.go) => true <nil>
Matchfile(GO.link/src/os/user/cgo_lookup_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/getgrouplist_darwin.go) => true <nil>
Matchfile(GO.link/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_plan9.go) => false <nil>
Ignoring test code in lookup_unix_test.go
Processing package=os/user:
Walking from GO.link/src to GO.link/src/path
Processing path:
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in match_test.go
Matchfile(GO.link/src/path/match.go) => true <nil>
Matchfile(GO.link/src/path/path.go) => true <nil>
Processing package=path:
Walking from GO.link/src to GO.link/src/path/filepath
Processing path/filepath:
Matchfile(GO.link/src/path/filepath/symlink.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in example_unix_test.go
Matchfile(GO.link/src/path/filepath/symlink_windows.go) => false <nil>
Ignoring test code in example_unix_walk_test.go
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/path/filepath/path_unix.go) => true <nil>
Ignoring test code in match_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/path/filepath/path_windows.go) => false <nil>
Matchfile(GO.link/src/path/filepath/symlink_unix.go) => true <nil>
Matchfile(GO.link/src/path/filepath/match.go) => true <nil>
Matchfile(GO.link/src/path/filepath/path.go) => true <nil>
Matchfile(GO.link/src/path/filepath/path_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Processing package=path/filepath:
Walking from GO.link/src to GO.link/src/plugin
Processing plugin:
Matchfile(GO.link/src/plugin/plugin_stubs.go) => false <nil>
Matchfile(GO.link/src/plugin/plugin_dlopen.go) => true <nil>
Matchfile(GO.link/src/plugin/plugin.go) => true <nil>
Processing package=plugin:
Walking from GO.link/src to GO.link/src/reflect
Processing reflect:
Matchfile(GO.link/src/reflect/swapper.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/reflect/type.go) => true <nil>
Matchfile(GO.link/src/reflect/deepequal.go) => true <nil>
Ignoring test code in set_test.go
Ignoring test code in all_test.go
Ignoring test code in export_test.go
Ignoring test code in tostring_test.go
Matchfile(GO.link/src/reflect/makefunc.go) => true <nil>
Matchfile(GO.link/src/reflect/value.go) => true <nil>
Processing package=reflect:
Walking from GO.link/src to GO.link/src/regexp
Processing regexp:
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in onepass_test.go
Matchfile(GO.link/src/regexp/exec.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/regexp/backtrack.go) => true <nil>
Ignoring test code in exec2_test.go
Matchfile(GO.link/src/regexp/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/onepass.go) => true <nil>
Ignoring test code in find_test.go
Processing package=regexp:
Walking from GO.link/src to GO.link/src/regexp/syntax
Processing regexp/syntax:
Matchfile(GO.link/src/regexp/syntax/prog.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/simplify.go) => true <nil>
Ignoring test code in prog_test.go
Ignoring test code in parse_test.go
Ignoring test code in simplify_test.go
Matchfile(GO.link/src/regexp/syntax/doc.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/compile.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/op_string.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/parse.go) => true <nil>
Processing package=regexp/syntax:
Excluding GO.link/src/regexp/testdata
Walking from GO.link/src to GO.link/src/runtime
Processing runtime:
Matchfile(GO.link/src/runtime/netpoll_stub.go) => false <nil>
Ignoring test code in export_mmap_test.go
Ignoring test code in fastlog2_test.go
Matchfile(GO.link/src/runtime/proc.go) => true <nil>
Matchfile(GO.link/src/runtime/lock_js.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/net_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_elf64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/mbitmap.go) => true <nil>
Matchfile(GO.link/src/runtime/os_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/map_faststr.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/slice.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_amd64x.go) => true <nil>
Matchfile(GO.link/src/runtime/compiler.go) => true <nil>
Ignoring test code in memmove_linux_amd64_test.go
Ignoring test code in chan_test.go
Matchfile(GO.link/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/error.go) => true <nil>
Matchfile(GO.link/src/runtime/symtab.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/map_fast32.go) => true <nil>
Matchfile(GO.link/src/runtime/os_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/lfstack.go) => true <nil>
Matchfile(GO.link/src/runtime/env_posix.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/runtime/mwbbuf.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(GO.link/src/runtime/profbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/os2_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_amd64.go) => false <nil>
Ignoring test code in runtime_unix_test.go
Ignoring test code in slice_test.go
Matchfile(GO.link/src/runtime/stubs_android.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_noauxv.go) => false <nil>
Ignoring test code in mfinal_test.go
Matchfile(GO.link/src/runtime/defs_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/os3_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/mfinal.go) => true <nil>
Matchfile(GO.link/src/runtime/trace.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/defs3_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_bsd.go) => false <nil>
Matchfile(GO.link/src/runtime/defs2_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime2.go) => true <nil>
Matchfile(GO.link/src/runtime/mem_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/atomic_pointer.go) => true <nil>
Matchfile(GO.link/src/runtime/time.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_nacl_arm.go) => false <nil>
Ignoring test code in env_test.go
Matchfile(GO.link/src/runtime/alg.go) => true <nil>
Ignoring test code in profbuf_test.go
Matchfile(GO.link/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm64.go) => false <nil>
Ignoring test code in softfloat64_test.go
Matchfile(GO.link/src/runtime/stubs_nonlinux.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/proflabel.go) => true <nil>
Matchfile(GO.link/src/runtime/msan.go) => false <nil>
Matchfile(GO.link/src/runtime/mgcsweep.go) => true <nil>
Matchfile(GO.link/src/runtime/mgclarge.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_mips64x.go) => false <nil>
Ignoring test code in numcpu_freebsd_test.go
Matchfile(GO.link/src/runtime/sema.go) => true <nil>
Matchfile(GO.link/src/runtime/unaligned2.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/type.go) => true <nil>
Matchfile(GO.link/src/runtime/os_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/auxv_none.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(GO.link/src/runtime/env_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux.go) => false <nil>
Ignoring test code in norace_linux_test.go
Ignoring test code in gcinfo_test.go
Matchfile(GO.link/src/runtime/mem_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_kqueue.go) => true <nil>
Matchfile(GO.link/src/runtime/fastlog2table.go) => true <nil>
Matchfile(GO.link/src/runtime/mcache.go) => true <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(GO.link/src/runtime/stubs32.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_in_none.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_sema.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/iface.go) => true <nil>
Ignoring test code in string_test.go
Matchfile(GO.link/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/cgocall.go) => true <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_ppc64x.go) => false <nil>
Ignoring test code in lfstack_test.go
Matchfile(GO.link/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/runtime/mcentral.go) => true <nil>
Matchfile(GO.link/src/runtime/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_wasm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_nacl.go) => false <nil>
Ignoring test code in map_benchmark_test.go
Matchfile(GO.link/src/runtime/race.go) => false <nil>
Matchfile(GO.link/src/runtime/utf8.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/hash64.go) => true <nil>
Matchfile(GO.link/src/runtime/chan.go) => true <nil>
Matchfile(GO.link/src/runtime/mgcmark.go) => true <nil>
Matchfile(GO.link/src/runtime/traceback.go) => true <nil>
Matchfile(GO.link/src/runtime/panic.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(GO.link/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/float.go) => true <nil>
Matchfile(GO.link/src/runtime/heapdump.go) => true <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(GO.link/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/write_err_android.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(GO.link/src/runtime/os_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/hash32.go) => false <nil>
Ignoring test code in proc_test.go
Matchfile(GO.link/src/runtime/defs1_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_generic.go) => false <nil>
Matchfile(GO.link/src/runtime/typekind.go) => true <nil>
Matchfile(GO.link/src/runtime/sizeclasses.go) => true <nil>
Ignoring test code in runtime_mmap_test.go
Matchfile(GO.link/src/runtime/race0.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/plugin.go) => true <nil>
Ignoring test code in hash_test.go
Matchfile(GO.link/src/runtime/vdso_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/msize.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd.go) => false <nil>
Ignoring test code in crash_cgo_test.go
Matchfile(GO.link/src/runtime/timestub2.go) => false <nil>
Matchfile(GO.link/src/runtime/debugcall.go) => true <nil>
Matchfile(GO.link/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_epoll.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_arm.go) => false <nil>
Ignoring test code in rwmutex_test.go
Ignoring test code in crash_test.go
Ignoring test code in symtab_test.go
Matchfile(GO.link/src/runtime/debug.go) => true <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/mstats.go) => true <nil>
Matchfile(GO.link/src/runtime/timeasm.go) => false <nil>
Matchfile(GO.link/src/runtime/print.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/os_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_nonppc64x.go) => true <nil>
Matchfile(GO.link/src/runtime/stack.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows_386.go) => false <nil>
Matchfile(GO.link/src/runtime/softfloat64.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cputicks.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/timestub.go) => true <nil>
Matchfile(GO.link/src/runtime/mkduff.go) => false <nil>
Matchfile(GO.link/src/runtime/os_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd.go) => false <nil>
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/runtime/mfixalloc.go) => true <nil>
Matchfile(GO.link/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(GO.link/src/runtime/unaligned1.go) => true <nil>
Ignoring test code in callers_test.go
Matchfile(GO.link/src/runtime/mksizeclasses.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_amd64.go) => false <nil>
Ignoring test code in crash_unix_test.go
Matchfile(GO.link/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_ppc64le.go) => false <nil>
Ignoring test code in export_debug_test.go
Matchfile(GO.link/src/runtime/syscall2_solaris.go) => false <nil>
Ignoring test code in futex_test.go
Ignoring test code in stack_test.go
Matchfile(GO.link/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/os_netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_amd64.go) => true <nil>
Ignoring test code in vlop_arm_test.go
Matchfile(GO.link/src/runtime/signal_openbsd_arm.go) => false <nil>
Ignoring test code in closure_test.go
Ignoring test code in vdso_linux_test.go
Matchfile(GO.link/src/runtime/rwmutex.go) => true <nil>
Ignoring test code in export_linux_test.go
Ignoring test code in iface_test.go
Matchfile(GO.link/src/runtime/signal_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/cgocallback.go) => true <nil>
Matchfile(GO.link/src/runtime/wincallback.go) => false <nil>
Matchfile(GO.link/src/runtime/map.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo.go) => true <nil>
Ignoring test code in complex_test.go
Matchfile(GO.link/src/runtime/signal_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mbarrier.go) => true <nil>
Matchfile(GO.link/src/runtime/sigqueue.go) => true <nil>
Matchfile(GO.link/src/runtime/os_android.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_futex.go) => false <nil>
Ignoring test code in gc_test.go
Matchfile(GO.link/src/runtime/malloc.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs3.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/msan0.go) => true <nil>
Matchfile(GO.link/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll.go) => true <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/runtime/cgo_sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/fastlog2.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/relax_stub.go) => true <nil>
Matchfile(GO.link/src/runtime/os3_solaris.go) => false <nil>
Ignoring test code in runtime_linux_test.go
Ignoring test code in runtime_test.go
Matchfile(GO.link/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(GO.link/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/complex.go) => true <nil>
Ignoring test code in runtime-gdb_test.go
Matchfile(GO.link/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime1.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/mheap.go) => true <nil>
Matchfile(GO.link/src/runtime/rdebug.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_generic.go) => false <nil>
Matchfile(GO.link/src/runtime/os_js.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_fake.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_js.go) => false <nil>
Matchfile(GO.link/src/runtime/cgocheck.go) => true <nil>
Matchfile(GO.link/src/runtime/os_linux_noauxv.go) => false <nil>
Matchfile(GO.link/src/runtime/map_fast64.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/runtime/write_err.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_unix.go) => true <nil>
Matchfile(GO.link/src/runtime/mgc.go) => true <nil>
Matchfile(GO.link/src/runtime/mkfastlog2table.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mprof.go) => true <nil>
Ignoring test code in sizeof_test.go
Matchfile(GO.link/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/extern.go) => true <nil>
Ignoring test code in runtime-lldb_test.go
Matchfile(GO.link/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/vlrt.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_mmap.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_darwin.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/string.go) => true <nil>
Ignoring test code in norace_test.go
Matchfile(GO.link/src/runtime/sys_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cpuprof.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs2.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(GO.link/src/runtime/select.go) => true <nil>
Ignoring test code in chanbarrier_test.go
Ignoring test code in debug_test.go
Matchfile(GO.link/src/runtime/mgcwork.go) => true <nil>
Ignoring test code in export_arm_test.go
Matchfile(GO.link/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(GO.link/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/os_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/mmap.go) => false <nil>
Ignoring test code in export_futex_test.go
Processing package=runtime:
Walking from GO.link/src to GO.link/src/runtime/cgo
Processing runtime/cgo:
Matchfile(GO.link/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/mmap.go) => false <nil>
Processing package=runtime/cgo:
Walking from GO.link/src to GO.link/src/runtime/debug
Processing runtime/debug:
Ignoring test code in garbage_test.go
Matchfile(GO.link/src/runtime/debug/stack.go) => true <nil>
Matchfile(GO.link/src/runtime/debug/stubs.go) => true <nil>
Ignoring test code in stack_test.go
Matchfile(GO.link/src/runtime/debug/garbage.go) => true <nil>
Ignoring test code in heapdump_test.go
Processing package=runtime/debug:
Excluding GO.link/src/runtime/internal
Walking from GO.link/src to GO.link/src/runtime/msan
Processing runtime/msan:
Matchfile(GO.link/src/runtime/msan/msan.go) => false <nil>
Walking from GO.link/src to GO.link/src/runtime/pprof
Processing runtime/pprof:
Matchfile(GO.link/src/runtime/pprof/pprof.go) => true <nil>
Ignoring test code in mprof_test.go
Matchfile(GO.link/src/runtime/pprof/runtime.go) => true <nil>
Ignoring test code in label_test.go
Matchfile(GO.link/src/runtime/pprof/protomem.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/label.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/elf.go) => true <nil>
Ignoring test code in proto_test.go
Matchfile(GO.link/src/runtime/pprof/map.go) => true <nil>
Ignoring test code in runtime_test.go
Ignoring test code in pprof_test.go
Matchfile(GO.link/src/runtime/pprof/proto.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/protobuf.go) => true <nil>
Ignoring test code in protomem_test.go
Processing package=runtime/pprof:
Excluding GO.link/src/runtime/pprof/internal
Excluding GO.link/src/runtime/pprof/testdata
Walking from GO.link/src to GO.link/src/runtime/race
Processing runtime/race:
Ignoring test code in race_unix_test.go
Ignoring test code in race_test.go
Ignoring test code in sched_test.go
Matchfile(GO.link/src/runtime/race/race.go) => false <nil>
Matchfile(GO.link/src/runtime/race/doc.go) => true <nil>
Ignoring test code in race_linux_test.go
Ignoring test code in race_windows_test.go
Ignoring test code in output_test.go
Processing package=runtime/race:
Excluding GO.link/src/runtime/race/testdata
Excluding GO.link/src/runtime/testdata
Walking from GO.link/src to GO.link/src/runtime/trace
Processing runtime/trace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Ignoring test code in annotation_test.go
Matchfile(GO.link/src/runtime/trace/annotation.go) => true <nil>
Matchfile(GO.link/src/runtime/trace/trace.go) => true <nil>
Ignoring test code in trace_stack_test.go
Processing package=runtime/trace:
Walking from GO.link/src to GO.link/src/sort
Processing sort:
Ignoring test code in example_search_test.go
Matchfile(GO.link/src/sort/slice.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/sort/zfuncversion.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(GO.link/src/sort/sort.go) => true <nil>
Matchfile(GO.link/src/sort/genzfunc.go) => false <nil>
Ignoring test code in example_wrapper_test.go
Ignoring test code in sort_test.go
Matchfile(GO.link/src/sort/search.go) => true <nil>
Ignoring test code in example_keys_test.go
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in example_multi_test.go
Processing package=sort:
Walking from GO.link/src to GO.link/src/strconv
Processing strconv:
Ignoring test code in atof_test.go
Matchfile(GO.link/src/strconv/extfloat.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in quote_test.go
Matchfile(GO.link/src/strconv/ftoa.go) => true <nil>
Matchfile(GO.link/src/strconv/decimal.go) => true <nil>
Ignoring test code in fp_test.go
Matchfile(GO.link/src/strconv/quote.go) => true <nil>
Matchfile(GO.link/src/strconv/makeisprint.go) => false <nil>
Matchfile(GO.link/src/strconv/doc.go) => true <nil>
Matchfile(GO.link/src/strconv/itoa.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/strconv/atof.go) => true <nil>
Matchfile(GO.link/src/strconv/atob.go) => true <nil>
Ignoring test code in atoi_test.go
Ignoring test code in itoa_test.go
Ignoring test code in internal_test.go
Matchfile(GO.link/src/strconv/isprint.go) => true <nil>
Ignoring test code in atob_test.go
Ignoring test code in decimal_test.go
Matchfile(GO.link/src/strconv/atoi.go) => true <nil>
Ignoring test code in strconv_test.go
Ignoring test code in ftoa_test.go
Processing package=strconv:
Excluding GO.link/src/strconv/testdata
Walking from GO.link/src to GO.link/src/strings
Processing strings:
Matchfile(GO.link/src/strings/strings_decl.go) => true <nil>
Ignoring test code in replace_test.go
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/strings/search.go) => true <nil>
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in strings_test.go
Matchfile(GO.link/src/strings/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/strings/builder.go) => true <nil>
Matchfile(GO.link/src/strings/replace.go) => true <nil>
Matchfile(GO.link/src/strings/compare.go) => true <nil>
Matchfile(GO.link/src/strings/strings.go) => true <nil>
Ignoring test code in builder_test.go
Processing package=strings:
Walking from GO.link/src to GO.link/src/sync
Processing sync:
Ignoring test code in map_bench_test.go
Ignoring test code in example_pool_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/sync/runtime.go) => true <nil>
Ignoring test code in once_test.go
Ignoring test code in mutex_test.go
Ignoring test code in rwmutex_test.go
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/sync/once.go) => true <nil>
Matchfile(GO.link/src/sync/cond.go) => true <nil>
Matchfile(GO.link/src/sync/rwmutex.go) => true <nil>
Matchfile(GO.link/src/sync/map.go) => true <nil>
Ignoring test code in runtime_sema_test.go
Ignoring test code in pool_test.go
Matchfile(GO.link/src/sync/mutex.go) => true <nil>
Matchfile(GO.link/src/sync/pool.go) => true <nil>
Ignoring test code in waitgroup_test.go
Ignoring test code in map_reference_test.go
Ignoring test code in cond_test.go
Matchfile(GO.link/src/sync/waitgroup.go) => true <nil>
Processing package=sync:
Walking from GO.link/src to GO.link/src/sync/atomic
Processing sync/atomic:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(GO.link/src/sync/atomic/doc.go) => true <nil>
Ignoring test code in atomic_test.go
Matchfile(GO.link/src/sync/atomic/value.go) => true <nil>
Processing package=sync/atomic:
Walking from GO.link/src to GO.link/src/syscall
Processing syscall:
Matchfile(GO.link/src/syscall/dirent.go) => true <nil>
Matchfile(GO.link/src/syscall/types_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/str.go) => true <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(GO.link/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_amd64.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Matchfile(GO.link/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(GO.link/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/env_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows_amd64.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(GO.link/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/fs_js.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Matchfile(GO.link/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_amd64.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(GO.link/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/bpf_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/route_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Ignoring test code in syscall_bsd_test.go
Matchfile(GO.link/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/msan.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysctl_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/env_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/dll_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/dir_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/timestruct.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/types_darwin.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_js.go) => false <nil>
Matchfile(GO.link/src/syscall/net.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/netlink_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/env_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/route_freebsd_32bit.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/exec_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/const_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_big.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/security_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/lsf_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/route_darwin.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/flock.go) => true <nil>
Matchfile(GO.link/src/syscall/flock_linux_32bit.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/syscall/net_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/route_bsd.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/net_js.go) => false <nil>
Ignoring test code in exec_unix_test.go
Matchfile(GO.link/src/syscall/forkpipe2.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/mkpost.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/fd_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Ignoring test code in export_linux_test.go
Matchfile(GO.link/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/unzip_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/msan0.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_386.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/syscall/syscall_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm.go) => false <nil>
Ignoring test code in syscall_test.go
Matchfile(GO.link/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/route_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/setuidgid_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/fs_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/forkpipe.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_386.go) => false <nil>
Ignoring test code in syscall_linux_test.go
Matchfile(GO.link/src/syscall/syscall_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/types_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_little.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/types_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/errors_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Processing package=syscall:
Walking from GO.link/src to GO.link/src/syscall/js
Processing syscall/js:
Matchfile(GO.link/src/syscall/js/callback.go) => false <nil>
Ignoring test code in js_test.go
Matchfile(GO.link/src/syscall/js/typedarray.go) => false <nil>
Matchfile(GO.link/src/syscall/js/js.go) => false <nil>
Walking from GO.link/src to GO.link/src/testing
Processing testing:
Ignoring test code in helper_test.go
Matchfile(GO.link/src/testing/benchmark.go) => true <nil>
Ignoring test code in sub_test.go
Matchfile(GO.link/src/testing/cover.go) => true <nil>
Matchfile(GO.link/src/testing/allocs.go) => true <nil>
Ignoring test code in helperfuncs_test.go
Ignoring test code in allocs_test.go
Ignoring test code in testing_test.go
Ignoring test code in match_test.go
Matchfile(GO.link/src/testing/example.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/testing/match.go) => true <nil>
Ignoring test code in benchmark_test.go
Matchfile(GO.link/src/testing/testing.go) => true <nil>
Processing package=testing:
Excluding GO.link/src/testing/internal
Walking from GO.link/src to GO.link/src/testing/iotest
Processing testing/iotest:
Matchfile(GO.link/src/testing/iotest/logger.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/writer.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/reader.go) => true <nil>
Processing package=testing/iotest:
Walking from GO.link/src to GO.link/src/testing/quick
Processing testing/quick:
Ignoring test code in quick_test.go
Matchfile(GO.link/src/testing/quick/quick.go) => true <nil>
Processing package=testing/quick:
Walking from GO.link/src to GO.link/src/text
Processing text:
Walking from GO.link/src to GO.link/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=text/scanner:
Walking from GO.link/src to GO.link/src/text/tabwriter
Processing text/tabwriter:
Ignoring test code in tabwriter_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/tabwriter/tabwriter.go) => true <nil>
Processing package=text/tabwriter:
Walking from GO.link/src to GO.link/src/text/template
Processing text/template:
Matchfile(GO.link/src/text/template/option.go) => true <nil>
Ignoring test code in examplefunc_test.go
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in multi_test.go
Matchfile(GO.link/src/text/template/exec.go) => true <nil>
Matchfile(GO.link/src/text/template/template.go) => true <nil>
Matchfile(GO.link/src/text/template/helper.go) => true <nil>
Matchfile(GO.link/src/text/template/doc.go) => true <nil>
Matchfile(GO.link/src/text/template/funcs.go) => true <nil>
Processing package=text/template:
Walking from GO.link/src to GO.link/src/text/template/parse
Processing text/template/parse:
Ignoring test code in lex_test.go
Matchfile(GO.link/src/text/template/parse/lex.go) => true <nil>
Ignoring test code in parse_test.go
Matchfile(GO.link/src/text/template/parse/node.go) => true <nil>
Matchfile(GO.link/src/text/template/parse/parse.go) => true <nil>
Processing package=text/template/parse:
Excluding GO.link/src/text/template/testdata
Walking from GO.link/src to GO.link/src/time
Processing time:
Ignoring test code in zoneinfo_windows_test.go
Matchfile(GO.link/src/time/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in zoneinfo_android_test.go
Matchfile(GO.link/src/time/zoneinfo_android.go) => false <nil>
Ignoring test code in sleep_test.go
Matchfile(GO.link/src/time/sys_plan9.go) => false <nil>
Ignoring test code in zoneinfo_test.go
Matchfile(GO.link/src/time/time.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_plan9.go) => false <nil>
Ignoring test code in format_test.go
Matchfile(GO.link/src/time/format.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_unix.go) => true <nil>
Ignoring test code in mono_test.go
Matchfile(GO.link/src/time/genzabbrs.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_ios.go) => false <nil>
Matchfile(GO.link/src/time/sleep.go) => true <nil>
Matchfile(GO.link/src/time/tick.go) => true <nil>
Ignoring test code in tick_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/time/zoneinfo_read.go) => true <nil>
Ignoring test code in internal_test.go
Matchfile(GO.link/src/time/sys_unix.go) => true <nil>
Ignoring test code in export_android_test.go
Ignoring test code in time_test.go
Ignoring test code in export_windows_test.go
Processing package=time:
Walking from GO.link/src to GO.link/src/unicode
Processing unicode:
Ignoring test code in example_test.go
Ignoring test code in graphic_test.go
Matchfile(GO.link/src/unicode/maketables.go) => false <nil>
Ignoring test code in script_test.go
Matchfile(GO.link/src/unicode/digit.go) => true <nil>
Matchfile(GO.link/src/unicode/tables.go) => true <nil>
Matchfile(GO.link/src/unicode/letter.go) => true <nil>
Ignoring test code in digit_test.go
Matchfile(GO.link/src/unicode/graphic.go) => true <nil>
Matchfile(GO.link/src/unicode/casetables.go) => true <nil>
Ignoring test code in letter_test.go
Processing package=unicode:
Walking from GO.link/src to GO.link/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in utf16_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/unicode/utf16/utf16.go) => true <nil>
Processing package=unicode/utf16:
Walking from GO.link/src to GO.link/src/unicode/utf8
Processing unicode/utf8:
Ignoring test code in example_test.go
Ignoring test code in utf8_test.go
Matchfile(GO.link/src/unicode/utf8/utf8.go) => true <nil>
Processing package=unicode/utf8:
Walking from GO.link/src to GO.link/src/unsafe
Processing unsafe:
Matchfile(GO.link/src/unsafe/unsafe.go) => true <nil>
Processing package=unsafe:
Excluding GO.link/src/vendor
TYPE archive/tar.Format:
  GO.link/src/archive/tar/format.go
TYPE archive/tar.Header:
  GO.link/src/archive/tar/common.go
TYPE archive/tar.Reader:
  GO.link/src/archive/tar/reader.go
TYPE archive/tar.Writer:
  GO.link/src/archive/tar/writer.go
TYPE archive/zip.Compressor:
  GO.link/src/archive/zip/register.go
TYPE archive/zip.Decompressor:
  GO.link/src/archive/zip/register.go
TYPE archive/zip.File:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.FileHeader:
  GO.link/src/archive/zip/struct.go
TYPE archive/zip.ReadCloser:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.Reader:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.Writer:
  GO.link/src/archive/zip/writer.go
TYPE bufio.ReadWriter:
  GO.link/src/bufio/bufio.go
TYPE bufio.Reader:
  GO.link/src/bufio/bufio.go
TYPE bufio.Scanner:
  GO.link/src/bufio/scan.go
TYPE bufio.SplitFunc:
  GO.link/src/bufio/scan.go
TYPE bufio.Writer:
  GO.link/src/bufio/bufio.go
TYPE bytes.Buffer:
  GO.link/src/bytes/buffer.go
TYPE bytes.Reader:
  GO.link/src/bytes/reader.go
TYPE compress/bzip2.StructuralError:
  GO.link/src/compress/bzip2/bzip2.go
TYPE compress/flate.CorruptInputError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.InternalError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.ReadError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Reader:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Resetter:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.WriteError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Writer:
  GO.link/src/compress/flate/deflate.go
TYPE compress/gzip.Header:
  GO.link/src/compress/gzip/gunzip.go
TYPE compress/gzip.Reader:
  GO.link/src/compress/gzip/gunzip.go
TYPE compress/gzip.Writer:
  GO.link/src/compress/gzip/gzip.go
TYPE compress/lzw.Order:
  GO.link/src/compress/lzw/reader.go
TYPE compress/zlib.Resetter:
  GO.link/src/compress/zlib/reader.go
TYPE compress/zlib.Writer:
  GO.link/src/compress/zlib/writer.go
TYPE container/heap.Interface:
  GO.link/src/container/heap/heap.go
TYPE container/list.Element:
  GO.link/src/container/list/list.go
TYPE container/list.List:
  GO.link/src/container/list/list.go
TYPE container/ring.Ring:
  GO.link/src/container/ring/ring.go
TYPE context.CancelFunc:
  GO.link/src/context/context.go
TYPE context.Context:
  GO.link/src/context/context.go
TYPE crypto.Decrypter:
  GO.link/src/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  GO.link/src/crypto/crypto.go
TYPE crypto.Hash:
  GO.link/src/crypto/crypto.go
TYPE crypto.PrivateKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.PublicKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.Signer:
  GO.link/src/crypto/crypto.go
TYPE crypto.SignerOpts:
  GO.link/src/crypto/crypto.go
TYPE crypto/aes.KeySizeError:
  GO.link/src/crypto/aes/cipher.go
TYPE crypto/cipher.AEAD:
  GO.link/src/crypto/cipher/gcm.go
TYPE crypto/cipher.Block:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.BlockMode:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.Stream:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.StreamReader:
  GO.link/src/crypto/cipher/io.go
TYPE crypto/cipher.StreamWriter:
  GO.link/src/crypto/cipher/io.go
TYPE crypto/des.KeySizeError:
  GO.link/src/crypto/des/cipher.go
TYPE crypto/dsa.ParameterSizes:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.Parameters:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.PrivateKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.PublicKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/ecdsa.PrivateKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE crypto/ecdsa.PublicKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE crypto/elliptic.Curve:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE crypto/elliptic.CurveParams:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE crypto/rc4.Cipher:
  GO.link/src/crypto/rc4/rc4.go
TYPE crypto/rc4.KeySizeError:
  GO.link/src/crypto/rc4/rc4.go
TYPE crypto/rsa.CRTValue:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.OAEPOptions:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PKCS1v15DecryptOptions:
  GO.link/src/crypto/rsa/pkcs1v15.go
TYPE crypto/rsa.PSSOptions:
  GO.link/src/crypto/rsa/pss.go
TYPE crypto/rsa.PrecomputedValues:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PrivateKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PublicKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/tls.Certificate:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.CertificateRequestInfo:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientAuthType:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientHelloInfo:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientSessionCache:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientSessionState:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.Config:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.Conn:
  GO.link/src/crypto/tls/conn.go
TYPE crypto/tls.ConnectionState:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.CurveID:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.RecordHeaderError:
  GO.link/src/crypto/tls/conn.go
TYPE crypto/tls.RenegotiationSupport:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.SignatureScheme:
  GO.link/src/crypto/tls/common.go
TYPE crypto/x509.CertPool:
  GO.link/src/crypto/x509/cert_pool.go
TYPE crypto/x509.Certificate:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.CertificateInvalidError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.CertificateRequest:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.ConstraintViolationError:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.ExtKeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.HostnameError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.InsecureAlgorithmError:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.InvalidReason:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.KeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.PEMCipher:
  GO.link/src/crypto/x509/pem_decrypt.go
TYPE crypto/x509.PublicKeyAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.SignatureAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.SystemRootsError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.UnhandledCriticalExtension:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.UnknownAuthorityError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.VerifyOptions:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509/pkix.AlgorithmIdentifier:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.AttributeTypeAndValue:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.AttributeTypeAndValueSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.CertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.Extension:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.Name:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RDNSequence:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RelativeDistinguishedNameSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RevokedCertificate:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.TBSCertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE database/sql.ColumnType:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Conn:
  GO.link/src/database/sql/sql.go
TYPE database/sql.DB:
  GO.link/src/database/sql/sql.go
TYPE database/sql.DBStats:
  GO.link/src/database/sql/sql.go
TYPE database/sql.IsolationLevel:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NamedArg:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullBool:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullFloat64:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullInt64:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullString:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Out:
  GO.link/src/database/sql/sql.go
TYPE database/sql.RawBytes:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Result:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Row:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Rows:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Scanner:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Stmt:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Tx:
  GO.link/src/database/sql/sql.go
TYPE database/sql.TxOptions:
  GO.link/src/database/sql/sql.go
TYPE database/sql/driver.ColumnConverter:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Conn:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ConnBeginTx:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ConnPrepareContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Connector:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Driver:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.DriverContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Execer:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ExecerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.IsolationLevel:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NamedValue:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NamedValueChecker:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NotNull:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Null:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Pinger:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Queryer:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.QueryerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Result:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Rows:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsAffected:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeDatabaseTypeName:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeLength:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeNullable:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypePrecisionScale:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeScanType:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsNextResultSet:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.SessionResetter:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Stmt:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.StmtExecContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.StmtQueryContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Tx:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.TxOptions:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Value:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ValueConverter:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Valuer:
  GO.link/src/database/sql/driver/types.go
TYPE debug/dwarf.AddrType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.ArrayType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Attr:
  GO.link/src/debug/dwarf/const.go
TYPE debug/dwarf.BasicType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.BoolType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.CharType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Class:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.CommonType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.ComplexType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Data:
  GO.link/src/debug/dwarf/open.go
TYPE debug/dwarf.DecodeError:
  GO.link/src/debug/dwarf/buf.go
TYPE debug/dwarf.DotDotDotType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Entry:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.EnumType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.EnumValue:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Field:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.FloatType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.FuncType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.IntType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.LineEntry:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineFile:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineReader:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineReaderPos:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.Offset:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.PtrType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.QualType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Reader:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.StructField:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.StructType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Tag:
  GO.link/src/debug/dwarf/const.go
TYPE debug/dwarf.Type:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.TypedefType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UcharType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UintType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UnspecifiedType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.VoidType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/elf.Chdr32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Chdr64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Class:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.CompressionType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Data:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Dyn32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Dyn64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.DynFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.DynTag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.File:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.FileHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.FormatError:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Header32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Header64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ImportedSymbol:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Machine:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.NType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.OSABI:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Prog:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Prog32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Prog64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ProgFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ProgHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.ProgType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_386:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_390:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_AARCH64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_ALPHA:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_ARM:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_MIPS:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_PPC:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_PPC64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_RISCV:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_SPARC:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_X86_64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rel32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rel64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rela32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rela64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Section:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Section32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Section64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.SectionIndex:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Sym32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Sym64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymBind:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymVis:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Symbol:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Type:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Version:
  GO.link/src/debug/elf/elf.go
TYPE debug/gosym.DecodingError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Func:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.LineTable:
  GO.link/src/debug/gosym/pclntab.go
TYPE debug/gosym.Obj:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Sym:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Table:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.UnknownFileError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.UnknownLineError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/macho.Cpu:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Dylib:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.DylibCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Dysymtab:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.DysymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.FatArch:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.FatArchHeader:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.FatFile:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.File:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.FileHeader:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.FormatError:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Load:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.LoadBytes:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.LoadCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Nlist32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Nlist64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Regs386:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.RegsAMD64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Reloc:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.RelocTypeARM:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeARM64:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeGeneric:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeX86_64:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.Rpath:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.RpathCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Section:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Section32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Section64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.SectionHeader:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Segment:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Segment32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Segment64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.SegmentHeader:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Symbol:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Symtab:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.SymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Thread:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Type:
  GO.link/src/debug/macho/macho.go
TYPE debug/pe.COFFSymbol:
  GO.link/src/debug/pe/symbol.go
TYPE debug/pe.DataDirectory:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.File:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.FileHeader:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.FormatError:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.ImportDirectory:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.OptionalHeader32:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.OptionalHeader64:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.Reloc:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.Section:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.SectionHeader:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.SectionHeader32:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.StringTable:
  GO.link/src/debug/pe/string.go
TYPE debug/pe.Symbol:
  GO.link/src/debug/pe/symbol.go
TYPE debug/plan9obj.File:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.FileHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.Section:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.SectionHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.Sym:
  GO.link/src/debug/plan9obj/file.go
TYPE encoding.BinaryMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding/ascii85.CorruptInputError:
  GO.link/src/encoding/ascii85/ascii85.go
TYPE encoding/asn1.BitString:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.Enumerated:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.Flag:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.ObjectIdentifier:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.RawContent:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.RawValue:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.StructuralError:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.SyntaxError:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/base32.CorruptInputError:
  GO.link/src/encoding/base32/base32.go
TYPE encoding/base32.Encoding:
  GO.link/src/encoding/base32/base32.go
TYPE encoding/base64.CorruptInputError:
  GO.link/src/encoding/base64/base64.go
TYPE encoding/base64.Encoding:
  GO.link/src/encoding/base64/base64.go
TYPE encoding/binary.ByteOrder:
  GO.link/src/encoding/binary/binary.go
TYPE encoding/csv.ParseError:
  GO.link/src/encoding/csv/reader.go
TYPE encoding/csv.Reader:
  GO.link/src/encoding/csv/reader.go
TYPE encoding/csv.Writer:
  GO.link/src/encoding/csv/writer.go
TYPE encoding/gob.CommonType:
  GO.link/src/encoding/gob/type.go
TYPE encoding/gob.Decoder:
  GO.link/src/encoding/gob/decoder.go
TYPE encoding/gob.Encoder:
  GO.link/src/encoding/gob/encoder.go
TYPE encoding/gob.GobDecoder:
  GO.link/src/encoding/gob/type.go
TYPE encoding/gob.GobEncoder:
  GO.link/src/encoding/gob/type.go
TYPE encoding/hex.InvalidByteError:
  GO.link/src/encoding/hex/hex.go
TYPE encoding/json.Decoder:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.Delim:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.Encoder:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.InvalidUTF8Error:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.InvalidUnmarshalError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.Marshaler:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.MarshalerError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.Number:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.RawMessage:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.SyntaxError:
  GO.link/src/encoding/json/scanner.go
TYPE encoding/json.Token:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.UnmarshalFieldError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.UnmarshalTypeError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.Unmarshaler:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.UnsupportedTypeError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.UnsupportedValueError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/pem.Block:
  GO.link/src/encoding/pem/pem.go
TYPE encoding/xml.Attr:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.CharData:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Comment:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Decoder:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Directive:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Encoder:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.EndElement:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Marshaler:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.MarshalerAttr:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.Name:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.ProcInst:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.StartElement:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.SyntaxError:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.TagPathError:
  GO.link/src/encoding/xml/typeinfo.go
TYPE encoding/xml.Token:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.TokenReader:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.UnmarshalError:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.Unmarshaler:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.UnmarshalerAttr:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.UnsupportedTypeError:
  GO.link/src/encoding/xml/marshal.go
TYPE expvar.Float:
  GO.link/src/expvar/expvar.go
TYPE expvar.Func:
  GO.link/src/expvar/expvar.go
TYPE expvar.Int:
  GO.link/src/expvar/expvar.go
TYPE expvar.KeyValue:
  GO.link/src/expvar/expvar.go
TYPE expvar.Map:
  GO.link/src/expvar/expvar.go
TYPE expvar.String:
  GO.link/src/expvar/expvar.go
TYPE expvar.Var:
  GO.link/src/expvar/expvar.go
TYPE flag.ErrorHandling:
  GO.link/src/flag/flag.go
TYPE flag.Flag:
  GO.link/src/flag/flag.go
TYPE flag.FlagSet:
  GO.link/src/flag/flag.go
TYPE flag.Getter:
  GO.link/src/flag/flag.go
TYPE flag.Value:
  GO.link/src/flag/flag.go
TYPE fmt.Formatter:
  GO.link/src/fmt/print.go
TYPE fmt.GoStringer:
  GO.link/src/fmt/print.go
TYPE fmt.ScanState:
  GO.link/src/fmt/scan.go
TYPE fmt.Scanner:
  GO.link/src/fmt/scan.go
TYPE fmt.State:
  GO.link/src/fmt/print.go
TYPE fmt.Stringer:
  GO.link/src/fmt/print.go
TYPE go/ast.ArrayType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.AssignStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BasicLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BinaryExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BlockStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BranchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CallExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CaseClause:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ChanDir:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ChanType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommClause:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Comment:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommentGroup:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommentMap:
  GO.link/src/go/ast/commentmap.go
TYPE go/ast.CompositeLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Decl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.DeclStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.DeferStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Ellipsis:
  GO.link/src/go/ast/ast.go
TYPE go/ast.EmptyStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Expr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ExprStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Field:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FieldFilter:
  GO.link/src/go/ast/print.go
TYPE go/ast.FieldList:
  GO.link/src/go/ast/ast.go
TYPE go/ast.File:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Filter:
  GO.link/src/go/ast/filter.go
TYPE go/ast.ForStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.GenDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.GoStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Ident:
  GO.link/src/go/ast/ast.go
TYPE go/ast.IfStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ImportSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Importer:
  GO.link/src/go/ast/resolve.go
TYPE go/ast.IncDecStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.IndexExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.InterfaceType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.KeyValueExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.LabeledStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.MapType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.MergeMode:
  GO.link/src/go/ast/filter.go
TYPE go/ast.Node:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ObjKind:
  GO.link/src/go/ast/scope.go
TYPE go/ast.Object:
  GO.link/src/go/ast/scope.go
TYPE go/ast.Package:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ParenExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.RangeStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ReturnStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Scope:
  GO.link/src/go/ast/scope.go
TYPE go/ast.SelectStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SelectorExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SendStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SliceExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Spec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.StarExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Stmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.StructType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeAssertExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeSwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.UnaryExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ValueSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Visitor:
  GO.link/src/go/ast/walk.go
TYPE go/build.Context:
  GO.link/src/go/build/build.go
TYPE go/build.ImportMode:
  GO.link/src/go/build/build.go
TYPE go/build.MultiplePackageError:
  GO.link/src/go/build/build.go
TYPE go/build.NoGoError:
  GO.link/src/go/build/build.go
TYPE go/build.Package:
  GO.link/src/go/build/build.go
TYPE go/constant.Kind:
  GO.link/src/go/constant/value.go
TYPE go/constant.Value:
  GO.link/src/go/constant/value.go
TYPE go/doc.Example:
  GO.link/src/go/doc/example.go
TYPE go/doc.Filter:
  GO.link/src/go/doc/filter.go
TYPE go/doc.Func:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Mode:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Note:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Package:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Type:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Value:
  GO.link/src/go/doc/doc.go
TYPE go/importer.Lookup:
  GO.link/src/go/importer/importer.go
TYPE go/parser.Mode:
  GO.link/src/go/parser/interface.go
TYPE go/printer.CommentedNode:
  GO.link/src/go/printer/printer.go
TYPE go/printer.Config:
  GO.link/src/go/printer/printer.go
TYPE go/printer.Mode:
  GO.link/src/go/printer/printer.go
TYPE go/scanner.Error:
  GO.link/src/go/scanner/errors.go
TYPE go/scanner.ErrorHandler:
  GO.link/src/go/scanner/scanner.go
TYPE go/scanner.ErrorList:
  GO.link/src/go/scanner/errors.go
TYPE go/scanner.Mode:
  GO.link/src/go/scanner/scanner.go
TYPE go/scanner.Scanner:
  GO.link/src/go/scanner/scanner.go
TYPE go/token.File:
  GO.link/src/go/token/position.go
TYPE go/token.FileSet:
  GO.link/src/go/token/position.go
TYPE go/token.Pos:
  GO.link/src/go/token/position.go
TYPE go/token.Position:
  GO.link/src/go/token/position.go
TYPE go/token.Token:
  GO.link/src/go/token/token.go
TYPE go/types.Array:
  GO.link/src/go/types/type.go
TYPE go/types.Basic:
  GO.link/src/go/types/type.go
TYPE go/types.BasicInfo:
  GO.link/src/go/types/type.go
TYPE go/types.BasicKind:
  GO.link/src/go/types/type.go
TYPE go/types.Builtin:
  GO.link/src/go/types/object.go
TYPE go/types.Chan:
  GO.link/src/go/types/type.go
TYPE go/types.ChanDir:
  GO.link/src/go/types/type.go
TYPE go/types.Checker:
  GO.link/src/go/types/check.go
TYPE go/types.Config:
  GO.link/src/go/types/api.go
TYPE go/types.Const:
  GO.link/src/go/types/object.go
TYPE go/types.Error:
  GO.link/src/go/types/api.go
TYPE go/types.Func:
  GO.link/src/go/types/object.go
TYPE go/types.ImportMode:
  GO.link/src/go/types/api.go
TYPE go/types.Importer:
  GO.link/src/go/types/api.go
TYPE go/types.ImporterFrom:
  GO.link/src/go/types/api.go
TYPE go/types.Info:
  GO.link/src/go/types/api.go
TYPE go/types.Initializer:
  GO.link/src/go/types/api.go
TYPE go/types.Interface:
  GO.link/src/go/types/type.go
TYPE go/types.Label:
  GO.link/src/go/types/object.go
TYPE go/types.Map:
  GO.link/src/go/types/type.go
TYPE go/types.MethodSet:
  GO.link/src/go/types/methodset.go
TYPE go/types.Named:
  GO.link/src/go/types/type.go
TYPE go/types.Nil:
  GO.link/src/go/types/object.go
TYPE go/types.Object:
  GO.link/src/go/types/object.go
TYPE go/types.Package:
  GO.link/src/go/types/package.go
TYPE go/types.PkgName:
  GO.link/src/go/types/object.go
TYPE go/types.Pointer:
  GO.link/src/go/types/type.go
TYPE go/types.Qualifier:
  GO.link/src/go/types/typestring.go
TYPE go/types.Scope:
  GO.link/src/go/types/scope.go
TYPE go/types.Selection:
  GO.link/src/go/types/selection.go
TYPE go/types.SelectionKind:
  GO.link/src/go/types/selection.go
TYPE go/types.Signature:
  GO.link/src/go/types/type.go
TYPE go/types.Sizes:
  GO.link/src/go/types/sizes.go
TYPE go/types.Slice:
  GO.link/src/go/types/type.go
TYPE go/types.StdSizes:
  GO.link/src/go/types/sizes.go
TYPE go/types.Struct:
  GO.link/src/go/types/type.go
TYPE go/types.Tuple:
  GO.link/src/go/types/type.go
TYPE go/types.Type:
  GO.link/src/go/types/type.go
TYPE go/types.TypeAndValue:
  GO.link/src/go/types/api.go
TYPE go/types.TypeName:
  GO.link/src/go/types/object.go
TYPE go/types.Var:
  GO.link/src/go/types/object.go
TYPE hash.Hash:
  GO.link/src/hash/hash.go
TYPE hash.Hash32:
  GO.link/src/hash/hash.go
TYPE hash.Hash64:
  GO.link/src/hash/hash.go
TYPE hash/crc32.Table:
  GO.link/src/hash/crc32/crc32.go
TYPE hash/crc64.Table:
  GO.link/src/hash/crc64/crc64.go
TYPE html/template.CSS:
  GO.link/src/html/template/content.go
TYPE html/template.Error:
  GO.link/src/html/template/error.go
TYPE html/template.ErrorCode:
  GO.link/src/html/template/error.go
TYPE html/template.FuncMap:
  GO.link/src/html/template/template.go
TYPE html/template.HTML:
  GO.link/src/html/template/content.go
TYPE html/template.HTMLAttr:
  GO.link/src/html/template/content.go
TYPE html/template.JS:
  GO.link/src/html/template/content.go
TYPE html/template.JSStr:
  GO.link/src/html/template/content.go
TYPE html/template.Srcset:
  GO.link/src/html/template/content.go
TYPE html/template.Template:
  GO.link/src/html/template/template.go
TYPE html/template.URL:
  GO.link/src/html/template/content.go
TYPE image.Alpha:
  GO.link/src/image/image.go
TYPE image.Alpha16:
  GO.link/src/image/image.go
TYPE image.CMYK:
  GO.link/src/image/image.go
TYPE image.Config:
  GO.link/src/image/image.go
TYPE image.Gray:
  GO.link/src/image/image.go
TYPE image.Gray16:
  GO.link/src/image/image.go
TYPE image.Image:
  GO.link/src/image/image.go
TYPE image.NRGBA:
  GO.link/src/image/image.go
TYPE image.NRGBA64:
  GO.link/src/image/image.go
TYPE image.NYCbCrA:
  GO.link/src/image/ycbcr.go
TYPE image.Paletted:
  GO.link/src/image/image.go
TYPE image.PalettedImage:
  GO.link/src/image/image.go
TYPE image.Point:
  GO.link/src/image/geom.go
TYPE image.RGBA:
  GO.link/src/image/image.go
TYPE image.RGBA64:
  GO.link/src/image/image.go
TYPE image.Rectangle:
  GO.link/src/image/geom.go
TYPE image.Uniform:
  GO.link/src/image/names.go
TYPE image.YCbCr:
  GO.link/src/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  GO.link/src/image/ycbcr.go
TYPE image/color.Alpha:
  GO.link/src/image/color/color.go
TYPE image/color.Alpha16:
  GO.link/src/image/color/color.go
TYPE image/color.CMYK:
  GO.link/src/image/color/ycbcr.go
TYPE image/color.Color:
  GO.link/src/image/color/color.go
TYPE image/color.Gray:
  GO.link/src/image/color/color.go
TYPE image/color.Gray16:
  GO.link/src/image/color/color.go
TYPE image/color.Model:
  GO.link/src/image/color/color.go
TYPE image/color.NRGBA:
  GO.link/src/image/color/color.go
TYPE image/color.NRGBA64:
  GO.link/src/image/color/color.go
TYPE image/color.NYCbCrA:
  GO.link/src/image/color/ycbcr.go
TYPE image/color.Palette:
  GO.link/src/image/color/color.go
TYPE image/color.RGBA:
  GO.link/src/image/color/color.go
TYPE image/color.RGBA64:
  GO.link/src/image/color/color.go
TYPE image/color.YCbCr:
  GO.link/src/image/color/ycbcr.go
TYPE image/draw.Drawer:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Image:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Op:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Quantizer:
  GO.link/src/image/draw/draw.go
TYPE image/gif.GIF:
  GO.link/src/image/gif/reader.go
TYPE image/gif.Options:
  GO.link/src/image/gif/writer.go
TYPE image/jpeg.FormatError:
  GO.link/src/image/jpeg/reader.go
TYPE image/jpeg.Options:
  GO.link/src/image/jpeg/writer.go
TYPE image/jpeg.Reader:
  GO.link/src/image/jpeg/reader.go
TYPE image/jpeg.UnsupportedError:
  GO.link/src/image/jpeg/reader.go
TYPE image/png.CompressionLevel:
  GO.link/src/image/png/writer.go
TYPE image/png.Encoder:
  GO.link/src/image/png/writer.go
TYPE image/png.EncoderBuffer:
  GO.link/src/image/png/writer.go
TYPE image/png.EncoderBufferPool:
  GO.link/src/image/png/writer.go
TYPE image/png.FormatError:
  GO.link/src/image/png/reader.go
TYPE image/png.UnsupportedError:
  GO.link/src/image/png/reader.go
TYPE index/suffixarray.Index:
  GO.link/src/index/suffixarray/suffixarray.go
TYPE io.ByteReader:
  GO.link/src/io/io.go
TYPE io.ByteScanner:
  GO.link/src/io/io.go
TYPE io.ByteWriter:
  GO.link/src/io/io.go
TYPE io.Closer:
  GO.link/src/io/io.go
TYPE io.LimitedReader:
  GO.link/src/io/io.go
TYPE io.PipeReader:
  GO.link/src/io/pipe.go
TYPE io.PipeWriter:
  GO.link/src/io/pipe.go
TYPE io.ReadCloser:
  GO.link/src/io/io.go
TYPE io.ReadSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriteCloser:
  GO.link/src/io/io.go
TYPE io.ReadWriteSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriter:
  GO.link/src/io/io.go
TYPE io.Reader:
  GO.link/src/io/io.go
TYPE io.ReaderAt:
  GO.link/src/io/io.go
TYPE io.ReaderFrom:
  GO.link/src/io/io.go
TYPE io.RuneReader:
  GO.link/src/io/io.go
TYPE io.RuneScanner:
  GO.link/src/io/io.go
TYPE io.SectionReader:
  GO.link/src/io/io.go
TYPE io.Seeker:
  GO.link/src/io/io.go
TYPE io.WriteCloser:
  GO.link/src/io/io.go
TYPE io.WriteSeeker:
  GO.link/src/io/io.go
TYPE io.Writer:
  GO.link/src/io/io.go
TYPE io.WriterAt:
  GO.link/src/io/io.go
TYPE io.WriterTo:
  GO.link/src/io/io.go
TYPE log.Logger:
  GO.link/src/log/log.go
TYPE log/syslog.Priority:
  GO.link/src/log/syslog/syslog.go
TYPE log/syslog.Writer:
  GO.link/src/log/syslog/syslog.go
TYPE math/big.Accuracy:
  GO.link/src/math/big/float.go
TYPE math/big.ErrNaN:
  GO.link/src/math/big/float.go
TYPE math/big.Float:
  GO.link/src/math/big/float.go
TYPE math/big.Int:
  GO.link/src/math/big/int.go
TYPE math/big.Rat:
  GO.link/src/math/big/rat.go
TYPE math/big.RoundingMode:
  GO.link/src/math/big/float.go
TYPE math/big.Word:
  GO.link/src/math/big/arith.go
TYPE math/rand.Rand:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Source:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Source64:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Zipf:
  GO.link/src/math/rand/zipf.go
TYPE mime.WordDecoder:
  GO.link/src/mime/encodedword.go
TYPE mime.WordEncoder:
  GO.link/src/mime/encodedword.go
TYPE mime/multipart.File:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.FileHeader:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.Form:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.Part:
  GO.link/src/mime/multipart/multipart.go
TYPE mime/multipart.Reader:
  GO.link/src/mime/multipart/multipart.go
TYPE mime/multipart.Writer:
  GO.link/src/mime/multipart/writer.go
TYPE mime/quotedprintable.Reader:
  GO.link/src/mime/quotedprintable/reader.go
TYPE mime/quotedprintable.Writer:
  GO.link/src/mime/quotedprintable/writer.go
TYPE net.Addr:
  GO.link/src/net/net.go
TYPE net.AddrError:
  GO.link/src/net/net.go
TYPE net.Buffers:
  GO.link/src/net/net.go
TYPE net.Conn:
  GO.link/src/net/net.go
TYPE net.DNSConfigError:
  GO.link/src/net/net.go
TYPE net.DNSError:
  GO.link/src/net/net.go
TYPE net.Dialer:
  GO.link/src/net/dial.go
TYPE net.Error:
  GO.link/src/net/net.go
TYPE net.Flags:
  GO.link/src/net/interface.go
TYPE net.HardwareAddr:
  GO.link/src/net/mac.go
TYPE net.IP:
  GO.link/src/net/ip.go
TYPE net.IPAddr:
  GO.link/src/net/iprawsock.go
TYPE net.IPConn:
  GO.link/src/net/iprawsock.go
TYPE net.IPMask:
  GO.link/src/net/ip.go
TYPE net.IPNet:
  GO.link/src/net/ip.go
TYPE net.Interface:
  GO.link/src/net/interface.go
TYPE net.InvalidAddrError:
  GO.link/src/net/net.go
TYPE net.ListenConfig:
  GO.link/src/net/dial.go
TYPE net.Listener:
  GO.link/src/net/net.go
TYPE net.MX:
  GO.link/src/net/dnsclient.go
TYPE net.NS:
  GO.link/src/net/dnsclient.go
TYPE net.OpError:
  GO.link/src/net/net.go
TYPE net.PacketConn:
  GO.link/src/net/net.go
TYPE net.ParseError:
  GO.link/src/net/net.go
TYPE net.Resolver:
  GO.link/src/net/lookup.go
TYPE net.SRV:
  GO.link/src/net/dnsclient.go
TYPE net.TCPAddr:
  GO.link/src/net/tcpsock.go
TYPE net.TCPConn:
  GO.link/src/net/tcpsock.go
TYPE net.TCPListener:
  GO.link/src/net/tcpsock.go
TYPE net.UDPAddr:
  GO.link/src/net/udpsock.go
TYPE net.UDPConn:
  GO.link/src/net/udpsock.go
TYPE net.UnixAddr:
  GO.link/src/net/unixsock.go
TYPE net.UnixConn:
  GO.link/src/net/unixsock.go
TYPE net.UnixListener:
  GO.link/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  GO.link/src/net/net.go
TYPE net/http.Client:
  GO.link/src/net/http/client.go
TYPE net/http.CloseNotifier:
  GO.link/src/net/http/server.go
TYPE net/http.ConnState:
  GO.link/src/net/http/server.go
TYPE net/http.Cookie:
  GO.link/src/net/http/cookie.go
TYPE net/http.CookieJar:
  GO.link/src/net/http/jar.go
TYPE net/http.Dir:
  GO.link/src/net/http/fs.go
TYPE net/http.File:
  GO.link/src/net/http/fs.go
TYPE net/http.FileSystem:
  GO.link/src/net/http/fs.go
TYPE net/http.Flusher:
  GO.link/src/net/http/server.go
TYPE net/http.Handler:
  GO.link/src/net/http/server.go
TYPE net/http.HandlerFunc:
  GO.link/src/net/http/server.go
TYPE net/http.Header:
  GO.link/src/net/http/header.go
TYPE net/http.Hijacker:
  GO.link/src/net/http/server.go
TYPE net/http.ProtocolError:
  GO.link/src/net/http/request.go
TYPE net/http.PushOptions:
  GO.link/src/net/http/http.go
TYPE net/http.Pusher:
  GO.link/src/net/http/http.go
TYPE net/http.Request:
  GO.link/src/net/http/request.go
TYPE net/http.Response:
  GO.link/src/net/http/response.go
TYPE net/http.ResponseWriter:
  GO.link/src/net/http/server.go
TYPE net/http.RoundTripper:
  GO.link/src/net/http/client.go
TYPE net/http.SameSite:
  GO.link/src/net/http/cookie.go
TYPE net/http.ServeMux:
  GO.link/src/net/http/server.go
TYPE net/http.Server:
  GO.link/src/net/http/server.go
TYPE net/http.Transport:
  GO.link/src/net/http/transport.go
TYPE net/http/cgi.Handler:
  GO.link/src/net/http/cgi/host.go
TYPE net/http/cookiejar.Jar:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.Options:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.PublicSuffixList:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/httptest.ResponseRecorder:
  GO.link/src/net/http/httptest/recorder.go
TYPE net/http/httptest.Server:
  GO.link/src/net/http/httptest/server.go
TYPE net/http/httptrace.ClientTrace:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSDoneInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSStartInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.GotConnInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.WroteRequestInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httputil.BufferPool:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ClientConn:
  GO.link/src/net/http/httputil/persist.go
TYPE net/http/httputil.ReverseProxy:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ServerConn:
  GO.link/src/net/http/httputil/persist.go
TYPE net/mail.Address:
  GO.link/src/net/mail/message.go
TYPE net/mail.AddressParser:
  GO.link/src/net/mail/message.go
TYPE net/mail.Header:
  GO.link/src/net/mail/message.go
TYPE net/mail.Message:
  GO.link/src/net/mail/message.go
TYPE net/rpc.Call:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.Client:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.ClientCodec:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.Request:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.Response:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.Server:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.ServerCodec:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.ServerError:
  GO.link/src/net/rpc/client.go
TYPE net/smtp.Auth:
  GO.link/src/net/smtp/auth.go
TYPE net/smtp.Client:
  GO.link/src/net/smtp/smtp.go
TYPE net/smtp.ServerInfo:
  GO.link/src/net/smtp/auth.go
TYPE net/textproto.Conn:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.Error:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.MIMEHeader:
  GO.link/src/net/textproto/header.go
TYPE net/textproto.Pipeline:
  GO.link/src/net/textproto/pipeline.go
TYPE net/textproto.ProtocolError:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.Reader:
  GO.link/src/net/textproto/reader.go
TYPE net/textproto.Writer:
  GO.link/src/net/textproto/writer.go
TYPE net/url.Error:
  GO.link/src/net/url/url.go
TYPE net/url.EscapeError:
  GO.link/src/net/url/url.go
TYPE net/url.InvalidHostError:
  GO.link/src/net/url/url.go
TYPE net/url.URL:
  GO.link/src/net/url/url.go
TYPE net/url.Userinfo:
  GO.link/src/net/url/url.go
TYPE net/url.Values:
  GO.link/src/net/url/url.go
TYPE os.File:
  GO.link/src/os/types.go
TYPE os.FileInfo:
  GO.link/src/os/types.go
TYPE os.FileMode:
  GO.link/src/os/types.go
TYPE os.LinkError:
  GO.link/src/os/file.go
TYPE os.PathError:
  GO.link/src/os/error.go
TYPE os.ProcAttr:
  GO.link/src/os/exec.go
TYPE os.Process:
  GO.link/src/os/exec.go
TYPE os.ProcessState:
  GO.link/src/os/exec_posix.go
TYPE os.Signal:
  GO.link/src/os/exec.go
TYPE os.SyscallError:
  GO.link/src/os/error.go
TYPE os/exec.Cmd:
  GO.link/src/os/exec/exec.go
TYPE os/exec.Error:
  GO.link/src/os/exec/exec.go
TYPE os/exec.ExitError:
  GO.link/src/os/exec/exec.go
TYPE os/user.Group:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownGroupError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownGroupIdError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownUserError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownUserIdError:
  GO.link/src/os/user/user.go
TYPE os/user.User:
  GO.link/src/os/user/user.go
TYPE path/filepath.WalkFunc:
  GO.link/src/path/filepath/path.go
TYPE plugin.Plugin:
  GO.link/src/plugin/plugin.go
TYPE plugin.Symbol:
  GO.link/src/plugin/plugin.go
TYPE reflect.ChanDir:
  GO.link/src/reflect/type.go
TYPE reflect.Kind:
  GO.link/src/reflect/type.go
TYPE reflect.Method:
  GO.link/src/reflect/type.go
TYPE reflect.SelectCase:
  GO.link/src/reflect/value.go
TYPE reflect.SelectDir:
  GO.link/src/reflect/value.go
TYPE reflect.SliceHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StringHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StructField:
  GO.link/src/reflect/type.go
TYPE reflect.StructTag:
  GO.link/src/reflect/type.go
TYPE reflect.Type:
  GO.link/src/reflect/type.go
TYPE reflect.Value:
  GO.link/src/reflect/value.go
TYPE reflect.ValueError:
  GO.link/src/reflect/value.go
TYPE regexp.Regexp:
  GO.link/src/regexp/regexp.go
TYPE regexp/syntax.EmptyOp:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Error:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.ErrorCode:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.Flags:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.Inst:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.InstOp:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Op:
  GO.link/src/regexp/syntax/regexp.go
TYPE regexp/syntax.Prog:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Regexp:
  GO.link/src/regexp/syntax/regexp.go
TYPE runtime.BlockProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.Error:
  GO.link/src/runtime/error.go
TYPE runtime.Frame:
  GO.link/src/runtime/symtab.go
TYPE runtime.Frames:
  GO.link/src/runtime/symtab.go
TYPE runtime.Func:
  GO.link/src/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.MemStats:
  GO.link/src/runtime/mstats.go
TYPE runtime.StackRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  GO.link/src/runtime/error.go
TYPE runtime/debug.GCStats:
  GO.link/src/runtime/debug/garbage.go
TYPE runtime/pprof.LabelSet:
  GO.link/src/runtime/pprof/label.go
TYPE runtime/pprof.Profile:
  GO.link/src/runtime/pprof/pprof.go
TYPE runtime/trace.Region:
  GO.link/src/runtime/trace/annotation.go
TYPE runtime/trace.Task:
  GO.link/src/runtime/trace/annotation.go
TYPE sort.Float64Slice:
  GO.link/src/sort/sort.go
TYPE sort.IntSlice:
  GO.link/src/sort/sort.go
TYPE sort.Interface:
  GO.link/src/sort/sort.go
TYPE sort.StringSlice:
  GO.link/src/sort/sort.go
TYPE strconv.NumError:
  GO.link/src/strconv/atoi.go
TYPE strings.Builder:
  GO.link/src/strings/builder.go
TYPE strings.Reader:
  GO.link/src/strings/reader.go
TYPE strings.Replacer:
  GO.link/src/strings/replace.go
TYPE sync.Cond:
  GO.link/src/sync/cond.go
TYPE sync.Locker:
  GO.link/src/sync/mutex.go
TYPE sync.Map:
  GO.link/src/sync/map.go
TYPE sync.Mutex:
  GO.link/src/sync/mutex.go
TYPE sync.Once:
  GO.link/src/sync/once.go
TYPE sync.Pool:
  GO.link/src/sync/pool.go
TYPE sync.RWMutex:
  GO.link/src/sync/rwmutex.go
TYPE sync.WaitGroup:
  GO.link/src/sync/waitgroup.go
TYPE sync/atomic.Value:
  GO.link/src/sync/atomic/value.go
TYPE syscall.BpfHdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfInsn:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfProgram:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfStat:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.BpfVersion:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Cmsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Conn:
  GO.link/src/syscall/net.go
TYPE syscall.Credential:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.Dirent:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Errno:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.Fbootstraptransfer_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.FdSet:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Flock_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fsid:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Fstore_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.ICMPv6Filter:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPMreq:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6MTUInfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IPv6Mreq:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfData:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfaMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.IfmaMsghdr2:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet4Pktinfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Inet6Pktinfo:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.InterfaceAddrMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.InterfaceMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.InterfaceMulticastAddrMessage:
  GO.link/src/syscall/route_darwin.go
TYPE syscall.Iovec:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Kevent_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Linger:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Log2phys_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Msghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.ProcAttr:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.Radvisory_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawConn:
  GO.link/src/syscall/net.go
TYPE syscall.RawSockaddr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrAny:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrDatalink:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet4:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrInet6:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RawSockaddrUnix:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rlimit:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RouteMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.RoutingMessage:
  GO.link/src/syscall/route_bsd.go
TYPE syscall.RtMetrics:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.RtMsghdr:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Rusage:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Signal:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.Sockaddr:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrDatalink:
  GO.link/src/syscall/syscall_darwin.go
TYPE syscall.SockaddrInet4:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrUnix:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  GO.link/src/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Statfs_t:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.SysProcAttr:
  GO.link/src/syscall/exec_bsd.go
TYPE syscall.Termios:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timespec:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.Timeval32:
  GO.link/src/syscall/ztypes_darwin_amd64.go
TYPE syscall.WaitStatus:
  GO.link/src/syscall/syscall_bsd.go
TYPE testing.B:
  GO.link/src/testing/benchmark.go
TYPE testing.BenchmarkResult:
  GO.link/src/testing/benchmark.go
TYPE testing.Cover:
  GO.link/src/testing/cover.go
TYPE testing.CoverBlock:
  GO.link/src/testing/cover.go
TYPE testing.InternalBenchmark:
  GO.link/src/testing/benchmark.go
TYPE testing.InternalExample:
  GO.link/src/testing/example.go
TYPE testing.InternalTest:
  GO.link/src/testing/testing.go
TYPE testing.M:
  GO.link/src/testing/testing.go
TYPE testing.PB:
  GO.link/src/testing/benchmark.go
TYPE testing.T:
  GO.link/src/testing/testing.go
TYPE testing.TB:
  GO.link/src/testing/testing.go
TYPE testing/quick.CheckEqualError:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.CheckError:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.Config:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.Generator:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.SetupError:
  GO.link/src/testing/quick/quick.go
TYPE text/scanner.Position:
  GO.link/src/text/scanner/scanner.go
TYPE text/scanner.Scanner:
  GO.link/src/text/scanner/scanner.go
TYPE text/tabwriter.Writer:
  GO.link/src/text/tabwriter/tabwriter.go
TYPE text/template.ExecError:
  GO.link/src/text/template/exec.go
TYPE text/template.FuncMap:
  GO.link/src/text/template/funcs.go
TYPE text/template.Template:
  GO.link/src/text/template/template.go
TYPE text/template/parse.ActionNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.BoolNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.BranchNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.ChainNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.CommandNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.DotNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.FieldNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.IdentifierNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.IfNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.ListNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NilNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Node:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NodeType:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NumberNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.PipeNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Pos:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.RangeNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.StringNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.TemplateNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.TextNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Tree:
  GO.link/src/text/template/parse/parse.go
TYPE text/template/parse.VariableNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.WithNode:
  GO.link/src/text/template/parse/node.go
TYPE time.Duration:
  GO.link/src/time/time.go
TYPE time.Location:
  GO.link/src/time/zoneinfo.go
TYPE time.Month:
  GO.link/src/time/time.go
TYPE time.ParseError:
  GO.link/src/time/format.go
TYPE time.Ticker:
  GO.link/src/time/tick.go
TYPE time.Time:
  GO.link/src/time/time.go
TYPE time.Timer:
  GO.link/src/time/sleep.go
TYPE time.Weekday:
  GO.link/src/time/time.go
TYPE unicode.CaseRange:
  GO.link/src/unicode/letter.go
TYPE unicode.Range16:
  GO.link/src/unicode/letter.go
TYPE unicode.Range32:
  GO.link/src/unicode/letter.go
TYPE unicode.RangeTable:
  GO.link/src/unicode/letter.go
TYPE unicode.SpecialCase:
  GO.link/src/unicode/letter.go
TYPE unsafe.ArbitraryType:
  GO.link/src/unsafe/unsafe.go
TYPE unsafe.Pointer:
  GO.link/src/unsafe/unsafe.go
JOKER FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo input arguments: (fi os.FileInfo, link string)\n\nGo return type: (*Header, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi, ^String link]\n\nJoker return type: [(atom-of go.std.archive.tar/Header) Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(_fi.(ABEND987(imports not yet supported: os.FileInfo)), _link)"}
;;   [^GoObject _fi, ^String _link])

JOKER FUNC archive/tar.NewReader from archive/tar/reader.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.archive.tar/Reader)"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC archive/tar.NewWriter from archive/tar/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.tar/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo input arguments: (fi os.FileInfo)\n\nGo return type: (*FileHeader, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi]\n\nJoker return type: [(atom-of go.std.archive.zip/FileHeader) Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(_fi.(ABEND987(imports not yet supported: os.FileInfo)))"}
;;   [^GoObject _fi])

JOKER FUNC archive/zip.NewReader from archive/zip/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo input arguments: (r io.ReaderAt, size int64)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Int64 size]\n\nJoker return type: [(atom-of go.std.archive.zip/Reader) Error]"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.ReaderAt)), _size)"}
;;   [^GoObject _r, ^Int64 _size])

JOKER FUNC archive/zip.NewWriter from archive/zip/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.zip/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC archive/zip.OpenReader from archive/zip/reader.go:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo input arguments: (name string)\n\nGo return type: (*ReadCloser, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.archive.zip/ReadCloser) Error]"
  {:added "1.0"
   :go "openReader(_name)"}
  [^String _name])

JOKER FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, comp Compressor)\n\nJoker input arguments: [^UInt16 method, ^go.std.archive.zip/Compressor comp]"
;;   {:added "1.0"
;;    :go "registerCompressor(_method, _comp.(zip.Compressor))"}
;;   [^UInt16 _method, ^GoObject _comp])

JOKER FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, dcomp Decompressor)\n\nJoker input arguments: [^UInt16 method, ^go.std.archive.zip/Decompressor dcomp]"
;;   {:added "1.0"
;;    :go "registerDecompressor(_method, _dcomp.(zip.Decompressor))"}
;;   [^UInt16 _method, ^GoObject _dcomp])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the archive/zip package."
    :empty false}
  go.std.archive.zip)
JOKER FUNC bufio.NewReadWriter from bufio/bufio.go:
;; (defn NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo input arguments: (r *Reader, w *Writer)\n\nGo return type: *ReadWriter\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.bufio/ReadWriter)"
;;   {:added "1.0"
;;    :go "newReadWriter(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_bufio.Reader(_r.(bufio.Reader))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_bufio.Writer(_w.(bufio.Writer))))"}
;;   [^Object _r, ^Object _w])

JOKER FUNC bufio.NewReader from bufio/bufio.go:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo input arguments: (rd io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "newReader(_rd.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _rd])

JOKER FUNC bufio.NewReaderSize from bufio/bufio.go:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo input arguments: (rd io.Reader, size int)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "newReaderSize(_rd.(ABEND987(imports not yet supported: io.Reader)), _size)"}
;;   [^GoObject _rd, ^Int _size])

JOKER FUNC bufio.NewScanner from bufio/scan.go:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Scanner\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.bufio/Scanner)"
;;   {:added "1.0"
;;    :go "newScanner(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC bufio.NewWriter from bufio/bufio.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC bufio.NewWriterSize from bufio/bufio.go:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo input arguments: (w io.Writer, size int)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "newWriterSize(_w.(ABEND987(imports not yet supported: io.Writer)), _size)"}
;;   [^GoObject _w, ^Int _size])

JOKER FUNC bufio.ScanBytes from bufio/scan.go:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of ) Error]"
;;   {:added "1.0"
;;    :go "scanBytes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanLines from bufio/scan.go:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of ) Error]"
;;   {:added "1.0"
;;    :go "scanLines(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanRunes from bufio/scan.go:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of ) Error]"
;;   {:added "1.0"
;;    :go "scanRunes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanWords from bufio/scan.go:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of ) Error]"
;;   {:added "1.0"
;;    :go "scanWords(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _atEOF)"}
;;   [^Object _data, ^Bool _atEOF])

JOKER FUNC bytes.Compare from bytes/bytes_decl.go:
;; (defn ^"Int" Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Compare(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_a)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _a, ^Object _b])

JOKER FUNC bytes.Contains from bytes/bytes.go:
;; (defn ^"Bool" Contains
;;   "Contains reports whether subslice is within b.\n\nGo input arguments: (b []byte, subslice []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^(vector-of Byte) subslice]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.Contains(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_subslice)))"}
;;   [^Object _b, ^Object _subslice])

JOKER FUNC bytes.ContainsAny from bytes/bytes.go:
;; (defn ^"Bool" ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo input arguments: (b []byte, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^String chars]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.ContainsAny(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _chars)"}
;;   [^Object _b, ^String _chars])

JOKER FUNC bytes.ContainsRune from bytes/bytes.go:
;; (defn ^"Bool" ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo input arguments: (b []byte, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _r)"}
;;   [^Object _b, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC bytes.Count from bytes/bytes.go:
;; (defn ^"Int" Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Count(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.Equal from bytes/bytes_decl.go:
;; (defn ^"Bool" Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.Equal(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_a)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _a, ^Object _b])

JOKER FUNC bytes.EqualFold from bytes/bytes.go:
;; (defn ^"Bool" EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s []byte, t []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) t]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.EqualFold(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_t)))"}
;;   [^Object _s, ^Object _t])

JOKER FUNC bytes.Fields from bytes/bytes.go:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "fields(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.FieldsFunc from bytes/bytes.go:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "fieldsFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.HasPrefix from bytes/bytes.go:
;; (defn ^"Bool" HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.HasPrefix(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_prefix)))"}
;;   [^Object _s, ^Object _prefix])

JOKER FUNC bytes.HasSuffix from bytes/bytes.go:
;; (defn ^"Bool" HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.HasSuffix(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_suffix)))"}
;;   [^Object _s, ^Object _suffix])

JOKER FUNC bytes.Index from bytes/bytes.go:
;; (defn ^"Int" Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Index(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.IndexAny from bytes/bytes.go:
;; (defn ^"Int" IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexAny(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _chars)"}
;;   [^Object _s, ^String _chars])

JOKER FUNC bytes.IndexByte from bytes/bytes_decl.go:
;; (defn ^"Int" IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo input arguments: (b []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) b, ^Byte c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexByte(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _c)"}
;;   [^Object _b, ^Byte _c])

JOKER FUNC bytes.IndexFunc from bytes/bytes.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.IndexRune from bytes/bytes.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _r)"}
;;   [^Object _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC bytes.Join from bytes/bytes.go:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo input arguments: (s [][]byte, sep []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of (vector-of Byte)) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "join(ConvertToArrayOf[]byte(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndex from bytes/bytes.go:
;; (defn ^"Int" LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndex(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndexAny from bytes/bytes.go:
;; (defn ^"Int" LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexAny(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _chars)"}
;;   [^Object _s, ^String _chars])

JOKER FUNC bytes.LastIndexByte from bytes/bytes.go:
;; (defn ^"Int" LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^Byte c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexByte(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _c)"}
;;   [^Object _s, ^Byte _c])

JOKER FUNC bytes.LastIndexFunc from bytes/bytes.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.Map from bytes/bytes.go:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo input arguments: (mapping func, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^fn mapping, ^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "_map(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^fn _mapping, ^Object _s])

JOKER FUNC bytes.NewBuffer from bytes/buffer.go:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (buf []byte)\n\nGo return type: *Buffer\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
;;   {:added "1.0"
;;    :go "newBuffer(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC bytes.NewBufferString from bytes/buffer.go:
(defn NewBufferString
  "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (s string)\n\nGo return type: *Buffer\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
  {:added "1.0"
   :go "newBufferString(_s)"}
  [^String _s])

JOKER FUNC bytes.NewReader from bytes/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo input arguments: (b []byte)\n\nGo return type: *Reader\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (atom-of go.std.bytes/Reader)"
;;   {:added "1.0"
;;    :go "newReader(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC bytes.Repeat from bytes/bytes.go:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo input arguments: (b []byte, count int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) b, ^Int count]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "repeat(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _count)"}
;;   [^Object _b, ^Int _count])

JOKER FUNC bytes.Replace from bytes/bytes.go:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s []byte, old []byte, new []byte, n int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) old, ^(vector-of Byte) new, ^Int n]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "replace(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_old)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_new)), _n)"}
;;   [^Object _s, ^Object _old, ^Object _new, ^Int _n])

JOKER FUNC bytes.Runes from bytes/bytes.go:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo input arguments: (s []byte)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of ABEND043(unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "runes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.Split from bytes/bytes.go:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "split(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfter from bytes/bytes.go:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "splitAfter(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfterN from bytes/bytes.go:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "splitAfterN(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)), _n)"}
;;   [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.SplitN from bytes/bytes.go:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of ))"
;;   {:added "1.0"
;;    :go "splitN(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sep)), _n)"}
;;   [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.Title from bytes/bytes.go:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "title(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToLower from bytes/bytes.go:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toLower(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToLowerSpecial from bytes/bytes.go:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toLowerSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^GoObject _c, ^Object _s])

JOKER FUNC bytes.ToTitle from bytes/bytes.go:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toTitle(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToTitleSpecial from bytes/bytes.go:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toTitleSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^GoObject _c, ^Object _s])

JOKER FUNC bytes.ToUpper from bytes/bytes.go:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toUpper(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.ToUpperSpecial from bytes/bytes.go:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "toUpperSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^GoObject _c, ^Object _s])

JOKER FUNC bytes.Trim from bytes/bytes.go:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trim(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimFunc from bytes/bytes.go:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimLeft from bytes/bytes.go:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimLeft(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimLeftFunc from bytes/bytes.go:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimLeftFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimPrefix from bytes/bytes.go:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimPrefix(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_prefix)))"}
;;   [^Object _s, ^Object _prefix])

JOKER FUNC bytes.TrimRight from bytes/bytes.go:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimRight(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), _cutset)"}
;;   [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimRightFunc from bytes/bytes.go:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimRightFunc(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimSpace from bytes/bytes.go:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimSpace(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^Object _s])

JOKER FUNC bytes.TrimSuffix from bytes/bytes.go:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimSuffix(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_suffix)))"}
;;   [^Object _s, ^Object _suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the bytes package."
    :empty false}
  go.std.bytes)
JOKER FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC compress/flate.NewReader from compress/flate/inflate.go:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) dict]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "newReaderDict(_r.(ABEND987(imports not yet supported: io.Reader)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^GoObject _r, ^Object _dict])

JOKER FUNC compress/flate.NewWriter from compress/flate/deflate.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)), _level)"}
;;   [^GoObject _w, ^Int _level])

JOKER FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "newWriterDict(_w.(ABEND987(imports not yet supported: io.Writer)), _level, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^GoObject _w, ^Int _level, ^Object _dict])

JOKER FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.compress.gzip/Reader) Error]"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.gzip/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.gzip/Writer) Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(_w.(ABEND987(imports not yet supported: io.Writer)), _level)"}
;;   [^GoObject _w, ^Int _level])

JOKER FUNC compress/lzw.NewReader from compress/lzw/reader.go:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo input arguments: (r io.Reader, order Order, litWidth int)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)), _order.(lzw.Order), _litWidth)"}
;;   [^GoObject _r, ^GoObject _order, ^Int _litWidth])

JOKER FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo input arguments: (w io.Writer, order Order, litWidth int)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)), _order.(lzw.Order), _litWidth)"}
;;   [^GoObject _w, ^GoObject _order, ^Int _litWidth])

JOKER FUNC compress/zlib.NewReader from compress/zlib/reader.go:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) dict]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "newReaderDict(_r.(ABEND987(imports not yet supported: io.Reader)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^GoObject _r, ^Object _dict])

JOKER FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.zlib/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(_w.(ABEND987(imports not yet supported: io.Writer)), _level)"}
;;   [^GoObject _w, ^Int _level])

JOKER FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "newWriterLevelDict(_w.(ABEND987(imports not yet supported: io.Writer)), _level, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dict)))"}
;;   [^GoObject _w, ^Int _level, ^Object _dict])

JOKER FUNC container/heap.Fix from container/heap/heap.go:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]"
;;   {:added "1.0"
;;    :go "fix(_h.(heap.Interface), _i)"}
;;   [^GoObject _h, ^Int _i])

JOKER FUNC container/heap.Init from container/heap/heap.go:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n\nGo input arguments: (h Interface)\n\nJoker input arguments: [^go.std.container.heap/Interface h]"
;;   {:added "1.0"
;;    :go "init(_h.(heap.Interface))"}
;;   [^GoObject _h])

JOKER FUNC container/heap.Pop from container/heap/heap.go:
;; (defn Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\n\nGo input arguments: (h Interface)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:62:23)"
;;   {:added "1.0"
;;    :go "pop(_h.(heap.Interface))"}
;;   [^GoObject _h])

JOKER FUNC container/heap.Push from container/heap/heap.go:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, x interface {})\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "push(_h.(heap.Interface), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _h, ^<protocol-or-something> _x])

JOKER FUNC container/heap.Remove from container/heap/heap.go:
;; (defn Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:72:33)"
;;   {:added "1.0"
;;    :go "remove(_h.(heap.Interface), _i)"}
;;   [^GoObject _h, ^Int _i])

JOKER FUNC container/list.New from container/list/list.go:
(defn New
  "New returns an initialized list.\n\nGo return type: *List\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.container.list/List)"
  {:added "1.0"
   :go "_new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/list package."
    :empty false}
  go.std.container.list)
JOKER FUNC container/ring.New from container/ring/ring.go:
(defn New
  "New creates a ring of n elements.\n\nGo input arguments: (n int)\n\nGo return type: *Ring\n\nJoker input arguments: [^Int n]\n\nJoker return type: (atom-of go.std.container.ring/Ring)"
  {:added "1.0"
   :go "_new(_n)"}
  [^Int _n])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/ring package."
    :empty false}
  go.std.container.ring)
JOKER FUNC context.Background from context/context.go:
(defn Background
  "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "background()"}
  [])

JOKER FUNC context.TODO from context/context.go:
(defn TODO
  "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "tODO()"}
  [])

JOKER FUNC context.WithCancel from context/context.go:
(defn WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context)\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
  {:added "1.0"
   :go "withCancel(_parent.(context.Context))"}
  [^GoObject _parent])

JOKER FUNC context.WithDeadline from context/context.go:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context, d time.Time)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Time d]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "withDeadline(_parent.(context.Context), _d.(ABEND987(imports not yet supported: time.Time)))"}
;;   [^GoObject _parent, ^GoObject _d])

JOKER FUNC context.WithTimeout from context/context.go:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo input arguments: (parent Context, timeout time.Duration)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "withTimeout(_parent.(context.Context), _timeout.(ABEND987(imports not yet supported: time.Duration)))"}
;;   [^GoObject _parent, ^GoObject _timeout])

JOKER FUNC context.WithValue from context/context.go:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo input arguments: (parent Context, key interface {}, val interface {})\n\nGo return type: Context\n\nJoker input arguments: [^go.std.context/Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "withValue(_parent.(context.Context), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _parent, ^<protocol-or-something> _key, ^<protocol-or-something> _val])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["context"]
    :doc "Provides a low-level interface to the context package."
    :empty false}
  go.std.context)
JOKER FUNC crypto.RegisterHash from crypto/crypto.go:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n\nGo input arguments: (h Hash, f func)\n\nJoker input arguments: [^go.std.crypto/Hash h, ^fn f]"
;;   {:added "1.0"
;;    :go "registerHash(_h.(crypto.Hash), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _h, ^fn _f])

JOKER FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "newCipher(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "newCBCDecrypter(_b.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "newCBCEncrypter(_b.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "newCFBDecrypter(_block.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "newCFBEncrypter(_block.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "newCTR(_block.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
(defn NewGCM
  "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo input arguments: (cipher Block)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "newGCM(_cipher.(cipher.Block))"}
  [^GoObject _cipher])

JOKER FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
(defn NewGCMWithNonceSize
  "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo input arguments: (cipher Block, size int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int size]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "newGCMWithNonceSize(_cipher.(cipher.Block), _size)"}
  [^GoObject _cipher, ^Int _size])

JOKER FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
(defn NewGCMWithTagSize
  "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo input arguments: (cipher Block, tagSize int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int tagSize]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "newGCMWithTagSize(_cipher.(cipher.Block), _tagSize)"}
  [^GoObject _cipher, ^Int _tagSize])

JOKER FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Byte) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "newOFB(_b.(cipher.Block), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_iv)))"}
;;   [^GoObject _b, ^Object _iv])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/cipher"]
    :doc "Provides a low-level interface to the crypto/cipher package."
    :empty false}
  go.std.crypto.cipher)
JOKER FUNC crypto/des.NewCipher from crypto/des/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "newCipher(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "newTripleDESCipher(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo input arguments: (priv *PrivateKey, rand io.Reader)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^go.std.io/Reader rand]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_dsa.PrivateKey(_priv.(dsa.PrivateKey))), _rand.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^Object _priv, ^GoObject _rand])

JOKER FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo input arguments: (params *Parameters, rand io.Reader, sizes ParameterSizes)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/Parameters) params, ^go.std.io/Reader rand, ^go.std.crypto.dsa/ParameterSizes sizes]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_dsa.Parameters(_params.(dsa.Parameters))), _rand.(ABEND987(imports not yet supported: io.Reader)), _sizes.(dsa.ParameterSizes))"}
;;   [^Object _params, ^GoObject _rand, ^GoObject _sizes])

JOKER FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "sign(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_dsa.PrivateKey(_priv.(dsa.PrivateKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)))"}
;;   [^GoObject _rand, ^Object _priv, ^Object _hash])

JOKER FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
;; (defn ^"Bool" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "dsa.Verify(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_dsa.PublicKey(_pub.(dsa.PublicKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)), ConvertToIndirectOfbig.Int(_r.(ABEND987(imports not yet supported: big.Int))), ConvertToIndirectOfbig.Int(_s.(ABEND987(imports not yet supported: big.Int))))"}
;;   [^Object _pub, ^Object _hash, ^Object _r, ^Object _s])

JOKER FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo input arguments: (c elliptic.Curve, rand io.Reader)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve c, ^go.std.io/Reader rand]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "generateKey(_c.(ABEND987(imports not yet supported: elliptic.Curve)), _rand.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _c, ^GoObject _rand])

JOKER FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.ecdsa/PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "sign(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ecdsa.PrivateKey(_priv.(ecdsa.PrivateKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)))"}
;;   [^GoObject _rand, ^Object _priv, ^Object _hash])

JOKER FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
;; (defn ^"Bool" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ecdsa.PublicKey(_pub.(ecdsa.PublicKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hash)), ConvertToIndirectOfbig.Int(_r.(ABEND987(imports not yet supported: big.Int))), ConvertToIndirectOfbig.Int(_s.(ABEND987(imports not yet supported: big.Int))))"}
;;   [^Object _pub, ^Object _hash, ^Object _r, ^Object _s])

JOKER FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo input arguments: (curve Curve, rand io.Reader)\n\nGo return type: (priv []byte, x *math/big.Int, y *math/big.Int, err error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^go.std.io/Reader rand]\n\nJoker return type: [(vector-of ) (atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "generateKey(_curve.(elliptic.Curve), _rand.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _curve, ^GoObject _rand])

JOKER FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo input arguments: (curve Curve, x *big.Int, y *big.Int)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "marshal(_curve.(elliptic.Curve), ConvertToIndirectOfbig.Int(_x.(ABEND987(imports not yet supported: big.Int))), ConvertToIndirectOfbig.Int(_y.(ABEND987(imports not yet supported: big.Int))))"}
;;   [^GoObject _curve, ^Object _x, ^Object _y])

JOKER FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
(defn P224
  "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "p224()"}
  [])

JOKER FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
(defn P256
  "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "p256()"}
  [])

JOKER FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
(defn P384
  "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "p384()"}
  [])

JOKER FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
(defn P521
  "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "p521()"}
  [])

JOKER FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo input arguments: (curve Curve, data []byte)\n\nGo return type: (x *math/big.Int, y *math/big.Int)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int)]"
;;   {:added "1.0"
;;    :go "unmarshal(_curve.(elliptic.Curve), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^GoObject _curve, ^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/elliptic package."
    :empty false}
  go.std.crypto.elliptic)
JOKER FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
;; (defn ^"Bool" Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n\nGo input arguments: (mac1 []byte, mac2 []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) mac1, ^(vector-of Byte) mac2]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "hmac.Equal(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_mac1)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_mac2)))"}
;;   [^Object _mac1, ^Object _mac2])

JOKER FUNC crypto/hmac.New from crypto/hmac/hmac.go:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo input arguments: (h func, key []byte)\n\nGo return type: hash.Hash\n\nJoker input arguments: [^fn h, ^(vector-of Byte) key]\n\nJoker return type: go.std.hash/Hash"
;;   {:added "1.0"
;;    :go "_new(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^fn _h, ^Object _key])

JOKER FUNC crypto/md5.New from crypto/md5/md5.go:
(defn New
  "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "_new()"}
  [])

JOKER FUNC crypto/md5.Sum from crypto/md5/md5.go:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/md5 package."
    :empty false}
  go.std.crypto.md5)
JOKER FUNC crypto/rand.Int from crypto/rand/util.go:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo input arguments: (rand io.Reader, max *big.Int)\n\nGo return type: (n *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.math.big/Int) max]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "_int(_rand.(ABEND987(imports not yet supported: io.Reader)), ConvertToIndirectOfbig.Int(_max.(ABEND987(imports not yet supported: big.Int))))"}
;;   [^GoObject _rand, ^Object _max])

JOKER FUNC crypto/rand.Prime from crypto/rand/util.go:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo input arguments: (rand io.Reader, bits int)\n\nGo return type: (p *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^Int bits]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "prime(_rand.(ABEND987(imports not yet supported: io.Reader)), _bits)"}
;;   [^GoObject _rand, ^Int _bits])

JOKER FUNC crypto/rand.Read from crypto/rand/rand.go:
;; (defn Read
;;   "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo input arguments: (b []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo input arguments: (key []byte)\n\nGo return type: (*Cipher, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [(atom-of go.std.crypto.rc4/Cipher) Error]"
;;   {:added "1.0"
;;    :go "newCipher(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^Object _key])

JOKER FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction  the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo input arguments: (hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "decryptOAEP(_hash.(ABEND987(imports not yet supported: hash.Hash)), _random.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PrivateKey(_priv.(rsa.PrivateKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_label)))"}
;;   [^GoObject _hash, ^GoObject _random, ^Object _priv, ^Object _ciphertext, ^Object _label])

JOKER FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PrivateKey(_priv.(rsa.PrivateKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)))"}
;;   [^GoObject _rand, ^Object _priv, ^Object _ciphertext])

JOKER FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) key]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PrivateKey(_priv.(rsa.PrivateKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_ciphertext)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_key)))"}
;;   [^GoObject _rand, ^Object _priv, ^Object _ciphertext, ^Object _key])

JOKER FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo input arguments: (hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Byte) msg, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "encryptOAEP(_hash.(ABEND987(imports not yet supported: hash.Hash)), _random.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PublicKey(_pub.(rsa.PublicKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_label)))"}
;;   [^GoObject _hash, ^GoObject _random, ^Object _pub, ^Object _msg, ^Object _label])

JOKER FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo input arguments: (rand io.Reader, pub *PublicKey, msg []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Byte) msg]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PublicKey(_pub.(rsa.PublicKey))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^GoObject _rand, ^Object _pub, ^Object _msg])

JOKER FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo input arguments: (random io.Reader, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "generateKey(_random.(ABEND987(imports not yet supported: io.Reader)), _bits)"}
;;   [^GoObject _random, ^Int _bits])

JOKER FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo input arguments: (random io.Reader, nprimes int, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int nprimes, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(_random.(ABEND987(imports not yet supported: io.Reader)), _nprimes, _bits)"}
;;   [^GoObject _random, ^Int _nprimes, ^Int _bits])

JOKER FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "signPKCS1v15(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PrivateKey(_priv.(rsa.PrivateKey))), _hash.(ABEND987(imports not yet supported: crypto.Hash)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)))"}
;;   [^GoObject _rand, ^Object _priv, ^GoObject _hash, ^Object _hashed])

JOKER FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "signPSS(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PrivateKey(_priv.(rsa.PrivateKey))), _hash.(ABEND987(imports not yet supported: crypto.Hash)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PSSOptions(_opts.(rsa.PSSOptions))))"}
;;   [^GoObject _rand, ^Object _priv, ^GoObject _hash, ^Object _hashed, ^Object _opts])

JOKER FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PublicKey(_pub.(rsa.PublicKey))), _hash.(ABEND987(imports not yet supported: crypto.Hash)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sig)))"}
;;   [^Object _pub, ^GoObject _hash, ^Object _hashed, ^Object _sig])

JOKER FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
;; (defn ^"Error" VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PublicKey(_pub.(rsa.PublicKey))), _hash.(ABEND987(imports not yet supported: crypto.Hash)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_hashed)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_sig)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rsa.PSSOptions(_opts.(rsa.PSSOptions))))"}
;;   [^Object _pub, ^GoObject _hash, ^Object _hashed, ^Object _sig, ^Object _opts])

JOKER FUNC crypto/sha1.New from crypto/sha1/sha1.go:
(defn New
  "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "_new()"}
  [])

JOKER FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha1 package."
    :empty false}
  go.std.crypto.sha1)
JOKER FUNC crypto/sha256.New from crypto/sha256/sha256.go:
(defn New
  "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "_new()"}
  [])

JOKER FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
(defn New224
  "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new224()"}
  [])

JOKER FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum224(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum256(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha256 package."
    :empty false}
  go.std.crypto.sha256)
JOKER FUNC crypto/sha512.New from crypto/sha512/sha512.go:
(defn New
  "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "_new()"}
  [])

JOKER FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
(defn New384
  "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new384()"}
  [])

JOKER FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
(defn New512_224
  "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new512_224()"}
  [])

JOKER FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
(defn New512_256
  "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new512_256()"}
  [])

JOKER FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum384(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum512(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum512_224(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "sum512_256(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha512 package."
    :empty false}
  go.std.crypto.sha512)
JOKER FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeByteEq
;;   "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x uint8, y uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x, ^uint8 y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeByteEq(_x, _y)"}
;;   [^ABEND044(unsupported built-in type uint8) _x, ^ABEND044(unsupported built-in type uint8) _y])

JOKER FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\n\nGo input arguments: (x []byte, y []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) x, ^(vector-of Byte) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeCompare(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_x)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_y)))"}
;;   [^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n\nGo input arguments: (v int, x []byte, y []byte)\n\nJoker input arguments: [^Int v, ^(vector-of Byte) x, ^(vector-of Byte) y]"
;;   {:added "1.0"
;;    :go "constantTimeCopy(_v, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_x)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_y)))"}
;;   [^Int _v, ^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x int32, y int32)\n\nGo return type: int\n\nJoker input arguments: [^Int32 x, ^Int32 y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(_x, _y)"}
  [^Int32 _x, ^Int32 _y])

JOKER FUNC crypto/subtle.ConstantTimeLessOrEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo input arguments: (x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(_x, _y)"}
  [^Int _x, ^Int _y])

JOKER FUNC crypto/subtle.ConstantTimeSelect from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\n\nGo input arguments: (v int, x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int v, ^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(_v, _x, _y)"}
  [^Int _v, ^Int _x, ^Int _y])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/subtle"]
    :doc "Provides a low-level interface to the crypto/subtle package."
    :empty false}
  go.std.crypto.subtle)
JOKER FUNC crypto/tls.Client from crypto/tls/tls.go:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "client(_conn.(ABEND987(imports not yet supported: net.Conn)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^GoObject _conn, ^Object _config])

JOKER FUNC crypto/tls.Dial from crypto/tls/tls.go:
;; (defn Dial
;;   "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo input arguments: (network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _addr, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^String _network, ^String _addr, ^Object _config])

JOKER FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo input arguments: (dialer *net.Dialer, network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^(atom-of go.std.net/Dialer) dialer, ^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
;;   {:added "1.0"
;;    :go "dialWithDialer(ConvertToIndirectOfnet.Dialer(_dialer.(ABEND987(imports not yet supported: net.Dialer))), _network, _addr, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^Object _dialer, ^String _network, ^String _addr, ^Object _config])

JOKER FUNC crypto/tls.Listen from crypto/tls/tls.go:
;; (defn Listen
;;   "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (network string, laddr string, config *Config)\n\nGo return type: (net.Listener, error)\n\nJoker input arguments: [^String network, ^String laddr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "listen(_network, _laddr, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^String _network, ^String _laddr, ^Object _config])

JOKER FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
(defn LoadX509KeyPair
  "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo input arguments: (certFile string, keyFile string)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^String certFile, ^String keyFile]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
  {:added "1.0"
   :go "loadX509KeyPair(_certFile, _keyFile)"}
  [^String _certFile, ^String _keyFile])

JOKER FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
(defn NewLRUClientSessionCache
  "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo input arguments: (capacity int)\n\nGo return type: ClientSessionCache\n\nJoker input arguments: [^Int capacity]\n\nJoker return type: go.std.crypto.tls/ClientSessionCache"
  {:added "1.0"
   :go "newLRUClientSessionCache(_capacity)"}
  [^Int _capacity])

JOKER FUNC crypto/tls.NewListener from crypto/tls/tls.go:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (inner net.Listener, config *Config)\n\nGo return type: net.Listener\n\nJoker input arguments: [^go.std.net/Listener inner, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: go.std.net/Listener"
;;   {:added "1.0"
;;    :go "newListener(_inner.(ABEND987(imports not yet supported: net.Listener)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^GoObject _inner, ^Object _config])

JOKER FUNC crypto/tls.Server from crypto/tls/tls.go:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "server(_conn.(ABEND987(imports not yet supported: net.Conn)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_tls.Config(_config.(tls.Config))))"}
;;   [^GoObject _conn, ^Object _config])

JOKER FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo input arguments: (certPEMBlock []byte, keyPEMBlock []byte)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) certPEMBlock, ^(vector-of Byte) keyPEMBlock]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
;;   {:added "1.0"
;;    :go "x509KeyPair(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_certPEMBlock)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_keyPEMBlock)))"}
;;   [^Object _certPEMBlock, ^Object _keyPEMBlock])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/tls package."
    :empty false}
  go.std.crypto.tls)
JOKER FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo input arguments: (rand io.Reader, template *Certificate, parent *Certificate, pub interface {}, priv interface {})\n\nGo return type: (cert []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/Certificate) template, ^(atom-of go.std.crypto.x509/Certificate) parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "createCertificate(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_x509.Certificate(_template.(x509.Certificate))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_x509.Certificate(_parent.(x509.Certificate))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _rand, ^Object _template, ^Object _parent, ^<protocol-or-something> _pub, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nGo input arguments: (rand io.Reader, template *CertificateRequest, priv interface {})\n\nGo return type: (csr []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/CertificateRequest) template, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "createCertificateRequest(_rand.(ABEND987(imports not yet supported: io.Reader)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_x509.CertificateRequest(_template.(x509.CertificateRequest))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _rand, ^Object _template, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo input arguments: (b *pem.Block, password []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b, ^(vector-of Byte) password]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "decryptPEMBlock(ConvertToIndirectOfpem.Block(_b.(ABEND987(imports not yet supported: pem.Block))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_password)))"}
;;   [^Object _b, ^Object _password])

JOKER FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo input arguments: (rand io.Reader, blockType string, data []byte, password []byte, alg PEMCipher)\n\nGo return type: (*encoding/pem.Block, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^String blockType, ^(vector-of Byte) data, ^(vector-of Byte) password, ^go.std.crypto.x509/PEMCipher alg]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) Error]"
;;   {:added "1.0"
;;    :go "encryptPEMBlock(_rand.(ABEND987(imports not yet supported: io.Reader)), _blockType, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_password)), _alg.(x509.PEMCipher))"}
;;   [^GoObject _rand, ^String _blockType, ^Object _data, ^Object _password, ^GoObject _alg])

JOKER FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn ^"Bool" IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo input arguments: (b *pem.Block)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(ConvertToIndirectOfpem.Block(_b.(ABEND987(imports not yet supported: pem.Block))))"}
;;   [^Object _b])

JOKER FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo input arguments: (key *ecdsa.PrivateKey)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PrivateKey) key]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(ConvertToIndirectOfecdsa.PrivateKey(_key.(ABEND987(imports not yet supported: ecdsa.PrivateKey))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo input arguments: (key *rsa.PrivateKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PrivateKey) key]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(ConvertToIndirectOfrsa.PrivateKey(_key.(ABEND987(imports not yet supported: rsa.PrivateKey))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo input arguments: (key *rsa.PublicKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) key]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(ConvertToIndirectOfrsa.PublicKey(_key.(ABEND987(imports not yet supported: rsa.PublicKey))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo input arguments: (key interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> key]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _key])

JOKER FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo input arguments: (pub interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> pub]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _pub])

JOKER FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
(defn NewCertPool
  "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.crypto.x509/CertPool)"
  {:added "1.0"
   :go "newCertPool()"}
  [])

JOKER FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo input arguments: (crlBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Byte) crlBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "parseCRL(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_crlBytes)))"}
;;   [^Object _crlBytes])

JOKER FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/Certificate) Error]"
;;   {:added "1.0"
;;    :go "parseCertificate(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*CertificateRequest, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/CertificateRequest) Error]"
;;   {:added "1.0"
;;    :go "parseCertificateRequest(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: ([]*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(vector-of (atom-of go.std.crypto.x509/Certificate)) Error]"
;;   {:added "1.0"
;;    :go "parseCertificates(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_asn1Data)))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "parseDERCRL(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_derBytes)))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/ecdsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "parseECPrivateKey(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PublicKey, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PublicKey) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PublicKey(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo input arguments: (der []byte)\n\nGo return type: (key ..., err error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_der)))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (pub ..., err error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:55:47) Error]"
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_derBytes)))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.crypto.x509/CertPool) Error]"
  {:added "1.0"
   :go "systemCertPool()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/x509 package."
    :empty false}
  go.std.crypto.x509)
JOKER FUNC database/sql.Drivers from database/sql/sql.go:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "drivers()"}
  [])

JOKER FUNC database/sql.Named from database/sql/sql.go:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo input arguments: (name string, value interface {})\n\nGo return type: NamedArg\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]\n\nJoker return type: go.std.database.sql/NamedArg"
;;   {:added "1.0"
;;    :go "named(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER FUNC database/sql.Open from database/sql/sql.go:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (driverName string, dataSourceName string)\n\nGo return type: (*DB, error)\n\nJoker input arguments: [^String driverName, ^String dataSourceName]\n\nJoker return type: [(atom-of go.std.database.sql/DB) Error]"
  {:added "1.0"
   :go "open(_driverName, _dataSourceName)"}
  [^String _driverName, ^String _dataSourceName])

JOKER FUNC database/sql.OpenDB from database/sql/sql.go:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (c driver.Connector)\n\nGo return type: *DB\n\nJoker input arguments: [^go.std.database.sql.driver/Connector c]\n\nJoker return type: (atom-of go.std.database.sql/DB)"
;;   {:added "1.0"
;;    :go "openDB(_c.(ABEND987(imports not yet supported: driver.Connector)))"}
;;   [^GoObject _c])

JOKER FUNC database/sql.Register from database/sql/sql.go:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n\nGo input arguments: (name string, driver driver.Driver)\n\nJoker input arguments: [^String name, ^go.std.database.sql.driver/Driver driver]"
;;   {:added "1.0"
;;    :go "register(_name, _driver.(ABEND987(imports not yet supported: driver.Driver)))"}
;;   [^String _name, ^GoObject _driver])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the database/sql package."
    :empty false}
  go.std.database.sql)
JOKER FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
;; (defn ^"Bool" IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
;; (defn ^"Bool" IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsValue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC debug/dwarf.New from debug/dwarf/open.go:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo input arguments: (abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte)\n\nGo return type: (*Data, error)\n\nJoker input arguments: [^(vector-of Byte) abbrev, ^(vector-of Byte) aranges, ^(vector-of Byte) frame, ^(vector-of Byte) info, ^(vector-of Byte) line, ^(vector-of Byte) pubnames, ^(vector-of Byte) ranges, ^(vector-of Byte) str]\n\nJoker return type: [(atom-of go.std.debug.dwarf/Data) Error]"
;;   {:added "1.0"
;;    :go "_new(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_abbrev)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_aranges)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_frame)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_info)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_line)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_pubnames)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_ranges)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_str)))"}
;;   [^Object _abbrev, ^Object _aranges, ^Object _frame, ^Object _info, ^Object _line, ^Object _pubnames, ^Object _ranges, ^Object _str])

JOKER FUNC debug/elf.NewFile from debug/elf/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
;;   {:added "1.0"
;;    :go "newFile(_r.(ABEND987(imports not yet supported: io.ReaderAt)))"}
;;   [^GoObject _r])

JOKER FUNC debug/elf.Open from debug/elf/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC debug/elf.R_INFO from debug/elf/elf.go:
;; (defn R_INFO
;;   "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: ...\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "r_INFO(_sym, _typ)"}
;;   [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
(defn R_INFO32
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]"
  {:added "1.0"
   :go "r_INFO32(_sym, _typ)"}
  [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
(defn R_SYM32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 info]"
  {:added "1.0"
   :go "r_SYM32(_info)"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
;; (defn R_SYM64
;;   "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^uint64 info]"
;;   {:added "1.0"
;;    :go "r_SYM64(_info)"}
;;   [^ABEND044(unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
(defn R_TYPE32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 info]"
  {:added "1.0"
   :go "r_TYPE32(_info)"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
;; (defn R_TYPE64
;;   "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^uint64 info]"
;;   {:added "1.0"
;;    :go "r_TYPE64(_info)"}
;;   [^ABEND044(unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.ST_BIND from debug/elf/elf.go:
;; (defn ST_BIND
;;   "Go input arguments: (info uint8)\n\nGo return type: SymBind\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: go.std.debug.elf/SymBind"
;;   {:added "1.0"
;;    :go "sT_BIND(_info)"}
;;   [^ABEND044(unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_INFO from debug/elf/elf.go:
;; (defn ST_INFO
;;   "Go input arguments: (bind SymBind, typ SymType)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.debug.elf/SymBind bind, ^go.std.debug.elf/SymType typ]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "sT_INFO(_bind.(elf.SymBind), _typ.(elf.SymType))"}
;;   [^GoObject _bind, ^GoObject _typ])

JOKER FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
;; (defn ST_TYPE
;;   "Go input arguments: (info uint8)\n\nGo return type: SymType\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: go.std.debug.elf/SymType"
;;   {:added "1.0"
;;    :go "sT_TYPE(_info)"}
;;   [^ABEND044(unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
;; (defn ST_VISIBILITY
;;   "Go input arguments: (other uint8)\n\nGo return type: SymVis\n\nJoker input arguments: [^uint8 other]\n\nJoker return type: go.std.debug.elf/SymVis"
;;   {:added "1.0"
;;    :go "sT_VISIBILITY(_other)"}
;;   [^ABEND044(unsupported built-in type uint8) _other])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/elf package."
    :empty false}
  go.std.debug.elf)
JOKER FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo input arguments: (data []byte, text uint64)\n\nGo return type: *LineTable\n\nJoker input arguments: [^(vector-of Byte) data, ^uint64 text]\n\nJoker return type: (atom-of go.std.debug.gosym/LineTable)"
;;   {:added "1.0"
;;    :go "newLineTable(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _text)"}
;;   [^Object _data, ^ABEND044(unsupported built-in type uint64) _text])

JOKER FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo input arguments: (symtab []byte, pcln *LineTable)\n\nGo return type: (*Table, error)\n\nJoker input arguments: [^(vector-of Byte) symtab, ^(atom-of go.std.debug.gosym/LineTable) pcln]\n\nJoker return type: [(atom-of go.std.debug.gosym/Table) Error]"
;;   {:added "1.0"
;;    :go "newTable(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_symtab)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_gosym.LineTable(_pcln.(gosym.LineTable))))"}
;;   [^Object _symtab, ^Object _pcln])

JOKER FUNC debug/macho.NewFatFile from debug/macho/fat.go:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
;;   {:added "1.0"
;;    :go "newFatFile(_r.(ABEND987(imports not yet supported: io.ReaderAt)))"}
;;   [^GoObject _r])

JOKER FUNC debug/macho.NewFile from debug/macho/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
;;   {:added "1.0"
;;    :go "newFile(_r.(ABEND987(imports not yet supported: io.ReaderAt)))"}
;;   [^GoObject _r])

JOKER FUNC debug/macho.Open from debug/macho/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC debug/macho.OpenFat from debug/macho/fat.go:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo input arguments: (name string)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
  {:added "1.0"
   :go "openFat(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/macho package."
    :empty false}
  go.std.debug.macho)
JOKER FUNC debug/pe.NewFile from debug/pe/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
;;   {:added "1.0"
;;    :go "newFile(_r.(ABEND987(imports not yet supported: io.ReaderAt)))"}
;;   [^GoObject _r])

JOKER FUNC debug/pe.Open from debug/pe/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/pe package."
    :empty false}
  go.std.debug.pe)
JOKER FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
;;   {:added "1.0"
;;    :go "newFile(_r.(ABEND987(imports not yet supported: io.ReaderAt)))"}
;;   [^GoObject _r])

JOKER FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/plan9obj package."
    :empty false}
  go.std.debug.plan9obj)
JOKER FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo input arguments: (dst []byte, src []byte, flush bool)\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src, ^Bool flush]\n\nJoker return type: [Int Int Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)), _flush)"}
;;   [^Object _dst, ^Object _src, ^Bool _flush])

JOKER FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ascii85.Encode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/ascii85.MaxEncodedLen from encoding/ascii85/ascii85.go:
(defn ^"Int" MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newDecoder(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "newEncoder(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/ascii85"]
    :doc "Provides a low-level interface to the encoding/ascii85 package."
    :empty false}
  go.std.encoding.ascii85)
JOKER FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo input arguments: (val interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (val interface {}, params string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalWithParams(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^<protocol-or-something> _val, ^String _params])

JOKER FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo input arguments: (b []byte, val interface {})\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "unmarshal(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _b, ^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (b []byte, val interface {}, params string)\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "unmarshalWithParams(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^Object _b, ^<protocol-or-something> _val, ^String _params])

JOKER FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newDecoder(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_base32.Encoding(_enc.(base32.Encoding))), _r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^Object _enc, ^GoObject _r])

JOKER FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "newEncoder(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_base32.Encoding(_enc.(base32.Encoding))), _w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^Object _enc, ^GoObject _w])

JOKER FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
(defn NewEncoding
  "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base32/Encoding)"
  {:added "1.0"
   :go "newEncoding(_encoder)"}
  [^String _encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base32 package."
    :empty false}
  go.std.encoding.base32)
JOKER FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newDecoder(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_base64.Encoding(_enc.(base64.Encoding))), _r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^Object _enc, ^GoObject _r])

JOKER FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "newEncoder(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_base64.Encoding(_enc.(base64.Encoding))), _w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^Object _enc, ^GoObject _w])

JOKER FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
(defn NewEncoding
  "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base64/Encoding)"
  {:added "1.0"
   :go "newEncoding(_encoder)"}
  [^String _encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base64 package."
    :empty false}
  go.std.encoding.base64)
JOKER FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
;; (defn ^"Int" PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo input arguments: (buf []byte, x uint64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _x)"}
;;   [^Object _buf, ^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
;; (defn ^"Int" PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo input arguments: (buf []byte, x int64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutVarint(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _x)"}
;;   [^Object _buf, ^Int64 _x])

JOKER FUNC encoding/binary.Read from encoding/binary/binary.go:
;; (defn ^"Error" Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo input arguments: (r io.Reader, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(_r.(ABEND987(imports not yet supported: io.Reader)), _order.(binary.ByteOrder), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _r, ^GoObject _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Error]"
;;   {:added "1.0"
;;    :go "readUvarint(_r.(ABEND987(imports not yet supported: io.ByteReader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (int64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [ Error]"
;;   {:added "1.0"
;;    :go "readVarint(_r.(ABEND987(imports not yet supported: io.ByteReader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/binary.Size from encoding/binary/binary.go:
;; (defn ^"Int" Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo input arguments: (v interface {})\n\nGo return type: int\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (..., int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Int]"
;;   {:added "1.0"
;;    :go "uvarint(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC encoding/binary.Varint from encoding/binary/varint.go:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (int64, int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [ Int]"
;;   {:added "1.0"
;;    :go "varint(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC encoding/binary.Write from encoding/binary/binary.go:
;; (defn ^"Error" Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo input arguments: (w io.Writer, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(_w.(ABEND987(imports not yet supported: io.Writer)), _order.(binary.ByteOrder), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _w, ^GoObject _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/csv.NewReader from encoding/csv/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.csv/Reader)"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.csv/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.gob/Decoder)"
;;   {:added "1.0"
;;    :go "newDecoder(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.gob/Encoder)"
;;   {:added "1.0"
;;    :go "newEncoder(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC encoding/gob.Register from encoding/gob/type.go:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n\nGo input arguments: (value interface {})\n\nJoker input arguments: [^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _value])

JOKER FUNC encoding/gob.RegisterName from encoding/gob/type.go:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n\nGo input arguments: (name string, value interface {})\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "registerName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER FUNC encoding/hex.Decode from encoding/hex/hex.go:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: (int, error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "decodeString(_s)"}
  [^String _s])

JOKER FUNC encoding/hex.DecodedLen from encoding/hex/hex.go:
(defn ^"Int" DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo input arguments: (x int)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(_x)"}
  [^Int _x])

JOKER FUNC encoding/hex.Dump from encoding/hex/hex.go:
;; (defn ^"String" Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.Dump(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC encoding/hex.Dumper from encoding/hex/hex.go:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "dumper(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC encoding/hex.Encode from encoding/hex/hex.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "hex.Encode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
;; (defn ^"String" EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n\nGo input arguments: (src []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.EncodeToString(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _src])

JOKER FUNC encoding/hex.EncodedLen from encoding/hex/hex.go:
(defn ^"Int" EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newDecoder(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "newEncoder(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/hex"]
    :doc "Provides a low-level interface to the encoding/hex package."
    :empty false}
  go.std.encoding.hex)
JOKER FUNC encoding/json.Compact from encoding/json/indent.go:
;; (defn ^"Error" Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(ConvertToIndirectOfbytes.Buffer(_dst.(ABEND987(imports not yet supported: bytes.Buffer))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src]"
;;   {:added "1.0"
;;    :go "hTMLEscape(ConvertToIndirectOfbytes.Buffer(_dst.(ABEND987(imports not yet supported: bytes.Buffer))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/json.Indent from encoding/json/indent.go:
;; (defn ^"Error" Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo input arguments: (dst *bytes.Buffer, src []byte, prefix string, indent string)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Byte) src, ^String prefix, ^String indent]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(ConvertToIndirectOfbytes.Buffer(_dst.(ABEND987(imports not yet supported: bytes.Buffer))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)), _prefix, _indent)"}
;;   [^Object _dst, ^Object _src, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.Marshal from encoding/json/encode.go:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.NewDecoder from encoding/json/stream.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.json/Decoder)"
;;   {:added "1.0"
;;    :go "newDecoder(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/json.NewEncoder from encoding/json/stream.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.json/Encoder)"
;;   {:added "1.0"
;;    :go "newEncoder(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC encoding/json.Unmarshal from encoding/json/decode.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

JOKER FUNC encoding/json.Valid from encoding/json/scanner.go:
;; (defn ^"Bool" Valid
;;   "Valid reports whether data is a valid JSON encoding.\n\nGo input arguments: (data []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "json.Valid(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC encoding/pem.Decode from encoding/pem/pem.go:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo input arguments: (data []byte)\n\nGo return type: (p *Block, rest []byte)\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) (vector-of )]"
;;   {:added "1.0"
;;    :go "decode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC encoding/pem.Encode from encoding/pem/pem.go:
;; (defn ^"Error" Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo input arguments: (out io.Writer, b *Block)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer out, ^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(_out.(ABEND987(imports not yet supported: io.Writer)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pem.Block(_b.(pem.Block))))"}
;;   [^GoObject _out, ^Object _b])

JOKER FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
;; (defn EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo input arguments: (b *Block)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "encodeToMemory(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_pem.Block(_b.(pem.Block))))"}
;;   [^Object _b])

JOKER FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
(defn CopyToken
  "CopyToken returns a copy of a Token.\n\nGo input arguments: (t Token)\n\nGo return type: Token\n\nJoker input arguments: [^go.std.encoding.xml/Token t]\n\nJoker return type: go.std.encoding.xml/Token"
  {:added "1.0"
   :go "copyToken(_t.(xml.Token))"}
  [^GoObject _t])

JOKER FUNC encoding/xml.Escape from encoding/xml/xml.go:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n\nGo input arguments: (w io.Writer, s []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) s]"
;;   {:added "1.0"
;;    :go "escape(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^GoObject _w, ^Object _s])

JOKER FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
;; (defn ^"Error" EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo input arguments: (w io.Writer, s []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) s]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_s)))"}
;;   [^GoObject _w, ^Object _s])

JOKER FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
;;   {:added "1.0"
;;    :go "newDecoder(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.xml/Encoder)"
;;   {:added "1.0"
;;    :go "newEncoder(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
(defn NewTokenDecoder
  "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo input arguments: (t TokenReader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.encoding.xml/TokenReader t]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
  {:added "1.0"
   :go "newTokenDecoder(_t.(xml.TokenReader))"}
  [^GoObject _t])

JOKER FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/xml"]
    :doc "Provides a low-level interface to the encoding/xml package."
    :empty false}
  go.std.encoding.xml)
JOKER FUNC errors.New from errors/errors.go:
(defn ^"Error" New
  "New returns an error that formats as the given text.\n\nGo input arguments: (text string)\n\nGo return type: error\n\nJoker input arguments: [^String text]\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(_text)"}
  [^String _text])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["errors"]
    :doc "Provides a low-level interface to the errors package."
    :empty false}
  go.std.errors)
JOKER FUNC expvar.Do from expvar/expvar.go:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n\nGo input arguments: (f func)\n\nJoker input arguments: [^fn f]"
;;   {:added "1.0"
;;    :go "do(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC expvar.Get from expvar/expvar.go:
(defn Get
  "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo input arguments: (name string)\n\nGo return type: Var\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.expvar/Var"
  {:added "1.0"
   :go "get(_name)"}
  [^String _name])

JOKER FUNC expvar.Handler from expvar/expvar.go:
(defn Handler
  "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: net/http.Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "handler()"}
  [])

JOKER FUNC expvar.NewFloat from expvar/expvar.go:
(defn NewFloat
  "Go input arguments: (name string)\n\nGo return type: *Float\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Float)"
  {:added "1.0"
   :go "newFloat(_name)"}
  [^String _name])

JOKER FUNC expvar.NewInt from expvar/expvar.go:
(defn NewInt
  "Go input arguments: (name string)\n\nGo return type: *Int\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Int)"
  {:added "1.0"
   :go "newInt(_name)"}
  [^String _name])

JOKER FUNC expvar.NewMap from expvar/expvar.go:
(defn NewMap
  "Go input arguments: (name string)\n\nGo return type: *Map\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Map)"
  {:added "1.0"
   :go "newMap(_name)"}
  [^String _name])

JOKER FUNC expvar.NewString from expvar/expvar.go:
(defn NewString
  "Go input arguments: (name string)\n\nGo return type: *String\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/String)"
  {:added "1.0"
   :go "newString(_name)"}
  [^String _name])

JOKER FUNC expvar.Publish from expvar/expvar.go:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n\nGo input arguments: (name string, v Var)\n\nJoker input arguments: [^String name, ^go.std.expvar/Var v]"
;;   {:added "1.0"
;;    :go "publish(_name, _v.(expvar.Var))"}
;;   [^String _name, ^GoObject _v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the expvar package."
    :empty false}
  go.std.expvar)
JOKER FUNC flag.Arg from flag/flag.go:
(defn ^"String" Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(_i)"}
  [^Int _i])

JOKER FUNC flag.Args from flag/flag.go:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "args()"}
  [])

JOKER FUNC flag.Bool from flag/flag.go:
(defn Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo input arguments: (name string, value bool, usage string)\n\nGo return type: *bool\n\nJoker input arguments: [^String name, ^Bool value, ^String usage]\n\nJoker return type: (atom-of Bool)"
  {:added "1.0"
   :go "_bool(_name, _value, _usage)"}
  [^String _name, ^Bool _value, ^String _usage])

JOKER FUNC flag.BoolVar from flag/flag.go:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n\nGo input arguments: (p *bool, name string, value bool, usage string)\n\nJoker input arguments: [^(atom-of Bool) p, ^String name, ^Bool value, ^String usage]"
;;   {:added "1.0"
;;    :go "boolVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfbool(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Bool _value, ^String _usage])

JOKER FUNC flag.Duration from flag/flag.go:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (name string, value time.Duration, usage string)\n\nGo return type: *time.Duration\n\nJoker input arguments: [^String name, ^go.std.time/Duration value, ^String usage]\n\nJoker return type: (atom-of go.std.time/Duration)"
;;   {:added "1.0"
;;    :go "duration(_name, _value.(ABEND987(imports not yet supported: time.Duration)), _usage)"}
;;   [^String _name, ^GoObject _value, ^String _usage])

JOKER FUNC flag.DurationVar from flag/flag.go:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (p *time.Duration, name string, value time.Duration, usage string)\n\nJoker input arguments: [^(atom-of go.std.time/Duration) p, ^String name, ^go.std.time/Duration value, ^String usage]"
;;   {:added "1.0"
;;    :go "durationVar(ConvertToIndirectOftime.Duration(_p.(ABEND987(imports not yet supported: time.Duration))), _name, _value.(ABEND987(imports not yet supported: time.Duration)), _usage)"}
;;   [^Object _p, ^String _name, ^GoObject _value, ^String _usage])

JOKER FUNC flag.Float64 from flag/flag.go:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value float64, usage string)\n\nGo return type: *...\n\nJoker input arguments: [^String name, ^float64 value, ^String usage]\n\nJoker return type: (atom-of ABEND043(unsupported built-in type float64))"
;;   {:added "1.0"
;;    :go "_float64(_name, _value, _usage)"}
;;   [^String _name, ^ABEND044(unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Float64Var from flag/flag.go:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n\nGo input arguments: (p *float64, name string, value float64, usage string)\n\nJoker input arguments: [^(atom-of float64) p, ^String name, ^float64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "float64Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOffloat64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Int from flag/flag.go:
(defn Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo input arguments: (name string, value int, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "_int(_name, _value, _usage)"}
  [^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Int64 from flag/flag.go:
(defn Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value int64, usage string)\n\nGo return type: *int64\n\nJoker input arguments: [^String name, ^Int64 value, ^String usage]\n\nJoker return type: (atom-of )"
  {:added "1.0"
   :go "_int64(_name, _value, _usage)"}
  [^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.Int64Var from flag/flag.go:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n\nGo input arguments: (p *int64, name string, value int64, usage string)\n\nJoker input arguments: [^(atom-of Int64) p, ^String name, ^Int64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "int64Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.IntVar from flag/flag.go:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n\nGo input arguments: (p *int, name string, value int, usage string)\n\nJoker input arguments: [^(atom-of Int) p, ^String name, ^Int value, ^String usage]"
;;   {:added "1.0"
;;    :go "intVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Lookup from flag/flag.go:
(defn Lookup
  "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo input arguments: (name string)\n\nGo return type: *Flag\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.flag/Flag)"
  {:added "1.0"
   :go "lookup(_name)"}
  [^String _name])

JOKER FUNC flag.NArg from flag/flag.go:
(defn ^"Int" NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag from flag/flag.go:
(defn ^"Int" NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet from flag/flag.go:
(defn NewFlagSet
  "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo input arguments: (name string, errorHandling ErrorHandling)\n\nGo return type: *FlagSet\n\nJoker input arguments: [^String name, ^go.std.flag/ErrorHandling errorHandling]\n\nJoker return type: (atom-of go.std.flag/FlagSet)"
  {:added "1.0"
   :go "newFlagSet(_name, _errorHandling.(flag.ErrorHandling))"}
  [^String _name, ^GoObject _errorHandling])

JOKER FUNC flag.Parse from flag/flag.go:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])

JOKER FUNC flag.Parsed from flag/flag.go:
(defn ^"Bool" Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults from flag/flag.go:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])

JOKER FUNC flag.Set from flag/flag.go:
(defn ^"Error" Set
  "Set sets the value of the named command-line flag.\n\nGo input arguments: (name string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(_name, _value)"}
  [^String _name, ^String _value])

JOKER FUNC flag.String from flag/flag.go:
(defn String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo input arguments: (name string, value string, usage string)\n\nGo return type: *string\n\nJoker input arguments: [^String name, ^String value, ^String usage]\n\nJoker return type: (atom-of String)"
  {:added "1.0"
   :go "_string(_name, _value, _usage)"}
  [^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.StringVar from flag/flag.go:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n\nGo input arguments: (p *string, name string, value string, usage string)\n\nJoker input arguments: [^(atom-of String) p, ^String name, ^String value, ^String usage]"
;;   {:added "1.0"
;;    :go "stringVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfstring(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.Uint from flag/flag.go:
(defn Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint, usage string)\n\nGo return type: *uint\n\nJoker input arguments: [^String name, ^UInt value, ^String usage]\n\nJoker return type: (atom-of )"
  {:added "1.0"
   :go "_uint(_name, _value, _usage)"}
  [^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.Uint64 from flag/flag.go:
;; (defn Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint64, usage string)\n\nGo return type: *...\n\nJoker input arguments: [^String name, ^uint64 value, ^String usage]\n\nJoker return type: (atom-of ABEND043(unsupported built-in type uint64))"
;;   {:added "1.0"
;;    :go "_uint64(_name, _value, _usage)"}
;;   [^String _name, ^ABEND044(unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.Uint64Var from flag/flag.go:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n\nGo input arguments: (p *uint64, name string, value uint64, usage string)\n\nJoker input arguments: [^(atom-of uint64) p, ^String name, ^uint64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "uint64Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.UintVar from flag/flag.go:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n\nGo input arguments: (p *uint, name string, value uint, usage string)\n\nJoker input arguments: [^(atom-of UInt) p, ^String name, ^UInt value, ^String usage]"
;;   {:added "1.0"
;;    :go "uintVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.UnquoteUsage from flag/flag.go:
;; (defn UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo input arguments: (flag *Flag)\n\nGo return type: (name string, usage string)\n\nJoker input arguments: [^(atom-of go.std.flag/Flag) flag]\n\nJoker return type: [String String]"
;;   {:added "1.0"
;;    :go "unquoteUsage(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_flag.Flag(_flag.(flag.Flag))))"}
;;   [^Object _flag])

JOKER FUNC flag.Var from flag/flag.go:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n\nGo input arguments: (value Value, name string, usage string)\n\nJoker input arguments: [^go.std.flag/Value value, ^String name, ^String usage]"
;;   {:added "1.0"
;;    :go "_var(_value.(flag.Value), _name, _usage)"}
;;   [^GoObject _value, ^String _name, ^String _usage])

JOKER FUNC flag.Visit from flag/flag.go:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "visit(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _fn])

JOKER FUNC flag.VisitAll from flag/flag.go:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "visitAll(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["flag"]
    :doc "Provides a low-level interface to the flag package."
    :empty false}
  go.std.flag)
JOKER FUNC fmt.Errorf from fmt/print.go:
;; (defn ^"Error" Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: error\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprint from fmt/print.go:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprint(_w.(ABEND987(imports not yet supported: io.Writer)), ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintf from fmt/print.go:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintf(_w.(ABEND987(imports not yet supported: io.Writer)), _format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _w, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintln from fmt/print.go:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintln(_w.(ABEND987(imports not yet supported: io.Writer)), ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscan from fmt/scan.go:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscan(_r.(ABEND987(imports not yet supported: io.Reader)), ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanf from fmt/scan.go:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (r io.Reader, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanf(_r.(ABEND987(imports not yet supported: io.Reader)), _format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _r, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanln from fmt/scan.go:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanln(_r.(ABEND987(imports not yet supported: io.Reader)), ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Print from fmt/print.go:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "_print(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Printf from fmt/print.go:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "printf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Println from fmt/print.go:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "_println(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scan from fmt/scan.go:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scan(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scanf from fmt/scan.go:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Scanln from fmt/scan.go:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanln(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprint from fmt/print.go:
;; (defn ^"String" Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintf from fmt/print.go:
;; (defn ^"String" Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintln from fmt/print.go:
;; (defn ^"String" Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sscan from fmt/scan.go:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscan(_str, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanf from fmt/scan.go:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (str string, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanf(_str, _format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanln from fmt/scan.go:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanln(_str, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER FUNC go/ast.FileExports from go/ast/filter.go:
;; (defn ^"Bool" FileExports
;;   "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo input arguments: (src *File)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FileExports(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.File(_src.(ast.File))))"}
;;   [^Object _src])

JOKER FUNC go/ast.FilterDecl from go/ast/filter.go:
(defn ^"Bool" FilterDecl
  "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo input arguments: (decl Decl, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.ast/Decl decl, ^go.std.go.ast/Filter f]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "ast.FilterDecl(_decl.(ast.Decl), _f.(ast.Filter))"}
  [^GoObject _decl, ^GoObject _f])

JOKER FUNC go/ast.FilterFile from go/ast/filter.go:
;; (defn ^"Bool" FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (src *File, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src, ^go.std.go.ast/Filter f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterFile(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.File(_src.(ast.File))), _f.(ast.Filter))"}
;;   [^Object _src, ^GoObject _f])

JOKER FUNC go/ast.FilterPackage from go/ast/filter.go:
;; (defn ^"Bool" FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (pkg *Package, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/Filter f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterPackage(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.Package(_pkg.(ast.Package))), _f.(ast.Filter))"}
;;   [^Object _pkg, ^GoObject _f])

JOKER FUNC go/ast.Fprint from go/ast/print.go:
;; (defn ^"Error" Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo input arguments: (w io.Writer, fset *token.FileSet, x interface {}, f FieldFilter)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x, ^go.std.go.ast/FieldFilter f]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(_w.(ABEND987(imports not yet supported: io.Writer)), ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _f.(ast.FieldFilter))"}
;;   [^GoObject _w, ^Object _fset, ^<protocol-or-something> _x, ^GoObject _f])

JOKER FUNC go/ast.Inspect from go/ast/walk.go:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n\nGo input arguments: (node Node, f func)\n\nJoker input arguments: [^go.std.go.ast/Node node, ^fn f]"
;;   {:added "1.0"
;;    :go "inspect(_node.(ast.Node), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _node, ^fn _f])

JOKER FUNC go/ast.IsExported from go/ast/ast.go:
(defn ^"Bool" IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo input arguments: (name string)\n\nGo return type: bool\n\nJoker input arguments: [^String name]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "ast.IsExported(_name)"}
  [^String _name])

JOKER FUNC go/ast.MergePackageFiles from go/ast/filter.go:
;; (defn MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo input arguments: (pkg *Package, mode MergeMode)\n\nGo return type: *File\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/MergeMode mode]\n\nJoker return type: (atom-of go.std.go.ast/File)"
;;   {:added "1.0"
;;    :go "mergePackageFiles(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.Package(_pkg.(ast.Package))), _mode.(ast.MergeMode))"}
;;   [^Object _pkg, ^GoObject _mode])

JOKER FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo input arguments: (fset *token.FileSet, node Node, comments []*CommentGroup)\n\nGo return type: CommentMap\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^go.std.go.ast/Node node, ^(vector-of (atom-of go.std.go.ast/CommentGroup)) comments]\n\nJoker return type: go.std.go.ast/CommentMap"
;;   {:added "1.0"
;;    :go "newCommentMap(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), _node.(ast.Node), ConvertToArrayOf*_ast.CommentGroup(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.CommentGroup(_comments.(ast.CommentGroup)))))"}
;;   [^Object _fset, ^GoObject _node, ^Object _comments])

JOKER FUNC go/ast.NewIdent from go/ast/ast.go:
(defn NewIdent
  "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo input arguments: (name string)\n\nGo return type: *Ident\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.go.ast/Ident)"
  {:added "1.0"
   :go "newIdent(_name)"}
  [^String _name])

JOKER FUNC go/ast.NewObj from go/ast/scope.go:
(defn NewObj
  "NewObj creates a new object of a given kind and name.\n\nGo input arguments: (kind ObjKind, name string)\n\nGo return type: *Object\n\nJoker input arguments: [^go.std.go.ast/ObjKind kind, ^String name]\n\nJoker return type: (atom-of go.std.go.ast/Object)"
  {:added "1.0"
   :go "newObj(_kind.(ast.ObjKind), _name)"}
  [^GoObject _kind, ^String _name])

JOKER FUNC go/ast.NewPackage from go/ast/resolve.go:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo input arguments: (fset *token.FileSet, files map[], importer Importer, universe *Scope)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^{} files, ^go.std.go.ast/Importer importer, ^(atom-of go.std.go.ast/Scope) universe]\n\nJoker return type: [(atom-of go.std.go.ast/Package) Error]"
;;   {:added "1.0"
;;    :go "newPackage(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()), _importer.(ast.Importer), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.Scope(_universe.(ast.Scope))))"}
;;   [^Object _fset, ^{} _files, ^GoObject _importer, ^Object _universe])

JOKER FUNC go/ast.NewScope from go/ast/scope.go:
;; (defn NewScope
;;   "NewScope creates a new scope nested in the outer scope.\n\nGo input arguments: (outer *Scope)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.ast/Scope) outer]\n\nJoker return type: (atom-of go.std.go.ast/Scope)"
;;   {:added "1.0"
;;    :go "newScope(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.Scope(_outer.(ast.Scope))))"}
;;   [^Object _outer])

JOKER FUNC go/ast.NotNilFilter from go/ast/print.go:
;; (defn ^"Bool" NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo input arguments: (_ string, v reflect.Value)\n\nGo return type: bool\n\nJoker input arguments: [^String _, ^go.std.reflect/Value v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(__, _v.(ABEND987(imports not yet supported: reflect.Value)))"}
;;   [^String __, ^GoObject _v])

JOKER FUNC go/ast.PackageExports from go/ast/filter.go:
;; (defn ^"Bool" PackageExports
;;   "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo input arguments: (pkg *Package)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.PackageExports(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.Package(_pkg.(ast.Package))))"}
;;   [^Object _pkg])

JOKER FUNC go/ast.Print from go/ast/print.go:
;; (defn ^"Error" Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo input arguments: (fset *token.FileSet, x interface {})\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _fset, ^<protocol-or-something> _x])

JOKER FUNC go/ast.SortImports from go/ast/import.go:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n\nGo input arguments: (fset *token.FileSet, f *File)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.ast/File) f]"
;;   {:added "1.0"
;;    :go "sortImports(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_ast.File(_f.(ast.File))))"}
;;   [^Object _fset, ^Object _f])

JOKER FUNC go/ast.Walk from go/ast/walk.go:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n\nGo input arguments: (v Visitor, node Node)\n\nJoker input arguments: [^go.std.go.ast/Visitor v, ^go.std.go.ast/Node node]"
;;   {:added "1.0"
;;    :go "walk(_v.(ast.Visitor), _node.(ast.Node))"}
;;   [^GoObject _v, ^GoObject _node])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/ast"]
    :doc "Provides a low-level interface to the go/ast package."
    :empty false}
  go.std.go.ast)
JOKER FUNC go/build.ArchChar from go/build/build.go:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo input arguments: (goarch string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String goarch]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "archChar(_goarch)"}
  [^String _goarch])

JOKER FUNC go/build.Import from go/build/build.go:
(defn Import
  "Import is shorthand for Default.Import.\n\nGo input arguments: (path string, srcDir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String path, ^String srcDir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "_import(_path, _srcDir, _mode.(build.ImportMode))"}
  [^String _path, ^String _srcDir, ^GoObject _mode])

JOKER FUNC go/build.ImportDir from go/build/build.go:
(defn ImportDir
  "ImportDir is shorthand for Default.ImportDir.\n\nGo input arguments: (dir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String dir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "importDir(_dir, _mode.(build.ImportMode))"}
  [^String _dir, ^GoObject _mode])

JOKER FUNC go/build.IsLocalImport from go/build/build.go:
(defn ^"Bool" IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "build.IsLocalImport(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/build"]
    :doc "Provides a low-level interface to the go/build package."
    :empty false}
  go.std.go.build)
JOKER FUNC go/constant.BinaryOp from go/constant/value.go:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "binaryOp(_x_.(constant.Value), _op.(ABEND987(imports not yet supported: token.Token)), _y_.(constant.Value))"}
;;   [^GoObject _x_, ^GoObject _op, ^GoObject _y_])

JOKER FUNC go/constant.BitLen from go/constant/value.go:
(defn ^"Int" BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.BitLen(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.BoolVal from go/constant/value.go:
(defn ^"Bool" BoolVal
  "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo input arguments: (x Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "constant.BoolVal(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Bytes from go/constant/value.go:
(defn Bytes
  "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo input arguments: (x Value)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: (vector-of )"
  {:added "1.0"
   :go "bytes(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Compare from go/constant/value.go:
;; (defn ^"Bool" Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "constant.Compare(_x_.(constant.Value), _op.(ABEND987(imports not yet supported: token.Token)), _y_.(constant.Value))"}
;;   [^GoObject _x_, ^GoObject _op, ^GoObject _y_])

JOKER FUNC go/constant.Denom from go/constant/value.go:
(defn Denom
  "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "denom(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Float32Val from go/constant/value.go:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo input arguments: (x Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ABEND043(unsupported built-in type float32) Bool]"
;;   {:added "1.0"
;;    :go "float32Val(_x.(constant.Value))"}
;;   [^GoObject _x])

JOKER FUNC go/constant.Float64Val from go/constant/value.go:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Bool]"
;;   {:added "1.0"
;;    :go "float64Val(_x.(constant.Value))"}
;;   [^GoObject _x])

JOKER FUNC go/constant.Imag from go/constant/value.go:
(defn Imag
  "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "_imag(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Int64Val from go/constant/value.go:
(defn Int64Val
  "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (int64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ Bool]"
  {:added "1.0"
   :go "int64Val(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.MakeBool from go/constant/value.go:
(defn MakeBool
  "MakeBool returns the Bool value for b.\n\nGo input arguments: (b bool)\n\nGo return type: Value\n\nJoker input arguments: [^Bool b]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "makeBool(_b)"}
  [^Bool _b])

JOKER FUNC go/constant.MakeFloat64 from go/constant/value.go:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo input arguments: (x float64)\n\nGo return type: Value\n\nJoker input arguments: [^float64 x]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "makeFloat64(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC go/constant.MakeFromBytes from go/constant/value.go:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo input arguments: (bytes []byte)\n\nGo return type: Value\n\nJoker input arguments: [^(vector-of Byte) bytes]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "makeFromBytes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_bytes)))"}
;;   [^Object _bytes])

JOKER FUNC go/constant.MakeFromLiteral from go/constant/value.go:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo input arguments: (lit string, tok token.Token, zero uint)\n\nGo return type: Value\n\nJoker input arguments: [^String lit, ^go.std.go.token/Token tok, ^UInt zero]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "makeFromLiteral(_lit, _tok.(ABEND987(imports not yet supported: token.Token)), _zero)"}
;;   [^String _lit, ^GoObject _tok, ^UInt _zero])

JOKER FUNC go/constant.MakeImag from go/constant/value.go:
(defn MakeImag
  "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "makeImag(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.MakeInt64 from go/constant/value.go:
(defn MakeInt64
  "MakeInt64 returns the Int value for x.\n\nGo input arguments: (x int64)\n\nGo return type: Value\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "makeInt64(_x)"}
  [^Int64 _x])

JOKER FUNC go/constant.MakeString from go/constant/value.go:
(defn MakeString
  "MakeString returns the String value for s.\n\nGo input arguments: (s string)\n\nGo return type: Value\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "makeString(_s)"}
  [^String _s])

JOKER FUNC go/constant.MakeUint64 from go/constant/value.go:
;; (defn MakeUint64
;;   "MakeUint64 returns the Int value for x.\n\nGo input arguments: (x uint64)\n\nGo return type: Value\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "makeUint64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC go/constant.MakeUnknown from go/constant/value.go:
(defn MakeUnknown
  "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker input arguments: []\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "makeUnknown()"}
  [])

JOKER FUNC go/constant.Num from go/constant/value.go:
(defn Num
  "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "num(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Real from go/constant/value.go:
(defn Real
  "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "_real(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Shift from go/constant/value.go:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo input arguments: (x Value, op token.Token, s uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x, ^go.std.go.token/Token op, ^UInt s]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "shift(_x.(constant.Value), _op.(ABEND987(imports not yet supported: token.Token)), _s)"}
;;   [^GoObject _x, ^GoObject _op, ^UInt _s])

JOKER FUNC go/constant.Sign from go/constant/value.go:
(defn ^"Int" Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.Sign(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.StringVal from go/constant/value.go:
(defn ^"String" StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo input arguments: (x Value)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: String"
  {:added "1.0"
   :go "constant.StringVal(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.ToComplex from go/constant/value.go:
(defn ToComplex
  "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "toComplex(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.ToFloat from go/constant/value.go:
(defn ToFloat
  "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "toFloat(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.ToInt from go/constant/value.go:
(defn ToInt
  "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "toInt(_x.(constant.Value))"}
  [^GoObject _x])

JOKER FUNC go/constant.Uint64Val from go/constant/value.go:
;; (defn Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Bool]"
;;   {:added "1.0"
;;    :go "uint64Val(_x.(constant.Value))"}
;;   [^GoObject _x])

JOKER FUNC go/constant.UnaryOp from go/constant/value.go:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo input arguments: (op token.Token, y Value, prec uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.token/Token op, ^go.std.go.constant/Value y, ^UInt prec]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "unaryOp(_op.(ABEND987(imports not yet supported: token.Token)), _y.(constant.Value), _prec)"}
;;   [^GoObject _op, ^GoObject _y, ^UInt _prec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/constant"]
    :doc "Provides a low-level interface to the go/constant package."
    :empty false}
  go.std.go.constant)
JOKER FUNC go/doc.Examples from go/doc/example.go:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo input arguments: (files ...*ast.File)\n\nGo return type: []*Example\n\nJoker input arguments: [^(ellipsis-somehow Object) files]\n\nJoker return type: (vector-of (atom-of go.std.go.doc/Example))"
;;   {:added "1.0"
;;    :go "examples(ConvertToEllipsisHaHa*ast.File(ConvertToIndirectOfast.File(_files.(ABEND987(imports not yet supported: ast.File)))))"}
;;   [^Object _files])

JOKER FUNC go/doc.IsPredeclared from go/doc/reader.go:
(defn ^"Bool" IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "doc.IsPredeclared(_s)"}
  [^String _s])

JOKER FUNC go/doc.New from go/doc/doc.go:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo input arguments: (pkg *ast.Package, importPath string, mode Mode)\n\nGo return type: *Package\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^String importPath, ^go.std.go.doc/Mode mode]\n\nJoker return type: (atom-of go.std.go.doc/Package)"
;;   {:added "1.0"
;;    :go "_new(ConvertToIndirectOfast.Package(_pkg.(ABEND987(imports not yet supported: ast.Package))), _importPath, _mode.(doc.Mode))"}
;;   [^Object _pkg, ^String _importPath, ^GoObject _mode])

JOKER FUNC go/doc.Synopsis from go/doc/synopsis.go:
(defn ^"String" Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(_s)"}
  [^String _s])

JOKER FUNC go/doc.ToHTML from go/doc/comment.go:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n\nGo input arguments: (w io.Writer, text string, words map[])\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^{} words]"
;;   {:added "1.0"
;;    :go "toHTML(_w.(ABEND987(imports not yet supported: io.Writer)), _text, ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^GoObject _w, ^String _text, ^{} _words])

JOKER FUNC go/doc.ToText from go/doc/comment.go:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n\nGo input arguments: (w io.Writer, text string, indent string, preIndent string, width int)\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^String indent, ^String preIndent, ^Int width]"
;;   {:added "1.0"
;;    :go "toText(_w.(ABEND987(imports not yet supported: io.Writer)), _text, _indent, _preIndent, _width)"}
;;   [^GoObject _w, ^String _text, ^String _indent, ^String _preIndent, ^Int _width])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/doc"]
    :doc "Provides a low-level interface to the go/doc package."
    :empty false}
  go.std.go.doc)
JOKER FUNC go/format.Node from go/format/format.go:
;; (defn ^"Error" Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo input arguments: (dst io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer dst, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(_dst.(ABEND987(imports not yet supported: io.Writer)), ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _dst, ^Object _fset, ^<protocol-or-something> _node])

JOKER FUNC go/format.Source from go/format/format.go:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo input arguments: (src []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "source(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_src)))"}
;;   [^Object _src])

JOKER FUNC go/importer.Default from go/importer/importer.go:
(defn Default
  "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: go/types.Importer\n\nJoker input arguments: []\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "_default()"}
  [])

JOKER FUNC go/importer.For from go/importer/importer.go:
(defn For
  "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo input arguments: (compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "_for(_compiler, _lookup.(importer.Lookup))"}
  [^String _compiler, ^GoObject _lookup])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/importer"]
    :doc "Provides a low-level interface to the go/importer package."
    :empty false}
  go.std.go.importer)
JOKER FUNC go/parser.ParseDir from go/parser/interface.go:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo input arguments: (fset *token.FileSet, path string, filter func, mode Mode)\n\nGo return type: (pkgs ..., first error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String path, ^fn filter, ^go.std.go.parser/Mode mode]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "parseDir(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), _path, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), _mode.(parser.Mode))"}
;;   [^Object _fset, ^String _path, ^fn _filter, ^GoObject _mode])

JOKER FUNC go/parser.ParseExpr from go/parser/interface.go:
(defn ParseExpr
  "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo input arguments: (x string)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^String x]\n\nJoker return type: [go.std.go.ast/Expr Error]"
  {:added "1.0"
   :go "parseExpr(_x)"}
  [^String _x])

JOKER FUNC go/parser.ParseExprFrom from go/parser/interface.go:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [go.std.go.ast/Expr Error]"
;;   {:added "1.0"
;;    :go "parseExprFrom(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), _filename, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _mode.(parser.Mode))"}
;;   [^Object _fset, ^String _filename, ^<protocol-or-something> _src, ^GoObject _mode])

JOKER FUNC go/parser.ParseFile from go/parser/interface.go:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (f *go/ast.File, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [(atom-of go.std.go.ast/File) Error]"
;;   {:added "1.0"
;;    :go "parseFile(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), _filename, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _mode.(parser.Mode))"}
;;   [^Object _fset, ^String _filename, ^<protocol-or-something> _src, ^GoObject _mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/parser package."
    :empty false}
  go.std.go.parser)
JOKER FUNC go/printer.Fprint from go/printer/printer.go:
;; (defn ^"Error" Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo input arguments: (output io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer output, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(_output.(ABEND987(imports not yet supported: io.Writer)), ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^GoObject _output, ^Object _fset, ^<protocol-or-something> _node])

JOKER FUNC go/scanner.PrintError from go/scanner/errors.go:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n\nGo input arguments: (w io.Writer, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^ABEND885(unrecognized type error at: GO.link/src/go/scanner/errors.go:116:34) err]"
;;   {:added "1.0"
;;    :go "printError(_w.(ABEND987(imports not yet supported: io.Writer)), _err)"}
;;   [^GoObject _w, ^ABEND885(unrecognized type error at: GO.link/src/go/scanner/errors.go:116:34) _err])

JOKER FUNC go/token.Lookup from go/token/token.go:
(defn Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo input arguments: (ident string)\n\nGo return type: Token\n\nJoker input arguments: [^String ident]\n\nJoker return type: go.std.go.token/Token"
  {:added "1.0"
   :go "lookup(_ident)"}
  [^String _ident])

JOKER FUNC go/token.NewFileSet from go/token/position.go:
(defn NewFileSet
  "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.go.token/FileSet)"
  {:added "1.0"
   :go "newFileSet()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/token package."
    :empty false}
  go.std.go.token)
JOKER FUNC go/types.AssertableTo from go/types/api.go:
;; (defn ^"Bool" AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo input arguments: (V *Interface, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.types/Interface) V, ^go.std.go.types/Type T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.AssertableTo(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Interface(_V.(types.Interface))), _T.(types.Type))"}
;;   [^Object _V, ^GoObject _T])

JOKER FUNC go/types.AssignableTo from go/types/api.go:
(defn ^"Bool" AssignableTo
  "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.AssignableTo(_V.(types.Type), _T.(types.Type))"}
  [^GoObject _V, ^GoObject _T])

JOKER FUNC go/types.Comparable from go/types/predicates.go:
(defn ^"Bool" Comparable
  "Comparable reports whether values of type T are comparable.\n\nGo input arguments: (T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.Comparable(_T.(types.Type))"}
  [^GoObject _T])

JOKER FUNC go/types.ConvertibleTo from go/types/api.go:
(defn ^"Bool" ConvertibleTo
  "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.ConvertibleTo(_V.(types.Type), _T.(types.Type))"}
  [^GoObject _V, ^GoObject _T])

JOKER FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC go/types.Default from go/types/predicates.go:
(defn Default
  "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo input arguments: (typ Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: go.std.go.types/Type"
  {:added "1.0"
   :go "_default(_typ.(types.Type))"}
  [^GoObject _typ])

JOKER FUNC go/types.Eval from go/types/eval.go:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo input arguments: (fset *token.FileSet, pkg *Package, pos token.Pos, expr string)\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^go.std.go.token/Pos pos, ^String expr]\n\nJoker return type: [go.std.go.types/TypeAndValue Error]"
;;   {:added "1.0"
;;    :go "eval(ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _pos.(ABEND987(imports not yet supported: token.Pos)), _expr)"}
;;   [^Object _fset, ^Object _pkg, ^GoObject _pos, ^String _expr])

JOKER FUNC go/types.ExprString from go/types/exprstring.go:
;; (defn ^"String" ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (x ast.Expr)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.ast/Expr x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(_x.(ABEND987(imports not yet supported: ast.Expr)))"}
;;   [^GoObject _x])

JOKER FUNC go/types.Id from go/types/object.go:
;; (defn ^"String" Id
;;   "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo input arguments: (pkg *Package, name string)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.Id(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name)"}
;;   [^Object _pkg, ^String _name])

JOKER FUNC go/types.Identical from go/types/predicates.go:
(defn ^"Bool" Identical
  "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.Identical(_x.(types.Type), _y.(types.Type))"}
  [^GoObject _x, ^GoObject _y])

JOKER FUNC go/types.IdenticalIgnoreTags from go/types/predicates.go:
(defn ^"Bool" IdenticalIgnoreTags
  "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.IdenticalIgnoreTags(_x.(types.Type), _y.(types.Type))"}
  [^GoObject _x, ^GoObject _y])

JOKER FUNC go/types.Implements from go/types/api.go:
;; (defn ^"Bool" Implements
;;   "Implements reports whether type V implements interface T.\n\nGo input arguments: (V Type, T *Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Implements(_V.(types.Type), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Interface(_T.(types.Interface))))"}
;;   [^GoObject _V, ^Object _T])

JOKER FUNC go/types.IsInterface from go/types/predicates.go:
(defn ^"Bool" IsInterface
  "IsInterface reports whether typ is an interface type.\n\nGo input arguments: (typ Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "types.IsInterface(_typ.(types.Type))"}
  [^GoObject _typ])

JOKER FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
;; (defn LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo input arguments: (T Type, addressable bool, pkg *Package, name string)\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker input arguments: [^go.std.go.types/Type T, ^Bool addressable, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: [go.std.go.types/Object (vector-of Int) Bool]"
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(_T.(types.Type), _addressable, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name)"}
;;   [^GoObject _T, ^Bool _addressable, ^Object _pkg, ^String _name])

JOKER FUNC go/types.MissingMethod from go/types/lookup.go:
;; (defn MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo input arguments: (V Type, T *Interface, static bool)\n\nGo return type: (method *Func, wrongType bool)\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T, ^Bool static]\n\nJoker return type: [(atom-of go.std.go.types/Func) Bool]"
;;   {:added "1.0"
;;    :go "missingMethod(_V.(types.Type), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Interface(_T.(types.Interface))), _static)"}
;;   [^GoObject _V, ^Object _T, ^Bool _static])

JOKER FUNC go/types.NewArray from go/types/type.go:
(defn NewArray
  "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo input arguments: (elem Type, len int64)\n\nGo return type: *Array\n\nJoker input arguments: [^go.std.go.types/Type elem, ^Int64 len]\n\nJoker return type: (atom-of go.std.go.types/Array)"
  {:added "1.0"
   :go "newArray(_elem.(types.Type), _len)"}
  [^GoObject _elem, ^Int64 _len])

JOKER FUNC go/types.NewChan from go/types/type.go:
(defn NewChan
  "NewChan returns a new channel type for the given direction and element type.\n\nGo input arguments: (dir ChanDir, elem Type)\n\nGo return type: *Chan\n\nJoker input arguments: [^go.std.go.types/ChanDir dir, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Chan)"
  {:added "1.0"
   :go "newChan(_dir.(types.ChanDir), _elem.(types.Type))"}
  [^GoObject _dir, ^GoObject _elem])

JOKER FUNC go/types.NewChecker from go/types/check.go:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo input arguments: (conf *Config, fset *token.FileSet, pkg *Package, info *Info)\n\nGo return type: *Checker\n\nJoker input arguments: [^(atom-of go.std.go.types/Config) conf, ^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^(atom-of go.std.go.types/Info) info]\n\nJoker return type: (atom-of go.std.go.types/Checker)"
;;   {:added "1.0"
;;    :go "newChecker(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Config(_conf.(types.Config))), ConvertToIndirectOftoken.FileSet(_fset.(ABEND987(imports not yet supported: token.FileSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Info(_info.(types.Info))))"}
;;   [^Object _conf, ^Object _fset, ^Object _pkg, ^Object _info])

JOKER FUNC go/types.NewConst from go/types/object.go:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, val constant.Value)\n\nGo return type: *Const\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^go.std.go.constant/Value val]\n\nJoker return type: (atom-of go.std.go.types/Const)"
;;   {:added "1.0"
;;    :go "newConst(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, _typ.(types.Type), _val.(ABEND987(imports not yet supported: constant.Value)))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^GoObject _typ, ^GoObject _val])

JOKER FUNC go/types.NewField from go/types/object.go:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, embedded bool)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^Bool embedded]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "newField(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, _typ.(types.Type), _embedded)"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^GoObject _typ, ^Bool _embedded])

JOKER FUNC go/types.NewFunc from go/types/object.go:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, sig *Signature)\n\nGo return type: *Func\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Signature) sig]\n\nJoker return type: (atom-of go.std.go.types/Func)"
;;   {:added "1.0"
;;    :go "newFunc(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Signature(_sig.(types.Signature))))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^Object _sig])

JOKER FUNC go/types.NewInterface from go/types/type.go:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo input arguments: (methods []*Func, embeddeds []*Named)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of (atom-of go.std.go.types/Named)) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "newInterface(ConvertToArrayOf*_types.Func(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Func(_methods.(types.Func)))), ConvertToArrayOf*_types.Named(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Named(_embeddeds.(types.Named)))))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewInterfaceType from go/types/type.go:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo input arguments: (methods []*Func, embeddeds []Type)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of go.std.go.types/Type) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "newInterfaceType(ConvertToArrayOf*_types.Func(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Func(_methods.(types.Func)))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_types.Type(_embeddeds.(types.Type))))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewLabel from go/types/object.go:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string)\n\nGo return type: *Label\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Label)"
;;   {:added "1.0"
;;    :go "newLabel(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name)"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name])

JOKER FUNC go/types.NewMap from go/types/type.go:
(defn NewMap
  "NewMap returns a new map for the given key and element types.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: *Map\n\nJoker input arguments: [^go.std.go.types/Type key, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Map)"
  {:added "1.0"
   :go "newMap(_key.(types.Type), _elem.(types.Type))"}
  [^GoObject _key, ^GoObject _elem])

JOKER FUNC go/types.NewMethodSet from go/types/methodset.go:
(defn NewMethodSet
  "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo input arguments: (T Type)\n\nGo return type: *MethodSet\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: (atom-of go.std.go.types/MethodSet)"
  {:added "1.0"
   :go "newMethodSet(_T.(types.Type))"}
  [^GoObject _T])

JOKER FUNC go/types.NewNamed from go/types/type.go:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo input arguments: (obj *TypeName, underlying Type, methods []*Func)\n\nGo return type: *Named\n\nJoker input arguments: [^(atom-of go.std.go.types/TypeName) obj, ^go.std.go.types/Type underlying, ^(vector-of (atom-of go.std.go.types/Func)) methods]\n\nJoker return type: (atom-of go.std.go.types/Named)"
;;   {:added "1.0"
;;    :go "newNamed(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.TypeName(_obj.(types.TypeName))), _underlying.(types.Type), ConvertToArrayOf*_types.Func(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Func(_methods.(types.Func)))))"}
;;   [^Object _obj, ^GoObject _underlying, ^Object _methods])

JOKER FUNC go/types.NewPackage from go/types/package.go:
(defn NewPackage
  "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo input arguments: (path string, name string)\n\nGo return type: *Package\n\nJoker input arguments: [^String path, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Package)"
  {:added "1.0"
   :go "newPackage(_path, _name)"}
  [^String _path, ^String _name])

JOKER FUNC go/types.NewParam from go/types/object.go:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "newParam(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, _typ.(types.Type))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^GoObject _typ])

JOKER FUNC go/types.NewPkgName from go/types/object.go:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, imported *Package)\n\nGo return type: *PkgName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Package) imported]\n\nJoker return type: (atom-of go.std.go.types/PkgName)"
;;   {:added "1.0"
;;    :go "newPkgName(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_imported.(types.Package))))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^Object _imported])

JOKER FUNC go/types.NewPointer from go/types/type.go:
(defn NewPointer
  "NewPointer returns a new pointer type for the given element (base) type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Pointer\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Pointer)"
  {:added "1.0"
   :go "newPointer(_elem.(types.Type))"}
  [^GoObject _elem])

JOKER FUNC go/types.NewScope from go/types/scope.go:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo input arguments: (parent *Scope, pos token.Pos, end token.Pos, comment string)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.types/Scope) parent, ^go.std.go.token/Pos pos, ^go.std.go.token/Pos end, ^String comment]\n\nJoker return type: (atom-of go.std.go.types/Scope)"
;;   {:added "1.0"
;;    :go "newScope(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Scope(_parent.(types.Scope))), _pos.(ABEND987(imports not yet supported: token.Pos)), _end.(ABEND987(imports not yet supported: token.Pos)), _comment)"}
;;   [^Object _parent, ^GoObject _pos, ^GoObject _end, ^String _comment])

JOKER FUNC go/types.NewSignature from go/types/type.go:
;; (defn NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo input arguments: (recv *Var, params *Tuple, results *Tuple, variadic bool)\n\nGo return type: *Signature\n\nJoker input arguments: [^(atom-of go.std.go.types/Var) recv, ^(atom-of go.std.go.types/Tuple) params, ^(atom-of go.std.go.types/Tuple) results, ^Bool variadic]\n\nJoker return type: (atom-of go.std.go.types/Signature)"
;;   {:added "1.0"
;;    :go "newSignature(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Var(_recv.(types.Var))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Tuple(_params.(types.Tuple))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Tuple(_results.(types.Tuple))), _variadic)"}
;;   [^Object _recv, ^Object _params, ^Object _results, ^Bool _variadic])

JOKER FUNC go/types.NewSlice from go/types/type.go:
(defn NewSlice
  "NewSlice returns a new slice type for the given element type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Slice\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Slice)"
  {:added "1.0"
   :go "newSlice(_elem.(types.Type))"}
  [^GoObject _elem])

JOKER FUNC go/types.NewStruct from go/types/type.go:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo input arguments: (fields []*Var, tags []string)\n\nGo return type: *Struct\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Var)) fields, ^(vector-of String) tags]\n\nJoker return type: (atom-of go.std.go.types/Struct)"
;;   {:added "1.0"
;;    :go "newStruct(ConvertToArrayOf*_types.Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Var(_fields.(types.Var)))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_tags)))"}
;;   [^Object _fields, ^Object _tags])

JOKER FUNC go/types.NewTuple from go/types/type.go:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo input arguments: (x ...*Var)\n\nGo return type: *Tuple\n\nJoker input arguments: [^(ellipsis-somehow Object) x]\n\nJoker return type: (atom-of go.std.go.types/Tuple)"
;;   {:added "1.0"
;;    :go "newTuple(ConvertToEllipsisHaHa*_types.Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Var(_x.(types.Var)))))"}
;;   [^Object _x])

JOKER FUNC go/types.NewTypeName from go/types/object.go:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *TypeName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/TypeName)"
;;   {:added "1.0"
;;    :go "newTypeName(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, _typ.(types.Type))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^GoObject _typ])

JOKER FUNC go/types.NewVar from go/types/object.go:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "newVar(_pos.(ABEND987(imports not yet supported: token.Pos)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))), _name, _typ.(types.Type))"}
;;   [^GoObject _pos, ^Object _pkg, ^String _name, ^GoObject _typ])

JOKER FUNC go/types.ObjectString from go/types/object.go:
(defn ^"String" ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (obj Object, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Object obj, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.ObjectString(_obj.(types.Object), _qf.(types.Qualifier))"}
  [^GoObject _obj, ^GoObject _qf])

JOKER FUNC go/types.RelativeTo from go/types/typestring.go:
;; (defn RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo input arguments: (pkg *Package)\n\nGo return type: Qualifier\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg]\n\nJoker return type: go.std.go.types/Qualifier"
;;   {:added "1.0"
;;    :go "relativeTo(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Package(_pkg.(types.Package))))"}
;;   [^Object _pkg])

JOKER FUNC go/types.SelectionString from go/types/selection.go:
;; (defn ^"String" SelectionString
;;   "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo input arguments: (s *Selection, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Selection) s, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.SelectionString(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Selection(_s.(types.Selection))), _qf.(types.Qualifier))"}
;;   [^Object _s, ^GoObject _qf])

JOKER FUNC go/types.SizesFor from go/types/sizes.go:
(defn SizesFor
  "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\n\nGo input arguments: (compiler string, arch string)\n\nGo return type: Sizes\n\nJoker input arguments: [^String compiler, ^String arch]\n\nJoker return type: go.std.go.types/Sizes"
  {:added "1.0"
   :go "sizesFor(_compiler, _arch)"}
  [^String _compiler, ^String _arch])

JOKER FUNC go/types.TypeString from go/types/typestring.go:
(defn ^"String" TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (typ Type, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.TypeString(_typ.(types.Type), _qf.(types.Qualifier))"}
  [^GoObject _typ, ^GoObject _qf])

JOKER FUNC go/types.WriteExpr from go/types/exprstring.go:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (buf *bytes.Buffer, x ast.Expr)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.ast/Expr x]"
;;   {:added "1.0"
;;    :go "writeExpr(ConvertToIndirectOfbytes.Buffer(_buf.(ABEND987(imports not yet supported: bytes.Buffer))), _x.(ABEND987(imports not yet supported: ast.Expr)))"}
;;   [^Object _buf, ^GoObject _x])

JOKER FUNC go/types.WriteSignature from go/types/typestring.go:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, sig *Signature, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^(atom-of go.std.go.types/Signature) sig, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "writeSignature(ConvertToIndirectOfbytes.Buffer(_buf.(ABEND987(imports not yet supported: bytes.Buffer))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_types.Signature(_sig.(types.Signature))), _qf.(types.Qualifier))"}
;;   [^Object _buf, ^Object _sig, ^GoObject _qf])

JOKER FUNC go/types.WriteType from go/types/typestring.go:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, typ Type, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "writeType(ConvertToIndirectOfbytes.Buffer(_buf.(ABEND987(imports not yet supported: bytes.Buffer))), _typ.(types.Type), _qf.(types.Qualifier))"}
;;   [^Object _buf, ^GoObject _typ, ^GoObject _qf])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/types"]
    :doc "Provides a low-level interface to the go/types package."
    :empty false}
  go.std.go.types)
JOKER FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
;; (defn Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data]"
;;   {:added "1.0"
;;    :go "checksum(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC hash/adler32.New from hash/adler32/adler32.go:
(defn New
  "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "_new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/adler32 package."
    :empty false}
  go.std.hash.adler32)
JOKER FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
;; (defn Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of go.std.hash.crc32/Table) tab]"
;;   {:added "1.0"
;;    :go "checksum(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc32.Table(_tab.(crc32.Table))))"}
;;   [^Object _data, ^Object _tab])

JOKER FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
;; (defn ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Byte) data]"
;;   {:added "1.0"
;;    :go "checksumIEEE(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint32)\n\nGo return type: *Table\n\nJoker input arguments: [^UInt32 poly]\n\nJoker return type: (atom-of go.std.hash.crc32/Table)"
  {:added "1.0"
   :go "makeTable(_poly)"}
  [^UInt32 _poly])

JOKER FUNC hash/crc32.New from hash/crc32/crc32.go:
;; (defn New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash32\n\nJoker input arguments: [^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: go.std.hash/Hash32"
;;   {:added "1.0"
;;    :go "_new(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc32.Table(_tab.(crc32.Table))))"}
;;   [^Object _tab])

JOKER FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
(defn NewIEEE
  "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "newIEEE()"}
  [])

JOKER FUNC hash/crc32.Update from hash/crc32/crc32.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint32, tab *Table, p []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 crc, ^(atom-of go.std.hash.crc32/Table) tab, ^(vector-of Byte) p]"
;;   {:added "1.0"
;;    :go "update(_crc, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc32.Table(_tab.(crc32.Table))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^UInt32 _crc, ^Object _tab, ^Object _p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/crc32 package."
    :empty false}
  go.std.hash.crc32)
JOKER FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: ...\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "checksum(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc64.Table(_tab.(crc64.Table))))"}
;;   [^Object _data, ^Object _tab])

JOKER FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint64)\n\nGo return type: *Table\n\nJoker input arguments: [^uint64 poly]\n\nJoker return type: (atom-of go.std.hash.crc64/Table)"
;;   {:added "1.0"
;;    :go "makeTable(_poly)"}
;;   [^ABEND044(unsupported built-in type uint64) _poly])

JOKER FUNC hash/crc64.New from hash/crc64/crc64.go:
;; (defn New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash64\n\nJoker input arguments: [^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: go.std.hash/Hash64"
;;   {:added "1.0"
;;    :go "_new(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc64.Table(_tab.(crc64.Table))))"}
;;   [^Object _tab])

JOKER FUNC hash/crc64.Update from hash/crc64/crc64.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint64, tab *Table, p []byte)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 crc, ^(atom-of go.std.hash.crc64/Table) tab, ^(vector-of Byte) p]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "update(_crc, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_crc64.Table(_tab.(crc64.Table))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^ABEND044(unsupported built-in type uint64) _crc, ^Object _tab, ^Object _p])

JOKER FUNC hash/fnv.New128 from hash/fnv/fnv.go:
(defn New128
  "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new128()"}
  [])

JOKER FUNC hash/fnv.New128a from hash/fnv/fnv.go:
(defn New128a
  "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "new128a()"}
  [])

JOKER FUNC hash/fnv.New32 from hash/fnv/fnv.go:
(defn New32
  "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "new32()"}
  [])

JOKER FUNC hash/fnv.New32a from hash/fnv/fnv.go:
(defn New32a
  "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "new32a()"}
  [])

JOKER FUNC hash/fnv.New64 from hash/fnv/fnv.go:
(defn New64
  "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "new64()"}
  [])

JOKER FUNC hash/fnv.New64a from hash/fnv/fnv.go:
(defn New64a
  "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "new64a()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/fnv package."
    :empty false}
  go.std.hash.fnv)
JOKER FUNC html.EscapeString from html/escape.go:
(defn ^"String" EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(_s)"}
  [^String _s])

JOKER FUNC html.UnescapeString from html/escape.go:
(defn ^"String" UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html"]
    :doc "Provides a low-level interface to the html package."
    :empty false}
  go.std.html)
JOKER FUNC html/template.HTMLEscape from html/template/escape.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "hTMLEscape(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^GoObject _w, ^Object _b])

JOKER FUNC html/template.HTMLEscapeString from html/template/escape.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.HTMLEscaper from html/template/escape.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.IsTrue from html/template/template.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC html/template.JSEscape from html/template/escape.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "jSEscape(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^GoObject _w, ^Object _b])

JOKER FUNC html/template.JSEscapeString from html/template/escape.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.JSEscaper from html/template/escape.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.Must from html/template/template.go:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.html.template/Template) t, ^ABEND885(unrecognized type error at: GO.link/src/html/template/template.go:370:28) err]\n\nJoker return type: (atom-of go.std.html.template/Template)"
;;   {:added "1.0"
;;    :go "must(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_template.Template(_t.(template.Template))), _err)"}
;;   [^Object _t, ^ABEND885(unrecognized type error at: GO.link/src/html/template/template.go:370:28) _err])

JOKER FUNC html/template.New from html/template/template.go:
(defn New
  "New allocates a new HTML template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "_new(_name)"}
  [^String _name])

JOKER FUNC html/template.ParseFiles from html/template/template.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
;;   {:added "1.0"
;;    :go "parseFiles(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC html/template.ParseGlob from html/template/template.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
  {:added "1.0"
   :go "parseGlob(_pattern)"}
  [^String _pattern])

JOKER FUNC html/template.URLQueryEscaper from html/template/escape.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html/template"]
    :doc "Provides a low-level interface to the html/template package."
    :empty false}
  go.std.html.template)
JOKER FUNC image.Decode from image/format.go:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Image, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image String Error]"
;;   {:added "1.0"
;;    :go "decode(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image.DecodeConfig from image/format.go:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Config, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config String Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image.NewAlpha from image/image.go:
(defn NewAlpha
  "NewAlpha returns a new Alpha image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha)"
  {:added "1.0"
   :go "newAlpha(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewAlpha16 from image/image.go:
(defn NewAlpha16
  "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha16)"
  {:added "1.0"
   :go "newAlpha16(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewCMYK from image/image.go:
(defn NewCMYK
  "NewCMYK returns a new CMYK image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *CMYK\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/CMYK)"
  {:added "1.0"
   :go "newCMYK(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewGray from image/image.go:
(defn NewGray
  "NewGray returns a new Gray image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray)"
  {:added "1.0"
   :go "newGray(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewGray16 from image/image.go:
(defn NewGray16
  "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray16)"
  {:added "1.0"
   :go "newGray16(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewNRGBA from image/image.go:
(defn NewNRGBA
  "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA)"
  {:added "1.0"
   :go "newNRGBA(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewNRGBA64 from image/image.go:
(defn NewNRGBA64
  "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA64)"
  {:added "1.0"
   :go "newNRGBA64(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewNYCbCrA from image/ycbcr.go:
(defn NewNYCbCrA
  "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *NYCbCrA\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/NYCbCrA)"
  {:added "1.0"
   :go "newNYCbCrA(_r.(image.Rectangle), _subsampleRatio.(image.YCbCrSubsampleRatio))"}
  [^GoObject _r, ^GoObject _subsampleRatio])

JOKER FUNC image.NewPaletted from image/image.go:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo input arguments: (r Rectangle, p color.Palette)\n\nGo return type: *Paletted\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image.color/Palette p]\n\nJoker return type: (atom-of go.std.image/Paletted)"
;;   {:added "1.0"
;;    :go "newPaletted(_r.(image.Rectangle), _p.(ABEND987(imports not yet supported: color.Palette)))"}
;;   [^GoObject _r, ^GoObject _p])

JOKER FUNC image.NewRGBA from image/image.go:
(defn NewRGBA
  "NewRGBA returns a new RGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA)"
  {:added "1.0"
   :go "newRGBA(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewRGBA64 from image/image.go:
(defn NewRGBA64
  "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA64)"
  {:added "1.0"
   :go "newRGBA64(_r.(image.Rectangle))"}
  [^GoObject _r])

JOKER FUNC image.NewUniform from image/names.go:
;; (defn NewUniform
;;   "Go input arguments: (c color.Color)\n\nGo return type: *Uniform\n\nJoker input arguments: [^go.std.image.color/Color c]\n\nJoker return type: (atom-of go.std.image/Uniform)"
;;   {:added "1.0"
;;    :go "newUniform(_c.(ABEND987(imports not yet supported: color.Color)))"}
;;   [^GoObject _c])

JOKER FUNC image.NewYCbCr from image/ycbcr.go:
(defn NewYCbCr
  "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *YCbCr\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/YCbCr)"
  {:added "1.0"
   :go "newYCbCr(_r.(image.Rectangle), _subsampleRatio.(image.YCbCrSubsampleRatio))"}
  [^GoObject _r, ^GoObject _subsampleRatio])

JOKER FUNC image.Pt from image/geom.go:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo input arguments: (X int, Y int)\n\nGo return type: Point\n\nJoker input arguments: [^Int X, ^Int Y]\n\nJoker return type: go.std.image/Point"
  {:added "1.0"
   :go "pt(_X, _Y)"}
  [^Int _X, ^Int _Y])

JOKER FUNC image.Rect from image/geom.go:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo input arguments: (x0 int, y0 int, x1 int, y1 int)\n\nGo return type: Rectangle\n\nJoker input arguments: [^Int x0, ^Int y0, ^Int x1, ^Int y1]\n\nJoker return type: go.std.image/Rectangle"
  {:added "1.0"
   :go "rect(_x0, _y0, _x1, _y1)"}
  [^Int _x0, ^Int _y0, ^Int _x1, ^Int _y1])

JOKER FUNC image.RegisterFormat from image/format.go:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n\nGo input arguments: (name string, magic string, decode func, decodeConfig func)\n\nJoker input arguments: [^String name, ^String magic, ^fn decode, ^fn decodeConfig]"
;;   {:added "1.0"
;;    :go "registerFormat(_name, _magic, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _name, ^String _magic, ^fn _decode, ^fn _decodeConfig])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["image"]
    :doc "Provides a low-level interface to the image package."
    :empty false}
  go.std.image)
JOKER FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
;; (defn CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo input arguments: (c uint8, m uint8, y uint8, k uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 c, ^uint8 m, ^uint8 y, ^uint8 k]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "cMYKToRGB(_c, _m, _y, _k)"}
;;   [^ABEND044(unsupported built-in type uint8) _c, ^ABEND044(unsupported built-in type uint8) _m, ^ABEND044(unsupported built-in type uint8) _y, ^ABEND044(unsupported built-in type uint8) _k])

JOKER FUNC image/color.ModelFunc from image/color/color.go:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo input arguments: (f func)\n\nGo return type: Model\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.image.color/Model"
;;   {:added "1.0"
;;    :go "modelFunc(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
;; (defn RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "rGBToCMYK(_r, _g, _b)"}
;;   [^ABEND044(unsupported built-in type uint8) _r, ^ABEND044(unsupported built-in type uint8) _g, ^ABEND044(unsupported built-in type uint8) _b])

JOKER FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
;; (defn RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "rGBToYCbCr(_r, _g, _b)"}
;;   [^ABEND044(unsupported built-in type uint8) _r, ^ABEND044(unsupported built-in type uint8) _g, ^ABEND044(unsupported built-in type uint8) _b])

JOKER FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
;; (defn YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo input arguments: (y uint8, cb uint8, cr uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 y, ^uint8 cb, ^uint8 cr]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "yCbCrToRGB(_y, _cb, _cr)"}
;;   [^ABEND044(unsupported built-in type uint8) _y, ^ABEND044(unsupported built-in type uint8) _cb, ^ABEND044(unsupported built-in type uint8) _cr])

JOKER FUNC image/draw.Draw from image/draw/draw.go:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "draw(_dst.(draw.Image), _r.(ABEND987(imports not yet supported: image.Rectangle)), _src.(ABEND987(imports not yet supported: image.Image)), _sp.(ABEND987(imports not yet supported: image.Point)), _op.(draw.Op))"}
;;   [^GoObject _dst, ^GoObject _r, ^GoObject _src, ^GoObject _sp, ^GoObject _op])

JOKER FUNC image/draw.DrawMask from image/draw/draw.go:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image/Image mask, ^go.std.image/Point mp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "drawMask(_dst.(draw.Image), _r.(ABEND987(imports not yet supported: image.Rectangle)), _src.(ABEND987(imports not yet supported: image.Image)), _sp.(ABEND987(imports not yet supported: image.Point)), _mask.(ABEND987(imports not yet supported: image.Image)), _mp.(ABEND987(imports not yet supported: image.Point)), _op.(draw.Op))"}
;;   [^GoObject _dst, ^GoObject _r, ^GoObject _src, ^GoObject _sp, ^GoObject _mask, ^GoObject _mp, ^GoObject _op])

JOKER FUNC image/gif.Decode from image/gif/reader.go:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "decode(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/gif.DecodeAll from image/gif/reader.go:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*GIF, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.image.gif/GIF) Error]"
;;   {:added "1.0"
;;    :go "decodeAll(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/gif.DecodeConfig from image/gif/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/gif.Encode from image/gif/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.gif/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(_w.(ABEND987(imports not yet supported: io.Writer)), _m.(ABEND987(imports not yet supported: image.Image)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_gif.Options(_o.(gif.Options))))"}
;;   [^GoObject _w, ^GoObject _m, ^Object _o])

JOKER FUNC image/gif.EncodeAll from image/gif/writer.go:
;; (defn ^"Error" EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo input arguments: (w io.Writer, g *GIF)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.image.gif/GIF) g]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_gif.GIF(_g.(gif.GIF))))"}
;;   [^GoObject _w, ^Object _g])

JOKER FUNC image/jpeg.Decode from image/jpeg/reader.go:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "decode(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/jpeg.Encode from image/jpeg/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.jpeg/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(_w.(ABEND987(imports not yet supported: io.Writer)), _m.(ABEND987(imports not yet supported: image.Image)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_jpeg.Options(_o.(jpeg.Options))))"}
;;   [^GoObject _w, ^GoObject _m, ^Object _o])

JOKER FUNC image/png.Decode from image/png/reader.go:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "decode(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/png.DecodeConfig from image/png/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC image/png.Encode from image/png/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo input arguments: (w io.Writer, m image.Image)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(_w.(ABEND987(imports not yet supported: io.Writer)), _m.(ABEND987(imports not yet supported: image.Image)))"}
;;   [^GoObject _w, ^GoObject _m])

JOKER FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo input arguments: (data []byte)\n\nGo return type: *Index\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (atom-of go.std.index.suffixarray/Index)"
;;   {:added "1.0"
;;    :go "_new(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC io.Copy from io/io.go:
(defn Copy
  "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo input arguments: (dst Writer, src Reader)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "_copy(_dst.(io.Writer), _src.(io.Reader))"}
  [^GoObject _dst, ^GoObject _src])

JOKER FUNC io.CopyBuffer from io/io.go:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo input arguments: (dst Writer, src Reader, buf []byte)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^(vector-of Byte) buf]\n\nJoker return type: [ Error]"
;;   {:added "1.0"
;;    :go "copyBuffer(_dst.(io.Writer), _src.(io.Reader), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^GoObject _dst, ^GoObject _src, ^Object _buf])

JOKER FUNC io.CopyN from io/io.go:
(defn CopyN
  "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo input arguments: (dst Writer, src Reader, n int64)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^Int64 n]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "copyN(_dst.(io.Writer), _src.(io.Reader), _n)"}
  [^GoObject _dst, ^GoObject _src, ^Int64 _n])

JOKER FUNC io.LimitReader from io/io.go:
(defn LimitReader
  "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo input arguments: (r Reader, n int64)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^Int64 n]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "limitReader(_r.(io.Reader), _n)"}
  [^GoObject _r, ^Int64 _n])

JOKER FUNC io.MultiReader from io/multi.go:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo input arguments: (readers ...Reader)\n\nGo return type: Reader\n\nJoker input arguments: [^(ellipsis-somehow GoObject) readers]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "multiReader(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Reader(_readers.(io.Reader))))"}
;;   [^GoObject _readers])

JOKER FUNC io.MultiWriter from io/multi.go:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo input arguments: (writers ...Writer)\n\nGo return type: Writer\n\nJoker input arguments: [^(ellipsis-somehow GoObject) writers]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "multiWriter(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Writer(_writers.(io.Writer))))"}
;;   [^GoObject _writers])

JOKER FUNC io.NewSectionReader from io/io.go:
(defn NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo input arguments: (r ReaderAt, off int64, n int64)\n\nGo return type: *SectionReader\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Int64 off, ^Int64 n]\n\nJoker return type: (atom-of go.std.io/SectionReader)"
  {:added "1.0"
   :go "newSectionReader(_r.(io.ReaderAt), _off, _n)"}
  [^GoObject _r, ^Int64 _off, ^Int64 _n])

JOKER FUNC io.Pipe from io/pipe.go:
(defn Pipe
  "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.io/PipeReader) (atom-of go.std.io/PipeWriter)]"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC io.ReadAtLeast from io/io.go:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte, min int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) buf, ^Int min]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readAtLeast(_r.(io.Reader), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _min)"}
;;   [^GoObject _r, ^Object _buf, ^Int _min])

JOKER FUNC io.ReadFull from io/io.go:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readFull(_r.(io.Reader), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^GoObject _r, ^Object _buf])

JOKER FUNC io.TeeReader from io/io.go:
(defn TeeReader
  "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo input arguments: (r Reader, w Writer)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "teeReader(_r.(io.Reader), _w.(io.Writer))"}
  [^GoObject _r, ^GoObject _w])

JOKER FUNC io.WriteString from io/io.go:
(defn WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo input arguments: (w Writer, s string)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "writeString(_w.(io.Writer), _s)"}
  [^GoObject _w, ^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["io"]
    :doc "Provides a low-level interface to the io package."
    :empty false}
  go.std.io)
JOKER FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "nopCloser(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "readAll(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
(defn ReadDir
  "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo input arguments: (dirname string)\n\nGo return type: ([]os.FileInfo, error)\n\nJoker input arguments: [^String dirname]\n\nJoker return type: [(vector-of go.std.os/FileInfo) Error]"
  {:added "1.0"
   :go "readDir(_dirname)"}
  [^String _dirname])

JOKER FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo input arguments: (filename string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String filename]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "readFile(_filename)"}
  [^String _filename])

JOKER FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo input arguments: (dir string, prefix string)\n\nGo return type: (name string, err error)\n\nJoker input arguments: [^String dir, ^String prefix]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "tempDir(_dir, _prefix)"}
  [^String _dir, ^String _prefix])

JOKER FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
(defn TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo input arguments: (dir string, pattern string)\n\nGo return type: (f *os.File, err error)\n\nJoker input arguments: [^String dir, ^String pattern]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "tempFile(_dir, _pattern)"}
  [^String _dir, ^String _pattern])

JOKER FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
;; (defn ^"Error" WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo input arguments: (filename string, data []byte, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String filename, ^(vector-of Byte) data, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(_filename, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)), _perm.(ABEND987(imports not yet supported: os.FileMode)))"}
;;   [^String _filename, ^Object _data, ^GoObject _perm])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the io/ioutil package."
    :empty false}
  go.std.io.ioutil)
JOKER FUNC log.Fatal from log/log.go:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatal(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Fatalf from log/log.go:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatalf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Fatalln from log/log.go:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatalln(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Flags from log/log.go:
(defn ^"Int" Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New from log/log.go:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo input arguments: (out io.Writer, prefix string, flag int)\n\nGo return type: *Logger\n\nJoker input arguments: [^go.std.io/Writer out, ^String prefix, ^Int flag]\n\nJoker return type: (atom-of go.std.log/Logger)"
;;   {:added "1.0"
;;    :go "_new(_out.(ABEND987(imports not yet supported: io.Writer)), _prefix, _flag)"}
;;   [^GoObject _out, ^String _prefix, ^Int _flag])

JOKER FUNC log.Output from log/log.go:
(defn ^"Error" Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo input arguments: (calldepth int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int calldepth, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(_calldepth, _s)"}
  [^Int _calldepth, ^String _s])

JOKER FUNC log.Panic from log/log.go:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "_panic(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Panicf from log/log.go:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "panicf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Panicln from log/log.go:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "panicln(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Prefix from log/log.go:
(defn ^"String" Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print from log/log.go:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "_print(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Printf from log/log.go:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "printf(_format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Println from log/log.go:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "_println(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.SetFlags from log/log.go:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n\nGo input arguments: (flag int)\n\nJoker input arguments: [^Int flag]"
;;   {:added "1.0"
;;    :go "setFlags(_flag)"}
;;   [^Int _flag])

JOKER FUNC log.SetOutput from log/log.go:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n\nGo input arguments: (w io.Writer)\n\nJoker input arguments: [^go.std.io/Writer w]"
;;   {:added "1.0"
;;    :go "setOutput(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC log.SetPrefix from log/log.go:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n\nGo input arguments: (prefix string)\n\nJoker input arguments: [^String prefix]"
;;   {:added "1.0"
;;    :go "setPrefix(_prefix)"}
;;   [^String _prefix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log"]
    :doc "Provides a low-level interface to the log package."
    :empty false}
  go.std.log)
JOKER FUNC log/syslog.Dial from log/syslog/syslog.go:
(defn Dial
  "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo input arguments: (network string, raddr string, priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^String network, ^String raddr, ^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "dial(_network, _raddr, _priority.(syslog.Priority), _tag)"}
  [^String _network, ^String _raddr, ^GoObject _priority, ^String _tag])

JOKER FUNC log/syslog.New from log/syslog/syslog.go:
(defn New
  "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo input arguments: (priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "_new(_priority.(syslog.Priority), _tag)"}
  [^GoObject _priority, ^String _tag])

JOKER FUNC log/syslog.NewLogger from log/syslog/syslog.go:
(defn NewLogger
  "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo input arguments: (p Priority, logFlag int)\n\nGo return type: (*log.Logger, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority p, ^Int logFlag]\n\nJoker return type: [(atom-of go.std.log/Logger) Error]"
  {:added "1.0"
   :go "newLogger(_p.(syslog.Priority), _logFlag)"}
  [^GoObject _p, ^Int _logFlag])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log/syslog"]
    :doc "Provides a low-level interface to the log/syslog package."
    :empty false}
  go.std.log.syslog)
JOKER FUNC math.Abs from math/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "abs(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Acos from math/asin.go:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "acos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Acosh from math/acosh.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "acosh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Asin from math/asin.go:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(0) = 0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "asin(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Asinh from math/asinh.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(0) = 0\n\tAsinh(Inf) = Inf\n\tAsinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "asinh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atan from math/atan.go:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(0) = 0\n     Atan(Inf) = Pi/2\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atan(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atan2 from math/atan2.go:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo input arguments: (y float64, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 y, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atan2(_y, _x)"}
;;   [^ABEND044(unsupported built-in type float64) _y, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atanh from math/atanh.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(0) = 0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atanh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Cbrt from math/cbrt.go:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(0) = 0\n\tCbrt(Inf) = Inf\n\tCbrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cbrt(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Ceil from math/floor.go:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(0) = 0\n\tCeil(Inf) = Inf\n\tCeil(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "ceil(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Copysign from math/copysign.go:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "copysign(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Cos from math/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(Inf) = NaN\n\tCos(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Cosh from math/sinh.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(0) = 1\n\tCosh(Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cosh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Dim from math/dim.go:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "dim(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Erf from math/erf.go:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erf(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfc from math/erf.go:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfc(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfcinv from math/erfinv.go:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfcinv(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfinv from math/erfinv.go:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfinv(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Exp from math/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "exp(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Exp2 from math/exp.go:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "exp2(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Expm1 from math/expm1.go:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "expm1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Float32bits from math/unsafe.go:
;; (defn Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float32)\n\nGo return type: uint32\n\nJoker input arguments: [^float32 f]"
;;   {:added "1.0"
;;    :go "float32bits(_f)"}
;;   [^ABEND044(unsupported built-in type float32) _f])

JOKER FUNC math.Float32frombits from math/unsafe.go:
;; (defn Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\n\nGo input arguments: (b uint32)\n\nGo return type: ...\n\nJoker input arguments: [^UInt32 b]\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "float32frombits(_b)"}
;;   [^UInt32 _b])

JOKER FUNC math.Float64bits from math/unsafe.go:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 f]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "float64bits(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.Float64frombits from math/unsafe.go:
;; (defn Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\n\nGo input arguments: (b uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 b]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "float64frombits(_b)"}
;;   [^ABEND044(unsupported built-in type uint64) _b])

JOKER FUNC math.Floor from math/floor.go:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(0) = 0\n\tFloor(Inf) = Inf\n\tFloor(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "floor(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Frexp from math/frexp.go:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac  2**exp,\nwith the absolute value of frac in the interval [, 1).\n\nSpecial cases are:\n\tFrexp(0) = 0, 0\n\tFrexp(Inf) = Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo input arguments: (f float64)\n\nGo return type: (frac ..., exp int)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "frexp(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.Gamma from math/gamma.go:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "gamma(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Hypot from math/hypot.go:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(Inf, q) = +Inf\n\tHypot(p, Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo input arguments: (p float64, q float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 p, ^float64 q]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "hypot(_p, _q)"}
;;   [^ABEND044(unsupported built-in type float64) _p, ^ABEND044(unsupported built-in type float64) _q])

JOKER FUNC math.Ilogb from math/logb.go:
;; (defn ^"Int" Ilogb
;;   "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo input arguments: (x float64)\n\nGo return type: int\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Ilogb(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Inf from math/bits.go:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo input arguments: (sign int)\n\nGo return type: ...\n\nJoker input arguments: [^Int sign]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "inf(_sign)"}
;;   [^Int _sign])

JOKER FUNC math.IsInf from math/bits.go:
;; (defn ^"Bool" IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo input arguments: (f float64, sign int)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f, ^Int sign]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsInf(_f, _sign)"}
;;   [^ABEND044(unsupported built-in type float64) _f, ^Int _sign])

JOKER FUNC math.IsNaN from math/bits.go:
;; (defn ^"Bool" IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo input arguments: (f float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsNaN(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.J0 from math/j0.go:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "j0(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.J1 from math/j1.go:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(Inf) = 0\n\tJ1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "j1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Jn from math/jn.go:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "jn(_n, _x)"}
;;   [^Int _n, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Ldexp from math/ldexp.go:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac  2**exp.\n\nSpecial cases are:\n\tLdexp(0, exp) = 0\n\tLdexp(Inf, exp) = Inf\n\tLdexp(NaN, exp) = NaN\n\nGo input arguments: (frac float64, exp int)\n\nGo return type: ...\n\nJoker input arguments: [^float64 frac, ^Int exp]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "ldexp(_frac, _exp)"}
;;   [^ABEND044(unsupported built-in type float64) _frac, ^Int _exp])

JOKER FUNC math.Lgamma from math/lgamma.go:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: (lgamma ..., sign int)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "lgamma(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log from math/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log10 from math/log10.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log10(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log1p from math/log1p.go:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(0) = 0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log1p(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log2 from math/log10.go:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log2(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Logb from math/logb.go:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "logb(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Max from math/dim.go:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, 0) = Max(0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "max(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Min from math/dim.go:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, 0) = Min(0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "min(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Mod from math/mod.go:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, Inf) = x\n\tMod(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "mod(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Modf from math/modf.go:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(Inf) = Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo input arguments: (f float64)\n\nGo return type: (int ..., frac ...)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "modf(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.NaN from math/bits.go:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math.Nextafter from math/nextafter.go:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "nextafter(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Nextafter32 from math/nextafter.go:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo input arguments: (x float32, y float32)\n\nGo return type: ...\n\nJoker input arguments: [^float32 x, ^float32 y]\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "nextafter32(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float32) _x, ^ABEND044(unsupported built-in type float32) _y])

JOKER FUNC math.Pow from math/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, 0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(0, y) = Inf for y an odd integer < 0\n\tPow(0, -Inf) = +Inf\n\tPow(0, +Inf) = +0\n\tPow(0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(0, y) = 0 for y an odd integer > 0\n\tPow(0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "pow(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Pow10 from math/pow10.go:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo input arguments: (n int)\n\nGo return type: ...\n\nJoker input arguments: [^Int n]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "pow10(_n)"}
;;   [^Int _n])

JOKER FUNC math.Remainder from math/remainder.go:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "remainder(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Round from math/floor.go:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(0) = 0\n\tRound(Inf) = Inf\n\tRound(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "round(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.RoundToEven from math/floor.go:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(0) = 0\n\tRoundToEven(Inf) = Inf\n\tRoundToEven(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "roundToEven(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Signbit from math/signbit.go:
;; (defn ^"Bool" Signbit
;;   "Signbit returns true if x is negative or negative zero.\n\nGo input arguments: (x float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.Signbit(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sin from math/sin.go:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(0) = 0\n\tSin(Inf) = NaN\n\tSin(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sin(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sincos from math/sincos.go:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(0) = 0, 1\n\tSincos(Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo input arguments: (x float64)\n\nGo return type: (sin ..., cos ...)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "sincos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sinh from math/sinh.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(0) = 0\n\tSinh(Inf) = Inf\n\tSinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sinh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sqrt from math/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(0) = 0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sqrt(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Tan from math/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(0) = 0\n\tTan(Inf) = NaN\n\tTan(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "tan(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Tanh from math/tanh.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(0) = 0\n\tTanh(Inf) = 1\n\tTanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "tanh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Trunc from math/floor.go:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(0) = 0\n\tTrunc(Inf) = Inf\n\tTrunc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "trunc(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Y0 from math/j0.go:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "y0(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Y1 from math/j1.go:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "y1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Yn from math/jn.go:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n  0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "yn(_n, _x)"}
;;   [^Int _n, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math/big.Jacobi from math/big/int.go:
;; (defn ^"Int" Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo input arguments: (x *Int, y *Int)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "big.Jacobi(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_big.Int(_x.(big.Int))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_big.Int(_y.(big.Int))))"}
;;   [^Object _x, ^Object _y])

JOKER FUNC math/big.NewFloat from math/big/float.go:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo input arguments: (x float64)\n\nGo return type: *Float\n\nJoker input arguments: [^float64 x]\n\nJoker return type: (atom-of go.std.math.big/Float)"
;;   {:added "1.0"
;;    :go "newFloat(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math/big.NewInt from math/big/int.go:
(defn NewInt
  "NewInt allocates and returns a new Int set to x.\n\nGo input arguments: (x int64)\n\nGo return type: *Int\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: (atom-of go.std.math.big/Int)"
  {:added "1.0"
   :go "newInt(_x)"}
  [^Int64 _x])

JOKER FUNC math/big.NewRat from math/big/rat.go:
(defn NewRat
  "NewRat creates a new Rat with numerator a and denominator b.\n\nGo input arguments: (a int64, b int64)\n\nGo return type: *Rat\n\nJoker input arguments: [^Int64 a, ^Int64 b]\n\nJoker return type: (atom-of go.std.math.big/Rat)"
  {:added "1.0"
   :go "newRat(_a, _b)"}
  [^Int64 _a, ^Int64 _b])

JOKER FUNC math/big.ParseFloat from math/big/floatconv.go:
(defn ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo input arguments: (s string, base int, prec uint, mode RoundingMode)\n\nGo return type: (f *Float, b int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^UInt prec, ^go.std.math.big/RoundingMode mode]\n\nJoker return type: [(atom-of go.std.math.big/Float) Int Error]"
  {:added "1.0"
   :go "parseFloat(_s, _base, _prec, _mode.(big.RoundingMode))"}
  [^String _s, ^Int _base, ^UInt _prec, ^GoObject _mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/big"]
    :doc "Provides a low-level interface to the math/big package."
    :empty false}
  go.std.math.big)
JOKER FUNC math/bits.LeadingZeros from math/bits/bits.go:
(defn ^"Int" LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.LeadingZeros16 from math/bits/bits.go:
(defn ^"Int" LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.LeadingZeros32 from math/bits/bits.go:
(defn ^"Int" LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
;; (defn ^"Int" LeadingZeros64
;;   "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
;; (defn ^"Int" LeadingZeros8
;;   "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Len from math/bits/bits.go:
(defn ^"Int" Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.Len16 from math/bits/bits.go:
(defn ^"Int" Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.Len32 from math/bits/bits.go:
(defn ^"Int" Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.Len64 from math/bits/bits.go:
;; (defn ^"Int" Len64
;;   "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Len8 from math/bits/bits.go:
;; (defn ^"Int" Len8
;;   "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.OnesCount from math/bits/bits.go:
(defn ^"Int" OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.OnesCount16 from math/bits/bits.go:
(defn ^"Int" OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.OnesCount32 from math/bits/bits.go:
(defn ^"Int" OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.OnesCount64 from math/bits/bits.go:
;; (defn ^"Int" OnesCount64
;;   "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.OnesCount8 from math/bits/bits.go:
;; (defn ^"Int" OnesCount8
;;   "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Reverse from math/bits/bits.go:
(defn Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x]"
  {:added "1.0"
   :go "reverse(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.Reverse16 from math/bits/bits.go:
(defn Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x]"
  {:added "1.0"
   :go "reverse16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.Reverse32 from math/bits/bits.go:
(defn Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x]"
  {:added "1.0"
   :go "reverse32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.Reverse64 from math/bits/bits.go:
;; (defn Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "reverse64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Reverse8 from math/bits/bits.go:
;; (defn Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint8)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "reverse8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.ReverseBytes from math/bits/bits.go:
(defn ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x]"
  {:added "1.0"
   :go "reverseBytes(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
(defn ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x]"
  {:added "1.0"
   :go "reverseBytes16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
(defn ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x]"
  {:added "1.0"
   :go "reverseBytes32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
;; (defn ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "reverseBytes64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.RotateLeft from math/bits/bits.go:
(defn RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo input arguments: (x uint, k int)\n\nGo return type: uint\n\nJoker input arguments: [^UInt x, ^Int k]"
  {:added "1.0"
   :go "rotateLeft(_x, _k)"}
  [^UInt _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft16 from math/bits/bits.go:
(defn RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo input arguments: (x uint16, k int)\n\nGo return type: uint16\n\nJoker input arguments: [^UInt16 x, ^Int k]"
  {:added "1.0"
   :go "rotateLeft16(_x, _k)"}
  [^UInt16 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft32 from math/bits/bits.go:
(defn RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo input arguments: (x uint32, k int)\n\nGo return type: uint32\n\nJoker input arguments: [^UInt32 x, ^Int k]"
  {:added "1.0"
   :go "rotateLeft32(_x, _k)"}
  [^UInt32 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft64 from math/bits/bits.go:
;; (defn RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo input arguments: (x uint64, k int)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x, ^Int k]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "rotateLeft64(_x, _k)"}
;;   [^ABEND044(unsupported built-in type uint64) _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft8 from math/bits/bits.go:
;; (defn RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo input arguments: (x uint8, k int)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x, ^Int k]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "rotateLeft8(_x, _k)"}
;;   [^ABEND044(unsupported built-in type uint8) _x, ^Int _k])

JOKER FUNC math/bits.TrailingZeros from math/bits/bits.go:
(defn ^"Int" TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.TrailingZeros16 from math/bits/bits.go:
(defn ^"Int" TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.TrailingZeros32 from math/bits/bits.go:
(defn ^"Int" TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
;; (defn ^"Int" TrailingZeros64
;;   "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
;; (defn ^"Int" TrailingZeros8
;;   "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/bits"]
    :doc "Provides a low-level interface to the math/bits package."
    :empty false}
  go.std.math.bits)
JOKER FUNC math/cmplx.Abs from math/cmplx/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "abs(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acos from math/cmplx/asin.go:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "acos(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acosh from math/cmplx/asin.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "acosh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asin from math/cmplx/asin.go:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "asin(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asinh from math/cmplx/asin.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "asinh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atan from math/cmplx/asin.go:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "atan(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atanh from math/cmplx/asin.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "atanh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Conj from math/cmplx/conj.go:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "conj(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cos from math/cmplx/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cos(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cosh from math/cmplx/sin.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cosh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cot from math/cmplx/tan.go:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cot(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Exp from math/cmplx/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "exp(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Inf from math/cmplx/isinf.go:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])

JOKER FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
;; (defn ^"Bool" IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsInf(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
;; (defn ^"Bool" IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsNaN(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log from math/cmplx/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "log(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log10 from math/cmplx/log.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "log10(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.NaN from math/cmplx/isnan.go:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math/cmplx.Phase from math/cmplx/phase.go:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "phase(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Polar from math/cmplx/polar.go:
;; (defn Polar
;;   "Polar returns the absolute value r and phase  of x,\nsuch that x = r * e**i.\nThe phase is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: (r ...,  ...)\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "polar(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Pow from math/cmplx/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, 0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo input arguments: (x complex128, y complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x, ^complex128 y]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "pow(_x, _y)"}
;;   [^ABEND044(unsupported built-in type complex128) _x, ^ABEND044(unsupported built-in type complex128) _y])

JOKER FUNC math/cmplx.Rect from math/cmplx/rect.go:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, .\n\nGo input arguments: (r float64,  float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 r, ^float64 ]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "rect(_r, _)"}
;;   [^ABEND044(unsupported built-in type float64) _r, ^ABEND044(unsupported built-in type float64) _])

JOKER FUNC math/cmplx.Sin from math/cmplx/sin.go:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sin(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sinh from math/cmplx/sin.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sinh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r)  0 and imag(r) has the same sign as imag(x).\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sqrt(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tan from math/cmplx/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "tan(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tanh from math/cmplx/tan.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "tanh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/rand.ExpFloat64 from math/rand/rand.go:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])

JOKER FUNC math/rand.Float32 from math/rand/rand.go:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "_float32()"}
;;   [])

JOKER FUNC math/rand.Float64 from math/rand/rand.go:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "_float64()"}
;;   [])

JOKER FUNC math/rand.Int from math/rand/rand.go:
(defn ^"Int" Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC math/rand.Int31 from math/rand/rand.go:
(defn Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int32\n\nJoker input arguments: []"
  {:added "1.0"
   :go "int31()"}
  [])

JOKER FUNC math/rand.Int31n from math/rand/rand.go:
(defn Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int32)\n\nGo return type: int32\n\nJoker input arguments: [^Int32 n]"
  {:added "1.0"
   :go "int31n(_n)"}
  [^Int32 _n])

JOKER FUNC math/rand.Int63 from math/rand/rand.go:
(defn Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int64\n\nJoker input arguments: []"
  {:added "1.0"
   :go "int63()"}
  [])

JOKER FUNC math/rand.Int63n from math/rand/rand.go:
(defn Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int64)\n\nGo return type: int64\n\nJoker input arguments: [^Int64 n]"
  {:added "1.0"
   :go "int63n(_n)"}
  [^Int64 _n])

JOKER FUNC math/rand.Intn from math/rand/rand.go:
(defn ^"Int" Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(_n)"}
  [^Int _n])

JOKER FUNC math/rand.New from math/rand/rand.go:
(defn New
  "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo input arguments: (src Source)\n\nGo return type: *Rand\n\nJoker input arguments: [^go.std.math.rand/Source src]\n\nJoker return type: (atom-of go.std.math.rand/Rand)"
  {:added "1.0"
   :go "_new(_src.(rand.Source))"}
  [^GoObject _src])

JOKER FUNC math/rand.NewSource from math/rand/rand.go:
(defn NewSource
  "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo input arguments: (seed int64)\n\nGo return type: Source\n\nJoker input arguments: [^Int64 seed]\n\nJoker return type: go.std.math.rand/Source"
  {:added "1.0"
   :go "newSource(_seed)"}
  [^Int64 _seed])

JOKER FUNC math/rand.NewZipf from math/rand/zipf.go:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k  [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo input arguments: (r *Rand, s float64, v float64, imax uint64)\n\nGo return type: *Zipf\n\nJoker input arguments: [^(atom-of go.std.math.rand/Rand) r, ^float64 s, ^float64 v, ^uint64 imax]\n\nJoker return type: (atom-of go.std.math.rand/Zipf)"
;;   {:added "1.0"
;;    :go "newZipf(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_rand.Rand(_r.(rand.Rand))), _s, _v, _imax)"}
;;   [^Object _r, ^ABEND044(unsupported built-in type float64) _s, ^ABEND044(unsupported built-in type float64) _v, ^ABEND044(unsupported built-in type uint64) _imax])

JOKER FUNC math/rand.NormFloat64 from math/rand/rand.go:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])

JOKER FUNC math/rand.Perm from math/rand/rand.go:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo input arguments: (n int)\n\nGo return type: []int\n\nJoker input arguments: [^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "perm(_n)"}
  [^Int _n])

JOKER FUNC math/rand.Read from math/rand/rand.go:
;; (defn Read
;;   "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo input arguments: (p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC math/rand.Seed from math/rand/rand.go:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n\nGo input arguments: (seed int64)\n\nJoker input arguments: [^Int64 seed]"
;;   {:added "1.0"
;;    :go "seed(_seed)"}
;;   [^Int64 _seed])

JOKER FUNC math/rand.Shuffle from math/rand/rand.go:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n\nGo input arguments: (n int, swap func)\n\nJoker input arguments: [^Int n, ^fn swap]"
;;   {:added "1.0"
;;    :go "shuffle(_n, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _n, ^fn _swap])

JOKER FUNC math/rand.Uint32 from math/rand/rand.go:
(defn Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: uint32\n\nJoker input arguments: []"
  {:added "1.0"
   :go "_uint32()"}
  [])

JOKER FUNC math/rand.Uint64 from math/rand/rand.go:
;; (defn Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "_uint64()"}
;;   [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/rand"]
    :doc "Provides a low-level interface to the math/rand package."
    :empty false}
  go.std.math.rand)
JOKER FUNC mime.AddExtensionType from mime/type.go:
(defn ^"Error" AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo input arguments: (ext string, typ string)\n\nGo return type: error\n\nJoker input arguments: [^String ext, ^String typ]\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(_ext, _typ)"}
  [^String _ext, ^String _typ])

JOKER FUNC mime.ExtensionsByType from mime/type.go:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo input arguments: (typ string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String typ]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "extensionsByType(_typ)"}
  [^String _typ])

JOKER FUNC mime.FormatMediaType from mime/mediatype.go:
;; (defn ^"String" FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo input arguments: (t string, param map[])\n\nGo return type: string\n\nJoker input arguments: [^String t, ^{} param]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(_t, ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^String _t, ^{} _param])

JOKER FUNC mime.ParseMediaType from mime/mediatype.go:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo input arguments: (v string)\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker input arguments: [^String v]\n\nJoker return type: [String ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/mediatype.go:111:57) Error]"
;;   {:added "1.0"
;;    :go "parseMediaType(_v)"}
;;   [^String _v])

JOKER FUNC mime.TypeByExtension from mime/type.go:
(defn ^"String" TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo input arguments: (ext string)\n\nGo return type: string\n\nJoker input arguments: [^String ext]\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(_ext)"}
  [^String _ext])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["mime"]
    :doc "Provides a low-level interface to the mime package."
    :empty false}
  go.std.mime)
JOKER FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo input arguments: (r io.Reader, boundary string)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^String boundary]\n\nJoker return type: (atom-of go.std.mime.multipart/Reader)"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)), _boundary)"}
;;   [^GoObject _r, ^String _boundary])

JOKER FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.multipart/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Reader)"
;;   {:added "1.0"
;;    :go "newReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "cIDRMask(_ones, _bits)"}
  [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.DialIP from net/iprawsock.go:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
;;   {:added "1.0"
;;    :go "dialIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_laddr.(net.IPAddr))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_raddr.(net.IPAddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
;;   {:added "1.0"
;;    :go "dialTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_laddr.(net.TCPAddr))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_raddr.(net.TCPAddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(_network, _address, _timeout.(ABEND987(imports not yet supported: time.Duration)))"}
;;   [^String _network, ^String _address, ^GoObject _timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
;;   {:added "1.0"
;;    :go "dialUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_laddr.(net.UDPAddr))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_raddr.(net.UDPAddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
;;   {:added "1.0"
;;    :go "dialUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr.(net.UnixAddr))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_raddr.(net.UnixAddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "fileConn(ConvertToIndirectOfos.File(_f.(ABEND987(imports not yet supported: os.File))))"}
;;   [^Object _f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "fileListener(ConvertToIndirectOfos.File(_f.(ABEND987(imports not yet supported: os.File))))"}
;;   [^Object _f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(ConvertToIndirectOfos.File(_f.(ABEND987(imports not yet supported: os.File))))"}
;;   [^Object _f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "iPv4(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "iPv4Mask(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "interfaceByIndex(_index)"}
  [^Int _index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "interfaceByName(_name)"}
  [^String _name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "listen(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
;;   {:added "1.0"
;;    :go "listenIP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.IPAddr(_laddr.(net.IPAddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.Interface(_ifi.(net.Interface))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_gaddr.(net.UDPAddr))))"}
;;   [^String _network, ^Object _ifi, ^Object _gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "listenPacket(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
;;   {:added "1.0"
;;    :go "listenTCP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.TCPAddr(_laddr.(net.TCPAddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
;;   {:added "1.0"
;;    :go "listenUDP(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UDPAddr(_laddr.(net.UDPAddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
;;   {:added "1.0"
;;    :go "listenUnix(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr.(net.UnixAddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(_network, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_net.UnixAddr(_laddr.(net.UnixAddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "lookupIP(_host)"}
  [^String _host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "lookupMX(_name)"}
  [^String _name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "lookupNS(_name)"}
  [^String _name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "lookupSRV(_service, _proto, _name)"}
  [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "parseCIDR(_s)"}
  [^String _s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "parseIP(_s)"}
  [^String _s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "parseMAC(_s)"}
  [^String _s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "resolveIPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "resolveTCPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "resolveUDPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "resolveUnixAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "splitHostPort(_hostport)"}
  [^String _hostport])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net"]
    :doc "Provides a low-level interface to the net package."
    :empty false}
  go.std.net)
JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^Object _data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "_error(_w.(http.ResponseWriter), _error, _code)"}
;;   [^GoObject _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "fileServer(_root.(http.FileSystem))"}
  [^GoObject _root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "get(_url)"}
  [^String _url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "handle(_pattern, _handler.(http.Handler))"}
;;   [^String _pattern, ^GoObject _handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "handleFunc(_pattern, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "head(_url)"}
  [^String _url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(_addr, _handler.(http.Handler))"}
  [^String _addr, ^GoObject _handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, _handler.(http.Handler))"}
  [^String _addr, ^String _certFile, ^String _keyFile, ^GoObject _handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Int64 n]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "maxBytesReader(_w.(http.ResponseWriter), _r.(ABEND987(imports not yet supported: io.ReadCloser)), _n)"}
;;   [^GoObject _w, ^GoObject _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "newFileTransport(_fs.(http.FileSystem))"}
  [^GoObject _fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "newRequest(_method, _url, _body.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^String _method, ^String _url, ^GoObject _body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "notFound(_w.(http.ResponseWriter), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r.(http.Request))))"}
;;   [^GoObject _w, ^Object _r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Bool]"
  {:added "1.0"
   :go "parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t time.Time, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "parseTime(_text)"}
  [^String _text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "post(_url, _contentType, _body.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^String _url, ^String _contentType, ^GoObject _body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "postForm(_url, _data.(ABEND987(imports not yet supported: url.Values)))"}
;;   [^String _url, ^GoObject _data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req.(http.Request))))"}
;;   [^Object _req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(ConvertToIndirectOfurl.URL(_fixedURL.(ABEND987(imports not yet supported: url.URL))))"}
;;   [^Object _fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "readRequest(ConvertToIndirectOfbufio.Reader(_b.(ABEND987(imports not yet supported: bufio.Reader))))"}
;;   [^Object _b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "readResponse(ConvertToIndirectOfbufio.Reader(_r.(ABEND987(imports not yet supported: bufio.Reader))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req.(http.Request))))"}
;;   [^Object _r, ^Object _req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "redirect(_w.(http.ResponseWriter), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r.(http.Request))), _url, _code)"}
;;   [^GoObject _w, ^Object _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "redirectHandler(_url, _code)"}
  [^String _url, ^Int _code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(_l.(ABEND987(imports not yet supported: net.Listener)), _handler.(http.Handler))"}
;;   [^GoObject _l, ^GoObject _handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "serveContent(_w.(http.ResponseWriter), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_req.(http.Request))), _name, _modtime.(ABEND987(imports not yet supported: time.Time)), _content.(ABEND987(imports not yet supported: io.ReadSeeker)))"}
;;   [^GoObject _w, ^Object _req, ^String _name, ^GoObject _modtime, ^GoObject _content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "serveFile(_w.(http.ResponseWriter), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Request(_r.(http.Request))), _name)"}
;;   [^GoObject _w, ^Object _r, ^String _name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(_l.(ABEND987(imports not yet supported: net.Listener)), _handler.(http.Handler), _certFile, _keyFile)"}
;;   [^GoObject _l, ^GoObject _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "setCookie(_w.(http.ResponseWriter), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_http.Cookie(_cookie.(http.Cookie))))"}
;;   [^GoObject _w, ^Object _cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "stripPrefix(_prefix, _h.(http.Handler))"}
  [^String _prefix, ^GoObject _h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "timeoutHandler(_h.(http.Handler), _dt.(ABEND987(imports not yet supported: time.Duration)), _msg)"}
;;   [^GoObject _h, ^GoObject _dt, ^String _msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http"]
    :doc "Provides a low-level interface to the net/http package."
    :empty false}
  go.std.net.http)
JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(_handler.(ABEND987(imports not yet supported: http.Handler)))"}
;;   [^GoObject _handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cgi package."
    :empty false}
  go.std.net.http.cgi)
JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
;;   {:added "1.0"
;;    :go "_new(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_cookiejar.Options(_o.(cookiejar.Options))))"}
;;   [^Object _o])

JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^Object _r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(_l.(ABEND987(imports not yet supported: net.Listener)), _handler.(ABEND987(imports not yet supported: http.Handler)))"}
;;   [^GoObject _l, ^GoObject _handler])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "newRequest(_method, _target, _body.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^String _method, ^String _target, ^GoObject _body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "newServer(_handler.(ABEND987(imports not yet supported: http.Handler)))"}
;;   [^GoObject _handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "newTLSServer(_handler.(ABEND987(imports not yet supported: http.Handler)))"}
;;   [^GoObject _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "newUnstartedServer(_handler.(ABEND987(imports not yet supported: http.Handler)))"}
;;   [^GoObject _handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/httptest package."
    :empty false}
  go.std.net.http.httptest)
JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "contextClientTrace(_ctx.(ABEND987(imports not yet supported: context.Context)))"}
;;   [^GoObject _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "withClientTrace(_ctx.(ABEND987(imports not yet supported: context.Context)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_httptrace.ClientTrace(_trace.(httptrace.ClientTrace))))"}
;;   [^GoObject _ctx, ^Object _trace])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Bool body]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(ConvertToIndirectOfhttp.Request(_req.(ABEND987(imports not yet supported: http.Request))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Bool body]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(ConvertToIndirectOfhttp.Request(_req.(ABEND987(imports not yet supported: http.Request))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Bool body]\n\nJoker return type: [(vector-of ) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(ConvertToIndirectOfhttp.Response(_resp.(ABEND987(imports not yet supported: http.Response))), _body)"}
;;   [^Object _resp, ^Bool _body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newChunkedReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "newChunkedWriter(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "newClientConn(_c.(ABEND987(imports not yet supported: net.Conn)), ConvertToIndirectOfbufio.Reader(_r.(ABEND987(imports not yet supported: bufio.Reader))))"}
;;   [^GoObject _c, ^Object _r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "newProxyClientConn(_c.(ABEND987(imports not yet supported: net.Conn)), ConvertToIndirectOfbufio.Reader(_r.(ABEND987(imports not yet supported: bufio.Reader))))"}
;;   [^GoObject _c, ^Object _r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "newServerConn(_c.(ABEND987(imports not yet supported: net.Conn)), ConvertToIndirectOfbufio.Reader(_r.(ABEND987(imports not yet supported: bufio.Reader))))"}
;;   [^GoObject _c, ^Object _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "newSingleHostReverseProxy(ConvertToIndirectOfurl.URL(_target.(ABEND987(imports not yet supported: url.URL))))"}
;;   [^Object _target])

JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "cmdline(_w.(ABEND987(imports not yet supported: http.ResponseWriter)), ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^GoObject _w, ^Object _r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "handler(_name)"}
  [^String _name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "index(_w.(ABEND987(imports not yet supported: http.ResponseWriter)), ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^GoObject _w, ^Object _r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "profile(_w.(ABEND987(imports not yet supported: http.ResponseWriter)), ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^GoObject _w, ^Object _r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "symbol(_w.(ABEND987(imports not yet supported: http.ResponseWriter)), ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^GoObject _w, ^Object _r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "trace(_w.(ABEND987(imports not yet supported: http.ResponseWriter)), ConvertToIndirectOfhttp.Request(_r.(ABEND987(imports not yet supported: http.Request))))"}
;;   [^GoObject _w, ^Object _r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/pprof package."
    :empty false}
  go.std.net.http.pprof)
JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "parseAddress(_address)"}
  [^String _address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "parseAddressList(_list)"}
  [^String _list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
(defn ParseDate
  "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (time.Time, error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "parseDate(_date)"}
  [^String _date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "readMessage(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/mail package."
    :empty false}
  go.std.net.mail)
JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "accept(_lis.(ABEND987(imports not yet supported: net.Listener)))"}
;;   [^GoObject _lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "dialHTTP(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "dialHTTPPath(_network, _address, _path)"}
  [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "newClient(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "newClientWithCodec(_codec.(rpc.ClientCodec))"}
  [^GoObject _codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "serveCodec(_codec.(rpc.ServerCodec))"}
;;   [^GoObject _codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(_codec.(rpc.ServerCodec))"}
  [^GoObject _codec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/rpc"]
    :doc "Provides a low-level interface to the net/rpc package."
    :empty false}
  go.std.net.rpc)
JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "newClient(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "newClientCodec(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "newServerCodec(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/rpc/jsonrpc package."
    :empty false}
  go.std.net.rpc.jsonrpc)
JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "cRAMMD5Auth(_username, _secret)"}
  [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "dial(_addr)"}
  [^String _addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "newClient(_conn.(ABEND987(imports not yet supported: net.Conn)), _host)"}
;;   [^GoObject _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "plainAuth(_identity, _username, _password, _host)"}
  [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(_addr, _a.(smtp.Auth), _from, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_to)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_msg)))"}
;;   [^String _addr, ^GoObject _a, ^String _from, ^Object _to, ^Object _msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/smtp package."
    :empty false}
  go.std.net.smtp)
JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "dial(_network, _addr)"}
  [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "newConn(_conn.(ABEND987(imports not yet supported: io.ReadWriteCloser)))"}
;;   [^GoObject _conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "newReader(ConvertToIndirectOfbufio.Reader(_r.(ABEND987(imports not yet supported: bufio.Reader))))"}
;;   [^Object _r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(ConvertToIndirectOfbufio.Writer(_w.(ABEND987(imports not yet supported: bufio.Writer))))"}
;;   [^Object _w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "trimBytes(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/textproto"]
    :doc "Provides a low-level interface to the net/textproto package."
    :empty false}
  go.std.net.textproto)
JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "parse(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "parseQuery(_query)"}
  [^String _query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "parseRequestURI(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "user(_username)"}
  [^String _username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "userPassword(_username, _password)"}
  [^String _username, ^String _password])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/url"]
    :doc "Provides a low-level interface to the net/url package."
    :empty false}
  go.std.net.url)
JOKER FUNC os.Chdir from os/file.go:
(defn ^"Error" Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (dir string)\n\nGo return type: error\n\nJoker input arguments: [^String dir]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(_dir)"}
  [^String _dir])

JOKER FUNC os.Chmod from os/file.go:
(defn ^"Error" Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo input arguments: (name string, mode FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chmod(_name, _mode.(os.FileMode))"}
  [^String _name, ^GoObject _mode])

JOKER FUNC os.Chown from os/file_posix.go:
(defn ^"Error" Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Chtimes from os/file_posix.go:
;; (defn ^"Error" Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, atime time.Time, mtime time.Time)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.time/Time atime, ^go.std.time/Time mtime]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(_name, _atime.(ABEND987(imports not yet supported: time.Time)), _mtime.(ABEND987(imports not yet supported: time.Time)))"}
;;   [^String _name, ^GoObject _atime, ^GoObject _mtime])

JOKER FUNC os.Clearenv from os/env.go:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC os.Create from os/file.go:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "create(_name)"}
  [^String _name])

JOKER FUNC os.Environ from os/env.go:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC os.Executable from os/executable.go:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "executable()"}
  [])

JOKER FUNC os.Exit from os/proc.go:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n\nGo input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "exit(_code)"}
;;   [^Int _code])

JOKER FUNC os.Expand from os/env.go:
;; (defn ^"String" Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo input arguments: (s string, mapping func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn mapping]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _mapping])

JOKER FUNC os.ExpandEnv from os/env.go:
(defn ^"String" ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(_s)"}
  [^String _s])

JOKER FUNC os.FindProcess from os/exec.go:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo input arguments: (pid int)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
  {:added "1.0"
   :go "findProcess(_pid)"}
  [^Int _pid])

JOKER FUNC os.Getegid from os/proc.go:
(defn ^"Int" Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv from os/env.go:
(defn ^"String" Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo input arguments: (key string)\n\nGo return type: string\n\nJoker input arguments: [^String key]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(_key)"}
  [^String _key])

JOKER FUNC os.Geteuid from os/proc.go:
(defn ^"Int" Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid from os/proc.go:
(defn ^"Int" Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups from os/proc.go:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC os.Getpagesize from os/types.go:
(defn ^"Int" Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid from os/exec.go:
(defn ^"Int" Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid from os/exec.go:
(defn ^"Int" Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid from os/proc.go:
(defn ^"Int" Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd from os/getwd.go:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC os.Hostname from os/sys.go:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "hostname()"}
  [])

JOKER FUNC os.IsExist from os/error.go:
;; (defn ^"Bool" IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:68:18) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsExist(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:68:18) _err])

JOKER FUNC os.IsNotExist from os/error.go:
;; (defn ^"Bool" IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:75:21) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsNotExist(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:75:21) _err])

JOKER FUNC os.IsPathSeparator from os/path_unix.go:
;; (defn ^"Bool" IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character.\n\nGo input arguments: (c uint8)\n\nGo return type: bool\n\nJoker input arguments: [^uint8 c]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPathSeparator(_c)"}
;;   [^ABEND044(unsupported built-in type uint8) _c])

JOKER FUNC os.IsPermission from os/error.go:
;; (defn ^"Bool" IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:82:23) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPermission(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:82:23) _err])

JOKER FUNC os.IsTimeout from os/error.go:
;; (defn ^"Bool" IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:88:20) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsTimeout(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:88:20) _err])

JOKER FUNC os.Lchown from os/file_posix.go:
(defn ^"Error" Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Link from os/file_unix.go:
(defn ^"Error" Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.LookupEnv from os/env.go:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo input arguments: (key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "lookupEnv(_key)"}
  [^String _key])

JOKER FUNC os.Lstat from os/stat.go:
(defn Lstat
  "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "lstat(_name)"}
  [^String _name])

JOKER FUNC os.Mkdir from os/file.go:
(defn ^"Error" Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Mkdir(_name, _perm.(os.FileMode))"}
  [^String _name, ^GoObject _perm])

JOKER FUNC os.MkdirAll from os/path.go:
(defn ^"Error" MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo input arguments: (path string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.MkdirAll(_path, _perm.(os.FileMode))"}
  [^String _path, ^GoObject _perm])

JOKER FUNC os.NewFile from os/file_unix.go:
;; (defn NewFile
;;   "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo input arguments: (fd uintptr, name string)\n\nGo return type: *File\n\nJoker input arguments: [^uintptr fd, ^String name]\n\nJoker return type: (atom-of go.std.os/File)"
;;   {:added "1.0"
;;    :go "newFile(_fd, _name)"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd, ^String _name])

JOKER FUNC os.NewSyscallError from os/error.go:
;; (defn ^"Error" NewSyscallError
;;   "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo input arguments: (syscall string, err error)\n\nGo return type: error\n\nJoker input arguments: [^String syscall, ^ABEND885(unrecognized type error at: GO.link/src/os/error.go:58:42) err]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.NewSyscallError(_syscall, _err)"}
;;   [^String _syscall, ^ABEND885(unrecognized type error at: GO.link/src/os/error.go:58:42) _err])

JOKER FUNC os.Open from os/file.go:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC os.OpenFile from os/file.go:
(defn OpenFile
  "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, flag int, perm FileMode)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name, ^Int flag, ^go.std.os/FileMode perm]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "openFile(_name, _flag, _perm.(os.FileMode))"}
  [^String _name, ^Int _flag, ^GoObject _perm])

JOKER FUNC os.Pipe from os/pipe_bsd.go:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os/File) (atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC os.Readlink from os/file_posix.go:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "readlink(_name)"}
  [^String _name])

JOKER FUNC os.Remove from os/file_unix.go:
(defn ^"Error" Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(_name)"}
  [^String _name])

JOKER FUNC os.RemoveAll from os/path.go:
(defn ^"Error" RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\n\nGo input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(_path)"}
  [^String _path])

JOKER FUNC os.Rename from os/file.go:
(defn ^"Error" Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC os.SameFile from os/types.go:
(defn ^"Bool" SameFile
  "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo input arguments: (fi1 FileInfo, fi2 FileInfo)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/FileInfo fi1, ^go.std.os/FileInfo fi2]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "os.SameFile(_fi1.(os.FileInfo), _fi2.(os.FileInfo))"}
  [^GoObject _fi1, ^GoObject _fi2])

JOKER FUNC os.Setenv from os/env.go:
(defn ^"Error" Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC os.StartProcess from os/exec.go:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, argv []string, attr *ProcAttr)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^String name, ^(vector-of String) argv, ^(atom-of go.std.os/ProcAttr) attr]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
;;   {:added "1.0"
;;    :go "startProcess(_name, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_os.ProcAttr(_attr.(os.ProcAttr))))"}
;;   [^String _name, ^Object _argv, ^Object _attr])

JOKER FUNC os.Stat from os/stat.go:
(defn Stat
  "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "stat(_name)"}
  [^String _name])

JOKER FUNC os.Symlink from os/file_unix.go:
(defn ^"Error" Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.TempDir from os/file.go:
(defn ^"String" TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate from os/file_unix.go:
(defn ^"Error" Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, size int64)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int64 size]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(_name, _size)"}
  [^String _name, ^Int64 _size])

JOKER FUNC os.Unsetenv from os/env.go:
(defn ^"Error" Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC os.UserCacheDir from os/file.go:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "userCacheDir()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["os"]
    :doc "Provides a low-level interface to the os package."
    :empty false}
  go.std.os)
JOKER FUNC os/exec.Command from os/exec/exec.go:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nGo input arguments: (name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "command(_name, ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_arg)))"}
;;   [^String _name, ^String _arg])

JOKER FUNC os/exec.CommandContext from os/exec/exec.go:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo input arguments: (ctx context.Context, name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^go.std.context/Context ctx, ^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "commandContext(_ctx.(ABEND987(imports not yet supported: context.Context)), _name, ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_arg)))"}
;;   [^GoObject _ctx, ^String _name, ^String _arg])

JOKER FUNC os/exec.LookPath from os/exec/lp_unix.go:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo input arguments: (file string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String file]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookPath(_file)"}
  [^String _file])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/exec package."
    :empty false}
  go.std.os.exec)
JOKER FUNC os/signal.Ignore from os/signal/signal.go:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow GoObject) sig]"
;;   {:added "1.0"
;;    :go "ignore(ConvertToEllipsisHaHaos.Signal(_sig.(ABEND987(imports not yet supported: os.Signal))))"}
;;   [^GoObject _sig])

JOKER FUNC os/signal.Ignored from os/signal/signal.go:
;; (defn ^"Bool" Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo input arguments: (sig os.Signal)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/Signal sig]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "signal.Ignored(_sig.(ABEND987(imports not yet supported: os.Signal)))"}
;;   [^GoObject _sig])

JOKER FUNC os/signal.Notify from os/signal/signal.go:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n\nGo input arguments: (c <-chan, sig ...os.Signal)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c, ^(ellipsis-somehow GoObject) sig]"
;;   {:added "1.0"
;;    :go "notify(ABEND909(custom-runtime routine not implemented: ConvertToChanTypeHaHa()), ConvertToEllipsisHaHaos.Signal(_sig.(ABEND987(imports not yet supported: os.Signal))))"}
;;   [^<no-idea-about-chan-yet> _c, ^GoObject _sig])

JOKER FUNC os/signal.Reset from os/signal/signal.go:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow GoObject) sig]"
;;   {:added "1.0"
;;    :go "reset(ConvertToEllipsisHaHaos.Signal(_sig.(ABEND987(imports not yet supported: os.Signal))))"}
;;   [^GoObject _sig])

JOKER FUNC os/signal.Stop from os/signal/signal.go:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n\nGo input arguments: (c <-chan)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c]"
;;   {:added "1.0"
;;    :go "stop(ABEND909(custom-runtime routine not implemented: ConvertToChanTypeHaHa()))"}
;;   [^<no-idea-about-chan-yet> _c])

JOKER FUNC os/user.Current from os/user/lookup.go:
(defn Current
  "Current returns the current user.\n\nGo return type: (*User, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "current()"}
  [])

JOKER FUNC os/user.Lookup from os/user/lookup.go:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo input arguments: (username string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String username]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "lookup(_username)"}
  [^String _username])

JOKER FUNC os/user.LookupGroup from os/user/lookup.go:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo input arguments: (name string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "lookupGroup(_name)"}
  [^String _name])

JOKER FUNC os/user.LookupGroupId from os/user/lookup.go:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo input arguments: (gid string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String gid]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "lookupGroupId(_gid)"}
  [^String _gid])

JOKER FUNC os/user.LookupId from os/user/lookup.go:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo input arguments: (uid string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String uid]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "lookupId(_uid)"}
  [^String _uid])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/user package."
    :empty false}
  go.std.os.user)
JOKER FUNC path.Base from path/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(_path)"}
  [^String _path])

JOKER FUNC path.Clean from path/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(_path)"}
  [^String _path])

JOKER FUNC path.Dir from path/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(_path)"}
  [^String _path])

JOKER FUNC path.Ext from path/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(_path)"}
  [^String _path])

JOKER FUNC path.IsAbs from path/path.go:
(defn ^"Bool" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "path.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path.Join from path/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_elem)))"}
;;   [^String _elem])

JOKER FUNC path.Match from path/match.go:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path.Split from path/path.go:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path"]
    :doc "Provides a low-level interface to the path package."
    :empty false}
  go.std.path)
JOKER FUNC path/filepath.Abs from path/filepath/path.go:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "abs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Base from path/filepath/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Clean from path/filepath/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Dir from path/filepath/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(_path)"}
  [^String _path])

JOKER FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "evalSymlinks(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Ext from path/filepath/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(_path)"}
  [^String _path])

JOKER FUNC path/filepath.FromSlash from path/filepath/path.go:
(defn ^"String" FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Glob from path/filepath/match.go:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string)\n\nGo return type: (matches []string, err error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "glob(_pattern)"}
  [^String _pattern])

JOKER FUNC path/filepath.HasPrefix from path/filepath/path_unix.go:
(defn ^"Bool" HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo input arguments: (p string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String p, ^String prefix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.HasPrefix(_p, _prefix)"}
  [^String _p, ^String _prefix])

JOKER FUNC path/filepath.IsAbs from path/filepath/path_unix.go:
(defn ^"Bool" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Join from path/filepath/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_elem)))"}
;;   [^String _elem])

JOKER FUNC path/filepath.Match from path/filepath/match.go:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path/filepath.Rel from path/filepath/path.go:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo input arguments: (basepath string, targpath string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String basepath, ^String targpath]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "rel(_basepath, _targpath)"}
  [^String _basepath, ^String _targpath])

JOKER FUNC path/filepath.Split from path/filepath/path.go:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(_path)"}
  [^String _path])

JOKER FUNC path/filepath.SplitList from path/filepath/path.go:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo input arguments: (path string)\n\nGo return type: []string\n\nJoker input arguments: [^String path]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitList(_path)"}
  [^String _path])

JOKER FUNC path/filepath.ToSlash from path/filepath/path.go:
(defn ^"String" ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.VolumeName from path/filepath/path.go:
(defn ^"String" VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Walk from path/filepath/path.go:
(defn ^"Error" Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo input arguments: (root string, walkFn WalkFunc)\n\nGo return type: error\n\nJoker input arguments: [^String root, ^go.std.path.filepath/WalkFunc walkFn]\n\nJoker return type: Error"
  {:added "1.0"
   :go "filepath.Walk(_root, _walkFn.(filepath.WalkFunc))"}
  [^String _root, ^GoObject _walkFn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path/filepath"]
    :doc "Provides a low-level interface to the path/filepath package."
    :empty false}
  go.std.path.filepath)
JOKER FUNC plugin.Open from plugin/plugin.go:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo input arguments: (path string)\n\nGo return type: (*Plugin, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [(atom-of go.std.plugin/Plugin) Error]"
  {:added "1.0"
   :go "open(_path)"}
  [^String _path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the plugin package."
    :empty false}
  go.std.plugin)
JOKER FUNC reflect.Append from reflect/value.go:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo input arguments: (s Value, x ...Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^(ellipsis-somehow GoObject) x]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "_append(_s.(reflect.Value), ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHa_reflect.Value(_x.(reflect.Value))))"}
;;   [^GoObject _s, ^GoObject _x])

JOKER FUNC reflect.AppendSlice from reflect/value.go:
(defn AppendSlice
  "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo input arguments: (s Value, t Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^go.std.reflect/Value t]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "appendSlice(_s.(reflect.Value), _t.(reflect.Value))"}
  [^GoObject _s, ^GoObject _t])

JOKER FUNC reflect.ArrayOf from reflect/type.go:
(defn ArrayOf
  "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo input arguments: (count int, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^Int count, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "arrayOf(_count, _elem.(reflect.Type))"}
  [^Int _count, ^GoObject _elem])

JOKER FUNC reflect.ChanOf from reflect/type.go:
(defn ChanOf
  "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo input arguments: (dir ChanDir, t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/ChanDir dir, ^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "chanOf(_dir.(reflect.ChanDir), _t.(reflect.Type))"}
  [^GoObject _dir, ^GoObject _t])

JOKER FUNC reflect.Copy from reflect/value.go:
(defn ^"Int" Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo input arguments: (dst Value, src Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.reflect/Value dst, ^go.std.reflect/Value src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "reflect.Copy(_dst.(reflect.Value), _src.(reflect.Value))"}
  [^GoObject _dst, ^GoObject _src])

JOKER FUNC reflect.DeepEqual from reflect/deepequal.go:
;; (defn ^"Bool" DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo input arguments: (x interface {}, y interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> x, ^<protocol-or-something> y]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x, ^<protocol-or-something> _y])

JOKER FUNC reflect.FuncOf from reflect/type.go:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo input arguments: (in []Type, out []Type, variadic bool)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/Type) in, ^(vector-of go.std.reflect/Type) out, ^Bool variadic]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "funcOf(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(_in.(reflect.Type))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(_out.(reflect.Type))), _variadic)"}
;;   [^Object _in, ^Object _out, ^Bool _variadic])

JOKER FUNC reflect.Indirect from reflect/value.go:
(defn Indirect
  "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo input arguments: (v Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value v]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "indirect(_v.(reflect.Value))"}
  [^GoObject _v])

JOKER FUNC reflect.MakeChan from reflect/value.go:
(defn MakeChan
  "MakeChan creates a new channel with the specified type and buffer size.\n\nGo input arguments: (typ Type, buffer int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int buffer]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "makeChan(_typ.(reflect.Type), _buffer)"}
  [^GoObject _typ, ^Int _buffer])

JOKER FUNC reflect.MakeFunc from reflect/makefunc.go:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo input arguments: (typ Type, fn func)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^fn fn]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "makeFunc(_typ.(reflect.Type), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _typ, ^fn _fn])

JOKER FUNC reflect.MakeMap from reflect/value.go:
(defn MakeMap
  "MakeMap creates a new map with the specified type.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "makeMap(_typ.(reflect.Type))"}
  [^GoObject _typ])

JOKER FUNC reflect.MakeMapWithSize from reflect/value.go:
(defn MakeMapWithSize
  "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo input arguments: (typ Type, n int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int n]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "makeMapWithSize(_typ.(reflect.Type), _n)"}
  [^GoObject _typ, ^Int _n])

JOKER FUNC reflect.MakeSlice from reflect/value.go:
(defn MakeSlice
  "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo input arguments: (typ Type, len int, cap int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int len, ^Int cap]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "makeSlice(_typ.(reflect.Type), _len, _cap)"}
  [^GoObject _typ, ^Int _len, ^Int _cap])

JOKER FUNC reflect.MapOf from reflect/type.go:
(defn MapOf
  "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type key, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "mapOf(_key.(reflect.Type), _elem.(reflect.Type))"}
  [^GoObject _key, ^GoObject _elem])

JOKER FUNC reflect.New from reflect/value.go:
(defn New
  "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "_new(_typ.(reflect.Type))"}
  [^GoObject _typ])

JOKER FUNC reflect.NewAt from reflect/value.go:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo input arguments: (typ Type, p unsafe.Pointer)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^go.std.unsafe/Pointer p]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "newAt(_typ.(reflect.Type), _p.(ABEND987(imports not yet supported: unsafe.Pointer)))"}
;;   [^GoObject _typ, ^GoObject _p])

JOKER FUNC reflect.PtrTo from reflect/type.go:
(defn PtrTo
  "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "ptrTo(_t.(reflect.Type))"}
  [^GoObject _t])

JOKER FUNC reflect.Select from reflect/value.go:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo input arguments: (cases []SelectCase)\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker input arguments: [^(vector-of go.std.reflect/SelectCase) cases]\n\nJoker return type: [Int go.std.reflect/Value Bool]"
;;   {:added "1.0"
;;    :go "_select(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_reflect.SelectCase(_cases.(reflect.SelectCase))))"}
;;   [^Object _cases])

JOKER FUNC reflect.SliceOf from reflect/type.go:
(defn SliceOf
  "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "sliceOf(_t.(reflect.Type))"}
  [^GoObject _t])

JOKER FUNC reflect.StructOf from reflect/type.go:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo input arguments: (fields []StructField)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/StructField) fields]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "structOf(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_reflect.StructField(_fields.(reflect.StructField))))"}
;;   [^Object _fields])

JOKER FUNC reflect.Swapper from reflect/swapper.go:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {})\n\nGo return type: ...\n\nJoker input arguments: [^<protocol-or-something> slice]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "swapper(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _slice])

JOKER FUNC reflect.TypeOf from reflect/type.go:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo input arguments: (i interface {})\n\nGo return type: Type\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "typeOf(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.ValueOf from reflect/value.go:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo input arguments: (i interface {})\n\nGo return type: Value\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "valueOf(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.Zero from reflect/value.go:
(defn Zero
  "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "zero(_typ.(reflect.Type))"}
  [^GoObject _typ])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["reflect"]
    :doc "Provides a low-level interface to the reflect package."
    :empty false}
  go.std.reflect)
JOKER FUNC regexp.Compile from regexp/regexp.go:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "compile(_expr)"}
  [^String _expr])

JOKER FUNC regexp.CompilePOSIX from regexp/regexp.go:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "compilePOSIX(_expr)"}
  [^String _expr])

JOKER FUNC regexp.Match from regexp/regexp.go:
;; (defn Match
;;   "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, b []byte)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^(vector-of Byte) b]\n\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "match(_pattern, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^String _pattern, ^Object _b])

JOKER FUNC regexp.MatchReader from regexp/regexp.go:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, r io.RuneReader)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^go.std.io/RuneReader r]\n\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "matchReader(_pattern, _r.(ABEND987(imports not yet supported: io.RuneReader)))"}
;;   [^String _pattern, ^GoObject _r])

JOKER FUNC regexp.MatchString from regexp/regexp.go:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, s string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String s]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "matchString(_pattern, _s)"}
  [^String _pattern, ^String _s])

JOKER FUNC regexp.MustCompile from regexp/regexp.go:
(defn MustCompile
  "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "mustCompile(_str)"}
  [^String _str])

JOKER FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
(defn MustCompilePOSIX
  "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "mustCompilePOSIX(_str)"}
  [^String _str])

JOKER FUNC regexp.QuoteMeta from regexp/regexp.go:
(defn ^"String" QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp"]
    :doc "Provides a low-level interface to the regexp package."
    :empty false}
  go.std.regexp)
JOKER FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
;; (defn Compile
;;   "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo input arguments: (re *Regexp)\n\nGo return type: (*Prog, error)\n\nJoker input arguments: [^(atom-of go.std.regexp.syntax/Regexp) re]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Prog) Error]"
;;   {:added "1.0"
;;    :go "compile(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syntax.Regexp(_re.(syntax.Regexp))))"}
;;   [^Object _re])

JOKER FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
;; (defn EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: EmptyOp\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: go.std.regexp.syntax/EmptyOp"
;;   {:added "1.0"
;;    :go "emptyOpContext(_r1, _r2)"}
;;   [^ABEND044(unsupported built-in type rune) _r1, ^ABEND044(unsupported built-in type rune) _r2])

JOKER FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
;; (defn ^"Bool" IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "syntax.IsWordChar(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
(defn Parse
  "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo input arguments: (s string, flags Flags)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String s, ^go.std.regexp.syntax/Flags flags]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Regexp) Error]"
  {:added "1.0"
   :go "parse(_s, _flags.(syntax.Flags))"}
  [^String _s, ^GoObject _flags])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp/syntax"]
    :doc "Provides a low-level interface to the regexp/syntax package."
    :empty false}
  go.std.regexp.syntax)
JOKER FUNC runtime.BlockProfile from runtime/mprof.go:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "blockProfile(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(_p.(runtime.BlockProfileRecord))))"}
;;   [^Object _p])

JOKER FUNC runtime.Breakpoint from runtime/proc.go:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile from runtime/cpuprof.go:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of )"
  {:added "1.0"
   :go "cPUProfile()"}
  [])

JOKER FUNC runtime.Caller from runtime/extern.go:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo input arguments: (skip int)\n\nGo return type: (pc ..., file string, line int, ok bool)\n\nJoker input arguments: [^Int skip]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) String Int Bool]"
;;   {:added "1.0"
;;    :go "caller(_skip)"}
;;   [^Int _skip])

JOKER FUNC runtime.Callers from runtime/extern.go:
;; (defn ^"Int" Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\n\nGo input arguments: (skip int, pc []uintptr)\n\nGo return type: int\n\nJoker input arguments: [^Int skip, ^(vector-of uintptr) pc]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(_skip, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfuintptr(_pc)))"}
;;   [^Int _skip, ^Object _pc])

JOKER FUNC runtime.CallersFrames from runtime/symtab.go:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo input arguments: (callers []uintptr)\n\nGo return type: *Frames\n\nJoker input arguments: [^(vector-of uintptr) callers]\n\nJoker return type: (atom-of go.std.runtime/Frames)"
;;   {:added "1.0"
;;    :go "callersFrames(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfuintptr(_callers)))"}
;;   [^Object _callers])

JOKER FUNC runtime.FuncForPC from runtime/symtab.go:
;; (defn FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\n\nGo input arguments: (pc uintptr)\n\nGo return type: *Func\n\nJoker input arguments: [^uintptr pc]\n\nJoker return type: (atom-of go.std.runtime/Func)"
;;   {:added "1.0"
;;    :go "funcForPC(_pc)"}
;;   [^ABEND044(unsupported built-in type uintptr) _pc])

JOKER FUNC runtime.GC from runtime/mgc.go:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS from runtime/debug.go:
(defn ^"Int" GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(_n)"}
  [^Int _n])

JOKER FUNC runtime.GOROOT from runtime/extern.go:
(defn ^"String" GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit from runtime/panic.go:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile from runtime/mprof.go:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "goroutineProfile(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(_p.(runtime.StackRecord))))"}
;;   [^Object _p])

JOKER FUNC runtime.Gosched from runtime/proc.go:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive from runtime/mfinal.go:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n\nGo input arguments: (x interface {})\n\nJoker input arguments: [^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "keepAlive(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x])

JOKER FUNC runtime.LockOSThread from runtime/proc.go:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile from runtime/mprof.go:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo input arguments: (p []MemProfileRecord, inuseZero bool)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/MemProfileRecord) p, ^Bool inuseZero]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "memProfile(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_runtime.MemProfileRecord(_p.(runtime.MemProfileRecord))), _inuseZero)"}
;;   [^Object _p, ^Bool _inuseZero])

JOKER FUNC runtime.MutexProfile from runtime/mprof.go:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "mutexProfile(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(_p.(runtime.BlockProfileRecord))))"}
;;   [^Object _p])

JOKER FUNC runtime.NumCPU from runtime/debug.go:
(defn ^"Int" NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall from runtime/debug.go:
(defn NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int64\n\nJoker input arguments: []"
  {:added "1.0"
   :go "numCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine from runtime/debug.go:
(defn ^"Int" NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats from runtime/mstats.go:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n\nGo input arguments: (m *MemStats)\n\nJoker input arguments: [^(atom-of go.std.runtime/MemStats) m]"
;;   {:added "1.0"
;;    :go "readMemStats(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_runtime.MemStats(_m.(runtime.MemStats))))"}
;;   [^Object _m])

JOKER FUNC runtime.ReadTrace from runtime/trace.go:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of )"
  {:added "1.0"
   :go "readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n\nGo input arguments: (rate int)\n\nJoker input arguments: [^Int rate]"
;;   {:added "1.0"
;;    :go "setBlockProfileRate(_rate)"}
;;   [^Int _rate])

JOKER FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n\nGo input arguments: (hz int)\n\nJoker input arguments: [^Int hz]"
;;   {:added "1.0"
;;    :go "setCPUProfileRate(_hz)"}
;;   [^Int _hz])

JOKER FUNC runtime.SetCgoTraceback from runtime/traceback.go:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n\nGo input arguments: (version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)\n\nJoker input arguments: [^Int version, ^go.std.unsafe/Pointer traceback, ^go.std.unsafe/Pointer context, ^go.std.unsafe/Pointer symbolizer]"
;;   {:added "1.0"
;;    :go "setCgoTraceback(_version, _traceback.(ABEND987(imports not yet supported: unsafe.Pointer)), _context.(ABEND987(imports not yet supported: unsafe.Pointer)), _symbolizer.(ABEND987(imports not yet supported: unsafe.Pointer)))"}
;;   [^Int _version, ^GoObject _traceback, ^GoObject _context, ^GoObject _symbolizer])

JOKER FUNC runtime.SetFinalizer from runtime/mfinal.go:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n\nGo input arguments: (obj interface {}, finalizer interface {})\n\nJoker input arguments: [^<protocol-or-something> obj, ^<protocol-or-something> finalizer]"
;;   {:added "1.0"
;;    :go "setFinalizer(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _obj, ^<protocol-or-something> _finalizer])

JOKER FUNC runtime.SetMutexProfileFraction from runtime/mprof.go:
(defn ^"Int" SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo input arguments: (rate int)\n\nGo return type: int\n\nJoker input arguments: [^Int rate]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(_rate)"}
  [^Int _rate])

JOKER FUNC runtime.Stack from runtime/mprof.go:
;; (defn ^"Int" Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo input arguments: (buf []byte, all bool)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Bool all]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Stack(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _all)"}
;;   [^Object _buf, ^Bool _all])

JOKER FUNC runtime.StartTrace from runtime/trace.go:
(defn ^"Error" StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace from runtime/trace.go:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "threadCreateProfile(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(_p.(runtime.StackRecord))))"}
;;   [^Object _p])

JOKER FUNC runtime.UnlockOSThread from runtime/proc.go:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version from runtime/extern.go:
(defn ^"String" Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime"]
    :doc "Provides a low-level interface to the runtime package."
    :empty false}
  go.std.runtime)
JOKER FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])

JOKER FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])

JOKER FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n\nGo input arguments: (stats *GCStats)\n\nJoker input arguments: [^(atom-of go.std.runtime.debug/GCStats) stats]"
;;   {:added "1.0"
;;    :go "readGCStats(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_debug.GCStats(_stats.(debug.GCStats))))"}
;;   [^Object _stats])

JOKER FUNC runtime/debug.SetGCPercent from runtime/debug/garbage.go:
(defn ^"Int" SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo input arguments: (percent int)\n\nGo return type: int\n\nJoker input arguments: [^Int percent]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(_percent)"}
  [^Int _percent])

JOKER FUNC runtime/debug.SetMaxStack from runtime/debug/garbage.go:
(defn ^"Int" SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo input arguments: (bytes int)\n\nGo return type: int\n\nJoker input arguments: [^Int bytes]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(_bytes)"}
  [^Int _bytes])

JOKER FUNC runtime/debug.SetMaxThreads from runtime/debug/garbage.go:
(defn ^"Int" SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo input arguments: (threads int)\n\nGo return type: int\n\nJoker input arguments: [^Int threads]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(_threads)"}
  [^Int _threads])

JOKER FUNC runtime/debug.SetPanicOnFault from runtime/debug/garbage.go:
(defn ^"Bool" SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo input arguments: (enabled bool)\n\nGo return type: bool\n\nJoker input arguments: [^Bool enabled]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "debug.SetPanicOnFault(_enabled)"}
  [^Bool _enabled])

JOKER FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n\nGo input arguments: (level string)\n\nJoker input arguments: [^String level]"
;;   {:added "1.0"
;;    :go "setTraceback(_level)"}
;;   [^String _level])

JOKER FUNC runtime/debug.Stack from runtime/debug/stack.go:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of )"
  {:added "1.0"
   :go "stack()"}
  [])

JOKER FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n\nGo input arguments: (fd uintptr)\n\nJoker input arguments: [^uintptr fd]"
;;   {:added "1.0"
;;    :go "writeHeapDump(_fd)"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/debug"]
    :doc "Provides a low-level interface to the runtime/debug package."
    :empty false}
  go.std.runtime.debug)
JOKER FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n\nGo input arguments: (ctx context.Context, labels LabelSet, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels, ^fn f]"
;;   {:added "1.0"
;;    :go "do(_ctx.(ABEND987(imports not yet supported: context.Context)), _labels.(pprof.LabelSet), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _ctx, ^GoObject _labels, ^fn _f])

JOKER FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n\nGo input arguments: (ctx context.Context, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^fn f]"
;;   {:added "1.0"
;;    :go "forLabels(_ctx.(ABEND987(imports not yet supported: context.Context)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _ctx, ^fn _f])

JOKER FUNC runtime/pprof.Label from runtime/pprof/label.go:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo input arguments: (ctx context.Context, key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String key]\n\nJoker return type: [String Bool]"
;;   {:added "1.0"
;;    :go "label(_ctx.(ABEND987(imports not yet supported: context.Context)), _key)"}
;;   [^GoObject _ctx, ^String _key])

JOKER FUNC runtime/pprof.Labels from runtime/pprof/label.go:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (args ...string)\n\nGo return type: LabelSet\n\nJoker input arguments: [^(ellipsis-somehow String) args]\n\nJoker return type: go.std.runtime.pprof/LabelSet"
;;   {:added "1.0"
;;    :go "labels(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_args)))"}
;;   [^String _args])

JOKER FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
(defn Lookup
  "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "lookup(_name)"}
  [^String _name])

JOKER FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
(defn NewProfile
  "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "newProfile(_name)"}
  [^String _name])

JOKER FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
(defn Profiles
  "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker input arguments: []\n\nJoker return type: (vector-of (atom-of go.std.runtime.pprof/Profile))"
  {:added "1.0"
   :go "profiles()"}
  [])

JOKER FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n\nGo input arguments: (ctx context.Context)\n\nJoker input arguments: [^go.std.context/Context ctx]"
;;   {:added "1.0"
;;    :go "setGoroutineLabels(_ctx.(ABEND987(imports not yet supported: context.Context)))"}
;;   [^GoObject _ctx])

JOKER FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])

JOKER FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (ctx context.Context, labels LabelSet)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "withLabels(_ctx.(ABEND987(imports not yet supported: context.Context)), _labels.(pprof.LabelSet))"}
;;   [^GoObject _ctx, ^GoObject _labels])

JOKER FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the runtime/pprof package."
    :empty false}
  go.std.runtime.pprof)
JOKER FUNC runtime/trace.IsEnabled from runtime/trace/annotation.go:
(defn ^"Bool" IsEnabled
  "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC runtime/trace.Log from runtime/trace/annotation.go:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n\nGo input arguments: (ctx context.Context, category string, message string)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String message]"
;;   {:added "1.0"
;;    :go "log(_ctx.(ABEND987(imports not yet supported: context.Context)), _category, _message)"}
;;   [^GoObject _ctx, ^String _category, ^String _message])

JOKER FUNC runtime/trace.Logf from runtime/trace/annotation.go:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n\nGo input arguments: (ctx context.Context, category string, format string, args ...interface {})\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String format, ^(ellipsis-somehow <protocol-or-something>) args]"
;;   {:added "1.0"
;;    :go "logf(_ctx.(ABEND987(imports not yet supported: context.Context)), _category, _format, ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^GoObject _ctx, ^String _category, ^String _format, ^<protocol-or-something> _args])

JOKER FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo input arguments: (pctx context.Context, taskType string)\n\nGo return type: (ctx context.Context, task *Task)\n\nJoker input arguments: [^go.std.context/Context pctx, ^String taskType]\n\nJoker return type: [go.std.context/Context (atom-of go.std.runtime.trace/Task)]"
;;   {:added "1.0"
;;    :go "newTask(_pctx.(ABEND987(imports not yet supported: context.Context)), _taskType)"}
;;   [^GoObject _pctx, ^String _taskType])

JOKER FUNC runtime/trace.Start from runtime/trace/trace.go:
;; (defn ^"Error" Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(_w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^GoObject _w])

JOKER FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo input arguments: (ctx context.Context, regionType string)\n\nGo return type: *Region\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType]\n\nJoker return type: (atom-of go.std.runtime.trace/Region)"
;;   {:added "1.0"
;;    :go "startRegion(_ctx.(ABEND987(imports not yet supported: context.Context)), _regionType)"}
;;   [^GoObject _ctx, ^String _regionType])

JOKER FUNC runtime/trace.Stop from runtime/trace/trace.go:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])

JOKER FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n\nGo input arguments: (ctx context.Context, regionType string, fn func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType, ^fn fn]"
;;   {:added "1.0"
;;    :go "withRegion(_ctx.(ABEND987(imports not yet supported: context.Context)), _regionType, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _ctx, ^String _regionType, ^fn _fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/trace"]
    :doc "Provides a low-level interface to the runtime/trace package."
    :empty false}
  go.std.runtime.trace)
JOKER FUNC sort.Float64s from sort/sort.go:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nJoker input arguments: [^(vector-of float64) a]"
;;   {:added "1.0"
;;    :go "float64s(ABEND902(custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.Float64sAreSorted from sort/sort.go:
;; (defn ^"Bool" Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of float64) a]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(ABEND902(custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.Ints from sort/sort.go:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n\nGo input arguments: (a []int)\n\nJoker input arguments: [^(vector-of Int) a]"
;;   {:added "1.0"
;;    :go "ints(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfint(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.IntsAreSorted from sort/sort.go:
;; (defn ^"Bool" IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo input arguments: (a []int)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.IntsAreSorted(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfint(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.IsSorted from sort/sort.go:
(defn ^"Bool" IsSorted
  "IsSorted reports whether data is sorted.\n\nGo input arguments: (data Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "sort.IsSorted(_data.(sort.Interface))"}
  [^GoObject _data])

JOKER FUNC sort.Reverse from sort/sort.go:
(defn Reverse
  "Reverse returns the reverse order for data.\n\nGo input arguments: (data Interface)\n\nGo return type: Interface\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: go.std.sort/Interface"
  {:added "1.0"
   :go "reverse(_data.(sort.Interface))"}
  [^GoObject _data])

JOKER FUNC sort.Search from sort/search.go:
;; (defn ^"Int" Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo input arguments: (n int, f func)\n\nGo return type: int\n\nJoker input arguments: [^Int n, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(_n, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _n, ^fn _f])

JOKER FUNC sort.SearchFloat64s from sort/search.go:
;; (defn ^"Int" SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []float64, x float64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of float64) a, ^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(ABEND902(custom-runtime routine not implemented: ConvertToArrayOffloat64(_a)), _x)"}
;;   [^Object _a, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC sort.SearchInts from sort/search.go:
;; (defn ^"Int" SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []int, x int)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^Int x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchInts(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfint(_a)), _x)"}
;;   [^Object _a, ^Int _x])

JOKER FUNC sort.SearchStrings from sort/search.go:
;; (defn ^"Int" SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []string, x string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of String) a, ^String x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchStrings(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_a)), _x)"}
;;   [^Object _a, ^String _x])

JOKER FUNC sort.Slice from sort/slice.go:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "slice(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceIsSorted from sort/slice.go:
;; (defn ^"Bool" SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceStable from sort/slice.go:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "sliceStable(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.Sort from sort/sort.go:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "sort(_data.(sort.Interface))"}
;;   [^GoObject _data])

JOKER FUNC sort.Stable from sort/sort.go:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "stable(_data.(sort.Interface))"}
;;   [^GoObject _data])

JOKER FUNC sort.Strings from sort/sort.go:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n\nGo input arguments: (a []string)\n\nJoker input arguments: [^(vector-of String) a]"
;;   {:added "1.0"
;;    :go "strings(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_a)))"}
;;   [^Object _a])

JOKER FUNC sort.StringsAreSorted from sort/sort.go:
;; (defn ^"Bool" StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo input arguments: (a []string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of String) a]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.StringsAreSorted(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_a)))"}
;;   [^Object _a])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["sort"]
    :doc "Provides a low-level interface to the sort package."
    :empty false}
  go.std.sort)
JOKER FUNC strconv.AppendBool from strconv/atob.go:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, b bool)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^Bool b]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendBool(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _b)"}
;;   [^Object _dst, ^Bool _b])

JOKER FUNC strconv.AppendFloat from strconv/ftoa.go:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, f float64, fmt byte, prec int, bitSize int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendFloat(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _f, _fmt, _prec, _bitSize)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.AppendInt from strconv/itoa.go:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i int64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^Int64 i, ^Int base]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendInt(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _i, _base)"}
;;   [^Object _dst, ^Int64 _i, ^Int _base])

JOKER FUNC strconv.AppendQuote from strconv/quote.go:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuote(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteRune from strconv/quote.go:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuoteRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuoteToASCII(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendQuoteToGraphic(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _s)"}
;;   [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendUint from strconv/itoa.go:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i uint64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Byte) dst, ^uint64 i, ^Int base]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "appendUint(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_dst)), _i, _base)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.Atoi from strconv/atoi.go:
(defn Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\n\nGo input arguments: (s string)\n\nGo return type: (int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "atoi(_s)"}
  [^String _s])

JOKER FUNC strconv.CanBackquote from strconv/quote.go:
(defn ^"Bool" CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strconv.CanBackquote(_s)"}
  [^String _s])

JOKER FUNC strconv.FormatBool from strconv/atob.go:
(defn ^"String" FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo input arguments: (b bool)\n\nGo return type: string\n\nJoker input arguments: [^Bool b]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(_b)"}
  [^Bool _b])

JOKER FUNC strconv.FormatFloat from strconv/ftoa.go:
;; (defn ^"String" FormatFloat
;;   "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddpddd, a binary exponent),\n'e' (-d.ddddedd, a decimal exponent),\n'E' (-d.ddddEdd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo input arguments: (f float64, fmt byte, prec int, bitSize int)\n\nGo return type: string\n\nJoker input arguments: [^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatFloat(_f, _fmt, _prec, _bitSize)"}
;;   [^ABEND044(unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.FormatInt from strconv/itoa.go:
(defn ^"String" FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i int64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Int64 i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(_i, _base)"}
  [^Int64 _i, ^Int _base])

JOKER FUNC strconv.FormatUint from strconv/itoa.go:
;; (defn ^"String" FormatUint
;;   "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i uint64, base int)\n\nGo return type: string\n\nJoker input arguments: [^uint64 i, ^Int base]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatUint(_i, _base)"}
;;   [^ABEND044(unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.IsGraphic from strconv/quote.go:
;; (defn ^"Bool" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.IsPrint from strconv/quote.go:
;; (defn ^"Bool" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsPrint(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.Itoa from strconv/itoa.go:
(defn ^"String" Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(_i)"}
  [^Int _i])

JOKER FUNC strconv.ParseBool from strconv/atob.go:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo input arguments: (str string)\n\nGo return type: (bool, error)\n\nJoker input arguments: [^String str]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "parseBool(_str)"}
  [^String _str])

JOKER FUNC strconv.ParseFloat from strconv/atof.go:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = Inf, err.Err = ErrRange.\n\nGo input arguments: (s string, bitSize int)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String s, ^Int bitSize]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Error]"
;;   {:added "1.0"
;;    :go "parseFloat(_s, _bitSize)"}
;;   [^String _s, ^Int _bitSize])

JOKER FUNC strconv.ParseInt from strconv/atoi.go:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (i int64, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "parseInt(_s, _base, _bitSize)"}
  [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.ParseUint from strconv/atoi.go:
;; (defn ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Error]"
;;   {:added "1.0"
;;    :go "parseUint(_s, _base, _bitSize)"}
;;   [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.Quote from strconv/quote.go:
(defn ^"String" Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteRune from strconv/quote.go:
;; (defn ^"String" QuoteRune
;;   "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
;; (defn ^"String" QuoteRuneToASCII
;;   "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToASCII(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
;; (defn ^"String" QuoteRuneToGraphic
;;   "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteToASCII from strconv/quote.go:
(defn ^"String" QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteToGraphic from strconv/quote.go:
(defn ^"String" QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(_s)"}
  [^String _s])

JOKER FUNC strconv.Unquote from strconv/quote.go:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "unquote(_s)"}
  [^String _s])

JOKER FUNC strconv.UnquoteChar from strconv/quote.go:
;; (defn UnquoteChar
;;   "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo input arguments: (s string, quote byte)\n\nGo return type: (value ..., multibyte bool, tail string, err error)\n\nJoker input arguments: [^String s, ^Byte quote]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Bool String Error]"
;;   {:added "1.0"
;;    :go "unquoteChar(_s, _quote)"}
;;   [^String _s, ^Byte _quote])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strconv"]
    :doc "Provides a low-level interface to the strconv package."
    :empty false}
  go.std.strconv)
JOKER FUNC strings.Compare from strings/compare.go:
(defn ^"Int" Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo input arguments: (a string, b string)\n\nGo return type: int\n\nJoker input arguments: [^String a, ^String b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(_a, _b)"}
  [^String _a, ^String _b])

JOKER FUNC strings.Contains from strings/strings.go:
(defn ^"Bool" Contains
  "Contains reports whether substr is within s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.Contains(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.ContainsAny from strings/strings.go:
(defn ^"Bool" ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.ContainsAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.ContainsRune from strings/strings.go:
;; (defn ^"Bool" ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s.\n\nGo input arguments: (s string, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strings.ContainsRune(_s, _r)"}
;;   [^String _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strings.Count from strings/strings.go:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.EqualFold from strings/strings.go:
(defn ^"Bool" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s string, t string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String t]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.EqualFold(_s, _t)"}
  [^String _s, ^String _t])

JOKER FUNC strings.Fields from strings/strings.go:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s string)\n\nGo return type: []string\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "fields(_s)"}
  [^String _s])

JOKER FUNC strings.FieldsFunc from strings/strings.go:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s string, f func)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "fieldsFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.HasPrefix from strings/strings.go:
(defn ^"Bool" HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.HasSuffix from strings/strings.go:
(defn ^"Bool" HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

JOKER FUNC strings.Index from strings/strings.go:
(defn ^"Int" Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.IndexAny from strings/strings.go:
(defn ^"Int" IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.IndexByte from strings/strings_decl.go:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.IndexFunc from strings/strings.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.IndexRune from strings/strings.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s string, r rune)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexRune(_s, _r)"}
;;   [^String _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strings.Join from strings/strings.go:
;; (defn ^"String" Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo input arguments: (a []string, sep string)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of String) a, ^String sep]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Join(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_a)), _sep)"}
;;   [^Object _a, ^String _sep])

JOKER FUNC strings.LastIndex from strings/strings.go:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.LastIndexAny from strings/strings.go:
(defn ^"Int" LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.LastIndexByte from strings/strings.go:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.LastIndexFunc from strings/strings.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.Map from strings/strings.go:
;; (defn ^"String" Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo input arguments: (mapping func, s string)\n\nGo return type: string\n\nJoker input arguments: [^fn mapping, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), _s)"}
;;   [^fn _mapping, ^String _s])

JOKER FUNC strings.NewReader from strings/reader.go:
(defn NewReader
  "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo input arguments: (s string)\n\nGo return type: *Reader\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.strings/Reader)"
  {:added "1.0"
   :go "newReader(_s)"}
  [^String _s])

JOKER FUNC strings.NewReplacer from strings/replace.go:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo input arguments: (oldnew ...string)\n\nGo return type: *Replacer\n\nJoker input arguments: [^(ellipsis-somehow String) oldnew]\n\nJoker return type: (atom-of go.std.strings/Replacer)"
;;   {:added "1.0"
;;    :go "newReplacer(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_oldnew)))"}
;;   [^String _oldnew])

JOKER FUNC strings.Repeat from strings/strings.go:
(defn ^"String" Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo input arguments: (s string, count int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^Int count]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(_s, _count)"}
  [^String _s, ^Int _count])

JOKER FUNC strings.Replace from strings/strings.go:
(defn ^"String" Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s string, old string, new string, n int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new, ^Int n]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(_s, _old, _new, _n)"}
  [^String _s, ^String _old, ^String _new, ^Int _n])

JOKER FUNC strings.Split from strings/strings.go:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "split(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfter from strings/strings.go:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfter(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfterN from strings/strings.go:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfterN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.SplitN from strings/strings.go:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.Title from strings/strings.go:
(defn ^"String" Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(_s)"}
  [^String _s])

JOKER FUNC strings.ToLower from strings/strings.go:
(defn ^"String" ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(_s)"}
  [^String _s])

JOKER FUNC strings.ToLowerSpecial from strings/strings.go:
;; (defn ^"String" ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), _s)"}
;;   [^GoObject _c, ^String _s])

JOKER FUNC strings.ToTitle from strings/strings.go:
(defn ^"String" ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(_s)"}
  [^String _s])

JOKER FUNC strings.ToTitleSpecial from strings/strings.go:
;; (defn ^"String" ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), _s)"}
;;   [^GoObject _c, ^String _s])

JOKER FUNC strings.ToUpper from strings/strings.go:
(defn ^"String" ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(_s)"}
  [^String _s])

JOKER FUNC strings.ToUpperSpecial from strings/strings.go:
;; (defn ^"String" ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(_c.(ABEND987(imports not yet supported: unicode.SpecialCase)), _s)"}
;;   [^GoObject _c, ^String _s])

JOKER FUNC strings.Trim from strings/strings.go:
(defn ^"String" Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimFunc from strings/strings.go:
;; (defn ^"String" TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimLeft from strings/strings.go:
(defn ^"String" TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimLeftFunc from strings/strings.go:
;; (defn ^"String" TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimPrefix from strings/strings.go:
(defn ^"String" TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.TrimRight from strings/strings.go:
(defn ^"String" TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimRightFunc from strings/strings.go:
;; (defn ^"String" TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimSpace from strings/strings.go:
(defn ^"String" TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(_s)"}
  [^String _s])

JOKER FUNC strings.TrimSuffix from strings/strings.go:
(defn ^"String" TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strings"]
    :doc "Provides a low-level interface to the strings package."
    :empty false}
  go.std.strings)
JOKER FUNC sync.NewCond from sync/cond.go:
(defn NewCond
  "NewCond returns a new Cond with Locker l.\n\nGo input arguments: (l Locker)\n\nGo return type: *Cond\n\nJoker input arguments: [^go.std.sync/Locker l]\n\nJoker return type: (atom-of go.std.sync/Cond)"
  {:added "1.0"
   :go "newCond(_l.(sync.Locker))"}
  [^GoObject _l])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["sync"]
    :doc "Provides a low-level interface to the sync package."
    :empty false}
  go.std.sync)
JOKER FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
;; (defn AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int32, delta int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 delta]"
;;   {:added "1.0"
;;    :go "addInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _delta)"}
;;   [^Object _addr, ^Int32 _delta])

JOKER FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
;; (defn AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int64, delta int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 delta]"
;;   {:added "1.0"
;;    :go "addInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _delta)"}
;;   [^Object _addr, ^Int64 _delta])

JOKER FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
;; (defn AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo input arguments: (addr *uint32, delta uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 delta]"
;;   {:added "1.0"
;;    :go "addUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _delta)"}
;;   [^Object _addr, ^UInt32 _delta])

JOKER FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo input arguments: (addr *uint64, delta uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 delta]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "addUint64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _delta)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _delta])

JOKER FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *uintptr, delta uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr delta]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "addUintptr(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _delta)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _delta])

JOKER FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo input arguments: (addr *int32, old int32, new int32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 old, ^Int32 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int32 _old, ^Int32 _new])

JOKER FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo input arguments: (addr *int64, old int64, new int64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 old, ^Int64 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int64 _old, ^Int64 _new])

JOKER FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo input arguments: (addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer old, ^go.std.unsafe/Pointer new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(ConvertToIndirectOfunsafe.Pointer(_addr.(ABEND987(imports not yet supported: unsafe.Pointer))), _old.(ABEND987(imports not yet supported: unsafe.Pointer)), _new.(ABEND987(imports not yet supported: unsafe.Pointer)))"}
;;   [^Object _addr, ^GoObject _old, ^GoObject _new])

JOKER FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo input arguments: (addr *uint32, old uint32, new uint32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 old, ^UInt32 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _old, _new)"}
;;   [^Object _addr, ^UInt32 _old, ^UInt32 _new])

JOKER FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo input arguments: (addr *uint64, old uint64, new uint64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 old, ^uint64 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _old, _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _old, ^ABEND044(unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
;; (defn ^"Bool" CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo input arguments: (addr *uintptr, old uintptr, new uintptr)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr old, ^uintptr new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _old, _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _old, ^ABEND044(unsupported built-in type uintptr) _new])

JOKER FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
;; (defn LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo input arguments: (addr *int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr]"
;;   {:added "1.0"
;;    :go "loadInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
;; (defn LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo input arguments: (addr *int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr]"
;;   {:added "1.0"
;;    :go "loadInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo input arguments: (addr *unsafe.Pointer)\n\nGo return type: unsafe.Pointer\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr]\n\nJoker return type: go.std.unsafe/Pointer"
;;   {:added "1.0"
;;    :go "loadPointer(ConvertToIndirectOfunsafe.Pointer(_addr.(ABEND987(imports not yet supported: unsafe.Pointer))))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
;; (defn LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo input arguments: (addr *uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr]"
;;   {:added "1.0"
;;    :go "loadUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo input arguments: (addr *uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "loadUint64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo input arguments: (addr *uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "loadUintptr(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n\nGo input arguments: (addr *int32, val int32)\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 val]"
;;   {:added "1.0"
;;    :go "storeInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _val)"}
;;   [^Object _addr, ^Int32 _val])

JOKER FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n\nGo input arguments: (addr *int64, val int64)\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 val]"
;;   {:added "1.0"
;;    :go "storeInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _val)"}
;;   [^Object _addr, ^Int64 _val])

JOKER FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n\nGo input arguments: (addr *unsafe.Pointer, val unsafe.Pointer)\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer val]"
;;   {:added "1.0"
;;    :go "storePointer(ConvertToIndirectOfunsafe.Pointer(_addr.(ABEND987(imports not yet supported: unsafe.Pointer))), _val.(ABEND987(imports not yet supported: unsafe.Pointer)))"}
;;   [^Object _addr, ^GoObject _val])

JOKER FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n\nGo input arguments: (addr *uint32, val uint32)\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 val]"
;;   {:added "1.0"
;;    :go "storeUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _val)"}
;;   [^Object _addr, ^UInt32 _val])

JOKER FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n\nGo input arguments: (addr *uint64, val uint64)\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 val]"
;;   {:added "1.0"
;;    :go "storeUint64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _val)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _val])

JOKER FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n\nGo input arguments: (addr *uintptr, val uintptr)\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr val]"
;;   {:added "1.0"
;;    :go "storeUintptr(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _val)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _val])

JOKER FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
;; (defn SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int32, new int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 new]"
;;   {:added "1.0"
;;    :go "swapInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint32(_addr)), _new)"}
;;   [^Object _addr, ^Int32 _new])

JOKER FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
;; (defn SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int64, new int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 new]"
;;   {:added "1.0"
;;    :go "swapInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_addr)), _new)"}
;;   [^Object _addr, ^Int64 _new])

JOKER FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: unsafe.Pointer\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer new]\n\nJoker return type: go.std.unsafe/Pointer"
;;   {:added "1.0"
;;    :go "swapPointer(ConvertToIndirectOfunsafe.Pointer(_addr.(ABEND987(imports not yet supported: unsafe.Pointer))), _new.(ABEND987(imports not yet supported: unsafe.Pointer)))"}
;;   [^Object _addr, ^GoObject _new])

JOKER FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
;; (defn SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint32, new uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 new]"
;;   {:added "1.0"
;;    :go "swapUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint32(_addr)), _new)"}
;;   [^Object _addr, ^UInt32 _new])

JOKER FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint64, new uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 new]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "swapUint64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuint64(_addr)), _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uintptr, new uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr new]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "swapUintptr(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_addr)), _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _new])

JOKER FUNC syscall.Accept from syscall/syscall_bsd.go:
(defn Accept
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "accept(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Access from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Access
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Adjtime from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Adjtime
;;   "Go input arguments: (delta *Timeval, olddelta *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) delta, ^(atom-of go.std.syscall/Timeval) olddelta]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Adjtime(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_delta.(syscall.Timeval))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_olddelta.(syscall.Timeval))))"}
;;   [^Object _delta, ^Object _olddelta])

JOKER FUNC syscall.Bind from syscall/syscall_unix.go:
(defn ^"Error" Bind
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Bind(_fd, _sa.(syscall.Sockaddr))"}
  [^Int _fd, ^GoObject _sa])

JOKER FUNC syscall.BpfBuflen from syscall/bpf_bsd.go:
(defn BpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfBuflen(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.BpfDatalink from syscall/bpf_bsd.go:
(defn BpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfDatalink(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.BpfHeadercmpl from syscall/bpf_bsd.go:
(defn BpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bpfHeadercmpl(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.BpfInterface from syscall/bpf_bsd.go:
(defn BpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^Int fd, ^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "bpfInterface(_fd, _name)"}
  [^Int _fd, ^String _name])

JOKER FUNC syscall.BpfJump from syscall/bpf_bsd.go:
(defn BpfJump
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int, jt int, jf int)\n\nGo return type: *BpfInsn\n\nJoker input arguments: [^Int code, ^Int k, ^Int jt, ^Int jf]\n\nJoker return type: (atom-of go.std.syscall/BpfInsn)"
  {:added "1.0"
   :go "bpfJump(_code, _k, _jt, _jf)"}
  [^Int _code, ^Int _k, ^Int _jt, ^Int _jf])

JOKER FUNC syscall.BpfStats from syscall/bpf_bsd.go:
(defn BpfStats
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (*BpfStat, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [(atom-of go.std.syscall/BpfStat) Error]"
  {:added "1.0"
   :go "bpfStats(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.BpfStmt from syscall/bpf_bsd.go:
(defn BpfStmt
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int)\n\nGo return type: *BpfInsn\n\nJoker input arguments: [^Int code, ^Int k]\n\nJoker return type: (atom-of go.std.syscall/BpfInsn)"
  {:added "1.0"
   :go "bpfStmt(_code, _k)"}
  [^Int _code, ^Int _k])

JOKER FUNC syscall.BpfTimeout from syscall/bpf_bsd.go:
(defn BpfTimeout
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (*Timeval, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [(atom-of go.std.syscall/Timeval) Error]"
  {:added "1.0"
   :go "bpfTimeout(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.BytePtrFromString from syscall/syscall.go:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: (*byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(atom-of ) Error]"
  {:added "1.0"
   :go "bytePtrFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.ByteSliceFromString from syscall/syscall.go:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "byteSliceFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.Chdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(_path)"}
  [^String _path])

JOKER FUNC syscall.CheckBpfVersion from syscall/bpf_bsd.go:
(defn ^"Error" CheckBpfVersion
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.CheckBpfVersion(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Chflags from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chflags
  "Go input arguments: (path string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chflags(_path, _flags)"}
  [^String _path, ^Int _flags])

JOKER FUNC syscall.Chmod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chmod
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Chown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Chroot from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chroot
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(_path)"}
  [^String _path])

JOKER FUNC syscall.Clearenv from syscall/env_unix.go:
;; (defn Clearenv
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC syscall.Close from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Close
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.CloseOnExec from syscall/exec_unix.go:
;; (defn CloseOnExec
;;   "Go input arguments: (fd int)\n\nJoker input arguments: [^Int fd]"
;;   {:added "1.0"
;;    :go "closeOnExec(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.CmsgLen from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.CmsgSpace from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.Connect from syscall/syscall_unix.go:
(defn ^"Error" Connect
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Connect(_fd, _sa.(syscall.Sockaddr))"}
  [^Int _fd, ^GoObject _sa])

JOKER FUNC syscall.Dup from syscall/zsyscall_darwin_amd64.go:
(defn Dup
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "dup(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Dup2 from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Dup2
  "Go input arguments: (from int, to int)\n\nGo return type: error\n\nJoker input arguments: [^Int from, ^Int to]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(_from, _to)"}
  [^Int _from, ^Int _to])

JOKER FUNC syscall.Environ from syscall/env_unix.go:
(defn Environ
  "Go return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC syscall.Exchangedata from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Exchangedata
  "Go input arguments: (path1 string, path2 string, options int)\n\nGo return type: error\n\nJoker input arguments: [^String path1, ^String path2, ^Int options]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Exchangedata(_path1, _path2, _options)"}
  [^String _path1, ^String _path2, ^Int _options])

JOKER FUNC syscall.Exec from syscall/exec_unix.go:
;; (defn ^"Error" Exec
;;   "Exec invokes the execve(2) system call.\n\nGo input arguments: (argv0 string, argv []string, envv []string)\n\nGo return type: error\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(vector-of String) envv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Exec(_argv0, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_envv)))"}
;;   [^String _argv0, ^Object _argv, ^Object _envv])

JOKER FUNC syscall.Exit from syscall/syscall.go:
;; (defn Exit
;;   "Go input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "exit(_code)"}
;;   [^Int _code])

JOKER FUNC syscall.Fchdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchdir
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Fchflags from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchflags
  "Go input arguments: (fd int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchflags(_fd, _flags)"}
  [^Int _fd, ^Int _flags])

JOKER FUNC syscall.Fchmod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchmod
  "Go input arguments: (fd int, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(_fd, _mode)"}
  [^Int _fd, ^UInt32 _mode])

JOKER FUNC syscall.Fchown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchown
  "Go input arguments: (fd int, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(_fd, _uid, _gid)"}
  [^Int _fd, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.FcntlFlock from syscall/flock.go:
;; (defn ^"Error" FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo input arguments: (fd uintptr, cmd int, lk *Flock_t)\n\nGo return type: error\n\nJoker input arguments: [^uintptr fd, ^Int cmd, ^(atom-of go.std.syscall/Flock_t) lk]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.FcntlFlock(_fd, _cmd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Flock_t(_lk.(syscall.Flock_t))))"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd, ^Int _cmd, ^Object _lk])

JOKER FUNC syscall.Flock from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Flock
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(_fd, _how)"}
  [^Int _fd, ^Int _how])

JOKER FUNC syscall.FlushBpf from syscall/bpf_bsd.go:
(defn ^"Error" FlushBpf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FlushBpf(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.ForkExec from syscall/exec_unix.go:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "forkExec(_argv0, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.ProcAttr(_attr.(syscall.ProcAttr))))"}
;;   [^String _argv0, ^Object _argv, ^Object _attr])

JOKER FUNC syscall.Fpathconf from syscall/zsyscall_darwin_amd64.go:
(defn Fpathconf
  "Go input arguments: (fd int, name int)\n\nGo return type: (val int, err error)\n\nJoker input arguments: [^Int fd, ^Int name]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "fpathconf(_fd, _name)"}
  [^Int _fd, ^Int _name])

JOKER FUNC syscall.Fstat from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Fstat
;;   "Go input arguments: (fd int, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstat(_fd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Stat_t(_stat.(syscall.Stat_t))))"}
;;   [^Int _fd, ^Object _stat])

JOKER FUNC syscall.Fstatfs from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Fstatfs
;;   "Go input arguments: (fd int, stat *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Statfs_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstatfs(_fd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Statfs_t(_stat.(syscall.Statfs_t))))"}
;;   [^Int _fd, ^Object _stat])

JOKER FUNC syscall.Fsync from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fsync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Ftruncate from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Ftruncate
  "Go input arguments: (fd int, length int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(_fd, _length)"}
  [^Int _fd, ^Int64 _length])

JOKER FUNC syscall.Futimes from syscall/syscall_bsd.go:
;; (defn ^"Error" Futimes
;;   "Go input arguments: (fd int, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(_tv.(syscall.Timeval))))"}
;;   [^Int _fd, ^Object _tv])

JOKER FUNC syscall.Getdirentries from syscall/zsyscall_darwin_amd64.go:
;; (defn Getdirentries
;;   "Go input arguments: (fd int, buf []byte, basep *uintptr)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf, ^(atom-of uintptr) basep]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "getdirentries(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfuintptr(_basep)))"}
;;   [^Int _fd, ^Object _buf, ^Object _basep])

JOKER FUNC syscall.Getdtablesize from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getdtablesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getdtablesize()"}
  [])

JOKER FUNC syscall.Getegid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getegid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv from syscall/env_unix.go:
(defn Getenv
  "Go input arguments: (key string)\n\nGo return type: (value string, found bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "getenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Geteuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Geteuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getfsstat from syscall/syscall_darwin.go:
;; (defn Getfsstat
;;   "Go input arguments: (buf []Statfs_t, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of go.std.syscall/Statfs_t) buf, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "getfsstat(ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Statfs_t(_buf.(syscall.Statfs_t))), _flags)"}
;;   [^Object _buf, ^Int _flags])

JOKER FUNC syscall.Getgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getgid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups from syscall/syscall_bsd.go:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize from syscall/syscall.go:
(defn ^"Int" Getpagesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername from syscall/syscall_unix.go:
(defn Getpeername
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "getpeername(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Getpgid from syscall/zsyscall_darwin_amd64.go:
(defn Getpgid
  "Go input arguments: (pid int)\n\nGo return type: (pgid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpgid(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.Getpgrp from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getpgrp
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getpid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getppid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority from syscall/zsyscall_darwin_amd64.go:
(defn Getpriority
  "Go input arguments: (which int, who int)\n\nGo return type: (prio int, err error)\n\nJoker input arguments: [^Int which, ^Int who]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpriority(_which, _who)"}
  [^Int _which, ^Int _who])

JOKER FUNC syscall.Getrlimit from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Getrlimit
;;   "Go input arguments: (which int, lim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^(atom-of go.std.syscall/Rlimit) lim]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrlimit(_which, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Rlimit(_lim.(syscall.Rlimit))))"}
;;   [^Int _which, ^Object _lim])

JOKER FUNC syscall.Getrusage from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Getrusage
;;   "Go input arguments: (who int, rusage *Rusage)\n\nGo return type: error\n\nJoker input arguments: [^Int who, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrusage(_who, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Rusage(_rusage.(syscall.Rusage))))"}
;;   [^Int _who, ^Object _rusage])

JOKER FUNC syscall.Getsid from syscall/zsyscall_darwin_amd64.go:
(defn Getsid
  "Go input arguments: (pid int)\n\nGo return type: (sid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsid(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.Getsockname from syscall/syscall_bsd.go:
(defn Getsockname
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "getsockname(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.GetsockoptByte from syscall/syscall_bsd.go:
(defn GetsockoptByte
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "getsockoptByte(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_bsd.go:
(defn GetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*ICMPv6Filter, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/ICMPv6Filter) Error]"
  {:added "1.0"
   :go "getsockoptICMPv6Filter(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPMreq from syscall/syscall_bsd.go:
(defn GetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreq) Error]"
  {:added "1.0"
   :go "getsockoptIPMreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_bsd.go:
(defn GetsockoptIPv6MTUInfo
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6MTUInfo, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6MTUInfo) Error]"
  {:added "1.0"
   :go "getsockoptIPv6MTUInfo(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_bsd.go:
(defn GetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6Mreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6Mreq) Error]"
  {:added "1.0"
   :go "getsockoptIPv6Mreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInet4Addr from syscall/syscall_bsd.go:
(defn GetsockoptInet4Addr
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "getsockoptInet4Addr(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
(defn GetsockoptInt
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsockoptInt(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.Gettimeofday from syscall/syscall_darwin_amd64.go:
;; (defn ^"Error" Gettimeofday
;;   "sysnb\tgettimeofday(tp *Timeval) (sec int64, usec int32, err error)\n\nGo input arguments: (tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Gettimeofday(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_tv.(syscall.Timeval))))"}
;;   [^Object _tv])

JOKER FUNC syscall.Getuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd from syscall/syscall_darwin.go:
(defn Getwd
  "Go return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC syscall.Issetugid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Bool" Issetugid
  "Go return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "syscall.Issetugid()"}
  [])

JOKER FUNC syscall.Kevent from syscall/syscall_bsd.go:
;; (defn Kevent
;;   "Go input arguments: (kq int, changes []Kevent_t, events []Kevent_t, timeout *Timespec)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int kq, ^(vector-of go.std.syscall/Kevent_t) changes, ^(vector-of go.std.syscall/Kevent_t) events, ^(atom-of go.std.syscall/Timespec) timeout]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "kevent(_kq, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Kevent_t(_changes.(syscall.Kevent_t))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Kevent_t(_events.(syscall.Kevent_t))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timespec(_timeout.(syscall.Timespec))))"}
;;   [^Int _kq, ^Object _changes, ^Object _events, ^Object _timeout])

JOKER FUNC syscall.Kill from syscall/syscall_darwin.go:
(defn ^"Error" Kill
  "Go input arguments: (pid int, signum Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^go.std.syscall/Signal signum]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Kill(_pid, _signum.(syscall.Signal))"}
  [^Int _pid, ^GoObject _signum])

JOKER FUNC syscall.Kqueue from syscall/zsyscall_darwin_amd64.go:
(defn Kqueue
  "Go return type: (fd int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "kqueue()"}
  [])

JOKER FUNC syscall.Lchown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Lchown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Link from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Link
  "Go input arguments: (path string, link string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String link]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(_path, _link)"}
  [^String _path, ^String _link])

JOKER FUNC syscall.Listen from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Listen
  "Go input arguments: (s int, backlog int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int backlog]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(_s, _backlog)"}
  [^Int _s, ^Int _backlog])

JOKER FUNC syscall.Lstat from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Lstat
;;   "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Lstat(_path, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Stat_t(_stat.(syscall.Stat_t))))"}
;;   [^String _path, ^Object _stat])

JOKER FUNC syscall.Mkdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mkdir
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mkfifo from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mkfifo
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mknod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mknod
  "Go input arguments: (path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(_path, _mode, _dev)"}
  [^String _path, ^UInt32 _mode, ^Int _dev])

JOKER FUNC syscall.Mlock from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Mlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mlock(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.Mlockall from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mlockall
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.Mmap from syscall/syscall_bsd.go:
(defn Mmap
  "Go input arguments: (fd int, offset int64, length int, prot int, flags int)\n\nGo return type: (data []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int length, ^Int prot, ^Int flags]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "mmap(_fd, _offset, _length, _prot, _flags)"}
  [^Int _fd, ^Int64 _offset, ^Int _length, ^Int _prot, ^Int _flags])

JOKER FUNC syscall.Mprotect from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Mprotect
;;   "Go input arguments: (b []byte, prot int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b, ^Int prot]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mprotect(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)), _prot)"}
;;   [^Object _b, ^Int _prot])

JOKER FUNC syscall.Munlock from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Munlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munlock(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.Munlockall from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Munlockall
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap from syscall/syscall_bsd.go:
;; (defn ^"Error" Munmap
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munmap(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.NsecToTimespec from syscall/timestruct.go:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timespec\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: go.std.syscall/Timespec"
  {:added "1.0"
   :go "nsecToTimespec(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.NsecToTimeval from syscall/timestruct.go:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timeval\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: go.std.syscall/Timeval"
  {:added "1.0"
   :go "nsecToTimeval(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.Open from syscall/zsyscall_darwin_amd64.go:
(defn Open
  "Go input arguments: (path string, mode int, perm uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Int mode, ^UInt32 perm]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "open(_path, _mode, _perm)"}
  [^String _path, ^Int _mode, ^UInt32 _perm])

JOKER FUNC syscall.ParseDirent from syscall/dirent.go:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo input arguments: (buf []byte, max int, names []string)\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int max, ^(vector-of String) names]\n\nJoker return type: [Int Int (vector-of String)]"
;;   {:added "1.0"
;;    :go "parseDirent(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)), _max, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_names)))"}
;;   [^Object _buf, ^Int _max, ^Object _names])

JOKER FUNC syscall.ParseRoutingMessage from syscall/route_bsd.go:
;; (defn ParseRoutingMessage
;;   "ParseRoutingMessage parses b as routing messages and returns the\nslice containing the RoutingMessage interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (b []byte)\n\nGo return type: (msgs []RoutingMessage, err error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of go.std.syscall/RoutingMessage) Error]"
;;   {:added "1.0"
;;    :go "parseRoutingMessage(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.ParseRoutingSockaddr from syscall/route_bsd.go:
(defn ParseRoutingSockaddr
  "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and\nreturns the slice containing the Sockaddr interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (msg RoutingMessage)\n\nGo return type: ([]Sockaddr, error)\n\nJoker input arguments: [^go.std.syscall/RoutingMessage msg]\n\nJoker return type: [(vector-of go.std.syscall/Sockaddr) Error]"
  {:added "1.0"
   :go "parseRoutingSockaddr(_msg.(syscall.RoutingMessage))"}
  [^GoObject _msg])

JOKER FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of go.std.syscall/SocketControlMessage) Error]"
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^Object _b])

JOKER FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
;; (defn ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "parseUnixRights(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.SocketControlMessage(_m.(syscall.SocketControlMessage))))"}
;;   [^Object _m])

JOKER FUNC syscall.Pathconf from syscall/zsyscall_darwin_amd64.go:
(defn Pathconf
  "Go input arguments: (path string, name int)\n\nGo return type: (val int, err error)\n\nJoker input arguments: [^String path, ^Int name]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "pathconf(_path, _name)"}
  [^String _path, ^Int _name])

JOKER FUNC syscall.Pipe from syscall/syscall_darwin.go:
;; (defn ^"Error" Pipe
;;   "Go input arguments: (p []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfint(_p)))"}
;;   [^Object _p])

JOKER FUNC syscall.Pread from syscall/zsyscall_darwin_amd64.go:
;; (defn Pread
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "pread(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _offset)"}
;;   [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.PtraceAttach from syscall/syscall_darwin.go:
(defn ^"Error" PtraceAttach
  "sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n\nGo input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceDetach from syscall/syscall_darwin.go:
(defn ^"Error" PtraceDetach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.Pwrite from syscall/zsyscall_darwin_amd64.go:
;; (defn Pwrite
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "pwrite(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _offset)"}
;;   [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.RawSyscall from syscall/syscall_unix.go:
;; (defn RawSyscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "rawSyscall(_trap, _a1, _a2, _a3)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3])

JOKER FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
;; (defn RawSyscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3, ^uintptr a4, ^uintptr a5, ^uintptr a6]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "rawSyscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3, ^ABEND044(unsupported built-in type uintptr) _a4, ^ABEND044(unsupported built-in type uintptr) _a5, ^ABEND044(unsupported built-in type uintptr) _a6])

JOKER FUNC syscall.Read from syscall/syscall_unix.go:
;; (defn Read
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "read(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Int _fd, ^Object _p])

JOKER FUNC syscall.ReadDirent from syscall/syscall_bsd.go:
;; (defn ReadDirent
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readDirent(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Readlink from syscall/zsyscall_darwin_amd64.go:
;; (defn Readlink
;;   "Go input arguments: (path string, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readlink(_path, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_buf)))"}
;;   [^String _path, ^Object _buf])

JOKER FUNC syscall.Recvfrom from syscall/syscall_unix.go:
;; (defn Recvfrom
;;   "Go input arguments: (fd int, p []byte, flags int)\n\nGo return type: (n int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "recvfrom(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Int _flags])

JOKER FUNC syscall.Recvmsg from syscall/syscall_bsd.go:
;; (defn Recvmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, flags int)\n\nGo return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^Int flags]\n\nJoker return type: [Int Int Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "recvmsg(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^Int _flags])

JOKER FUNC syscall.Rename from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Rename
  "Go input arguments: (from string, to string)\n\nGo return type: error\n\nJoker input arguments: [^String from, ^String to]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(_from, _to)"}
  [^String _from, ^String _to])

JOKER FUNC syscall.Revoke from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Revoke
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Revoke(_path)"}
  [^String _path])

JOKER FUNC syscall.Rmdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Rmdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(_path)"}
  [^String _path])

JOKER FUNC syscall.RouteRIB from syscall/route_bsd.go:
(defn RouteRIB
  "RouteRIB returns routing information base, as known as RIB,\nwhich consists of network facility information, states and\nparameters.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (facility int, param int)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^Int facility, ^Int param]\n\nJoker return type: [(vector-of ) Error]"
  {:added "1.0"
   :go "routeRIB(_facility, _param)"}
  [^Int _facility, ^Int _param])

JOKER FUNC syscall.Seek from syscall/zsyscall_darwin_amd64.go:
(defn Seek
  "Go input arguments: (fd int, offset int64, whence int)\n\nGo return type: (newoffset int64, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int whence]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "seek(_fd, _offset, _whence)"}
  [^Int _fd, ^Int64 _offset, ^Int _whence])

JOKER FUNC syscall.Select from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Select
;;   "Go input arguments: (n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int n, ^(atom-of go.std.syscall/FdSet) r, ^(atom-of go.std.syscall/FdSet) w, ^(atom-of go.std.syscall/FdSet) e, ^(atom-of go.std.syscall/Timeval) timeout]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Select(_n, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.FdSet(_r.(syscall.FdSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.FdSet(_w.(syscall.FdSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.FdSet(_e.(syscall.FdSet))), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_timeout.(syscall.Timeval))))"}
;;   [^Int _n, ^Object _r, ^Object _w, ^Object _e, ^Object _timeout])

JOKER FUNC syscall.Sendfile from syscall/syscall_unix.go:
;; (defn Sendfile
;;   "Go input arguments: (outfd int, infd int, offset *int64, count int)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^Int outfd, ^Int infd, ^(atom-of Int64) offset, ^Int count]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendfile(_outfd, _infd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfint64(_offset)), _count)"}
;;   [^Int _outfd, ^Int _infd, ^Object _offset, ^Int _count])

JOKER FUNC syscall.Sendmsg from syscall/syscall_bsd.go:
;; (defn ^"Error" Sendmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), _to.(syscall.Sockaddr), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^GoObject _to, ^Int _flags])

JOKER FUNC syscall.SendmsgN from syscall/syscall_bsd.go:
;; (defn SendmsgN
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendmsgN(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_oob)), _to.(syscall.Sockaddr), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^GoObject _to, ^Int _flags])

JOKER FUNC syscall.Sendto from syscall/syscall_unix.go:
;; (defn ^"Error" Sendto
;;   "Go input arguments: (fd int, p []byte, flags int, to Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags, ^go.std.syscall/Sockaddr to]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _flags, _to.(syscall.Sockaddr))"}
;;   [^Int _fd, ^Object _p, ^Int _flags, ^GoObject _to])

JOKER FUNC syscall.SetBpf from syscall/bpf_bsd.go:
;; (defn ^"Error" SetBpf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, i []BpfInsn)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/BpfInsn) i]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetBpf(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.BpfInsn(_i.(syscall.BpfInsn))))"}
;;   [^Int _fd, ^Object _i])

JOKER FUNC syscall.SetBpfBuflen from syscall/bpf_bsd.go:
(defn SetBpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, l int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd, ^Int l]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setBpfBuflen(_fd, _l)"}
  [^Int _fd, ^Int _l])

JOKER FUNC syscall.SetBpfDatalink from syscall/bpf_bsd.go:
(defn SetBpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, t int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd, ^Int t]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setBpfDatalink(_fd, _t)"}
  [^Int _fd, ^Int _t])

JOKER FUNC syscall.SetBpfHeadercmpl from syscall/bpf_bsd.go:
(defn ^"Error" SetBpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, f int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int f]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfHeadercmpl(_fd, _f)"}
  [^Int _fd, ^Int _f])

JOKER FUNC syscall.SetBpfImmediate from syscall/bpf_bsd.go:
(defn ^"Error" SetBpfImmediate
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, m int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfImmediate(_fd, _m)"}
  [^Int _fd, ^Int _m])

JOKER FUNC syscall.SetBpfInterface from syscall/bpf_bsd.go:
(defn ^"Error" SetBpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, name string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfInterface(_fd, _name)"}
  [^Int _fd, ^String _name])

JOKER FUNC syscall.SetBpfPromisc from syscall/bpf_bsd.go:
(defn ^"Error" SetBpfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, m int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfPromisc(_fd, _m)"}
  [^Int _fd, ^Int _m])

JOKER FUNC syscall.SetBpfTimeout from syscall/bpf_bsd.go:
;; (defn ^"Error" SetBpfTimeout
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetBpfTimeout(_fd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_tv.(syscall.Timeval))))"}
;;   [^Int _fd, ^Object _tv])

JOKER FUNC syscall.SetKevent from syscall/syscall_darwin_amd64.go:
;; (defn SetKevent
;;   "Go input arguments: (k *Kevent_t, fd int, mode int, flags int)\n\nJoker input arguments: [^(atom-of go.std.syscall/Kevent_t) k, ^Int fd, ^Int mode, ^Int flags]"
;;   {:added "1.0"
;;    :go "setKevent(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Kevent_t(_k.(syscall.Kevent_t))), _fd, _mode, _flags)"}
;;   [^Object _k, ^Int _fd, ^Int _mode, ^Int _flags])

JOKER FUNC syscall.SetNonblock from syscall/exec_unix.go:
(defn ^"Error" SetNonblock
  "Go input arguments: (fd int, nonblocking bool)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Bool nonblocking]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(_fd, _nonblocking)"}
  [^Int _fd, ^Bool _nonblocking])

JOKER FUNC syscall.Setegid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setegid
  "Go input arguments: (egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setegid(_egid)"}
  [^Int _egid])

JOKER FUNC syscall.Setenv from syscall/env_unix.go:
(defn ^"Error" Setenv
  "Go input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC syscall.Seteuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Seteuid
  "Go input arguments: (euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Seteuid(_euid)"}
  [^Int _euid])

JOKER FUNC syscall.Setgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(_gid)"}
  [^Int _gid])

JOKER FUNC syscall.Setgroups from syscall/syscall_bsd.go:
;; (defn ^"Error" Setgroups
;;   "Go input arguments: (gids []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) gids]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setgroups(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfint(_gids)))"}
;;   [^Object _gids])

JOKER FUNC syscall.Setlogin from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setlogin
  "Go input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setlogin(_name)"}
  [^String _name])

JOKER FUNC syscall.Setpgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setpgid
  "Go input arguments: (pid int, pgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int pgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(_pid, _pgid)"}
  [^Int _pid, ^Int _pgid])

JOKER FUNC syscall.Setpriority from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setpriority
  "Go input arguments: (which int, who int, prio int)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^Int who, ^Int prio]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(_which, _who, _prio)"}
  [^Int _which, ^Int _who, ^Int _prio])

JOKER FUNC syscall.Setprivexec from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setprivexec
  "Go input arguments: (flag int)\n\nGo return type: error\n\nJoker input arguments: [^Int flag]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setprivexec(_flag)"}
  [^Int _flag])

JOKER FUNC syscall.Setregid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setregid
  "Go input arguments: (rgid int, egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(_rgid, _egid)"}
  [^Int _rgid, ^Int _egid])

JOKER FUNC syscall.Setreuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setreuid
  "Go input arguments: (ruid int, euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(_ruid, _euid)"}
  [^Int _ruid, ^Int _euid])

JOKER FUNC syscall.Setrlimit from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Setrlimit
;;   "Go input arguments: (which int, lim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^(atom-of go.std.syscall/Rlimit) lim]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setrlimit(_which, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Rlimit(_lim.(syscall.Rlimit))))"}
;;   [^Int _which, ^Object _lim])

JOKER FUNC syscall.Setsid from syscall/zsyscall_darwin_amd64.go:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptByte
  "Go input arguments: (fd int, level int, opt int, value byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Byte value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Byte _value])

JOKER FUNC syscall.SetsockoptICMPv6Filter from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptICMPv6Filter
;;   "Go input arguments: (fd int, level int, opt int, filter *ICMPv6Filter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/ICMPv6Filter) filter]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptICMPv6Filter(_fd, _level, _opt, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.ICMPv6Filter(_filter.(syscall.ICMPv6Filter))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _filter])

JOKER FUNC syscall.SetsockoptIPMreq from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptIPMreq
;;   "Go input arguments: (fd int, level int, opt int, mreq *IPMreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreq) mreq]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPMreq(_fd, _level, _opt, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.IPMreq(_mreq.(syscall.IPMreq))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptIPv6Mreq
;;   "Go input arguments: (fd int, level int, opt int, mreq *IPv6Mreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPv6Mreq) mreq]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPv6Mreq(_fd, _level, _opt, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.IPv6Mreq(_mreq.(syscall.IPv6Mreq))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _mreq])

JOKER FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptInet4Addr
;;   "Go input arguments: (fd int, level int, opt int, value []byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(vector-of Byte) value]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(_fd, _level, _opt, ABEND901(specific-length arrays not supported: ConvertToArrayOfbyte(_value)))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _value])

JOKER FUNC syscall.SetsockoptInt from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptInt
  "Go input arguments: (fd int, level int, opt int, value int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Int _value])

JOKER FUNC syscall.SetsockoptLinger from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptLinger
;;   "Go input arguments: (fd int, level int, opt int, l *Linger)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Linger) l]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptLinger(_fd, _level, _opt, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Linger(_l.(syscall.Linger))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _l])

JOKER FUNC syscall.SetsockoptString from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptString
  "Go input arguments: (fd int, level int, opt int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(_fd, _level, _opt, _s)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^String _s])

JOKER FUNC syscall.SetsockoptTimeval from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptTimeval
;;   "Go input arguments: (fd int, level int, opt int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptTimeval(_fd, _level, _opt, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_tv.(syscall.Timeval))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _tv])

JOKER FUNC syscall.Settimeofday from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Settimeofday
;;   "Go input arguments: (tp *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tp]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Settimeofday(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Timeval(_tp.(syscall.Timeval))))"}
;;   [^Object _tp])

JOKER FUNC syscall.Setuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(_uid)"}
  [^Int _uid])

JOKER FUNC syscall.Shutdown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Shutdown
  "Go input arguments: (s int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(_s, _how)"}
  [^Int _s, ^Int _how])

JOKER FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo input arguments: (ss []string)\n\nGo return type: ([]*byte, error)\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: [(vector-of (atom-of )) Error]"
;;   {:added "1.0"
;;    :go "slicePtrFromStrings(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_ss)))"}
;;   [^Object _ss])

JOKER FUNC syscall.Socket from syscall/syscall_unix.go:
(defn Socket
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "socket(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.Socketpair from syscall/syscall_unix.go:
(defn Socketpair
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd []int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "socketpair(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.StartProcess from syscall/exec_unix.go:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, handle ..., err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int ABEND043(unsupported built-in type uintptr) Error]"
;;   {:added "1.0"
;;    :go "startProcess(_argv0, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_argv)), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.ProcAttr(_attr.(syscall.ProcAttr))))"}
;;   [^String _argv0, ^Object _argv, ^Object _attr])

JOKER FUNC syscall.Stat from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Stat
;;   "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Stat(_path, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Stat_t(_stat.(syscall.Stat_t))))"}
;;   [^String _path, ^Object _stat])

JOKER FUNC syscall.Statfs from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Statfs
;;   "Go input arguments: (path string, stat *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Statfs_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Statfs(_path, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Statfs_t(_stat.(syscall.Statfs_t))))"}
;;   [^String _path, ^Object _stat])

JOKER FUNC syscall.StringBytePtr from syscall/syscall.go:
(defn StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: *byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of )"
  {:added "1.0"
   :go "stringBytePtr(_s)"}
  [^String _s])

JOKER FUNC syscall.StringByteSlice from syscall/syscall.go:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: []byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of )"
  {:added "1.0"
   :go "stringByteSlice(_s)"}
  [^String _s])

JOKER FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo input arguments: (ss []string)\n\nGo return type: []*byte\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: (vector-of (atom-of ))"
;;   {:added "1.0"
;;    :go "stringSlicePtr(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfstring(_ss)))"}
;;   [^Object _ss])

JOKER FUNC syscall.Symlink from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Symlink
  "Go input arguments: (path string, link string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String link]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(_path, _link)"}
  [^String _path, ^String _link])

JOKER FUNC syscall.Sync from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Sync
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sync()"}
  [])

JOKER FUNC syscall.Syscall from syscall/syscall_unix.go:
;; (defn Syscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "syscall(_trap, _a1, _a2, _a3)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3])

JOKER FUNC syscall.Syscall6 from syscall/syscall_unix.go:
;; (defn Syscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3, ^uintptr a4, ^uintptr a5, ^uintptr a6]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "syscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3, ^ABEND044(unsupported built-in type uintptr) _a4, ^ABEND044(unsupported built-in type uintptr) _a5, ^ABEND044(unsupported built-in type uintptr) _a6])

JOKER FUNC syscall.Syscall9 from syscall/syscall_darwin_amd64.go:
;; (defn Syscall9
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3, ^uintptr a4, ^uintptr a5, ^uintptr a6, ^uintptr a7, ^uintptr a8, ^uintptr a9]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "syscall9(_trap, _a1, _a2, _a3, _a4, _a5, _a6, _a7, _a8, _a9)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3, ^ABEND044(unsupported built-in type uintptr) _a4, ^ABEND044(unsupported built-in type uintptr) _a5, ^ABEND044(unsupported built-in type uintptr) _a6, ^ABEND044(unsupported built-in type uintptr) _a7, ^ABEND044(unsupported built-in type uintptr) _a8, ^ABEND044(unsupported built-in type uintptr) _a9])

JOKER FUNC syscall.Sysctl from syscall/syscall_bsd.go:
(defn Sysctl
  "Go input arguments: (name string)\n\nGo return type: (value string, err error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "sysctl(_name)"}
  [^String _name])

JOKER FUNC syscall.SysctlUint32 from syscall/syscall_bsd.go:
(defn SysctlUint32
  "Go input arguments: (name string)\n\nGo return type: (value uint32, err error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [ Error]"
  {:added "1.0"
   :go "sysctlUint32(_name)"}
  [^String _name])

JOKER FUNC syscall.TimespecToNsec from syscall/timestruct.go:
(defn TimespecToNsec
  "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo input arguments: (ts Timespec)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timespec ts]"
  {:added "1.0"
   :go "timespecToNsec(_ts.(syscall.Timespec))"}
  [^GoObject _ts])

JOKER FUNC syscall.TimevalToNsec from syscall/timestruct.go:
(defn TimevalToNsec
  "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo input arguments: (tv Timeval)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timeval tv]"
  {:added "1.0"
   :go "timevalToNsec(_tv.(syscall.Timeval))"}
  [^GoObject _tv])

JOKER FUNC syscall.Truncate from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Truncate
  "Go input arguments: (path string, length int64)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(_path, _length)"}
  [^String _path, ^Int64 _length])

JOKER FUNC syscall.Umask from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Umask
  "Go input arguments: (newmask int)\n\nGo return type: int\n\nJoker input arguments: [^Int newmask]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(_newmask)"}
  [^Int _newmask])

JOKER FUNC syscall.Undelete from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Undelete
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Undelete(_path)"}
  [^String _path])

JOKER FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo input arguments: (fds ...int)\n\nGo return type: []byte\n\nJoker input arguments: [^(ellipsis-somehow Int) fds]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "unixRights(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaint(_fds)))"}
;;   [^Int _fds])

JOKER FUNC syscall.Unlink from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Unlink
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(_path)"}
  [^String _path])

JOKER FUNC syscall.Unmount from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Unmount
  "Go input arguments: (path string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(_path, _flags)"}
  [^String _path, ^Int _flags])

JOKER FUNC syscall.Unsetenv from syscall/env_unix.go:
(defn ^"Error" Unsetenv
  "Go input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Utimes from syscall/syscall_bsd.go:
;; (defn ^"Error" Utimes
;;   "Go input arguments: (path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(_path, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(_tv.(syscall.Timeval))))"}
;;   [^String _path, ^Object _tv])

JOKER FUNC syscall.UtimesNano from syscall/syscall_bsd.go:
;; (defn ^"Error" UtimesNano
;;   "Go input arguments: (path string, ts []Timespec)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timespec) ts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(_path, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timespec(_ts.(syscall.Timespec))))"}
;;   [^String _path, ^Object _ts])

JOKER FUNC syscall.Wait4 from syscall/syscall_bsd.go:
;; (defn Wait4
;;   "Go input arguments: (pid int, wstatus *WaitStatus, options int, rusage *Rusage)\n\nGo return type: (wpid int, err error)\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/WaitStatus) wstatus, ^Int options, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "wait4(_pid, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.WaitStatus(_wstatus.(syscall.WaitStatus))), _options, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_syscall.Rusage(_rusage.(syscall.Rusage))))"}
;;   [^Int _pid, ^Object _wstatus, ^Int _options, ^Object _rusage])

JOKER FUNC syscall.Write from syscall/syscall_unix.go:
;; (defn Write
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "write(_fd, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Int _fd, ^Object _p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["syscall"]
    :doc "Provides a low-level interface to the syscall package."
    :empty false}
  go.std.syscall)
JOKER FUNC testing.AllocsPerRun from testing/allocs.go:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo input arguments: (runs int, f func)\n\nGo return type: ...\n\nJoker input arguments: [^Int runs, ^fn f]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "allocsPerRun(_runs, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int _runs, ^fn _f])

JOKER FUNC testing.Benchmark from testing/benchmark.go:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo input arguments: (f func)\n\nGo return type: BenchmarkResult\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.testing/BenchmarkResult"
;;   {:added "1.0"
;;    :go "benchmark(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn _f])

JOKER FUNC testing.CoverMode from testing/testing.go:
(defn ^"String" CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage from testing/cover.go:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])

JOKER FUNC testing.Main from testing/testing.go:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n\nGo input arguments: (matchString func, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]"
;;   {:added "1.0"
;;    :go "main(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(_tests.(testing.InternalTest))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(_benchmarks.(testing.InternalBenchmark))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(_examples.(testing.InternalExample))))"}
;;   [^fn _matchString, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.MainStart from testing/testing.go:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo input arguments: (deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nGo return type: *M\n\nJoker input arguments: [^testDeps deps, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: (atom-of go.std.testing/M)"
;;   {:added "1.0"
;;    :go "mainStart(_deps, ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(_tests.(testing.InternalTest))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(_benchmarks.(testing.InternalBenchmark))), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(_examples.(testing.InternalExample))))"}
;;   [^ABEND044(unsupported built-in type testDeps) _deps, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.RegisterCover from testing/cover.go:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n\nGo input arguments: (c Cover)\n\nJoker input arguments: [^go.std.testing/Cover c]"
;;   {:added "1.0"
;;    :go "registerCover(_c.(testing.Cover))"}
;;   [^GoObject _c])

JOKER FUNC testing.RunBenchmarks from testing/benchmark.go:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, benchmarks []InternalBenchmark)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalBenchmark) benchmarks]"
;;   {:added "1.0"
;;    :go "runBenchmarks(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(_benchmarks.(testing.InternalBenchmark))))"}
;;   [^fn _matchString, ^Object _benchmarks])

JOKER FUNC testing.RunExamples from testing/example.go:
;; (defn ^"Bool" RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, examples []InternalExample)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunExamples(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(_examples.(testing.InternalExample))))"}
;;   [^fn _matchString, ^Object _examples])

JOKER FUNC testing.RunTests from testing/testing.go:
;; (defn ^"Bool" RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, tests []InternalTest)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunTests(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(_tests.(testing.InternalTest))))"}
;;   [^fn _matchString, ^Object _tests])

JOKER FUNC testing.Short from testing/testing.go:
(defn ^"Bool" Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose from testing/testing.go:
(defn ^"Bool" Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["testing"]
    :doc "Provides a low-level interface to the testing package."
    :empty false}
  go.std.testing)
JOKER FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "dataErrReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "halfReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo input arguments: (prefix string, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^String prefix, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "newReadLogger(_prefix, _r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^String _prefix, ^GoObject _r])

JOKER FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo input arguments: (prefix string, w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^String prefix, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "newWriteLogger(_prefix, _w.(ABEND987(imports not yet supported: io.Writer)))"}
;;   [^String _prefix, ^GoObject _w])

JOKER FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "oneByteReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "timeoutReader(_r.(ABEND987(imports not yet supported: io.Reader)))"}
;;   [^GoObject _r])

JOKER FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo input arguments: (w io.Writer, n int64)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int64 n]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "truncateWriter(_w.(ABEND987(imports not yet supported: io.Writer)), _n)"}
;;   [^GoObject _w, ^Int64 _n])

JOKER FUNC testing/quick.Check from testing/quick/quick.go:
;; (defn ^"Error" Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo input arguments: (f interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_quick.Config(_config.(quick.Config))))"}
;;   [^<protocol-or-something> _f, ^Object _config])

JOKER FUNC testing/quick.CheckEqual from testing/quick/quick.go:
;; (defn ^"Error" CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo input arguments: (f interface {}, g interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^<protocol-or-something> g, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_quick.Config(_config.(quick.Config))))"}
;;   [^<protocol-or-something> _f, ^<protocol-or-something> _g, ^Object _config])

JOKER FUNC testing/quick.Value from testing/quick/quick.go:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo input arguments: (t reflect.Type, rand *rand.Rand)\n\nGo return type: (value reflect.Value, ok bool)\n\nJoker input arguments: [^go.std.reflect/Type t, ^(atom-of go.std.math.rand/Rand) rand]\n\nJoker return type: [go.std.reflect/Value Bool]"
;;   {:added "1.0"
;;    :go "value(_t.(ABEND987(imports not yet supported: reflect.Type)), ConvertToIndirectOfrand.Rand(_rand.(ABEND987(imports not yet supported: rand.Rand))))"}
;;   [^GoObject _t, ^Object _rand])

JOKER FUNC text/scanner.TokenString from text/scanner/scanner.go:
;; (defn ^"String" TokenString
;;   "TokenString returns a printable string for a token or Unicode character.\n\nGo input arguments: (tok rune)\n\nGo return type: string\n\nJoker input arguments: [^rune tok]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "scanner.TokenString(_tok)"}
;;   [^ABEND044(unsupported built-in type rune) _tok])

JOKER FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo input arguments: (output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Byte padchar, ^UInt flags]\n\nJoker return type: (atom-of go.std.text.tabwriter/Writer)"
;;   {:added "1.0"
;;    :go "newWriter(_output.(ABEND987(imports not yet supported: io.Writer)), _minwidth, _tabwidth, _padding, _padchar, _flags)"}
;;   [^GoObject _output, ^Int _minwidth, ^Int _tabwidth, ^Int _padding, ^Byte _padchar, ^UInt _flags])

JOKER FUNC text/template.HTMLEscape from text/template/funcs.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "hTMLEscape(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^GoObject _w, ^Object _b])

JOKER FUNC text/template.HTMLEscapeString from text/template/funcs.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.HTMLEscaper from text/template/funcs.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.IsTrue from text/template/exec.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC text/template.JSEscape from text/template/funcs.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "jSEscape(_w.(ABEND987(imports not yet supported: io.Writer)), ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_b)))"}
;;   [^GoObject _w, ^Object _b])

JOKER FUNC text/template.JSEscapeString from text/template/funcs.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.JSEscaper from text/template/funcs.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.Must from text/template/helper.go:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.text.template/Template) t, ^ABEND885(unrecognized type error at: GO.link/src/text/template/helper.go:21:28) err]\n\nJoker return type: (atom-of go.std.text.template/Template)"
;;   {:added "1.0"
;;    :go "must(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_template.Template(_t.(template.Template))), _err)"}
;;   [^Object _t, ^ABEND885(unrecognized type error at: GO.link/src/text/template/helper.go:21:28) _err])

JOKER FUNC text/template.New from text/template/template.go:
(defn New
  "New allocates a new, undefined template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "_new(_name)"}
  [^String _name])

JOKER FUNC text/template.ParseFiles from text/template/helper.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
;;   {:added "1.0"
;;    :go "parseFiles(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHastring(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC text/template.ParseGlob from text/template/helper.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
  {:added "1.0"
   :go "parseGlob(_pattern)"}
  [^String _pattern])

JOKER FUNC text/template.URLQueryEscaper from text/template/funcs.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template"]
    :doc "Provides a low-level interface to the text/template package."
    :empty false}
  go.std.text.template)
JOKER FUNC text/template/parse.IsEmptyTree from text/template/parse/parse.go:
(defn ^"Bool" IsEmptyTree
  "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo input arguments: (n Node)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.text.template.parse/Node n]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "parse.IsEmptyTree(_n.(parse.Node))"}
  [^GoObject _n])

JOKER FUNC text/template/parse.New from text/template/parse/parse.go:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo input arguments: (name string, funcs ...map[])\n\nGo return type: *Tree\n\nJoker input arguments: [^String name, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: (atom-of go.std.text.template.parse/Tree)"
;;   {:added "1.0"
;;    :go "_new(_name, ConvertToEllipsisHaHamap[](ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String _name, ^{} _funcs])

JOKER FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
(defn NewIdentifier
  "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo input arguments: (ident string)\n\nGo return type: *IdentifierNode\n\nJoker input arguments: [^String ident]\n\nJoker return type: (atom-of go.std.text.template.parse/IdentifierNode)"
  {:added "1.0"
   :go "newIdentifier(_ident)"}
  [^String _ident])

JOKER FUNC text/template/parse.Parse from text/template/parse/parse.go:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo input arguments: (name string, text string, leftDelim string, rightDelim string, funcs ...map[])\n\nGo return type: (..., error)\n\nJoker input arguments: [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "parse(_name, _text, _leftDelim, _rightDelim, ConvertToEllipsisHaHamap[](ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String _name, ^String _text, ^String _leftDelim, ^String _rightDelim, ^{} _funcs])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template/parse"]
    :doc "Provides a low-level interface to the text/template/parse package."
    :empty false}
  go.std.text.template.parse)
JOKER FUNC time.After from time/sleep.go:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:152:24)"
;;   {:added "1.0"
;;    :go "after(_d.(time.Duration))"}
;;   [^GoObject _d])

JOKER FUNC time.AfterFunc from time/sleep.go:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo input arguments: (d Duration, f func)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d, ^fn f]\n\nJoker return type: (atom-of go.std.time/Timer)"
;;   {:added "1.0"
;;    :go "afterFunc(_d.(time.Duration), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^GoObject _d, ^fn _f])

JOKER FUNC time.Date from time/time.go:
;; (defn Date
;;   "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo input arguments: (year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location)\n\nGo return type: Time\n\nJoker input arguments: [^Int year, ^go.std.time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: go.std.time/Time"
;;   {:added "1.0"
;;    :go "date(_year, _month.(time.Month), _day, _hour, _min, _sec, _nsec, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_time.Location(_loc.(time.Location))))"}
;;   [^Int _year, ^GoObject _month, ^Int _day, ^Int _hour, ^Int _min, ^Int _sec, ^Int _nsec, ^Object _loc])

JOKER FUNC time.FixedZone from time/zoneinfo.go:
(defn FixedZone
  "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo input arguments: (name string, offset int)\n\nGo return type: *Location\n\nJoker input arguments: [^String name, ^Int offset]\n\nJoker return type: (atom-of go.std.time/Location)"
  {:added "1.0"
   :go "fixedZone(_name, _offset)"}
  [^String _name, ^Int _offset])

JOKER FUNC time.LoadLocation from time/zoneinfo.go:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo input arguments: (name string)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
  {:added "1.0"
   :go "loadLocation(_name)"}
  [^String _name])

JOKER FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo input arguments: (name string, data []byte)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name, ^(vector-of Byte) data]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
;;   {:added "1.0"
;;    :go "loadLocationFromTZData(_name, ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_data)))"}
;;   [^String _name, ^Object _data])

JOKER FUNC time.NewTicker from time/tick.go:
(defn NewTicker
  "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo input arguments: (d Duration)\n\nGo return type: *Ticker\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Ticker)"
  {:added "1.0"
   :go "newTicker(_d.(time.Duration))"}
  [^GoObject _d])

JOKER FUNC time.NewTimer from time/sleep.go:
(defn NewTimer
  "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo input arguments: (d Duration)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Timer)"
  {:added "1.0"
   :go "newTimer(_d.(time.Duration))"}
  [^GoObject _d])

JOKER FUNC time.Now from time/time.go:
(defn Now
  "Now returns the current local time.\n\nGo return type: Time\n\nJoker input arguments: []\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "now()"}
  [])

JOKER FUNC time.Parse from time/format.go:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo input arguments: (layout string, value string)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "parse(_layout, _value)"}
  [^String _layout, ^String _value])

JOKER FUNC time.ParseDuration from time/format.go:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo input arguments: (s string)\n\nGo return type: (Duration, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.time/Duration Error]"
  {:added "1.0"
   :go "parseDuration(_s)"}
  [^String _s])

JOKER FUNC time.ParseInLocation from time/format.go:
;; (defn ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo input arguments: (layout string, value string, loc *Location)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: [go.std.time/Time Error]"
;;   {:added "1.0"
;;    :go "parseInLocation(_layout, _value, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_time.Location(_loc.(time.Location))))"}
;;   [^String _layout, ^String _value, ^Object _loc])

JOKER FUNC time.Since from time/time.go:
(defn Since
  "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "since(_t.(time.Time))"}
  [^GoObject _t])

JOKER FUNC time.Sleep from time/sleep.go:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n\nGo input arguments: (d Duration)\n\nJoker input arguments: [^go.std.time/Duration d]"
;;   {:added "1.0"
;;    :go "sleep(_d.(time.Duration))"}
;;   [^GoObject _d])

JOKER FUNC time.Tick from time/tick.go:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "tick(_d.(time.Duration))"}
;;   [^GoObject _d])

JOKER FUNC time.Unix from time/time.go:
(defn Unix
  "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo input arguments: (sec int64, nsec int64)\n\nGo return type: Time\n\nJoker input arguments: [^Int64 sec, ^Int64 nsec]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "unix(_sec, _nsec)"}
  [^Int64 _sec, ^Int64 _nsec])

JOKER FUNC time.Until from time/time.go:
(defn Until
  "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "until(_t.(time.Time))"}
  [^GoObject _t])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["time"]
    :doc "Provides a low-level interface to the time package."
    :empty false}
  go.std.time)
JOKER FUNC unicode.In from unicode/graphic.go:
;; (defn ^"Bool" In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo input arguments: (r rune, ranges ...*RangeTable)\n\nGo return type: bool\n\nJoker input arguments: [^rune r, ^(ellipsis-somehow Object) ranges]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.In(_r, ConvertToEllipsisHaHa*_unicode.RangeTable(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_unicode.RangeTable(_ranges.(unicode.RangeTable)))))"}
;;   [^ABEND044(unsupported built-in type rune) _r, ^Object _ranges])

JOKER FUNC unicode.Is from unicode/letter.go:
;; (defn ^"Bool" Is
;;   "Is reports whether the rune is in the specified table of ranges.\n\nGo input arguments: (rangeTab *RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unicode/RangeTable) rangeTab, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.Is(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_unicode.RangeTable(_rangeTab.(unicode.RangeTable))), _r)"}
;;   [^Object _rangeTab, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsControl from unicode/graphic.go:
;; (defn ^"Bool" IsControl
;;   "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsControl(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsDigit from unicode/digit.go:
;; (defn ^"Bool" IsDigit
;;   "IsDigit reports whether the rune is a decimal digit.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsDigit(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsGraphic from unicode/graphic.go:
;; (defn ^"Bool" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLetter from unicode/graphic.go:
;; (defn ^"Bool" IsLetter
;;   "IsLetter reports whether the rune is a letter (category L).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLetter(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLower from unicode/letter.go:
;; (defn ^"Bool" IsLower
;;   "IsLower reports whether the rune is a lower case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLower(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsMark from unicode/graphic.go:
;; (defn ^"Bool" IsMark
;;   "IsMark reports whether the rune is a mark character (category M).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsMark(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsNumber from unicode/graphic.go:
;; (defn ^"Bool" IsNumber
;;   "IsNumber reports whether the rune is a number (category N).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsNumber(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsOneOf from unicode/graphic.go:
;; (defn ^"Bool" IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo input arguments: (ranges []*RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of (atom-of go.std.unicode/RangeTable)) ranges, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ConvertToArrayOf*_unicode.RangeTable(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOf_unicode.RangeTable(_ranges.(unicode.RangeTable)))), _r)"}
;;   [^Object _ranges, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPrint from unicode/graphic.go:
;; (defn ^"Bool" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPrint(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPunct from unicode/graphic.go:
;; (defn ^"Bool" IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPunct(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSpace from unicode/graphic.go:
;; (defn ^"Bool" IsSpace
;;   "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSpace(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSymbol from unicode/graphic.go:
;; (defn ^"Bool" IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSymbol(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsTitle from unicode/letter.go:
;; (defn ^"Bool" IsTitle
;;   "IsTitle reports whether the rune is a title case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsTitle(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsUpper from unicode/letter.go:
;; (defn ^"Bool" IsUpper
;;   "IsUpper reports whether the rune is an upper case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsUpper(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.SimpleFold from unicode/letter.go:
;; (defn SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, )\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "simpleFold(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.To from unicode/letter.go:
;; (defn To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo input arguments: (_case int, r rune)\n\nGo return type: ...\n\nJoker input arguments: [^Int _case, ^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "to(__case, _r)"}
;;   [^Int __case, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToLower from unicode/letter.go:
;; (defn ToLower
;;   "ToLower maps the rune to lower case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toLower(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToTitle from unicode/letter.go:
;; (defn ToTitle
;;   "ToTitle maps the rune to title case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toTitle(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToUpper from unicode/letter.go:
;; (defn ToUpper
;;   "ToUpper maps the rune to upper case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toUpper(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo input arguments: (s []uint16)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of UInt16) s]\n\nJoker return type: (vector-of ABEND043(unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "decode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfuint16(_s)))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
;; (defn DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "decodeRune(_r1, _r2)"}
;;   [^ABEND044(unsupported built-in type rune) _r1, ^ABEND044(unsupported built-in type rune) _r2])

JOKER FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo input arguments: (s []rune)\n\nGo return type: []uint16\n\nJoker input arguments: [^(vector-of rune) s]\n\nJoker return type: (vector-of )"
;;   {:added "1.0"
;;    :go "encode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfrune(_s)))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
;; (defn EncodeRune
;;   "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo input arguments: (r rune)\n\nGo return type: (r1 ..., r2 ...)\n\nJoker input arguments: [^rune r]\n\nJoker return type: [ABEND043(unsupported built-in type rune) ABEND043(unsupported built-in type rune)]"
;;   {:added "1.0"
;;    :go "encodeRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
;; (defn ^"Bool" IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf16.IsSurrogate(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
;; (defn DecodeLastRuneInString
;;   "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
;; (defn DecodeRuneInString
;;   "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
;; (defn ^"Int" EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo input arguments: (p []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)), _r)"}
;;   [^Object _p, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
;; (defn ^"Bool" FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.FullRune(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.FullRuneInString from unicode/utf8/utf8.go:
(defn ^"Bool" FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.FullRuneInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo input arguments: (p []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneCount(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.RuneCountInString from unicode/utf8/utf8.go:
(defn ^"Int" RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneLen
;;   "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo input arguments: (r rune)\n\nGo return type: int\n\nJoker input arguments: [^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneLen(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.RuneStart from unicode/utf8/utf8.go:
(defn ^"Bool" RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo input arguments: (b byte)\n\nGo return type: bool\n\nJoker input arguments: [^Byte b]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.RuneStart(_b)"}
  [^Byte _b])

JOKER FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
;; (defn ^"Bool" Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.Valid(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfbyte(_p)))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
;; (defn ^"Bool" ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.ValidRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.ValidString from unicode/utf8/utf8.go:
(defn ^"Bool" ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.ValidString(_s)"}
  [^String _s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf8"]
    :doc "Provides a low-level interface to the unicode/utf8 package."
    :empty false}
  go.std.unicode.utf8)
JOKER FUNC unsafe.Alignof from unsafe/unsafe.go:
;; (defn Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment\nof a hypothetical variable v as if v was declared via var v = x.\nIt is the largest value m such that the address of v is always zero mod m.\nIt is the same as the value returned by reflect.TypeOf(x).Align().\nAs a special case, if a variable s is of struct type and f is a field\nwithin that struct, then Alignof(s.f) will return the required alignment\nof a field of that type within a struct. This case is the same as the\nvalue returned by reflect.TypeOf(s.f).FieldAlign().\n\nGo input arguments: (x ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.unsafe/ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "alignof(_x.(unsafe.ArbitraryType))"}
;;   [^GoObject _x])

JOKER FUNC unsafe.Offsetof from unsafe/unsafe.go:
;; (defn Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,\nwhich must be of the form structValue.field. In other words, it returns the\nnumber of bytes between the start of the struct and the start of the field.\n\nGo input arguments: (x ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.unsafe/ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "offsetof(_x.(unsafe.ArbitraryType))"}
;;   [^GoObject _x])

JOKER FUNC unsafe.Sizeof from unsafe/unsafe.go:
;; (defn Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes\nof a hypothetical variable v as if v was declared via var v = x.\nThe size does not include any memory possibly referenced by x.\nFor instance, if x is a slice, Sizeof returns the size of the slice\ndescriptor, not the size of the memory referenced by the slice.\n\nGo input arguments: (x ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.unsafe/ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "sizeof(_x.(unsafe.ArbitraryType))"}
;;   [^GoObject _x])

GO FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
// func fileInfoHeader(fi os.FileInfo, link string) Object {
// 	_res1, _res2 := _tar.FileInfoHeader(fi, link)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/tar.NewReader from archive/tar/reader.go:
// func newReader(r io.Reader) Object {
// 	_res := _tar.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.NewWriter from archive/tar/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _tar.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
// func fileInfoHeader(fi os.FileInfo) Object {
// 	_res1, _res2 := _zip.FileInfoHeader(fi)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewReader from archive/zip/reader.go:
// func newReader(r io.ReaderAt, size int64) Object {
// 	_res1, _res2 := _zip.NewReader(r, size)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewWriter from archive/zip/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _zip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/zip.OpenReader from archive/zip/reader.go:
func openReader(name string) Object {
	_res1, _res2 := _zip.OpenReader(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
// func registerCompressor(method uint16, comp _zip.Compressor) Object {
// 	_zip.RegisterCompressor(method, comp)
// 	...ABEND675: TODO...
// }

GO FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
// func registerDecompressor(method uint16, dcomp _zip.Decompressor) Object {
// 	_zip.RegisterDecompressor(method, dcomp)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package zip

import (
	_zip "archive/zip"
	. "github.com/candid82/joker/core"
)
GO FUNC bufio.NewReadWriter from bufio/bufio.go:
// func newReadWriter(r *_bufio.Reader, w *_bufio.Writer) Object {
// 	_res := _bufio.NewReadWriter(r, w)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewReader from bufio/bufio.go:
// func newReader(rd io.Reader) Object {
// 	_res := _bufio.NewReader(rd)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewReaderSize from bufio/bufio.go:
// func newReaderSize(rd io.Reader, size int) Object {
// 	_res := _bufio.NewReaderSize(rd, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewScanner from bufio/scan.go:
// func newScanner(r io.Reader) Object {
// 	_res := _bufio.NewScanner(r)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriter from bufio/bufio.go:
// func newWriter(w io.Writer) Object {
// 	_res := _bufio.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriterSize from bufio/bufio.go:
// func newWriterSize(w io.Writer, size int) Object {
// 	_res := _bufio.NewWriterSize(w, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.ScanBytes from bufio/scan.go:
// func scanBytes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanBytes(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanLines from bufio/scan.go:
// func scanLines(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanLines(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanRunes from bufio/scan.go:
// func scanRunes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanRunes(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanWords from bufio/scan.go:
// func scanWords(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanWords(data, atEOF)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bytes.Compare from bytes/bytes_decl.go:
// func compare(a []byte, b []byte)  {
// 	_res := _bytes.Compare(a, b)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Contains from bytes/bytes.go:
// func contains(b []byte, subslice []byte)  {
// 	_res := _bytes.Contains(b, subslice)
// 	return MakeBool(_res)
// }

GO FUNC bytes.ContainsAny from bytes/bytes.go:
// func containsAny(b []byte, chars string)  {
// 	_res := _bytes.ContainsAny(b, chars)
// 	return MakeBool(_res)
// }

GO FUNC bytes.ContainsRune from bytes/bytes.go:
// func containsRune(b []byte, r rune)  {
// 	_res := _bytes.ContainsRune(b, r)
// 	return MakeBool(_res)
// }

GO FUNC bytes.Count from bytes/bytes.go:
// func count(s []byte, sep []byte)  {
// 	_res := _bytes.Count(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Equal from bytes/bytes_decl.go:
// func equal(a []byte, b []byte)  {
// 	_res := _bytes.Equal(a, b)
// 	return MakeBool(_res)
// }

GO FUNC bytes.EqualFold from bytes/bytes.go:
// func equalFold(s []byte, t []byte)  {
// 	_res := _bytes.EqualFold(s, t)
// 	return MakeBool(_res)
// }

GO FUNC bytes.Fields from bytes/bytes.go:
// func fields(s []byte) Object {
// 	_res := _bytes.Fields(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.FieldsFunc from bytes/bytes.go:
// func fieldsFunc(s []byte, f func) Object {
// 	_res := _bytes.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.HasPrefix from bytes/bytes.go:
// func hasPrefix(s []byte, prefix []byte)  {
// 	_res := _bytes.HasPrefix(s, prefix)
// 	return MakeBool(_res)
// }

GO FUNC bytes.HasSuffix from bytes/bytes.go:
// func hasSuffix(s []byte, suffix []byte)  {
// 	_res := _bytes.HasSuffix(s, suffix)
// 	return MakeBool(_res)
// }

GO FUNC bytes.Index from bytes/bytes.go:
// func index(s []byte, sep []byte)  {
// 	_res := _bytes.Index(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexAny from bytes/bytes.go:
// func indexAny(s []byte, chars string)  {
// 	_res := _bytes.IndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexByte from bytes/bytes_decl.go:
// func indexByte(b []byte, c byte)  {
// 	_res := _bytes.IndexByte(b, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexFunc from bytes/bytes.go:
// func indexFunc(s []byte, f func)  {
// 	_res := _bytes.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexRune from bytes/bytes.go:
// func indexRune(s []byte, r rune)  {
// 	_res := _bytes.IndexRune(s, r)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Join from bytes/bytes.go:
// func join(s [][]byte, sep []byte) Object {
// 	_res := _bytes.Join(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.LastIndex from bytes/bytes.go:
// func lastIndex(s []byte, sep []byte)  {
// 	_res := _bytes.LastIndex(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexAny from bytes/bytes.go:
// func lastIndexAny(s []byte, chars string)  {
// 	_res := _bytes.LastIndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexByte from bytes/bytes.go:
// func lastIndexByte(s []byte, c byte)  {
// 	_res := _bytes.LastIndexByte(s, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexFunc from bytes/bytes.go:
// func lastIndexFunc(s []byte, f func)  {
// 	_res := _bytes.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Map from bytes/bytes.go:
// func _map(mapping func, s []byte) Object {
// 	_res := _bytes.Map(mapping, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.NewBuffer from bytes/buffer.go:
// func newBuffer(buf []byte) Object {
// 	_res := _bytes.NewBuffer(buf)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.NewBufferString from bytes/buffer.go:
func newBufferString(s string) Object {
	_res := _bytes.NewBufferString(s)
	return MakeGoObject(_res)
}

GO FUNC bytes.NewReader from bytes/reader.go:
// func newReader(b []byte) Object {
// 	_res := _bytes.NewReader(b)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.Repeat from bytes/bytes.go:
// func repeat(b []byte, count int) Object {
// 	_res := _bytes.Repeat(b, count)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Replace from bytes/bytes.go:
// func replace(s []byte, old []byte, new []byte, n int) Object {
// 	_res := _bytes.Replace(s, old, new, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Runes from bytes/bytes.go:
// func runes(s []byte) Object {
// 	_res := _bytes.Runes(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Split from bytes/bytes.go:
// func split(s []byte, sep []byte) Object {
// 	_res := _bytes.Split(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfter from bytes/bytes.go:
// func splitAfter(s []byte, sep []byte) Object {
// 	_res := _bytes.SplitAfter(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfterN from bytes/bytes.go:
// func splitAfterN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitAfterN(s, sep, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitN from bytes/bytes.go:
// func splitN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitN(s, sep, n)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Title from bytes/bytes.go:
// func title(s []byte) Object {
// 	_res := _bytes.Title(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLower from bytes/bytes.go:
// func toLower(s []byte) Object {
// 	_res := _bytes.ToLower(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLowerSpecial from bytes/bytes.go:
// func toLowerSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToLowerSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitle from bytes/bytes.go:
// func toTitle(s []byte) Object {
// 	_res := _bytes.ToTitle(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitleSpecial from bytes/bytes.go:
// func toTitleSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToTitleSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpper from bytes/bytes.go:
// func toUpper(s []byte) Object {
// 	_res := _bytes.ToUpper(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpperSpecial from bytes/bytes.go:
// func toUpperSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToUpperSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Trim from bytes/bytes.go:
// func trim(s []byte, cutset string) Object {
// 	_res := _bytes.Trim(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimFunc from bytes/bytes.go:
// func trimFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeft from bytes/bytes.go:
// func trimLeft(s []byte, cutset string) Object {
// 	_res := _bytes.TrimLeft(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeftFunc from bytes/bytes.go:
// func trimLeftFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimLeftFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimPrefix from bytes/bytes.go:
// func trimPrefix(s []byte, prefix []byte) Object {
// 	_res := _bytes.TrimPrefix(s, prefix)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRight from bytes/bytes.go:
// func trimRight(s []byte, cutset string) Object {
// 	_res := _bytes.TrimRight(s, cutset)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRightFunc from bytes/bytes.go:
// func trimRightFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimRightFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSpace from bytes/bytes.go:
// func trimSpace(s []byte) Object {
// 	_res := _bytes.TrimSpace(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSuffix from bytes/bytes.go:
// func trimSuffix(s []byte, suffix []byte) Object {
// 	_res := _bytes.TrimSuffix(s, suffix)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bytes

import (
	_bytes "bytes"
	. "github.com/candid82/joker/core"
)
GO FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
// func newReader(r io.Reader) Object {
// 	_res := _bzip2.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewReader from compress/flate/inflate.go:
// func newReader(r io.Reader) Object {
// 	_res := _flate.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
// func newReaderDict(r io.Reader, dict []byte) Object {
// 	_res := _flate.NewReaderDict(r, dict)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewWriter from compress/flate/deflate.go:
// func newWriter(w io.Writer, level int) Object {
// 	_res1, _res2 := _flate.NewWriter(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
// func newWriterDict(w io.Writer, level int, dict []byte) Object {
// 	_res1, _res2 := _flate.NewWriterDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
// func newReader(r io.Reader) Object {
// 	_res1, _res2 := _gzip.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
// func newWriter(w io.Writer) Object {
// 	_res := _gzip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
// func newWriterLevel(w io.Writer, level int) Object {
// 	_res1, _res2 := _gzip.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/lzw.NewReader from compress/lzw/reader.go:
// func newReader(r io.Reader, order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewReader(r, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
// func newWriter(w io.Writer, order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewWriter(w, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/zlib.NewReader from compress/zlib/reader.go:
// func newReader(r io.Reader) Object {
// 	_res1, _res2 := _zlib.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
// func newReaderDict(r io.Reader, dict []byte) Object {
// 	_res1, _res2 := _zlib.NewReaderDict(r, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _zlib.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
// func newWriterLevel(w io.Writer, level int) Object {
// 	_res1, _res2 := _zlib.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
// func newWriterLevelDict(w io.Writer, level int, dict []byte) Object {
// 	_res1, _res2 := _zlib.NewWriterLevelDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC container/heap.Fix from container/heap/heap.go:
// func fix(h _heap.Interface, i int) Object {
// 	_heap.Fix(h, i)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Init from container/heap/heap.go:
// func init(h _heap.Interface) Object {
// 	_heap.Init(h)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Pop from container/heap/heap.go:
// func pop(h _heap.Interface) Object {
// 	return _heap.Pop(h)
// }

GO FUNC container/heap.Push from container/heap/heap.go:
// func push(h _heap.Interface, x interface {}) Object {
// 	_heap.Push(h, x)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Remove from container/heap/heap.go:
// func remove(h _heap.Interface, i int) Object {
// 	return _heap.Remove(h, i)
// }

GO FUNC container/list.New from container/list/list.go:
func _new() Object {
	_res := _list.New()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package list

import (
	_list "container/list"
	. "github.com/candid82/joker/core"
)
GO FUNC container/ring.New from container/ring/ring.go:
func _new(n int) Object {
	_res := _ring.New(n)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ring

import (
	_ring "container/ring"
	. "github.com/candid82/joker/core"
)
GO FUNC context.Background from context/context.go:
func background() Object {
	_res := _context.Background()
	return MakeGoObject(_res)
}

GO FUNC context.TODO from context/context.go:
func tODO() Object {
	_res := _context.TODO()
	return MakeGoObject(_res)
}

GO FUNC context.WithCancel from context/context.go:
func withCancel(parent _context.Context) Object {
	ctx, cancel := _context.WithCancel(parent)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(ctx))
	_res = _res.Conjoin(MakeGoObject(cancel))
	return _res
}

GO FUNC context.WithDeadline from context/context.go:
// func withDeadline(parent _context.Context, d time.Time) Object {
// 	_res1, _res2 := _context.WithDeadline(parent, d)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithTimeout from context/context.go:
// func withTimeout(parent _context.Context, timeout time.Duration) Object {
// 	_res1, _res2 := _context.WithTimeout(parent, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithValue from context/context.go:
// func withValue(parent _context.Context, key interface {}, val interface {}) Object {
// 	_res := _context.WithValue(parent, key, val)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package context

import (
	_context "context"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto.RegisterHash from crypto/crypto.go:
// func registerHash(h _crypto.Hash, f func) Object {
// 	_crypto.RegisterHash(h, f)
// 	...ABEND675: TODO...
// }

GO FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
// func newCipher(key []byte) Object {
// 	_res1, _res2 := _aes.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
// func newCBCDecrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCDecrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
// func newCBCEncrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCEncrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
// func newCFBDecrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBDecrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
// func newCFBEncrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBEncrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
// func newCTR(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCTR(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
func newGCM(cipher _cipher.Block) Object {
	_res1, _res2 := _cipher.NewGCM(cipher)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
func newGCMWithNonceSize(cipher _cipher.Block, size int) Object {
	_res1, _res2 := _cipher.NewGCMWithNonceSize(cipher, size)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
func newGCMWithTagSize(cipher _cipher.Block, tagSize int) Object {
	_res1, _res2 := _cipher.NewGCMWithTagSize(cipher, tagSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
// func newOFB(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewOFB(b, iv)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cipher

import (
	_cipher "crypto/cipher"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/des.NewCipher from crypto/des/cipher.go:
// func newCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
// func newTripleDESCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewTripleDESCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
// func generateKey(priv *_dsa.PrivateKey, rand io.Reader)  {
// 	_res := _dsa.GenerateKey(priv, rand)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
// func generateParameters(params *_dsa.Parameters, rand io.Reader, sizes _dsa.ParameterSizes)  {
// 	_res := _dsa.GenerateParameters(params, rand, sizes)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
// func sign(rand io.Reader, priv *_dsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _dsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
// func verify(pub *_dsa.PublicKey, hash []byte, r *big.Int, s *big.Int)  {
// 	_res := _dsa.Verify(pub, hash, r, s)
// 	return MakeBool(_res)
// }

GO FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
// func generateKey(c elliptic.Curve, rand io.Reader) Object {
// 	_res1, _res2 := _ecdsa.GenerateKey(c, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
// func sign(rand io.Reader, priv *_ecdsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _ecdsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
// func verify(pub *_ecdsa.PublicKey, hash []byte, r *big.Int, s *big.Int)  {
// 	_res := _ecdsa.Verify(pub, hash, r, s)
// 	return MakeBool(_res)
// }

GO FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
// func generateKey(curve _elliptic.Curve, rand io.Reader) Object {
// 	priv, x, y, err := _elliptic.GenerateKey(curve, rand)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range priv {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
// func marshal(curve _elliptic.Curve, x *big.Int, y *big.Int) Object {
// 	_res := _elliptic.Marshal(curve, x, y)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
func p224() Object {
	_res := _elliptic.P224()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
func p256() Object {
	_res := _elliptic.P256()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
func p384() Object {
	_res := _elliptic.P384()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
func p521() Object {
	_res := _elliptic.P521()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
// func unmarshal(curve _elliptic.Curve, data []byte) Object {
// 	x, y := _elliptic.Unmarshal(curve, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elliptic

import (
	_elliptic "crypto/elliptic"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
// func equal(mac1 []byte, mac2 []byte)  {
// 	_res := _hmac.Equal(mac1, mac2)
// 	return MakeBool(_res)
// }

GO FUNC crypto/hmac.New from crypto/hmac/hmac.go:
// func _new(h func, key []byte) Object {
// 	_res := _hmac.New(h, key)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/md5.New from crypto/md5/md5.go:
func _new() Object {
	_res := _md5.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/md5.Sum from crypto/md5/md5.go:
// func sum(data []byte) Object {
// 	_res := _md5.Sum(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package md5

import (
	_md5 "crypto/md5"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/rand.Int from crypto/rand/util.go:
// func _int(rand io.Reader, max *big.Int) Object {
// 	n, err := _rand.Int(rand, max)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Prime from crypto/rand/util.go:
// func prime(rand io.Reader, bits int) Object {
// 	p, err := _rand.Prime(rand, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Read from crypto/rand/rand.go:
// func read(b []byte) Object {
// 	n, err := _rand.Read(b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
// func newCipher(key []byte) Object {
// 	_res1, _res2 := _rc4.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
// func decryptOAEP(hash hash.Hash, random io.Reader, priv *_rsa.PrivateKey, ciphertext []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func decryptPKCS1v15(rand io.Reader, priv *_rsa.PrivateKey, ciphertext []byte) Object {
// 	_res1, _res2 := _rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
// func decryptPKCS1v15SessionKey(rand io.Reader, priv *_rsa.PrivateKey, ciphertext []byte, key []byte)  {
// 	_res := _rsa.DecryptPKCS1v15SessionKey(rand, priv, ciphertext, key)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
// func encryptOAEP(hash hash.Hash, random io.Reader, pub *_rsa.PublicKey, msg []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func encryptPKCS1v15(rand io.Reader, pub *_rsa.PublicKey, msg []byte) Object {
// 	_res1, _res2 := _rsa.EncryptPKCS1v15(rand, pub, msg)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
// func generateKey(random io.Reader, bits int) Object {
// 	_res1, _res2 := _rsa.GenerateKey(random, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
// func generateMultiPrimeKey(random io.Reader, nprimes int, bits int) Object {
// 	_res1, _res2 := _rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func signPKCS1v15(rand io.Reader, priv *_rsa.PrivateKey, hash crypto.Hash, hashed []byte) Object {
// 	_res1, _res2 := _rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
// func signPSS(rand io.Reader, priv *_rsa.PrivateKey, hash crypto.Hash, hashed []byte, opts *_rsa.PSSOptions) Object {
// 	_res1, _res2 := _rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func verifyPKCS1v15(pub *_rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte)  {
// 	_res := _rsa.VerifyPKCS1v15(pub, hash, hashed, sig)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
// func verifyPSS(pub *_rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *_rsa.PSSOptions)  {
// 	_res := _rsa.VerifyPSS(pub, hash, hashed, sig, opts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/sha1.New from crypto/sha1/sha1.go:
func _new() Object {
	_res := _sha1.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
// func sum(data []byte) Object {
// 	_res := _sha1.Sum(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha1

import (
	_sha1 "crypto/sha1"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/sha256.New from crypto/sha256/sha256.go:
func _new() Object {
	_res := _sha256.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
func new224() Object {
	_res := _sha256.New224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
// func sum224(data []byte) Object {
// 	_res := _sha256.Sum224(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
// func sum256(data []byte) Object {
// 	_res := _sha256.Sum256(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha256

import (
	_sha256 "crypto/sha256"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/sha512.New from crypto/sha512/sha512.go:
func _new() Object {
	_res := _sha512.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
func new384() Object {
	_res := _sha512.New384()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
func new512_224() Object {
	_res := _sha512.New512_224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
func new512_256() Object {
	_res := _sha512.New512_256()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
// func sum384(data []byte) Object {
// 	_res := _sha512.Sum384(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
// func sum512(data []byte) Object {
// 	_res := _sha512.Sum512(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
// func sum512_224(data []byte) Object {
// 	_res := _sha512.Sum512_224(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
// func sum512_256(data []byte) Object {
// 	_res := _sha512.Sum512_256(data)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha512

import (
	_sha512 "crypto/sha512"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
// func constantTimeByteEq(x uint8, y uint8)  {
// 	_res := _subtle.ConstantTimeByteEq(x, y)
// 	return MakeInt(_res)
// }

GO FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
// func constantTimeCompare(x []byte, y []byte)  {
// 	_res := _subtle.ConstantTimeCompare(x, y)
// 	return MakeInt(_res)
// }

GO FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
// func constantTimeCopy(v int, x []byte, y []byte) Object {
// 	_subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package subtle

import (
)
GO FUNC crypto/tls.Client from crypto/tls/tls.go:
// func client(conn net.Conn, config *_tls.Config) Object {
// 	_res := _tls.Client(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Dial from crypto/tls/tls.go:
// func dial(network string, addr string, config *_tls.Config) Object {
// 	_res1, _res2 := _tls.Dial(network, addr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
// func dialWithDialer(dialer *net.Dialer, network string, addr string, config *_tls.Config) Object {
// 	_res1, _res2 := _tls.DialWithDialer(dialer, network, addr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.Listen from crypto/tls/tls.go:
// func listen(network string, laddr string, config *_tls.Config) Object {
// 	_res1, _res2 := _tls.Listen(network, laddr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
func loadX509KeyPair(certFile string, keyFile string) Object {
	_res1, _res2 := _tls.LoadX509KeyPair(certFile, keyFile)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
func newLRUClientSessionCache(capacity int) Object {
	_res := _tls.NewLRUClientSessionCache(capacity)
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.NewListener from crypto/tls/tls.go:
// func newListener(inner net.Listener, config *_tls.Config) Object {
// 	_res := _tls.NewListener(inner, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Server from crypto/tls/tls.go:
// func server(conn net.Conn, config *_tls.Config) Object {
// 	_res := _tls.Server(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
// func x509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) Object {
// 	_res1, _res2 := _tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package tls

import (
	_tls "crypto/tls"
	. "github.com/candid82/joker/core"
)
GO FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
// func createCertificate(rand io.Reader, template *_x509.Certificate, parent *_x509.Certificate, pub interface {}, priv interface {}) Object {
// 	cert, err := _x509.CreateCertificate(rand, template, parent, pub, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range cert {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
// func createCertificateRequest(rand io.Reader, template *_x509.CertificateRequest, priv interface {}) Object {
// 	csr, err := _x509.CreateCertificateRequest(rand, template, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range csr {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
// func decryptPEMBlock(b *pem.Block, password []byte) Object {
// 	_res1, _res2 := _x509.DecryptPEMBlock(b, password)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
// func encryptPEMBlock(rand io.Reader, blockType string, data []byte, password []byte, alg _x509.PEMCipher) Object {
// 	_res1, _res2 := _x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
// func isEncryptedPEMBlock(b *pem.Block)  {
// 	_res := _x509.IsEncryptedPEMBlock(b)
// 	return MakeBool(_res)
// }

GO FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
// func marshalECPrivateKey(key *ecdsa.PrivateKey) Object {
// 	_res1, _res2 := _x509.MarshalECPrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
// func marshalPKCS1PrivateKey(key *rsa.PrivateKey) Object {
// 	_res := _x509.MarshalPKCS1PrivateKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
// func marshalPKCS1PublicKey(key *rsa.PublicKey) Object {
// 	_res := _x509.MarshalPKCS1PublicKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
// func marshalPKCS8PrivateKey(key interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKCS8PrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
// func marshalPKIXPublicKey(pub interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKIXPublicKey(pub)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
func newCertPool() Object {
	_res := _x509.NewCertPool()
	return MakeGoObject(_res)
}

GO FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
// func parseCRL(crlBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseCRL(crlBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
// func parseCertificate(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificate(asn1Data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
// func parseCertificateRequest(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificateRequest(asn1Data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
// func parseCertificates(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificates(asn1Data)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
// func parseDERCRL(derBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseDERCRL(derBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
// func parseECPrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParseECPrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
// func parsePKCS1PrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
// func parsePKCS1PublicKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PublicKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
// func parsePKCS8PrivateKey(der []byte) Object {
// 	key, err := _x509.ParsePKCS8PrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(key)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
// func parsePKIXPublicKey(derBytes []byte) Object {
// 	pub, err := _x509.ParsePKIXPublicKey(derBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pub)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
func systemCertPool() Object {
	_res1, _res2 := _x509.SystemCertPool()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package x509

import (
	_x509 "crypto/x509"
	. "github.com/candid82/joker/core"
)
GO FUNC database/sql.Drivers from database/sql/sql.go:
func drivers() Object {
	_res := _sql.Drivers()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC database/sql.Named from database/sql/sql.go:
// func named(name string, value interface {}) Object {
// 	_res := _sql.Named(name, value)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Open from database/sql/sql.go:
func open(driverName string, dataSourceName string) Object {
	_res1, _res2 := _sql.Open(driverName, dataSourceName)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.OpenDB from database/sql/sql.go:
// func openDB(c driver.Connector) Object {
// 	_res := _sql.OpenDB(c)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Register from database/sql/sql.go:
// func register(name string, driver driver.Driver) Object {
// 	_sql.Register(name, driver)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sql

import (
	_sql "database/sql"
	. "github.com/candid82/joker/core"
)
GO FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
// func isScanValue(v interface {})  {
// 	_res := _driver.IsScanValue(v)
// 	return MakeBool(_res)
// }

GO FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
// func isValue(v interface {})  {
// 	_res := _driver.IsValue(v)
// 	return MakeBool(_res)
// }

GO FUNC debug/dwarf.New from debug/dwarf/open.go:
// func _new(abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte) Object {
// 	_res1, _res2 := _dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/elf.NewFile from debug/elf/file.go:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _elf.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/elf.Open from debug/elf/file.go:
func open(name string) Object {
	_res1, _res2 := _elf.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.R_INFO from debug/elf/elf.go:
// func r_INFO(sym uint32, typ uint32) Object {
// 	return _elf.R_INFO(sym, typ)
// }

GO FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
func r_INFO32(sym uint32, typ uint32) Object {
	_res := _elf.R_INFO32(sym, typ)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
func r_SYM32(info uint32) Object {
	_res := _elf.R_SYM32(info)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
// func r_SYM64(info uint64) Object {
// 	_res := _elf.R_SYM64(info)
// 	return MakeInt(int(_res))
// }

GO FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
func r_TYPE32(info uint32) Object {
	_res := _elf.R_TYPE32(info)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
// func r_TYPE64(info uint64) Object {
// 	_res := _elf.R_TYPE64(info)
// 	return MakeInt(int(_res))
// }

GO FUNC debug/elf.ST_BIND from debug/elf/elf.go:
// func sT_BIND(info uint8) Object {
// 	_res := _elf.ST_BIND(info)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/elf.ST_INFO from debug/elf/elf.go:
// func sT_INFO(bind _elf.SymBind, typ _elf.SymType) Object {
// 	return _elf.ST_INFO(bind, typ)
// }

GO FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
// func sT_TYPE(info uint8) Object {
// 	_res := _elf.ST_TYPE(info)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
// func sT_VISIBILITY(other uint8) Object {
// 	_res := _elf.ST_VISIBILITY(other)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elf

import (
	_elf "debug/elf"
	. "github.com/candid82/joker/core"
)
GO FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
// func newLineTable(data []byte, text uint64) Object {
// 	_res := _gosym.NewLineTable(data, text)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
// func newTable(symtab []byte, pcln *_gosym.LineTable) Object {
// 	_res1, _res2 := _gosym.NewTable(symtab, pcln)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFatFile from debug/macho/fat.go:
// func newFatFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _macho.NewFatFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFile from debug/macho/file.go:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _macho.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.Open from debug/macho/file.go:
func open(name string) Object {
	_res1, _res2 := _macho.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.OpenFat from debug/macho/fat.go:
func openFat(name string) Object {
	_res1, _res2 := _macho.OpenFat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package macho

import (
	_macho "debug/macho"
	. "github.com/candid82/joker/core"
)
GO FUNC debug/pe.NewFile from debug/pe/file.go:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _pe.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/pe.Open from debug/pe/file.go:
func open(name string) Object {
	_res1, _res2 := _pe.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pe

import (
	_pe "debug/pe"
	. "github.com/candid82/joker/core"
)
GO FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _plan9obj.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
func open(name string) Object {
	_res1, _res2 := _plan9obj.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plan9obj

import (
	_plan9obj "debug/plan9obj"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
// func decode(dst []byte, src []byte, flush bool) Object {
// 	ndst, nsrc, err := _ascii85.Decode(dst, src, flush)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(ndst))
// 	_res = _res.Conjoin(MakeInt(nsrc))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
// func encode(dst []byte, src []byte)  {
// 	_res := _ascii85.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
// func newDecoder(r io.Reader) Object {
// 	_res := _ascii85.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
// func newEncoder(w io.Writer) Object {
// 	_res := _ascii85.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ascii85

import (
)
GO FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
// func marshal(val interface {}) Object {
// 	_res1, _res2 := _asn1.Marshal(val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
// func marshalWithParams(val interface {}, params string) Object {
// 	_res1, _res2 := _asn1.MarshalWithParams(val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
// func unmarshal(b []byte, val interface {}) Object {
// 	rest, err := _asn1.Unmarshal(b, val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
// func unmarshalWithParams(b []byte, val interface {}, params string) Object {
// 	rest, err := _asn1.UnmarshalWithParams(b, val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
// func newDecoder(enc *_base32.Encoding, r io.Reader) Object {
// 	_res := _base32.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
// func newEncoder(enc *_base32.Encoding, w io.Writer) Object {
// 	_res := _base32.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
func newEncoding(encoder string) Object {
	_res := _base32.NewEncoding(encoder)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base32

import (
	_base32 "encoding/base32"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
// func newDecoder(enc *_base64.Encoding, r io.Reader) Object {
// 	_res := _base64.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
// func newEncoder(enc *_base64.Encoding, w io.Writer) Object {
// 	_res := _base64.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
func newEncoding(encoder string) Object {
	_res := _base64.NewEncoding(encoder)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base64

import (
	_base64 "encoding/base64"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
// func putUvarint(buf []byte, x uint64)  {
// 	_res := _binary.PutUvarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
// func putVarint(buf []byte, x int64)  {
// 	_res := _binary.PutVarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Read from encoding/binary/binary.go:
// func read(r io.Reader, order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Read(r, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
// func readUvarint(r io.ByteReader) Object {
// 	_res1, _res2 := _binary.ReadUvarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
// func readVarint(r io.ByteReader) Object {
// 	_res1, _res2 := _binary.ReadVarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.Size from encoding/binary/binary.go:
// func size(v interface {})  {
// 	_res := _binary.Size(v)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
// func uvarint(buf []byte) Object {
// 	_res1, _res2 := _binary.Uvarint(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Varint from encoding/binary/varint.go:
// func varint(buf []byte) Object {
// 	_res1, _res2 := _binary.Varint(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Write from encoding/binary/binary.go:
// func write(w io.Writer, order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Write(w, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/csv.NewReader from encoding/csv/reader.go:
// func newReader(r io.Reader) Object {
// 	_res := _csv.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _csv.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
// func newDecoder(r io.Reader) Object {
// 	_res := _gob.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
// func newEncoder(w io.Writer) Object {
// 	_res := _gob.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.Register from encoding/gob/type.go:
// func register(value interface {}) Object {
// 	_gob.Register(value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/gob.RegisterName from encoding/gob/type.go:
// func registerName(name string, value interface {}) Object {
// 	_gob.RegisterName(name, value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/hex.Decode from encoding/hex/hex.go:
// func decode(dst []byte, src []byte) Object {
// 	_res1, _res2 := _hex.Decode(dst, src)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
func decodeString(s string) Object {
	_res1, _res2 := _hex.DecodeString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/hex.Dump from encoding/hex/hex.go:
// func dump(data []byte)  {
// 	_res := _hex.Dump(data)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.Dumper from encoding/hex/hex.go:
// func dumper(w io.Writer) Object {
// 	_res := _hex.Dumper(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.Encode from encoding/hex/hex.go:
// func encode(dst []byte, src []byte)  {
// 	_res := _hex.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
// func encodeToString(src []byte)  {
// 	_res := _hex.EncodeToString(src)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
// func newDecoder(r io.Reader) Object {
// 	_res := _hex.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
// func newEncoder(w io.Writer) Object {
// 	_res := _hex.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package hex

import (
	_hex "encoding/hex"
	. "github.com/candid82/joker/core"
)
GO FUNC encoding/json.Compact from encoding/json/indent.go:
// func compact(dst *bytes.Buffer, src []byte)  {
// 	_res := _json.Compact(dst, src)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
// func hTMLEscape(dst *bytes.Buffer, src []byte) Object {
// 	_json.HTMLEscape(dst, src)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/json.Indent from encoding/json/indent.go:
// func indent(dst *bytes.Buffer, src []byte, prefix string, indent string)  {
// 	_res := _json.Indent(dst, src, prefix, indent)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Marshal from encoding/json/encode.go:
// func marshal(v interface {}) Object {
// 	_res1, _res2 := _json.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
// func marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _json.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.NewDecoder from encoding/json/stream.go:
// func newDecoder(r io.Reader) Object {
// 	_res := _json.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.NewEncoder from encoding/json/stream.go:
// func newEncoder(w io.Writer) Object {
// 	_res := _json.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.Unmarshal from encoding/json/decode.go:
// func unmarshal(data []byte, v interface {})  {
// 	_res := _json.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Valid from encoding/json/scanner.go:
// func valid(data []byte)  {
// 	_res := _json.Valid(data)
// 	return MakeBool(_res)
// }

GO FUNC encoding/pem.Decode from encoding/pem/pem.go:
// func decode(data []byte) Object {
// 	p, rest := _pem.Decode(data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC encoding/pem.Encode from encoding/pem/pem.go:
// func encode(out io.Writer, b *_pem.Block)  {
// 	_res := _pem.Encode(out, b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
// func encodeToMemory(b *_pem.Block) Object {
// 	_res := _pem.EncodeToMemory(b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
func copyToken(t _xml.Token) Object {
	_res := _xml.CopyToken(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Escape from encoding/xml/xml.go:
// func escape(w io.Writer, s []byte) Object {
// 	_xml.Escape(w, s)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
// func escapeText(w io.Writer, s []byte)  {
// 	_res := _xml.EscapeText(w, s)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
// func marshal(v interface {}) Object {
// 	_res1, _res2 := _xml.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
// func marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _xml.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
// func newDecoder(r io.Reader) Object {
// 	_res := _xml.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
// func newEncoder(w io.Writer) Object {
// 	_res := _xml.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
func newTokenDecoder(t _xml.TokenReader) Object {
	_res := _xml.NewTokenDecoder(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
// func unmarshal(data []byte, v interface {})  {
// 	_res := _xml.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package xml

import (
	_xml "encoding/xml"
	. "github.com/candid82/joker/core"
)
// Auto-generated by gostd at (omitted for testing), do not edit!!

package errors

import (
)
GO FUNC expvar.Do from expvar/expvar.go:
// func do(f func) Object {
// 	_expvar.Do(f)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.Get from expvar/expvar.go:
func get(name string) Object {
	_res := _expvar.Get(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Handler from expvar/expvar.go:
func handler() Object {
	_res := _expvar.Handler()
	return MakeGoObject(_res)
}

GO FUNC expvar.NewFloat from expvar/expvar.go:
func newFloat(name string) Object {
	_res := _expvar.NewFloat(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewInt from expvar/expvar.go:
func newInt(name string) Object {
	_res := _expvar.NewInt(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewMap from expvar/expvar.go:
func newMap(name string) Object {
	_res := _expvar.NewMap(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewString from expvar/expvar.go:
func newString(name string) Object {
	_res := _expvar.NewString(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Publish from expvar/expvar.go:
// func publish(name string, v _expvar.Var) Object {
// 	_expvar.Publish(name, v)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package expvar

import (
	_expvar "expvar"
	. "github.com/candid82/joker/core"
)
GO FUNC flag.Args from flag/flag.go:
func args() Object {
	_res := _flag.Args()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC flag.Bool from flag/flag.go:
func _bool(name string, value bool, usage string) Object {
	_res := _flag.Bool(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.BoolVar from flag/flag.go:
// func boolVar(p *bool, name string, value bool, usage string) Object {
// 	_flag.BoolVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Duration from flag/flag.go:
// func duration(name string, value time.Duration, usage string) Object {
// 	_res := _flag.Duration(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.DurationVar from flag/flag.go:
// func durationVar(p *time.Duration, name string, value time.Duration, usage string) Object {
// 	_flag.DurationVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Float64 from flag/flag.go:
// func _float64(name string, value float64, usage string) Object {
// 	_res := _flag.Float64(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.Float64Var from flag/flag.go:
// func float64Var(p *float64, name string, value float64, usage string) Object {
// 	_flag.Float64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Int from flag/flag.go:
func _int(name string, value int, usage string) Object {
	_res := _flag.Int(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64 from flag/flag.go:
func _int64(name string, value int64, usage string) Object {
	_res := _flag.Int64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64Var from flag/flag.go:
// func int64Var(p *int64, name string, value int64, usage string) Object {
// 	_flag.Int64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.IntVar from flag/flag.go:
// func intVar(p *int, name string, value int, usage string) Object {
// 	_flag.IntVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Lookup from flag/flag.go:
func lookup(name string) Object {
	_res := _flag.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC flag.NewFlagSet from flag/flag.go:
func newFlagSet(name string, errorHandling _flag.ErrorHandling) Object {
	_res := _flag.NewFlagSet(name, errorHandling)
	return MakeGoObject(_res)
}

GO FUNC flag.Parse from flag/flag.go:
// func parse() Object {
// 	_flag.Parse()
// 	...ABEND675: TODO...
// }

GO FUNC flag.PrintDefaults from flag/flag.go:
// func printDefaults() Object {
// 	_flag.PrintDefaults()
// 	...ABEND675: TODO...
// }

GO FUNC flag.String from flag/flag.go:
func _string(name string, value string, usage string) Object {
	_res := _flag.String(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.StringVar from flag/flag.go:
// func stringVar(p *string, name string, value string, usage string) Object {
// 	_flag.StringVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Uint from flag/flag.go:
func _uint(name string, value uint, usage string) Object {
	_res := _flag.Uint(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Uint64 from flag/flag.go:
// func _uint64(name string, value uint64, usage string) Object {
// 	_res := _flag.Uint64(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.Uint64Var from flag/flag.go:
// func uint64Var(p *uint64, name string, value uint64, usage string) Object {
// 	_flag.Uint64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UintVar from flag/flag.go:
// func uintVar(p *uint, name string, value uint, usage string) Object {
// 	_flag.UintVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UnquoteUsage from flag/flag.go:
// func unquoteUsage(flag *_flag.Flag) Object {
// 	name, usage := _flag.UnquoteUsage(flag)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(name))
// 	_res = _res.Conjoin(MakeString(usage))
// 	return _res
// }

GO FUNC flag.Var from flag/flag.go:
// func _var(value _flag.Value, name string, usage string) Object {
// 	_flag.Var(value, name, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Visit from flag/flag.go:
// func visit(fn func) Object {
// 	_flag.Visit(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.VisitAll from flag/flag.go:
// func visitAll(fn func) Object {
// 	_flag.VisitAll(fn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package flag

import (
	_flag "flag"
	. "github.com/candid82/joker/core"
)
GO FUNC fmt.Errorf from fmt/print.go:
// func errorf(format string, a ...interface {})  {
// 	_res := _fmt.Errorf(format, a)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC fmt.Fprint from fmt/print.go:
// func fprint(w io.Writer, a ...interface {}) Object {
// 	n, err := _fmt.Fprint(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintf from fmt/print.go:
// func fprintf(w io.Writer, format string, a ...interface {}) Object {
// 	n, err := _fmt.Fprintf(w, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintln from fmt/print.go:
// func fprintln(w io.Writer, a ...interface {}) Object {
// 	n, err := _fmt.Fprintln(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscan from fmt/scan.go:
// func fscan(r io.Reader, a ...interface {}) Object {
// 	n, err := _fmt.Fscan(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanf from fmt/scan.go:
// func fscanf(r io.Reader, format string, a ...interface {}) Object {
// 	n, err := _fmt.Fscanf(r, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanln from fmt/scan.go:
// func fscanln(r io.Reader, a ...interface {}) Object {
// 	n, err := _fmt.Fscanln(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Print from fmt/print.go:
// func _print(a ...interface {}) Object {
// 	n, err := _fmt.Print(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Printf from fmt/print.go:
// func printf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Printf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Println from fmt/print.go:
// func _println(a ...interface {}) Object {
// 	n, err := _fmt.Println(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scan from fmt/scan.go:
// func scan(a ...interface {}) Object {
// 	n, err := _fmt.Scan(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanf from fmt/scan.go:
// func scanf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Scanf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanln from fmt/scan.go:
// func scanln(a ...interface {}) Object {
// 	n, err := _fmt.Scanln(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sprint from fmt/print.go:
// func sprint(a ...interface {})  {
// 	_res := _fmt.Sprint(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintf from fmt/print.go:
// func sprintf(format string, a ...interface {})  {
// 	_res := _fmt.Sprintf(format, a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintln from fmt/print.go:
// func sprintln(a ...interface {})  {
// 	_res := _fmt.Sprintln(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sscan from fmt/scan.go:
// func sscan(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscan(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanf from fmt/scan.go:
// func sscanf(str string, format string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanf(str, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanln from fmt/scan.go:
// func sscanln(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanln(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/ast.FileExports from go/ast/filter.go:
// func fileExports(src *_ast.File)  {
// 	_res := _ast.FileExports(src)
// 	return MakeBool(_res)
// }

GO FUNC go/ast.FilterFile from go/ast/filter.go:
// func filterFile(src *_ast.File, f _ast.Filter)  {
// 	_res := _ast.FilterFile(src, f)
// 	return MakeBool(_res)
// }

GO FUNC go/ast.FilterPackage from go/ast/filter.go:
// func filterPackage(pkg *_ast.Package, f _ast.Filter)  {
// 	_res := _ast.FilterPackage(pkg, f)
// 	return MakeBool(_res)
// }

GO FUNC go/ast.Fprint from go/ast/print.go:
// func fprint(w io.Writer, fset *token.FileSet, x interface {}, f _ast.FieldFilter)  {
// 	_res := _ast.Fprint(w, fset, x, f)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.Inspect from go/ast/walk.go:
// func inspect(node _ast.Node, f func) Object {
// 	_ast.Inspect(node, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.MergePackageFiles from go/ast/filter.go:
// func mergePackageFiles(pkg *_ast.Package, mode _ast.MergeMode) Object {
// 	_res := _ast.MergePackageFiles(pkg, mode)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
// func newCommentMap(fset *token.FileSet, node _ast.Node, comments []*_ast.CommentGroup) Object {
// 	_res := _ast.NewCommentMap(fset, node, comments)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.NewIdent from go/ast/ast.go:
func newIdent(name string) Object {
	_res := _ast.NewIdent(name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewObj from go/ast/scope.go:
func newObj(kind _ast.ObjKind, name string) Object {
	_res := _ast.NewObj(kind, name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewPackage from go/ast/resolve.go:
// func newPackage(fset *token.FileSet, files map[], importer _ast.Importer, universe *_ast.Scope) Object {
// 	_res1, _res2 := _ast.NewPackage(fset, files, importer, universe)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/ast.NewScope from go/ast/scope.go:
// func newScope(outer *_ast.Scope) Object {
// 	_res := _ast.NewScope(outer)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.NotNilFilter from go/ast/print.go:
// func notNilFilter(_ string, v reflect.Value)  {
// 	_res := _ast.NotNilFilter(_, v)
// 	return MakeBool(_res)
// }

GO FUNC go/ast.PackageExports from go/ast/filter.go:
// func packageExports(pkg *_ast.Package)  {
// 	_res := _ast.PackageExports(pkg)
// 	return MakeBool(_res)
// }

GO FUNC go/ast.Print from go/ast/print.go:
// func _print(fset *token.FileSet, x interface {})  {
// 	_res := _ast.Print(fset, x)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.SortImports from go/ast/import.go:
// func sortImports(fset *token.FileSet, f *_ast.File) Object {
// 	_ast.SortImports(fset, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.Walk from go/ast/walk.go:
// func walk(v _ast.Visitor, node _ast.Node) Object {
// 	_ast.Walk(v, node)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ast

import (
	_ast "go/ast"
	. "github.com/candid82/joker/core"
)
GO FUNC go/build.ArchChar from go/build/build.go:
func archChar(goarch string) Object {
	_res1, _res2 := _build.ArchChar(goarch)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.Import from go/build/build.go:
func _import(path string, srcDir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.Import(path, srcDir, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.ImportDir from go/build/build.go:
func importDir(dir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.ImportDir(dir, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package build

import (
	_build "go/build"
	. "github.com/candid82/joker/core"
)
GO FUNC go/constant.BinaryOp from go/constant/value.go:
// func binaryOp(x_ _constant.Value, op token.Token, y_ _constant.Value) Object {
// 	_res := _constant.BinaryOp(x_, op, y_)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.Bytes from go/constant/value.go:
func bytes(x _constant.Value) Object {
	_res := _constant.Bytes(x)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC go/constant.Compare from go/constant/value.go:
// func compare(x_ _constant.Value, op token.Token, y_ _constant.Value)  {
// 	_res := _constant.Compare(x_, op, y_)
// 	return MakeBool(_res)
// }

GO FUNC go/constant.Denom from go/constant/value.go:
func denom(x _constant.Value) Object {
	_res := _constant.Denom(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Float32Val from go/constant/value.go:
// func float32Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float32Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.Float64Val from go/constant/value.go:
// func float64Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.Imag from go/constant/value.go:
func _imag(x _constant.Value) Object {
	_res := _constant.Imag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Int64Val from go/constant/value.go:
func int64Val(x _constant.Value) Object {
	_res1, _res2 := _constant.Int64Val(x)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeBool(_res2))
	return _res
}

GO FUNC go/constant.MakeBool from go/constant/value.go:
func makeBool(b bool) Object {
	_res := _constant.MakeBool(b)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeFloat64 from go/constant/value.go:
// func makeFloat64(x float64) Object {
// 	_res := _constant.MakeFloat64(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeFromBytes from go/constant/value.go:
// func makeFromBytes(bytes []byte) Object {
// 	_res := _constant.MakeFromBytes(bytes)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeFromLiteral from go/constant/value.go:
// func makeFromLiteral(lit string, tok token.Token, zero uint) Object {
// 	_res := _constant.MakeFromLiteral(lit, tok, zero)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeImag from go/constant/value.go:
func makeImag(x _constant.Value) Object {
	_res := _constant.MakeImag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeInt64 from go/constant/value.go:
func makeInt64(x int64) Object {
	_res := _constant.MakeInt64(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeString from go/constant/value.go:
func makeString(s string) Object {
	_res := _constant.MakeString(s)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeUint64 from go/constant/value.go:
// func makeUint64(x uint64) Object {
// 	_res := _constant.MakeUint64(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeUnknown from go/constant/value.go:
func makeUnknown() Object {
	_res := _constant.MakeUnknown()
	return MakeGoObject(_res)
}

GO FUNC go/constant.Num from go/constant/value.go:
func num(x _constant.Value) Object {
	_res := _constant.Num(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Real from go/constant/value.go:
func _real(x _constant.Value) Object {
	_res := _constant.Real(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Shift from go/constant/value.go:
// func shift(x _constant.Value, op token.Token, s uint) Object {
// 	_res := _constant.Shift(x, op, s)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.ToComplex from go/constant/value.go:
func toComplex(x _constant.Value) Object {
	_res := _constant.ToComplex(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToFloat from go/constant/value.go:
func toFloat(x _constant.Value) Object {
	_res := _constant.ToFloat(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToInt from go/constant/value.go:
func toInt(x _constant.Value) Object {
	_res := _constant.ToInt(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Uint64Val from go/constant/value.go:
// func uint64Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Uint64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.UnaryOp from go/constant/value.go:
// func unaryOp(op token.Token, y _constant.Value, prec uint) Object {
// 	_res := _constant.UnaryOp(op, y, prec)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package constant

import (
	_constant "go/constant"
	. "github.com/candid82/joker/core"
)
GO FUNC go/doc.Examples from go/doc/example.go:
// func examples(files ...*ast.File) Object {
// 	_res := _doc.Examples(files)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC go/doc.New from go/doc/doc.go:
// func _new(pkg *ast.Package, importPath string, mode _doc.Mode) Object {
// 	_res := _doc.New(pkg, importPath, mode)
// 	return MakeGoObject(_res)
// }

GO FUNC go/doc.ToHTML from go/doc/comment.go:
// func toHTML(w io.Writer, text string, words map[]) Object {
// 	_doc.ToHTML(w, text, words)
// 	...ABEND675: TODO...
// }

GO FUNC go/doc.ToText from go/doc/comment.go:
// func toText(w io.Writer, text string, indent string, preIndent string, width int) Object {
// 	_doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package doc

import (
)
GO FUNC go/format.Node from go/format/format.go:
// func node(dst io.Writer, fset *token.FileSet, node interface {})  {
// 	_res := _format.Node(dst, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/format.Source from go/format/format.go:
// func source(src []byte) Object {
// 	_res1, _res2 := _format.Source(src)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/importer.Default from go/importer/importer.go:
func _default() Object {
	_res := _importer.Default()
	return MakeGoObject(_res)
}

GO FUNC go/importer.For from go/importer/importer.go:
func _for(compiler string, lookup _importer.Lookup) Object {
	_res := _importer.For(compiler, lookup)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package importer

import (
	_importer "go/importer"
	. "github.com/candid82/joker/core"
)
GO FUNC go/parser.ParseDir from go/parser/interface.go:
// func parseDir(fset *token.FileSet, path string, filter func, mode _parser.Mode) Object {
// 	pkgs, first := _parser.ParseDir(fset, path, filter, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pkgs)
// 	_res = _res.Conjoin(func () Object { if (first) == nil { return NIL } else { return MakeError(first) } }())
// 	return _res
// }

GO FUNC go/parser.ParseExpr from go/parser/interface.go:
func parseExpr(x string) Object {
	_res1, _res2 := _parser.ParseExpr(x)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/parser.ParseExprFrom from go/parser/interface.go:
// func parseExprFrom(fset *token.FileSet, filename string, src interface {}, mode _parser.Mode) Object {
// 	_res1, _res2 := _parser.ParseExprFrom(fset, filename, src, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/parser.ParseFile from go/parser/interface.go:
// func parseFile(fset *token.FileSet, filename string, src interface {}, mode _parser.Mode) Object {
// 	f, err := _parser.ParseFile(fset, filename, src, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(f))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parser

import (
	_parser "go/parser"
	. "github.com/candid82/joker/core"
)
GO FUNC go/printer.Fprint from go/printer/printer.go:
// func fprint(output io.Writer, fset *token.FileSet, node interface {})  {
// 	_res := _printer.Fprint(output, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/scanner.PrintError from go/scanner/errors.go:
// func printError(w io.Writer, err error) Object {
// 	_scanner.PrintError(w, err)
// 	...ABEND675: TODO...
// }

GO FUNC go/token.Lookup from go/token/token.go:
func lookup(ident string) Object {
	_res := _token.Lookup(ident)
	return MakeGoObject(_res)
}

GO FUNC go/token.NewFileSet from go/token/position.go:
func newFileSet() Object {
	_res := _token.NewFileSet()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package token

import (
	_token "go/token"
	. "github.com/candid82/joker/core"
)
GO FUNC go/types.AssertableTo from go/types/api.go:
// func assertableTo(V *_types.Interface, T _types.Type)  {
// 	_res := _types.AssertableTo(V, T)
// 	return MakeBool(_res)
// }

GO FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
// func defPredeclaredTestFuncs() Object {
// 	_types.DefPredeclaredTestFuncs()
// 	...ABEND675: TODO...
// }

GO FUNC go/types.Default from go/types/predicates.go:
func _default(typ _types.Type) Object {
	_res := _types.Default(typ)
	return MakeGoObject(_res)
}

GO FUNC go/types.Eval from go/types/eval.go:
// func eval(fset *token.FileSet, pkg *_types.Package, pos token.Pos, expr string) Object {
// 	_, err := _types.Eval(fset, pkg, pos, expr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/types.ExprString from go/types/exprstring.go:
// func exprString(x ast.Expr)  {
// 	_res := _types.ExprString(x)
// 	return MakeString(_res)
// }

GO FUNC go/types.Id from go/types/object.go:
// func id(pkg *_types.Package, name string)  {
// 	_res := _types.Id(pkg, name)
// 	return MakeString(_res)
// }

GO FUNC go/types.Implements from go/types/api.go:
// func implements(V _types.Type, T *_types.Interface)  {
// 	_res := _types.Implements(V, T)
// 	return MakeBool(_res)
// }

GO FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
// func lookupFieldOrMethod(T _types.Type, addressable bool, pkg *_types.Package, name string) Object {
// 	obj, index, indirect := _types.LookupFieldOrMethod(T, addressable, pkg, name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(obj))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range index {
// 		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(MakeBool(indirect))
// 	return _res
// }

GO FUNC go/types.MissingMethod from go/types/lookup.go:
// func missingMethod(V _types.Type, T *_types.Interface, static bool) Object {
// 	method, wrongType := _types.MissingMethod(V, T, static)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(method))
// 	_res = _res.Conjoin(MakeBool(wrongType))
// 	return _res
// }

GO FUNC go/types.NewArray from go/types/type.go:
func newArray(elem _types.Type, len int64) Object {
	_res := _types.NewArray(elem, len)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChan from go/types/type.go:
func newChan(dir _types.ChanDir, elem _types.Type) Object {
	_res := _types.NewChan(dir, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChecker from go/types/check.go:
// func newChecker(conf *_types.Config, fset *token.FileSet, pkg *_types.Package, info *_types.Info) Object {
// 	_res := _types.NewChecker(conf, fset, pkg, info)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewConst from go/types/object.go:
// func newConst(pos token.Pos, pkg *_types.Package, name string, typ _types.Type, val constant.Value) Object {
// 	_res := _types.NewConst(pos, pkg, name, typ, val)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewField from go/types/object.go:
// func newField(pos token.Pos, pkg *_types.Package, name string, typ _types.Type, embedded bool) Object {
// 	_res := _types.NewField(pos, pkg, name, typ, embedded)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewFunc from go/types/object.go:
// func newFunc(pos token.Pos, pkg *_types.Package, name string, sig *_types.Signature) Object {
// 	_res := _types.NewFunc(pos, pkg, name, sig)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterface from go/types/type.go:
// func newInterface(methods []*_types.Func, embeddeds []*_types.Named) Object {
// 	_res := _types.NewInterface(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterfaceType from go/types/type.go:
// func newInterfaceType(methods []*_types.Func, embeddeds []_types.Type) Object {
// 	_res := _types.NewInterfaceType(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewLabel from go/types/object.go:
// func newLabel(pos token.Pos, pkg *_types.Package, name string) Object {
// 	_res := _types.NewLabel(pos, pkg, name)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewMap from go/types/type.go:
func newMap(key _types.Type, elem _types.Type) Object {
	_res := _types.NewMap(key, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewMethodSet from go/types/methodset.go:
func newMethodSet(T _types.Type) Object {
	_res := _types.NewMethodSet(T)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewNamed from go/types/type.go:
// func newNamed(obj *_types.TypeName, underlying _types.Type, methods []*_types.Func) Object {
// 	_res := _types.NewNamed(obj, underlying, methods)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPackage from go/types/package.go:
func newPackage(path string, name string) Object {
	_res := _types.NewPackage(path, name)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewParam from go/types/object.go:
// func newParam(pos token.Pos, pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewParam(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPkgName from go/types/object.go:
// func newPkgName(pos token.Pos, pkg *_types.Package, name string, imported *_types.Package) Object {
// 	_res := _types.NewPkgName(pos, pkg, name, imported)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPointer from go/types/type.go:
func newPointer(elem _types.Type) Object {
	_res := _types.NewPointer(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewScope from go/types/scope.go:
// func newScope(parent *_types.Scope, pos token.Pos, end token.Pos, comment string) Object {
// 	_res := _types.NewScope(parent, pos, end, comment)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewSignature from go/types/type.go:
// func newSignature(recv *_types.Var, params *_types.Tuple, results *_types.Tuple, variadic bool) Object {
// 	_res := _types.NewSignature(recv, params, results, variadic)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewSlice from go/types/type.go:
func newSlice(elem _types.Type) Object {
	_res := _types.NewSlice(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewStruct from go/types/type.go:
// func newStruct(fields []*_types.Var, tags []string) Object {
// 	_res := _types.NewStruct(fields, tags)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTuple from go/types/type.go:
// func newTuple(x ...*_types.Var) Object {
// 	_res := _types.NewTuple(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTypeName from go/types/object.go:
// func newTypeName(pos token.Pos, pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewTypeName(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewVar from go/types/object.go:
// func newVar(pos token.Pos, pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewVar(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.RelativeTo from go/types/typestring.go:
// func relativeTo(pkg *_types.Package) Object {
// 	_res := _types.RelativeTo(pkg)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.SelectionString from go/types/selection.go:
// func selectionString(s *_types.Selection, qf _types.Qualifier)  {
// 	_res := _types.SelectionString(s, qf)
// 	return MakeString(_res)
// }

GO FUNC go/types.SizesFor from go/types/sizes.go:
func sizesFor(compiler string, arch string) Object {
	_res := _types.SizesFor(compiler, arch)
	return MakeGoObject(_res)
}

GO FUNC go/types.WriteExpr from go/types/exprstring.go:
// func writeExpr(buf *bytes.Buffer, x ast.Expr) Object {
// 	_types.WriteExpr(buf, x)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteSignature from go/types/typestring.go:
// func writeSignature(buf *bytes.Buffer, sig *_types.Signature, qf _types.Qualifier) Object {
// 	_types.WriteSignature(buf, sig, qf)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteType from go/types/typestring.go:
// func writeType(buf *bytes.Buffer, typ _types.Type, qf _types.Qualifier) Object {
// 	_types.WriteType(buf, typ, qf)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package types

import (
	_types "go/types"
	. "github.com/candid82/joker/core"
)
GO FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
// func checksum(data []byte) Object {
// 	_res := _adler32.Checksum(data)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/adler32.New from hash/adler32/adler32.go:
func _new() Object {
	_res := _adler32.New()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package adler32

import (
	_adler32 "hash/adler32"
	. "github.com/candid82/joker/core"
)
GO FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
// func checksum(data []byte, tab *_crc32.Table) Object {
// 	_res := _crc32.Checksum(data, tab)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
// func checksumIEEE(data []byte) Object {
// 	_res := _crc32.ChecksumIEEE(data)
// 	return MakeInt(int(_res))
// }

GO FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
func makeTable(poly uint32) Object {
	_res := _crc32.MakeTable(poly)
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.New from hash/crc32/crc32.go:
// func _new(tab *_crc32.Table) Object {
// 	_res := _crc32.New(tab)
// 	return MakeGoObject(_res)
// }

GO FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
func newIEEE() Object {
	_res := _crc32.NewIEEE()
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.Update from hash/crc32/crc32.go:
// func update(crc uint32, tab *_crc32.Table, p []byte) Object {
// 	_res := _crc32.Update(crc, tab, p)
// 	return MakeInt(int(_res))
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crc32

import (
	_crc32 "hash/crc32"
	. "github.com/candid82/joker/core"
)
GO FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
// func checksum(data []byte, tab *_crc64.Table) Object {
// 	return _crc64.Checksum(data, tab)
// }

GO FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
// func makeTable(poly uint64) Object {
// 	_res := _crc64.MakeTable(poly)
// 	return MakeGoObject(_res)
// }

GO FUNC hash/crc64.New from hash/crc64/crc64.go:
// func _new(tab *_crc64.Table) Object {
// 	_res := _crc64.New(tab)
// 	return MakeGoObject(_res)
// }

GO FUNC hash/crc64.Update from hash/crc64/crc64.go:
// func update(crc uint64, tab *_crc64.Table, p []byte) Object {
// 	return _crc64.Update(crc, tab, p)
// }

GO FUNC hash/fnv.New128 from hash/fnv/fnv.go:
func new128() Object {
	_res := _fnv.New128()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New128a from hash/fnv/fnv.go:
func new128a() Object {
	_res := _fnv.New128a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32 from hash/fnv/fnv.go:
func new32() Object {
	_res := _fnv.New32()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32a from hash/fnv/fnv.go:
func new32a() Object {
	_res := _fnv.New32a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64 from hash/fnv/fnv.go:
func new64() Object {
	_res := _fnv.New64()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64a from hash/fnv/fnv.go:
func new64a() Object {
	_res := _fnv.New64a()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package fnv

import (
	_fnv "hash/fnv"
	. "github.com/candid82/joker/core"
)
// Auto-generated by gostd at (omitted for testing), do not edit!!

package html

import (
)
GO FUNC html/template.HTMLEscape from html/template/escape.go:
// func hTMLEscape(w io.Writer, b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.HTMLEscaper from html/template/escape.go:
// func hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.IsTrue from html/template/template.go:
// func isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(truth))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC html/template.JSEscape from html/template/escape.go:
// func jSEscape(w io.Writer, b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.JSEscaper from html/template/escape.go:
// func jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.Must from html/template/template.go:
// func must(t *_template.Template, err error) Object {
// 	_res := _template.Must(t, err)
// 	return MakeGoObject(_res)
// }

GO FUNC html/template.New from html/template/template.go:
func _new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC html/template.ParseFiles from html/template/template.go:
// func parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC html/template.ParseGlob from html/template/template.go:
func parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.URLQueryEscaper from html/template/escape.go:
// func uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	_template "html/template"
	. "github.com/candid82/joker/core"
)
GO FUNC image.Decode from image/format.go:
// func decode(r io.Reader) Object {
// 	_res1, _res2, _res3 := _image.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.DecodeConfig from image/format.go:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2, _res3 := _image.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.NewAlpha from image/image.go:
func newAlpha(r _image.Rectangle) Object {
	_res := _image.NewAlpha(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewAlpha16 from image/image.go:
func newAlpha16(r _image.Rectangle) Object {
	_res := _image.NewAlpha16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewCMYK from image/image.go:
func newCMYK(r _image.Rectangle) Object {
	_res := _image.NewCMYK(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray from image/image.go:
func newGray(r _image.Rectangle) Object {
	_res := _image.NewGray(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray16 from image/image.go:
func newGray16(r _image.Rectangle) Object {
	_res := _image.NewGray16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA from image/image.go:
func newNRGBA(r _image.Rectangle) Object {
	_res := _image.NewNRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA64 from image/image.go:
func newNRGBA64(r _image.Rectangle) Object {
	_res := _image.NewNRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNYCbCrA from image/ycbcr.go:
func newNYCbCrA(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewNYCbCrA(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.NewPaletted from image/image.go:
// func newPaletted(r _image.Rectangle, p color.Palette) Object {
// 	_res := _image.NewPaletted(r, p)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewRGBA from image/image.go:
func newRGBA(r _image.Rectangle) Object {
	_res := _image.NewRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewRGBA64 from image/image.go:
func newRGBA64(r _image.Rectangle) Object {
	_res := _image.NewRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewUniform from image/names.go:
// func newUniform(c color.Color) Object {
// 	_res := _image.NewUniform(c)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewYCbCr from image/ycbcr.go:
func newYCbCr(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewYCbCr(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.Pt from image/geom.go:
func pt(X int, Y int) Object {
	_res := _image.Pt(X, Y)
	return MakeGoObject(_res)
}

GO FUNC image.Rect from image/geom.go:
func rect(x0 int, y0 int, x1 int, y1 int) Object {
	_res := _image.Rect(x0, y0, x1, y1)
	return MakeGoObject(_res)
}

GO FUNC image.RegisterFormat from image/format.go:
// func registerFormat(name string, magic string, decode func, decodeConfig func) Object {
// 	_image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package image

import (
	_image "image"
	. "github.com/candid82/joker/core"
)
GO FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
// func cMYKToRGB(c uint8, m uint8, y uint8, k uint8) Object {
// 	_res1, _res2, _res3 := _color.CMYKToRGB(c, m, y, k)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.ModelFunc from image/color/color.go:
// func modelFunc(f func) Object {
// 	_res := _color.ModelFunc(f)
// 	return MakeGoObject(_res)
// }

GO FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
// func rGBToCMYK(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3, _res4 := _color.RGBToCMYK(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	_res = _res.Conjoin(_res4)
// 	return _res
// }

GO FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
// func rGBToYCbCr(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3 := _color.RGBToYCbCr(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
// func yCbCrToRGB(y uint8, cb uint8, cr uint8) Object {
// 	_res1, _res2, _res3 := _color.YCbCrToRGB(y, cb, cr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/draw.Draw from image/draw/draw.go:
// func draw(dst _draw.Image, r image.Rectangle, src image.Image, sp image.Point, op _draw.Op) Object {
// 	_draw.Draw(dst, r, src, sp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/draw.DrawMask from image/draw/draw.go:
// func drawMask(dst _draw.Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op _draw.Op) Object {
// 	_draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/gif.Decode from image/gif/reader.go:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _gif.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeAll from image/gif/reader.go:
// func decodeAll(r io.Reader) Object {
// 	_res1, _res2 := _gif.DecodeAll(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeConfig from image/gif/reader.go:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _gif.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.Encode from image/gif/writer.go:
// func encode(w io.Writer, m image.Image, o *_gif.Options)  {
// 	_res := _gif.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/gif.EncodeAll from image/gif/writer.go:
// func encodeAll(w io.Writer, g *_gif.GIF)  {
// 	_res := _gif.EncodeAll(w, g)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/jpeg.Decode from image/jpeg/reader.go:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _jpeg.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _jpeg.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.Encode from image/jpeg/writer.go:
// func encode(w io.Writer, m image.Image, o *_jpeg.Options)  {
// 	_res := _jpeg.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/png.Decode from image/png/reader.go:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _png.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.DecodeConfig from image/png/reader.go:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _png.DecodeConfig(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.Encode from image/png/writer.go:
// func encode(w io.Writer, m image.Image)  {
// 	_res := _png.Encode(w, m)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
// func _new(data []byte) Object {
// 	_res := _suffixarray.New(data)
// 	return MakeGoObject(_res)
// }

GO FUNC io.Copy from io/io.go:
func _copy(dst _io.Writer, src _io.Reader) Object {
	written, err := _io.Copy(dst, src)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(written)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.CopyBuffer from io/io.go:
// func copyBuffer(dst _io.Writer, src _io.Reader, buf []byte) Object {
// 	written, err := _io.CopyBuffer(dst, src, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(written)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.CopyN from io/io.go:
func copyN(dst _io.Writer, src _io.Reader, n int64) Object {
	written, err := _io.CopyN(dst, src, n)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(written)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.LimitReader from io/io.go:
func limitReader(r _io.Reader, n int64) Object {
	_res := _io.LimitReader(r, n)
	return MakeGoObject(_res)
}

GO FUNC io.MultiReader from io/multi.go:
// func multiReader(readers ..._io.Reader) Object {
// 	_res := _io.MultiReader(readers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.MultiWriter from io/multi.go:
// func multiWriter(writers ..._io.Writer) Object {
// 	_res := _io.MultiWriter(writers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.NewSectionReader from io/io.go:
func newSectionReader(r _io.ReaderAt, off int64, n int64) Object {
	_res := _io.NewSectionReader(r, off, n)
	return MakeGoObject(_res)
}

GO FUNC io.Pipe from io/pipe.go:
func pipe() Object {
	_res1, _res2 := _io.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC io.ReadAtLeast from io/io.go:
// func readAtLeast(r _io.Reader, buf []byte, min int) Object {
// 	n, err := _io.ReadAtLeast(r, buf, min)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.ReadFull from io/io.go:
// func readFull(r _io.Reader, buf []byte) Object {
// 	n, err := _io.ReadFull(r, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.TeeReader from io/io.go:
func teeReader(r _io.Reader, w _io.Writer) Object {
	_res := _io.TeeReader(r, w)
	return MakeGoObject(_res)
}

GO FUNC io.WriteString from io/io.go:
func writeString(w _io.Writer, s string) Object {
	n, err := _io.WriteString(w, s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package io

import (
	_io "io"
	. "github.com/candid82/joker/core"
)
GO FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
// func nopCloser(r io.Reader) Object {
// 	_res := _ioutil.NopCloser(r)
// 	return MakeGoObject(_res)
// }

GO FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
// func readAll(r io.Reader) Object {
// 	_res1, _res2 := _ioutil.ReadAll(r)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
func readDir(dirname string) Object {
	_res1, _res2 := _ioutil.ReadDir(dirname)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
func readFile(filename string) Object {
	_res1, _res2 := _ioutil.ReadFile(filename)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
func tempDir(dir string, prefix string) Object {
	name, err := _ioutil.TempDir(dir, prefix)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
func tempFile(dir string, pattern string) Object {
	f, err := _ioutil.TempFile(dir, pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
// func writeFile(filename string, data []byte, perm os.FileMode)  {
// 	_res := _ioutil.WriteFile(filename, data, perm)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ioutil

import (
	_ioutil "io/ioutil"
	. "github.com/candid82/joker/core"
)
GO FUNC log.Fatal from log/log.go:
// func fatal(v ...interface {}) Object {
// 	_log.Fatal(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalf from log/log.go:
// func fatalf(format string, v ...interface {}) Object {
// 	_log.Fatalf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalln from log/log.go:
// func fatalln(v ...interface {}) Object {
// 	_log.Fatalln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.New from log/log.go:
// func _new(out io.Writer, prefix string, flag int) Object {
// 	_res := _log.New(out, prefix, flag)
// 	return MakeGoObject(_res)
// }

GO FUNC log.Panic from log/log.go:
// func _panic(v ...interface {}) Object {
// 	_log.Panic(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicf from log/log.go:
// func panicf(format string, v ...interface {}) Object {
// 	_log.Panicf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicln from log/log.go:
// func panicln(v ...interface {}) Object {
// 	_log.Panicln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Print from log/log.go:
// func _print(v ...interface {}) Object {
// 	_log.Print(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Printf from log/log.go:
// func printf(format string, v ...interface {}) Object {
// 	_log.Printf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Println from log/log.go:
// func _println(v ...interface {}) Object {
// 	_log.Println(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetFlags from log/log.go:
// func setFlags(flag int) Object {
// 	_log.SetFlags(flag)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetOutput from log/log.go:
// func setOutput(w io.Writer) Object {
// 	_log.SetOutput(w)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetPrefix from log/log.go:
// func setPrefix(prefix string) Object {
// 	_log.SetPrefix(prefix)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package log

import (
)
GO FUNC log/syslog.Dial from log/syslog/syslog.go:
func dial(network string, raddr string, priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.Dial(network, raddr, priority, tag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.New from log/syslog/syslog.go:
func _new(priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.New(priority, tag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.NewLogger from log/syslog/syslog.go:
func newLogger(p _syslog.Priority, logFlag int) Object {
	_res1, _res2 := _syslog.NewLogger(p, logFlag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syslog

import (
	_syslog "log/syslog"
	. "github.com/candid82/joker/core"
)
GO FUNC math.Abs from math/abs.go:
// func abs(x float64) Object {
// 	return _math.Abs(x)
// }

GO FUNC math.Acos from math/asin.go:
// func acos(x float64) Object {
// 	return _math.Acos(x)
// }

GO FUNC math.Acosh from math/acosh.go:
// func acosh(x float64) Object {
// 	return _math.Acosh(x)
// }

GO FUNC math.Asin from math/asin.go:
// func asin(x float64) Object {
// 	return _math.Asin(x)
// }

GO FUNC math.Asinh from math/asinh.go:
// func asinh(x float64) Object {
// 	return _math.Asinh(x)
// }

GO FUNC math.Atan from math/atan.go:
// func atan(x float64) Object {
// 	return _math.Atan(x)
// }

GO FUNC math.Atan2 from math/atan2.go:
// func atan2(y float64, x float64) Object {
// 	return _math.Atan2(y, x)
// }

GO FUNC math.Atanh from math/atanh.go:
// func atanh(x float64) Object {
// 	return _math.Atanh(x)
// }

GO FUNC math.Cbrt from math/cbrt.go:
// func cbrt(x float64) Object {
// 	return _math.Cbrt(x)
// }

GO FUNC math.Ceil from math/floor.go:
// func ceil(x float64) Object {
// 	return _math.Ceil(x)
// }

GO FUNC math.Copysign from math/copysign.go:
// func copysign(x float64, y float64) Object {
// 	return _math.Copysign(x, y)
// }

GO FUNC math.Cos from math/sin.go:
// func cos(x float64) Object {
// 	return _math.Cos(x)
// }

GO FUNC math.Cosh from math/sinh.go:
// func cosh(x float64) Object {
// 	return _math.Cosh(x)
// }

GO FUNC math.Dim from math/dim.go:
// func dim(x float64, y float64) Object {
// 	return _math.Dim(x, y)
// }

GO FUNC math.Erf from math/erf.go:
// func erf(x float64) Object {
// 	return _math.Erf(x)
// }

GO FUNC math.Erfc from math/erf.go:
// func erfc(x float64) Object {
// 	return _math.Erfc(x)
// }

GO FUNC math.Erfcinv from math/erfinv.go:
// func erfcinv(x float64) Object {
// 	return _math.Erfcinv(x)
// }

GO FUNC math.Erfinv from math/erfinv.go:
// func erfinv(x float64) Object {
// 	return _math.Erfinv(x)
// }

GO FUNC math.Exp from math/exp.go:
// func exp(x float64) Object {
// 	return _math.Exp(x)
// }

GO FUNC math.Exp2 from math/exp.go:
// func exp2(x float64) Object {
// 	return _math.Exp2(x)
// }

GO FUNC math.Expm1 from math/expm1.go:
// func expm1(x float64) Object {
// 	return _math.Expm1(x)
// }

GO FUNC math.Float32bits from math/unsafe.go:
// func float32bits(f float32) Object {
// 	_res := _math.Float32bits(f)
// 	return MakeInt(int(_res))
// }

GO FUNC math.Float32frombits from math/unsafe.go:
// func float32frombits(b uint32) Object {
// 	return _math.Float32frombits(b)
// }

GO FUNC math.Float64bits from math/unsafe.go:
// func float64bits(f float64) Object {
// 	return _math.Float64bits(f)
// }

GO FUNC math.Float64frombits from math/unsafe.go:
// func float64frombits(b uint64) Object {
// 	return _math.Float64frombits(b)
// }

GO FUNC math.Floor from math/floor.go:
// func floor(x float64) Object {
// 	return _math.Floor(x)
// }

GO FUNC math.Frexp from math/frexp.go:
// func frexp(f float64) Object {
// 	frac, exp := _math.Frexp(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(frac)
// 	_res = _res.Conjoin(MakeInt(exp))
// 	return _res
// }

GO FUNC math.Gamma from math/gamma.go:
// func gamma(x float64) Object {
// 	return _math.Gamma(x)
// }

GO FUNC math.Hypot from math/hypot.go:
// func hypot(p float64, q float64) Object {
// 	return _math.Hypot(p, q)
// }

GO FUNC math.Ilogb from math/logb.go:
// func ilogb(x float64)  {
// 	_res := _math.Ilogb(x)
// 	return MakeInt(_res)
// }

GO FUNC math.Inf from math/bits.go:
// func inf(sign int) Object {
// 	return _math.Inf(sign)
// }

GO FUNC math.IsInf from math/bits.go:
// func isInf(f float64, sign int)  {
// 	_res := _math.IsInf(f, sign)
// 	return MakeBool(_res)
// }

GO FUNC math.IsNaN from math/bits.go:
// func isNaN(f float64)  {
// 	_res := _math.IsNaN(f)
// 	return MakeBool(_res)
// }

GO FUNC math.J0 from math/j0.go:
// func j0(x float64) Object {
// 	return _math.J0(x)
// }

GO FUNC math.J1 from math/j1.go:
// func j1(x float64) Object {
// 	return _math.J1(x)
// }

GO FUNC math.Jn from math/jn.go:
// func jn(n int, x float64) Object {
// 	return _math.Jn(n, x)
// }

GO FUNC math.Ldexp from math/ldexp.go:
// func ldexp(frac float64, exp int) Object {
// 	return _math.Ldexp(frac, exp)
// }

GO FUNC math.Lgamma from math/lgamma.go:
// func lgamma(x float64) Object {
// 	lgamma, sign := _math.Lgamma(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(lgamma)
// 	_res = _res.Conjoin(MakeInt(sign))
// 	return _res
// }

GO FUNC math.Log from math/log.go:
// func log(x float64) Object {
// 	return _math.Log(x)
// }

GO FUNC math.Log10 from math/log10.go:
// func log10(x float64) Object {
// 	return _math.Log10(x)
// }

GO FUNC math.Log1p from math/log1p.go:
// func log1p(x float64) Object {
// 	return _math.Log1p(x)
// }

GO FUNC math.Log2 from math/log10.go:
// func log2(x float64) Object {
// 	return _math.Log2(x)
// }

GO FUNC math.Logb from math/logb.go:
// func logb(x float64) Object {
// 	return _math.Logb(x)
// }

GO FUNC math.Max from math/dim.go:
// func max(x float64, y float64) Object {
// 	return _math.Max(x, y)
// }

GO FUNC math.Min from math/dim.go:
// func min(x float64, y float64) Object {
// 	return _math.Min(x, y)
// }

GO FUNC math.Mod from math/mod.go:
// func mod(x float64, y float64) Object {
// 	return _math.Mod(x, y)
// }

GO FUNC math.Modf from math/modf.go:
// func modf(f float64) Object {
// 	int, frac := _math.Modf(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(int)
// 	_res = _res.Conjoin(frac)
// 	return _res
// }

GO FUNC math.NaN from math/bits.go:
// func naN() Object {
// 	return _math.NaN()
// }

GO FUNC math.Nextafter from math/nextafter.go:
// func nextafter(x float64, y float64) Object {
// 	return _math.Nextafter(x, y)
// }

GO FUNC math.Nextafter32 from math/nextafter.go:
// func nextafter32(x float32, y float32) Object {
// 	return _math.Nextafter32(x, y)
// }

GO FUNC math.Pow from math/pow.go:
// func pow(x float64, y float64) Object {
// 	return _math.Pow(x, y)
// }

GO FUNC math.Pow10 from math/pow10.go:
// func pow10(n int) Object {
// 	return _math.Pow10(n)
// }

GO FUNC math.Remainder from math/remainder.go:
// func remainder(x float64, y float64) Object {
// 	return _math.Remainder(x, y)
// }

GO FUNC math.Round from math/floor.go:
// func round(x float64) Object {
// 	return _math.Round(x)
// }

GO FUNC math.RoundToEven from math/floor.go:
// func roundToEven(x float64) Object {
// 	return _math.RoundToEven(x)
// }

GO FUNC math.Signbit from math/signbit.go:
// func signbit(x float64)  {
// 	_res := _math.Signbit(x)
// 	return MakeBool(_res)
// }

GO FUNC math.Sin from math/sin.go:
// func sin(x float64) Object {
// 	return _math.Sin(x)
// }

GO FUNC math.Sincos from math/sincos.go:
// func sincos(x float64) Object {
// 	sin, cos := _math.Sincos(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(sin)
// 	_res = _res.Conjoin(cos)
// 	return _res
// }

GO FUNC math.Sinh from math/sinh.go:
// func sinh(x float64) Object {
// 	return _math.Sinh(x)
// }

GO FUNC math.Sqrt from math/sqrt.go:
// func sqrt(x float64) Object {
// 	return _math.Sqrt(x)
// }

GO FUNC math.Tan from math/tan.go:
// func tan(x float64) Object {
// 	return _math.Tan(x)
// }

GO FUNC math.Tanh from math/tanh.go:
// func tanh(x float64) Object {
// 	return _math.Tanh(x)
// }

GO FUNC math.Trunc from math/floor.go:
// func trunc(x float64) Object {
// 	return _math.Trunc(x)
// }

GO FUNC math.Y0 from math/j0.go:
// func y0(x float64) Object {
// 	return _math.Y0(x)
// }

GO FUNC math.Y1 from math/j1.go:
// func y1(x float64) Object {
// 	return _math.Y1(x)
// }

GO FUNC math.Yn from math/jn.go:
// func yn(n int, x float64) Object {
// 	return _math.Yn(n, x)
// }

GO FUNC math/big.Jacobi from math/big/int.go:
// func jacobi(x *_big.Int, y *_big.Int)  {
// 	_res := _big.Jacobi(x, y)
// 	return MakeInt(_res)
// }

GO FUNC math/big.NewFloat from math/big/float.go:
// func newFloat(x float64) Object {
// 	_res := _big.NewFloat(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.NewInt from math/big/int.go:
func newInt(x int64) Object {
	_res := _big.NewInt(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.NewRat from math/big/rat.go:
func newRat(a int64, b int64) Object {
	_res := _big.NewRat(a, b)
	return MakeGoObject(_res)
}

GO FUNC math/big.ParseFloat from math/big/floatconv.go:
func parseFloat(s string, base int, prec uint, mode _big.RoundingMode) Object {
	f, b, err := _big.ParseFloat(s, base, prec, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(MakeInt(b))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package big

import (
	_big "math/big"
	. "github.com/candid82/joker/core"
)
GO FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
// func leadingZeros64(x uint64)  {
// 	_res := _bits.LeadingZeros64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
// func leadingZeros8(x uint8)  {
// 	_res := _bits.LeadingZeros8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Len64 from math/bits/bits.go:
// func len64(x uint64)  {
// 	_res := _bits.Len64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Len8 from math/bits/bits.go:
// func len8(x uint8)  {
// 	_res := _bits.Len8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.OnesCount64 from math/bits/bits.go:
// func onesCount64(x uint64)  {
// 	_res := _bits.OnesCount64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.OnesCount8 from math/bits/bits.go:
// func onesCount8(x uint8)  {
// 	_res := _bits.OnesCount8(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.Reverse from math/bits/bits.go:
func reverse(x uint) Object {
	_res := _bits.Reverse(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse16 from math/bits/bits.go:
func reverse16(x uint16) Object {
	_res := _bits.Reverse16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse32 from math/bits/bits.go:
func reverse32(x uint32) Object {
	_res := _bits.Reverse32(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse64 from math/bits/bits.go:
// func reverse64(x uint64) Object {
// 	return _bits.Reverse64(x)
// }

GO FUNC math/bits.Reverse8 from math/bits/bits.go:
// func reverse8(x uint8) Object {
// 	return _bits.Reverse8(x)
// }

GO FUNC math/bits.ReverseBytes from math/bits/bits.go:
func reverseBytes(x uint) Object {
	_res := _bits.ReverseBytes(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
func reverseBytes16(x uint16) Object {
	_res := _bits.ReverseBytes16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
func reverseBytes32(x uint32) Object {
	_res := _bits.ReverseBytes32(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
// func reverseBytes64(x uint64) Object {
// 	return _bits.ReverseBytes64(x)
// }

GO FUNC math/bits.RotateLeft from math/bits/bits.go:
func rotateLeft(x uint, k int) Object {
	_res := _bits.RotateLeft(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft16 from math/bits/bits.go:
func rotateLeft16(x uint16, k int) Object {
	_res := _bits.RotateLeft16(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft32 from math/bits/bits.go:
func rotateLeft32(x uint32, k int) Object {
	_res := _bits.RotateLeft32(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft64 from math/bits/bits.go:
// func rotateLeft64(x uint64, k int) Object {
// 	return _bits.RotateLeft64(x, k)
// }

GO FUNC math/bits.RotateLeft8 from math/bits/bits.go:
// func rotateLeft8(x uint8, k int) Object {
// 	return _bits.RotateLeft8(x, k)
// }

GO FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
// func trailingZeros64(x uint64)  {
// 	_res := _bits.TrailingZeros64(x)
// 	return MakeInt(_res)
// }

GO FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
// func trailingZeros8(x uint8)  {
// 	_res := _bits.TrailingZeros8(x)
// 	return MakeInt(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bits

import (
	_bits "math/bits"
	. "github.com/candid82/joker/core"
)
GO FUNC math/cmplx.Abs from math/cmplx/abs.go:
// func abs(x complex128) Object {
// 	return _cmplx.Abs(x)
// }

GO FUNC math/cmplx.Acos from math/cmplx/asin.go:
// func acos(x complex128) Object {
// 	return _cmplx.Acos(x)
// }

GO FUNC math/cmplx.Acosh from math/cmplx/asin.go:
// func acosh(x complex128) Object {
// 	return _cmplx.Acosh(x)
// }

GO FUNC math/cmplx.Asin from math/cmplx/asin.go:
// func asin(x complex128) Object {
// 	return _cmplx.Asin(x)
// }

GO FUNC math/cmplx.Asinh from math/cmplx/asin.go:
// func asinh(x complex128) Object {
// 	return _cmplx.Asinh(x)
// }

GO FUNC math/cmplx.Atan from math/cmplx/asin.go:
// func atan(x complex128) Object {
// 	return _cmplx.Atan(x)
// }

GO FUNC math/cmplx.Atanh from math/cmplx/asin.go:
// func atanh(x complex128) Object {
// 	return _cmplx.Atanh(x)
// }

GO FUNC math/cmplx.Conj from math/cmplx/conj.go:
// func conj(x complex128) Object {
// 	return _cmplx.Conj(x)
// }

GO FUNC math/cmplx.Cos from math/cmplx/sin.go:
// func cos(x complex128) Object {
// 	return _cmplx.Cos(x)
// }

GO FUNC math/cmplx.Cosh from math/cmplx/sin.go:
// func cosh(x complex128) Object {
// 	return _cmplx.Cosh(x)
// }

GO FUNC math/cmplx.Cot from math/cmplx/tan.go:
// func cot(x complex128) Object {
// 	return _cmplx.Cot(x)
// }

GO FUNC math/cmplx.Exp from math/cmplx/exp.go:
// func exp(x complex128) Object {
// 	return _cmplx.Exp(x)
// }

GO FUNC math/cmplx.Inf from math/cmplx/isinf.go:
// func inf() Object {
// 	return _cmplx.Inf()
// }

GO FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
// func isInf(x complex128)  {
// 	_res := _cmplx.IsInf(x)
// 	return MakeBool(_res)
// }

GO FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
// func isNaN(x complex128)  {
// 	_res := _cmplx.IsNaN(x)
// 	return MakeBool(_res)
// }

GO FUNC math/cmplx.Log from math/cmplx/log.go:
// func log(x complex128) Object {
// 	return _cmplx.Log(x)
// }

GO FUNC math/cmplx.Log10 from math/cmplx/log.go:
// func log10(x complex128) Object {
// 	return _cmplx.Log10(x)
// }

GO FUNC math/cmplx.NaN from math/cmplx/isnan.go:
// func naN() Object {
// 	return _cmplx.NaN()
// }

GO FUNC math/cmplx.Phase from math/cmplx/phase.go:
// func phase(x complex128) Object {
// 	return _cmplx.Phase(x)
// }

GO FUNC math/cmplx.Polar from math/cmplx/polar.go:
// func polar(x complex128) Object {
// 	r,  := _cmplx.Polar(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin()
// 	return _res
// }

GO FUNC math/cmplx.Pow from math/cmplx/pow.go:
// func pow(x complex128, y complex128) Object {
// 	return _cmplx.Pow(x, y)
// }

GO FUNC math/cmplx.Rect from math/cmplx/rect.go:
// func rect(r float64,  float64) Object {
// 	return _cmplx.Rect(r, )
// }

GO FUNC math/cmplx.Sin from math/cmplx/sin.go:
// func sin(x complex128) Object {
// 	return _cmplx.Sin(x)
// }

GO FUNC math/cmplx.Sinh from math/cmplx/sin.go:
// func sinh(x complex128) Object {
// 	return _cmplx.Sinh(x)
// }

GO FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
// func sqrt(x complex128) Object {
// 	return _cmplx.Sqrt(x)
// }

GO FUNC math/cmplx.Tan from math/cmplx/tan.go:
// func tan(x complex128) Object {
// 	return _cmplx.Tan(x)
// }

GO FUNC math/cmplx.Tanh from math/cmplx/tan.go:
// func tanh(x complex128) Object {
// 	return _cmplx.Tanh(x)
// }

GO FUNC math/rand.ExpFloat64 from math/rand/rand.go:
// func expFloat64() Object {
// 	return _rand.ExpFloat64()
// }

GO FUNC math/rand.Float32 from math/rand/rand.go:
// func _float32() Object {
// 	return _rand.Float32()
// }

GO FUNC math/rand.Float64 from math/rand/rand.go:
// func _float64() Object {
// 	return _rand.Float64()
// }

GO FUNC math/rand.Int31 from math/rand/rand.go:
func int31() Object {
	_res := _rand.Int31()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int31n from math/rand/rand.go:
func int31n(n int32) Object {
	_res := _rand.Int31n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int63 from math/rand/rand.go:
func int63() Object {
	_res := _rand.Int63()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int63n from math/rand/rand.go:
func int63n(n int64) Object {
	_res := _rand.Int63n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.New from math/rand/rand.go:
func _new(src _rand.Source) Object {
	_res := _rand.New(src)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewSource from math/rand/rand.go:
func newSource(seed int64) Object {
	_res := _rand.NewSource(seed)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewZipf from math/rand/zipf.go:
// func newZipf(r *_rand.Rand, s float64, v float64, imax uint64) Object {
// 	_res := _rand.NewZipf(r, s, v, imax)
// 	return MakeGoObject(_res)
// }

GO FUNC math/rand.NormFloat64 from math/rand/rand.go:
// func normFloat64() Object {
// 	return _rand.NormFloat64()
// }

GO FUNC math/rand.Perm from math/rand/rand.go:
func perm(n int) Object {
	_res := _rand.Perm(n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC math/rand.Read from math/rand/rand.go:
// func read(p []byte) Object {
// 	n, err := _rand.Read(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC math/rand.Seed from math/rand/rand.go:
// func seed(seed int64) Object {
// 	_rand.Seed(seed)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Shuffle from math/rand/rand.go:
// func shuffle(n int, swap func) Object {
// 	_rand.Shuffle(n, swap)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Uint32 from math/rand/rand.go:
func _uint32() Object {
	_res := _rand.Uint32()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Uint64 from math/rand/rand.go:
// func _uint64() Object {
// 	return _rand.Uint64()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rand

import (
	_rand "math/rand"
	. "github.com/candid82/joker/core"
)
GO FUNC mime.ExtensionsByType from mime/type.go:
func extensionsByType(typ string) Object {
	_res1, _res2 := _mime.ExtensionsByType(typ)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.FormatMediaType from mime/mediatype.go:
// func formatMediaType(t string, param map[])  {
// 	_res := _mime.FormatMediaType(t, param)
// 	return MakeString(_res)
// }

GO FUNC mime.ParseMediaType from mime/mediatype.go:
// func parseMediaType(v string) Object {
// 	mediatype, params, err := _mime.ParseMediaType(v)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(mediatype))
// 	_res = _res.Conjoin(params)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mime

import (
	_mime "mime"
	. "github.com/candid82/joker/core"
)
GO FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
// func newReader(r io.Reader, boundary string) Object {
// 	_res := _multipart.NewReader(r, boundary)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _multipart.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
// func newReader(r io.Reader) Object {
// 	_res := _quotedprintable.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
// func newWriter(w io.Writer) Object {
// 	_res := _quotedprintable.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net.CIDRMask from net/ip.go:
func cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func dial(network string, address string) Object {
	_res1, _res2 := _net.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
// func dialIP(network string, laddr *_net.IPAddr, raddr *_net.IPAddr) Object {
// 	_res1, _res2 := _net.DialIP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTCP from net/tcpsock.go:
// func dialTCP(network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr) Object {
// 	_res1, _res2 := _net.DialTCP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTimeout from net/dial.go:
// func dialTimeout(network string, address string, timeout time.Duration) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
// func dialUDP(network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.DialUDP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUnix from net/unixsock.go:
// func dialUnix(network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.DialUnix(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.FileConn from net/file.go:
// func fileConn(f *os.File) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func fileListener(f *os.File) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func filePacketConn(f *os.File) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func listen(network string, address string) Object {
	_res1, _res2 := _net.Listen(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
// func listenIP(network string, laddr *_net.IPAddr) Object {
// 	_res1, _res2 := _net.ListenIP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
// func listenMulticastUDP(network string, ifi *_net.Interface, gaddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenPacket from net/dial.go:
func listenPacket(network string, address string) Object {
	_res1, _res2 := _net.ListenPacket(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
// func listenTCP(network string, laddr *_net.TCPAddr) Object {
// 	_res1, _res2 := _net.ListenTCP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUDP from net/udpsock.go:
// func listenUDP(network string, laddr *_net.UDPAddr) Object {
// 	_res1, _res2 := _net.ListenUDP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnix from net/unixsock.go:
// func listenUnix(network string, laddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.ListenUnix(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnixgram from net/unixsock.go:
// func listenUnixgram(network string, laddr *_net.UnixAddr) Object {
// 	_res1, _res2 := _net.ListenUnixgram(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupAddr from net/lookup.go:
func lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func parseIP(s string) Object {
	_res := _net.ParseIP(s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package net

import (
	_net "net"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http.DetectContentType from net/http/sniff.go:
// func detectContentType(data []byte)  {
// 	_res := _http.DetectContentType(data)
// 	return MakeString(_res)
// }

GO FUNC net/http.Error from net/http/server.go:
// func _error(w _http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
func fileServer(root _http.FileSystem) Object {
	_res := _http.FileServer(root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func get(url string) Object {
	resp, err := _http.Get(url)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
// func handle(pattern string, handler _http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
func head(url string) Object {
	resp, err := _http.Head(url)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func maxBytesReader(w _http.ResponseWriter, r io.ReadCloser, n int64) Object {
// 	_res := _http.MaxBytesReader(w, r, n)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func newFileTransport(fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func newRequest(method string, url string, body io.Reader) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
// func notFound(w _http.ResponseWriter, r *_http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBool(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
func parseTime(text string) Object {
	t, err := _http.ParseTime(text)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(t))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Post from net/http/client.go:
// func post(url string, contentType string, body io.Reader) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func postForm(url string, data url.Values) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
// func proxyFromEnvironment(req *_http.Request) Object {
// 	_res1, _res2 := _http.ProxyFromEnvironment(req)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func proxyURL(fixedURL *url.URL) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func readRequest(b *bufio.Reader) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func readResponse(r *bufio.Reader, req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func redirect(w _http.ResponseWriter, r *_http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
func redirectHandler(url string, code int) Object {
	_res := _http.RedirectHandler(url, code)
	return MakeGoObject(_res)
}

GO FUNC net/http.Serve from net/http/server.go:
// func serve(l net.Listener, handler _http.Handler)  {
// 	_res := _http.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func serveContent(w _http.ResponseWriter, req *_http.Request, name string, modtime time.Time, content io.ReadSeeker) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func serveFile(w _http.ResponseWriter, r *_http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeTLS from net/http/server.go:
// func serveTLS(l net.Listener, handler _http.Handler, certFile string, keyFile string)  {
// 	_res := _http.ServeTLS(l, handler, certFile, keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func setCookie(w _http.ResponseWriter, cookie *_http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
func stripPrefix(prefix string, h _http.Handler) Object {
	_res := _http.StripPrefix(prefix, h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func timeoutHandler(h _http.Handler, dt time.Duration, msg string) Object {
// 	_res := _http.TimeoutHandler(h, dt, msg)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package http

import (
	_http "net/http"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func request() Object {
	_res1, _res2 := _cgi.Request()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.Serve from net/http/cgi/child.go:
// func serve(handler http.Handler)  {
// 	_res := _cgi.Serve(handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cgi

import (
	_cgi "net/http/cgi"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
// func _new(o *_cookiejar.Options) Object {
// 	_res1, _res2 := _cookiejar.New(o)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func processEnv(r *http.Request) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
// func serve(l net.Listener, handler http.Handler)  {
// 	_res := _fcgi.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func newRecorder() Object {
	_res := _httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func newRequest(method string, target string, body io.Reader) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func newServer(handler http.Handler) Object {
// 	_res := _httptest.NewServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func newTLSServer(handler http.Handler) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func newUnstartedServer(handler http.Handler) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package httptest

import (
	_httptest "net/http/httptest"
	. "github.com/candid82/joker/core"
)
GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func contextClientTrace(ctx context.Context) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func withClientTrace(ctx context.Context, trace *_httptrace.ClientTrace) Object {
// 	_res := _httptrace.WithClientTrace(ctx, trace)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func dumpRequest(req *http.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func dumpRequestOut(req *http.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func dumpResponse(resp *http.Response, body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func newChunkedReader(r io.Reader) Object {
// 	_res := _httputil.NewChunkedReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func newChunkedWriter(w io.Writer) Object {
// 	_res := _httputil.NewChunkedWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func newClientConn(c net.Conn, r *bufio.Reader) Object {
// 	_res := _httputil.NewClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func newProxyClientConn(c net.Conn, r *bufio.Reader) Object {
// 	_res := _httputil.NewProxyClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func newServerConn(c net.Conn, r *bufio.Reader) Object {
// 	_res := _httputil.NewServerConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func newSingleHostReverseProxy(target *url.URL) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func cmdline(w http.ResponseWriter, r *http.Request) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func handler(name string) Object {
	_res := _pprof.Handler(name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func index(w http.ResponseWriter, r *http.Request) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func profile(w http.ResponseWriter, r *http.Request) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func symbol(w http.ResponseWriter, r *http.Request) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func trace(w http.ResponseWriter, r *http.Request) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	_pprof "net/http/pprof"
	. "github.com/candid82/joker/core"
)
GO FUNC net/mail.ParseAddress from net/mail/message.go:
func parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
func parseDate(date string) Object {
	_res1, _res2 := _mail.ParseDate(date)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func readMessage(r io.Reader) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mail

import (
	_mail "net/mail"
	. "github.com/candid82/joker/core"
)
GO FUNC net/rpc.Accept from net/rpc/server.go:
// func accept(lis net.Listener) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
func dial(network string, address string) Object {
	_res1, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func dialHTTP(network string, address string) Object {
	_res1, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func dialHTTPPath(network string, address string, path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func newClient(conn io.ReadWriteCloser) Object {
// 	_res := _rpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func newClientWithCodec(codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.Register from net/rpc/server.go:
// func register(rcvr interface {})  {
// 	_res := _rpc.Register(rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.RegisterName from net/rpc/server.go:
// func registerName(name string, rcvr interface {})  {
// 	_res := _rpc.RegisterName(name, rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func serveCodec(codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func serveConn(conn io.ReadWriteCloser) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rpc

import (
	_rpc "net/rpc"
	. "github.com/candid82/joker/core"
)
GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func dial(network string, address string) Object {
	_res1, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func newClient(conn io.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func newClientCodec(conn io.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewClientCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func newServerCodec(conn io.ReadWriteCloser) Object {
// 	_res := _jsonrpc.NewServerCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func serveConn(conn io.ReadWriteCloser) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package jsonrpc

import (
	_jsonrpc "net/rpc/jsonrpc"
	. "github.com/candid82/joker/core"
)
GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func cRAMMD5Auth(username string, secret string) Object {
	_res := _smtp.CRAMMD5Auth(username, secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func dial(addr string) Object {
	_res1, _res2 := _smtp.Dial(addr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func newClient(conn net.Conn, host string) Object {
// 	_res1, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func plainAuth(identity string, username string, password string, host string) Object {
	_res := _smtp.PlainAuth(identity, username, password, host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.SendMail from net/smtp/smtp.go:
// func sendMail(addr string, a _smtp.Auth, from string, to []string, msg []byte)  {
// 	_res := _smtp.SendMail(addr, a, from, to, msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package smtp

import (
	_smtp "net/smtp"
	. "github.com/candid82/joker/core"
)
GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func dial(network string, addr string) Object {
	_res1, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func newConn(conn io.ReadWriteCloser) Object {
// 	_res := _textproto.NewConn(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func newReader(r *bufio.Reader) Object {
// 	_res := _textproto.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func newWriter(w *bufio.Writer) Object {
// 	_res := _textproto.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func trimBytes(b []byte) Object {
// 	_res := _textproto.TrimBytes(b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package textproto

import (
	_textproto "net/textproto"
	. "github.com/candid82/joker/core"
)
GO FUNC net/url.Parse from net/url/url.go:
func parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func parseQuery(query string) Object {
	_res1, _res2 := _url.ParseQuery(query)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func user(username string) Object {
	_res := _url.User(username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func userPassword(username string, password string) Object {
	_res := _url.UserPassword(username, password)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package url

import (
	_url "net/url"
	. "github.com/candid82/joker/core"
)
GO FUNC os.Chtimes from os/file_posix.go:
// func chtimes(name string, atime time.Time, mtime time.Time)  {
// 	_res := _os.Chtimes(name, atime, mtime)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC os.Clearenv from os/env.go:
// func clearenv() Object {
// 	_os.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC os.Create from os/file.go:
func create(name string) Object {
	_res1, _res2 := _os.Create(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Environ from os/env.go:
func environ() Object {
	_res := _os.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC os.Executable from os/executable.go:
func executable() Object {
	_res1, _res2 := _os.Executable()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Exit from os/proc.go:
// func exit(code int) Object {
// 	_os.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC os.Expand from os/env.go:
// func expand(s string, mapping func)  {
// 	_res := _os.Expand(s, mapping)
// 	return MakeString(_res)
// }

GO FUNC os.FindProcess from os/exec.go:
func findProcess(pid int) Object {
	_res1, _res2 := _os.FindProcess(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getgroups from os/proc.go:
func getgroups() Object {
	_res1, _res2 := _os.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getwd from os/getwd.go:
func getwd() Object {
	dir, err := _os.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Hostname from os/sys.go:
func hostname() Object {
	name, err := _os.Hostname()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.IsExist from os/error.go:
// func isExist(err error)  {
// 	_res := _os.IsExist(err)
// 	return MakeBool(_res)
// }

GO FUNC os.IsNotExist from os/error.go:
// func isNotExist(err error)  {
// 	_res := _os.IsNotExist(err)
// 	return MakeBool(_res)
// }

GO FUNC os.IsPathSeparator from os/path_unix.go:
// func isPathSeparator(c uint8)  {
// 	_res := _os.IsPathSeparator(c)
// 	return MakeBool(_res)
// }

GO FUNC os.IsPermission from os/error.go:
// func isPermission(err error)  {
// 	_res := _os.IsPermission(err)
// 	return MakeBool(_res)
// }

GO FUNC os.IsTimeout from os/error.go:
// func isTimeout(err error)  {
// 	_res := _os.IsTimeout(err)
// 	return MakeBool(_res)
// }

GO FUNC os.LookupEnv from os/env.go:
func lookupEnv(key string) Object {
	_res1, _res2 := _os.LookupEnv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBool(_res2))
	return _res
}

GO FUNC os.Lstat from os/stat.go:
func lstat(name string) Object {
	_res1, _res2 := _os.Lstat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.NewFile from os/file_unix.go:
// func newFile(fd uintptr, name string) Object {
// 	_res := _os.NewFile(fd, name)
// 	return MakeGoObject(_res)
// }

GO FUNC os.NewSyscallError from os/error.go:
// func newSyscallError(syscall string, err error)  {
// 	_res := _os.NewSyscallError(syscall, err)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC os.Open from os/file.go:
func open(name string) Object {
	_res1, _res2 := _os.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.OpenFile from os/file.go:
func openFile(name string, flag int, perm _os.FileMode) Object {
	_res1, _res2 := _os.OpenFile(name, flag, perm)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Pipe from os/pipe_bsd.go:
func pipe() Object {
	r, w, err := _os.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(r))
	_res = _res.Conjoin(MakeGoObject(w))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Readlink from os/file_posix.go:
func readlink(name string) Object {
	_res1, _res2 := _os.Readlink(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.StartProcess from os/exec.go:
// func startProcess(name string, argv []string, attr *_os.ProcAttr) Object {
// 	_res1, _res2 := _os.StartProcess(name, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.Stat from os/stat.go:
func stat(name string) Object {
	_res1, _res2 := _os.Stat(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.UserCacheDir from os/file.go:
func userCacheDir() Object {
	_res1, _res2 := _os.UserCacheDir()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package os

import (
	_os "os"
	. "github.com/candid82/joker/core"
)
GO FUNC os/exec.Command from os/exec/exec.go:
// func command(name string, arg ...string) Object {
// 	_res := _exec.Command(name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.CommandContext from os/exec/exec.go:
// func commandContext(ctx context.Context, name string, arg ...string) Object {
// 	_res := _exec.CommandContext(ctx, name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.LookPath from os/exec/lp_unix.go:
func lookPath(file string) Object {
	_res1, _res2 := _exec.LookPath(file)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package exec

import (
	_exec "os/exec"
	. "github.com/candid82/joker/core"
)
GO FUNC os/signal.Ignore from os/signal/signal.go:
// func ignore(sig ...os.Signal) Object {
// 	_signal.Ignore(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Ignored from os/signal/signal.go:
// func ignored(sig os.Signal)  {
// 	_res := _signal.Ignored(sig)
// 	return MakeBool(_res)
// }

GO FUNC os/signal.Notify from os/signal/signal.go:
// func notify(c <-chan, sig ...os.Signal) Object {
// 	_signal.Notify(c, sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Reset from os/signal/signal.go:
// func reset(sig ...os.Signal) Object {
// 	_signal.Reset(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Stop from os/signal/signal.go:
// func stop(c <-chan) Object {
// 	_signal.Stop(c)
// 	...ABEND675: TODO...
// }

GO FUNC os/user.Current from os/user/lookup.go:
func current() Object {
	_res1, _res2 := _user.Current()
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.Lookup from os/user/lookup.go:
func lookup(username string) Object {
	_res1, _res2 := _user.Lookup(username)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroup from os/user/lookup.go:
func lookupGroup(name string) Object {
	_res1, _res2 := _user.LookupGroup(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroupId from os/user/lookup.go:
func lookupGroupId(gid string) Object {
	_res1, _res2 := _user.LookupGroupId(gid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupId from os/user/lookup.go:
func lookupId(uid string) Object {
	_res1, _res2 := _user.LookupId(uid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package user

import (
	_user "os/user"
	. "github.com/candid82/joker/core"
)
GO FUNC path.Join from path/path.go:
// func join(elem ...string)  {
// 	_res := _path.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path.Match from path/match.go:
func match(pattern string, name string) Object {
	matched, err := _path.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path.Split from path/path.go:
func split(path string) Object {
	dir, file := _path.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package path

import (
	_path "path"
	. "github.com/candid82/joker/core"
)
GO FUNC path/filepath.Abs from path/filepath/path.go:
func abs(path string) Object {
	_res1, _res2 := _filepath.Abs(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
func evalSymlinks(path string) Object {
	_res1, _res2 := _filepath.EvalSymlinks(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Glob from path/filepath/match.go:
func glob(pattern string) Object {
	matches, err := _filepath.Glob(pattern)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range matches {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Join from path/filepath/path.go:
// func join(elem ...string)  {
// 	_res := _filepath.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path/filepath.Match from path/filepath/match.go:
func match(pattern string, name string) Object {
	matched, err := _filepath.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Rel from path/filepath/path.go:
func rel(basepath string, targpath string) Object {
	_res1, _res2 := _filepath.Rel(basepath, targpath)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Split from path/filepath/path.go:
func split(path string) Object {
	dir, file := _filepath.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

GO FUNC path/filepath.SplitList from path/filepath/path.go:
func splitList(path string) Object {
	_res := _filepath.SplitList(path)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package filepath

import (
	_filepath "path/filepath"
	. "github.com/candid82/joker/core"
)
GO FUNC plugin.Open from plugin/plugin.go:
func open(path string) Object {
	_res1, _res2 := _plugin.Open(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plugin

import (
	_plugin "plugin"
	. "github.com/candid82/joker/core"
)
GO FUNC reflect.Append from reflect/value.go:
// func _append(s _reflect.Value, x ..._reflect.Value) Object {
// 	_res := _reflect.Append(s, x)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.AppendSlice from reflect/value.go:
func appendSlice(s _reflect.Value, t _reflect.Value) Object {
	_res := _reflect.AppendSlice(s, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.ArrayOf from reflect/type.go:
func arrayOf(count int, elem _reflect.Type) Object {
	_res := _reflect.ArrayOf(count, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.ChanOf from reflect/type.go:
func chanOf(dir _reflect.ChanDir, t _reflect.Type) Object {
	_res := _reflect.ChanOf(dir, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.DeepEqual from reflect/deepequal.go:
// func deepEqual(x interface {}, y interface {})  {
// 	_res := _reflect.DeepEqual(x, y)
// 	return MakeBool(_res)
// }

GO FUNC reflect.FuncOf from reflect/type.go:
// func funcOf(in []_reflect.Type, out []_reflect.Type, variadic bool) Object {
// 	_res := _reflect.FuncOf(in, out, variadic)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Indirect from reflect/value.go:
func indirect(v _reflect.Value) Object {
	_res := _reflect.Indirect(v)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeChan from reflect/value.go:
func makeChan(typ _reflect.Type, buffer int) Object {
	_res := _reflect.MakeChan(typ, buffer)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeFunc from reflect/makefunc.go:
// func makeFunc(typ _reflect.Type, fn func) Object {
// 	_res := _reflect.MakeFunc(typ, fn)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.MakeMap from reflect/value.go:
func makeMap(typ _reflect.Type) Object {
	_res := _reflect.MakeMap(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeMapWithSize from reflect/value.go:
func makeMapWithSize(typ _reflect.Type, n int) Object {
	_res := _reflect.MakeMapWithSize(typ, n)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeSlice from reflect/value.go:
func makeSlice(typ _reflect.Type, len int, cap int) Object {
	_res := _reflect.MakeSlice(typ, len, cap)
	return MakeGoObject(_res)
}

GO FUNC reflect.MapOf from reflect/type.go:
func mapOf(key _reflect.Type, elem _reflect.Type) Object {
	_res := _reflect.MapOf(key, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.New from reflect/value.go:
func _new(typ _reflect.Type) Object {
	_res := _reflect.New(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.NewAt from reflect/value.go:
// func newAt(typ _reflect.Type, p unsafe.Pointer) Object {
// 	_res := _reflect.NewAt(typ, p)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.PtrTo from reflect/type.go:
func ptrTo(t _reflect.Type) Object {
	_res := _reflect.PtrTo(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.Select from reflect/value.go:
// func _select(cases []_reflect.SelectCase) Object {
// 	chosen, recv, recvOK := _reflect.Select(cases)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(chosen))
// 	_res = _res.Conjoin(MakeGoObject(recv))
// 	_res = _res.Conjoin(MakeBool(recvOK))
// 	return _res
// }

GO FUNC reflect.SliceOf from reflect/type.go:
func sliceOf(t _reflect.Type) Object {
	_res := _reflect.SliceOf(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.StructOf from reflect/type.go:
// func structOf(fields []_reflect.StructField) Object {
// 	_res := _reflect.StructOf(fields)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Swapper from reflect/swapper.go:
// func swapper(slice interface {}) Object {
// 	return _reflect.Swapper(slice)
// }

GO FUNC reflect.TypeOf from reflect/type.go:
// func typeOf(i interface {}) Object {
// 	_res := _reflect.TypeOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.ValueOf from reflect/value.go:
// func valueOf(i interface {}) Object {
// 	_res := _reflect.ValueOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Zero from reflect/value.go:
func zero(typ _reflect.Type) Object {
	_res := _reflect.Zero(typ)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package reflect

import (
	_reflect "reflect"
	. "github.com/candid82/joker/core"
)
GO FUNC regexp.Compile from regexp/regexp.go:
func compile(expr string) Object {
	_res1, _res2 := _regexp.Compile(expr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.CompilePOSIX from regexp/regexp.go:
func compilePOSIX(expr string) Object {
	_res1, _res2 := _regexp.CompilePOSIX(expr)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.Match from regexp/regexp.go:
// func match(pattern string, b []byte) Object {
// 	matched, err := _regexp.Match(pattern, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchReader from regexp/regexp.go:
// func matchReader(pattern string, r io.RuneReader) Object {
// 	matched, err := _regexp.MatchReader(pattern, r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchString from regexp/regexp.go:
func matchString(pattern string, s string) Object {
	matched, err := _regexp.MatchString(pattern, s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC regexp.MustCompile from regexp/regexp.go:
func mustCompile(str string) Object {
	_res := _regexp.MustCompile(str)
	return MakeGoObject(_res)
}

GO FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
func mustCompilePOSIX(str string) Object {
	_res := _regexp.MustCompilePOSIX(str)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package regexp

import (
	_regexp "regexp"
	. "github.com/candid82/joker/core"
)
GO FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
// func compile(re *_syntax.Regexp) Object {
// 	_res1, _res2 := _syntax.Compile(re)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
// func emptyOpContext(r1 rune, r2 rune) Object {
// 	_res := _syntax.EmptyOpContext(r1, r2)
// 	return MakeGoObject(_res)
// }

GO FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
// func isWordChar(r rune)  {
// 	_res := _syntax.IsWordChar(r)
// 	return MakeBool(_res)
// }

GO FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
func parse(s string, flags _syntax.Flags) Object {
	_res1, _res2 := _syntax.Parse(s, flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syntax

import (
	_syntax "regexp/syntax"
	. "github.com/candid82/joker/core"
)
GO FUNC runtime.BlockProfile from runtime/mprof.go:
// func blockProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.BlockProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.Breakpoint from runtime/proc.go:
// func breakpoint() Object {
// 	_runtime.Breakpoint()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.CPUProfile from runtime/cpuprof.go:
func cPUProfile() Object {
	_res := _runtime.CPUProfile()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.Caller from runtime/extern.go:
// func caller(skip int) Object {
// 	pc, file, line, ok := _runtime.Caller(skip)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pc)
// 	_res = _res.Conjoin(MakeString(file))
// 	_res = _res.Conjoin(MakeInt(line))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.Callers from runtime/extern.go:
// func callers(skip int, pc []uintptr)  {
// 	_res := _runtime.Callers(skip, pc)
// 	return MakeInt(_res)
// }

GO FUNC runtime.CallersFrames from runtime/symtab.go:
// func callersFrames(callers []uintptr) Object {
// 	_res := _runtime.CallersFrames(callers)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime.FuncForPC from runtime/symtab.go:
// func funcForPC(pc uintptr) Object {
// 	_res := _runtime.FuncForPC(pc)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime.GC from runtime/mgc.go:
// func gC() Object {
// 	_runtime.GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Goexit from runtime/panic.go:
// func goexit() Object {
// 	_runtime.Goexit()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.GoroutineProfile from runtime/mprof.go:
// func goroutineProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.GoroutineProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.Gosched from runtime/proc.go:
// func gosched() Object {
// 	_runtime.Gosched()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.KeepAlive from runtime/mfinal.go:
// func keepAlive(x interface {}) Object {
// 	_runtime.KeepAlive(x)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.LockOSThread from runtime/proc.go:
// func lockOSThread() Object {
// 	_runtime.LockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.MemProfile from runtime/mprof.go:
// func memProfile(p []_runtime.MemProfileRecord, inuseZero bool) Object {
// 	n, ok := _runtime.MemProfile(p, inuseZero)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.MutexProfile from runtime/mprof.go:
// func mutexProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.MutexProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.NumCgoCall from runtime/debug.go:
func numCgoCall() Object {
	_res := _runtime.NumCgoCall()
	return MakeInt(int(_res))
}

GO FUNC runtime.ReadMemStats from runtime/mstats.go:
// func readMemStats(m *_runtime.MemStats) Object {
// 	_runtime.ReadMemStats(m)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ReadTrace from runtime/trace.go:
func readTrace() Object {
	_res := _runtime.ReadTrace()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
// func setBlockProfileRate(rate int) Object {
// 	_runtime.SetBlockProfileRate(rate)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
// func setCPUProfileRate(hz int) Object {
// 	_runtime.SetCPUProfileRate(hz)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCgoTraceback from runtime/traceback.go:
// func setCgoTraceback(version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer) Object {
// 	_runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetFinalizer from runtime/mfinal.go:
// func setFinalizer(obj interface {}, finalizer interface {}) Object {
// 	_runtime.SetFinalizer(obj, finalizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Stack from runtime/mprof.go:
// func stack(buf []byte, all bool)  {
// 	_res := _runtime.Stack(buf, all)
// 	return MakeInt(_res)
// }

GO FUNC runtime.StopTrace from runtime/trace.go:
// func stopTrace() Object {
// 	_runtime.StopTrace()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
// func threadCreateProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.ThreadCreateProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.UnlockOSThread from runtime/proc.go:
// func unlockOSThread() Object {
// 	_runtime.UnlockOSThread()
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package runtime

import (
	_runtime "runtime"
	. "github.com/candid82/joker/core"
)
GO FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
// func freeOSMemory() Object {
// 	_debug.FreeOSMemory()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
// func printStack() Object {
// 	_debug.PrintStack()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
// func readGCStats(stats *_debug.GCStats) Object {
// 	_debug.ReadGCStats(stats)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
// func setTraceback(level string) Object {
// 	_debug.SetTraceback(level)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.Stack from runtime/debug/stack.go:
func stack() Object {
	_res := _debug.Stack()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
// func writeHeapDump(fd uintptr) Object {
// 	_debug.WriteHeapDump(fd)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package debug

import (
	_debug "runtime/debug"
	. "github.com/candid82/joker/core"
)
GO FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
// func do(ctx context.Context, labels _pprof.LabelSet, f func) Object {
// 	_pprof.Do(ctx, labels, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
// func forLabels(ctx context.Context, f func) Object {
// 	_pprof.ForLabels(ctx, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.Label from runtime/pprof/label.go:
// func label(ctx context.Context, key string) Object {
// 	_res1, _res2 := _pprof.Label(ctx, key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(_res1))
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC runtime/pprof.Labels from runtime/pprof/label.go:
// func labels(args ...string) Object {
// 	_res := _pprof.Labels(args)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
func lookup(name string) Object {
	_res := _pprof.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
func newProfile(name string) Object {
	_res := _pprof.NewProfile(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
func profiles() Object {
	_res := _pprof.Profiles()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
// func setGoroutineLabels(ctx context.Context) Object {
// 	_pprof.SetGoroutineLabels(ctx)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
// func startCPUProfile(w io.Writer)  {
// 	_res := _pprof.StartCPUProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
// func stopCPUProfile() Object {
// 	_pprof.StopCPUProfile()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
// func withLabels(ctx context.Context, labels _pprof.LabelSet) Object {
// 	_res := _pprof.WithLabels(ctx, labels)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
// func writeHeapProfile(w io.Writer)  {
// 	_res := _pprof.WriteHeapProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	_pprof "runtime/pprof"
	. "github.com/candid82/joker/core"
)
GO FUNC runtime/trace.Log from runtime/trace/annotation.go:
// func log(ctx context.Context, category string, message string) Object {
// 	_trace.Log(ctx, category, message)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.Logf from runtime/trace/annotation.go:
// func logf(ctx context.Context, category string, format string, args ...interface {}) Object {
// 	_trace.Logf(ctx, category, format, args)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
// func newTask(pctx context.Context, taskType string) Object {
// 	ctx, task := _trace.NewTask(pctx, taskType)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(ctx))
// 	_res = _res.Conjoin(MakeGoObject(task))
// 	return _res
// }

GO FUNC runtime/trace.Start from runtime/trace/trace.go:
// func start(w io.Writer)  {
// 	_res := _trace.Start(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
// func startRegion(ctx context.Context, regionType string) Object {
// 	_res := _trace.StartRegion(ctx, regionType)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/trace.Stop from runtime/trace/trace.go:
// func stop() Object {
// 	_trace.Stop()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
// func withRegion(ctx context.Context, regionType string, fn func) Object {
// 	_trace.WithRegion(ctx, regionType, fn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package trace

import (
)
GO FUNC sort.Float64s from sort/sort.go:
// func float64s(a []float64) Object {
// 	_sort.Float64s(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Float64sAreSorted from sort/sort.go:
// func float64sAreSorted(a []float64)  {
// 	_res := _sort.Float64sAreSorted(a)
// 	return MakeBool(_res)
// }

GO FUNC sort.Ints from sort/sort.go:
// func ints(a []int) Object {
// 	_sort.Ints(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.IntsAreSorted from sort/sort.go:
// func intsAreSorted(a []int)  {
// 	_res := _sort.IntsAreSorted(a)
// 	return MakeBool(_res)
// }

GO FUNC sort.Reverse from sort/sort.go:
func reverse(data _sort.Interface) Object {
	_res := _sort.Reverse(data)
	return MakeGoObject(_res)
}

GO FUNC sort.Search from sort/search.go:
// func search(n int, f func)  {
// 	_res := _sort.Search(n, f)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchFloat64s from sort/search.go:
// func searchFloat64s(a []float64, x float64)  {
// 	_res := _sort.SearchFloat64s(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchInts from sort/search.go:
// func searchInts(a []int, x int)  {
// 	_res := _sort.SearchInts(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchStrings from sort/search.go:
// func searchStrings(a []string, x string)  {
// 	_res := _sort.SearchStrings(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.Slice from sort/slice.go:
// func slice(slice interface {}, less func) Object {
// 	_sort.Slice(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.SliceIsSorted from sort/slice.go:
// func sliceIsSorted(slice interface {}, less func)  {
// 	_res := _sort.SliceIsSorted(slice, less)
// 	return MakeBool(_res)
// }

GO FUNC sort.SliceStable from sort/slice.go:
// func sliceStable(slice interface {}, less func) Object {
// 	_sort.SliceStable(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Sort from sort/sort.go:
// func sort(data _sort.Interface) Object {
// 	_sort.Sort(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Stable from sort/sort.go:
// func stable(data _sort.Interface) Object {
// 	_sort.Stable(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Strings from sort/sort.go:
// func strings(a []string) Object {
// 	_sort.Strings(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.StringsAreSorted from sort/sort.go:
// func stringsAreSorted(a []string)  {
// 	_res := _sort.StringsAreSorted(a)
// 	return MakeBool(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sort

import (
	_sort "sort"
	. "github.com/candid82/joker/core"
)
GO FUNC strconv.AppendBool from strconv/atob.go:
// func appendBool(dst []byte, b bool) Object {
// 	_res := _strconv.AppendBool(dst, b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendFloat from strconv/ftoa.go:
// func appendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) Object {
// 	_res := _strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendInt from strconv/itoa.go:
// func appendInt(dst []byte, i int64, base int) Object {
// 	_res := _strconv.AppendInt(dst, i, base)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuote from strconv/quote.go:
// func appendQuote(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuote(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRune from strconv/quote.go:
// func appendQuoteRune(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRune(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
// func appendQuoteRuneToASCII(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToASCII(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
// func appendQuoteRuneToGraphic(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToGraphic(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
// func appendQuoteToASCII(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToASCII(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
// func appendQuoteToGraphic(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToGraphic(dst, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendUint from strconv/itoa.go:
// func appendUint(dst []byte, i uint64, base int) Object {
// 	_res := _strconv.AppendUint(dst, i, base)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.Atoi from strconv/atoi.go:
func atoi(s string) Object {
	_res1, _res2 := _strconv.Atoi(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.FormatFloat from strconv/ftoa.go:
// func formatFloat(f float64, fmt byte, prec int, bitSize int)  {
// 	_res := _strconv.FormatFloat(f, fmt, prec, bitSize)
// 	return MakeString(_res)
// }

GO FUNC strconv.FormatUint from strconv/itoa.go:
// func formatUint(i uint64, base int)  {
// 	_res := _strconv.FormatUint(i, base)
// 	return MakeString(_res)
// }

GO FUNC strconv.IsGraphic from strconv/quote.go:
// func isGraphic(r rune)  {
// 	_res := _strconv.IsGraphic(r)
// 	return MakeBool(_res)
// }

GO FUNC strconv.IsPrint from strconv/quote.go:
// func isPrint(r rune)  {
// 	_res := _strconv.IsPrint(r)
// 	return MakeBool(_res)
// }

GO FUNC strconv.ParseBool from strconv/atob.go:
func parseBool(str string) Object {
	_res1, _res2 := _strconv.ParseBool(str)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseFloat from strconv/atof.go:
// func parseFloat(s string, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseFloat(s, bitSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.ParseInt from strconv/atoi.go:
func parseInt(s string, base int, bitSize int) Object {
	i, err := _strconv.ParseInt(s, base, bitSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(i)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strconv.ParseUint from strconv/atoi.go:
// func parseUint(s string, base int, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseUint(s, base, bitSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.QuoteRune from strconv/quote.go:
// func quoteRune(r rune)  {
// 	_res := _strconv.QuoteRune(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
// func quoteRuneToASCII(r rune)  {
// 	_res := _strconv.QuoteRuneToASCII(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
// func quoteRuneToGraphic(r rune)  {
// 	_res := _strconv.QuoteRuneToGraphic(r)
// 	return MakeString(_res)
// }

GO FUNC strconv.Unquote from strconv/quote.go:
func unquote(s string) Object {
	_res1, _res2 := _strconv.Unquote(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.UnquoteChar from strconv/quote.go:
// func unquoteChar(s string, quote byte) Object {
// 	value, multibyte, tail, err := _strconv.UnquoteChar(s, quote)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(value)
// 	_res = _res.Conjoin(MakeBool(multibyte))
// 	_res = _res.Conjoin(MakeString(tail))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strconv

import (
	_strconv "strconv"
	. "github.com/candid82/joker/core"
)
GO FUNC strings.ContainsRune from strings/strings.go:
// func containsRune(s string, r rune)  {
// 	_res := _strings.ContainsRune(s, r)
// 	return MakeBool(_res)
// }

GO FUNC strings.Fields from strings/strings.go:
func fields(s string) Object {
	_res := _strings.Fields(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.FieldsFunc from strings/strings.go:
// func fieldsFunc(s string, f func) Object {
// 	_res := _strings.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC strings.IndexFunc from strings/strings.go:
// func indexFunc(s string, f func)  {
// 	_res := _strings.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.IndexRune from strings/strings.go:
// func indexRune(s string, r rune)  {
// 	_res := _strings.IndexRune(s, r)
// 	return MakeInt(_res)
// }

GO FUNC strings.Join from strings/strings.go:
// func join(a []string, sep string)  {
// 	_res := _strings.Join(a, sep)
// 	return MakeString(_res)
// }

GO FUNC strings.LastIndexFunc from strings/strings.go:
// func lastIndexFunc(s string, f func)  {
// 	_res := _strings.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.Map from strings/strings.go:
// func _map(mapping func, s string)  {
// 	_res := _strings.Map(mapping, s)
// 	return MakeString(_res)
// }

GO FUNC strings.NewReader from strings/reader.go:
func newReader(s string) Object {
	_res := _strings.NewReader(s)
	return MakeGoObject(_res)
}

GO FUNC strings.NewReplacer from strings/replace.go:
// func newReplacer(oldnew ...string) Object {
// 	_res := _strings.NewReplacer(oldnew)
// 	return MakeGoObject(_res)
// }

GO FUNC strings.Split from strings/strings.go:
func split(s string, sep string) Object {
	_res := _strings.Split(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfter from strings/strings.go:
func splitAfter(s string, sep string) Object {
	_res := _strings.SplitAfter(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfterN from strings/strings.go:
func splitAfterN(s string, sep string, n int) Object {
	_res := _strings.SplitAfterN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitN from strings/strings.go:
func splitN(s string, sep string, n int) Object {
	_res := _strings.SplitN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.ToLowerSpecial from strings/strings.go:
// func toLowerSpecial(c unicode.SpecialCase, s string)  {
// 	_res := _strings.ToLowerSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToTitleSpecial from strings/strings.go:
// func toTitleSpecial(c unicode.SpecialCase, s string)  {
// 	_res := _strings.ToTitleSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToUpperSpecial from strings/strings.go:
// func toUpperSpecial(c unicode.SpecialCase, s string)  {
// 	_res := _strings.ToUpperSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimFunc from strings/strings.go:
// func trimFunc(s string, f func)  {
// 	_res := _strings.TrimFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimLeftFunc from strings/strings.go:
// func trimLeftFunc(s string, f func)  {
// 	_res := _strings.TrimLeftFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimRightFunc from strings/strings.go:
// func trimRightFunc(s string, f func)  {
// 	_res := _strings.TrimRightFunc(s, f)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strings

import (
	_strings "strings"
	. "github.com/candid82/joker/core"
)
GO FUNC sync.NewCond from sync/cond.go:
func newCond(l _sync.Locker) Object {
	_res := _sync.NewCond(l)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sync

import (
	_sync "sync"
	. "github.com/candid82/joker/core"
)
GO FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
// func addInt32(addr *int32, delta int32) Object {
// 	_res := _atomic.AddInt32(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
// func addInt64(addr *int64, delta int64) Object {
// 	_res := _atomic.AddInt64(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
// func addUint32(addr *uint32, delta uint32) Object {
// 	_res := _atomic.AddUint32(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
// func addUint64(addr *uint64, delta uint64) Object {
// 	return _atomic.AddUint64(addr, delta)
// }

GO FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
// func addUintptr(addr *uintptr, delta uintptr) Object {
// 	return _atomic.AddUintptr(addr, delta)
// }

GO FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
// func compareAndSwapInt32(addr *int32, old int32, new int32)  {
// 	_res := _atomic.CompareAndSwapInt32(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
// func compareAndSwapInt64(addr *int64, old int64, new int64)  {
// 	_res := _atomic.CompareAndSwapInt64(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
// func compareAndSwapPointer(addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)  {
// 	_res := _atomic.CompareAndSwapPointer(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
// func compareAndSwapUint32(addr *uint32, old uint32, new uint32)  {
// 	_res := _atomic.CompareAndSwapUint32(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
// func compareAndSwapUint64(addr *uint64, old uint64, new uint64)  {
// 	_res := _atomic.CompareAndSwapUint64(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
// func compareAndSwapUintptr(addr *uintptr, old uintptr, new uintptr)  {
// 	_res := _atomic.CompareAndSwapUintptr(addr, old, new)
// 	return MakeBool(_res)
// }

GO FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
// func loadInt32(addr *int32) Object {
// 	_res := _atomic.LoadInt32(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
// func loadInt64(addr *int64) Object {
// 	_res := _atomic.LoadInt64(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
// func loadPointer(addr *unsafe.Pointer) Object {
// 	_res := _atomic.LoadPointer(addr)
// 	return MakeGoObject(_res)
// }

GO FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
// func loadUint32(addr *uint32) Object {
// 	_res := _atomic.LoadUint32(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
// func loadUint64(addr *uint64) Object {
// 	return _atomic.LoadUint64(addr)
// }

GO FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
// func loadUintptr(addr *uintptr) Object {
// 	return _atomic.LoadUintptr(addr)
// }

GO FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
// func storeInt32(addr *int32, val int32) Object {
// 	_atomic.StoreInt32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
// func storeInt64(addr *int64, val int64) Object {
// 	_atomic.StoreInt64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
// func storePointer(addr *unsafe.Pointer, val unsafe.Pointer) Object {
// 	_atomic.StorePointer(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
// func storeUint32(addr *uint32, val uint32) Object {
// 	_atomic.StoreUint32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
// func storeUint64(addr *uint64, val uint64) Object {
// 	_atomic.StoreUint64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
// func storeUintptr(addr *uintptr, val uintptr) Object {
// 	_atomic.StoreUintptr(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
// func swapInt32(addr *int32, new int32) Object {
// 	_res := _atomic.SwapInt32(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
// func swapInt64(addr *int64, new int64) Object {
// 	_res := _atomic.SwapInt64(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
// func swapPointer(addr *unsafe.Pointer, new unsafe.Pointer) Object {
// 	_res := _atomic.SwapPointer(addr, new)
// 	return MakeGoObject(_res)
// }

GO FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
// func swapUint32(addr *uint32, new uint32) Object {
// 	_res := _atomic.SwapUint32(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
// func swapUint64(addr *uint64, new uint64) Object {
// 	return _atomic.SwapUint64(addr, new)
// }

GO FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
// func swapUintptr(addr *uintptr, new uintptr) Object {
// 	return _atomic.SwapUintptr(addr, new)
// }

GO FUNC syscall.Accept from syscall/syscall_bsd.go:
func accept(fd int) Object {
	nfd, sa, err := _syscall.Accept(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Adjtime from syscall/zsyscall_darwin_amd64.go:
// func adjtime(delta *_syscall.Timeval, olddelta *_syscall.Timeval)  {
// 	_res := _syscall.Adjtime(delta, olddelta)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.BpfBuflen from syscall/bpf_bsd.go:
func bpfBuflen(fd int) Object {
	_res1, _res2 := _syscall.BpfBuflen(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfDatalink from syscall/bpf_bsd.go:
func bpfDatalink(fd int) Object {
	_res1, _res2 := _syscall.BpfDatalink(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfHeadercmpl from syscall/bpf_bsd.go:
func bpfHeadercmpl(fd int) Object {
	_res1, _res2 := _syscall.BpfHeadercmpl(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfInterface from syscall/bpf_bsd.go:
func bpfInterface(fd int, name string) Object {
	_res1, _res2 := _syscall.BpfInterface(fd, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfJump from syscall/bpf_bsd.go:
func bpfJump(code int, k int, jt int, jf int) Object {
	_res := _syscall.BpfJump(code, k, jt, jf)
	return MakeGoObject(_res)
}

GO FUNC syscall.BpfStats from syscall/bpf_bsd.go:
func bpfStats(fd int) Object {
	_res1, _res2 := _syscall.BpfStats(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfStmt from syscall/bpf_bsd.go:
func bpfStmt(code int, k int) Object {
	_res := _syscall.BpfStmt(code, k)
	return MakeGoObject(_res)
}

GO FUNC syscall.BpfTimeout from syscall/bpf_bsd.go:
func bpfTimeout(fd int) Object {
	_res1, _res2 := _syscall.BpfTimeout(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BytePtrFromString from syscall/syscall.go:
func bytePtrFromString(s string) Object {
	_res1, _res2 := _syscall.BytePtrFromString(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ByteSliceFromString from syscall/syscall.go:
func byteSliceFromString(s string) Object {
	_res1, _res2 := _syscall.ByteSliceFromString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Clearenv from syscall/env_unix.go:
// func clearenv() Object {
// 	_syscall.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.CloseOnExec from syscall/exec_unix.go:
// func closeOnExec(fd int) Object {
// 	_syscall.CloseOnExec(fd)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Dup from syscall/zsyscall_darwin_amd64.go:
func dup(fd int) Object {
	nfd, err := _syscall.Dup(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Environ from syscall/env_unix.go:
func environ() Object {
	_res := _syscall.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC syscall.Exec from syscall/exec_unix.go:
// func exec(argv0 string, argv []string, envv []string)  {
// 	_res := _syscall.Exec(argv0, argv, envv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Exit from syscall/syscall.go:
// func exit(code int) Object {
// 	_syscall.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.FcntlFlock from syscall/flock.go:
// func fcntlFlock(fd uintptr, cmd int, lk *_syscall.Flock_t)  {
// 	_res := _syscall.FcntlFlock(fd, cmd, lk)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.ForkExec from syscall/exec_unix.go:
// func forkExec(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, err := _syscall.ForkExec(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Fpathconf from syscall/zsyscall_darwin_amd64.go:
func fpathconf(fd int, name int) Object {
	val, err := _syscall.Fpathconf(fd, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(val))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Fstat from syscall/zsyscall_darwin_amd64.go:
// func fstat(fd int, stat *_syscall.Stat_t)  {
// 	_res := _syscall.Fstat(fd, stat)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Fstatfs from syscall/zsyscall_darwin_amd64.go:
// func fstatfs(fd int, stat *_syscall.Statfs_t)  {
// 	_res := _syscall.Fstatfs(fd, stat)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Futimes from syscall/syscall_bsd.go:
// func futimes(fd int, tv []_syscall.Timeval)  {
// 	_res := _syscall.Futimes(fd, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getdirentries from syscall/zsyscall_darwin_amd64.go:
// func getdirentries(fd int, buf []byte, basep *uintptr) Object {
// 	n, err := _syscall.Getdirentries(fd, buf, basep)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getenv from syscall/env_unix.go:
func getenv(key string) Object {
	value, found := _syscall.Getenv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(MakeBool(found))
	return _res
}

GO FUNC syscall.Getfsstat from syscall/syscall_darwin.go:
// func getfsstat(buf []_syscall.Statfs_t, flags int) Object {
// 	n, err := _syscall.Getfsstat(buf, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getgroups from syscall/syscall_bsd.go:
func getgroups() Object {
	gids, err := _syscall.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range gids {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpeername from syscall/syscall_unix.go:
func getpeername(fd int) Object {
	sa, err := _syscall.Getpeername(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpgid from syscall/zsyscall_darwin_amd64.go:
func getpgid(pid int) Object {
	pgid, err := _syscall.Getpgid(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pgid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpriority from syscall/zsyscall_darwin_amd64.go:
func getpriority(which int, who int) Object {
	prio, err := _syscall.Getpriority(which, who)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(prio))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getrlimit from syscall/zsyscall_darwin_amd64.go:
// func getrlimit(which int, lim *_syscall.Rlimit)  {
// 	_res := _syscall.Getrlimit(which, lim)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getrusage from syscall/zsyscall_darwin_amd64.go:
// func getrusage(who int, rusage *_syscall.Rusage)  {
// 	_res := _syscall.Getrusage(who, rusage)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getsid from syscall/zsyscall_darwin_amd64.go:
func getsid(pid int) Object {
	sid, err := _syscall.Getsid(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(sid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getsockname from syscall/syscall_bsd.go:
func getsockname(fd int) Object {
	sa, err := _syscall.Getsockname(fd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptByte from syscall/syscall_bsd.go:
func getsockoptByte(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptByte(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(value)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_bsd.go:
func getsockoptICMPv6Filter(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptICMPv6Filter(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreq from syscall/syscall_bsd.go:
func getsockoptIPMreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreq(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_bsd.go:
func getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_bsd.go:
func getsockoptIPv6Mreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6Mreq(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptInet4Addr from syscall/syscall_bsd.go:
func getsockoptInet4Addr(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInet4Addr(fd, level, opt)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range value {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
func getsockoptInt(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInt(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Gettimeofday from syscall/syscall_darwin_amd64.go:
// func gettimeofday(tv *_syscall.Timeval)  {
// 	_res := _syscall.Gettimeofday(tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getwd from syscall/syscall_darwin.go:
func getwd() Object {
	_res1, _res2 := _syscall.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Kevent from syscall/syscall_bsd.go:
// func kevent(kq int, changes []_syscall.Kevent_t, events []_syscall.Kevent_t, timeout *_syscall.Timespec) Object {
// 	n, err := _syscall.Kevent(kq, changes, events, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Kqueue from syscall/zsyscall_darwin_amd64.go:
func kqueue() Object {
	fd, err := _syscall.Kqueue()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Lstat from syscall/zsyscall_darwin_amd64.go:
// func lstat(path string, stat *_syscall.Stat_t)  {
// 	_res := _syscall.Lstat(path, stat)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Mlock from syscall/zsyscall_darwin_amd64.go:
// func mlock(b []byte)  {
// 	_res := _syscall.Mlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Mmap from syscall/syscall_bsd.go:
func mmap(fd int, offset int64, length int, prot int, flags int) Object {
	data, err := _syscall.Mmap(fd, offset, length, prot, flags)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range data {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Mprotect from syscall/zsyscall_darwin_amd64.go:
// func mprotect(b []byte, prot int)  {
// 	_res := _syscall.Mprotect(b, prot)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munlock from syscall/zsyscall_darwin_amd64.go:
// func munlock(b []byte)  {
// 	_res := _syscall.Munlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munmap from syscall/syscall_bsd.go:
// func munmap(b []byte)  {
// 	_res := _syscall.Munmap(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.NsecToTimespec from syscall/timestruct.go:
func nsecToTimespec(nsec int64) Object {
	_res := _syscall.NsecToTimespec(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.NsecToTimeval from syscall/timestruct.go:
func nsecToTimeval(nsec int64) Object {
	_res := _syscall.NsecToTimeval(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.Open from syscall/zsyscall_darwin_amd64.go:
func open(path string, mode int, perm uint32) Object {
	fd, err := _syscall.Open(path, mode, perm)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.ParseDirent from syscall/dirent.go:
// func parseDirent(buf []byte, max int, names []string) Object {
// 	consumed, count, newnames := _syscall.ParseDirent(buf, max, names)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(consumed))
// 	_res = _res.Conjoin(MakeInt(count))
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range newnames {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC syscall.ParseRoutingMessage from syscall/route_bsd.go:
// func parseRoutingMessage(b []byte) Object {
// 	msgs, err := _syscall.ParseRoutingMessage(b)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range msgs {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.ParseRoutingSockaddr from syscall/route_bsd.go:
func parseRoutingSockaddr(msg _syscall.RoutingMessage) Object {
	_res1, _res2 := _syscall.ParseRoutingSockaddr(msg)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
// func parseSocketControlMessage(b []byte) Object {
// 	_res1, _res2 := _syscall.ParseSocketControlMessage(b)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
// func parseUnixRights(m *_syscall.SocketControlMessage) Object {
// 	_res1, _res2 := _syscall.ParseUnixRights(m)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.Pathconf from syscall/zsyscall_darwin_amd64.go:
func pathconf(path string, name int) Object {
	val, err := _syscall.Pathconf(path, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(val))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Pipe from syscall/syscall_darwin.go:
// func pipe(p []int)  {
// 	_res := _syscall.Pipe(p)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Pread from syscall/zsyscall_darwin_amd64.go:
// func pread(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pread(fd, p, offset)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Pwrite from syscall/zsyscall_darwin_amd64.go:
// func pwrite(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pwrite(fd, p, offset)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.RawSyscall from syscall/syscall_unix.go:
// func rawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall(trap, a1, a2, a3)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
// func rawSyscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Read from syscall/syscall_unix.go:
// func read(fd int, p []byte) Object {
// 	n, err := _syscall.Read(fd, p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.ReadDirent from syscall/syscall_bsd.go:
// func readDirent(fd int, buf []byte) Object {
// 	n, err := _syscall.ReadDirent(fd, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Readlink from syscall/zsyscall_darwin_amd64.go:
// func readlink(path string, buf []byte) Object {
// 	n, err := _syscall.Readlink(path, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvfrom from syscall/syscall_unix.go:
// func recvfrom(fd int, p []byte, flags int) Object {
// 	n, from, err := _syscall.Recvfrom(fd, p, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvmsg from syscall/syscall_bsd.go:
// func recvmsg(fd int, p []byte, oob []byte, flags int) Object {
// 	n, oobn, recvflags, from, err := _syscall.Recvmsg(fd, p, oob, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeInt(oobn))
// 	_res = _res.Conjoin(MakeInt(recvflags))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.RouteRIB from syscall/route_bsd.go:
func routeRIB(facility int, param int) Object {
	_res1, _res2 := _syscall.RouteRIB(facility, param)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Seek from syscall/zsyscall_darwin_amd64.go:
func seek(fd int, offset int64, whence int) Object {
	newoffset, err := _syscall.Seek(fd, offset, whence)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(newoffset)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Select from syscall/zsyscall_darwin_amd64.go:
// func _select(n int, r *_syscall.FdSet, w *_syscall.FdSet, e *_syscall.FdSet, timeout *_syscall.Timeval)  {
// 	_res := _syscall.Select(n, r, w, e, timeout)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Sendfile from syscall/syscall_unix.go:
// func sendfile(outfd int, infd int, offset *int64, count int) Object {
// 	written, err := _syscall.Sendfile(outfd, infd, offset, count)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(written))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendmsg from syscall/syscall_bsd.go:
// func sendmsg(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int)  {
// 	_res := _syscall.Sendmsg(fd, p, oob, to, flags)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SendmsgN from syscall/syscall_bsd.go:
// func sendmsgN(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int) Object {
// 	n, err := _syscall.SendmsgN(fd, p, oob, to, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendto from syscall/syscall_unix.go:
// func sendto(fd int, p []byte, flags int, to _syscall.Sockaddr)  {
// 	_res := _syscall.Sendto(fd, p, flags, to)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetBpf from syscall/bpf_bsd.go:
// func setBpf(fd int, i []_syscall.BpfInsn)  {
// 	_res := _syscall.SetBpf(fd, i)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetBpfBuflen from syscall/bpf_bsd.go:
func setBpfBuflen(fd int, l int) Object {
	_res1, _res2 := _syscall.SetBpfBuflen(fd, l)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.SetBpfDatalink from syscall/bpf_bsd.go:
func setBpfDatalink(fd int, t int) Object {
	_res1, _res2 := _syscall.SetBpfDatalink(fd, t)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.SetBpfTimeout from syscall/bpf_bsd.go:
// func setBpfTimeout(fd int, tv *_syscall.Timeval)  {
// 	_res := _syscall.SetBpfTimeout(fd, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetKevent from syscall/syscall_darwin_amd64.go:
// func setKevent(k *_syscall.Kevent_t, fd int, mode int, flags int) Object {
// 	_syscall.SetKevent(k, fd, mode, flags)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Setgroups from syscall/syscall_bsd.go:
// func setgroups(gids []int)  {
// 	_res := _syscall.Setgroups(gids)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setrlimit from syscall/zsyscall_darwin_amd64.go:
// func setrlimit(which int, lim *_syscall.Rlimit)  {
// 	_res := _syscall.Setrlimit(which, lim)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setsid from syscall/zsyscall_darwin_amd64.go:
func setsid() Object {
	pid, err := _syscall.Setsid()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SetsockoptICMPv6Filter from syscall/syscall_unix.go:
// func setsockoptICMPv6Filter(fd int, level int, opt int, filter *_syscall.ICMPv6Filter)  {
// 	_res := _syscall.SetsockoptICMPv6Filter(fd, level, opt, filter)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetsockoptIPMreq from syscall/syscall_unix.go:
// func setsockoptIPMreq(fd int, level int, opt int, mreq *_syscall.IPMreq)  {
// 	_res := _syscall.SetsockoptIPMreq(fd, level, opt, mreq)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetsockoptIPv6Mreq from syscall/syscall_unix.go:
// func setsockoptIPv6Mreq(fd int, level int, opt int, mreq *_syscall.IPv6Mreq)  {
// 	_res := _syscall.SetsockoptIPv6Mreq(fd, level, opt, mreq)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
// func setsockoptInet4Addr(fd int, level int, opt int, value []byte)  {
// 	_res := _syscall.SetsockoptInet4Addr(fd, level, opt, value)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetsockoptLinger from syscall/syscall_unix.go:
// func setsockoptLinger(fd int, level int, opt int, l *_syscall.Linger)  {
// 	_res := _syscall.SetsockoptLinger(fd, level, opt, l)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetsockoptTimeval from syscall/syscall_unix.go:
// func setsockoptTimeval(fd int, level int, opt int, tv *_syscall.Timeval)  {
// 	_res := _syscall.SetsockoptTimeval(fd, level, opt, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Settimeofday from syscall/zsyscall_darwin_amd64.go:
// func settimeofday(tp *_syscall.Timeval)  {
// 	_res := _syscall.Settimeofday(tp)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
// func slicePtrFromStrings(ss []string) Object {
// 	_res1, _res2 := _syscall.SlicePtrFromStrings(ss)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.Socket from syscall/syscall_unix.go:
func socket(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socket(domain, typ, proto)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Socketpair from syscall/syscall_unix.go:
func socketpair(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socketpair(domain, typ, proto)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range fd {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.StartProcess from syscall/exec_unix.go:
// func startProcess(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, handle, err := _syscall.StartProcess(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(handle)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Stat from syscall/zsyscall_darwin_amd64.go:
// func stat(path string, stat *_syscall.Stat_t)  {
// 	_res := _syscall.Stat(path, stat)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Statfs from syscall/zsyscall_darwin_amd64.go:
// func statfs(path string, stat *_syscall.Statfs_t)  {
// 	_res := _syscall.Statfs(path, stat)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.StringBytePtr from syscall/syscall.go:
func stringBytePtr(s string) Object {
	_res := _syscall.StringBytePtr(s)
	return MakeGoObject(_res)
}

GO FUNC syscall.StringByteSlice from syscall/syscall.go:
func stringByteSlice(s string) Object {
	_res := _syscall.StringByteSlice(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
// func stringSlicePtr(ss []string) Object {
// 	_res := _syscall.StringSlicePtr(ss)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Syscall from syscall/syscall_unix.go:
// func syscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall(trap, a1, a2, a3)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Syscall6 from syscall/syscall_unix.go:
// func syscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Syscall9 from syscall/syscall_darwin_amd64.go:
// func syscall9(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Sysctl from syscall/syscall_bsd.go:
func sysctl(name string) Object {
	value, err := _syscall.Sysctl(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SysctlUint32 from syscall/syscall_bsd.go:
func sysctlUint32(name string) Object {
	value, err := _syscall.SysctlUint32(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(value)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.TimespecToNsec from syscall/timestruct.go:
func timespecToNsec(ts _syscall.Timespec) Object {
	_res := _syscall.TimespecToNsec(ts)
	return MakeInt(int(_res))
}

GO FUNC syscall.TimevalToNsec from syscall/timestruct.go:
func timevalToNsec(tv _syscall.Timeval) Object {
	_res := _syscall.TimevalToNsec(tv)
	return MakeInt(int(_res))
}

GO FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
// func unixRights(fds ...int) Object {
// 	_res := _syscall.UnixRights(fds)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Utimes from syscall/syscall_bsd.go:
// func utimes(path string, tv []_syscall.Timeval)  {
// 	_res := _syscall.Utimes(path, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.UtimesNano from syscall/syscall_bsd.go:
// func utimesNano(path string, ts []_syscall.Timespec)  {
// 	_res := _syscall.UtimesNano(path, ts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Wait4 from syscall/syscall_bsd.go:
// func wait4(pid int, wstatus *_syscall.WaitStatus, options int, rusage *_syscall.Rusage) Object {
// 	wpid, err := _syscall.Wait4(pid, wstatus, options, rusage)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(wpid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Write from syscall/syscall_unix.go:
// func write(fd int, p []byte) Object {
// 	n, err := _syscall.Write(fd, p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syscall

import (
	_syscall "syscall"
	. "github.com/candid82/joker/core"
)
GO FUNC testing.AllocsPerRun from testing/allocs.go:
// func allocsPerRun(runs int, f func) Object {
// 	return _testing.AllocsPerRun(runs, f)
// }

GO FUNC testing.Benchmark from testing/benchmark.go:
// func benchmark(f func) Object {
// 	_res := _testing.Benchmark(f)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.Coverage from testing/cover.go:
// func coverage() Object {
// 	return _testing.Coverage()
// }

GO FUNC testing.Main from testing/testing.go:
// func main(matchString func, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND675: TODO...
// }

GO FUNC testing.MainStart from testing/testing.go:
// func mainStart(deps testDeps, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_res := _testing.MainStart(deps, tests, benchmarks, examples)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.RegisterCover from testing/cover.go:
// func registerCover(c _testing.Cover) Object {
// 	_testing.RegisterCover(c)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunBenchmarks from testing/benchmark.go:
// func runBenchmarks(matchString func, benchmarks []_testing.InternalBenchmark) Object {
// 	_testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunExamples from testing/example.go:
// func runExamples(matchString func, examples []_testing.InternalExample)  {
// 	_res := _testing.RunExamples(matchString, examples)
// 	return MakeBool(_res)
// }

GO FUNC testing.RunTests from testing/testing.go:
// func runTests(matchString func, tests []_testing.InternalTest)  {
// 	_res := _testing.RunTests(matchString, tests)
// 	return MakeBool(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package testing

import (
)
GO FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
// func dataErrReader(r io.Reader) Object {
// 	_res := _iotest.DataErrReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
// func halfReader(r io.Reader) Object {
// 	_res := _iotest.HalfReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
// func newReadLogger(prefix string, r io.Reader) Object {
// 	_res := _iotest.NewReadLogger(prefix, r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
// func newWriteLogger(prefix string, w io.Writer) Object {
// 	_res := _iotest.NewWriteLogger(prefix, w)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
// func oneByteReader(r io.Reader) Object {
// 	_res := _iotest.OneByteReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
// func timeoutReader(r io.Reader) Object {
// 	_res := _iotest.TimeoutReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
// func truncateWriter(w io.Writer, n int64) Object {
// 	_res := _iotest.TruncateWriter(w, n)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/quick.Check from testing/quick/quick.go:
// func check(f interface {}, config *_quick.Config)  {
// 	_res := _quick.Check(f, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.CheckEqual from testing/quick/quick.go:
// func checkEqual(f interface {}, g interface {}, config *_quick.Config)  {
// 	_res := _quick.CheckEqual(f, g, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.Value from testing/quick/quick.go:
// func value(t reflect.Type, rand *rand.Rand) Object {
// 	value, ok := _quick.Value(t, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(value))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC text/scanner.TokenString from text/scanner/scanner.go:
// func tokenString(tok rune)  {
// 	_res := _scanner.TokenString(tok)
// 	return MakeString(_res)
// }

GO FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
// func newWriter(output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint) Object {
// 	_res := _tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template.HTMLEscape from text/template/funcs.go:
// func hTMLEscape(w io.Writer, b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.HTMLEscaper from text/template/funcs.go:
// func hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.IsTrue from text/template/exec.go:
// func isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(truth))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC text/template.JSEscape from text/template/funcs.go:
// func jSEscape(w io.Writer, b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.JSEscaper from text/template/funcs.go:
// func jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.Must from text/template/helper.go:
// func must(t *_template.Template, err error) Object {
// 	_res := _template.Must(t, err)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template.New from text/template/template.go:
func _new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC text/template.ParseFiles from text/template/helper.go:
// func parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC text/template.ParseGlob from text/template/helper.go:
func parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.URLQueryEscaper from text/template/funcs.go:
// func uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	_template "text/template"
	. "github.com/candid82/joker/core"
)
GO FUNC text/template/parse.New from text/template/parse/parse.go:
// func _new(name string, funcs ...map[]) Object {
// 	_res := _parse.New(name, funcs)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
func newIdentifier(ident string) Object {
	_res := _parse.NewIdentifier(ident)
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.Parse from text/template/parse/parse.go:
// func parse(name string, text string, leftDelim string, rightDelim string, funcs ...map[]) Object {
// 	_res1, _res2 := _parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parse

import (
	_parse "text/template/parse"
	. "github.com/candid82/joker/core"
)
GO FUNC time.After from time/sleep.go:
// func after(d _time.Duration) Object {
// 	return _time.After(d)
// }

GO FUNC time.AfterFunc from time/sleep.go:
// func afterFunc(d _time.Duration, f func) Object {
// 	_res := _time.AfterFunc(d, f)
// 	return MakeGoObject(_res)
// }

GO FUNC time.Date from time/time.go:
// func date(year int, month _time.Month, day int, hour int, min int, sec int, nsec int, loc *_time.Location) Object {
// 	_res := _time.Date(year, month, day, hour, min, sec, nsec, loc)
// 	return MakeGoObject(_res)
// }

GO FUNC time.FixedZone from time/zoneinfo.go:
func fixedZone(name string, offset int) Object {
	_res := _time.FixedZone(name, offset)
	return MakeGoObject(_res)
}

GO FUNC time.LoadLocation from time/zoneinfo.go:
func loadLocation(name string) Object {
	_res1, _res2 := _time.LoadLocation(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
// func loadLocationFromTZData(name string, data []byte) Object {
// 	_res1, _res2 := _time.LoadLocationFromTZData(name, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.NewTicker from time/tick.go:
func newTicker(d _time.Duration) Object {
	_res := _time.NewTicker(d)
	return MakeGoObject(_res)
}

GO FUNC time.NewTimer from time/sleep.go:
func newTimer(d _time.Duration) Object {
	_res := _time.NewTimer(d)
	return MakeGoObject(_res)
}

GO FUNC time.Now from time/time.go:
func now() Object {
	_res := _time.Now()
	return MakeGoObject(_res)
}

GO FUNC time.Parse from time/format.go:
func parse(layout string, value string) Object {
	_res1, _res2 := _time.Parse(layout, value)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseDuration from time/format.go:
func parseDuration(s string) Object {
	_res1, _res2 := _time.ParseDuration(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseInLocation from time/format.go:
// func parseInLocation(layout string, value string, loc *_time.Location) Object {
// 	_res1, _res2 := _time.ParseInLocation(layout, value, loc)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.Since from time/time.go:
func since(t _time.Time) Object {
	_res := _time.Since(t)
	return MakeGoObject(_res)
}

GO FUNC time.Sleep from time/sleep.go:
// func sleep(d _time.Duration) Object {
// 	_time.Sleep(d)
// 	...ABEND675: TODO...
// }

GO FUNC time.Tick from time/tick.go:
// func tick(d _time.Duration) Object {
// 	return _time.Tick(d)
// }

GO FUNC time.Unix from time/time.go:
func unix(sec int64, nsec int64) Object {
	_res := _time.Unix(sec, nsec)
	return MakeGoObject(_res)
}

GO FUNC time.Until from time/time.go:
func until(t _time.Time) Object {
	_res := _time.Until(t)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package time

import (
	_time "time"
	. "github.com/candid82/joker/core"
)
GO FUNC unicode.In from unicode/graphic.go:
// func in(r rune, ranges ...*_unicode.RangeTable)  {
// 	_res := _unicode.In(r, ranges)
// 	return MakeBool(_res)
// }

GO FUNC unicode.Is from unicode/letter.go:
// func is(rangeTab *_unicode.RangeTable, r rune)  {
// 	_res := _unicode.Is(rangeTab, r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsControl from unicode/graphic.go:
// func isControl(r rune)  {
// 	_res := _unicode.IsControl(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsDigit from unicode/digit.go:
// func isDigit(r rune)  {
// 	_res := _unicode.IsDigit(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsGraphic from unicode/graphic.go:
// func isGraphic(r rune)  {
// 	_res := _unicode.IsGraphic(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsLetter from unicode/graphic.go:
// func isLetter(r rune)  {
// 	_res := _unicode.IsLetter(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsLower from unicode/letter.go:
// func isLower(r rune)  {
// 	_res := _unicode.IsLower(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsMark from unicode/graphic.go:
// func isMark(r rune)  {
// 	_res := _unicode.IsMark(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsNumber from unicode/graphic.go:
// func isNumber(r rune)  {
// 	_res := _unicode.IsNumber(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsOneOf from unicode/graphic.go:
// func isOneOf(ranges []*_unicode.RangeTable, r rune)  {
// 	_res := _unicode.IsOneOf(ranges, r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsPrint from unicode/graphic.go:
// func isPrint(r rune)  {
// 	_res := _unicode.IsPrint(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsPunct from unicode/graphic.go:
// func isPunct(r rune)  {
// 	_res := _unicode.IsPunct(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsSpace from unicode/graphic.go:
// func isSpace(r rune)  {
// 	_res := _unicode.IsSpace(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsSymbol from unicode/graphic.go:
// func isSymbol(r rune)  {
// 	_res := _unicode.IsSymbol(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsTitle from unicode/letter.go:
// func isTitle(r rune)  {
// 	_res := _unicode.IsTitle(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.IsUpper from unicode/letter.go:
// func isUpper(r rune)  {
// 	_res := _unicode.IsUpper(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode.SimpleFold from unicode/letter.go:
// func simpleFold(r rune) Object {
// 	return _unicode.SimpleFold(r)
// }

GO FUNC unicode.To from unicode/letter.go:
// func to(_case int, r rune) Object {
// 	return _unicode.To(_case, r)
// }

GO FUNC unicode.ToLower from unicode/letter.go:
// func toLower(r rune) Object {
// 	return _unicode.ToLower(r)
// }

GO FUNC unicode.ToTitle from unicode/letter.go:
// func toTitle(r rune) Object {
// 	return _unicode.ToTitle(r)
// }

GO FUNC unicode.ToUpper from unicode/letter.go:
// func toUpper(r rune) Object {
// 	return _unicode.ToUpper(r)
// }

GO FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
// func decode(s []uint16) Object {
// 	_res := _utf16.Decode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
// func decodeRune(r1 rune, r2 rune) Object {
// 	return _utf16.DecodeRune(r1, r2)
// }

GO FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
// func encode(s []rune) Object {
// 	_res := _utf16.Encode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
// func encodeRune(r rune) Object {
// 	r1, r2 := _utf16.EncodeRune(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	return _res
// }

GO FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
// func isSurrogate(r rune)  {
// 	_res := _utf16.IsSurrogate(r)
// 	return MakeBool(_res)
// }

GO FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
// func decodeLastRune(p []byte) Object {
// 	r, size := _utf8.DecodeLastRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
// func decodeLastRuneInString(s string) Object {
// 	r, size := _utf8.DecodeLastRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
// func decodeRune(p []byte) Object {
// 	r, size := _utf8.DecodeRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
// func decodeRuneInString(s string) Object {
// 	r, size := _utf8.DecodeRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
// func encodeRune(p []byte, r rune)  {
// 	_res := _utf8.EncodeRune(p, r)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
// func fullRune(p []byte)  {
// 	_res := _utf8.FullRune(p)
// 	return MakeBool(_res)
// }

GO FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
// func runeCount(p []byte)  {
// 	_res := _utf8.RuneCount(p)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
// func runeLen(r rune)  {
// 	_res := _utf8.RuneLen(r)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
// func valid(p []byte)  {
// 	_res := _utf8.Valid(p)
// 	return MakeBool(_res)
// }

GO FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
// func validRune(r rune)  {
// 	_res := _utf8.ValidRune(r)
// 	return MakeBool(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package utf8

import (
)
GO FUNC unsafe.Alignof from unsafe/unsafe.go:
// func alignof(x _unsafe.ArbitraryType) Object {
// 	return _unsafe.Alignof(x)
// }

GO FUNC unsafe.Offsetof from unsafe/unsafe.go:
// func offsetof(x _unsafe.ArbitraryType) Object {
// 	return _unsafe.Offsetof(x)
// }

GO FUNC unsafe.Sizeof from unsafe/unsafe.go:
// func sizeof(x _unsafe.ArbitraryType) Object {
// 	return _unsafe.Sizeof(x)
// }

ABENDs: 987(305) 902(282) 044(244) 903(191) 043(163) 675(129) 907(85) 906(42) 885(16) 883(12) 905(12) 908(6) 909(2) 901(1)
Totals: types=957 functions=7096 methods=5623 (79.24%) standalone=1473 (20.76%) generated=572 (38.83%)
