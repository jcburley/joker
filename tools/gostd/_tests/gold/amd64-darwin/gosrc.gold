Walking from /usr/local/go/src to /usr/local/go/src/archive
Processing archive:
Walking from /usr/local/go/src to /usr/local/go/src/archive/tar
Processing archive/tar:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/archive/tar/stat_actime2.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/format.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/writer.go) => true <nil>
Ignoring test code in tar_test.go
Matchfile(/usr/local/go/src/archive/tar/common.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/stat_unix.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/archive/tar/strconv.go) => true <nil>
Matchfile(/usr/local/go/src/archive/tar/stat_actime1.go) => false <nil>
Ignoring test code in strconv_test.go
Processing package=archive/tar:
Excluding /usr/local/go/src/archive/tar/testdata
Walking from /usr/local/go/src to /usr/local/go/src/archive/zip
Processing archive/zip:
Matchfile(/usr/local/go/src/archive/zip/register.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in zip_test.go
Matchfile(/usr/local/go/src/archive/zip/writer.go) => true <nil>
Matchfile(/usr/local/go/src/archive/zip/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/archive/zip/struct.go) => true <nil>
Processing package=archive/zip:
Excluding /usr/local/go/src/archive/zip/testdata
Walking from /usr/local/go/src to /usr/local/go/src/bufio
Processing bufio:
Ignoring test code in example_test.go
Ignoring test code in bufio_test.go
Matchfile(/usr/local/go/src/bufio/scan.go) => true <nil>
Matchfile(/usr/local/go/src/bufio/bufio.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in scan_test.go
Processing package=bufio:
Excluding /usr/local/go/src/builtin
Walking from /usr/local/go/src to /usr/local/go/src/bytes
Processing bytes:
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Ignoring test code in boundary_test.go
Ignoring test code in buffer_test.go
Matchfile(/usr/local/go/src/bytes/buffer.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/bytes/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/bytes/bytes.go) => true <nil>
Ignoring test code in bytes_test.go
Processing package=bytes:
Excluding /usr/local/go/src/cmd
Walking from /usr/local/go/src to /usr/local/go/src/compress
Processing compress:
Walking from /usr/local/go/src to /usr/local/go/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(/usr/local/go/src/compress/bzip2/huffman.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(/usr/local/go/src/compress/bzip2/bit_reader.go) => true <nil>
Processing package=compress/bzip2:
Excluding /usr/local/go/src/compress/bzip2/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/flate
Processing compress/flate:
Ignoring test code in flate_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/compress/flate/token.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/compress/flate/inflate.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/deflate.go) => true <nil>
Ignoring test code in huffman_bit_writer_test.go
Ignoring test code in dict_decoder_test.go
Ignoring test code in deflate_test.go
Matchfile(/usr/local/go/src/compress/flate/deflatefast.go) => true <nil>
Ignoring test code in inflate_test.go
Matchfile(/usr/local/go/src/compress/flate/huffman_bit_writer.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/compress/flate/dict_decoder.go) => true <nil>
Matchfile(/usr/local/go/src/compress/flate/huffman_code.go) => true <nil>
Processing package=compress/flate:
Excluding /usr/local/go/src/compress/flate/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/gzip
Processing compress/gzip:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/compress/gzip/gzip.go) => true <nil>
Matchfile(/usr/local/go/src/compress/gzip/gunzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Ignoring test code in gunzip_test.go
Processing package=compress/gzip:
Excluding /usr/local/go/src/compress/gzip/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/lzw
Processing compress/lzw:
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/compress/lzw/writer.go) => true <nil>
Matchfile(/usr/local/go/src/compress/lzw/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=compress/lzw:
Excluding /usr/local/go/src/compress/testdata
Walking from /usr/local/go/src to /usr/local/go/src/compress/zlib
Processing compress/zlib:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/compress/zlib/writer.go) => true <nil>
Matchfile(/usr/local/go/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=compress/zlib:
Walking from /usr/local/go/src to /usr/local/go/src/container
Processing container:
Walking from /usr/local/go/src to /usr/local/go/src/container/heap
Processing container/heap:
Matchfile(/usr/local/go/src/container/heap/heap.go) => true <nil>
Ignoring test code in example_pq_test.go
Ignoring test code in example_intheap_test.go
Ignoring test code in heap_test.go
Processing package=container/heap:
Walking from /usr/local/go/src to /usr/local/go/src/container/list
Processing container/list:
Matchfile(/usr/local/go/src/container/list/list.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in list_test.go
Processing package=container/list:
Walking from /usr/local/go/src to /usr/local/go/src/container/ring
Processing container/ring:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/container/ring/ring.go) => true <nil>
Ignoring test code in ring_test.go
Processing package=container/ring:
Walking from /usr/local/go/src to /usr/local/go/src/context
Processing context:
Ignoring test code in example_test.go
Ignoring test code in net_test.go
Ignoring test code in context_test.go
Matchfile(/usr/local/go/src/context/context.go) => true <nil>
Ignoring test code in x_test.go
Ignoring test code in benchmark_test.go
Processing package=context:
Walking from /usr/local/go/src to /usr/local/go/src/crypto
Processing crypto:
Ignoring test code in issue21104_test.go
Matchfile(/usr/local/go/src/crypto/crypto.go) => true <nil>
Processing package=crypto:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/aes
Processing crypto/aes:
Matchfile(/usr/local/go/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/ctr_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/aes_gcm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/modes.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_generic.go) => false <nil>
Ignoring test code in modes_test.go
Ignoring test code in aes_test.go
Matchfile(/usr/local/go/src/crypto/aes/cipher.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/const.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/aes/block.go) => true <nil>
Processing package=crypto/aes:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/cipher
Processing crypto/cipher:
Matchfile(/usr/local/go/src/crypto/cipher/cfb.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/cbc.go) => true <nil>
Ignoring test code in ctr_aes_test.go
Ignoring test code in xor_test.go
Matchfile(/usr/local/go/src/crypto/cipher/ofb.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in ctr_test.go
Matchfile(/usr/local/go/src/crypto/cipher/xor_ppc64x.go) => false <nil>
Ignoring test code in cipher_test.go
Ignoring test code in cbc_aes_test.go
Ignoring test code in gcm_test.go
Matchfile(/usr/local/go/src/crypto/cipher/io.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/xor_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/cipher/xor_amd64.go) => true <nil>
Ignoring test code in common_test.go
Ignoring test code in cfb_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/crypto/cipher/ctr.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/cipher.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in benchmark_test.go
Ignoring test code in ofb_test.go
Processing package=crypto/cipher:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Ignoring test code in des_test.go
Matchfile(/usr/local/go/src/crypto/des/cipher.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/des/const.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/des/block.go) => true <nil>
Processing package=crypto/des:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/dsa
Processing crypto/dsa:
Ignoring test code in dsa_test.go
Matchfile(/usr/local/go/src/crypto/dsa/dsa.go) => true <nil>
Processing package=crypto/dsa:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in example_test.go
Ignoring test code in ecdsa_test.go
Matchfile(/usr/local/go/src/crypto/ecdsa/ecdsa.go) => true <nil>
Processing package=crypto/ecdsa:
Excluding /usr/local/go/src/crypto/ecdsa/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(/usr/local/go/src/crypto/elliptic/p224.go) => true <nil>
Ignoring test code in fuzz_test.go
Ignoring test code in p224_test.go
Matchfile(/usr/local/go/src/crypto/elliptic/elliptic.go) => true <nil>
Ignoring test code in elliptic_test.go
Matchfile(/usr/local/go/src/crypto/elliptic/p256_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/elliptic/p256_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/elliptic/p256.go) => false <nil>
Processing package=crypto/elliptic:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/hmac
Processing crypto/hmac:
Ignoring test code in hmac_test.go
Matchfile(/usr/local/go/src/crypto/hmac/hmac.go) => true <nil>
Processing package=crypto/hmac:
Excluding /usr/local/go/src/crypto/internal
Walking from /usr/local/go/src to /usr/local/go/src/crypto/md5
Processing crypto/md5:
Matchfile(/usr/local/go/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/md5/gen.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/md5/md5block.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/md5/md5block_generic.go) => false <nil>
Ignoring test code in md5_test.go
Matchfile(/usr/local/go/src/crypto/md5/md5.go) => true <nil>
Processing package=crypto/md5:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rand
Processing crypto/rand:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_unix.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_openbsd.go) => false <nil>
Ignoring test code in util_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_freebsd.go) => false <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/crypto/rand/util.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_batched.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_js.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand_linux.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/rand/rand.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rand/eagain.go) => true <nil>
Ignoring test code in rand_batched_test.go
Matchfile(/usr/local/go/src/crypto/rand/rand_windows.go) => false <nil>
Processing package=crypto/rand:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rc4
Processing crypto/rc4:
Ignoring test code in rc4_test.go
Matchfile(/usr/local/go/src/crypto/rc4/rc4.go) => true <nil>
Processing package=crypto/rc4:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/rsa
Processing crypto/rsa:
Ignoring test code in pkcs1v15_test.go
Ignoring test code in example_test.go
Ignoring test code in pss_test.go
Ignoring test code in rsa_test.go
Matchfile(/usr/local/go/src/crypto/rsa/rsa.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rsa/pkcs1v15.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/rsa/pss.go) => true <nil>
Processing package=crypto/rsa:
Excluding /usr/local/go/src/crypto/rsa/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha1
Processing crypto/sha1:
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1block.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in sha1_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_decl.go) => false <nil>
Ignoring test code in issue15617_test.go
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Processing package=crypto/sha1:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha256
Processing crypto/sha256:
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_generic.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_decl.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/crypto/sha256/sha256.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Ignoring test code in sha256_test.go
Matchfile(/usr/local/go/src/crypto/sha256/sha256block.go) => true <nil>
Processing package=crypto/sha256:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/sha512
Processing crypto/sha512:
Ignoring test code in fallback_test.go
Matchfile(/usr/local/go/src/crypto/sha512/sha512.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_decl.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Ignoring test code in sha512_test.go
Matchfile(/usr/local/go/src/crypto/sha512/sha512block_generic.go) => false <nil>
Processing package=crypto/sha512:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/subtle
Processing crypto/subtle:
Ignoring test code in constant_time_test.go
Matchfile(/usr/local/go/src/crypto/subtle/constant_time.go) => true <nil>
Processing package=crypto/subtle:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/tls
Processing crypto/tls:
Ignoring test code in example_test.go
Ignoring test code in handshake_test.go
Ignoring test code in handshake_messages_test.go
Matchfile(/usr/local/go/src/crypto/tls/ticket.go) => true <nil>
Ignoring test code in auth_test.go
Matchfile(/usr/local/go/src/crypto/tls/handshake_client.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in prf_test.go
Matchfile(/usr/local/go/src/crypto/tls/key_schedule.go) => true <nil>
Ignoring test code in handshake_server_test.go
Matchfile(/usr/local/go/src/crypto/tls/prf.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/handshake_server_tls13.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/handshake_server.go) => true <nil>
Ignoring test code in handshake_client_test.go
Matchfile(/usr/local/go/src/crypto/tls/handshake_messages.go) => true <nil>
Ignoring test code in key_schedule_test.go
Matchfile(/usr/local/go/src/crypto/tls/common.go) => true <nil>
Ignoring test code in conn_test.go
Matchfile(/usr/local/go/src/crypto/tls/key_agreement.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/cipher_suites.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/tls.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/alert.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/handshake_client_tls13.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/tls/generate_cert.go) => false <nil>
Ignoring test code in tls_test.go
Matchfile(/usr/local/go/src/crypto/tls/conn.go) => true <nil>
Processing package=crypto/tls:
Excluding /usr/local/go/src/crypto/tls/testdata
Walking from /usr/local/go/src to /usr/local/go/src/crypto/x509
Processing crypto/x509:
Matchfile(/usr/local/go/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_js.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_unix.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/x509.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/pem_decrypt.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in name_constraints_test.go
Ignoring test code in root_unix_test.go
Ignoring test code in x509_test.go
Ignoring test code in pkcs8_test.go
Matchfile(/usr/local/go/src/crypto/x509/x509_test_import.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/sec1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/cert_pool.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Ignoring test code in pem_decrypt_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_cgo_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_darwin_armx.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_aix.go) => false <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_nacl.go) => false <nil>
Ignoring test code in verify_test.go
Matchfile(/usr/local/go/src/crypto/x509/root_plan9.go) => false <nil>
Ignoring test code in root_darwin_test.go
Matchfile(/usr/local/go/src/crypto/x509/pkcs8.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/root_linux.go) => false <nil>
Ignoring test code in sec1_test.go
Matchfile(/usr/local/go/src/crypto/x509/root.go) => true <nil>
Matchfile(/usr/local/go/src/crypto/x509/verify.go) => true <nil>
Processing package=crypto/x509:
Walking from /usr/local/go/src to /usr/local/go/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(/usr/local/go/src/crypto/x509/pkix/pkix.go) => true <nil>
Processing package=crypto/x509/pkix:
Excluding /usr/local/go/src/crypto/x509/testdata
Walking from /usr/local/go/src to /usr/local/go/src/database
Processing database:
Walking from /usr/local/go/src to /usr/local/go/src/database/sql
Processing database/sql:
Ignoring test code in example_test.go
Ignoring test code in example_cli_test.go
Ignoring test code in example_service_test.go
Matchfile(/usr/local/go/src/database/sql/convert.go) => true <nil>
Ignoring test code in sql_test.go
Ignoring test code in fakedb_test.go
Ignoring test code in convert_test.go
Matchfile(/usr/local/go/src/database/sql/ctxutil.go) => true <nil>
Matchfile(/usr/local/go/src/database/sql/sql.go) => true <nil>
Processing package=database/sql:
Walking from /usr/local/go/src to /usr/local/go/src/database/sql/driver
Processing database/sql/driver:
Ignoring test code in types_test.go
Matchfile(/usr/local/go/src/database/sql/driver/types.go) => true <nil>
Matchfile(/usr/local/go/src/database/sql/driver/driver.go) => true <nil>
Processing package=database/sql/driver:
Walking from /usr/local/go/src to /usr/local/go/src/debug
Processing debug:
Walking from /usr/local/go/src to /usr/local/go/src/debug/dwarf
Processing debug/dwarf:
Matchfile(/usr/local/go/src/debug/dwarf/buf.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/type.go) => true <nil>
Ignoring test code in entry_test.go
Matchfile(/usr/local/go/src/debug/dwarf/line.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/tag_string.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/open.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/entry.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/unit.go) => true <nil>
Matchfile(/usr/local/go/src/debug/dwarf/attr_string.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in type_test.go
Ignoring test code in line_test.go
Matchfile(/usr/local/go/src/debug/dwarf/const.go) => true <nil>
Processing package=debug/dwarf:
Excluding /usr/local/go/src/debug/dwarf/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/elf
Processing debug/elf:
Ignoring test code in symbols_test.go
Ignoring test code in file_test.go
Ignoring test code in elf_test.go
Matchfile(/usr/local/go/src/debug/elf/elf.go) => true <nil>
Matchfile(/usr/local/go/src/debug/elf/file.go) => true <nil>
Matchfile(/usr/local/go/src/debug/elf/reader.go) => true <nil>
Processing package=debug/elf:
Excluding /usr/local/go/src/debug/elf/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/gosym
Processing debug/gosym:
Matchfile(/usr/local/go/src/debug/gosym/symtab.go) => true <nil>
Matchfile(/usr/local/go/src/debug/gosym/pclntab.go) => true <nil>
Ignoring test code in symtab_test.go
Ignoring test code in pclntab_test.go
Processing package=debug/gosym:
Excluding /usr/local/go/src/debug/gosym/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/macho
Processing debug/macho:
Matchfile(/usr/local/go/src/debug/macho/reloctype.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/macho.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go/src/debug/macho/file.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/fat.go) => true <nil>
Matchfile(/usr/local/go/src/debug/macho/reloctype_string.go) => true <nil>
Processing package=debug/macho:
Excluding /usr/local/go/src/debug/macho/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/pe
Processing debug/pe:
Matchfile(/usr/local/go/src/debug/pe/section.go) => true <nil>
Matchfile(/usr/local/go/src/debug/pe/symbol.go) => true <nil>
Ignoring test code in file_test.go
Ignoring test code in file_cgo_test.go
Matchfile(/usr/local/go/src/debug/pe/file.go) => true <nil>
Matchfile(/usr/local/go/src/debug/pe/pe.go) => true <nil>
Matchfile(/usr/local/go/src/debug/pe/string.go) => true <nil>
Processing package=debug/pe:
Excluding /usr/local/go/src/debug/pe/testdata
Walking from /usr/local/go/src to /usr/local/go/src/debug/plan9obj
Processing debug/plan9obj:
Matchfile(/usr/local/go/src/debug/plan9obj/plan9obj.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go/src/debug/plan9obj/file.go) => true <nil>
Processing package=debug/plan9obj:
Excluding /usr/local/go/src/debug/plan9obj/testdata
Walking from /usr/local/go/src to /usr/local/go/src/encoding
Processing encoding:
Matchfile(/usr/local/go/src/encoding/encoding.go) => true <nil>
Processing package=encoding:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/ascii85
Processing encoding/ascii85:
Ignoring test code in ascii85_test.go
Matchfile(/usr/local/go/src/encoding/ascii85/ascii85.go) => true <nil>
Processing package=encoding/ascii85:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/asn1
Processing encoding/asn1:
Matchfile(/usr/local/go/src/encoding/asn1/marshal.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/asn1/common.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in marshal_test.go
Ignoring test code in asn1_test.go
Processing package=encoding/asn1:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/base32
Processing encoding/base32:
Ignoring test code in base32_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/base32/base32.go) => true <nil>
Processing package=encoding/base32:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/base64
Processing encoding/base64:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/base64/base64.go) => true <nil>
Ignoring test code in base64_test.go
Processing package=encoding/base64:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/binary
Processing encoding/binary:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in binary_test.go
Ignoring test code in varint_test.go
Matchfile(/usr/local/go/src/encoding/binary/varint.go) => true <nil>
Processing package=encoding/binary:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/csv
Processing encoding/csv:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/encoding/csv/writer.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=encoding/csv:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/gob
Processing encoding/gob:
Ignoring test code in timing_test.go
Matchfile(/usr/local/go/src/encoding/gob/decgen.go) => false <nil>
Matchfile(/usr/local/go/src/encoding/gob/encode.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/error.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in gobencdec_test.go
Matchfile(/usr/local/go/src/encoding/gob/decoder.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/dec_helpers.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/encoder.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(/usr/local/go/src/encoding/gob/type.go) => true <nil>
Ignoring test code in codec_test.go
Matchfile(/usr/local/go/src/encoding/gob/debug.go) => false <nil>
Matchfile(/usr/local/go/src/encoding/gob/doc.go) => true <nil>
Ignoring test code in type_test.go
Ignoring test code in encoder_test.go
Matchfile(/usr/local/go/src/encoding/gob/dump.go) => false <nil>
Matchfile(/usr/local/go/src/encoding/gob/enc_helpers.go) => true <nil>
Ignoring test code in example_encdec_test.go
Matchfile(/usr/local/go/src/encoding/gob/decode.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/gob/encgen.go) => false <nil>
Processing package=encoding/gob:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/hex
Processing encoding/hex:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/hex/hex.go) => true <nil>
Ignoring test code in hex_test.go
Processing package=encoding/hex:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/json
Processing encoding/json:
Ignoring test code in decode_test.go
Matchfile(/usr/local/go/src/encoding/json/encode.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in tagkey_test.go
Matchfile(/usr/local/go/src/encoding/json/tags.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/json/stream.go) => true <nil>
Ignoring test code in tags_test.go
Ignoring test code in fold_test.go
Matchfile(/usr/local/go/src/encoding/json/tables.go) => true <nil>
Ignoring test code in number_test.go
Ignoring test code in stream_test.go
Matchfile(/usr/local/go/src/encoding/json/indent.go) => true <nil>
Ignoring test code in bench_test.go
Ignoring test code in example_marshaling_test.go
Matchfile(/usr/local/go/src/encoding/json/fold.go) => true <nil>
Ignoring test code in example_text_marshaling_test.go
Matchfile(/usr/local/go/src/encoding/json/decode.go) => true <nil>
Ignoring test code in scanner_test.go
Ignoring test code in encode_test.go
Processing package=encoding/json:
Excluding /usr/local/go/src/encoding/json/testdata
Walking from /usr/local/go/src to /usr/local/go/src/encoding/pem
Processing encoding/pem:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/pem/pem.go) => true <nil>
Ignoring test code in pem_test.go
Processing package=encoding/pem:
Walking from /usr/local/go/src to /usr/local/go/src/encoding/xml
Processing encoding/xml:
Ignoring test code in read_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/encoding/xml/marshal.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/xml/typeinfo.go) => true <nil>
Matchfile(/usr/local/go/src/encoding/xml/xml.go) => true <nil>
Ignoring test code in atom_test.go
Matchfile(/usr/local/go/src/encoding/xml/read.go) => true <nil>
Ignoring test code in example_marshaling_test.go
Ignoring test code in xml_test.go
Ignoring test code in example_text_marshaling_test.go
Ignoring test code in marshal_test.go
Processing package=encoding/xml:
Walking from /usr/local/go/src to /usr/local/go/src/errors
Processing errors:
Ignoring test code in example_test.go
Ignoring test code in errors_test.go
Matchfile(/usr/local/go/src/errors/errors.go) => true <nil>
Processing package=errors:
Walking from /usr/local/go/src to /usr/local/go/src/expvar
Processing expvar:
Ignoring test code in expvar_test.go
Matchfile(/usr/local/go/src/expvar/expvar.go) => true <nil>
Processing package=expvar:
Walking from /usr/local/go/src to /usr/local/go/src/flag
Processing flag:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/flag/flag.go) => true <nil>
Ignoring test code in flag_test.go
Ignoring test code in export_test.go
Ignoring test code in example_value_test.go
Processing package=flag:
Walking from /usr/local/go/src to /usr/local/go/src/fmt
Processing fmt:
Ignoring test code in example_test.go
Ignoring test code in fmt_test.go
Matchfile(/usr/local/go/src/fmt/format.go) => true <nil>
Ignoring test code in gostringer_example_test.go
Matchfile(/usr/local/go/src/fmt/scan.go) => true <nil>
Matchfile(/usr/local/go/src/fmt/doc.go) => true <nil>
Matchfile(/usr/local/go/src/fmt/print.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in stringer_test.go
Ignoring test code in scan_test.go
Ignoring test code in stringer_example_test.go
Processing package=fmt:
Walking from /usr/local/go/src to /usr/local/go/src/go
Processing go:
Walking from /usr/local/go/src to /usr/local/go/src/go/ast
Processing go/ast:
Matchfile(/usr/local/go/src/go/ast/resolve.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in filter_test.go
Matchfile(/usr/local/go/src/go/ast/import.go) => true <nil>
Ignoring test code in ast_test.go
Matchfile(/usr/local/go/src/go/ast/filter.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/ast.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/print.go) => true <nil>
Ignoring test code in commentmap_test.go
Matchfile(/usr/local/go/src/go/ast/walk.go) => true <nil>
Ignoring test code in print_test.go
Matchfile(/usr/local/go/src/go/ast/scope.go) => true <nil>
Matchfile(/usr/local/go/src/go/ast/commentmap.go) => true <nil>
Processing package=go/ast:
Walking from /usr/local/go/src to /usr/local/go/src/go/build
Processing go/build:
Matchfile(/usr/local/go/src/go/build/zcgo.go) => true <nil>
Matchfile(/usr/local/go/src/go/build/gc.go) => true <nil>
Ignoring test code in read_test.go
Matchfile(/usr/local/go/src/go/build/build.go) => true <nil>
Matchfile(/usr/local/go/src/go/build/syslist.go) => true <nil>
Ignoring test code in build_test.go
Ignoring test code in syslist_test.go
Matchfile(/usr/local/go/src/go/build/gccgo.go) => false <nil>
Matchfile(/usr/local/go/src/go/build/doc.go) => true <nil>
Ignoring test code in deps_test.go
Matchfile(/usr/local/go/src/go/build/read.go) => true <nil>
Processing package=go/build:
Excluding /usr/local/go/src/go/build/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/constant
Processing go/constant:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(/usr/local/go/src/go/constant/value.go) => true <nil>
Processing package=go/constant:
Walking from /usr/local/go/src to /usr/local/go/src/go/doc
Processing go/doc:
Ignoring test code in comment_test.go
Ignoring test code in example_test.go
Ignoring test code in synopsis_test.go
Matchfile(/usr/local/go/src/go/doc/comment.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/exports.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/lazyre.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/headscan.go) => false <nil>
Matchfile(/usr/local/go/src/go/doc/synopsis.go) => true <nil>
Ignoring test code in doc_test.go
Matchfile(/usr/local/go/src/go/doc/filter.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/doc.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/example.go) => true <nil>
Matchfile(/usr/local/go/src/go/doc/reader.go) => true <nil>
Processing package=go/doc:
Excluding /usr/local/go/src/go/doc/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/format
Processing go/format:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/format/internal.go) => true <nil>
Ignoring test code in format_test.go
Matchfile(/usr/local/go/src/go/format/format.go) => true <nil>
Ignoring test code in benchmark_test.go
Processing package=go/format:
Walking from /usr/local/go/src to /usr/local/go/src/go/importer
Processing go/importer:
Matchfile(/usr/local/go/src/go/importer/importer.go) => true <nil>
Ignoring test code in importer_test.go
Processing package=go/importer:
Excluding /usr/local/go/src/go/internal
Walking from /usr/local/go/src to /usr/local/go/src/go/parser
Processing go/parser:
Ignoring test code in example_test.go
Ignoring test code in parser_test.go
Matchfile(/usr/local/go/src/go/parser/interface.go) => true <nil>
Ignoring test code in short_test.go
Ignoring test code in performance_test.go
Matchfile(/usr/local/go/src/go/parser/parser.go) => true <nil>
Ignoring test code in error_test.go
Processing package=go/parser:
Excluding /usr/local/go/src/go/parser/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/printer
Processing go/printer:
Ignoring test code in example_test.go
Ignoring test code in printer_test.go
Ignoring test code in performance_test.go
Matchfile(/usr/local/go/src/go/printer/printer.go) => true <nil>
Matchfile(/usr/local/go/src/go/printer/nodes.go) => true <nil>
Processing package=go/printer:
Excluding /usr/local/go/src/go/printer/testdata
Walking from /usr/local/go/src to /usr/local/go/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(/usr/local/go/src/go/scanner/errors.go) => true <nil>
Processing package=go/scanner:
Walking from /usr/local/go/src to /usr/local/go/src/go/token
Processing go/token:
Ignoring test code in serialize_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/go/token/token.go) => true <nil>
Matchfile(/usr/local/go/src/go/token/serialize.go) => true <nil>
Ignoring test code in position_test.go
Matchfile(/usr/local/go/src/go/token/position.go) => true <nil>
Processing package=go/token:
Walking from /usr/local/go/src to /usr/local/go/src/go/types
Processing go/types:
Matchfile(/usr/local/go/src/go/types/object.go) => true <nil>
Ignoring test code in check_test.go
Matchfile(/usr/local/go/src/go/types/check.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in exprstring_test.go
Matchfile(/usr/local/go/src/go/types/methodset.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/predicates.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/labels.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/interfaces.go) => true <nil>
Ignoring test code in stdlib_test.go
Ignoring test code in builtins_test.go
Ignoring test code in sizes_test.go
Matchfile(/usr/local/go/src/go/types/package.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/sizes.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/type.go) => true <nil>
Ignoring test code in issues_test.go
Ignoring test code in resolver_test.go
Matchfile(/usr/local/go/src/go/types/lookup.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/typestring.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/stmt.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/typexpr.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/conversions.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/operand.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/builtins.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/initorder.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/resolver.go) => true <nil>
Ignoring test code in token_test.go
Ignoring test code in eval_test.go
Ignoring test code in self_test.go
Matchfile(/usr/local/go/src/go/types/universe.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/api.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/exprstring.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/assignments.go) => true <nil>
Ignoring test code in hilbert_test.go
Matchfile(/usr/local/go/src/go/types/expr.go) => true <nil>
Ignoring test code in typestring_test.go
Matchfile(/usr/local/go/src/go/types/scope.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/objset.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/return.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/decl.go) => true <nil>
Ignoring test code in api_test.go
Matchfile(/usr/local/go/src/go/types/call.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/eval.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/selection.go) => true <nil>
Matchfile(/usr/local/go/src/go/types/errors.go) => true <nil>
Ignoring test code in object_test.go
Matchfile(/usr/local/go/src/go/types/gotype.go) => false <nil>
Processing package=go/types:
Excluding /usr/local/go/src/go/types/testdata
Walking from /usr/local/go/src to /usr/local/go/src/hash
Processing hash:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/hash/hash.go) => true <nil>
Ignoring test code in marshal_test.go
Processing package=hash:
Walking from /usr/local/go/src to /usr/local/go/src/hash/adler32
Processing hash/adler32:
Matchfile(/usr/local/go/src/hash/adler32/adler32.go) => true <nil>
Ignoring test code in adler32_test.go
Processing package=hash/adler32:
Walking from /usr/local/go/src to /usr/local/go/src/hash/crc32
Processing hash/crc32:
Matchfile(/usr/local/go/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_amd64.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/hash/crc32/crc32_otherarch.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32.go) => true <nil>
Ignoring test code in crc32_test.go
Matchfile(/usr/local/go/src/hash/crc32/crc32_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_generic.go) => true <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Processing package=hash/crc32:
Walking from /usr/local/go/src to /usr/local/go/src/hash/crc64
Processing hash/crc64:
Ignoring test code in crc64_test.go
Matchfile(/usr/local/go/src/hash/crc64/crc64.go) => true <nil>
Processing package=hash/crc64:
Walking from /usr/local/go/src to /usr/local/go/src/hash/fnv
Processing hash/fnv:
Matchfile(/usr/local/go/src/hash/fnv/fnv.go) => true <nil>
Ignoring test code in fnv_test.go
Processing package=hash/fnv:
Walking from /usr/local/go/src to /usr/local/go/src/html
Processing html:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/html/escape.go) => true <nil>
Matchfile(/usr/local/go/src/html/entity.go) => true <nil>
Ignoring test code in entity_test.go
Ignoring test code in escape_test.go
Processing package=html:
Walking from /usr/local/go/src to /usr/local/go/src/html/template
Processing html/template:
Ignoring test code in clone_test.go
Matchfile(/usr/local/go/src/html/template/error.go) => true <nil>
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in content_test.go
Matchfile(/usr/local/go/src/html/template/escape.go) => true <nil>
Ignoring test code in transition_test.go
Ignoring test code in js_test.go
Matchfile(/usr/local/go/src/html/template/element_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/urlpart_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/transition.go) => true <nil>
Ignoring test code in css_test.go
Ignoring test code in template_test.go
Matchfile(/usr/local/go/src/html/template/html.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/state_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/js.go) => true <nil>
Ignoring test code in html_test.go
Matchfile(/usr/local/go/src/html/template/delim_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/template.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/doc.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/context.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/attr_string.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/content.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/css.go) => true <nil>
Matchfile(/usr/local/go/src/html/template/url.go) => true <nil>
Ignoring test code in escape_test.go
Matchfile(/usr/local/go/src/html/template/attr.go) => true <nil>
Ignoring test code in url_test.go
Matchfile(/usr/local/go/src/html/template/jsctx_string.go) => true <nil>
Processing package=html/template:
Walking from /usr/local/go/src to /usr/local/go/src/image
Processing image:
Ignoring test code in geom_test.go
Ignoring test code in decode_test.go
Matchfile(/usr/local/go/src/image/format.go) => true <nil>
Matchfile(/usr/local/go/src/image/geom.go) => true <nil>
Ignoring test code in ycbcr_test.go
Ignoring test code in image_test.go
Matchfile(/usr/local/go/src/image/names.go) => true <nil>
Matchfile(/usr/local/go/src/image/image.go) => true <nil>
Matchfile(/usr/local/go/src/image/ycbcr.go) => true <nil>
Ignoring test code in decode_example_test.go
Processing package=image:
Walking from /usr/local/go/src to /usr/local/go/src/image/color
Processing image/color:
Matchfile(/usr/local/go/src/image/color/color.go) => true <nil>
Ignoring test code in color_test.go
Ignoring test code in ycbcr_test.go
Matchfile(/usr/local/go/src/image/color/ycbcr.go) => true <nil>
Processing package=image/color:
Walking from /usr/local/go/src to /usr/local/go/src/image/color/palette
Processing image/color/palette:
Matchfile(/usr/local/go/src/image/color/palette/generate.go) => true <nil>
Matchfile(/usr/local/go/src/image/color/palette/gen.go) => false <nil>
Matchfile(/usr/local/go/src/image/color/palette/palette.go) => true <nil>
Processing package=image/color/palette:
Walking from /usr/local/go/src to /usr/local/go/src/image/draw
Processing image/draw:
Ignoring test code in draw_test.go
Ignoring test code in example_test.go
Ignoring test code in clip_test.go
Ignoring test code in bench_test.go
Matchfile(/usr/local/go/src/image/draw/draw.go) => true <nil>
Processing package=image/draw:
Walking from /usr/local/go/src to /usr/local/go/src/image/gif
Processing image/gif:
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/image/gif/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/gif/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=image/gif:
Excluding /usr/local/go/src/image/internal
Walking from /usr/local/go/src to /usr/local/go/src/image/jpeg
Processing image/jpeg:
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/image/jpeg/huffman.go) => true <nil>
Ignoring test code in dct_test.go
Matchfile(/usr/local/go/src/image/jpeg/idct.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/scan.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/jpeg/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/image/jpeg/fdct.go) => true <nil>
Processing package=image/jpeg:
Walking from /usr/local/go/src to /usr/local/go/src/image/png
Processing image/png:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in paeth_test.go
Matchfile(/usr/local/go/src/image/png/writer.go) => true <nil>
Matchfile(/usr/local/go/src/image/png/paeth.go) => true <nil>
Matchfile(/usr/local/go/src/image/png/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=image/png:
Excluding /usr/local/go/src/image/png/testdata
Excluding /usr/local/go/src/image/testdata
Walking from /usr/local/go/src to /usr/local/go/src/index
Processing index:
Walking from /usr/local/go/src to /usr/local/go/src/index/suffixarray
Processing index/suffixarray:
Ignoring test code in example_test.go
Ignoring test code in suffixarray_test.go
Matchfile(/usr/local/go/src/index/suffixarray/suffixarray.go) => true <nil>
Matchfile(/usr/local/go/src/index/suffixarray/qsufsort.go) => true <nil>
Processing package=index/suffixarray:
Excluding /usr/local/go/src/internal
Walking from /usr/local/go/src to /usr/local/go/src/io
Processing io:
Ignoring test code in example_test.go
Ignoring test code in multi_test.go
Matchfile(/usr/local/go/src/io/io.go) => true <nil>
Matchfile(/usr/local/go/src/io/multi.go) => true <nil>
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go/src/io/pipe.go) => true <nil>
Ignoring test code in io_test.go
Processing package=io:
Walking from /usr/local/go/src to /usr/local/go/src/io/ioutil
Processing io/ioutil:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/io/ioutil/tempfile.go) => true <nil>
Matchfile(/usr/local/go/src/io/ioutil/ioutil.go) => true <nil>
Ignoring test code in ioutil_test.go
Ignoring test code in tempfile_test.go
Processing package=io/ioutil:
Excluding /usr/local/go/src/io/ioutil/testdata
Walking from /usr/local/go/src to /usr/local/go/src/log
Processing log:
Matchfile(/usr/local/go/src/log/log.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in log_test.go
Processing package=log:
Walking from /usr/local/go/src to /usr/local/go/src/log/syslog
Processing log/syslog:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/log/syslog/syslog.go) => true <nil>
Matchfile(/usr/local/go/src/log/syslog/doc.go) => true <nil>
Ignoring test code in syslog_test.go
Matchfile(/usr/local/go/src/log/syslog/syslog_unix.go) => true <nil>
Processing package=log/syslog:
Walking from /usr/local/go/src to /usr/local/go/src/math
Processing math:
Matchfile(/usr/local/go/src/math/arith_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/math/sqrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/log.go) => true <nil>
Matchfile(/usr/local/go/src/math/hypot.go) => true <nil>
Matchfile(/usr/local/go/src/math/logb.go) => true <nil>
Matchfile(/usr/local/go/src/math/nextafter.go) => true <nil>
Matchfile(/usr/local/go/src/math/exp_asm.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/signbit.go) => true <nil>
Matchfile(/usr/local/go/src/math/tanh.go) => true <nil>
Matchfile(/usr/local/go/src/math/pow.go) => true <nil>
Matchfile(/usr/local/go/src/math/acosh.go) => true <nil>
Matchfile(/usr/local/go/src/math/bits.go) => true <nil>
Matchfile(/usr/local/go/src/math/asinh.go) => true <nil>
Ignoring test code in huge_test.go
Matchfile(/usr/local/go/src/math/copysign.go) => true <nil>
Matchfile(/usr/local/go/src/math/jn.go) => true <nil>
Matchfile(/usr/local/go/src/math/erf.go) => true <nil>
Matchfile(/usr/local/go/src/math/floor.go) => true <nil>
Matchfile(/usr/local/go/src/math/modf.go) => true <nil>
Matchfile(/usr/local/go/src/math/ldexp.go) => true <nil>
Matchfile(/usr/local/go/src/math/abs.go) => true <nil>
Matchfile(/usr/local/go/src/math/tan.go) => true <nil>
Matchfile(/usr/local/go/src/math/atan2.go) => true <nil>
Matchfile(/usr/local/go/src/math/asin.go) => true <nil>
Matchfile(/usr/local/go/src/math/remainder.go) => true <nil>
Matchfile(/usr/local/go/src/math/pow10.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(/usr/local/go/src/math/expm1.go) => true <nil>
Matchfile(/usr/local/go/src/math/trig_reduce.go) => true <nil>
Matchfile(/usr/local/go/src/math/unsafe.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/math/frexp.go) => true <nil>
Matchfile(/usr/local/go/src/math/log10.go) => true <nil>
Matchfile(/usr/local/go/src/math/sincos.go) => true <nil>
Matchfile(/usr/local/go/src/math/const.go) => true <nil>
Matchfile(/usr/local/go/src/math/gamma.go) => true <nil>
Matchfile(/usr/local/go/src/math/sin.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(/usr/local/go/src/math/atanh.go) => true <nil>
Matchfile(/usr/local/go/src/math/cbrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/log1p.go) => true <nil>
Matchfile(/usr/local/go/src/math/atan.go) => true <nil>
Matchfile(/usr/local/go/src/math/mod.go) => true <nil>
Matchfile(/usr/local/go/src/math/j1.go) => true <nil>
Matchfile(/usr/local/go/src/math/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/sinh.go) => true <nil>
Ignoring test code in export_s390x_test.go
Matchfile(/usr/local/go/src/math/erfinv.go) => true <nil>
Matchfile(/usr/local/go/src/math/j0.go) => true <nil>
Matchfile(/usr/local/go/src/math/dim.go) => true <nil>
Matchfile(/usr/local/go/src/math/lgamma.go) => true <nil>
Processing package=math:
Walking from /usr/local/go/src to /usr/local/go/src/math/big
Processing math/big:
Matchfile(/usr/local/go/src/math/big/sqrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/natconv.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/ratmarsh.go) => true <nil>
Ignoring test code in int_test.go
Ignoring test code in ratconv_test.go
Ignoring test code in example_test.go
Ignoring test code in rat_test.go
Matchfile(/usr/local/go/src/math/big/intmarsh.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/prime.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/ftoa.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/roundingmode_string.go) => true <nil>
Ignoring test code in float_test.go
Ignoring test code in ratmarsh_test.go
Matchfile(/usr/local/go/src/math/big/floatmarsh.go) => true <nil>
Ignoring test code in natconv_test.go
Ignoring test code in sqrt_test.go
Ignoring test code in intmarsh_test.go
Matchfile(/usr/local/go/src/math/big/decimal.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/nat.go) => true <nil>
Ignoring test code in gcd_test.go
Ignoring test code in floatmarsh_test.go
Matchfile(/usr/local/go/src/math/big/arith_decl_pure.go) => false <nil>
Matchfile(/usr/local/go/src/math/big/arith_decl_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/math/big/arith_decl.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/float.go) => true <nil>
Ignoring test code in calibrate_test.go
Matchfile(/usr/local/go/src/math/big/arith.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/ratconv.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/arith_amd64.go) => true <nil>
Ignoring test code in floatconv_test.go
Matchfile(/usr/local/go/src/math/big/doc.go) => true <nil>
Ignoring test code in nat_test.go
Ignoring test code in floatexample_test.go
Ignoring test code in prime_test.go
Ignoring test code in arith_test.go
Ignoring test code in hilbert_test.go
Ignoring test code in arith_s390x_test.go
Ignoring test code in decimal_test.go
Matchfile(/usr/local/go/src/math/big/int.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/intconv.go) => true <nil>
Matchfile(/usr/local/go/src/math/big/accuracy_string.go) => true <nil>
Ignoring test code in example_rat_test.go
Matchfile(/usr/local/go/src/math/big/rat.go) => true <nil>
Ignoring test code in intconv_test.go
Matchfile(/usr/local/go/src/math/big/floatconv.go) => true <nil>
Ignoring test code in bits_test.go
Processing package=math/big:
Walking from /usr/local/go/src to /usr/local/go/src/math/bits
Processing math/bits:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/bits/bits.go) => true <nil>
Matchfile(/usr/local/go/src/math/bits/bits_tables.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/math/bits/make_examples.go) => false <nil>
Matchfile(/usr/local/go/src/math/bits/make_tables.go) => false <nil>
Ignoring test code in bits_test.go
Processing package=math/bits:
Walking from /usr/local/go/src to /usr/local/go/src/math/cmplx
Processing math/cmplx:
Matchfile(/usr/local/go/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/log.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/isnan.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/isinf.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/math/cmplx/pow.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/phase.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/polar.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/rect.go) => true <nil>
Ignoring test code in cmath_test.go
Matchfile(/usr/local/go/src/math/cmplx/abs.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/tan.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/asin.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/sin.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/cmplx/conj.go) => true <nil>
Processing package=math/cmplx:
Walking from /usr/local/go/src to /usr/local/go/src/math/rand
Processing math/rand:
Matchfile(/usr/local/go/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in race_test.go
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/math/rand/rng.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/normal.go) => true <nil>
Ignoring test code in regress_test.go
Matchfile(/usr/local/go/src/math/rand/rand.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/exp.go) => true <nil>
Matchfile(/usr/local/go/src/math/rand/zipf.go) => true <nil>
Processing package=math/rand:
Walking from /usr/local/go/src to /usr/local/go/src/mime
Processing mime:
Ignoring test code in encodedword_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/mime/type_windows.go) => false <nil>
Matchfile(/usr/local/go/src/mime/grammar.go) => true <nil>
Matchfile(/usr/local/go/src/mime/type.go) => true <nil>
Matchfile(/usr/local/go/src/mime/type_plan9.go) => false <nil>
Ignoring test code in mediatype_test.go
Matchfile(/usr/local/go/src/mime/mediatype.go) => true <nil>
Matchfile(/usr/local/go/src/mime/encodedword.go) => true <nil>
Matchfile(/usr/local/go/src/mime/type_freebsd.go) => false <nil>
Ignoring test code in type_test.go
Matchfile(/usr/local/go/src/mime/type_unix.go) => true <nil>
Matchfile(/usr/local/go/src/mime/type_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/mime/type_openbsd.go) => false <nil>
Processing package=mime:
Walking from /usr/local/go/src to /usr/local/go/src/mime/multipart
Processing mime/multipart:
Ignoring test code in example_test.go
Ignoring test code in multipart_test.go
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/mime/multipart/multipart.go) => true <nil>
Matchfile(/usr/local/go/src/mime/multipart/writer.go) => true <nil>
Matchfile(/usr/local/go/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in formdata_test.go
Processing package=mime/multipart:
Excluding /usr/local/go/src/mime/multipart/testdata
Walking from /usr/local/go/src to /usr/local/go/src/mime/quotedprintable
Processing mime/quotedprintable:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/mime/quotedprintable/writer.go) => true <nil>
Matchfile(/usr/local/go/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=mime/quotedprintable:
Excluding /usr/local/go/src/mime/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net
Processing net:
Matchfile(/usr/local/go/src/net/fd_windows.go) => false <nil>
Ignoring test code in ipsock_test.go
Matchfile(/usr/local/go/src/net/fd_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/net/fd_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/error_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockopt_stub.go) => false <nil>
Ignoring test code in mac_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in lookup_test.go
Matchfile(/usr/local/go/src/net/sockoptip_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/sock_cloexec.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Matchfile(/usr/local/go/src/net/error_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_unix.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockaddr_posix.go) => true <nil>
Ignoring test code in dnsclient_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/interface_freebsd.go) => false <nil>
Ignoring test code in iprawsock_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(/usr/local/go/src/net/cgo_socknew.go) => false <nil>
Matchfile(/usr/local/go/src/net/error_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockoptip_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/udpsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/udpsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sock_linux.go) => false <nil>
Matchfile(/usr/local/go/src/net/sendfile_linux.go) => false <nil>
Ignoring test code in hosts_test.go
Matchfile(/usr/local/go/src/net/cgo_resold.go) => false <nil>
Matchfile(/usr/local/go/src/net/splice_linux.go) => false <nil>
Ignoring test code in main_windows_test.go
Matchfile(/usr/local/go/src/net/unixsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/rawconn.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook_windows.go) => false <nil>
Ignoring test code in interface_test.go
Matchfile(/usr/local/go/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_linux.go) => false <nil>
Matchfile(/usr/local/go/src/net/cgo_android.go) => false <nil>
Matchfile(/usr/local/go/src/net/addrselect.go) => true <nil>
Matchfile(/usr/local/go/src/net/net_fake.go) => false <nil>
Ignoring test code in interface_bsd_test.go
Matchfile(/usr/local/go/src/net/file_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/port.go) => true <nil>
Matchfile(/usr/local/go/src/net/sock_posix.go) => true <nil>
Ignoring test code in lookup_windows_test.go
Matchfile(/usr/local/go/src/net/sockopt_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sendfile_stub.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(/usr/local/go/src/net/lookup_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/dnsclient_unix.go) => true <nil>
Ignoring test code in rawconn_windows_test.go
Ignoring test code in error_plan9_test.go
Matchfile(/usr/local/go/src/net/lookup_windows.go) => false <nil>
Ignoring test code in timeout_test.go
Matchfile(/usr/local/go/src/net/dnsconfig_unix.go) => true <nil>
Ignoring test code in dial_test.go
Matchfile(/usr/local/go/src/net/hosts.go) => true <nil>
Matchfile(/usr/local/go/src/net/lookup_fake.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_bsdvar.go) => false <nil>
Ignoring test code in error_unix_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in platform_test.go
Matchfile(/usr/local/go/src/net/sock_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/error_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook.go) => true <nil>
Matchfile(/usr/local/go/src/net/ipsock.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in parse_test.go
Matchfile(/usr/local/go/src/net/iprawsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/sock_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/net.go) => true <nil>
Ignoring test code in error_posix_test.go
Matchfile(/usr/local/go/src/net/lookup.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface.go) => true <nil>
Matchfile(/usr/local/go/src/net/sys_cloexec.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(/usr/local/go/src/net/conf.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockopt_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/splice_stub.go) => true <nil>
Matchfile(/usr/local/go/src/net/sock_plan9.go) => false <nil>
Ignoring test code in interface_linux_test.go
Ignoring test code in net_test.go
Matchfile(/usr/local/go/src/net/udpsock_posix.go) => true <nil>
Ignoring test code in packetconn_test.go
Matchfile(/usr/local/go/src/net/sockopt_linux.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsock_posix.go) => true <nil>
Ignoring test code in nss_test.go
Matchfile(/usr/local/go/src/net/sendfile_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_linux.go) => false <nil>
Matchfile(/usr/local/go/src/net/iprawsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/unixsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockopt_bsd.go) => true <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in main_posix_test.go
Matchfile(/usr/local/go/src/net/interface_windows.go) => false <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(/usr/local/go/src/net/file_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockopt_aix.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_dragonfly.go) => false <nil>
Ignoring test code in port_test.go
Matchfile(/usr/local/go/src/net/dnsclient.go) => true <nil>
Matchfile(/usr/local/go/src/net/error_unix.go) => true <nil>
Ignoring test code in error_windows_test.go
Matchfile(/usr/local/go/src/net/tcpsockopt_posix.go) => true <nil>
Ignoring test code in conf_test.go
Matchfile(/usr/local/go/src/net/ip.go) => true <nil>
Matchfile(/usr/local/go/src/net/nss.go) => true <nil>
Matchfile(/usr/local/go/src/net/ipsock_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_sockold.go) => true <nil>
Ignoring test code in sendfile_test.go
Matchfile(/usr/local/go/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(/usr/local/go/src/net/writev_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/net/file.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_bsd.go) => true <nil>
Ignoring test code in ip_test.go
Ignoring test code in main_plan9_test.go
Matchfile(/usr/local/go/src/net/cgo_resnew.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(/usr/local/go/src/net/sockopt_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_stub.go) => false <nil>
Ignoring test code in conn_test.go
Matchfile(/usr/local/go/src/net/tcpsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/hook_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/net/interface_aix.go) => false <nil>
Ignoring test code in main_conf_test.go
Matchfile(/usr/local/go/src/net/cgo_openbsd.go) => false <nil>
Ignoring test code in rawconn_unix_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in external_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in pipe_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in net_windows_test.go
Matchfile(/usr/local/go/src/net/port_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/cgo_stub.go) => false <nil>
Ignoring test code in unixsock_windows_test.go
Ignoring test code in main_unix_test.go
Matchfile(/usr/local/go/src/net/mac.go) => true <nil>
Ignoring test code in unixsock_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in error_test.go
Matchfile(/usr/local/go/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockoptip_linux.go) => false <nil>
Matchfile(/usr/local/go/src/net/unixsock.go) => true <nil>
Matchfile(/usr/local/go/src/net/lookup_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockopt_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/sockoptip_posix.go) => true <nil>
Matchfile(/usr/local/go/src/net/sockoptip_bsdvar.go) => true <nil>
Matchfile(/usr/local/go/src/net/pipe.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(/usr/local/go/src/net/hook_unix.go) => true <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(/usr/local/go/src/net/tcpsockopt_darwin.go) => true <nil>
Ignoring test code in udpsock_test.go
Matchfile(/usr/local/go/src/net/interface_solaris.go) => false <nil>
Ignoring test code in listen_test.go
Matchfile(/usr/local/go/src/net/sock_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/net/interface_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/net/dial.go) => true <nil>
Ignoring test code in server_test.go
Matchfile(/usr/local/go/src/net/file_windows.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in addrselect_test.go
Matchfile(/usr/local/go/src/net/ipsock_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/net/parse.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Matchfile(/usr/local/go/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in main_test.go
Ignoring test code in dnsclient_unix_test.go
Matchfile(/usr/local/go/src/net/file_stub.go) => false <nil>
Processing package=net:
Walking from /usr/local/go/src to /usr/local/go/src/net/http
Processing net/http:
Matchfile(/usr/local/go/src/net/http/jar.go) => true <nil>
Ignoring test code in cookie_test.go
Matchfile(/usr/local/go/src/net/http/transport.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/header.go) => true <nil>
Ignoring test code in requestwrite_test.go
Ignoring test code in range_test.go
Ignoring test code in example_test.go
Ignoring test code in transfer_test.go
Matchfile(/usr/local/go/src/net/http/server.go) => true <nil>
Ignoring test code in transport_internal_test.go
Ignoring test code in fs_test.go
Ignoring test code in http_test.go
Matchfile(/usr/local/go/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in header_test.go
Matchfile(/usr/local/go/src/net/http/response.go) => true <nil>
Ignoring test code in request_test.go
Matchfile(/usr/local/go/src/net/http/request.go) => true <nil>
Ignoring test code in serve_test.go
Ignoring test code in response_test.go
Matchfile(/usr/local/go/src/net/http/client.go) => true <nil>
Ignoring test code in example_filesystem_test.go
Matchfile(/usr/local/go/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in responsewrite_test.go
Matchfile(/usr/local/go/src/net/http/method.go) => true <nil>
Ignoring test code in clientserver_test.go
Matchfile(/usr/local/go/src/net/http/http.go) => true <nil>
Ignoring test code in filetransport_test.go
Matchfile(/usr/local/go/src/net/http/doc.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/fs.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/triv.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/net/http/transfer.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/cookie.go) => true <nil>
Ignoring test code in proxy_test.go
Matchfile(/usr/local/go/src/net/http/sniff.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(/usr/local/go/src/net/http/status.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in client_test.go
Ignoring test code in example_handle_test.go
Matchfile(/usr/local/go/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in npn_test.go
Ignoring test code in server_test.go
Ignoring test code in readrequest_test.go
Matchfile(/usr/local/go/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in main_test.go
Matchfile(/usr/local/go/src/net/http/filetransport.go) => true <nil>
Processing package=net/http:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in plan9_test.go
Ignoring test code in child_test.go
Ignoring test code in posix_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Matchfile(/usr/local/go/src/net/http/cgi/host.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding /usr/local/go/src/net/http/cgi/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net/http/cookiejar
Processing net/http/cookiejar:
Matchfile(/usr/local/go/src/net/http/cookiejar/jar.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Processing package=net/http/cookiejar:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(/usr/local/go/src/net/http/fcgi/child.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Processing package=net/http/fcgi:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httptest
Processing net/http/httptest:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/httptest/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in httptest_test.go
Matchfile(/usr/local/go/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in recorder_test.go
Ignoring test code in server_test.go
Processing package=net/http/httptest:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/httptrace/trace.go) => true <nil>
Processing package=net/http/httptrace:
Walking from /usr/local/go/src to /usr/local/go/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(/usr/local/go/src/net/http/httputil/persist.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(/usr/local/go/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(/usr/local/go/src/net/http/httputil/reverseproxy.go) => true <nil>
Processing package=net/http/httputil:
Excluding /usr/local/go/src/net/http/internal
Walking from /usr/local/go/src to /usr/local/go/src/net/http/pprof
Processing net/http/pprof:
Matchfile(/usr/local/go/src/net/http/pprof/pprof.go) => true <nil>
Ignoring test code in pprof_test.go
Processing package=net/http/pprof:
Excluding /usr/local/go/src/net/http/testdata
Excluding /usr/local/go/src/net/internal
Walking from /usr/local/go/src to /usr/local/go/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/mail/message.go) => true <nil>
Ignoring test code in message_test.go
Processing package=net/mail:
Walking from /usr/local/go/src to /usr/local/go/src/net/rpc
Processing net/rpc:
Matchfile(/usr/local/go/src/net/rpc/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/rpc/client.go) => true <nil>
Matchfile(/usr/local/go/src/net/rpc/debug.go) => true <nil>
Ignoring test code in client_test.go
Ignoring test code in server_test.go
Processing package=net/rpc:
Walking from /usr/local/go/src to /usr/local/go/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(/usr/local/go/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(/usr/local/go/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Processing package=net/rpc/jsonrpc:
Walking from /usr/local/go/src to /usr/local/go/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/smtp/auth.go) => true <nil>
Ignoring test code in smtp_test.go
Matchfile(/usr/local/go/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding /usr/local/go/src/net/testdata
Walking from /usr/local/go/src to /usr/local/go/src/net/textproto
Processing net/textproto:
Matchfile(/usr/local/go/src/net/textproto/header.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/textproto.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(/usr/local/go/src/net/textproto/writer.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/pipeline.go) => true <nil>
Matchfile(/usr/local/go/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Processing package=net/textproto:
Walking from /usr/local/go/src to /usr/local/go/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/net/url/url.go) => true <nil>
Ignoring test code in url_test.go
Processing package=net/url:
Walking from /usr/local/go/src to /usr/local/go/src/os
Processing os:
Matchfile(/usr/local/go/src/os/stat_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/sticky_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/os/executable_procfs.go) => false <nil>
Ignoring test code in env_unix_test.go
Matchfile(/usr/local/go/src/os/str.go) => true <nil>
Matchfile(/usr/local/go/src/os/proc.go) => true <nil>
Matchfile(/usr/local/go/src/os/error_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/pipe2_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir.go) => true <nil>
Matchfile(/usr/local/go/src/os/env.go) => true <nil>
Matchfile(/usr/local/go/src/os/types_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/os/error_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/error.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in executable_test.go
Matchfile(/usr/local/go/src/os/exec_posix.go) => true <nil>
Matchfile(/usr/local/go/src/os/env_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/os/wait_wait6.go) => false <nil>
Matchfile(/usr/local/go/src/os/sticky_notbsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/os/rawconn.go) => true <nil>
Ignoring test code in fifo_test.go
Matchfile(/usr/local/go/src/os/sys_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/file_unix.go) => true <nil>
Ignoring test code in os_unix_test.go
Matchfile(/usr/local/go/src/os/getwd.go) => true <nil>
Matchfile(/usr/local/go/src/os/types_windows.go) => false <nil>
Ignoring test code in env_test.go
Ignoring test code in path_test.go
Matchfile(/usr/local/go/src/os/removeall_noat.go) => false <nil>
Matchfile(/usr/local/go/src/os/types.go) => true <nil>
Ignoring test code in timeout_test.go
Matchfile(/usr/local/go/src/os/sys_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/os/types_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_plan9.go) => false <nil>
Ignoring test code in error_unix_test.go
Matchfile(/usr/local/go/src/os/error_posix.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_aix.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_nacljs.go) => false <nil>
Ignoring test code in removeall_test.go
Ignoring test code in path_windows_test.go
Matchfile(/usr/local/go/src/os/pipe_linux.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/path_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/env_default.go) => true <nil>
Matchfile(/usr/local/go/src/os/exec.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/sys_linux.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_ios.go) => false <nil>
Matchfile(/usr/local/go/src/os/dir_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/executable_path.go) => false <nil>
Matchfile(/usr/local/go/src/os/file_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/sys_js.go) => false <nil>
Ignoring test code in export_unix_test.go
Ignoring test code in os_test.go
Matchfile(/usr/local/go/src/os/executable.go) => true <nil>
Matchfile(/usr/local/go/src/os/error_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat.go) => true <nil>
Ignoring test code in error_windows_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/os/path_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/file.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_linux.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/stat_unix.go) => true <nil>
Ignoring test code in rawconn_test.go
Matchfile(/usr/local/go/src/os/stat_aix.go) => false <nil>
Matchfile(/usr/local/go/src/os/wait_waitid.go) => false <nil>
Ignoring test code in pipe_test.go
Matchfile(/usr/local/go/src/os/sys_unix.go) => true <nil>
Ignoring test code in os_windows_test.go
Ignoring test code in error_test.go
Matchfile(/usr/local/go/src/os/sys.go) => true <nil>
Matchfile(/usr/local/go/src/os/removeall_at.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/path.go) => true <nil>
Matchfile(/usr/local/go/src/os/path_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/pipe_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/os/file_posix.go) => true <nil>
Matchfile(/usr/local/go/src/os/stat_plan9.go) => false <nil>
Ignoring test code in stat_test.go
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go/src/os/wait_unimp.go) => true <nil>
Matchfile(/usr/local/go/src/os/file_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/executable_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/getwd_darwin.go) => true <nil>
Processing package=os:
Walking from /usr/local/go/src to /usr/local/go/src/os/exec
Processing os/exec:
Matchfile(/usr/local/go/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Matchfile(/usr/local/go/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in env_test.go
Matchfile(/usr/local/go/src/os/exec/lp_js.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec/lp_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/exec/exec.go) => true <nil>
Matchfile(/usr/local/go/src/os/exec/exec_unix.go) => true <nil>
Ignoring test code in lp_test.go
Matchfile(/usr/local/go/src/os/exec/exec_windows.go) => false <nil>
Ignoring test code in lp_windows_test.go
Ignoring test code in internal_test.go
Ignoring test code in lp_unix_test.go
Ignoring test code in exec_posix_test.go
Processing package=os/exec:
Walking from /usr/local/go/src to /usr/local/go/src/os/signal
Processing os/signal:
Matchfile(/usr/local/go/src/os/signal/signal.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in signal_plan9_test.go
Ignoring test code in signal_windows_test.go
Matchfile(/usr/local/go/src/os/signal/doc.go) => true <nil>
Ignoring test code in signal_test.go
Ignoring test code in signal_cgo_test.go
Matchfile(/usr/local/go/src/os/signal/signal_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/os/signal/signal_unix.go) => true <nil>
Processing package=os/signal:
Excluding /usr/local/go/src/os/signal/internal
Walking from /usr/local/go/src to /usr/local/go/src/os/user
Processing os/user:
Matchfile(/usr/local/go/src/os/user/lookup_android.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/user.go) => true <nil>
Ignoring test code in user_test.go
Matchfile(/usr/local/go/src/os/user/lookup_unix.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup_windows.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/getgrouplist_unix.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(/usr/local/go/src/os/user/lookup.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/cgo_lookup_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/getgrouplist_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(/usr/local/go/src/os/user/lookup_plan9.go) => false <nil>
Ignoring test code in lookup_unix_test.go
Processing package=os/user:
Walking from /usr/local/go/src to /usr/local/go/src/path
Processing path:
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in match_test.go
Matchfile(/usr/local/go/src/path/match.go) => true <nil>
Matchfile(/usr/local/go/src/path/path.go) => true <nil>
Processing package=path:
Walking from /usr/local/go/src to /usr/local/go/src/path/filepath
Processing path/filepath:
Matchfile(/usr/local/go/src/path/filepath/symlink.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in example_unix_test.go
Matchfile(/usr/local/go/src/path/filepath/symlink_windows.go) => false <nil>
Ignoring test code in example_unix_walk_test.go
Ignoring test code in path_windows_test.go
Matchfile(/usr/local/go/src/path/filepath/path_unix.go) => true <nil>
Ignoring test code in match_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/path/filepath/path_windows.go) => false <nil>
Matchfile(/usr/local/go/src/path/filepath/symlink_unix.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/match.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/path.go) => true <nil>
Matchfile(/usr/local/go/src/path/filepath/path_plan9.go) => false <nil>
Ignoring test code in export_windows_test.go
Processing package=path/filepath:
Walking from /usr/local/go/src to /usr/local/go/src/plugin
Processing plugin:
Matchfile(/usr/local/go/src/plugin/plugin_stubs.go) => false <nil>
Matchfile(/usr/local/go/src/plugin/plugin_dlopen.go) => true <nil>
Ignoring test code in plugin_test.go
Matchfile(/usr/local/go/src/plugin/plugin.go) => true <nil>
Processing package=plugin:
Walking from /usr/local/go/src to /usr/local/go/src/reflect
Processing reflect:
Matchfile(/usr/local/go/src/reflect/swapper.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/reflect/type.go) => true <nil>
Matchfile(/usr/local/go/src/reflect/deepequal.go) => true <nil>
Ignoring test code in set_test.go
Ignoring test code in all_test.go
Ignoring test code in export_test.go
Ignoring test code in tostring_test.go
Matchfile(/usr/local/go/src/reflect/makefunc.go) => true <nil>
Matchfile(/usr/local/go/src/reflect/value.go) => true <nil>
Processing package=reflect:
Walking from /usr/local/go/src to /usr/local/go/src/regexp
Processing regexp:
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in onepass_test.go
Matchfile(/usr/local/go/src/regexp/exec.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(/usr/local/go/src/regexp/backtrack.go) => true <nil>
Ignoring test code in exec2_test.go
Matchfile(/usr/local/go/src/regexp/regexp.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/onepass.go) => true <nil>
Ignoring test code in find_test.go
Processing package=regexp:
Walking from /usr/local/go/src to /usr/local/go/src/regexp/syntax
Processing regexp/syntax:
Matchfile(/usr/local/go/src/regexp/syntax/prog.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/simplify.go) => true <nil>
Ignoring test code in prog_test.go
Ignoring test code in parse_test.go
Ignoring test code in simplify_test.go
Matchfile(/usr/local/go/src/regexp/syntax/doc.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/compile.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/op_string.go) => true <nil>
Matchfile(/usr/local/go/src/regexp/syntax/parse.go) => true <nil>
Processing package=regexp/syntax:
Excluding /usr/local/go/src/regexp/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime
Processing runtime:
Matchfile(/usr/local/go/src/runtime/netpoll_stub.go) => false <nil>
Ignoring test code in export_mmap_test.go
Ignoring test code in fastlog2_test.go
Ignoring test code in treap_test.go
Matchfile(/usr/local/go/src/runtime/proc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/lock_js.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/net_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_elf64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mbitmap.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map_faststr.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/slice.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_amd64x.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/compiler.go) => true <nil>
Ignoring test code in memmove_linux_amd64_test.go
Ignoring test code in chan_test.go
Matchfile(/usr/local/go/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/error.go) => true <nil>
Ignoring test code in semasleep_test.go
Matchfile(/usr/local/go/src/runtime/symtab.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map_fast32.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lfstack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/env_posix.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/runtime/mwbbuf.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(/usr/local/go/src/runtime/profbuf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os2_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_amd64.go) => false <nil>
Ignoring test code in runtime_unix_test.go
Ignoring test code in slice_test.go
Matchfile(/usr/local/go/src/runtime/stubs_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_noauxv.go) => false <nil>
Ignoring test code in mfinal_test.go
Matchfile(/usr/local/go/src/runtime/defs_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os3_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mfinal.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/trace.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs3_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs2_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime2.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/atomic_pointer.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/time.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_nacl_arm.go) => false <nil>
Ignoring test code in env_test.go
Matchfile(/usr/local/go/src/runtime/alg.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs_386.go) => false <nil>
Ignoring test code in profbuf_test.go
Matchfile(/usr/local/go/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_arm64.go) => false <nil>
Ignoring test code in softfloat64_test.go
Matchfile(/usr/local/go/src/runtime/stubs_nonlinux.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/proflabel.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/msan.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgcsweep.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgclarge.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_mips64x.go) => false <nil>
Ignoring test code in numcpu_freebsd_test.go
Matchfile(/usr/local/go/src/runtime/sema.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/unaligned2.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os2_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/type.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/auxv_none.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/env_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux.go) => false <nil>
Ignoring test code in norace_linux_test.go
Matchfile(/usr/local/go/src/runtime/sigtab_aix.go) => false <nil>
Ignoring test code in gcinfo_test.go
Matchfile(/usr/local/go/src/runtime/mem_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_kqueue.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/syscall_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/fastlog2table.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mcache.go) => true <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(/usr/local/go/src/runtime/stubs32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgcstack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_x86.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_in_none.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lock_sema.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/iface.go) => true <nil>
Ignoring test code in string_test.go
Matchfile(/usr/local/go/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgocall.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo_ppc64x.go) => false <nil>
Ignoring test code in lfstack_test.go
Matchfile(/usr/local/go/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mcentral.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/syscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_wasm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_nacl.go) => false <nil>
Ignoring test code in map_benchmark_test.go
Matchfile(/usr/local/go/src/runtime/sys_darwin_64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/race.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/utf8.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/hash64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/chan.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgcmark.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/traceback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/panic.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(/usr/local/go/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigaction.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/float.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/heapdump.go) => true <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(/usr/local/go/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/write_err_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/hash32.go) => false <nil>
Ignoring test code in proc_test.go
Matchfile(/usr/local/go/src/runtime/sys_darwin_32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs1_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigtab_linux_generic.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/typekind.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sizeclasses.go) => true <nil>
Ignoring test code in runtime_mmap_test.go
Matchfile(/usr/local/go/src/runtime/race0.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/plugin.go) => true <nil>
Ignoring test code in hash_test.go
Matchfile(/usr/local/go/src/runtime/vdso_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/msize.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd.go) => false <nil>
Ignoring test code in crash_cgo_test.go
Matchfile(/usr/local/go/src/runtime/timestub2.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/debugcall.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_epoll.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_x86.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_arm.go) => false <nil>
Ignoring test code in rwmutex_test.go
Ignoring test code in crash_test.go
Ignoring test code in symtab_test.go
Matchfile(/usr/local/go/src/runtime/defs_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/debug.go) => true <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mstats.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/timeasm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/print.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_nonppc64x.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/vdso_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/softfloat64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cputicks.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/timestub.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mkduff.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cpuflags.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd.go) => false <nil>
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/runtime/mfixalloc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/unaligned1.go) => true <nil>
Ignoring test code in callers_test.go
Matchfile(/usr/local/go/src/runtime/mksizeclasses.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd_amd64.go) => false <nil>
Ignoring test code in crash_unix_test.go
Matchfile(/usr/local/go/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_ppc64le.go) => false <nil>
Ignoring test code in export_debug_test.go
Matchfile(/usr/local/go/src/runtime/syscall2_solaris.go) => false <nil>
Ignoring test code in futex_test.go
Ignoring test code in stack_test.go
Matchfile(/usr/local/go/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_amd64.go) => true <nil>
Ignoring test code in vlop_arm_test.go
Matchfile(/usr/local/go/src/runtime/signal_openbsd_arm.go) => false <nil>
Ignoring test code in closure_test.go
Ignoring test code in vdso_linux_test.go
Matchfile(/usr/local/go/src/runtime/rwmutex.go) => true <nil>
Ignoring test code in export_linux_test.go
Ignoring test code in iface_test.go
Matchfile(/usr/local/go/src/runtime/signal_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgocallback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/wincallback.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo.go) => true <nil>
Ignoring test code in complex_test.go
Matchfile(/usr/local/go/src/runtime/signal_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mbarrier.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/sigqueue.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_android.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/lock_futex.go) => false <nil>
Ignoring test code in gc_test.go
Matchfile(/usr/local/go/src/runtime/malloc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs3.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/msan0.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll.go) => true <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go/src/runtime/os_aix.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo_sigaction.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/fastlog2.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/relax_stub.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os3_solaris.go) => false <nil>
Ignoring test code in runtime_linux_test.go
Ignoring test code in runtime_test.go
Matchfile(/usr/local/go/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/complex.go) => true <nil>
Ignoring test code in runtime-gdb_test.go
Matchfile(/usr/local/go/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/runtime1.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mheap.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/rdebug.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_generic.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_js.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os2_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/stubs_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/netpoll_fake.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_js.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgocheck.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_noauxv.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/map_fast64.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_netbsd.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(/usr/local/go/src/runtime/write_err.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_unix.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mgc.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/mkfastlog2table.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mprof.go) => true <nil>
Ignoring test code in sizeof_test.go
Matchfile(/usr/local/go/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/defs_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/extern.go) => true <nil>
Ignoring test code in runtime-lldb_test.go
Matchfile(/usr/local/go/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vlrt.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo_mmap.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mem_linux.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/sys_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/string.go) => true <nil>
Ignoring test code in norace_test.go
Matchfile(/usr/local/go/src/runtime/sys_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cpuprof.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/stubs2.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(/usr/local/go/src/runtime/select.go) => true <nil>
Ignoring test code in chanbarrier_test.go
Ignoring test code in debug_test.go
Matchfile(/usr/local/go/src/runtime/mgcwork.go) => true <nil>
Ignoring test code in export_arm_test.go
Matchfile(/usr/local/go/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/os_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/mmap.go) => false <nil>
Ignoring test code in export_futex_test.go
Processing package=runtime:
Walking from /usr/local/go/src to /usr/local/go/src/runtime/cgo
Processing runtime/cgo:
Matchfile(/usr/local/go/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/sigaction.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/cgo/mmap.go) => false <nil>
Processing package=runtime/cgo:
Walking from /usr/local/go/src to /usr/local/go/src/runtime/debug
Processing runtime/debug:
Ignoring test code in garbage_test.go
Matchfile(/usr/local/go/src/runtime/debug/stack.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/debug/stubs.go) => true <nil>
Ignoring test code in stack_test.go
Matchfile(/usr/local/go/src/runtime/debug/garbage.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/debug/mod.go) => true <nil>
Ignoring test code in heapdump_test.go
Processing package=runtime/debug:
Excluding /usr/local/go/src/runtime/internal
Walking from /usr/local/go/src to /usr/local/go/src/runtime/msan
Processing runtime/msan:
Matchfile(/usr/local/go/src/runtime/msan/msan.go) => false <nil>
Walking from /usr/local/go/src to /usr/local/go/src/runtime/pprof
Processing runtime/pprof:
Matchfile(/usr/local/go/src/runtime/pprof/pprof.go) => true <nil>
Ignoring test code in mprof_test.go
Matchfile(/usr/local/go/src/runtime/pprof/runtime.go) => true <nil>
Ignoring test code in label_test.go
Matchfile(/usr/local/go/src/runtime/pprof/protomem.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/label.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/elf.go) => true <nil>
Ignoring test code in proto_test.go
Matchfile(/usr/local/go/src/runtime/pprof/map.go) => true <nil>
Ignoring test code in runtime_test.go
Ignoring test code in pprof_test.go
Matchfile(/usr/local/go/src/runtime/pprof/proto.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/pprof/protobuf.go) => true <nil>
Ignoring test code in protomem_test.go
Processing package=runtime/pprof:
Excluding /usr/local/go/src/runtime/pprof/internal
Excluding /usr/local/go/src/runtime/pprof/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime/race
Processing runtime/race:
Ignoring test code in race_unix_test.go
Ignoring test code in race_test.go
Ignoring test code in sched_test.go
Matchfile(/usr/local/go/src/runtime/race/race.go) => false <nil>
Matchfile(/usr/local/go/src/runtime/race/doc.go) => true <nil>
Ignoring test code in race_linux_test.go
Ignoring test code in race_windows_test.go
Ignoring test code in output_test.go
Processing package=runtime/race:
Excluding /usr/local/go/src/runtime/race/testdata
Excluding /usr/local/go/src/runtime/testdata
Walking from /usr/local/go/src to /usr/local/go/src/runtime/trace
Processing runtime/trace:
Ignoring test code in trace_test.go
Ignoring test code in example_test.go
Ignoring test code in annotation_test.go
Matchfile(/usr/local/go/src/runtime/trace/annotation.go) => true <nil>
Matchfile(/usr/local/go/src/runtime/trace/trace.go) => true <nil>
Ignoring test code in trace_stack_test.go
Processing package=runtime/trace:
Walking from /usr/local/go/src to /usr/local/go/src/sort
Processing sort:
Ignoring test code in example_search_test.go
Matchfile(/usr/local/go/src/sort/slice.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/sort/zfuncversion.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(/usr/local/go/src/sort/sort.go) => true <nil>
Matchfile(/usr/local/go/src/sort/genzfunc.go) => false <nil>
Ignoring test code in example_wrapper_test.go
Ignoring test code in sort_test.go
Matchfile(/usr/local/go/src/sort/search.go) => true <nil>
Ignoring test code in example_keys_test.go
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in example_multi_test.go
Processing package=sort:
Walking from /usr/local/go/src to /usr/local/go/src/strconv
Processing strconv:
Ignoring test code in atof_test.go
Matchfile(/usr/local/go/src/strconv/extfloat.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in quote_test.go
Matchfile(/usr/local/go/src/strconv/ftoa.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/decimal.go) => true <nil>
Ignoring test code in fp_test.go
Matchfile(/usr/local/go/src/strconv/quote.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/makeisprint.go) => false <nil>
Matchfile(/usr/local/go/src/strconv/doc.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/itoa.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/strconv/atof.go) => true <nil>
Matchfile(/usr/local/go/src/strconv/atob.go) => true <nil>
Ignoring test code in atoi_test.go
Ignoring test code in itoa_test.go
Ignoring test code in internal_test.go
Matchfile(/usr/local/go/src/strconv/isprint.go) => true <nil>
Ignoring test code in atob_test.go
Ignoring test code in decimal_test.go
Matchfile(/usr/local/go/src/strconv/atoi.go) => true <nil>
Ignoring test code in strconv_test.go
Ignoring test code in ftoa_test.go
Processing package=strconv:
Excluding /usr/local/go/src/strconv/testdata
Walking from /usr/local/go/src to /usr/local/go/src/strings
Processing strings:
Ignoring test code in replace_test.go
Ignoring test code in compare_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/strings/search.go) => true <nil>
Ignoring test code in search_test.go
Ignoring test code in export_test.go
Ignoring test code in strings_test.go
Matchfile(/usr/local/go/src/strings/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(/usr/local/go/src/strings/builder.go) => true <nil>
Matchfile(/usr/local/go/src/strings/replace.go) => true <nil>
Matchfile(/usr/local/go/src/strings/compare.go) => true <nil>
Matchfile(/usr/local/go/src/strings/strings.go) => true <nil>
Ignoring test code in builder_test.go
Processing package=strings:
Walking from /usr/local/go/src to /usr/local/go/src/sync
Processing sync:
Ignoring test code in map_bench_test.go
Ignoring test code in example_pool_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/sync/runtime.go) => true <nil>
Ignoring test code in once_test.go
Ignoring test code in mutex_test.go
Ignoring test code in rwmutex_test.go
Ignoring test code in map_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/sync/once.go) => true <nil>
Matchfile(/usr/local/go/src/sync/cond.go) => true <nil>
Matchfile(/usr/local/go/src/sync/rwmutex.go) => true <nil>
Matchfile(/usr/local/go/src/sync/map.go) => true <nil>
Ignoring test code in runtime_sema_test.go
Ignoring test code in pool_test.go
Matchfile(/usr/local/go/src/sync/mutex.go) => true <nil>
Matchfile(/usr/local/go/src/sync/pool.go) => true <nil>
Ignoring test code in waitgroup_test.go
Ignoring test code in map_reference_test.go
Ignoring test code in cond_test.go
Matchfile(/usr/local/go/src/sync/waitgroup.go) => true <nil>
Processing package=sync:
Walking from /usr/local/go/src to /usr/local/go/src/sync/atomic
Processing sync/atomic:
Ignoring test code in example_test.go
Ignoring test code in value_test.go
Matchfile(/usr/local/go/src/sync/atomic/doc.go) => true <nil>
Ignoring test code in atomic_test.go
Matchfile(/usr/local/go/src/sync/atomic/value.go) => true <nil>
Processing package=sync/atomic:
Walking from /usr/local/go/src to /usr/local/go/src/syscall
Processing syscall:
Matchfile(/usr/local/go/src/syscall/dirent.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/types_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/str.go) => true <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_amd64.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips.go) => false <nil>
Ignoring test code in exec_aix_test.go
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl.go) => false <nil>
Ignoring test code in dirent_bsd_test.go
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_windows_amd64.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fs_js.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Matchfile(/usr/local/go/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_amd64.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/bpf_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_libc.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Ignoring test code in syscall_bsd_test.go
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/msan.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysctl_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/dll_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/dir_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/timestruct.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_solaris.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_js.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/net.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/netlink_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/env_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd_32bit.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/mkasm_darwin.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_bsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/const_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/endian_big.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/security_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/lsf_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/bpf_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock_linux_32bit.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(/usr/local/go/src/syscall/net_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_unix.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/flock_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_bsd.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_windows.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/net_js.go) => false <nil>
Ignoring test code in exec_unix_test.go
Matchfile(/usr/local/go/src/syscall/forkpipe2.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/mkpost.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_aix.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fd_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Ignoring test code in export_linux_test.go
Matchfile(/usr/local/go/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/exec_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/unzip_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/msan0.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_darwin_386.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(/usr/local/go/src/syscall/syscall_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_darwin_arm.go) => false <nil>
Ignoring test code in syscall_test.go
Matchfile(/usr/local/go/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_linux_mips64x.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_aix_ppc64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/route_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Ignoring test code in syscall_freebsd_test.go
Matchfile(/usr/local/go/src/syscall/setuidgid_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_darwin_amd64.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/fs_nacl.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/flock_darwin.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/forkpipe.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_386.go) => false <nil>
Ignoring test code in syscall_linux_test.go
Matchfile(/usr/local/go/src/syscall/syscall_linux_mipsx.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_netbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/endian_little.go) => true <nil>
Matchfile(/usr/local/go/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/types_openbsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/sockcmsg_linux.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/ztypes_netbsd_386.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/errors_plan9.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/zerrors_aix_ppc64.go) => false <nil>
Ignoring test code in export_freebsd_test.go
Processing package=syscall:
Walking from /usr/local/go/src to /usr/local/go/src/syscall/js
Processing syscall/js:
Ignoring test code in js_test.go
Matchfile(/usr/local/go/src/syscall/js/typedarray.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/js/js.go) => false <nil>
Matchfile(/usr/local/go/src/syscall/js/func.go) => false <nil>
Excluding /usr/local/go/src/testdata
Walking from /usr/local/go/src to /usr/local/go/src/testing
Processing testing:
Ignoring test code in helper_test.go
Matchfile(/usr/local/go/src/testing/benchmark.go) => true <nil>
Ignoring test code in sub_test.go
Matchfile(/usr/local/go/src/testing/cover.go) => true <nil>
Matchfile(/usr/local/go/src/testing/allocs.go) => true <nil>
Ignoring test code in helperfuncs_test.go
Ignoring test code in allocs_test.go
Ignoring test code in testing_test.go
Ignoring test code in match_test.go
Matchfile(/usr/local/go/src/testing/example.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/testing/match.go) => true <nil>
Ignoring test code in benchmark_test.go
Matchfile(/usr/local/go/src/testing/testing.go) => true <nil>
Processing package=testing:
Excluding /usr/local/go/src/testing/internal
Walking from /usr/local/go/src to /usr/local/go/src/testing/iotest
Processing testing/iotest:
Matchfile(/usr/local/go/src/testing/iotest/logger.go) => true <nil>
Matchfile(/usr/local/go/src/testing/iotest/writer.go) => true <nil>
Matchfile(/usr/local/go/src/testing/iotest/reader.go) => true <nil>
Processing package=testing/iotest:
Walking from /usr/local/go/src to /usr/local/go/src/testing/quick
Processing testing/quick:
Ignoring test code in quick_test.go
Matchfile(/usr/local/go/src/testing/quick/quick.go) => true <nil>
Processing package=testing/quick:
Walking from /usr/local/go/src to /usr/local/go/src/text
Processing text:
Walking from /usr/local/go/src to /usr/local/go/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=text/scanner:
Walking from /usr/local/go/src to /usr/local/go/src/text/tabwriter
Processing text/tabwriter:
Ignoring test code in tabwriter_test.go
Ignoring test code in example_test.go
Matchfile(/usr/local/go/src/text/tabwriter/tabwriter.go) => true <nil>
Processing package=text/tabwriter:
Walking from /usr/local/go/src to /usr/local/go/src/text/template
Processing text/template:
Matchfile(/usr/local/go/src/text/template/option.go) => true <nil>
Ignoring test code in examplefunc_test.go
Ignoring test code in examplefiles_test.go
Ignoring test code in example_test.go
Ignoring test code in exec_test.go
Ignoring test code in multi_test.go
Matchfile(/usr/local/go/src/text/template/exec.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/template.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/helper.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/doc.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/funcs.go) => true <nil>
Processing package=text/template:
Walking from /usr/local/go/src to /usr/local/go/src/text/template/parse
Processing text/template/parse:
Ignoring test code in lex_test.go
Matchfile(/usr/local/go/src/text/template/parse/lex.go) => true <nil>
Ignoring test code in parse_test.go
Matchfile(/usr/local/go/src/text/template/parse/node.go) => true <nil>
Matchfile(/usr/local/go/src/text/template/parse/parse.go) => true <nil>
Processing package=text/template/parse:
Excluding /usr/local/go/src/text/template/testdata
Walking from /usr/local/go/src to /usr/local/go/src/time
Processing time:
Ignoring test code in zoneinfo_windows_test.go
Matchfile(/usr/local/go/src/time/sys_windows.go) => false <nil>
Ignoring test code in example_test.go
Ignoring test code in zoneinfo_android_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_android.go) => false <nil>
Ignoring test code in sleep_test.go
Matchfile(/usr/local/go/src/time/sys_plan9.go) => false <nil>
Ignoring test code in zoneinfo_test.go
Matchfile(/usr/local/go/src/time/time.go) => true <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_plan9.go) => false <nil>
Ignoring test code in format_test.go
Matchfile(/usr/local/go/src/time/format.go) => true <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_unix.go) => true <nil>
Ignoring test code in mono_test.go
Matchfile(/usr/local/go/src/time/genzabbrs.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo.go) => true <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_ios.go) => false <nil>
Matchfile(/usr/local/go/src/time/sleep.go) => true <nil>
Matchfile(/usr/local/go/src/time/tick.go) => true <nil>
Ignoring test code in tick_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/time/zoneinfo_read.go) => true <nil>
Matchfile(/usr/local/go/src/time/zoneinfo_js.go) => false <nil>
Ignoring test code in internal_test.go
Matchfile(/usr/local/go/src/time/sys_unix.go) => true <nil>
Ignoring test code in export_android_test.go
Ignoring test code in time_test.go
Ignoring test code in export_windows_test.go
Processing package=time:
Walking from /usr/local/go/src to /usr/local/go/src/unicode
Processing unicode:
Ignoring test code in example_test.go
Ignoring test code in graphic_test.go
Matchfile(/usr/local/go/src/unicode/maketables.go) => false <nil>
Ignoring test code in script_test.go
Matchfile(/usr/local/go/src/unicode/digit.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/tables.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/letter.go) => true <nil>
Ignoring test code in digit_test.go
Matchfile(/usr/local/go/src/unicode/graphic.go) => true <nil>
Matchfile(/usr/local/go/src/unicode/casetables.go) => true <nil>
Ignoring test code in letter_test.go
Processing package=unicode:
Walking from /usr/local/go/src to /usr/local/go/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in utf16_test.go
Ignoring test code in export_test.go
Matchfile(/usr/local/go/src/unicode/utf16/utf16.go) => true <nil>
Processing package=unicode/utf16:
Walking from /usr/local/go/src to /usr/local/go/src/unicode/utf8
Processing unicode/utf8:
Ignoring test code in example_test.go
Ignoring test code in utf8_test.go
Matchfile(/usr/local/go/src/unicode/utf8/utf8.go) => true <nil>
Processing package=unicode/utf8:
Walking from /usr/local/go/src to /usr/local/go/src/unsafe
Processing unsafe:
Matchfile(/usr/local/go/src/unsafe/unsafe.go) => true <nil>
NOTICE: Ignoring package unsafe in unsafe
JOKER TYPE archive/tar.Format from archive/tar/format.go:
(defn ^"GoObject" Format.
  "Constructor for tar.Format"
  {:added "1.0"
   :go "_ConstructFormat(_v)"}
  [^Object _v])

JOKER TYPE archive/tar.Header from archive/tar/common.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for tar.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/tar.Reader from archive/tar/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for tar.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE archive/tar.Writer from archive/tar/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for tar.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo input arguments: (fi os.FileInfo, link string)\n\nGo return type: (*Header, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi, ^String link]\n\nJoker return type: [(atom-of go.std.archive.tar/Header) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*fi, link)"}
;;   [^os/FileInfo fi, ^String link])

JOKER FUNC archive/tar.NewReader from archive/tar/reader.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.archive.tar/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC archive/tar.NewWriter from archive/tar/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.tar/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the archive/tar package."
    :empty false}
  go.std.archive.tar)
JOKER TYPE archive/zip.Compressor from archive/zip/register.go:
;; (defn ^"GoObject" Compressor.
;;   "Constructor for zip.Compressor"
;;   {:added "1.0"
;;    :go "_ConstructCompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.Decompressor from archive/zip/register.go:
;; (defn ^"GoObject" Decompressor.
;;   "Constructor for zip.Decompressor"
;;   {:added "1.0"
;;    :go "_ConstructDecompressor(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.File from archive/zip/reader.go:
(defn ^"GoObject" File.
  "Constructor for zip.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.FileHeader from archive/zip/struct.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for zip.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.ReadCloser from archive/zip/reader.go:
(defn ^"GoObject" ReadCloser.
  "Constructor for zip.ReadCloser"
  {:added "1.0"
   :go "_ConstructReadCloser(_v)"}
  [^Object _v])

JOKER TYPE archive/zip.Reader from archive/zip/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for zip.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE archive/zip.Writer from archive/zip/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for zip.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo input arguments: (fi os.FileInfo)\n\nGo return type: (*FileHeader, error)\n\nJoker input arguments: [^go.std.os/FileInfo fi]\n\nJoker return type: [(atom-of go.std.archive.zip/FileHeader) Error]"
;;   {:added "1.0"
;;    :go "__fileInfoHeader(*fi)"}
;;   [^os/FileInfo fi])

JOKER FUNC archive/zip.NewReader from archive/zip/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo input arguments: (r io.ReaderAt, size int64)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Number size]\n\nJoker return type: [(atom-of go.std.archive.zip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*r, size)"}
;;   [^io/ReaderAt r, ^Number size])

JOKER FUNC archive/zip.NewWriter from archive/zip/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.archive.zip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

JOKER FUNC archive/zip.OpenReader from archive/zip/reader.go:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo input arguments: (name string)\n\nGo return type: (*ReadCloser, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.archive.zip/ReadCloser) Error]"
  {:added "1.0"
   :go "__openReader(name)"}
  [^String name])

JOKER FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, comp Compressor)\n\nJoker input arguments: [^Int method, ^go.std.archive.zip/Compressor comp]"
;;   {:added "1.0"
;;    :go "__registerCompressor(method, *comp)"}
;;   [^Int method, ^zip/Compressor comp])

JOKER FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, dcomp Decompressor)\n\nJoker input arguments: [^Int method, ^go.std.archive.zip/Decompressor dcomp]"
;;   {:added "1.0"
;;    :go "__registerDecompressor(method, *dcomp)"}
;;   [^Int method, ^zip/Decompressor dcomp])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the archive/zip package."
    :empty false}
  go.std.archive.zip)
JOKER TYPE bufio.ReadWriter from bufio/bufio.go:
(defn ^"GoObject" ReadWriter.
  "Constructor for bufio.ReadWriter"
  {:added "1.0"
   :go "_ConstructReadWriter(_v)"}
  [^Object _v])

JOKER TYPE bufio.Reader from bufio/bufio.go:
(defn ^"GoObject" Reader.
  "Constructor for bufio.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE bufio.Scanner from bufio/scan.go:
(defn ^"GoObject" Scanner.
  "Constructor for bufio.Scanner"
  {:added "1.0"
   :go "_ConstructScanner(_v)"}
  [^Object _v])

JOKER TYPE bufio.SplitFunc from bufio/scan.go:
;; (defn ^"GoObject" SplitFunc.
;;   "Constructor for bufio.SplitFunc"
;;   {:added "1.0"
;;    :go "_ConstructSplitFunc(_v)"}
;;   [^Object _v])

JOKER TYPE bufio.Writer from bufio/bufio.go:
(defn ^"GoObject" Writer.
  "Constructor for bufio.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC bufio.NewReadWriter from bufio/bufio.go:
(defn NewReadWriter
  "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo input arguments: (r *Reader, w *Writer)\n\nGo return type: *ReadWriter\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.bufio/ReadWriter)"
  {:added "1.0"
   :go "__newReadWriter(r, w)"}
  [^bufio/Reader r, ^bufio/Writer w])

JOKER FUNC bufio.NewReader from bufio/bufio.go:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo input arguments: (rd io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*rd)"}
;;   [^io/Reader rd])

JOKER FUNC bufio.NewReaderSize from bufio/bufio.go:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo input arguments: (rd io.Reader, size int)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader rd, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Reader)"
;;   {:added "1.0"
;;    :go "__newReaderSize(*rd, size)"}
;;   [^io/Reader rd, ^Int size])

JOKER FUNC bufio.NewScanner from bufio/scan.go:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Scanner\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.bufio/Scanner)"
;;   {:added "1.0"
;;    :go "__newScanner(*r)"}
;;   [^io/Reader r])

JOKER FUNC bufio.NewWriter from bufio/bufio.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

JOKER FUNC bufio.NewWriterSize from bufio/bufio.go:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo input arguments: (w io.Writer, size int)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Int size]\n\nJoker return type: (atom-of go.std.bufio/Writer)"
;;   {:added "1.0"
;;    :go "__newWriterSize(*w, size)"}
;;   [^io/Writer w, ^Int size])

JOKER FUNC bufio.ScanBytes from bufio/scan.go:
;; (defn ScanBytes
;;   "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), atEOF)"}
;;   [^Object data, ^Boolean atEOF])

JOKER FUNC bufio.ScanLines from bufio/scan.go:
;; (defn ScanLines
;;   "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanLines(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), atEOF)"}
;;   [^Object data, ^Boolean atEOF])

JOKER FUNC bufio.ScanRunes from bufio/scan.go:
;; (defn ScanRunes
;;   "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanRunes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), atEOF)"}
;;   [^Object data, ^Boolean atEOF])

JOKER FUNC bufio.ScanWords from bufio/scan.go:
;; (defn ScanWords
;;   "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []byte, err error)\n\nJoker input arguments: [^(vector-of Int) data, ^Boolean atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__scanWords(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), atEOF)"}
;;   [^Object data, ^Boolean atEOF])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the bufio package."
    :empty false}
  go.std.bufio)
JOKER TYPE bytes.Buffer from bytes/buffer.go:
(defn ^"GoObject" Buffer.
  "Constructor for bytes.Buffer"
  {:added "1.0"
   :go "_ConstructBuffer(_v)"}
  [^Object _v])

JOKER TYPE bytes.Reader from bytes/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for bytes.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER FUNC bytes.Compare from bytes/bytes.go:
;; (defn ^"Int" Compare
;;   "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^(vector-of Int) b]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Compare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object a, ^Object b])

JOKER FUNC bytes.Contains from bytes/bytes.go:
;; (defn ^"Boolean" Contains
;;   "Contains reports whether subslice is within b.\n\nGo input arguments: (b []byte, subslice []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^(vector-of Int) subslice]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Contains(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(subslice)))"}
;;   [^Object b, ^Object subslice])

JOKER FUNC bytes.ContainsAny from bytes/bytes.go:
;; (defn ^"Boolean" ContainsAny
;;   "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo input arguments: (b []byte, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^String chars]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), chars)"}
;;   [^Object b, ^String chars])

JOKER FUNC bytes.ContainsRune from bytes/bytes.go:
;; (defn ^"Boolean" ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo input arguments: (b []byte, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) b, ^Char r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), r)"}
;;   [^Object b, ^Char r])

JOKER FUNC bytes.Count from bytes/bytes.go:
;; (defn ^"Int" Count
;;   "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Count(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.Equal from bytes/bytes.go:
;; (defn ^"Boolean" Equal
;;   "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a, ^(vector-of Int) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(a)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object a, ^Object b])

JOKER FUNC bytes.EqualFold from bytes/bytes.go:
;; (defn ^"Boolean" EqualFold
;;   "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s []byte, t []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) t]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.EqualFold(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(t)))"}
;;   [^Object s, ^Object t])

JOKER FUNC bytes.Fields from bytes/bytes.go:
;; (defn Fields
;;   "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fields(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.FieldsFunc from bytes/bytes.go:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__fieldsFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.HasPrefix from bytes/bytes.go:
;; (defn ^"Boolean" HasPrefix
;;   "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) prefix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(prefix)))"}
;;   [^Object s, ^Object prefix])

JOKER FUNC bytes.HasSuffix from bytes/bytes.go:
;; (defn ^"Boolean" HasSuffix
;;   "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) suffix]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "bytes.HasSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(suffix)))"}
;;   [^Object s, ^Object suffix])

JOKER FUNC bytes.Index from bytes/bytes.go:
;; (defn ^"Int" Index
;;   "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.Index(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.IndexAny from bytes/bytes.go:
;; (defn ^"Int" IndexAny
;;   "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), chars)"}
;;   [^Object s, ^String chars])

JOKER FUNC bytes.IndexByte from bytes/bytes.go:
;; (defn ^"Int" IndexByte
;;   "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo input arguments: (b []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) b, ^Int c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), c)"}
;;   [^Object b, ^Int c])

JOKER FUNC bytes.IndexFunc from bytes/bytes.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.IndexRune from bytes/bytes.go:
;; (defn ^"Int" IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^Char r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), r)"}
;;   [^Object s, ^Char r])

JOKER FUNC bytes.Join from bytes/bytes.go:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo input arguments: (s [][]byte, sep []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of (vector-of Int)) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__join(ConvertToArrayOf[]byte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s))), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.LastIndex from bytes/bytes.go:
;; (defn ^"Int" LastIndex
;;   "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndex(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.LastIndexAny from bytes/bytes.go:
;; (defn ^"Int" LastIndexAny
;;   "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^String chars]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexAny(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), chars)"}
;;   [^Object s, ^String chars])

JOKER FUNC bytes.LastIndexByte from bytes/bytes.go:
;; (defn ^"Int" LastIndexByte
;;   "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^Int c]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexByte(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), c)"}
;;   [^Object s, ^Int c])

JOKER FUNC bytes.LastIndexFunc from bytes/bytes.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.Map from bytes/bytes.go:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo input arguments: (mapping func, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^fn mapping, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^fn mapping, ^Object s])

JOKER FUNC bytes.NewBuffer from bytes/buffer.go:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to set\nthe initial size of the internal buffer for writing. To do that,\nbuf should have the desired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (buf []byte)\n\nGo return type: *Buffer\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
;;   {:added "1.0"
;;    :go "__newBuffer(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^Object buf])

JOKER FUNC bytes.NewBufferString from bytes/buffer.go:
(defn NewBufferString
  "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (s string)\n\nGo return type: *Buffer\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.bytes/Buffer)"
  {:added "1.0"
   :go "__newBufferString(s)"}
  [^String s])

JOKER FUNC bytes.NewReader from bytes/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo input arguments: (b []byte)\n\nGo return type: *Reader\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: (atom-of go.std.bytes/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC bytes.Repeat from bytes/bytes.go:
;; (defn Repeat
;;   "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo input arguments: (b []byte, count int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) b, ^Int count]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__repeat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), count)"}
;;   [^Object b, ^Int count])

JOKER FUNC bytes.Replace from bytes/bytes.go:
;; (defn Replace
;;   "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s []byte, old []byte, new []byte, n int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) old, ^(vector-of Int) new, ^Int n]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__replace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(old)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(new)), n)"}
;;   [^Object s, ^Object old, ^Object new, ^Int n])

JOKER FUNC bytes.ReplaceAll from bytes/bytes.go:
;; (defn ReplaceAll
;;   "ReplaceAll returns a copy of the slice s with all\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\n\nGo input arguments: (s []byte, old []byte, new []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) old, ^(vector-of Int) new]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__replaceAll(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(old)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(new)))"}
;;   [^Object s, ^Object old, ^Object new])

JOKER FUNC bytes.Runes from bytes/bytes.go:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo input arguments: (s []byte)\n\nGo return type: []rune\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Char)"
;;   {:added "1.0"
;;    :go "__runes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.Split from bytes/bytes.go:
;; (defn Split
;;   "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__split(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.SplitAfter from bytes/bytes.go:
;; (defn SplitAfter
;;   "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfter(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)))"}
;;   [^Object s, ^Object sep])

JOKER FUNC bytes.SplitAfterN from bytes/bytes.go:
;; (defn SplitAfterN
;;   "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitAfterN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)), n)"}
;;   [^Object s, ^Object sep, ^Int n])

JOKER FUNC bytes.SplitN from bytes/bytes.go:
;; (defn SplitN
;;   "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "__splitN(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sep)), n)"}
;;   [^Object s, ^Object sep, ^Int n])

JOKER FUNC bytes.Title from bytes/bytes.go:
;; (defn Title
;;   "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__title(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.ToLower from bytes/bytes.go:
;; (defn ToLower
;;   "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLower(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.ToLowerSpecial from bytes/bytes.go:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toLowerSpecial(*c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^unicode/SpecialCase c, ^Object s])

JOKER FUNC bytes.ToTitle from bytes/bytes.go:
;; (defn ToTitle
;;   "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitle(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.ToTitleSpecial from bytes/bytes.go:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toTitleSpecial(*c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^unicode/SpecialCase c, ^Object s])

JOKER FUNC bytes.ToUpper from bytes/bytes.go:
;; (defn ToUpper
;;   "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpper(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.ToUpperSpecial from bytes/bytes.go:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__toUpperSpecial(*c, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^unicode/SpecialCase c, ^Object s])

JOKER FUNC bytes.Trim from bytes/bytes.go:
;; (defn Trim
;;   "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trim(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), cutset)"}
;;   [^Object s, ^String cutset])

JOKER FUNC bytes.TrimFunc from bytes/bytes.go:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.TrimLeft from bytes/bytes.go:
;; (defn TrimLeft
;;   "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeft(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), cutset)"}
;;   [^Object s, ^String cutset])

JOKER FUNC bytes.TrimLeftFunc from bytes/bytes.go:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimLeftFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.TrimPrefix from bytes/bytes.go:
;; (defn TrimPrefix
;;   "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) prefix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimPrefix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(prefix)))"}
;;   [^Object s, ^Object prefix])

JOKER FUNC bytes.TrimRight from bytes/bytes.go:
;; (defn TrimRight
;;   "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRight(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), cutset)"}
;;   [^Object s, ^String cutset])

JOKER FUNC bytes.TrimRightFunc from bytes/bytes.go:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimRightFunc(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Object s, ^fn f])

JOKER FUNC bytes.TrimSpace from bytes/bytes.go:
;; (defn TrimSpace
;;   "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo input arguments: (s []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSpace(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^Object s])

JOKER FUNC bytes.TrimSuffix from bytes/bytes.go:
;; (defn TrimSuffix
;;   "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) s, ^(vector-of Int) suffix]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimSuffix(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(suffix)))"}
;;   [^Object s, ^Object suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the bytes package."
    :empty false}
  go.std.bytes)
JOKER TYPE compress/bzip2.StructuralError from compress/bzip2/bzip2.go:
(defn ^"GoObject" StructuralError.
  "Constructor for bzip2.StructuralError"
  {:added "1.0"
   :go "_ConstructStructuralError(_v)"}
  [^Object _v])

JOKER FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the compress/bzip2 package."
    :empty false}
  go.std.compress.bzip2)
JOKER TYPE compress/flate.CorruptInputError from compress/flate/inflate.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for flate.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.InternalError from compress/flate/inflate.go:
(defn ^"GoObject" InternalError.
  "Constructor for flate.InternalError"
  {:added "1.0"
   :go "_ConstructInternalError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.ReadError from compress/flate/inflate.go:
(defn ^"GoObject" ReadError.
  "Constructor for flate.ReadError"
  {:added "1.0"
   :go "_ConstructReadError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.Reader from compress/flate/inflate.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for flate.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE compress/flate.Resetter from compress/flate/inflate.go:
;; (defn ^"GoObject" Resetter.
;;   "Constructor for flate.Resetter"
;;   {:added "1.0"
;;    :go "_ConstructResetter(_v)"}
;;   [^Object _v])

JOKER TYPE compress/flate.WriteError from compress/flate/inflate.go:
(defn ^"GoObject" WriteError.
  "Constructor for flate.WriteError"
  {:added "1.0"
   :go "_ConstructWriteError(_v)"}
  [^Object _v])

JOKER TYPE compress/flate.Writer from compress/flate/deflate.go:
(defn ^"GoObject" Writer.
  "Constructor for flate.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/flate.NewReader from compress/flate/inflate.go:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) dict]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReaderDict(*r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dict)))"}
;;   [^io/Reader r, ^Object dict])

JOKER FUNC compress/flate.NewWriter from compress/flate/deflate.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriter(*w, level)"}
;;   [^io/Writer w, ^Int level])

JOKER FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Int) dict]\n\nJoker return type: [(atom-of go.std.compress.flate/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterDict(*w, level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dict)))"}
;;   [^io/Writer w, ^Int level, ^Object dict])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the compress/flate package."
    :empty false}
  go.std.compress.flate)
JOKER TYPE compress/gzip.Header from compress/gzip/gunzip.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for gzip.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE compress/gzip.Reader from compress/gzip/gunzip.go:
(defn ^"GoObject" Reader.
  "Constructor for gzip.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE compress/gzip.Writer from compress/gzip/gzip.go:
(defn ^"GoObject" Writer.
  "Constructor for gzip.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.compress.gzip/Reader) Error]"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.gzip/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

JOKER FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.gzip/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*w, level)"}
;;   [^io/Writer w, ^Int level])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the compress/gzip package."
    :empty false}
  go.std.compress.gzip)
JOKER FUNC compress/lzw.NewReader from compress/lzw/reader.go:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo input arguments: (r io.Reader, order Order, litWidth int)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__newReader(*r, *order, litWidth)"}
;;   [^io/Reader r, ^lzw/Order order, ^Int litWidth])

JOKER FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo input arguments: (w io.Writer, order Order, litWidth int)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.compress.lzw/Order order, ^Int litWidth]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newWriter(*w, *order, litWidth)"}
;;   [^io/Writer w, ^lzw/Order order, ^Int litWidth])

JOKER TYPE compress/zlib.Resetter from compress/zlib/reader.go:
;; (defn ^"GoObject" Resetter.
;;   "Constructor for zlib.Resetter"
;;   {:added "1.0"
;;    :go "_ConstructResetter(_v)"}
;;   [^Object _v])

JOKER TYPE compress/zlib.Writer from compress/zlib/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for zlib.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC compress/zlib.NewReader from compress/zlib/reader.go:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: (io.ReadCloser, error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) dict]\n\nJoker return type: [go.std.io/ReadCloser Error]"
;;   {:added "1.0"
;;    :go "__newReaderDict(*r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dict)))"}
;;   [^io/Reader r, ^Object dict])

JOKER FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.compress.zlib/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

JOKER FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevel(*w, level)"}
;;   [^io/Writer w, ^Int level])

JOKER FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Int level, ^(vector-of Int) dict]\n\nJoker return type: [(atom-of go.std.compress.zlib/Writer) Error]"
;;   {:added "1.0"
;;    :go "__newWriterLevelDict(*w, level, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dict)))"}
;;   [^io/Writer w, ^Int level, ^Object dict])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the compress/zlib package."
    :empty false}
  go.std.compress.zlib)
JOKER FUNC container/heap.Fix from container/heap/heap.go:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]"
;;   {:added "1.0"
;;    :go "__fix(*h, i)"}
;;   [^heap/Interface h, ^Int i])

JOKER FUNC container/heap.Init from container/heap/heap.go:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nThe complexity is O(n) where n = h.Len().\n\nGo input arguments: (h Interface)\n\nJoker input arguments: [^go.std.container.heap/Interface h]"
;;   {:added "1.0"
;;    :go "__init(*h)"}
;;   [^heap/Interface h])

JOKER FUNC container/heap.Pop from container/heap/heap.go:
;; (defn Pop
;;   "Pop removes and returns the minimum element (according to Less) from the heap.\nThe complexity is O(log n) where n = h.Len().\nPop is equivalent to Remove(h, 0).\n\nGo input arguments: (h Interface)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/container/heap/heap.go:60:23)"
;;   {:added "1.0"
;;    :go "__pop(*h)"}
;;   [^heap/Interface h])

JOKER FUNC container/heap.Push from container/heap/heap.go:
;; (defn Push
;;   "Push pushes the element x onto the heap.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, x interface {})\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__push(*h, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^heap/Interface h, ^<protocol-or-something> x])

JOKER FUNC container/heap.Remove from container/heap/heap.go:
;; (defn Remove
;;   "Remove removes and returns the element at index i from the heap.\nThe complexity is O(log n) where n = h.Len().\n\nGo input arguments: (h Interface, i int)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.container.heap/Interface h, ^Int i]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/container/heap/heap.go:69:33)"
;;   {:added "1.0"
;;    :go "__remove(*h, i)"}
;;   [^heap/Interface h, ^Int i])

JOKER TYPE container/list.Element from container/list/list.go:
;; (defn ^"GoObject" Element.
;;   "Constructor for list.Element"
;;   {:added "1.0"
;;    :go "_ConstructElement(_v)"}
;;   [^Object _v])

JOKER TYPE container/list.List from container/list/list.go:
(defn ^"GoObject" List.
  "Constructor for list.List"
  {:added "1.0"
   :go "_ConstructList(_v)"}
  [^Object _v])

JOKER FUNC container/list.New from container/list/list.go:
(defn New
  "New returns an initialized list.\n\nGo return type: *List\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.container.list/List)"
  {:added "1.0"
   :go "__new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/list package."
    :empty false}
  go.std.container.list)
JOKER TYPE container/ring.Ring from container/ring/ring.go:
;; (defn ^"GoObject" Ring.
;;   "Constructor for ring.Ring"
;;   {:added "1.0"
;;    :go "_ConstructRing(_v)"}
;;   [^Object _v])

JOKER FUNC container/ring.New from container/ring/ring.go:
(defn New
  "New creates a ring of n elements.\n\nGo input arguments: (n int)\n\nGo return type: *Ring\n\nJoker input arguments: [^Int n]\n\nJoker return type: (atom-of go.std.container.ring/Ring)"
  {:added "1.0"
   :go "__new(n)"}
  [^Int n])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the container/ring package."
    :empty false}
  go.std.container.ring)
JOKER TYPE context.CancelFunc from context/context.go:
;; (defn ^"GoObject" CancelFunc.
;;   "Constructor for context.CancelFunc"
;;   {:added "1.0"
;;    :go "_ConstructCancelFunc(_v)"}
;;   [^Object _v])

JOKER TYPE context.Context from context/context.go:
;; (defn ^"GoObject" Context.
;;   "Constructor for context.Context"
;;   {:added "1.0"
;;    :go "_ConstructContext(_v)"}
;;   [^Object _v])

JOKER FUNC context.Background from context/context.go:
(defn Background
  "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__background()"}
  [])

JOKER FUNC context.TODO from context/context.go:
(defn TODO
  "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter).\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: go.std.context/Context"
  {:added "1.0"
   :go "__tODO()"}
  [])

JOKER FUNC context.WithCancel from context/context.go:
(defn WithCancel
  "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context)\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
  {:added "1.0"
   :go "__withCancel(*parent)"}
  [^context/Context parent])

JOKER FUNC context.WithDeadline from context/context.go:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent Context, d time.Time)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Time d]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withDeadline(*parent, *d)"}
;;   [^context/Context parent, ^time/Time d])

JOKER FUNC context.WithTimeout from context/context.go:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo input arguments: (parent Context, timeout time.Duration)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^go.std.context/Context parent, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.context/Context go.std.context/CancelFunc]"
;;   {:added "1.0"
;;    :go "__withTimeout(*parent, *timeout)"}
;;   [^context/Context parent, ^time/Duration timeout])

JOKER FUNC context.WithValue from context/context.go:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo input arguments: (parent Context, key interface {}, val interface {})\n\nGo return type: Context\n\nJoker input arguments: [^go.std.context/Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withValue(*parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^context/Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the context package."
    :empty false}
  go.std.context)
JOKER TYPE crypto.Decrypter from crypto/crypto.go:
;; (defn ^"GoObject" Decrypter.
;;   "Constructor for crypto.Decrypter"
;;   {:added "1.0"
;;    :go "_ConstructDecrypter(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.DecrypterOpts from crypto/crypto.go:
;; (defn ^"GoObject" DecrypterOpts.
;;   "Constructor for crypto.DecrypterOpts"
;;   {:added "1.0"
;;    :go "_ConstructDecrypterOpts(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.Hash from crypto/crypto.go:
(defn ^"GoObject" Hash.
  "Constructor for crypto.Hash"
  {:added "1.0"
   :go "_ConstructHash(_v)"}
  [^Object _v])

JOKER TYPE crypto.PrivateKey from crypto/crypto.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for crypto.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.PublicKey from crypto/crypto.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for crypto.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.Signer from crypto/crypto.go:
;; (defn ^"GoObject" Signer.
;;   "Constructor for crypto.Signer"
;;   {:added "1.0"
;;    :go "_ConstructSigner(_v)"}
;;   [^Object _v])

JOKER TYPE crypto.SignerOpts from crypto/crypto.go:
;; (defn ^"GoObject" SignerOpts.
;;   "Constructor for crypto.SignerOpts"
;;   {:added "1.0"
;;    :go "_ConstructSignerOpts(_v)"}
;;   [^Object _v])

JOKER FUNC crypto.RegisterHash from crypto/crypto.go:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n\nGo input arguments: (h Hash, f func)\n\nJoker input arguments: [^go.std.crypto/Hash h, ^fn f]"
;;   {:added "1.0"
;;    :go "__registerHash(*h, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^crypto/Hash h, ^fn f])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto package."
    :empty false}
  go.std.crypto)
JOKER TYPE crypto/aes.KeySizeError from crypto/aes/cipher.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for aes.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^Object key])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/aes package."
    :empty false}
  go.std.crypto.aes)
JOKER TYPE crypto/cipher.AEAD from crypto/cipher/gcm.go:
;; (defn ^"GoObject" AEAD.
;;   "Constructor for cipher.AEAD"
;;   {:added "1.0"
;;    :go "_ConstructAEAD(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Block from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Block.
;;   "Constructor for cipher.Block"
;;   {:added "1.0"
;;    :go "_ConstructBlock(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.BlockMode from crypto/cipher/cipher.go:
;; (defn ^"GoObject" BlockMode.
;;   "Constructor for cipher.BlockMode"
;;   {:added "1.0"
;;    :go "_ConstructBlockMode(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.Stream from crypto/cipher/cipher.go:
;; (defn ^"GoObject" Stream.
;;   "Constructor for cipher.Stream"
;;   {:added "1.0"
;;    :go "_ConstructStream(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.StreamReader from crypto/cipher/io.go:
;; (defn ^"GoObject" StreamReader.
;;   "Constructor for cipher.StreamReader"
;;   {:added "1.0"
;;    :go "_ConstructStreamReader(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/cipher.StreamWriter from crypto/cipher/io.go:
;; (defn ^"GoObject" StreamWriter.
;;   "Constructor for cipher.StreamWriter"
;;   {:added "1.0"
;;    :go "_ConstructStreamWriter(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCDecrypter(*b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block b, ^Object iv])

JOKER FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/BlockMode"
;;   {:added "1.0"
;;    :go "__newCBCEncrypter(*b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block b, ^Object iv])

JOKER FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBDecrypter(*block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block block, ^Object iv])

JOKER FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCFBEncrypter(*block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block block, ^Object iv])

JOKER FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo input arguments: (block Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block block, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newCTR(*block, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block block, ^Object iv])

JOKER FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
(defn NewGCM
  "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo input arguments: (cipher Block)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCM(*cipher)"}
  [^cipher/Block cipher])

JOKER FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
(defn NewGCMWithNonceSize
  "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo input arguments: (cipher Block, size int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int size]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithNonceSize(*cipher, size)"}
  [^cipher/Block cipher, ^Int size])

JOKER FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
(defn NewGCMWithTagSize
  "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo input arguments: (cipher Block, tagSize int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^go.std.crypto.cipher/Block cipher, ^Int tagSize]\n\nJoker return type: [go.std.crypto.cipher/AEAD Error]"
  {:added "1.0"
   :go "__newGCMWithTagSize(*cipher, tagSize)"}
  [^cipher/Block cipher, ^Int tagSize])

JOKER FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo input arguments: (b Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^go.std.crypto.cipher/Block b, ^(vector-of Int) iv]\n\nJoker return type: go.std.crypto.cipher/Stream"
;;   {:added "1.0"
;;    :go "__newOFB(*b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(iv)))"}
;;   [^cipher/Block b, ^Object iv])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/cipher package."
    :empty false}
  go.std.crypto.cipher)
JOKER TYPE crypto/des.KeySizeError from crypto/des/cipher.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for des.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/des.NewCipher from crypto/des/cipher.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^Object key])

JOKER FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (crypto/cipher.Block, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [go.std.crypto.cipher/Block Error]"
;;   {:added "1.0"
;;    :go "__newTripleDESCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^Object key])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/des package."
    :empty false}
  go.std.crypto.des)
JOKER FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo input arguments: (priv *PrivateKey, rand io.Reader)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^go.std.io/Reader rand]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(priv, *rand)"}
;;   [^dsa/PrivateKey priv, ^io/Reader rand])

JOKER FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
;; (defn ^"Error" GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo input arguments: (params *Parameters, rand io.Reader, sizes ParameterSizes)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/Parameters) params, ^go.std.io/Reader rand, ^go.std.crypto.dsa/ParameterSizes sizes]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(params, *rand, *sizes)"}
;;   [^dsa/Parameters params, ^io/Reader rand, ^dsa/ParameterSizes sizes])

JOKER FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.dsa/PrivateKey) priv, ^(vector-of Int) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*rand, priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hash)))"}
;;   [^io/Reader rand, ^dsa/PrivateKey priv, ^Object hash])

JOKER FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.dsa/PublicKey) pub, ^(vector-of Int) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "dsa.Verify(pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hash)), r, s)"}
;;   [^dsa/PublicKey pub, ^Object hash, ^big/Int r, ^big/Int s])

JOKER TYPE crypto/ecdsa.PrivateKey from crypto/ecdsa/ecdsa.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for ecdsa.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/ecdsa.PublicKey from crypto/ecdsa/ecdsa.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for ecdsa.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo input arguments: (c elliptic.Curve, rand io.Reader)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve c, ^go.std.io/Reader rand]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*c, *rand)"}
;;   [^elliptic/Curve c, ^io/Reader rand])

JOKER FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash []byte)\n\nGo return type: (r *math/big.Int, s *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.ecdsa/PrivateKey) priv, ^(vector-of Int) hash]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__sign(*rand, priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hash)))"}
;;   [^io/Reader rand, ^ecdsa/PrivateKey priv, ^Object hash])

JOKER FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
;; (defn ^"Boolean" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo input arguments: (pub *PublicKey, hash []byte, r *big.Int, s *big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PublicKey) pub, ^(vector-of Int) hash, ^(atom-of go.std.math.big/Int) r, ^(atom-of go.std.math.big/Int) s]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hash)), r, s)"}
;;   [^ecdsa/PublicKey pub, ^Object hash, ^big/Int r, ^big/Int s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/ecdsa package."
    :empty false}
  go.std.crypto.ecdsa)
JOKER TYPE crypto/elliptic.Curve from crypto/elliptic/elliptic.go:
;; (defn ^"GoObject" Curve.
;;   "Constructor for elliptic.Curve"
;;   {:added "1.0"
;;    :go "_ConstructCurve(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/elliptic.CurveParams from crypto/elliptic/elliptic.go:
;; (defn ^"GoObject" CurveParams.
;;   "Constructor for elliptic.CurveParams"
;;   {:added "1.0"
;;    :go "_ConstructCurveParams(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo input arguments: (curve Curve, rand io.Reader)\n\nGo return type: (priv []byte, x *math/big.Int, y *math/big.Int, err error)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^go.std.io/Reader rand]\n\nJoker return type: [(vector-of Int) (atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*curve, *rand)"}
;;   [^elliptic/Curve curve, ^io/Reader rand])

JOKER FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo input arguments: (curve Curve, x *big.Int, y *big.Int)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshal(*curve, x, y)"}
;;   [^elliptic/Curve curve, ^big/Int x, ^big/Int y])

JOKER FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
(defn P224
  "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p224()"}
  [])

JOKER FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
(defn P256
  "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p256()"}
  [])

JOKER FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
(defn P384
  "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p384()"}
  [])

JOKER FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
(defn P521
  "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: go.std.crypto.elliptic/Curve"
  {:added "1.0"
   :go "__p521()"}
  [])

JOKER FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo input arguments: (curve Curve, data []byte)\n\nGo return type: (x *math/big.Int, y *math/big.Int)\n\nJoker input arguments: [^go.std.crypto.elliptic/Curve curve, ^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.math.big/Int) (atom-of go.std.math.big/Int)]"
;;   {:added "1.0"
;;    :go "__unmarshal(*curve, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^elliptic/Curve curve, ^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/elliptic package."
    :empty false}
  go.std.crypto.elliptic)
JOKER FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
;; (defn ^"Boolean" Equal
;;   "Equal compares two MACs for equality without leaking timing information.\n\nGo input arguments: (mac1 []byte, mac2 []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) mac1, ^(vector-of Int) mac2]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "hmac.Equal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(mac1)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(mac2)))"}
;;   [^Object mac1, ^Object mac2])

JOKER FUNC crypto/hmac.New from crypto/hmac/hmac.go:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo input arguments: (h func, key []byte)\n\nGo return type: hash.Hash\n\nJoker input arguments: [^fn h, ^(vector-of Int) key]\n\nJoker return type: go.std.hash/Hash"
;;   {:added "1.0"
;;    :go "__new(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^fn h, ^Object key])

JOKER FUNC crypto/md5.New from crypto/md5/md5.go:
(defn New
  "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/md5.Sum from crypto/md5/md5.go:
;; (defn Sum
;;   "Sum returns the MD5 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/md5 package."
    :empty false}
  go.std.crypto.md5)
JOKER FUNC crypto/rand.Int from crypto/rand/util.go:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo input arguments: (rand io.Reader, max *big.Int)\n\nGo return type: (n *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.math.big/Int) max]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__int(*rand, max)"}
;;   [^io/Reader rand, ^big/Int max])

JOKER FUNC crypto/rand.Prime from crypto/rand/util.go:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo input arguments: (rand io.Reader, bits int)\n\nGo return type: (p *math/big.Int, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^Int bits]\n\nJoker return type: [(atom-of go.std.math.big/Int) Error]"
;;   {:added "1.0"
;;    :go "__prime(*rand, bits)"}
;;   [^io/Reader rand, ^Int bits])

JOKER FUNC crypto/rand.Read from crypto/rand/rand.go:
;; (defn Read
;;   "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo input arguments: (b []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER TYPE crypto/rc4.Cipher from crypto/rc4/rc4.go:
(defn ^"GoObject" Cipher.
  "Constructor for rc4.Cipher"
  {:added "1.0"
   :go "_ConstructCipher(_v)"}
  [^Object _v])

JOKER TYPE crypto/rc4.KeySizeError from crypto/rc4/rc4.go:
(defn ^"GoObject" KeySizeError.
  "Constructor for rc4.KeySizeError"
  {:added "1.0"
   :go "_ConstructKeySizeError(_v)"}
  [^Object _v])

JOKER FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
;; (defn NewCipher
;;   "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo input arguments: (key []byte)\n\nGo return type: (*Cipher, error)\n\nJoker input arguments: [^(vector-of Int) key]\n\nJoker return type: [(atom-of go.std.crypto.rc4/Cipher) Error]"
;;   {:added "1.0"
;;    :go "__newCipher(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^Object key])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/rc4 package."
    :empty false}
  go.std.crypto.rc4)
JOKER TYPE crypto/rsa.CRTValue from crypto/rsa/rsa.go:
;; (defn ^"GoObject" CRTValue.
;;   "Constructor for rsa.CRTValue"
;;   {:added "1.0"
;;    :go "_ConstructCRTValue(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.OAEPOptions from crypto/rsa/rsa.go:
;; (defn ^"GoObject" OAEPOptions.
;;   "Constructor for rsa.OAEPOptions"
;;   {:added "1.0"
;;    :go "_ConstructOAEPOptions(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PKCS1v15DecryptOptions from crypto/rsa/pkcs1v15.go:
(defn ^"GoObject" PKCS1v15DecryptOptions.
  "Constructor for rsa.PKCS1v15DecryptOptions"
  {:added "1.0"
   :go "_ConstructPKCS1v15DecryptOptions(_v)"}
  [^Object _v])

JOKER TYPE crypto/rsa.PSSOptions from crypto/rsa/pss.go:
;; (defn ^"GoObject" PSSOptions.
;;   "Constructor for rsa.PSSOptions"
;;   {:added "1.0"
;;    :go "_ConstructPSSOptions(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PrecomputedValues from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PrecomputedValues.
;;   "Constructor for rsa.PrecomputedValues"
;;   {:added "1.0"
;;    :go "_ConstructPrecomputedValues(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PrivateKey from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PrivateKey.
;;   "Constructor for rsa.PrivateKey"
;;   {:added "1.0"
;;    :go "_ConstructPrivateKey(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/rsa.PublicKey from crypto/rsa/rsa.go:
;; (defn ^"GoObject" PublicKey.
;;   "Constructor for rsa.PublicKey"
;;   {:added "1.0"
;;    :go "_ConstructPublicKey(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction  the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo input arguments: (hash hash.Hash, random io.Reader, priv *PrivateKey, ciphertext []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext, ^(vector-of Int) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptOAEP(*hash, *random, priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(label)))"}
;;   [^hash/Hash hash, ^io/Reader random, ^rsa/PrivateKey priv, ^Object ciphertext, ^Object label])

JOKER FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPKCS1v15(*rand, priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(ciphertext)))"}
;;   [^io/Reader rand, ^rsa/PrivateKey priv, ^Object ciphertext])

JOKER FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, ciphertext []byte, key []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^(vector-of Int) ciphertext, ^(vector-of Int) key]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(*rand, priv, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(ciphertext)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(key)))"}
;;   [^io/Reader rand, ^rsa/PrivateKey priv, ^Object ciphertext, ^Object key])

JOKER FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo input arguments: (hash hash.Hash, random io.Reader, pub *PublicKey, msg []byte, label []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.hash/Hash hash, ^go.std.io/Reader random, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Int) msg, ^(vector-of Int) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptOAEP(*hash, *random, pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(msg)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(label)))"}
;;   [^hash/Hash hash, ^io/Reader random, ^rsa/PublicKey pub, ^Object msg, ^Object label])

JOKER FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo input arguments: (rand io.Reader, pub *PublicKey, msg []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PublicKey) pub, ^(vector-of Int) msg]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__encryptPKCS1v15(*rand, pub, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(msg)))"}
;;   [^io/Reader rand, ^rsa/PublicKey pub, ^Object msg])

JOKER FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo input arguments: (random io.Reader, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateKey(*random, bits)"}
;;   [^io/Reader random, ^Int bits])

JOKER FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo input arguments: (random io.Reader, nprimes int, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^go.std.io/Reader random, ^Int nprimes, ^Int bits]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__generateMultiPrimeKey(*random, nprimes, bits)"}
;;   [^io/Reader random, ^Int nprimes, ^Int bits])

JOKER FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPKCS1v15(*rand, priv, *hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hashed)))"}
;;   [^io/Reader rand, ^rsa/PrivateKey priv, ^crypto/Hash hash, ^Object hashed])

JOKER FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte, opts *PSSOptions)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.rsa/PrivateKey) priv, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__signPSS(*rand, priv, *hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hashed)), opts)"}
;;   [^io/Reader rand, ^rsa/PrivateKey priv, ^crypto/Hash hash, ^Object hashed, ^rsa/PSSOptions opts])

JOKER FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
;; (defn ^"Error" VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(vector-of Int) sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(pub, *hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sig)))"}
;;   [^rsa/PublicKey pub, ^crypto/Hash hash, ^Object hashed, ^Object sig])

JOKER FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
;; (defn ^"Error" VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *PSSOptions)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) pub, ^go.std.crypto/Hash hash, ^(vector-of Int) hashed, ^(vector-of Int) sig, ^(atom-of go.std.crypto.rsa/PSSOptions) opts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(pub, *hash, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(hashed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(sig)), opts)"}
;;   [^rsa/PublicKey pub, ^crypto/Hash hash, ^Object hashed, ^Object sig, ^rsa/PSSOptions opts])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/rsa package."
    :empty false}
  go.std.crypto.rsa)
JOKER FUNC crypto/sha1.New from crypto/sha1/sha1.go:
(defn New
  "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
;; (defn Sum
;;   "Sum returns the SHA-1 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha1 package."
    :empty false}
  go.std.crypto.sha1)
JOKER FUNC crypto/sha256.New from crypto/sha256/sha256.go:
(defn New
  "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
(defn New224
  "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new224()"}
  [])

JOKER FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
;; (defn Sum224
;;   "Sum224 returns the SHA224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
;; (defn Sum256
;;   "Sum256 returns the SHA256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha256 package."
    :empty false}
  go.std.crypto.sha256)
JOKER FUNC crypto/sha512.New from crypto/sha512/sha512.go:
(defn New
  "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new()"}
  [])

JOKER FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
(defn New384
  "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new384()"}
  [])

JOKER FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
(defn New512_224
  "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_224()"}
  [])

JOKER FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
(defn New512_256
  "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new512_256()"}
  [])

JOKER FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
;; (defn Sum384
;;   "Sum384 returns the SHA384 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum384(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
;; (defn Sum512
;;   "Sum512 returns the SHA512 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
;; (defn Sum512_224
;;   "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_224(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
;; (defn Sum512_256
;;   "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__sum512_256(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/sha512 package."
    :empty false}
  go.std.crypto.sha512)
JOKER FUNC crypto/subtle.ConstantTimeByteEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeByteEq
  "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x uint8, y uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeByteEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
;; (defn ^"Int" ConstantTimeCompare
;;   "ConstantTimeCompare returns 1 if the two slices, x and y, have equal contents\nand 0 otherwise. The time taken is a function of the length of the slices and\nis independent of the contents.\n\nGo input arguments: (x []byte, y []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) x, ^(vector-of Int) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeCompare(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(y)))"}
;;   [^Object x, ^Object y])

JOKER FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n\nGo input arguments: (v int, x []byte, y []byte)\n\nJoker input arguments: [^Int v, ^(vector-of Int) x, ^(vector-of Int) y]"
;;   {:added "1.0"
;;    :go "__constantTimeCopy(v, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(x)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(y)))"}
;;   [^Int v, ^Object x, ^Object y])

JOKER FUNC crypto/subtle.ConstantTimeEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x int32, y int32)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC crypto/subtle.ConstantTimeLessOrEq from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo input arguments: (x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(x, y)"}
  [^Int x, ^Int y])

JOKER FUNC crypto/subtle.ConstantTimeSelect from crypto/subtle/constant_time.go:
(defn ^"Int" ConstantTimeSelect
  "ConstantTimeSelect returns x if v == 1 and y if v == 0.\nIts behavior is undefined if v takes any other value.\n\nGo input arguments: (v int, x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int v, ^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(v, x, y)"}
  [^Int v, ^Int x, ^Int y])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["crypto/subtle"]
    :doc "Provides a low-level interface to the crypto/subtle package."
    :empty false}
  go.std.crypto.subtle)
JOKER TYPE crypto/tls.Certificate from crypto/tls/common.go:
;; (defn ^"GoObject" Certificate.
;;   "Constructor for tls.Certificate"
;;   {:added "1.0"
;;    :go "_ConstructCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.CertificateRequestInfo from crypto/tls/common.go:
;; (defn ^"GoObject" CertificateRequestInfo.
;;   "Constructor for tls.CertificateRequestInfo"
;;   {:added "1.0"
;;    :go "_ConstructCertificateRequestInfo(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientAuthType from crypto/tls/common.go:
(defn ^"GoObject" ClientAuthType.
  "Constructor for tls.ClientAuthType"
  {:added "1.0"
   :go "_ConstructClientAuthType(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ClientHelloInfo from crypto/tls/common.go:
;; (defn ^"GoObject" ClientHelloInfo.
;;   "Constructor for tls.ClientHelloInfo"
;;   {:added "1.0"
;;    :go "_ConstructClientHelloInfo(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientSessionCache from crypto/tls/common.go:
;; (defn ^"GoObject" ClientSessionCache.
;;   "Constructor for tls.ClientSessionCache"
;;   {:added "1.0"
;;    :go "_ConstructClientSessionCache(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.ClientSessionState from crypto/tls/common.go:
(defn ^"GoObject" ClientSessionState.
  "Constructor for tls.ClientSessionState"
  {:added "1.0"
   :go "_ConstructClientSessionState(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.Config from crypto/tls/common.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for tls.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.Conn from crypto/tls/conn.go:
(defn ^"GoObject" Conn.
  "Constructor for tls.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.ConnectionState from crypto/tls/common.go:
;; (defn ^"GoObject" ConnectionState.
;;   "Constructor for tls.ConnectionState"
;;   {:added "1.0"
;;    :go "_ConstructConnectionState(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.CurveID from crypto/tls/common.go:
(defn ^"GoObject" CurveID.
  "Constructor for tls.CurveID"
  {:added "1.0"
   :go "_ConstructCurveID(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.RecordHeaderError from crypto/tls/conn.go:
;; (defn ^"GoObject" RecordHeaderError.
;;   "Constructor for tls.RecordHeaderError"
;;   {:added "1.0"
;;    :go "_ConstructRecordHeaderError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/tls.RenegotiationSupport from crypto/tls/common.go:
(defn ^"GoObject" RenegotiationSupport.
  "Constructor for tls.RenegotiationSupport"
  {:added "1.0"
   :go "_ConstructRenegotiationSupport(_v)"}
  [^Object _v])

JOKER TYPE crypto/tls.SignatureScheme from crypto/tls/common.go:
(defn ^"GoObject" SignatureScheme.
  "Constructor for tls.SignatureScheme"
  {:added "1.0"
   :go "_ConstructSignatureScheme(_v)"}
  [^Object _v])

JOKER FUNC crypto/tls.Client from crypto/tls/tls.go:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__client(*conn, config)"}
;;   [^net/Conn conn, ^tls/Config config])

JOKER FUNC crypto/tls.Dial from crypto/tls/tls.go:
(defn Dial
  "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo input arguments: (network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
  {:added "1.0"
   :go "__dial(network, addr, config)"}
  [^String network, ^String addr, ^tls/Config config])

JOKER FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo input arguments: (dialer *net.Dialer, network string, addr string, config *Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^(atom-of go.std.net/Dialer) dialer, ^String network, ^String addr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [(atom-of go.std.crypto.tls/Conn) Error]"
;;   {:added "1.0"
;;    :go "__dialWithDialer(dialer, network, addr, config)"}
;;   [^net/Dialer dialer, ^String network, ^String addr, ^tls/Config config])

JOKER FUNC crypto/tls.Listen from crypto/tls/tls.go:
(defn Listen
  "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (network string, laddr string, config *Config)\n\nGo return type: (net.Listener, error)\n\nJoker input arguments: [^String network, ^String laddr, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(network, laddr, config)"}
  [^String network, ^String laddr, ^tls/Config config])

JOKER FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
(defn LoadX509KeyPair
  "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo input arguments: (certFile string, keyFile string)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^String certFile, ^String keyFile]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
  {:added "1.0"
   :go "__loadX509KeyPair(certFile, keyFile)"}
  [^String certFile, ^String keyFile])

JOKER FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
(defn NewLRUClientSessionCache
  "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo input arguments: (capacity int)\n\nGo return type: ClientSessionCache\n\nJoker input arguments: [^Int capacity]\n\nJoker return type: go.std.crypto.tls/ClientSessionCache"
  {:added "1.0"
   :go "__newLRUClientSessionCache(capacity)"}
  [^Int capacity])

JOKER FUNC crypto/tls.NewListener from crypto/tls/tls.go:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (inner net.Listener, config *Config)\n\nGo return type: net.Listener\n\nJoker input arguments: [^go.std.net/Listener inner, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: go.std.net/Listener"
;;   {:added "1.0"
;;    :go "__newListener(*inner, config)"}
;;   [^net/Listener inner, ^tls/Config config])

JOKER FUNC crypto/tls.Server from crypto/tls/tls.go:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (conn net.Conn, config *Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.net/Conn conn, ^(atom-of go.std.crypto.tls/Config) config]\n\nJoker return type: (atom-of go.std.crypto.tls/Conn)"
;;   {:added "1.0"
;;    :go "__server(*conn, config)"}
;;   [^net/Conn conn, ^tls/Config config])

JOKER FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo input arguments: (certPEMBlock []byte, keyPEMBlock []byte)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^(vector-of Int) certPEMBlock, ^(vector-of Int) keyPEMBlock]\n\nJoker return type: [go.std.crypto.tls/Certificate Error]"
;;   {:added "1.0"
;;    :go "__x509KeyPair(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(certPEMBlock)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(keyPEMBlock)))"}
;;   [^Object certPEMBlock, ^Object keyPEMBlock])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/tls package."
    :empty false}
  go.std.crypto.tls)
JOKER TYPE crypto/x509.CertPool from crypto/x509/cert_pool.go:
(defn ^"GoObject" CertPool.
  "Constructor for x509.CertPool"
  {:added "1.0"
   :go "_ConstructCertPool(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.Certificate from crypto/x509/x509.go:
;; (defn ^"GoObject" Certificate.
;;   "Constructor for x509.Certificate"
;;   {:added "1.0"
;;    :go "_ConstructCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.CertificateInvalidError from crypto/x509/verify.go:
;; (defn ^"GoObject" CertificateInvalidError.
;;   "Constructor for x509.CertificateInvalidError"
;;   {:added "1.0"
;;    :go "_ConstructCertificateInvalidError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.CertificateRequest from crypto/x509/x509.go:
;; (defn ^"GoObject" CertificateRequest.
;;   "Constructor for x509.CertificateRequest"
;;   {:added "1.0"
;;    :go "_ConstructCertificateRequest(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.ConstraintViolationError from crypto/x509/x509.go:
(defn ^"GoObject" ConstraintViolationError.
  "Constructor for x509.ConstraintViolationError"
  {:added "1.0"
   :go "_ConstructConstraintViolationError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.ExtKeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" ExtKeyUsage.
  "Constructor for x509.ExtKeyUsage"
  {:added "1.0"
   :go "_ConstructExtKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.HostnameError from crypto/x509/verify.go:
;; (defn ^"GoObject" HostnameError.
;;   "Constructor for x509.HostnameError"
;;   {:added "1.0"
;;    :go "_ConstructHostnameError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.InsecureAlgorithmError from crypto/x509/x509.go:
;; (defn ^"GoObject" InsecureAlgorithmError.
;;   "Constructor for x509.InsecureAlgorithmError"
;;   {:added "1.0"
;;    :go "_ConstructInsecureAlgorithmError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.InvalidReason from crypto/x509/verify.go:
(defn ^"GoObject" InvalidReason.
  "Constructor for x509.InvalidReason"
  {:added "1.0"
   :go "_ConstructInvalidReason(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.KeyUsage from crypto/x509/x509.go:
(defn ^"GoObject" KeyUsage.
  "Constructor for x509.KeyUsage"
  {:added "1.0"
   :go "_ConstructKeyUsage(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PEMCipher from crypto/x509/pem_decrypt.go:
(defn ^"GoObject" PEMCipher.
  "Constructor for x509.PEMCipher"
  {:added "1.0"
   :go "_ConstructPEMCipher(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.PublicKeyAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" PublicKeyAlgorithm.
  "Constructor for x509.PublicKeyAlgorithm"
  {:added "1.0"
   :go "_ConstructPublicKeyAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SignatureAlgorithm from crypto/x509/x509.go:
(defn ^"GoObject" SignatureAlgorithm.
  "Constructor for x509.SignatureAlgorithm"
  {:added "1.0"
   :go "_ConstructSignatureAlgorithm(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.SystemRootsError from crypto/x509/verify.go:
(defn ^"GoObject" SystemRootsError.
  "Constructor for x509.SystemRootsError"
  {:added "1.0"
   :go "_ConstructSystemRootsError(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnhandledCriticalExtension from crypto/x509/x509.go:
(defn ^"GoObject" UnhandledCriticalExtension.
  "Constructor for x509.UnhandledCriticalExtension"
  {:added "1.0"
   :go "_ConstructUnhandledCriticalExtension(_v)"}
  [^Object _v])

JOKER TYPE crypto/x509.UnknownAuthorityError from crypto/x509/verify.go:
;; (defn ^"GoObject" UnknownAuthorityError.
;;   "Constructor for x509.UnknownAuthorityError"
;;   {:added "1.0"
;;    :go "_ConstructUnknownAuthorityError(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509.VerifyOptions from crypto/x509/verify.go:
;; (defn ^"GoObject" VerifyOptions.
;;   "Constructor for x509.VerifyOptions"
;;   {:added "1.0"
;;    :go "_ConstructVerifyOptions(_v)"}
;;   [^Object _v])

JOKER FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo input arguments: (rand io.Reader, template *Certificate, parent *Certificate, pub interface {}, priv interface {})\n\nGo return type: (cert []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/Certificate) template, ^(atom-of go.std.crypto.x509/Certificate) parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificate(*rand, template, parent, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader rand, ^x509/Certificate template, ^x509/Certificate parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv])

JOKER FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - SignatureAlgorithm\n - Subject\n - DNSNames\n - EmailAddresses\n - IPAddresses\n - URIs\n - ExtraExtensions\n - Attributes (deprecated)\n\npriv is the private key to sign the CSR with, and the corresponding public\nkey will be included in the CSR. It must implement crypto.Signer and its\nPublic() method must return a *rsa.PublicKey or a *ecdsa.PublicKey. (A\n*rsa.PrivateKey or *ecdsa.PrivateKey satisfies this.)\n\nThe returned slice is the certificate request in DER encoding.\n\nGo input arguments: (rand io.Reader, template *CertificateRequest, priv interface {})\n\nGo return type: (csr []byte, err error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^(atom-of go.std.crypto.x509/CertificateRequest) template, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__createCertificateRequest(*rand, template, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader rand, ^x509/CertificateRequest template, ^<protocol-or-something> priv])

JOKER FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo input arguments: (b *pem.Block, password []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b, ^(vector-of Int) password]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__decryptPEMBlock(b, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(password)))"}
;;   [^pem/Block b, ^Object password])

JOKER FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo input arguments: (rand io.Reader, blockType string, data []byte, password []byte, alg PEMCipher)\n\nGo return type: (*encoding/pem.Block, error)\n\nJoker input arguments: [^go.std.io/Reader rand, ^String blockType, ^(vector-of Int) data, ^(vector-of Int) password, ^go.std.crypto.x509/PEMCipher alg]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) Error]"
;;   {:added "1.0"
;;    :go "__encryptPEMBlock(*rand, blockType, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(password)), *alg)"}
;;   [^io/Reader rand, ^String blockType, ^Object data, ^Object password, ^x509/PEMCipher alg])

JOKER FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
;; (defn ^"Boolean" IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo input arguments: (b *pem.Block)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(b)"}
;;   [^pem/Block b])

JOKER FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo input arguments: (key *ecdsa.PrivateKey)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.crypto.ecdsa/PrivateKey) key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalECPrivateKey(key)"}
;;   [^ecdsa/PrivateKey key])

JOKER FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo input arguments: (key *rsa.PrivateKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PrivateKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PrivateKey(key)"}
;;   [^rsa/PrivateKey key])

JOKER FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo input arguments: (key *rsa.PublicKey)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.crypto.rsa/PublicKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__marshalPKCS1PublicKey(key)"}
;;   [^rsa/PublicKey key])

JOKER FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo input arguments: (key interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKCS8PrivateKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> key])

JOKER FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo input arguments: (pub interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> pub]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalPKIXPublicKey(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> pub])

JOKER FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
(defn NewCertPool
  "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.crypto.x509/CertPool)"
  {:added "1.0"
   :go "__newCertPool()"}
  [])

JOKER FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo input arguments: (crlBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Int) crlBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(crlBytes)))"}
;;   [^Object crlBytes])

JOKER FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*Certificate, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/Certificate) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificate(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(asn1Data)))"}
;;   [^Object asn1Data])

JOKER FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*CertificateRequest, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(atom-of go.std.crypto.x509/CertificateRequest) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificateRequest(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(asn1Data)))"}
;;   [^Object asn1Data])

JOKER FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: ([]*Certificate, error)\n\nJoker input arguments: [^(vector-of Int) asn1Data]\n\nJoker return type: [(vector-of (atom-of go.std.crypto.x509/Certificate)) Error]"
;;   {:added "1.0"
;;    :go "__parseCertificates(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(asn1Data)))"}
;;   [^Object asn1Data])

JOKER FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (*crypto/x509/pkix.CertificateList, error)\n\nJoker input arguments: [^(vector-of Int) derBytes]\n\nJoker return type: [(atom-of go.std.crypto.x509.pkix/CertificateList) Error]"
;;   {:added "1.0"
;;    :go "__parseDERCRL(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(derBytes)))"}
;;   [^Object derBytes])

JOKER FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
;; (defn ParseECPrivateKey
;;   "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/ecdsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.ecdsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parseECPrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(der)))"}
;;   [^Object der])

JOKER FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PrivateKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PrivateKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(der)))"}
;;   [^Object der])

JOKER FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
;; (defn ParsePKCS1PublicKey
;;   "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*crypto/rsa.PublicKey, error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [(atom-of go.std.crypto.rsa/PublicKey) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS1PublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(der)))"}
;;   [^Object der])

JOKER FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo input arguments: (der []byte)\n\nGo return type: (key ..., err error)\n\nJoker input arguments: [^(vector-of Int) der]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "__parsePKCS8PrivateKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(der)))"}
;;   [^Object der])

JOKER FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (pub ..., err error)\n\nJoker input arguments: [^(vector-of Int) derBytes]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/crypto/x509/x509.go:54:47) Error]"
;;   {:added "1.0"
;;    :go "__parsePKIXPublicKey(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(derBytes)))"}
;;   [^Object derBytes])

JOKER FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool returned by SystemCertPool.\n\nNew changes in the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.crypto.x509/CertPool) Error]"
  {:added "1.0"
   :go "__systemCertPool()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/x509 package."
    :empty false}
  go.std.crypto.x509)
JOKER TYPE crypto/x509/pkix.AlgorithmIdentifier from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AlgorithmIdentifier.
;;   "Constructor for pkix.AlgorithmIdentifier"
;;   {:added "1.0"
;;    :go "_ConstructAlgorithmIdentifier(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.AttributeTypeAndValue from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AttributeTypeAndValue.
;;   "Constructor for pkix.AttributeTypeAndValue"
;;   {:added "1.0"
;;    :go "_ConstructAttributeTypeAndValue(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.AttributeTypeAndValueSET from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" AttributeTypeAndValueSET.
;;   "Constructor for pkix.AttributeTypeAndValueSET"
;;   {:added "1.0"
;;    :go "_ConstructAttributeTypeAndValueSET(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.CertificateList from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" CertificateList.
;;   "Constructor for pkix.CertificateList"
;;   {:added "1.0"
;;    :go "_ConstructCertificateList(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.Extension from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" Extension.
;;   "Constructor for pkix.Extension"
;;   {:added "1.0"
;;    :go "_ConstructExtension(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.Name from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" Name.
;;   "Constructor for pkix.Name"
;;   {:added "1.0"
;;    :go "_ConstructName(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RDNSequence from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RDNSequence.
;;   "Constructor for pkix.RDNSequence"
;;   {:added "1.0"
;;    :go "_ConstructRDNSequence(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RelativeDistinguishedNameSET from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RelativeDistinguishedNameSET.
;;   "Constructor for pkix.RelativeDistinguishedNameSET"
;;   {:added "1.0"
;;    :go "_ConstructRelativeDistinguishedNameSET(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.RevokedCertificate from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" RevokedCertificate.
;;   "Constructor for pkix.RevokedCertificate"
;;   {:added "1.0"
;;    :go "_ConstructRevokedCertificate(_v)"}
;;   [^Object _v])

JOKER TYPE crypto/x509/pkix.TBSCertificateList from crypto/x509/pkix/pkix.go:
;; (defn ^"GoObject" TBSCertificateList.
;;   "Constructor for pkix.TBSCertificateList"
;;   {:added "1.0"
;;    :go "_ConstructTBSCertificateList(_v)"}
;;   [^Object _v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the crypto/x509/pkix package."
    :empty false}
  go.std.crypto.x509.pkix)
JOKER TYPE database/sql.ColumnType from database/sql/sql.go:
(defn ^"GoObject" ColumnType.
  "Constructor for sql.ColumnType"
  {:added "1.0"
   :go "_ConstructColumnType(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Conn from database/sql/sql.go:
(defn ^"GoObject" Conn.
  "Constructor for sql.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DB from database/sql/sql.go:
(defn ^"GoObject" DB.
  "Constructor for sql.DB"
  {:added "1.0"
   :go "_ConstructDB(_v)"}
  [^Object _v])

JOKER TYPE database/sql.DBStats from database/sql/sql.go:
;; (defn ^"GoObject" DBStats.
;;   "Constructor for sql.DBStats"
;;   {:added "1.0"
;;    :go "_ConstructDBStats(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.IsolationLevel from database/sql/sql.go:
(defn ^"GoObject" IsolationLevel.
  "Constructor for sql.IsolationLevel"
  {:added "1.0"
   :go "_ConstructIsolationLevel(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NamedArg from database/sql/sql.go:
;; (defn ^"GoObject" NamedArg.
;;   "Constructor for sql.NamedArg"
;;   {:added "1.0"
;;    :go "_ConstructNamedArg(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.NullBool from database/sql/sql.go:
(defn ^"GoObject" NullBool.
  "Constructor for sql.NullBool"
  {:added "1.0"
   :go "_ConstructNullBool(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullFloat64 from database/sql/sql.go:
(defn ^"GoObject" NullFloat64.
  "Constructor for sql.NullFloat64"
  {:added "1.0"
   :go "_ConstructNullFloat64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullInt64 from database/sql/sql.go:
(defn ^"GoObject" NullInt64.
  "Constructor for sql.NullInt64"
  {:added "1.0"
   :go "_ConstructNullInt64(_v)"}
  [^Object _v])

JOKER TYPE database/sql.NullString from database/sql/sql.go:
(defn ^"GoObject" NullString.
  "Constructor for sql.NullString"
  {:added "1.0"
   :go "_ConstructNullString(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Out from database/sql/sql.go:
;; (defn ^"GoObject" Out.
;;   "Constructor for sql.Out"
;;   {:added "1.0"
;;    :go "_ConstructOut(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.RawBytes from database/sql/sql.go:
;; (defn ^"GoObject" RawBytes.
;;   "Constructor for sql.RawBytes"
;;   {:added "1.0"
;;    :go "_ConstructRawBytes(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Result from database/sql/sql.go:
;; (defn ^"GoObject" Result.
;;   "Constructor for sql.Result"
;;   {:added "1.0"
;;    :go "_ConstructResult(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Row from database/sql/sql.go:
(defn ^"GoObject" Row.
  "Constructor for sql.Row"
  {:added "1.0"
   :go "_ConstructRow(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Rows from database/sql/sql.go:
(defn ^"GoObject" Rows.
  "Constructor for sql.Rows"
  {:added "1.0"
   :go "_ConstructRows(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Scanner from database/sql/sql.go:
;; (defn ^"GoObject" Scanner.
;;   "Constructor for sql.Scanner"
;;   {:added "1.0"
;;    :go "_ConstructScanner(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql.Stmt from database/sql/sql.go:
(defn ^"GoObject" Stmt.
  "Constructor for sql.Stmt"
  {:added "1.0"
   :go "_ConstructStmt(_v)"}
  [^Object _v])

JOKER TYPE database/sql.Tx from database/sql/sql.go:
(defn ^"GoObject" Tx.
  "Constructor for sql.Tx"
  {:added "1.0"
   :go "_ConstructTx(_v)"}
  [^Object _v])

JOKER TYPE database/sql.TxOptions from database/sql/sql.go:
(defn ^"GoObject" TxOptions.
  "Constructor for sql.TxOptions"
  {:added "1.0"
   :go "_ConstructTxOptions(_v)"}
  [^Object _v])

JOKER FUNC database/sql.Drivers from database/sql/sql.go:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__drivers()"}
  [])

JOKER FUNC database/sql.Named from database/sql/sql.go:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo input arguments: (name string, value interface {})\n\nGo return type: NamedArg\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]\n\nJoker return type: go.std.database.sql/NamedArg"
;;   {:added "1.0"
;;    :go "__named(name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String name, ^<protocol-or-something> value])

JOKER FUNC database/sql.Open from database/sql/sql.go:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (driverName string, dataSourceName string)\n\nGo return type: (*DB, error)\n\nJoker input arguments: [^String driverName, ^String dataSourceName]\n\nJoker return type: [(atom-of go.std.database.sql/DB) Error]"
  {:added "1.0"
   :go "__open(driverName, dataSourceName)"}
  [^String driverName, ^String dataSourceName])

JOKER FUNC database/sql.OpenDB from database/sql/sql.go:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (c driver.Connector)\n\nGo return type: *DB\n\nJoker input arguments: [^go.std.database.sql.driver/Connector c]\n\nJoker return type: (atom-of go.std.database.sql/DB)"
;;   {:added "1.0"
;;    :go "__openDB(*c)"}
;;   [^driver/Connector c])

JOKER FUNC database/sql.Register from database/sql/sql.go:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n\nGo input arguments: (name string, driver driver.Driver)\n\nJoker input arguments: [^String name, ^go.std.database.sql.driver/Driver driver]"
;;   {:added "1.0"
;;    :go "__register(name, *driver)"}
;;   [^String name, ^driver/Driver driver])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the database/sql package."
    :empty false}
  go.std.database.sql)
JOKER TYPE database/sql/driver.ColumnConverter from database/sql/driver/driver.go:
;; (defn ^"GoObject" ColumnConverter.
;;   "Constructor for driver.ColumnConverter"
;;   {:added "1.0"
;;    :go "_ConstructColumnConverter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Conn from database/sql/driver/driver.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for driver.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ConnBeginTx from database/sql/driver/driver.go:
;; (defn ^"GoObject" ConnBeginTx.
;;   "Constructor for driver.ConnBeginTx"
;;   {:added "1.0"
;;    :go "_ConstructConnBeginTx(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ConnPrepareContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" ConnPrepareContext.
;;   "Constructor for driver.ConnPrepareContext"
;;   {:added "1.0"
;;    :go "_ConstructConnPrepareContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Connector from database/sql/driver/driver.go:
;; (defn ^"GoObject" Connector.
;;   "Constructor for driver.Connector"
;;   {:added "1.0"
;;    :go "_ConstructConnector(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Driver from database/sql/driver/driver.go:
;; (defn ^"GoObject" Driver.
;;   "Constructor for driver.Driver"
;;   {:added "1.0"
;;    :go "_ConstructDriver(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.DriverContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" DriverContext.
;;   "Constructor for driver.DriverContext"
;;   {:added "1.0"
;;    :go "_ConstructDriverContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Execer from database/sql/driver/driver.go:
;; (defn ^"GoObject" Execer.
;;   "Constructor for driver.Execer"
;;   {:added "1.0"
;;    :go "_ConstructExecer(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ExecerContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" ExecerContext.
;;   "Constructor for driver.ExecerContext"
;;   {:added "1.0"
;;    :go "_ConstructExecerContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.IsolationLevel from database/sql/driver/driver.go:
(defn ^"GoObject" IsolationLevel.
  "Constructor for driver.IsolationLevel"
  {:added "1.0"
   :go "_ConstructIsolationLevel(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.NamedValue from database/sql/driver/driver.go:
;; (defn ^"GoObject" NamedValue.
;;   "Constructor for driver.NamedValue"
;;   {:added "1.0"
;;    :go "_ConstructNamedValue(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.NamedValueChecker from database/sql/driver/driver.go:
;; (defn ^"GoObject" NamedValueChecker.
;;   "Constructor for driver.NamedValueChecker"
;;   {:added "1.0"
;;    :go "_ConstructNamedValueChecker(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.NotNull from database/sql/driver/types.go:
;; (defn ^"GoObject" NotNull.
;;   "Constructor for driver.NotNull"
;;   {:added "1.0"
;;    :go "_ConstructNotNull(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Null from database/sql/driver/types.go:
;; (defn ^"GoObject" Null.
;;   "Constructor for driver.Null"
;;   {:added "1.0"
;;    :go "_ConstructNull(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Pinger from database/sql/driver/driver.go:
;; (defn ^"GoObject" Pinger.
;;   "Constructor for driver.Pinger"
;;   {:added "1.0"
;;    :go "_ConstructPinger(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Queryer from database/sql/driver/driver.go:
;; (defn ^"GoObject" Queryer.
;;   "Constructor for driver.Queryer"
;;   {:added "1.0"
;;    :go "_ConstructQueryer(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.QueryerContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" QueryerContext.
;;   "Constructor for driver.QueryerContext"
;;   {:added "1.0"
;;    :go "_ConstructQueryerContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Result from database/sql/driver/driver.go:
;; (defn ^"GoObject" Result.
;;   "Constructor for driver.Result"
;;   {:added "1.0"
;;    :go "_ConstructResult(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Rows from database/sql/driver/driver.go:
;; (defn ^"GoObject" Rows.
;;   "Constructor for driver.Rows"
;;   {:added "1.0"
;;    :go "_ConstructRows(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsAffected from database/sql/driver/driver.go:
(defn ^"GoObject" RowsAffected.
  "Constructor for driver.RowsAffected"
  {:added "1.0"
   :go "_ConstructRowsAffected(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeDatabaseTypeName from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeDatabaseTypeName.
;;   "Constructor for driver.RowsColumnTypeDatabaseTypeName"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeDatabaseTypeName(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeLength from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeLength.
;;   "Constructor for driver.RowsColumnTypeLength"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeLength(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeNullable from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeNullable.
;;   "Constructor for driver.RowsColumnTypeNullable"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeNullable(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypePrecisionScale from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypePrecisionScale.
;;   "Constructor for driver.RowsColumnTypePrecisionScale"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypePrecisionScale(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsColumnTypeScanType from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsColumnTypeScanType.
;;   "Constructor for driver.RowsColumnTypeScanType"
;;   {:added "1.0"
;;    :go "_ConstructRowsColumnTypeScanType(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.RowsNextResultSet from database/sql/driver/driver.go:
;; (defn ^"GoObject" RowsNextResultSet.
;;   "Constructor for driver.RowsNextResultSet"
;;   {:added "1.0"
;;    :go "_ConstructRowsNextResultSet(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.SessionResetter from database/sql/driver/driver.go:
;; (defn ^"GoObject" SessionResetter.
;;   "Constructor for driver.SessionResetter"
;;   {:added "1.0"
;;    :go "_ConstructSessionResetter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Stmt from database/sql/driver/driver.go:
;; (defn ^"GoObject" Stmt.
;;   "Constructor for driver.Stmt"
;;   {:added "1.0"
;;    :go "_ConstructStmt(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.StmtExecContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" StmtExecContext.
;;   "Constructor for driver.StmtExecContext"
;;   {:added "1.0"
;;    :go "_ConstructStmtExecContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.StmtQueryContext from database/sql/driver/driver.go:
;; (defn ^"GoObject" StmtQueryContext.
;;   "Constructor for driver.StmtQueryContext"
;;   {:added "1.0"
;;    :go "_ConstructStmtQueryContext(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Tx from database/sql/driver/driver.go:
;; (defn ^"GoObject" Tx.
;;   "Constructor for driver.Tx"
;;   {:added "1.0"
;;    :go "_ConstructTx(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.TxOptions from database/sql/driver/driver.go:
(defn ^"GoObject" TxOptions.
  "Constructor for driver.TxOptions"
  {:added "1.0"
   :go "_ConstructTxOptions(_v)"}
  [^Object _v])

JOKER TYPE database/sql/driver.Value from database/sql/driver/driver.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for driver.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.ValueConverter from database/sql/driver/types.go:
;; (defn ^"GoObject" ValueConverter.
;;   "Constructor for driver.ValueConverter"
;;   {:added "1.0"
;;    :go "_ConstructValueConverter(_v)"}
;;   [^Object _v])

JOKER TYPE database/sql/driver.Valuer from database/sql/driver/types.go:
;; (defn ^"GoObject" Valuer.
;;   "Constructor for driver.Valuer"
;;   {:added "1.0"
;;    :go "_ConstructValuer(_v)"}
;;   [^Object _v])

JOKER FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> v])

JOKER FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
;; (defn ^"Boolean" IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "driver.IsValue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the database/sql/driver package."
    :empty false}
  go.std.database.sql.driver)
JOKER TYPE debug/dwarf.AddrType from debug/dwarf/type.go:
(defn ^"GoObject" AddrType.
  "Constructor for dwarf.AddrType"
  {:added "1.0"
   :go "_ConstructAddrType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.ArrayType from debug/dwarf/type.go:
;; (defn ^"GoObject" ArrayType.
;;   "Constructor for dwarf.ArrayType"
;;   {:added "1.0"
;;    :go "_ConstructArrayType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Attr from debug/dwarf/const.go:
(defn ^"GoObject" Attr.
  "Constructor for dwarf.Attr"
  {:added "1.0"
   :go "_ConstructAttr(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.BasicType from debug/dwarf/type.go:
(defn ^"GoObject" BasicType.
  "Constructor for dwarf.BasicType"
  {:added "1.0"
   :go "_ConstructBasicType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.BoolType from debug/dwarf/type.go:
(defn ^"GoObject" BoolType.
  "Constructor for dwarf.BoolType"
  {:added "1.0"
   :go "_ConstructBoolType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.CharType from debug/dwarf/type.go:
(defn ^"GoObject" CharType.
  "Constructor for dwarf.CharType"
  {:added "1.0"
   :go "_ConstructCharType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Class from debug/dwarf/entry.go:
(defn ^"GoObject" Class.
  "Constructor for dwarf.Class"
  {:added "1.0"
   :go "_ConstructClass(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.CommonType from debug/dwarf/type.go:
(defn ^"GoObject" CommonType.
  "Constructor for dwarf.CommonType"
  {:added "1.0"
   :go "_ConstructCommonType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.ComplexType from debug/dwarf/type.go:
(defn ^"GoObject" ComplexType.
  "Constructor for dwarf.ComplexType"
  {:added "1.0"
   :go "_ConstructComplexType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Data from debug/dwarf/open.go:
(defn ^"GoObject" Data.
  "Constructor for dwarf.Data"
  {:added "1.0"
   :go "_ConstructData(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.DecodeError from debug/dwarf/buf.go:
(defn ^"GoObject" DecodeError.
  "Constructor for dwarf.DecodeError"
  {:added "1.0"
   :go "_ConstructDecodeError(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.DotDotDotType from debug/dwarf/type.go:
(defn ^"GoObject" DotDotDotType.
  "Constructor for dwarf.DotDotDotType"
  {:added "1.0"
   :go "_ConstructDotDotDotType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Entry from debug/dwarf/entry.go:
;; (defn ^"GoObject" Entry.
;;   "Constructor for dwarf.Entry"
;;   {:added "1.0"
;;    :go "_ConstructEntry(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.EnumType from debug/dwarf/type.go:
;; (defn ^"GoObject" EnumType.
;;   "Constructor for dwarf.EnumType"
;;   {:added "1.0"
;;    :go "_ConstructEnumType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.EnumValue from debug/dwarf/type.go:
(defn ^"GoObject" EnumValue.
  "Constructor for dwarf.EnumValue"
  {:added "1.0"
   :go "_ConstructEnumValue(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Field from debug/dwarf/entry.go:
;; (defn ^"GoObject" Field.
;;   "Constructor for dwarf.Field"
;;   {:added "1.0"
;;    :go "_ConstructField(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.FloatType from debug/dwarf/type.go:
(defn ^"GoObject" FloatType.
  "Constructor for dwarf.FloatType"
  {:added "1.0"
   :go "_ConstructFloatType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.FuncType from debug/dwarf/type.go:
;; (defn ^"GoObject" FuncType.
;;   "Constructor for dwarf.FuncType"
;;   {:added "1.0"
;;    :go "_ConstructFuncType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.IntType from debug/dwarf/type.go:
(defn ^"GoObject" IntType.
  "Constructor for dwarf.IntType"
  {:added "1.0"
   :go "_ConstructIntType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineEntry from debug/dwarf/line.go:
;; (defn ^"GoObject" LineEntry.
;;   "Constructor for dwarf.LineEntry"
;;   {:added "1.0"
;;    :go "_ConstructLineEntry(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.LineFile from debug/dwarf/line.go:
(defn ^"GoObject" LineFile.
  "Constructor for dwarf.LineFile"
  {:added "1.0"
   :go "_ConstructLineFile(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineReader from debug/dwarf/line.go:
(defn ^"GoObject" LineReader.
  "Constructor for dwarf.LineReader"
  {:added "1.0"
   :go "_ConstructLineReader(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.LineReaderPos from debug/dwarf/line.go:
(defn ^"GoObject" LineReaderPos.
  "Constructor for dwarf.LineReaderPos"
  {:added "1.0"
   :go "_ConstructLineReaderPos(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Offset from debug/dwarf/entry.go:
(defn ^"GoObject" Offset.
  "Constructor for dwarf.Offset"
  {:added "1.0"
   :go "_ConstructOffset(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.PtrType from debug/dwarf/type.go:
;; (defn ^"GoObject" PtrType.
;;   "Constructor for dwarf.PtrType"
;;   {:added "1.0"
;;    :go "_ConstructPtrType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.QualType from debug/dwarf/type.go:
;; (defn ^"GoObject" QualType.
;;   "Constructor for dwarf.QualType"
;;   {:added "1.0"
;;    :go "_ConstructQualType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Reader from debug/dwarf/entry.go:
(defn ^"GoObject" Reader.
  "Constructor for dwarf.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.StructField from debug/dwarf/type.go:
;; (defn ^"GoObject" StructField.
;;   "Constructor for dwarf.StructField"
;;   {:added "1.0"
;;    :go "_ConstructStructField(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.StructType from debug/dwarf/type.go:
;; (defn ^"GoObject" StructType.
;;   "Constructor for dwarf.StructType"
;;   {:added "1.0"
;;    :go "_ConstructStructType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.Tag from debug/dwarf/const.go:
(defn ^"GoObject" Tag.
  "Constructor for dwarf.Tag"
  {:added "1.0"
   :go "_ConstructTag(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.Type from debug/dwarf/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for dwarf.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.TypedefType from debug/dwarf/type.go:
;; (defn ^"GoObject" TypedefType.
;;   "Constructor for dwarf.TypedefType"
;;   {:added "1.0"
;;    :go "_ConstructTypedefType(_v)"}
;;   [^Object _v])

JOKER TYPE debug/dwarf.UcharType from debug/dwarf/type.go:
(defn ^"GoObject" UcharType.
  "Constructor for dwarf.UcharType"
  {:added "1.0"
   :go "_ConstructUcharType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.UintType from debug/dwarf/type.go:
(defn ^"GoObject" UintType.
  "Constructor for dwarf.UintType"
  {:added "1.0"
   :go "_ConstructUintType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.UnspecifiedType from debug/dwarf/type.go:
(defn ^"GoObject" UnspecifiedType.
  "Constructor for dwarf.UnspecifiedType"
  {:added "1.0"
   :go "_ConstructUnspecifiedType(_v)"}
  [^Object _v])

JOKER TYPE debug/dwarf.VoidType from debug/dwarf/type.go:
(defn ^"GoObject" VoidType.
  "Constructor for dwarf.VoidType"
  {:added "1.0"
   :go "_ConstructVoidType(_v)"}
  [^Object _v])

JOKER FUNC debug/dwarf.New from debug/dwarf/open.go:
;; (defn New
;;   "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo input arguments: (abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte)\n\nGo return type: (*Data, error)\n\nJoker input arguments: [^(vector-of Int) abbrev, ^(vector-of Int) aranges, ^(vector-of Int) frame, ^(vector-of Int) info, ^(vector-of Int) line, ^(vector-of Int) pubnames, ^(vector-of Int) ranges, ^(vector-of Int) str]\n\nJoker return type: [(atom-of go.std.debug.dwarf/Data) Error]"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(abbrev)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(aranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(frame)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(info)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(line)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(pubnames)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(ranges)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(str)))"}
;;   [^Object abbrev, ^Object aranges, ^Object frame, ^Object info, ^Object line, ^Object pubnames, ^Object ranges, ^Object str])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/dwarf package."
    :empty false}
  go.std.debug.dwarf)
JOKER TYPE debug/elf.Chdr32 from debug/elf/elf.go:
(defn ^"GoObject" Chdr32.
  "Constructor for elf.Chdr32"
  {:added "1.0"
   :go "_ConstructChdr32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Chdr64 from debug/elf/elf.go:
(defn ^"GoObject" Chdr64.
  "Constructor for elf.Chdr64"
  {:added "1.0"
   :go "_ConstructChdr64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Class from debug/elf/elf.go:
(defn ^"GoObject" Class.
  "Constructor for elf.Class"
  {:added "1.0"
   :go "_ConstructClass(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.CompressionType from debug/elf/elf.go:
(defn ^"GoObject" CompressionType.
  "Constructor for elf.CompressionType"
  {:added "1.0"
   :go "_ConstructCompressionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Data from debug/elf/elf.go:
(defn ^"GoObject" Data.
  "Constructor for elf.Data"
  {:added "1.0"
   :go "_ConstructData(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn32 from debug/elf/elf.go:
(defn ^"GoObject" Dyn32.
  "Constructor for elf.Dyn32"
  {:added "1.0"
   :go "_ConstructDyn32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Dyn64 from debug/elf/elf.go:
(defn ^"GoObject" Dyn64.
  "Constructor for elf.Dyn64"
  {:added "1.0"
   :go "_ConstructDyn64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynFlag from debug/elf/elf.go:
(defn ^"GoObject" DynFlag.
  "Constructor for elf.DynFlag"
  {:added "1.0"
   :go "_ConstructDynFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.DynTag from debug/elf/elf.go:
(defn ^"GoObject" DynTag.
  "Constructor for elf.DynTag"
  {:added "1.0"
   :go "_ConstructDynTag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.File from debug/elf/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for elf.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.FileHeader from debug/elf/file.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for elf.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.FormatError from debug/elf/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for elf.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Header32 from debug/elf/elf.go:
;; (defn ^"GoObject" Header32.
;;   "Constructor for elf.Header32"
;;   {:added "1.0"
;;    :go "_ConstructHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.Header64 from debug/elf/elf.go:
;; (defn ^"GoObject" Header64.
;;   "Constructor for elf.Header64"
;;   {:added "1.0"
;;    :go "_ConstructHeader64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/elf.ImportedSymbol from debug/elf/file.go:
(defn ^"GoObject" ImportedSymbol.
  "Constructor for elf.ImportedSymbol"
  {:added "1.0"
   :go "_ConstructImportedSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Machine from debug/elf/elf.go:
(defn ^"GoObject" Machine.
  "Constructor for elf.Machine"
  {:added "1.0"
   :go "_ConstructMachine(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.NType from debug/elf/elf.go:
(defn ^"GoObject" NType.
  "Constructor for elf.NType"
  {:added "1.0"
   :go "_ConstructNType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.OSABI from debug/elf/elf.go:
(defn ^"GoObject" OSABI.
  "Constructor for elf.OSABI"
  {:added "1.0"
   :go "_ConstructOSABI(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog from debug/elf/file.go:
(defn ^"GoObject" Prog.
  "Constructor for elf.Prog"
  {:added "1.0"
   :go "_ConstructProg(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog32 from debug/elf/elf.go:
(defn ^"GoObject" Prog32.
  "Constructor for elf.Prog32"
  {:added "1.0"
   :go "_ConstructProg32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Prog64 from debug/elf/elf.go:
(defn ^"GoObject" Prog64.
  "Constructor for elf.Prog64"
  {:added "1.0"
   :go "_ConstructProg64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgFlag from debug/elf/elf.go:
(defn ^"GoObject" ProgFlag.
  "Constructor for elf.ProgFlag"
  {:added "1.0"
   :go "_ConstructProgFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgHeader from debug/elf/file.go:
(defn ^"GoObject" ProgHeader.
  "Constructor for elf.ProgHeader"
  {:added "1.0"
   :go "_ConstructProgHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.ProgType from debug/elf/elf.go:
(defn ^"GoObject" ProgType.
  "Constructor for elf.ProgType"
  {:added "1.0"
   :go "_ConstructProgType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_386 from debug/elf/elf.go:
(defn ^"GoObject" R_386.
  "Constructor for elf.R_386"
  {:added "1.0"
   :go "_ConstructR_386(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_390 from debug/elf/elf.go:
(defn ^"GoObject" R_390.
  "Constructor for elf.R_390"
  {:added "1.0"
   :go "_ConstructR_390(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_AARCH64 from debug/elf/elf.go:
(defn ^"GoObject" R_AARCH64.
  "Constructor for elf.R_AARCH64"
  {:added "1.0"
   :go "_ConstructR_AARCH64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ALPHA from debug/elf/elf.go:
(defn ^"GoObject" R_ALPHA.
  "Constructor for elf.R_ALPHA"
  {:added "1.0"
   :go "_ConstructR_ALPHA(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_ARM from debug/elf/elf.go:
(defn ^"GoObject" R_ARM.
  "Constructor for elf.R_ARM"
  {:added "1.0"
   :go "_ConstructR_ARM(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_MIPS from debug/elf/elf.go:
(defn ^"GoObject" R_MIPS.
  "Constructor for elf.R_MIPS"
  {:added "1.0"
   :go "_ConstructR_MIPS(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC from debug/elf/elf.go:
(defn ^"GoObject" R_PPC.
  "Constructor for elf.R_PPC"
  {:added "1.0"
   :go "_ConstructR_PPC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_PPC64 from debug/elf/elf.go:
(defn ^"GoObject" R_PPC64.
  "Constructor for elf.R_PPC64"
  {:added "1.0"
   :go "_ConstructR_PPC64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_RISCV from debug/elf/elf.go:
(defn ^"GoObject" R_RISCV.
  "Constructor for elf.R_RISCV"
  {:added "1.0"
   :go "_ConstructR_RISCV(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_SPARC from debug/elf/elf.go:
(defn ^"GoObject" R_SPARC.
  "Constructor for elf.R_SPARC"
  {:added "1.0"
   :go "_ConstructR_SPARC(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.R_X86_64 from debug/elf/elf.go:
(defn ^"GoObject" R_X86_64.
  "Constructor for elf.R_X86_64"
  {:added "1.0"
   :go "_ConstructR_X86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel32 from debug/elf/elf.go:
(defn ^"GoObject" Rel32.
  "Constructor for elf.Rel32"
  {:added "1.0"
   :go "_ConstructRel32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rel64 from debug/elf/elf.go:
(defn ^"GoObject" Rel64.
  "Constructor for elf.Rel64"
  {:added "1.0"
   :go "_ConstructRel64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela32 from debug/elf/elf.go:
(defn ^"GoObject" Rela32.
  "Constructor for elf.Rela32"
  {:added "1.0"
   :go "_ConstructRela32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Rela64 from debug/elf/elf.go:
(defn ^"GoObject" Rela64.
  "Constructor for elf.Rela64"
  {:added "1.0"
   :go "_ConstructRela64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section from debug/elf/file.go:
(defn ^"GoObject" Section.
  "Constructor for elf.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section32 from debug/elf/elf.go:
(defn ^"GoObject" Section32.
  "Constructor for elf.Section32"
  {:added "1.0"
   :go "_ConstructSection32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Section64 from debug/elf/elf.go:
(defn ^"GoObject" Section64.
  "Constructor for elf.Section64"
  {:added "1.0"
   :go "_ConstructSection64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionFlag from debug/elf/elf.go:
(defn ^"GoObject" SectionFlag.
  "Constructor for elf.SectionFlag"
  {:added "1.0"
   :go "_ConstructSectionFlag(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionHeader from debug/elf/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for elf.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionIndex from debug/elf/elf.go:
(defn ^"GoObject" SectionIndex.
  "Constructor for elf.SectionIndex"
  {:added "1.0"
   :go "_ConstructSectionIndex(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SectionType from debug/elf/elf.go:
(defn ^"GoObject" SectionType.
  "Constructor for elf.SectionType"
  {:added "1.0"
   :go "_ConstructSectionType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym32 from debug/elf/elf.go:
(defn ^"GoObject" Sym32.
  "Constructor for elf.Sym32"
  {:added "1.0"
   :go "_ConstructSym32(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Sym64 from debug/elf/elf.go:
(defn ^"GoObject" Sym64.
  "Constructor for elf.Sym64"
  {:added "1.0"
   :go "_ConstructSym64(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymBind from debug/elf/elf.go:
(defn ^"GoObject" SymBind.
  "Constructor for elf.SymBind"
  {:added "1.0"
   :go "_ConstructSymBind(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymType from debug/elf/elf.go:
(defn ^"GoObject" SymType.
  "Constructor for elf.SymType"
  {:added "1.0"
   :go "_ConstructSymType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.SymVis from debug/elf/elf.go:
(defn ^"GoObject" SymVis.
  "Constructor for elf.SymVis"
  {:added "1.0"
   :go "_ConstructSymVis(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Symbol from debug/elf/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for elf.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Type from debug/elf/elf.go:
(defn ^"GoObject" Type.
  "Constructor for elf.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER TYPE debug/elf.Version from debug/elf/elf.go:
(defn ^"GoObject" Version.
  "Constructor for elf.Version"
  {:added "1.0"
   :go "_ConstructVersion(_v)"}
  [^Object _v])

JOKER FUNC debug/elf.NewFile from debug/elf/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*r)"}
;;   [^io/ReaderAt r])

JOKER FUNC debug/elf.Open from debug/elf/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.elf/File) Error]"
  {:added "1.0"
   :go "__open(name)"}
  [^String name])

JOKER FUNC debug/elf.R_INFO from debug/elf/elf.go:
(defn R_INFO
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint64\n\nJoker input arguments: [^Number sym, ^Number typ]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_INFO(sym, typ)"}
  [^Number sym, ^Number typ])

JOKER FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
(defn R_INFO32
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number sym, ^Number typ]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_INFO32(sym, typ)"}
  [^Number sym, ^Number typ])

JOKER FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
(defn R_SYM32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_SYM32(info)"}
  [^Number info])

JOKER FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
(defn R_SYM64
  "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_SYM64(info)"}
  [^Number info])

JOKER FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
(defn R_TYPE32
  "Go input arguments: (info uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_TYPE32(info)"}
  [^Number info])

JOKER FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
(defn R_TYPE64
  "Go input arguments: (info uint64)\n\nGo return type: uint32\n\nJoker input arguments: [^Number info]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__r_TYPE64(info)"}
  [^Number info])

JOKER FUNC debug/elf.ST_BIND from debug/elf/elf.go:
(defn ST_BIND
  "Go input arguments: (info uint8)\n\nGo return type: SymBind\n\nJoker input arguments: [^Int info]\n\nJoker return type: go.std.debug.elf/SymBind"
  {:added "1.0"
   :go "__sT_BIND(info)"}
  [^Int info])

JOKER FUNC debug/elf.ST_INFO from debug/elf/elf.go:
(defn ST_INFO
  "Go input arguments: (bind SymBind, typ SymType)\n\nGo return type: uint8\n\nJoker input arguments: [^go.std.debug.elf/SymBind bind, ^go.std.debug.elf/SymType typ]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__sT_INFO(*bind, *typ)"}
  [^elf/SymBind bind, ^elf/SymType typ])

JOKER FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
(defn ST_TYPE
  "Go input arguments: (info uint8)\n\nGo return type: SymType\n\nJoker input arguments: [^Int info]\n\nJoker return type: go.std.debug.elf/SymType"
  {:added "1.0"
   :go "__sT_TYPE(info)"}
  [^Int info])

JOKER FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
(defn ST_VISIBILITY
  "Go input arguments: (other uint8)\n\nGo return type: SymVis\n\nJoker input arguments: [^Int other]\n\nJoker return type: go.std.debug.elf/SymVis"
  {:added "1.0"
   :go "__sT_VISIBILITY(other)"}
  [^Int other])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/elf package."
    :empty false}
  go.std.debug.elf)
JOKER TYPE debug/gosym.DecodingError from debug/gosym/symtab.go:
(defn ^"GoObject" DecodingError.
  "Constructor for gosym.DecodingError"
  {:added "1.0"
   :go "_ConstructDecodingError(_v)"}
  [^Object _v])

JOKER TYPE debug/gosym.Func from debug/gosym/symtab.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for gosym.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.LineTable from debug/gosym/pclntab.go:
;; (defn ^"GoObject" LineTable.
;;   "Constructor for gosym.LineTable"
;;   {:added "1.0"
;;    :go "_ConstructLineTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Obj from debug/gosym/symtab.go:
;; (defn ^"GoObject" Obj.
;;   "Constructor for gosym.Obj"
;;   {:added "1.0"
;;    :go "_ConstructObj(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Sym from debug/gosym/symtab.go:
;; (defn ^"GoObject" Sym.
;;   "Constructor for gosym.Sym"
;;   {:added "1.0"
;;    :go "_ConstructSym(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.Table from debug/gosym/symtab.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for gosym.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/gosym.UnknownFileError from debug/gosym/symtab.go:
(defn ^"GoObject" UnknownFileError.
  "Constructor for gosym.UnknownFileError"
  {:added "1.0"
   :go "_ConstructUnknownFileError(_v)"}
  [^Object _v])

JOKER TYPE debug/gosym.UnknownLineError from debug/gosym/symtab.go:
(defn ^"GoObject" UnknownLineError.
  "Constructor for gosym.UnknownLineError"
  {:added "1.0"
   :go "_ConstructUnknownLineError(_v)"}
  [^Object _v])

JOKER FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo input arguments: (data []byte, text uint64)\n\nGo return type: *LineTable\n\nJoker input arguments: [^(vector-of Int) data, ^Number text]\n\nJoker return type: (atom-of go.std.debug.gosym/LineTable)"
;;   {:added "1.0"
;;    :go "__newLineTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), text)"}
;;   [^Object data, ^Number text])

JOKER FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo input arguments: (symtab []byte, pcln *LineTable)\n\nGo return type: (*Table, error)\n\nJoker input arguments: [^(vector-of Int) symtab, ^(atom-of go.std.debug.gosym/LineTable) pcln]\n\nJoker return type: [(atom-of go.std.debug.gosym/Table) Error]"
;;   {:added "1.0"
;;    :go "__newTable(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(symtab)), pcln)"}
;;   [^Object symtab, ^gosym/LineTable pcln])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/gosym package."
    :empty false}
  go.std.debug.gosym)
JOKER TYPE debug/macho.Cpu from debug/macho/macho.go:
(defn ^"GoObject" Cpu.
  "Constructor for macho.Cpu"
  {:added "1.0"
   :go "_ConstructCpu(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dylib from debug/macho/file.go:
(defn ^"GoObject" Dylib.
  "Constructor for macho.Dylib"
  {:added "1.0"
   :go "_ConstructDylib(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.DylibCmd from debug/macho/macho.go:
(defn ^"GoObject" DylibCmd.
  "Constructor for macho.DylibCmd"
  {:added "1.0"
   :go "_ConstructDylibCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Dysymtab from debug/macho/file.go:
;; (defn ^"GoObject" Dysymtab.
;;   "Constructor for macho.Dysymtab"
;;   {:added "1.0"
;;    :go "_ConstructDysymtab(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.DysymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" DysymtabCmd.
  "Constructor for macho.DysymtabCmd"
  {:added "1.0"
   :go "_ConstructDysymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArch from debug/macho/fat.go:
(defn ^"GoObject" FatArch.
  "Constructor for macho.FatArch"
  {:added "1.0"
   :go "_ConstructFatArch(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatArchHeader from debug/macho/fat.go:
(defn ^"GoObject" FatArchHeader.
  "Constructor for macho.FatArchHeader"
  {:added "1.0"
   :go "_ConstructFatArchHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FatFile from debug/macho/fat.go:
;; (defn ^"GoObject" FatFile.
;;   "Constructor for macho.FatFile"
;;   {:added "1.0"
;;    :go "_ConstructFatFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.File from debug/macho/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for macho.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.FileHeader from debug/macho/macho.go:
(defn ^"GoObject" FileHeader.
  "Constructor for macho.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.FormatError from debug/macho/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for macho.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Load from debug/macho/file.go:
;; (defn ^"GoObject" Load.
;;   "Constructor for macho.Load"
;;   {:added "1.0"
;;    :go "_ConstructLoad(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadBytes from debug/macho/file.go:
;; (defn ^"GoObject" LoadBytes.
;;   "Constructor for macho.LoadBytes"
;;   {:added "1.0"
;;    :go "_ConstructLoadBytes(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.LoadCmd from debug/macho/macho.go:
(defn ^"GoObject" LoadCmd.
  "Constructor for macho.LoadCmd"
  {:added "1.0"
   :go "_ConstructLoadCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist32 from debug/macho/macho.go:
(defn ^"GoObject" Nlist32.
  "Constructor for macho.Nlist32"
  {:added "1.0"
   :go "_ConstructNlist32(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Nlist64 from debug/macho/macho.go:
(defn ^"GoObject" Nlist64.
  "Constructor for macho.Nlist64"
  {:added "1.0"
   :go "_ConstructNlist64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Regs386 from debug/macho/macho.go:
(defn ^"GoObject" Regs386.
  "Constructor for macho.Regs386"
  {:added "1.0"
   :go "_ConstructRegs386(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RegsAMD64 from debug/macho/macho.go:
(defn ^"GoObject" RegsAMD64.
  "Constructor for macho.RegsAMD64"
  {:added "1.0"
   :go "_ConstructRegsAMD64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Reloc from debug/macho/file.go:
(defn ^"GoObject" Reloc.
  "Constructor for macho.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM.
  "Constructor for macho.RelocTypeARM"
  {:added "1.0"
   :go "_ConstructRelocTypeARM(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeARM64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeARM64.
  "Constructor for macho.RelocTypeARM64"
  {:added "1.0"
   :go "_ConstructRelocTypeARM64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeGeneric from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeGeneric.
  "Constructor for macho.RelocTypeGeneric"
  {:added "1.0"
   :go "_ConstructRelocTypeGeneric(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RelocTypeX86_64 from debug/macho/reloctype.go:
(defn ^"GoObject" RelocTypeX86_64.
  "Constructor for macho.RelocTypeX86_64"
  {:added "1.0"
   :go "_ConstructRelocTypeX86_64(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Rpath from debug/macho/file.go:
(defn ^"GoObject" Rpath.
  "Constructor for macho.Rpath"
  {:added "1.0"
   :go "_ConstructRpath(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.RpathCmd from debug/macho/macho.go:
(defn ^"GoObject" RpathCmd.
  "Constructor for macho.RpathCmd"
  {:added "1.0"
   :go "_ConstructRpathCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Section from debug/macho/file.go:
;; (defn ^"GoObject" Section.
;;   "Constructor for macho.Section"
;;   {:added "1.0"
;;    :go "_ConstructSection(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Section32 from debug/macho/macho.go:
;; (defn ^"GoObject" Section32.
;;   "Constructor for macho.Section32"
;;   {:added "1.0"
;;    :go "_ConstructSection32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Section64 from debug/macho/macho.go:
;; (defn ^"GoObject" Section64.
;;   "Constructor for macho.Section64"
;;   {:added "1.0"
;;    :go "_ConstructSection64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SectionHeader from debug/macho/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for macho.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment from debug/macho/file.go:
(defn ^"GoObject" Segment.
  "Constructor for macho.Segment"
  {:added "1.0"
   :go "_ConstructSegment(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Segment32 from debug/macho/macho.go:
;; (defn ^"GoObject" Segment32.
;;   "Constructor for macho.Segment32"
;;   {:added "1.0"
;;    :go "_ConstructSegment32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Segment64 from debug/macho/macho.go:
;; (defn ^"GoObject" Segment64.
;;   "Constructor for macho.Segment64"
;;   {:added "1.0"
;;    :go "_ConstructSegment64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SegmentHeader from debug/macho/file.go:
(defn ^"GoObject" SegmentHeader.
  "Constructor for macho.SegmentHeader"
  {:added "1.0"
   :go "_ConstructSegmentHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symbol from debug/macho/file.go:
(defn ^"GoObject" Symbol.
  "Constructor for macho.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Symtab from debug/macho/file.go:
;; (defn ^"GoObject" Symtab.
;;   "Constructor for macho.Symtab"
;;   {:added "1.0"
;;    :go "_ConstructSymtab(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.SymtabCmd from debug/macho/macho.go:
(defn ^"GoObject" SymtabCmd.
  "Constructor for macho.SymtabCmd"
  {:added "1.0"
   :go "_ConstructSymtabCmd(_v)"}
  [^Object _v])

JOKER TYPE debug/macho.Thread from debug/macho/macho.go:
;; (defn ^"GoObject" Thread.
;;   "Constructor for macho.Thread"
;;   {:added "1.0"
;;    :go "_ConstructThread(_v)"}
;;   [^Object _v])

JOKER TYPE debug/macho.Type from debug/macho/macho.go:
(defn ^"GoObject" Type.
  "Constructor for macho.Type"
  {:added "1.0"
   :go "_ConstructType(_v)"}
  [^Object _v])

JOKER FUNC debug/macho.NewFatFile from debug/macho/fat.go:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
;;   {:added "1.0"
;;    :go "__newFatFile(*r)"}
;;   [^io/ReaderAt r])

JOKER FUNC debug/macho.NewFile from debug/macho/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*r)"}
;;   [^io/ReaderAt r])

JOKER FUNC debug/macho.Open from debug/macho/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/File) Error]"
  {:added "1.0"
   :go "__open(name)"}
  [^String name])

JOKER FUNC debug/macho.OpenFat from debug/macho/fat.go:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo input arguments: (name string)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.macho/FatFile) Error]"
  {:added "1.0"
   :go "__openFat(name)"}
  [^String name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/macho package."
    :empty false}
  go.std.debug.macho)
JOKER TYPE debug/pe.COFFSymbol from debug/pe/symbol.go:
;; (defn ^"GoObject" COFFSymbol.
;;   "Constructor for pe.COFFSymbol"
;;   {:added "1.0"
;;    :go "_ConstructCOFFSymbol(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.DataDirectory from debug/pe/pe.go:
(defn ^"GoObject" DataDirectory.
  "Constructor for pe.DataDirectory"
  {:added "1.0"
   :go "_ConstructDataDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.File from debug/pe/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for pe.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.FileHeader from debug/pe/pe.go:
(defn ^"GoObject" FileHeader.
  "Constructor for pe.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.FormatError from debug/pe/file.go:
(defn ^"GoObject" FormatError.
  "Constructor for pe.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.ImportDirectory from debug/pe/file.go:
(defn ^"GoObject" ImportDirectory.
  "Constructor for pe.ImportDirectory"
  {:added "1.0"
   :go "_ConstructImportDirectory(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.OptionalHeader32 from debug/pe/pe.go:
;; (defn ^"GoObject" OptionalHeader32.
;;   "Constructor for pe.OptionalHeader32"
;;   {:added "1.0"
;;    :go "_ConstructOptionalHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.OptionalHeader64 from debug/pe/pe.go:
;; (defn ^"GoObject" OptionalHeader64.
;;   "Constructor for pe.OptionalHeader64"
;;   {:added "1.0"
;;    :go "_ConstructOptionalHeader64(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.Reloc from debug/pe/section.go:
(defn ^"GoObject" Reloc.
  "Constructor for pe.Reloc"
  {:added "1.0"
   :go "_ConstructReloc(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.Section from debug/pe/section.go:
;; (defn ^"GoObject" Section.
;;   "Constructor for pe.Section"
;;   {:added "1.0"
;;    :go "_ConstructSection(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.SectionHeader from debug/pe/section.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for pe.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/pe.SectionHeader32 from debug/pe/section.go:
;; (defn ^"GoObject" SectionHeader32.
;;   "Constructor for pe.SectionHeader32"
;;   {:added "1.0"
;;    :go "_ConstructSectionHeader32(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.StringTable from debug/pe/string.go:
;; (defn ^"GoObject" StringTable.
;;   "Constructor for pe.StringTable"
;;   {:added "1.0"
;;    :go "_ConstructStringTable(_v)"}
;;   [^Object _v])

JOKER TYPE debug/pe.Symbol from debug/pe/symbol.go:
(defn ^"GoObject" Symbol.
  "Constructor for pe.Symbol"
  {:added "1.0"
   :go "_ConstructSymbol(_v)"}
  [^Object _v])

JOKER FUNC debug/pe.NewFile from debug/pe/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*r)"}
;;   [^io/ReaderAt r])

JOKER FUNC debug/pe.Open from debug/pe/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.pe/File) Error]"
  {:added "1.0"
   :go "__open(name)"}
  [^String name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/pe package."
    :empty false}
  go.std.debug.pe)
JOKER TYPE debug/plan9obj.File from debug/plan9obj/file.go:
;; (defn ^"GoObject" File.
;;   "Constructor for plan9obj.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE debug/plan9obj.FileHeader from debug/plan9obj/file.go:
(defn ^"GoObject" FileHeader.
  "Constructor for plan9obj.FileHeader"
  {:added "1.0"
   :go "_ConstructFileHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Section from debug/plan9obj/file.go:
(defn ^"GoObject" Section.
  "Constructor for plan9obj.Section"
  {:added "1.0"
   :go "_ConstructSection(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.SectionHeader from debug/plan9obj/file.go:
(defn ^"GoObject" SectionHeader.
  "Constructor for plan9obj.SectionHeader"
  {:added "1.0"
   :go "_ConstructSectionHeader(_v)"}
  [^Object _v])

JOKER TYPE debug/plan9obj.Sym from debug/plan9obj/file.go:
(defn ^"GoObject" Sym.
  "Constructor for plan9obj.Sym"
  {:added "1.0"
   :go "_ConstructSym(_v)"}
  [^Object _v])

JOKER FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^go.std.io/ReaderAt r]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
;;   {:added "1.0"
;;    :go "__newFile(*r)"}
;;   [^io/ReaderAt r])

JOKER FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.debug.plan9obj/File) Error]"
  {:added "1.0"
   :go "__open(name)"}
  [^String name])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the debug/plan9obj package."
    :empty false}
  go.std.debug.plan9obj)
JOKER TYPE encoding/ascii85.CorruptInputError from encoding/ascii85/ascii85.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for ascii85.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
;; (defn Decode
;;   "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo input arguments: (dst []byte, src []byte, flush bool)\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src, ^Boolean flush]\n\nJoker return type: [Int Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), flush)"}
;;   [^Object dst, ^Object src, ^Boolean flush])

JOKER FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ascii85.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^Object dst, ^Object src])

JOKER FUNC encoding/ascii85.MaxEncodedLen from encoding/ascii85/ascii85.go:
(defn ^"Int" MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(n)"}
  [^Int n])

JOKER FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/ascii85"]
    :doc "Provides a low-level interface to the encoding/ascii85 package."
    :empty false}
  go.std.encoding.ascii85)
JOKER TYPE encoding/asn1.BitString from encoding/asn1/asn1.go:
;; (defn ^"GoObject" BitString.
;;   "Constructor for asn1.BitString"
;;   {:added "1.0"
;;    :go "_ConstructBitString(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.Enumerated from encoding/asn1/asn1.go:
(defn ^"GoObject" Enumerated.
  "Constructor for asn1.Enumerated"
  {:added "1.0"
   :go "_ConstructEnumerated(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.Flag from encoding/asn1/asn1.go:
(defn ^"GoObject" Flag.
  "Constructor for asn1.Flag"
  {:added "1.0"
   :go "_ConstructFlag(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.ObjectIdentifier from encoding/asn1/asn1.go:
;; (defn ^"GoObject" ObjectIdentifier.
;;   "Constructor for asn1.ObjectIdentifier"
;;   {:added "1.0"
;;    :go "_ConstructObjectIdentifier(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.RawContent from encoding/asn1/asn1.go:
;; (defn ^"GoObject" RawContent.
;;   "Constructor for asn1.RawContent"
;;   {:added "1.0"
;;    :go "_ConstructRawContent(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.RawValue from encoding/asn1/asn1.go:
;; (defn ^"GoObject" RawValue.
;;   "Constructor for asn1.RawValue"
;;   {:added "1.0"
;;    :go "_ConstructRawValue(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/asn1.StructuralError from encoding/asn1/asn1.go:
(defn ^"GoObject" StructuralError.
  "Constructor for asn1.StructuralError"
  {:added "1.0"
   :go "_ConstructStructuralError(_v)"}
  [^Object _v])

JOKER TYPE encoding/asn1.SyntaxError from encoding/asn1/asn1.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for asn1.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo input arguments: (val interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> val])

JOKER FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (val interface {}, params string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalWithParams(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), params)"}
;;   [^<protocol-or-something> val, ^String params])

JOKER FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo input arguments: (b []byte, val interface {})\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Int) b, ^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object b, ^<protocol-or-something> val])

JOKER FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (b []byte, val interface {}, params string)\n\nGo return type: (rest []byte, err error)\n\nJoker input arguments: [^(vector-of Int) b, ^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__unmarshalWithParams(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), params)"}
;;   [^Object b, ^<protocol-or-something> val, ^String params])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/asn1 package."
    :empty false}
  go.std.encoding.asn1)
JOKER TYPE encoding/base32.CorruptInputError from encoding/base32/base32.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base32.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base32.Encoding from encoding/base32/base32.go:
(defn ^"GoObject" Encoding.
  "Constructor for base32.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(enc, *r)"}
;;   [^base32/Encoding enc, ^io/Reader r])

JOKER FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base32/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(enc, *w)"}
;;   [^base32/Encoding enc, ^io/Writer w])

JOKER FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
(defn NewEncoding
  "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base32/Encoding)"
  {:added "1.0"
   :go "__newEncoding(encoder)"}
  [^String encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base32 package."
    :empty false}
  go.std.encoding.base32)
JOKER TYPE encoding/base64.CorruptInputError from encoding/base64/base64.go:
(defn ^"GoObject" CorruptInputError.
  "Constructor for base64.CorruptInputError"
  {:added "1.0"
   :go "_ConstructCorruptInputError(_v)"}
  [^Object _v])

JOKER TYPE encoding/base64.Encoding from encoding/base64/base64.go:
(defn ^"GoObject" Encoding.
  "Constructor for base64.Encoding"
  {:added "1.0"
   :go "_ConstructEncoding(_v)"}
  [^Object _v])

JOKER FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo input arguments: (enc *Encoding, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(enc, *r)"}
;;   [^base64/Encoding enc, ^io/Reader r])

JOKER FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *Encoding, w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^(atom-of go.std.encoding.base64/Encoding) enc, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newEncoder(enc, *w)"}
;;   [^base64/Encoding enc, ^io/Writer w])

JOKER FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
(defn NewEncoding
  "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: (atom-of go.std.encoding.base64/Encoding)"
  {:added "1.0"
   :go "__newEncoding(encoder)"}
  [^String encoder])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/base64 package."
    :empty false}
  go.std.encoding.base64)
JOKER FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
;; (defn ^"Int" PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo input arguments: (buf []byte, x uint64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Number x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), x)"}
;;   [^Object buf, ^Number x])

JOKER FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
;; (defn ^"Int" PutVarint
;;   "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo input arguments: (buf []byte, x int64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Number x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutVarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), x)"}
;;   [^Object buf, ^Number x])

JOKER FUNC encoding/binary.Read from encoding/binary/binary.go:
;; (defn ^"Error" Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo input arguments: (r io.Reader, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(*r, *order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Reader r, ^binary/ByteOrder order, ^<protocol-or-something> data])

JOKER FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__readUvarint(*r)"}
;;   [^io/ByteReader r])

JOKER FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (int64, error)\n\nJoker input arguments: [^go.std.io/ByteReader r]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__readVarint(*r)"}
;;   [^io/ByteReader r])

JOKER FUNC encoding/binary.Size from encoding/binary/binary.go:
;; (defn ^"Int" Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo input arguments: (v interface {})\n\nGo return type: int\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> v])

JOKER FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (uint64, int)\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: [Number Int]"
;;   {:added "1.0"
;;    :go "__uvarint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^Object buf])

JOKER FUNC encoding/binary.Varint from encoding/binary/varint.go:
;; (defn Varint
;;   "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (int64, int)\n\nJoker input arguments: [^(vector-of Int) buf]\n\nJoker return type: [Number Int]"
;;   {:added "1.0"
;;    :go "__varint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^Object buf])

JOKER FUNC encoding/binary.Write from encoding/binary/binary.go:
;; (defn ^"Error" Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo input arguments: (w io.Writer, order ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.encoding.binary/ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(*w, *order, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer w, ^binary/ByteOrder order, ^<protocol-or-something> data])

JOKER TYPE encoding/csv.ParseError from encoding/csv/reader.go:
(defn ^"GoObject" ParseError.
  "Constructor for csv.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE encoding/csv.Reader from encoding/csv/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for csv.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE encoding/csv.Writer from encoding/csv/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for csv.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC encoding/csv.NewReader from encoding/csv/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.csv/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.csv/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/csv package."
    :empty false}
  go.std.encoding.csv)
JOKER FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.gob/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.gob/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*w)"}
;;   [^io/Writer w])

JOKER FUNC encoding/gob.Register from encoding/gob/type.go:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n\nGo input arguments: (value interface {})\n\nJoker input arguments: [^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> value])

JOKER FUNC encoding/gob.RegisterName from encoding/gob/type.go:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n\nGo input arguments: (name string, value interface {})\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "__registerName(name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String name, ^<protocol-or-something> value])

JOKER TYPE encoding/hex.InvalidByteError from encoding/hex/hex.go:
(defn ^"GoObject" InvalidByteError.
  "Constructor for hex.InvalidByteError"
  {:added "1.0"
   :go "_ConstructInvalidByteError(_v)"}
  [^Object _v])

JOKER FUNC encoding/hex.Decode from encoding/hex/hex.go:
;; (defn Decode
;;   "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: (int, error)\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^Object dst, ^Object src])

JOKER FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__decodeString(s)"}
  [^String s])

JOKER FUNC encoding/hex.DecodedLen from encoding/hex/hex.go:
(defn ^"Int" DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo input arguments: (x int)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(x)"}
  [^Int x])

JOKER FUNC encoding/hex.Dump from encoding/hex/hex.go:
;; (defn ^"String" Dump
;;   "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.Dump(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC encoding/hex.Dumper from encoding/hex/hex.go:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__dumper(*w)"}
;;   [^io/Writer w])

JOKER FUNC encoding/hex.Encode from encoding/hex/hex.go:
;; (defn ^"Int" Encode
;;   "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) dst, ^(vector-of Int) src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "hex.Encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^Object dst, ^Object src])

JOKER FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
;; (defn ^"String" EncodeToString
;;   "EncodeToString returns the hexadecimal encoding of src.\n\nGo input arguments: (src []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) src]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "hex.EncodeToString(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^Object src])

JOKER FUNC encoding/hex.EncodedLen from encoding/hex/hex.go:
(defn ^"Int" EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(n)"}
  [^Int n])

JOKER FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newDecoder(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newEncoder(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["encoding/hex"]
    :doc "Provides a low-level interface to the encoding/hex package."
    :empty false}
  go.std.encoding.hex)
JOKER TYPE encoding/json.Decoder from encoding/json/stream.go:
(defn ^"GoObject" Decoder.
  "Constructor for json.Decoder"
  {:added "1.0"
   :go "_ConstructDecoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Delim from encoding/json/stream.go:
(defn ^"GoObject" Delim.
  "Constructor for json.Delim"
  {:added "1.0"
   :go "_ConstructDelim(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Encoder from encoding/json/stream.go:
(defn ^"GoObject" Encoder.
  "Constructor for json.Encoder"
  {:added "1.0"
   :go "_ConstructEncoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.InvalidUTF8Error from encoding/json/encode.go:
(defn ^"GoObject" InvalidUTF8Error.
  "Constructor for json.InvalidUTF8Error"
  {:added "1.0"
   :go "_ConstructInvalidUTF8Error(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.InvalidUnmarshalError from encoding/json/decode.go:
;; (defn ^"GoObject" InvalidUnmarshalError.
;;   "Constructor for json.InvalidUnmarshalError"
;;   {:added "1.0"
;;    :go "_ConstructInvalidUnmarshalError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Marshaler from encoding/json/encode.go:
;; (defn ^"GoObject" Marshaler.
;;   "Constructor for json.Marshaler"
;;   {:added "1.0"
;;    :go "_ConstructMarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.MarshalerError from encoding/json/encode.go:
;; (defn ^"GoObject" MarshalerError.
;;   "Constructor for json.MarshalerError"
;;   {:added "1.0"
;;    :go "_ConstructMarshalerError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Number from encoding/json/decode.go:
(defn ^"GoObject" Number.
  "Constructor for json.Number"
  {:added "1.0"
   :go "_ConstructNumber(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.RawMessage from encoding/json/stream.go:
;; (defn ^"GoObject" RawMessage.
;;   "Constructor for json.RawMessage"
;;   {:added "1.0"
;;    :go "_ConstructRawMessage(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.SyntaxError from encoding/json/scanner.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for json.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER TYPE encoding/json.Token from encoding/json/stream.go:
;; (defn ^"GoObject" Token.
;;   "Constructor for json.Token"
;;   {:added "1.0"
;;    :go "_ConstructToken(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnmarshalFieldError from encoding/json/decode.go:
;; (defn ^"GoObject" UnmarshalFieldError.
;;   "Constructor for json.UnmarshalFieldError"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalFieldError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnmarshalTypeError from encoding/json/decode.go:
;; (defn ^"GoObject" UnmarshalTypeError.
;;   "Constructor for json.UnmarshalTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalTypeError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.Unmarshaler from encoding/json/decode.go:
;; (defn ^"GoObject" Unmarshaler.
;;   "Constructor for json.Unmarshaler"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnsupportedTypeError from encoding/json/encode.go:
;; (defn ^"GoObject" UnsupportedTypeError.
;;   "Constructor for json.UnsupportedTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedTypeError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/json.UnsupportedValueError from encoding/json/encode.go:
;; (defn ^"GoObject" UnsupportedValueError.
;;   "Constructor for json.UnsupportedValueError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedValueError(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/json.Compact from encoding/json/indent.go:
;; (defn ^"Error" Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^bytes/Buffer dst, ^Object src])

JOKER FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^bytes/Buffer dst, ^Object src])

JOKER FUNC encoding/json.Indent from encoding/json/indent.go:
;; (defn ^"Error" Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo input arguments: (dst *bytes.Buffer, src []byte, prefix string, indent string)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) dst, ^(vector-of Int) src, ^String prefix, ^String indent]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(dst, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), prefix, indent)"}
;;   [^bytes/Buffer dst, ^Object src, ^String prefix, ^String indent])

JOKER FUNC encoding/json.Marshal from encoding/json/encode.go:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> v])

JOKER FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), prefix, indent)"}
;;   [^<protocol-or-something> v, ^String prefix, ^String indent])

JOKER FUNC encoding/json.NewDecoder from encoding/json/stream.go:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.json/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/json.NewEncoder from encoding/json/stream.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.json/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*w)"}
;;   [^io/Writer w])

JOKER FUNC encoding/json.Unmarshal from encoding/json/decode.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object data, ^<protocol-or-something> v])

JOKER FUNC encoding/json.Valid from encoding/json/scanner.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether data is a valid JSON encoding.\n\nGo input arguments: (data []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "json.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/json package."
    :empty false}
  go.std.encoding.json)
JOKER TYPE encoding/pem.Block from encoding/pem/pem.go:
;; (defn ^"GoObject" Block.
;;   "Constructor for pem.Block"
;;   {:added "1.0"
;;    :go "_ConstructBlock(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/pem.Decode from encoding/pem/pem.go:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo input arguments: (data []byte)\n\nGo return type: (p *Block, rest []byte)\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.encoding.pem/Block) (vector-of Int)]"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC encoding/pem.Encode from encoding/pem/pem.go:
;; (defn ^"Error" Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo input arguments: (out io.Writer, b *Block)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer out, ^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(*out, b)"}
;;   [^io/Writer out, ^pem/Block b])

JOKER FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
(defn EncodeToMemory
  "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo input arguments: (b *Block)\n\nGo return type: []byte\n\nJoker input arguments: [^(atom-of go.std.encoding.pem/Block) b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__encodeToMemory(b)"}
  [^pem/Block b])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/pem package."
    :empty false}
  go.std.encoding.pem)
JOKER TYPE encoding/xml.Attr from encoding/xml/xml.go:
;; (defn ^"GoObject" Attr.
;;   "Constructor for xml.Attr"
;;   {:added "1.0"
;;    :go "_ConstructAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.CharData from encoding/xml/xml.go:
;; (defn ^"GoObject" CharData.
;;   "Constructor for xml.CharData"
;;   {:added "1.0"
;;    :go "_ConstructCharData(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Comment from encoding/xml/xml.go:
;; (defn ^"GoObject" Comment.
;;   "Constructor for xml.Comment"
;;   {:added "1.0"
;;    :go "_ConstructComment(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Decoder from encoding/xml/xml.go:
;; (defn ^"GoObject" Decoder.
;;   "Constructor for xml.Decoder"
;;   {:added "1.0"
;;    :go "_ConstructDecoder(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Directive from encoding/xml/xml.go:
;; (defn ^"GoObject" Directive.
;;   "Constructor for xml.Directive"
;;   {:added "1.0"
;;    :go "_ConstructDirective(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Encoder from encoding/xml/marshal.go:
(defn ^"GoObject" Encoder.
  "Constructor for xml.Encoder"
  {:added "1.0"
   :go "_ConstructEncoder(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.EndElement from encoding/xml/xml.go:
;; (defn ^"GoObject" EndElement.
;;   "Constructor for xml.EndElement"
;;   {:added "1.0"
;;    :go "_ConstructEndElement(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Marshaler from encoding/xml/marshal.go:
;; (defn ^"GoObject" Marshaler.
;;   "Constructor for xml.Marshaler"
;;   {:added "1.0"
;;    :go "_ConstructMarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.MarshalerAttr from encoding/xml/marshal.go:
;; (defn ^"GoObject" MarshalerAttr.
;;   "Constructor for xml.MarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructMarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Name from encoding/xml/xml.go:
(defn ^"GoObject" Name.
  "Constructor for xml.Name"
  {:added "1.0"
   :go "_ConstructName(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.ProcInst from encoding/xml/xml.go:
;; (defn ^"GoObject" ProcInst.
;;   "Constructor for xml.ProcInst"
;;   {:added "1.0"
;;    :go "_ConstructProcInst(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.StartElement from encoding/xml/xml.go:
;; (defn ^"GoObject" StartElement.
;;   "Constructor for xml.StartElement"
;;   {:added "1.0"
;;    :go "_ConstructStartElement(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.SyntaxError from encoding/xml/xml.go:
(defn ^"GoObject" SyntaxError.
  "Constructor for xml.SyntaxError"
  {:added "1.0"
   :go "_ConstructSyntaxError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.TagPathError from encoding/xml/typeinfo.go:
;; (defn ^"GoObject" TagPathError.
;;   "Constructor for xml.TagPathError"
;;   {:added "1.0"
;;    :go "_ConstructTagPathError(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.Token from encoding/xml/xml.go:
;; (defn ^"GoObject" Token.
;;   "Constructor for xml.Token"
;;   {:added "1.0"
;;    :go "_ConstructToken(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.TokenReader from encoding/xml/xml.go:
;; (defn ^"GoObject" TokenReader.
;;   "Constructor for xml.TokenReader"
;;   {:added "1.0"
;;    :go "_ConstructTokenReader(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalError from encoding/xml/read.go:
(defn ^"GoObject" UnmarshalError.
  "Constructor for xml.UnmarshalError"
  {:added "1.0"
   :go "_ConstructUnmarshalError(_v)"}
  [^Object _v])

JOKER TYPE encoding/xml.Unmarshaler from encoding/xml/read.go:
;; (defn ^"GoObject" Unmarshaler.
;;   "Constructor for xml.Unmarshaler"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshaler(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnmarshalerAttr from encoding/xml/read.go:
;; (defn ^"GoObject" UnmarshalerAttr.
;;   "Constructor for xml.UnmarshalerAttr"
;;   {:added "1.0"
;;    :go "_ConstructUnmarshalerAttr(_v)"}
;;   [^Object _v])

JOKER TYPE encoding/xml.UnsupportedTypeError from encoding/xml/marshal.go:
;; (defn ^"GoObject" UnsupportedTypeError.
;;   "Constructor for xml.UnsupportedTypeError"
;;   {:added "1.0"
;;    :go "_ConstructUnsupportedTypeError(_v)"}
;;   [^Object _v])

JOKER FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
(defn CopyToken
  "CopyToken returns a copy of a Token.\n\nGo input arguments: (t Token)\n\nGo return type: Token\n\nJoker input arguments: [^go.std.encoding.xml/Token t]\n\nJoker return type: go.std.encoding.xml/Token"
  {:added "1.0"
   :go "__copyToken(*t)"}
  [^xml/Token t])

JOKER FUNC encoding/xml.Escape from encoding/xml/xml.go:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n\nGo input arguments: (w io.Writer, s []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) s]"
;;   {:added "1.0"
;;    :go "__escape(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^io/Writer w, ^Object s])

JOKER FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
;; (defn ^"Error" EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo input arguments: (w io.Writer, s []byte)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) s]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)))"}
;;   [^io/Writer w, ^Object s])

JOKER FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n    - a field implementing Marshaler is written by calling its MarshalXML\n      method.\n    - a field implementing encoding.TextMarshaler is written by encoding the\n      result of its MarshalText method as text.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshal(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> v])

JOKER FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__marshalIndent(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), prefix, indent)"}
;;   [^<protocol-or-something> v, ^String prefix, ^String indent])

JOKER FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
;;   {:added "1.0"
;;    :go "__newDecoder(*r)"}
;;   [^io/Reader r])

JOKER FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.encoding.xml/Encoder)"
;;   {:added "1.0"
;;    :go "__newEncoder(*w)"}
;;   [^io/Writer w])

JOKER FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
(defn NewTokenDecoder
  "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo input arguments: (t TokenReader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^go.std.encoding.xml/TokenReader t]\n\nJoker return type: (atom-of go.std.encoding.xml/Decoder)"
  {:added "1.0"
   :go "__newTokenDecoder(*t)"}
  [^xml/TokenReader t])

JOKER FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nIf Unmarshal encounters a field type that implements the Unmarshaler\ninterface, Unmarshal calls its UnmarshalXML method to produce the value from\nthe XML element.  Otherwise, if the value implements\nencoding.TextUnmarshaler, Unmarshal calls that value's UnmarshalText method.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object data, ^<protocol-or-something> v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the encoding/xml package."
    :empty false}
  go.std.encoding.xml)
JOKER FUNC errors.New from errors/errors.go:
(defn ^"Error" New
  "New returns an error that formats as the given text.\n\nGo input arguments: (text string)\n\nGo return type: error\n\nJoker input arguments: [^String text]\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(text)"}
  [^String text])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["errors"]
    :doc "Provides a low-level interface to the errors package."
    :empty false}
  go.std.errors)
JOKER TYPE expvar.Float from expvar/expvar.go:
(defn ^"GoObject" Float.
  "Constructor for expvar.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE expvar.Func from expvar/expvar.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for expvar.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE expvar.Int from expvar/expvar.go:
(defn ^"GoObject" Int.
  "Constructor for expvar.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE expvar.KeyValue from expvar/expvar.go:
;; (defn ^"GoObject" KeyValue.
;;   "Constructor for expvar.KeyValue"
;;   {:added "1.0"
;;    :go "_ConstructKeyValue(_v)"}
;;   [^Object _v])

JOKER TYPE expvar.Map from expvar/expvar.go:
(defn ^"GoObject" Map.
  "Constructor for expvar.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE expvar.String from expvar/expvar.go:
(defn ^"GoObject" String.
  "Constructor for expvar.String"
  {:added "1.0"
   :go "_ConstructString(_v)"}
  [^Object _v])

JOKER TYPE expvar.Var from expvar/expvar.go:
;; (defn ^"GoObject" Var.
;;   "Constructor for expvar.Var"
;;   {:added "1.0"
;;    :go "_ConstructVar(_v)"}
;;   [^Object _v])

JOKER FUNC expvar.Do from expvar/expvar.go:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n\nGo input arguments: (f func)\n\nJoker input arguments: [^fn f]"
;;   {:added "1.0"
;;    :go "__do(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn f])

JOKER FUNC expvar.Get from expvar/expvar.go:
(defn Get
  "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo input arguments: (name string)\n\nGo return type: Var\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.expvar/Var"
  {:added "1.0"
   :go "__get(name)"}
  [^String name])

JOKER FUNC expvar.Handler from expvar/expvar.go:
(defn Handler
  "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: net/http.Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler()"}
  [])

JOKER FUNC expvar.NewFloat from expvar/expvar.go:
(defn NewFloat
  "Go input arguments: (name string)\n\nGo return type: *Float\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Float)"
  {:added "1.0"
   :go "__newFloat(name)"}
  [^String name])

JOKER FUNC expvar.NewInt from expvar/expvar.go:
(defn NewInt
  "Go input arguments: (name string)\n\nGo return type: *Int\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Int)"
  {:added "1.0"
   :go "__newInt(name)"}
  [^String name])

JOKER FUNC expvar.NewMap from expvar/expvar.go:
(defn NewMap
  "Go input arguments: (name string)\n\nGo return type: *Map\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/Map)"
  {:added "1.0"
   :go "__newMap(name)"}
  [^String name])

JOKER FUNC expvar.NewString from expvar/expvar.go:
(defn NewString
  "Go input arguments: (name string)\n\nGo return type: *String\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.expvar/String)"
  {:added "1.0"
   :go "__newString(name)"}
  [^String name])

JOKER FUNC expvar.Publish from expvar/expvar.go:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n\nGo input arguments: (name string, v Var)\n\nJoker input arguments: [^String name, ^go.std.expvar/Var v]"
;;   {:added "1.0"
;;    :go "__publish(name, *v)"}
;;   [^String name, ^expvar/Var v])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the expvar package."
    :empty false}
  go.std.expvar)
JOKER TYPE flag.ErrorHandling from flag/flag.go:
(defn ^"GoObject" ErrorHandling.
  "Constructor for flag.ErrorHandling"
  {:added "1.0"
   :go "_ConstructErrorHandling(_v)"}
  [^Object _v])

JOKER TYPE flag.Flag from flag/flag.go:
;; (defn ^"GoObject" Flag.
;;   "Constructor for flag.Flag"
;;   {:added "1.0"
;;    :go "_ConstructFlag(_v)"}
;;   [^Object _v])

JOKER TYPE flag.FlagSet from flag/flag.go:
;; (defn ^"GoObject" FlagSet.
;;   "Constructor for flag.FlagSet"
;;   {:added "1.0"
;;    :go "_ConstructFlagSet(_v)"}
;;   [^Object _v])

JOKER TYPE flag.Getter from flag/flag.go:
;; (defn ^"GoObject" Getter.
;;   "Constructor for flag.Getter"
;;   {:added "1.0"
;;    :go "_ConstructGetter(_v)"}
;;   [^Object _v])

JOKER TYPE flag.Value from flag/flag.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for flag.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC flag.Arg from flag/flag.go:
(defn ^"String" Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(i)"}
  [^Int i])

JOKER FUNC flag.Args from flag/flag.go:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__args()"}
  [])

JOKER FUNC flag.Bool from flag/flag.go:
(defn Bool
  "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo input arguments: (name string, value bool, usage string)\n\nGo return type: *bool\n\nJoker input arguments: [^String name, ^Boolean value, ^String usage]\n\nJoker return type: (atom-of Boolean)"
  {:added "1.0"
   :go "__bool(name, value, usage)"}
  [^String name, ^Boolean value, ^String usage])

JOKER FUNC flag.BoolVar from flag/flag.go:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n\nGo input arguments: (p *bool, name string, value bool, usage string)\n\nJoker input arguments: [^(atom-of Boolean) p, ^String name, ^Boolean value, ^String usage]"
;;   {:added "1.0"
;;    :go "__boolVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfbool(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Boolean value, ^String usage])

JOKER FUNC flag.Duration from flag/flag.go:
;; (defn Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (name string, value time.Duration, usage string)\n\nGo return type: *time.Duration\n\nJoker input arguments: [^String name, ^go.std.time/Duration value, ^String usage]\n\nJoker return type: (atom-of go.std.time/Duration)"
;;   {:added "1.0"
;;    :go "__duration(name, *value, usage)"}
;;   [^String name, ^time/Duration value, ^String usage])

JOKER FUNC flag.DurationVar from flag/flag.go:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (p *time.Duration, name string, value time.Duration, usage string)\n\nJoker input arguments: [^(atom-of go.std.time/Duration) p, ^String name, ^go.std.time/Duration value, ^String usage]"
;;   {:added "1.0"
;;    :go "__durationVar(p, name, *value, usage)"}
;;   [^time/Duration p, ^String name, ^time/Duration value, ^String usage])

JOKER FUNC flag.Float64 from flag/flag.go:
(defn Float64
  "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value float64, usage string)\n\nGo return type: *float64\n\nJoker input arguments: [^String name, ^Double value, ^String usage]\n\nJoker return type: (atom-of Double)"
  {:added "1.0"
   :go "__float64(name, value, usage)"}
  [^String name, ^Double value, ^String usage])

JOKER FUNC flag.Float64Var from flag/flag.go:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n\nGo input arguments: (p *float64, name string, value float64, usage string)\n\nJoker input arguments: [^(atom-of Double) p, ^String name, ^Double value, ^String usage]"
;;   {:added "1.0"
;;    :go "__float64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOffloat64(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Double value, ^String usage])

JOKER FUNC flag.Int from flag/flag.go:
(defn Int
  "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo input arguments: (name string, value int, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int value, ^String usage]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__int(name, value, usage)"}
  [^String name, ^Int value, ^String usage])

JOKER FUNC flag.Int64 from flag/flag.go:
(defn Int64
  "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value int64, usage string)\n\nGo return type: *int64\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__int64(name, value, usage)"}
  [^String name, ^Number value, ^String usage])

JOKER FUNC flag.Int64Var from flag/flag.go:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n\nGo input arguments: (p *int64, name string, value int64, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__int64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Number value, ^String usage])

JOKER FUNC flag.IntVar from flag/flag.go:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n\nGo input arguments: (p *int, name string, value int, usage string)\n\nJoker input arguments: [^(atom-of Int) p, ^String name, ^Int value, ^String usage]"
;;   {:added "1.0"
;;    :go "__intVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Int value, ^String usage])

JOKER FUNC flag.Lookup from flag/flag.go:
(defn Lookup
  "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo input arguments: (name string)\n\nGo return type: *Flag\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.flag/Flag)"
  {:added "1.0"
   :go "__lookup(name)"}
  [^String name])

JOKER FUNC flag.NArg from flag/flag.go:
(defn ^"Int" NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag from flag/flag.go:
(defn ^"Int" NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet from flag/flag.go:
(defn NewFlagSet
  "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo input arguments: (name string, errorHandling ErrorHandling)\n\nGo return type: *FlagSet\n\nJoker input arguments: [^String name, ^go.std.flag/ErrorHandling errorHandling]\n\nJoker return type: (atom-of go.std.flag/FlagSet)"
  {:added "1.0"
   :go "__newFlagSet(name, *errorHandling)"}
  [^String name, ^flag/ErrorHandling errorHandling])

JOKER FUNC flag.Parse from flag/flag.go:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__parse()"}
;;   [])

JOKER FUNC flag.Parsed from flag/flag.go:
(defn ^"Boolean" Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults from flag/flag.go:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n\nTo change the destination for flag messages, call CommandLine.SetOutput.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printDefaults()"}
;;   [])

JOKER FUNC flag.Set from flag/flag.go:
(defn ^"Error" Set
  "Set sets the value of the named command-line flag.\n\nGo input arguments: (name string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(name, value)"}
  [^String name, ^String value])

JOKER FUNC flag.String from flag/flag.go:
(defn String
  "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo input arguments: (name string, value string, usage string)\n\nGo return type: *string\n\nJoker input arguments: [^String name, ^String value, ^String usage]\n\nJoker return type: (atom-of String)"
  {:added "1.0"
   :go "__string(name, value, usage)"}
  [^String name, ^String value, ^String usage])

JOKER FUNC flag.StringVar from flag/flag.go:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n\nGo input arguments: (p *string, name string, value string, usage string)\n\nJoker input arguments: [^(atom-of String) p, ^String name, ^String value, ^String usage]"
;;   {:added "1.0"
;;    :go "__stringVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfstring(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^String value, ^String usage])

JOKER FUNC flag.Uint from flag/flag.go:
(defn Uint
  "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint, usage string)\n\nGo return type: *uint\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__uint(name, value, usage)"}
  [^String name, ^Number value, ^String usage])

JOKER FUNC flag.Uint64 from flag/flag.go:
(defn Uint64
  "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint64, usage string)\n\nGo return type: *uint64\n\nJoker input arguments: [^String name, ^Number value, ^String usage]\n\nJoker return type: (atom-of Number)"
  {:added "1.0"
   :go "__uint64(name, value, usage)"}
  [^String name, ^Number value, ^String usage])

JOKER FUNC flag.Uint64Var from flag/flag.go:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n\nGo input arguments: (p *uint64, name string, value uint64, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uint64Var(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Number value, ^String usage])

JOKER FUNC flag.UintVar from flag/flag.go:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n\nGo input arguments: (p *uint, name string, value uint, usage string)\n\nJoker input arguments: [^(atom-of Number) p, ^String name, ^Number value, ^String usage]"
;;   {:added "1.0"
;;    :go "__uintVar(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint(p)), name, value, usage)"}
;;   [^Object p, ^String name, ^Number value, ^String usage])

JOKER FUNC flag.UnquoteUsage from flag/flag.go:
(defn UnquoteUsage
  "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo input arguments: (flag *Flag)\n\nGo return type: (name string, usage string)\n\nJoker input arguments: [^(atom-of go.std.flag/Flag) flag]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__unquoteUsage(flag)"}
  [^flag/Flag flag])

JOKER FUNC flag.Var from flag/flag.go:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n\nGo input arguments: (value Value, name string, usage string)\n\nJoker input arguments: [^go.std.flag/Value value, ^String name, ^String usage]"
;;   {:added "1.0"
;;    :go "__var(*value, name, usage)"}
;;   [^flag/Value value, ^String name, ^String usage])

JOKER FUNC flag.Visit from flag/flag.go:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visit(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn fn])

JOKER FUNC flag.VisitAll from flag/flag.go:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "__visitAll(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["flag"]
    :doc "Provides a low-level interface to the flag package."
    :empty false}
  go.std.flag)
JOKER FUNC fmt.Errorf from fmt/print.go:
;; (defn ^"Error" Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: error\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Fprint from fmt/print.go:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprint(*w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer w, ^<protocol-or-something> a])

JOKER FUNC fmt.Fprintf from fmt/print.go:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintf(*w, format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer w, ^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Fprintln from fmt/print.go:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fprintln(*w, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Writer w, ^<protocol-or-something> a])

JOKER FUNC fmt.Fscan from fmt/scan.go:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscan(*r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader r, ^<protocol-or-something> a])

JOKER FUNC fmt.Fscanf from fmt/scan.go:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (r io.Reader, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanf(*r, format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader r, ^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Fscanln from fmt/scan.go:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__fscanln(*r, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io/Reader r, ^<protocol-or-something> a])

JOKER FUNC fmt.Print from fmt/print.go:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Printf from fmt/print.go:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__printf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Println from fmt/print.go:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Scan from fmt/scan.go:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scan(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Scanf from fmt/scan.go:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Scanln from fmt/scan.go:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__scanln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Sprint from fmt/print.go:
;; (defn ^"String" Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Sprintf from fmt/print.go:
;; (defn ^"String" Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Sprintln from fmt/print.go:
;; (defn ^"String" Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> a])

JOKER FUNC fmt.Sscan from fmt/scan.go:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscan(str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String str, ^<protocol-or-something> a])

JOKER FUNC fmt.Sscanf from fmt/scan.go:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (str string, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanf(str, format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String str, ^String format, ^<protocol-or-something> a])

JOKER FUNC fmt.Sscanln from fmt/scan.go:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sscanln(str, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String str, ^<protocol-or-something> a])

JOKER TYPE go/ast.ArrayType from go/ast/ast.go:
;; (defn ^"GoObject" ArrayType.
;;   "Constructor for ast.ArrayType"
;;   {:added "1.0"
;;    :go "_ConstructArrayType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.AssignStmt from go/ast/ast.go:
;; (defn ^"GoObject" AssignStmt.
;;   "Constructor for ast.AssignStmt"
;;   {:added "1.0"
;;    :go "_ConstructAssignStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadDecl from go/ast/ast.go:
;; (defn ^"GoObject" BadDecl.
;;   "Constructor for ast.BadDecl"
;;   {:added "1.0"
;;    :go "_ConstructBadDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadExpr from go/ast/ast.go:
;; (defn ^"GoObject" BadExpr.
;;   "Constructor for ast.BadExpr"
;;   {:added "1.0"
;;    :go "_ConstructBadExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BadStmt from go/ast/ast.go:
;; (defn ^"GoObject" BadStmt.
;;   "Constructor for ast.BadStmt"
;;   {:added "1.0"
;;    :go "_ConstructBadStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BasicLit from go/ast/ast.go:
;; (defn ^"GoObject" BasicLit.
;;   "Constructor for ast.BasicLit"
;;   {:added "1.0"
;;    :go "_ConstructBasicLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BinaryExpr from go/ast/ast.go:
;; (defn ^"GoObject" BinaryExpr.
;;   "Constructor for ast.BinaryExpr"
;;   {:added "1.0"
;;    :go "_ConstructBinaryExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BlockStmt from go/ast/ast.go:
;; (defn ^"GoObject" BlockStmt.
;;   "Constructor for ast.BlockStmt"
;;   {:added "1.0"
;;    :go "_ConstructBlockStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.BranchStmt from go/ast/ast.go:
;; (defn ^"GoObject" BranchStmt.
;;   "Constructor for ast.BranchStmt"
;;   {:added "1.0"
;;    :go "_ConstructBranchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CallExpr from go/ast/ast.go:
;; (defn ^"GoObject" CallExpr.
;;   "Constructor for ast.CallExpr"
;;   {:added "1.0"
;;    :go "_ConstructCallExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CaseClause from go/ast/ast.go:
;; (defn ^"GoObject" CaseClause.
;;   "Constructor for ast.CaseClause"
;;   {:added "1.0"
;;    :go "_ConstructCaseClause(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ChanDir from go/ast/ast.go:
(defn ^"GoObject" ChanDir.
  "Constructor for ast.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/ast.ChanType from go/ast/ast.go:
;; (defn ^"GoObject" ChanType.
;;   "Constructor for ast.ChanType"
;;   {:added "1.0"
;;    :go "_ConstructChanType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommClause from go/ast/ast.go:
;; (defn ^"GoObject" CommClause.
;;   "Constructor for ast.CommClause"
;;   {:added "1.0"
;;    :go "_ConstructCommClause(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Comment from go/ast/ast.go:
;; (defn ^"GoObject" Comment.
;;   "Constructor for ast.Comment"
;;   {:added "1.0"
;;    :go "_ConstructComment(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommentGroup from go/ast/ast.go:
;; (defn ^"GoObject" CommentGroup.
;;   "Constructor for ast.CommentGroup"
;;   {:added "1.0"
;;    :go "_ConstructCommentGroup(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CommentMap from go/ast/commentmap.go:
;; (defn ^"GoObject" CommentMap.
;;   "Constructor for ast.CommentMap"
;;   {:added "1.0"
;;    :go "_ConstructCommentMap(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.CompositeLit from go/ast/ast.go:
;; (defn ^"GoObject" CompositeLit.
;;   "Constructor for ast.CompositeLit"
;;   {:added "1.0"
;;    :go "_ConstructCompositeLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Decl from go/ast/ast.go:
;; (defn ^"GoObject" Decl.
;;   "Constructor for ast.Decl"
;;   {:added "1.0"
;;    :go "_ConstructDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.DeclStmt from go/ast/ast.go:
;; (defn ^"GoObject" DeclStmt.
;;   "Constructor for ast.DeclStmt"
;;   {:added "1.0"
;;    :go "_ConstructDeclStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.DeferStmt from go/ast/ast.go:
;; (defn ^"GoObject" DeferStmt.
;;   "Constructor for ast.DeferStmt"
;;   {:added "1.0"
;;    :go "_ConstructDeferStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Ellipsis from go/ast/ast.go:
;; (defn ^"GoObject" Ellipsis.
;;   "Constructor for ast.Ellipsis"
;;   {:added "1.0"
;;    :go "_ConstructEllipsis(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.EmptyStmt from go/ast/ast.go:
;; (defn ^"GoObject" EmptyStmt.
;;   "Constructor for ast.EmptyStmt"
;;   {:added "1.0"
;;    :go "_ConstructEmptyStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Expr from go/ast/ast.go:
;; (defn ^"GoObject" Expr.
;;   "Constructor for ast.Expr"
;;   {:added "1.0"
;;    :go "_ConstructExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ExprStmt from go/ast/ast.go:
;; (defn ^"GoObject" ExprStmt.
;;   "Constructor for ast.ExprStmt"
;;   {:added "1.0"
;;    :go "_ConstructExprStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Field from go/ast/ast.go:
;; (defn ^"GoObject" Field.
;;   "Constructor for ast.Field"
;;   {:added "1.0"
;;    :go "_ConstructField(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FieldFilter from go/ast/print.go:
;; (defn ^"GoObject" FieldFilter.
;;   "Constructor for ast.FieldFilter"
;;   {:added "1.0"
;;    :go "_ConstructFieldFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FieldList from go/ast/ast.go:
;; (defn ^"GoObject" FieldList.
;;   "Constructor for ast.FieldList"
;;   {:added "1.0"
;;    :go "_ConstructFieldList(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.File from go/ast/ast.go:
;; (defn ^"GoObject" File.
;;   "Constructor for ast.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Filter from go/ast/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for ast.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ForStmt from go/ast/ast.go:
;; (defn ^"GoObject" ForStmt.
;;   "Constructor for ast.ForStmt"
;;   {:added "1.0"
;;    :go "_ConstructForStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncDecl from go/ast/ast.go:
;; (defn ^"GoObject" FuncDecl.
;;   "Constructor for ast.FuncDecl"
;;   {:added "1.0"
;;    :go "_ConstructFuncDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncLit from go/ast/ast.go:
;; (defn ^"GoObject" FuncLit.
;;   "Constructor for ast.FuncLit"
;;   {:added "1.0"
;;    :go "_ConstructFuncLit(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.FuncType from go/ast/ast.go:
;; (defn ^"GoObject" FuncType.
;;   "Constructor for ast.FuncType"
;;   {:added "1.0"
;;    :go "_ConstructFuncType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.GenDecl from go/ast/ast.go:
;; (defn ^"GoObject" GenDecl.
;;   "Constructor for ast.GenDecl"
;;   {:added "1.0"
;;    :go "_ConstructGenDecl(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.GoStmt from go/ast/ast.go:
;; (defn ^"GoObject" GoStmt.
;;   "Constructor for ast.GoStmt"
;;   {:added "1.0"
;;    :go "_ConstructGoStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Ident from go/ast/ast.go:
;; (defn ^"GoObject" Ident.
;;   "Constructor for ast.Ident"
;;   {:added "1.0"
;;    :go "_ConstructIdent(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IfStmt from go/ast/ast.go:
;; (defn ^"GoObject" IfStmt.
;;   "Constructor for ast.IfStmt"
;;   {:added "1.0"
;;    :go "_ConstructIfStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ImportSpec from go/ast/ast.go:
;; (defn ^"GoObject" ImportSpec.
;;   "Constructor for ast.ImportSpec"
;;   {:added "1.0"
;;    :go "_ConstructImportSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Importer from go/ast/resolve.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for ast.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IncDecStmt from go/ast/ast.go:
;; (defn ^"GoObject" IncDecStmt.
;;   "Constructor for ast.IncDecStmt"
;;   {:added "1.0"
;;    :go "_ConstructIncDecStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.IndexExpr from go/ast/ast.go:
;; (defn ^"GoObject" IndexExpr.
;;   "Constructor for ast.IndexExpr"
;;   {:added "1.0"
;;    :go "_ConstructIndexExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.InterfaceType from go/ast/ast.go:
;; (defn ^"GoObject" InterfaceType.
;;   "Constructor for ast.InterfaceType"
;;   {:added "1.0"
;;    :go "_ConstructInterfaceType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.KeyValueExpr from go/ast/ast.go:
;; (defn ^"GoObject" KeyValueExpr.
;;   "Constructor for ast.KeyValueExpr"
;;   {:added "1.0"
;;    :go "_ConstructKeyValueExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.LabeledStmt from go/ast/ast.go:
;; (defn ^"GoObject" LabeledStmt.
;;   "Constructor for ast.LabeledStmt"
;;   {:added "1.0"
;;    :go "_ConstructLabeledStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.MapType from go/ast/ast.go:
;; (defn ^"GoObject" MapType.
;;   "Constructor for ast.MapType"
;;   {:added "1.0"
;;    :go "_ConstructMapType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.MergeMode from go/ast/filter.go:
(defn ^"GoObject" MergeMode.
  "Constructor for ast.MergeMode"
  {:added "1.0"
   :go "_ConstructMergeMode(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Node from go/ast/ast.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for ast.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ObjKind from go/ast/scope.go:
(defn ^"GoObject" ObjKind.
  "Constructor for ast.ObjKind"
  {:added "1.0"
   :go "_ConstructObjKind(_v)"}
  [^Object _v])

JOKER TYPE go/ast.Object from go/ast/scope.go:
;; (defn ^"GoObject" Object.
;;   "Constructor for ast.Object"
;;   {:added "1.0"
;;    :go "_ConstructObject(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Package from go/ast/ast.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for ast.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ParenExpr from go/ast/ast.go:
;; (defn ^"GoObject" ParenExpr.
;;   "Constructor for ast.ParenExpr"
;;   {:added "1.0"
;;    :go "_ConstructParenExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.RangeStmt from go/ast/ast.go:
;; (defn ^"GoObject" RangeStmt.
;;   "Constructor for ast.RangeStmt"
;;   {:added "1.0"
;;    :go "_ConstructRangeStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ReturnStmt from go/ast/ast.go:
;; (defn ^"GoObject" ReturnStmt.
;;   "Constructor for ast.ReturnStmt"
;;   {:added "1.0"
;;    :go "_ConstructReturnStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Scope from go/ast/scope.go:
;; (defn ^"GoObject" Scope.
;;   "Constructor for ast.Scope"
;;   {:added "1.0"
;;    :go "_ConstructScope(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SelectStmt from go/ast/ast.go:
;; (defn ^"GoObject" SelectStmt.
;;   "Constructor for ast.SelectStmt"
;;   {:added "1.0"
;;    :go "_ConstructSelectStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SelectorExpr from go/ast/ast.go:
;; (defn ^"GoObject" SelectorExpr.
;;   "Constructor for ast.SelectorExpr"
;;   {:added "1.0"
;;    :go "_ConstructSelectorExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SendStmt from go/ast/ast.go:
;; (defn ^"GoObject" SendStmt.
;;   "Constructor for ast.SendStmt"
;;   {:added "1.0"
;;    :go "_ConstructSendStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SliceExpr from go/ast/ast.go:
;; (defn ^"GoObject" SliceExpr.
;;   "Constructor for ast.SliceExpr"
;;   {:added "1.0"
;;    :go "_ConstructSliceExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Spec from go/ast/ast.go:
;; (defn ^"GoObject" Spec.
;;   "Constructor for ast.Spec"
;;   {:added "1.0"
;;    :go "_ConstructSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StarExpr from go/ast/ast.go:
;; (defn ^"GoObject" StarExpr.
;;   "Constructor for ast.StarExpr"
;;   {:added "1.0"
;;    :go "_ConstructStarExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Stmt from go/ast/ast.go:
;; (defn ^"GoObject" Stmt.
;;   "Constructor for ast.Stmt"
;;   {:added "1.0"
;;    :go "_ConstructStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.StructType from go/ast/ast.go:
;; (defn ^"GoObject" StructType.
;;   "Constructor for ast.StructType"
;;   {:added "1.0"
;;    :go "_ConstructStructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.SwitchStmt from go/ast/ast.go:
;; (defn ^"GoObject" SwitchStmt.
;;   "Constructor for ast.SwitchStmt"
;;   {:added "1.0"
;;    :go "_ConstructSwitchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeAssertExpr from go/ast/ast.go:
;; (defn ^"GoObject" TypeAssertExpr.
;;   "Constructor for ast.TypeAssertExpr"
;;   {:added "1.0"
;;    :go "_ConstructTypeAssertExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeSpec from go/ast/ast.go:
;; (defn ^"GoObject" TypeSpec.
;;   "Constructor for ast.TypeSpec"
;;   {:added "1.0"
;;    :go "_ConstructTypeSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.TypeSwitchStmt from go/ast/ast.go:
;; (defn ^"GoObject" TypeSwitchStmt.
;;   "Constructor for ast.TypeSwitchStmt"
;;   {:added "1.0"
;;    :go "_ConstructTypeSwitchStmt(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.UnaryExpr from go/ast/ast.go:
;; (defn ^"GoObject" UnaryExpr.
;;   "Constructor for ast.UnaryExpr"
;;   {:added "1.0"
;;    :go "_ConstructUnaryExpr(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.ValueSpec from go/ast/ast.go:
;; (defn ^"GoObject" ValueSpec.
;;   "Constructor for ast.ValueSpec"
;;   {:added "1.0"
;;    :go "_ConstructValueSpec(_v)"}
;;   [^Object _v])

JOKER TYPE go/ast.Visitor from go/ast/walk.go:
;; (defn ^"GoObject" Visitor.
;;   "Constructor for ast.Visitor"
;;   {:added "1.0"
;;    :go "_ConstructVisitor(_v)"}
;;   [^Object _v])

JOKER FUNC go/ast.FileExports from go/ast/filter.go:
(defn ^"Boolean" FileExports
  "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo input arguments: (src *File)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FileExports(src)"}
  [^ast/File src])

JOKER FUNC go/ast.FilterDecl from go/ast/filter.go:
(defn ^"Boolean" FilterDecl
  "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo input arguments: (decl Decl, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.ast/Decl decl, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterDecl(*decl, *f)"}
  [^ast/Decl decl, ^ast/Filter f])

JOKER FUNC go/ast.FilterFile from go/ast/filter.go:
(defn ^"Boolean" FilterFile
  "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (src *File, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/File) src, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterFile(src, *f)"}
  [^ast/File src, ^ast/Filter f])

JOKER FUNC go/ast.FilterPackage from go/ast/filter.go:
(defn ^"Boolean" FilterPackage
  "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (pkg *Package, f Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/Filter f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.FilterPackage(pkg, *f)"}
  [^ast/Package pkg, ^ast/Filter f])

JOKER FUNC go/ast.Fprint from go/ast/print.go:
;; (defn ^"Error" Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo input arguments: (w io.Writer, fset *token.FileSet, x interface {}, f FieldFilter)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x, ^go.std.go.ast/FieldFilter f]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(*w, fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *f)"}
;;   [^io/Writer w, ^token/FileSet fset, ^<protocol-or-something> x, ^ast/FieldFilter f])

JOKER FUNC go/ast.Inspect from go/ast/walk.go:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n\nGo input arguments: (node Node, f func)\n\nJoker input arguments: [^go.std.go.ast/Node node, ^fn f]"
;;   {:added "1.0"
;;    :go "__inspect(*node, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^ast/Node node, ^fn f])

JOKER FUNC go/ast.IsExported from go/ast/ast.go:
(defn ^"Boolean" IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo input arguments: (name string)\n\nGo return type: bool\n\nJoker input arguments: [^String name]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.IsExported(name)"}
  [^String name])

JOKER FUNC go/ast.MergePackageFiles from go/ast/filter.go:
(defn MergePackageFiles
  "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo input arguments: (pkg *Package, mode MergeMode)\n\nGo return type: *File\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^go.std.go.ast/MergeMode mode]\n\nJoker return type: (atom-of go.std.go.ast/File)"
  {:added "1.0"
   :go "__mergePackageFiles(pkg, *mode)"}
  [^ast/Package pkg, ^ast/MergeMode mode])

JOKER FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo input arguments: (fset *token.FileSet, node Node, comments []*CommentGroup)\n\nGo return type: CommentMap\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^go.std.go.ast/Node node, ^(vector-of (atom-of go.std.go.ast/CommentGroup)) comments]\n\nJoker return type: go.std.go.ast/CommentMap"
;;   {:added "1.0"
;;    :go "__newCommentMap(fset, *node, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_ast.CommentGroup(comments)))"}
;;   [^token/FileSet fset, ^ast/Node node, ^Object comments])

JOKER FUNC go/ast.NewIdent from go/ast/ast.go:
(defn NewIdent
  "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo input arguments: (name string)\n\nGo return type: *Ident\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.go.ast/Ident)"
  {:added "1.0"
   :go "__newIdent(name)"}
  [^String name])

JOKER FUNC go/ast.NewObj from go/ast/scope.go:
(defn NewObj
  "NewObj creates a new object of a given kind and name.\n\nGo input arguments: (kind ObjKind, name string)\n\nGo return type: *Object\n\nJoker input arguments: [^go.std.go.ast/ObjKind kind, ^String name]\n\nJoker return type: (atom-of go.std.go.ast/Object)"
  {:added "1.0"
   :go "__newObj(*kind, name)"}
  [^ast/ObjKind kind, ^String name])

JOKER FUNC go/ast.NewPackage from go/ast/resolve.go:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo input arguments: (fset *token.FileSet, files map[], importer Importer, universe *Scope)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^{} files, ^go.std.go.ast/Importer importer, ^(atom-of go.std.go.ast/Scope) universe]\n\nJoker return type: [(atom-of go.std.go.ast/Package) Error]"
;;   {:added "1.0"
;;    :go "__newPackage(fset, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()), *importer, universe)"}
;;   [^token/FileSet fset, ^{} files, ^ast/Importer importer, ^ast/Scope universe])

JOKER FUNC go/ast.NewScope from go/ast/scope.go:
(defn NewScope
  "NewScope creates a new scope nested in the outer scope.\n\nGo input arguments: (outer *Scope)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.ast/Scope) outer]\n\nJoker return type: (atom-of go.std.go.ast/Scope)"
  {:added "1.0"
   :go "__newScope(outer)"}
  [^ast/Scope outer])

JOKER FUNC go/ast.NotNilFilter from go/ast/print.go:
;; (defn ^"Boolean" NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo input arguments: (_ string, v reflect.Value)\n\nGo return type: bool\n\nJoker input arguments: [^String _, ^go.std.reflect/Value v]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(_, *v)"}
;;   [^String _, ^reflect/Value v])

JOKER FUNC go/ast.PackageExports from go/ast/filter.go:
(defn ^"Boolean" PackageExports
  "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo input arguments: (pkg *Package)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "ast.PackageExports(pkg)"}
  [^ast/Package pkg])

JOKER FUNC go/ast.Print from go/ast/print.go:
;; (defn ^"Error" Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo input arguments: (fset *token.FileSet, x interface {})\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> x]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^token/FileSet fset, ^<protocol-or-something> x])

JOKER FUNC go/ast.SortImports from go/ast/import.go:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n\nGo input arguments: (fset *token.FileSet, f *File)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.ast/File) f]"
;;   {:added "1.0"
;;    :go "__sortImports(fset, f)"}
;;   [^token/FileSet fset, ^ast/File f])

JOKER FUNC go/ast.Walk from go/ast/walk.go:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n\nGo input arguments: (v Visitor, node Node)\n\nJoker input arguments: [^go.std.go.ast/Visitor v, ^go.std.go.ast/Node node]"
;;   {:added "1.0"
;;    :go "__walk(*v, *node)"}
;;   [^ast/Visitor v, ^ast/Node node])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/ast"]
    :doc "Provides a low-level interface to the go/ast package."
    :empty false}
  go.std.go.ast)
JOKER TYPE go/build.Context from go/build/build.go:
;; (defn ^"GoObject" Context.
;;   "Constructor for build.Context"
;;   {:added "1.0"
;;    :go "_ConstructContext(_v)"}
;;   [^Object _v])

JOKER TYPE go/build.ImportMode from go/build/build.go:
(defn ^"GoObject" ImportMode.
  "Constructor for build.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/build.MultiplePackageError from go/build/build.go:
;; (defn ^"GoObject" MultiplePackageError.
;;   "Constructor for build.MultiplePackageError"
;;   {:added "1.0"
;;    :go "_ConstructMultiplePackageError(_v)"}
;;   [^Object _v])

JOKER TYPE go/build.NoGoError from go/build/build.go:
(defn ^"GoObject" NoGoError.
  "Constructor for build.NoGoError"
  {:added "1.0"
   :go "_ConstructNoGoError(_v)"}
  [^Object _v])

JOKER TYPE go/build.Package from go/build/build.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for build.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER FUNC go/build.ArchChar from go/build/build.go:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo input arguments: (goarch string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String goarch]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__archChar(goarch)"}
  [^String goarch])

JOKER FUNC go/build.Import from go/build/build.go:
(defn Import
  "Import is shorthand for Default.Import.\n\nGo input arguments: (path string, srcDir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String path, ^String srcDir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__import(path, srcDir, *mode)"}
  [^String path, ^String srcDir, ^build/ImportMode mode])

JOKER FUNC go/build.ImportDir from go/build/build.go:
(defn ImportDir
  "ImportDir is shorthand for Default.ImportDir.\n\nGo input arguments: (dir string, mode ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String dir, ^go.std.go.build/ImportMode mode]\n\nJoker return type: [(atom-of go.std.go.build/Package) Error]"
  {:added "1.0"
   :go "__importDir(dir, *mode)"}
  [^String dir, ^build/ImportMode mode])

JOKER FUNC go/build.IsLocalImport from go/build/build.go:
(defn ^"Boolean" IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "build.IsLocalImport(path)"}
  [^String path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/build"]
    :doc "Provides a low-level interface to the go/build package."
    :empty false}
  go.std.go.build)
JOKER TYPE go/constant.Kind from go/constant/value.go:
(defn ^"GoObject" Kind.
  "Constructor for constant.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE go/constant.Value from go/constant/value.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for constant.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC go/constant.BinaryOp from go/constant/value.go:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__binaryOp(*x_, *op, *y_)"}
;;   [^constant/Value x_, ^token/Token op, ^constant/Value y_])

JOKER FUNC go/constant.BitLen from go/constant/value.go:
(defn ^"Int" BitLen
  "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.BitLen(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.BoolVal from go/constant/value.go:
(defn ^"Boolean" BoolVal
  "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo input arguments: (x Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "constant.BoolVal(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Bytes from go/constant/value.go:
(defn Bytes
  "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo input arguments: (x Value)\n\nGo return type: []byte\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__bytes(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Compare from go/constant/value.go:
;; (defn ^"Boolean" Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo input arguments: (x_ Value, op token.Token, y_ Value)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.constant/Value x_, ^go.std.go.token/Token op, ^go.std.go.constant/Value y_]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "constant.Compare(*x_, *op, *y_)"}
;;   [^constant/Value x_, ^token/Token op, ^constant/Value y_])

JOKER FUNC go/constant.Denom from go/constant/value.go:
(defn Denom
  "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__denom(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Float32Val from go/constant/value.go:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo input arguments: (x Value)\n\nGo return type: (float32, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Double Boolean]"
;;   {:added "1.0"
;;    :go "__float32Val(*x)"}
;;   [^constant/Value x])

JOKER FUNC go/constant.Float64Val from go/constant/value.go:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (float64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Double Boolean]"
;;   {:added "1.0"
;;    :go "__float64Val(*x)"}
;;   [^constant/Value x])

JOKER FUNC go/constant.Imag from go/constant/value.go:
(defn Imag
  "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__imag(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Int64Val from go/constant/value.go:
(defn Int64Val
  "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (int64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Number Boolean]"
  {:added "1.0"
   :go "__int64Val(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.MakeBool from go/constant/value.go:
(defn MakeBool
  "MakeBool returns the Bool value for b.\n\nGo input arguments: (b bool)\n\nGo return type: Value\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeBool(b)"}
  [^Boolean b])

JOKER FUNC go/constant.MakeFloat64 from go/constant/value.go:
(defn MakeFloat64
  "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo input arguments: (x float64)\n\nGo return type: Value\n\nJoker input arguments: [^Double x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeFloat64(x)"}
  [^Double x])

JOKER FUNC go/constant.MakeFromBytes from go/constant/value.go:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo input arguments: (bytes []byte)\n\nGo return type: Value\n\nJoker input arguments: [^(vector-of Int) bytes]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(bytes)))"}
;;   [^Object bytes])

JOKER FUNC go/constant.MakeFromLiteral from go/constant/value.go:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo input arguments: (lit string, tok token.Token, zero uint)\n\nGo return type: Value\n\nJoker input arguments: [^String lit, ^go.std.go.token/Token tok, ^Number zero]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__makeFromLiteral(lit, *tok, zero)"}
;;   [^String lit, ^token/Token tok, ^Number zero])

JOKER FUNC go/constant.MakeImag from go/constant/value.go:
(defn MakeImag
  "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeImag(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.MakeInt64 from go/constant/value.go:
(defn MakeInt64
  "MakeInt64 returns the Int value for x.\n\nGo input arguments: (x int64)\n\nGo return type: Value\n\nJoker input arguments: [^Number x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeInt64(x)"}
  [^Number x])

JOKER FUNC go/constant.MakeString from go/constant/value.go:
(defn MakeString
  "MakeString returns the String value for s.\n\nGo input arguments: (s string)\n\nGo return type: Value\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeString(s)"}
  [^String s])

JOKER FUNC go/constant.MakeUint64 from go/constant/value.go:
(defn MakeUint64
  "MakeUint64 returns the Int value for x.\n\nGo input arguments: (x uint64)\n\nGo return type: Value\n\nJoker input arguments: [^Number x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeUint64(x)"}
  [^Number x])

JOKER FUNC go/constant.MakeUnknown from go/constant/value.go:
(defn MakeUnknown
  "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker input arguments: []\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__makeUnknown()"}
  [])

JOKER FUNC go/constant.Num from go/constant/value.go:
(defn Num
  "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__num(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Real from go/constant/value.go:
(defn Real
  "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__real(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Shift from go/constant/value.go:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo input arguments: (x Value, op token.Token, s uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x, ^go.std.go.token/Token op, ^Number s]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__shift(*x, *op, s)"}
;;   [^constant/Value x, ^token/Token op, ^Number s])

JOKER FUNC go/constant.Sign from go/constant/value.go:
(defn ^"Int" Sign
  "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo input arguments: (x Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "constant.Sign(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.StringVal from go/constant/value.go:
(defn ^"String" StringVal
  "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo input arguments: (x Value)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: String"
  {:added "1.0"
   :go "constant.StringVal(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.ToComplex from go/constant/value.go:
(defn ToComplex
  "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toComplex(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.ToFloat from go/constant/value.go:
(defn ToFloat
  "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toFloat(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.ToInt from go/constant/value.go:
(defn ToInt
  "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: go.std.go.constant/Value"
  {:added "1.0"
   :go "__toInt(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.Uint64Val from go/constant/value.go:
(defn Uint64Val
  "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x Value)\n\nGo return type: (uint64, bool)\n\nJoker input arguments: [^go.std.go.constant/Value x]\n\nJoker return type: [Number Boolean]"
  {:added "1.0"
   :go "__uint64Val(*x)"}
  [^constant/Value x])

JOKER FUNC go/constant.UnaryOp from go/constant/value.go:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo input arguments: (op token.Token, y Value, prec uint)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.go.token/Token op, ^go.std.go.constant/Value y, ^Number prec]\n\nJoker return type: go.std.go.constant/Value"
;;   {:added "1.0"
;;    :go "__unaryOp(*op, *y, prec)"}
;;   [^token/Token op, ^constant/Value y, ^Number prec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/constant"]
    :doc "Provides a low-level interface to the go/constant package."
    :empty false}
  go.std.go.constant)
JOKER TYPE go/doc.Example from go/doc/example.go:
;; (defn ^"GoObject" Example.
;;   "Constructor for doc.Example"
;;   {:added "1.0"
;;    :go "_ConstructExample(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Filter from go/doc/filter.go:
;; (defn ^"GoObject" Filter.
;;   "Constructor for doc.Filter"
;;   {:added "1.0"
;;    :go "_ConstructFilter(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Func from go/doc/doc.go:
;; (defn ^"GoObject" Func.
;;   "Constructor for doc.Func"
;;   {:added "1.0"
;;    :go "_ConstructFunc(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Mode from go/doc/doc.go:
(defn ^"GoObject" Mode.
  "Constructor for doc.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER TYPE go/doc.Note from go/doc/doc.go:
;; (defn ^"GoObject" Note.
;;   "Constructor for doc.Note"
;;   {:added "1.0"
;;    :go "_ConstructNote(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Package from go/doc/doc.go:
;; (defn ^"GoObject" Package.
;;   "Constructor for doc.Package"
;;   {:added "1.0"
;;    :go "_ConstructPackage(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Type from go/doc/doc.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for doc.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/doc.Value from go/doc/doc.go:
;; (defn ^"GoObject" Value.
;;   "Constructor for doc.Value"
;;   {:added "1.0"
;;    :go "_ConstructValue(_v)"}
;;   [^Object _v])

JOKER FUNC go/doc.Examples from go/doc/example.go:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo input arguments: (files ...*ast.File)\n\nGo return type: []*Example\n\nJoker input arguments: [^(ellipsis-somehow ast/File) files]\n\nJoker return type: (vector-of (atom-of go.std.go.doc/Example))"
;;   {:added "1.0"
;;    :go "__examples(ConvertToEllipsisHaHa*ABEND987(genutils.go: imports not yet supported: ast.File)(files))"}
;;   [^ast/File files])

JOKER FUNC go/doc.IsPredeclared from go/doc/reader.go:
(defn ^"Boolean" IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "doc.IsPredeclared(s)"}
  [^String s])

JOKER FUNC go/doc.New from go/doc/doc.go:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo input arguments: (pkg *ast.Package, importPath string, mode Mode)\n\nGo return type: *Package\n\nJoker input arguments: [^(atom-of go.std.go.ast/Package) pkg, ^String importPath, ^go.std.go.doc/Mode mode]\n\nJoker return type: (atom-of go.std.go.doc/Package)"
;;   {:added "1.0"
;;    :go "__new(pkg, importPath, *mode)"}
;;   [^ast/Package pkg, ^String importPath, ^doc/Mode mode])

JOKER FUNC go/doc.Synopsis from go/doc/synopsis.go:
(defn ^"String" Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(s)"}
  [^String s])

JOKER FUNC go/doc.ToHTML from go/doc/comment.go:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n\nGo input arguments: (w io.Writer, text string, words map[])\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^{} words]"
;;   {:added "1.0"
;;    :go "__toHTML(*w, text, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^io/Writer w, ^String text, ^{} words])

JOKER FUNC go/doc.ToText from go/doc/comment.go:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n\nGo input arguments: (w io.Writer, text string, indent string, preIndent string, width int)\n\nJoker input arguments: [^go.std.io/Writer w, ^String text, ^String indent, ^String preIndent, ^Int width]"
;;   {:added "1.0"
;;    :go "__toText(*w, text, indent, preIndent, width)"}
;;   [^io/Writer w, ^String text, ^String indent, ^String preIndent, ^Int width])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/doc"]
    :doc "Provides a low-level interface to the go/doc package."
    :empty false}
  go.std.go.doc)
JOKER FUNC go/format.Node from go/format/format.go:
;; (defn ^"Error" Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo input arguments: (dst io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer dst, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(*dst, fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer dst, ^token/FileSet fset, ^<protocol-or-something> node])

JOKER FUNC go/format.Source from go/format/format.go:
;; (defn Source
;;   "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo input arguments: (src []byte)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(vector-of Int) src]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__source(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))"}
;;   [^Object src])

JOKER TYPE go/importer.Lookup from go/importer/importer.go:
;; (defn ^"GoObject" Lookup.
;;   "Constructor for importer.Lookup"
;;   {:added "1.0"
;;    :go "_ConstructLookup(_v)"}
;;   [^Object _v])

JOKER FUNC go/importer.Default from go/importer/importer.go:
(defn Default
  "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: go/types.Importer\n\nJoker input arguments: []\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__default()"}
  [])

JOKER FUNC go/importer.For from go/importer/importer.go:
(defn For
  "For calls ForCompiler with a new FileSet.\n\nDeprecated: use ForCompiler, which populates a FileSet\nwith the positions of objects created by the importer.\n\nGo input arguments: (compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
  {:added "1.0"
   :go "__for(compiler, *lookup)"}
  [^String compiler, ^importer/Lookup lookup])

JOKER FUNC go/importer.ForCompiler from go/importer/importer.go:
;; (defn ForCompiler
;;   "ForCompiler returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo input arguments: (fset *token.FileSet, compiler string, lookup Lookup)\n\nGo return type: go/types.Importer\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String compiler, ^go.std.go.importer/Lookup lookup]\n\nJoker return type: go.std.go.types/Importer"
;;   {:added "1.0"
;;    :go "__forCompiler(fset, compiler, *lookup)"}
;;   [^token/FileSet fset, ^String compiler, ^importer/Lookup lookup])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/importer package."
    :empty false}
  go.std.go.importer)
JOKER TYPE go/parser.Mode from go/parser/interface.go:
(defn ^"GoObject" Mode.
  "Constructor for parser.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER FUNC go/parser.ParseDir from go/parser/interface.go:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo input arguments: (fset *token.FileSet, path string, filter func, mode Mode)\n\nGo return type: (pkgs ..., first error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String path, ^fn filter, ^go.std.go.parser/Mode mode]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "__parseDir(fset, path, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), *mode)"}
;;   [^token/FileSet fset, ^String path, ^fn filter, ^parser/Mode mode])

JOKER FUNC go/parser.ParseExpr from go/parser/interface.go:
(defn ParseExpr
  "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo input arguments: (x string)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^String x]\n\nJoker return type: [go.std.go.ast/Expr Error]"
  {:added "1.0"
   :go "__parseExpr(x)"}
  [^String x])

JOKER FUNC go/parser.ParseExprFrom from go/parser/interface.go:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (go/ast.Expr, error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [go.std.go.ast/Expr Error]"
;;   {:added "1.0"
;;    :go "__parseExprFrom(fset, filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *mode)"}
;;   [^token/FileSet fset, ^String filename, ^<protocol-or-something> src, ^parser/Mode mode])

JOKER FUNC go/parser.ParseFile from go/parser/interface.go:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo input arguments: (fset *token.FileSet, filename string, src interface {}, mode Mode)\n\nGo return type: (f *go/ast.File, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go.std.go.parser/Mode mode]\n\nJoker return type: [(atom-of go.std.go.ast/File) Error]"
;;   {:added "1.0"
;;    :go "__parseFile(fset, filename, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *mode)"}
;;   [^token/FileSet fset, ^String filename, ^<protocol-or-something> src, ^parser/Mode mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/parser package."
    :empty false}
  go.std.go.parser)
JOKER FUNC go/printer.Fprint from go/printer/printer.go:
;; (defn ^"Error" Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo input arguments: (output io.Writer, fset *token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer output, ^(atom-of go.std.go.token/FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(*output, fset, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io/Writer output, ^token/FileSet fset, ^<protocol-or-something> node])

JOKER TYPE go/scanner.Error from go/scanner/errors.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for scanner.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.ErrorHandler from go/scanner/scanner.go:
;; (defn ^"GoObject" ErrorHandler.
;;   "Constructor for scanner.ErrorHandler"
;;   {:added "1.0"
;;    :go "_ConstructErrorHandler(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.ErrorList from go/scanner/errors.go:
;; (defn ^"GoObject" ErrorList.
;;   "Constructor for scanner.ErrorList"
;;   {:added "1.0"
;;    :go "_ConstructErrorList(_v)"}
;;   [^Object _v])

JOKER TYPE go/scanner.Mode from go/scanner/scanner.go:
(defn ^"GoObject" Mode.
  "Constructor for scanner.Mode"
  {:added "1.0"
   :go "_ConstructMode(_v)"}
  [^Object _v])

JOKER TYPE go/scanner.Scanner from go/scanner/scanner.go:
(defn ^"GoObject" Scanner.
  "Constructor for scanner.Scanner"
  {:added "1.0"
   :go "_ConstructScanner(_v)"}
  [^Object _v])

JOKER FUNC go/scanner.PrintError from go/scanner/errors.go:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n\nGo input arguments: (w io.Writer, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^Error err]"
;;   {:added "1.0"
;;    :go "__printError(*w, err)"}
;;   [^io/Writer w, ^Error err])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/scanner package."
    :empty false}
  go.std.go.scanner)
JOKER TYPE go/token.File from go/token/position.go:
(defn ^"GoObject" File.
  "Constructor for token.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE go/token.FileSet from go/token/position.go:
(defn ^"GoObject" FileSet.
  "Constructor for token.FileSet"
  {:added "1.0"
   :go "_ConstructFileSet(_v)"}
  [^Object _v])

JOKER TYPE go/token.Pos from go/token/position.go:
(defn ^"GoObject" Pos.
  "Constructor for token.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE go/token.Position from go/token/position.go:
(defn ^"GoObject" Position.
  "Constructor for token.Position"
  {:added "1.0"
   :go "_ConstructPosition(_v)"}
  [^Object _v])

JOKER TYPE go/token.Token from go/token/token.go:
(defn ^"GoObject" Token.
  "Constructor for token.Token"
  {:added "1.0"
   :go "_ConstructToken(_v)"}
  [^Object _v])

JOKER FUNC go/token.Lookup from go/token/token.go:
(defn Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo input arguments: (ident string)\n\nGo return type: Token\n\nJoker input arguments: [^String ident]\n\nJoker return type: go.std.go.token/Token"
  {:added "1.0"
   :go "__lookup(ident)"}
  [^String ident])

JOKER FUNC go/token.NewFileSet from go/token/position.go:
(defn NewFileSet
  "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.go.token/FileSet)"
  {:added "1.0"
   :go "__newFileSet()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the go/token package."
    :empty false}
  go.std.go.token)
JOKER TYPE go/types.Array from go/types/type.go:
(defn ^"GoObject" Array.
  "Constructor for types.Array"
  {:added "1.0"
   :go "_ConstructArray(_v)"}
  [^Object _v])

JOKER TYPE go/types.Basic from go/types/type.go:
(defn ^"GoObject" Basic.
  "Constructor for types.Basic"
  {:added "1.0"
   :go "_ConstructBasic(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicInfo from go/types/type.go:
(defn ^"GoObject" BasicInfo.
  "Constructor for types.BasicInfo"
  {:added "1.0"
   :go "_ConstructBasicInfo(_v)"}
  [^Object _v])

JOKER TYPE go/types.BasicKind from go/types/type.go:
(defn ^"GoObject" BasicKind.
  "Constructor for types.BasicKind"
  {:added "1.0"
   :go "_ConstructBasicKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Builtin from go/types/object.go:
(defn ^"GoObject" Builtin.
  "Constructor for types.Builtin"
  {:added "1.0"
   :go "_ConstructBuiltin(_v)"}
  [^Object _v])

JOKER TYPE go/types.Chan from go/types/type.go:
(defn ^"GoObject" Chan.
  "Constructor for types.Chan"
  {:added "1.0"
   :go "_ConstructChan(_v)"}
  [^Object _v])

JOKER TYPE go/types.ChanDir from go/types/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for types.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE go/types.Checker from go/types/check.go:
(defn ^"GoObject" Checker.
  "Constructor for types.Checker"
  {:added "1.0"
   :go "_ConstructChecker(_v)"}
  [^Object _v])

JOKER TYPE go/types.Config from go/types/api.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for types.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Const from go/types/object.go:
(defn ^"GoObject" Const.
  "Constructor for types.Const"
  {:added "1.0"
   :go "_ConstructConst(_v)"}
  [^Object _v])

JOKER TYPE go/types.Error from go/types/api.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for types.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Func from go/types/object.go:
(defn ^"GoObject" Func.
  "Constructor for types.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE go/types.ImportMode from go/types/api.go:
(defn ^"GoObject" ImportMode.
  "Constructor for types.ImportMode"
  {:added "1.0"
   :go "_ConstructImportMode(_v)"}
  [^Object _v])

JOKER TYPE go/types.Importer from go/types/api.go:
;; (defn ^"GoObject" Importer.
;;   "Constructor for types.Importer"
;;   {:added "1.0"
;;    :go "_ConstructImporter(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.ImporterFrom from go/types/api.go:
;; (defn ^"GoObject" ImporterFrom.
;;   "Constructor for types.ImporterFrom"
;;   {:added "1.0"
;;    :go "_ConstructImporterFrom(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Info from go/types/api.go:
;; (defn ^"GoObject" Info.
;;   "Constructor for types.Info"
;;   {:added "1.0"
;;    :go "_ConstructInfo(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Initializer from go/types/api.go:
;; (defn ^"GoObject" Initializer.
;;   "Constructor for types.Initializer"
;;   {:added "1.0"
;;    :go "_ConstructInitializer(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Interface from go/types/type.go:
(defn ^"GoObject" Interface.
  "Constructor for types.Interface"
  {:added "1.0"
   :go "_ConstructInterface(_v)"}
  [^Object _v])

JOKER TYPE go/types.Label from go/types/object.go:
(defn ^"GoObject" Label.
  "Constructor for types.Label"
  {:added "1.0"
   :go "_ConstructLabel(_v)"}
  [^Object _v])

JOKER TYPE go/types.Map from go/types/type.go:
(defn ^"GoObject" Map.
  "Constructor for types.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE go/types.MethodSet from go/types/methodset.go:
(defn ^"GoObject" MethodSet.
  "Constructor for types.MethodSet"
  {:added "1.0"
   :go "_ConstructMethodSet(_v)"}
  [^Object _v])

JOKER TYPE go/types.Named from go/types/type.go:
(defn ^"GoObject" Named.
  "Constructor for types.Named"
  {:added "1.0"
   :go "_ConstructNamed(_v)"}
  [^Object _v])

JOKER TYPE go/types.Nil from go/types/object.go:
(defn ^"GoObject" Nil.
  "Constructor for types.Nil"
  {:added "1.0"
   :go "_ConstructNil(_v)"}
  [^Object _v])

JOKER TYPE go/types.Object from go/types/object.go:
;; (defn ^"GoObject" Object.
;;   "Constructor for types.Object"
;;   {:added "1.0"
;;    :go "_ConstructObject(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Package from go/types/package.go:
(defn ^"GoObject" Package.
  "Constructor for types.Package"
  {:added "1.0"
   :go "_ConstructPackage(_v)"}
  [^Object _v])

JOKER TYPE go/types.PkgName from go/types/object.go:
(defn ^"GoObject" PkgName.
  "Constructor for types.PkgName"
  {:added "1.0"
   :go "_ConstructPkgName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Pointer from go/types/type.go:
(defn ^"GoObject" Pointer.
  "Constructor for types.Pointer"
  {:added "1.0"
   :go "_ConstructPointer(_v)"}
  [^Object _v])

JOKER TYPE go/types.Qualifier from go/types/typestring.go:
;; (defn ^"GoObject" Qualifier.
;;   "Constructor for types.Qualifier"
;;   {:added "1.0"
;;    :go "_ConstructQualifier(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Scope from go/types/scope.go:
(defn ^"GoObject" Scope.
  "Constructor for types.Scope"
  {:added "1.0"
   :go "_ConstructScope(_v)"}
  [^Object _v])

JOKER TYPE go/types.Selection from go/types/selection.go:
(defn ^"GoObject" Selection.
  "Constructor for types.Selection"
  {:added "1.0"
   :go "_ConstructSelection(_v)"}
  [^Object _v])

JOKER TYPE go/types.SelectionKind from go/types/selection.go:
(defn ^"GoObject" SelectionKind.
  "Constructor for types.SelectionKind"
  {:added "1.0"
   :go "_ConstructSelectionKind(_v)"}
  [^Object _v])

JOKER TYPE go/types.Signature from go/types/type.go:
(defn ^"GoObject" Signature.
  "Constructor for types.Signature"
  {:added "1.0"
   :go "_ConstructSignature(_v)"}
  [^Object _v])

JOKER TYPE go/types.Sizes from go/types/sizes.go:
;; (defn ^"GoObject" Sizes.
;;   "Constructor for types.Sizes"
;;   {:added "1.0"
;;    :go "_ConstructSizes(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.Slice from go/types/type.go:
(defn ^"GoObject" Slice.
  "Constructor for types.Slice"
  {:added "1.0"
   :go "_ConstructSlice(_v)"}
  [^Object _v])

JOKER TYPE go/types.StdSizes from go/types/sizes.go:
(defn ^"GoObject" StdSizes.
  "Constructor for types.StdSizes"
  {:added "1.0"
   :go "_ConstructStdSizes(_v)"}
  [^Object _v])

JOKER TYPE go/types.Struct from go/types/type.go:
(defn ^"GoObject" Struct.
  "Constructor for types.Struct"
  {:added "1.0"
   :go "_ConstructStruct(_v)"}
  [^Object _v])

JOKER TYPE go/types.Tuple from go/types/type.go:
(defn ^"GoObject" Tuple.
  "Constructor for types.Tuple"
  {:added "1.0"
   :go "_ConstructTuple(_v)"}
  [^Object _v])

JOKER TYPE go/types.Type from go/types/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for types.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.TypeAndValue from go/types/api.go:
;; (defn ^"GoObject" TypeAndValue.
;;   "Constructor for types.TypeAndValue"
;;   {:added "1.0"
;;    :go "_ConstructTypeAndValue(_v)"}
;;   [^Object _v])

JOKER TYPE go/types.TypeName from go/types/object.go:
(defn ^"GoObject" TypeName.
  "Constructor for types.TypeName"
  {:added "1.0"
   :go "_ConstructTypeName(_v)"}
  [^Object _v])

JOKER TYPE go/types.Var from go/types/object.go:
(defn ^"GoObject" Var.
  "Constructor for types.Var"
  {:added "1.0"
   :go "_ConstructVar(_v)"}
  [^Object _v])

JOKER FUNC go/types.AssertableTo from go/types/api.go:
(defn ^"Boolean" AssertableTo
  "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo input arguments: (V *Interface, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.go.types/Interface) V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssertableTo(V, *T)"}
  [^types/Interface V, ^types/Type T])

JOKER FUNC go/types.AssignableTo from go/types/api.go:
(defn ^"Boolean" AssignableTo
  "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.AssignableTo(*V, *T)"}
  [^types/Type V, ^types/Type T])

JOKER FUNC go/types.Comparable from go/types/predicates.go:
(defn ^"Boolean" Comparable
  "Comparable reports whether values of type T are comparable.\n\nGo input arguments: (T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Comparable(*T)"}
  [^types/Type T])

JOKER FUNC go/types.ConvertibleTo from go/types/api.go:
(defn ^"Boolean" ConvertibleTo
  "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo input arguments: (V Type, T Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^go.std.go.types/Type T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.ConvertibleTo(*V, *T)"}
  [^types/Type V, ^types/Type T])

JOKER FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC go/types.Default from go/types/predicates.go:
(defn Default
  "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo input arguments: (typ Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: go.std.go.types/Type"
  {:added "1.0"
   :go "__default(*typ)"}
  [^types/Type typ])

JOKER FUNC go/types.Eval from go/types/eval.go:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo input arguments: (fset *token.FileSet, pkg *Package, pos token.Pos, expr string)\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker input arguments: [^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^go.std.go.token/Pos pos, ^String expr]\n\nJoker return type: [go.std.go.types/TypeAndValue Error]"
;;   {:added "1.0"
;;    :go "__eval(fset, pkg, *pos, expr)"}
;;   [^token/FileSet fset, ^types/Package pkg, ^token/Pos pos, ^String expr])

JOKER FUNC go/types.ExprString from go/types/exprstring.go:
;; (defn ^"String" ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (x ast.Expr)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.ast/Expr x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(*x)"}
;;   [^ast/Expr x])

JOKER FUNC go/types.Id from go/types/object.go:
(defn ^"String" Id
  "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo input arguments: (pkg *Package, name string)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.Id(pkg, name)"}
  [^types/Package pkg, ^String name])

JOKER FUNC go/types.Identical from go/types/predicates.go:
(defn ^"Boolean" Identical
  "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Identical(*x, *y)"}
  [^types/Type x, ^types/Type y])

JOKER FUNC go/types.IdenticalIgnoreTags from go/types/predicates.go:
(defn ^"Boolean" IdenticalIgnoreTags
  "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x Type, y Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type x, ^go.std.go.types/Type y]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IdenticalIgnoreTags(*x, *y)"}
  [^types/Type x, ^types/Type y])

JOKER FUNC go/types.Implements from go/types/api.go:
(defn ^"Boolean" Implements
  "Implements reports whether type V implements interface T.\n\nGo input arguments: (V Type, T *Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.Implements(*V, T)"}
  [^types/Type V, ^types/Interface T])

JOKER FUNC go/types.IsInterface from go/types/predicates.go:
(defn ^"Boolean" IsInterface
  "IsInterface reports whether typ is an interface type.\n\nGo input arguments: (typ Type)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.go.types/Type typ]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "types.IsInterface(*typ)"}
  [^types/Type typ])

JOKER FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
(defn LookupFieldOrMethod
  "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo input arguments: (T Type, addressable bool, pkg *Package, name string)\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker input arguments: [^go.std.go.types/Type T, ^Boolean addressable, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: [go.std.go.types/Object (vector-of Int) Boolean]"
  {:added "1.0"
   :go "__lookupFieldOrMethod(*T, addressable, pkg, name)"}
  [^types/Type T, ^Boolean addressable, ^types/Package pkg, ^String name])

JOKER FUNC go/types.MissingMethod from go/types/lookup.go:
(defn MissingMethod
  "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo input arguments: (V Type, T *Interface, static bool)\n\nGo return type: (method *Func, wrongType bool)\n\nJoker input arguments: [^go.std.go.types/Type V, ^(atom-of go.std.go.types/Interface) T, ^Boolean static]\n\nJoker return type: [(atom-of go.std.go.types/Func) Boolean]"
  {:added "1.0"
   :go "__missingMethod(*V, T, static)"}
  [^types/Type V, ^types/Interface T, ^Boolean static])

JOKER FUNC go/types.NewArray from go/types/type.go:
(defn NewArray
  "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo input arguments: (elem Type, len int64)\n\nGo return type: *Array\n\nJoker input arguments: [^go.std.go.types/Type elem, ^Number len]\n\nJoker return type: (atom-of go.std.go.types/Array)"
  {:added "1.0"
   :go "__newArray(*elem, len)"}
  [^types/Type elem, ^Number len])

JOKER FUNC go/types.NewChan from go/types/type.go:
(defn NewChan
  "NewChan returns a new channel type for the given direction and element type.\n\nGo input arguments: (dir ChanDir, elem Type)\n\nGo return type: *Chan\n\nJoker input arguments: [^go.std.go.types/ChanDir dir, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Chan)"
  {:added "1.0"
   :go "__newChan(*dir, *elem)"}
  [^types/ChanDir dir, ^types/Type elem])

JOKER FUNC go/types.NewChecker from go/types/check.go:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo input arguments: (conf *Config, fset *token.FileSet, pkg *Package, info *Info)\n\nGo return type: *Checker\n\nJoker input arguments: [^(atom-of go.std.go.types/Config) conf, ^(atom-of go.std.go.token/FileSet) fset, ^(atom-of go.std.go.types/Package) pkg, ^(atom-of go.std.go.types/Info) info]\n\nJoker return type: (atom-of go.std.go.types/Checker)"
;;   {:added "1.0"
;;    :go "__newChecker(conf, fset, pkg, info)"}
;;   [^types/Config conf, ^token/FileSet fset, ^types/Package pkg, ^types/Info info])

JOKER FUNC go/types.NewConst from go/types/object.go:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, val constant.Value)\n\nGo return type: *Const\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^go.std.go.constant/Value val]\n\nJoker return type: (atom-of go.std.go.types/Const)"
;;   {:added "1.0"
;;    :go "__newConst(*pos, pkg, name, *typ, *val)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Type typ, ^constant/Value val])

JOKER FUNC go/types.NewField from go/types/object.go:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type, embedded bool)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ, ^Boolean embedded]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newField(*pos, pkg, name, *typ, embedded)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Type typ, ^Boolean embedded])

JOKER FUNC go/types.NewFunc from go/types/object.go:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, sig *Signature)\n\nGo return type: *Func\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Signature) sig]\n\nJoker return type: (atom-of go.std.go.types/Func)"
;;   {:added "1.0"
;;    :go "__newFunc(*pos, pkg, name, sig)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Signature sig])

JOKER FUNC go/types.NewInterface from go/types/type.go:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo input arguments: (methods []*Func, embeddeds []*Named)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of (atom-of go.std.go.types/Named)) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterface(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Named(embeddeds)))"}
;;   [^Object methods, ^Object embeddeds])

JOKER FUNC go/types.NewInterfaceType from go/types/type.go:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo input arguments: (methods []*Func, embeddeds []Type)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Func)) methods, ^(vector-of go.std.go.types/Type) embeddeds]\n\nJoker return type: (atom-of go.std.go.types/Interface)"
;;   {:added "1.0"
;;    :go "__newInterfaceType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(methods)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_types.Type(*embeddeds)))"}
;;   [^Object methods, ^Object embeddeds])

JOKER FUNC go/types.NewLabel from go/types/object.go:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string)\n\nGo return type: *Label\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Label)"
;;   {:added "1.0"
;;    :go "__newLabel(*pos, pkg, name)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name])

JOKER FUNC go/types.NewMap from go/types/type.go:
(defn NewMap
  "NewMap returns a new map for the given key and element types.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: *Map\n\nJoker input arguments: [^go.std.go.types/Type key, ^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Map)"
  {:added "1.0"
   :go "__newMap(*key, *elem)"}
  [^types/Type key, ^types/Type elem])

JOKER FUNC go/types.NewMethodSet from go/types/methodset.go:
(defn NewMethodSet
  "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo input arguments: (T Type)\n\nGo return type: *MethodSet\n\nJoker input arguments: [^go.std.go.types/Type T]\n\nJoker return type: (atom-of go.std.go.types/MethodSet)"
  {:added "1.0"
   :go "__newMethodSet(*T)"}
  [^types/Type T])

JOKER FUNC go/types.NewNamed from go/types/type.go:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo input arguments: (obj *TypeName, underlying Type, methods []*Func)\n\nGo return type: *Named\n\nJoker input arguments: [^(atom-of go.std.go.types/TypeName) obj, ^go.std.go.types/Type underlying, ^(vector-of (atom-of go.std.go.types/Func)) methods]\n\nJoker return type: (atom-of go.std.go.types/Named)"
;;   {:added "1.0"
;;    :go "__newNamed(obj, *underlying, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Func(methods)))"}
;;   [^types/TypeName obj, ^types/Type underlying, ^Object methods])

JOKER FUNC go/types.NewPackage from go/types/package.go:
(defn NewPackage
  "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo input arguments: (path string, name string)\n\nGo return type: *Package\n\nJoker input arguments: [^String path, ^String name]\n\nJoker return type: (atom-of go.std.go.types/Package)"
  {:added "1.0"
   :go "__newPackage(path, name)"}
  [^String path, ^String name])

JOKER FUNC go/types.NewParam from go/types/object.go:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newParam(*pos, pkg, name, *typ)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Type typ])

JOKER FUNC go/types.NewPkgName from go/types/object.go:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, imported *Package)\n\nGo return type: *PkgName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^(atom-of go.std.go.types/Package) imported]\n\nJoker return type: (atom-of go.std.go.types/PkgName)"
;;   {:added "1.0"
;;    :go "__newPkgName(*pos, pkg, name, imported)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Package imported])

JOKER FUNC go/types.NewPointer from go/types/type.go:
(defn NewPointer
  "NewPointer returns a new pointer type for the given element (base) type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Pointer\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Pointer)"
  {:added "1.0"
   :go "__newPointer(*elem)"}
  [^types/Type elem])

JOKER FUNC go/types.NewScope from go/types/scope.go:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo input arguments: (parent *Scope, pos token.Pos, end token.Pos, comment string)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go.std.go.types/Scope) parent, ^go.std.go.token/Pos pos, ^go.std.go.token/Pos end, ^String comment]\n\nJoker return type: (atom-of go.std.go.types/Scope)"
;;   {:added "1.0"
;;    :go "__newScope(parent, *pos, *end, comment)"}
;;   [^types/Scope parent, ^token/Pos pos, ^token/Pos end, ^String comment])

JOKER FUNC go/types.NewSignature from go/types/type.go:
(defn NewSignature
  "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo input arguments: (recv *Var, params *Tuple, results *Tuple, variadic bool)\n\nGo return type: *Signature\n\nJoker input arguments: [^(atom-of go.std.go.types/Var) recv, ^(atom-of go.std.go.types/Tuple) params, ^(atom-of go.std.go.types/Tuple) results, ^Boolean variadic]\n\nJoker return type: (atom-of go.std.go.types/Signature)"
  {:added "1.0"
   :go "__newSignature(recv, params, results, variadic)"}
  [^types/Var recv, ^types/Tuple params, ^types/Tuple results, ^Boolean variadic])

JOKER FUNC go/types.NewSlice from go/types/type.go:
(defn NewSlice
  "NewSlice returns a new slice type for the given element type.\n\nGo input arguments: (elem Type)\n\nGo return type: *Slice\n\nJoker input arguments: [^go.std.go.types/Type elem]\n\nJoker return type: (atom-of go.std.go.types/Slice)"
  {:added "1.0"
   :go "__newSlice(*elem)"}
  [^types/Type elem])

JOKER FUNC go/types.NewStruct from go/types/type.go:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo input arguments: (fields []*Var, tags []string)\n\nGo return type: *Struct\n\nJoker input arguments: [^(vector-of (atom-of go.std.go.types/Var)) fields, ^(vector-of String) tags]\n\nJoker return type: (atom-of go.std.go.types/Struct)"
;;   {:added "1.0"
;;    :go "__newStruct(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Var(fields)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(tags)))"}
;;   [^Object fields, ^Object tags])

JOKER FUNC go/types.NewTuple from go/types/type.go:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo input arguments: (x ...*Var)\n\nGo return type: *Tuple\n\nJoker input arguments: [^(ellipsis-somehow types/Var) x]\n\nJoker return type: (atom-of go.std.go.types/Tuple)"
;;   {:added "1.0"
;;    :go "__newTuple(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_types.Var(x)))"}
;;   [^types/Var x])

JOKER FUNC go/types.NewTypeName from go/types/object.go:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *TypeName\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/TypeName)"
;;   {:added "1.0"
;;    :go "__newTypeName(*pos, pkg, name, *typ)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Type typ])

JOKER FUNC go/types.NewVar from go/types/object.go:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo input arguments: (pos token.Pos, pkg *Package, name string, typ Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go.std.go.token/Pos pos, ^(atom-of go.std.go.types/Package) pkg, ^String name, ^go.std.go.types/Type typ]\n\nJoker return type: (atom-of go.std.go.types/Var)"
;;   {:added "1.0"
;;    :go "__newVar(*pos, pkg, name, *typ)"}
;;   [^token/Pos pos, ^types/Package pkg, ^String name, ^types/Type typ])

JOKER FUNC go/types.ObjectString from go/types/object.go:
(defn ^"String" ObjectString
  "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (obj Object, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Object obj, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.ObjectString(*obj, *qf)"}
  [^types/Object obj, ^types/Qualifier qf])

JOKER FUNC go/types.RelativeTo from go/types/typestring.go:
(defn RelativeTo
  "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo input arguments: (pkg *Package)\n\nGo return type: Qualifier\n\nJoker input arguments: [^(atom-of go.std.go.types/Package) pkg]\n\nJoker return type: go.std.go.types/Qualifier"
  {:added "1.0"
   :go "__relativeTo(pkg)"}
  [^types/Package pkg])

JOKER FUNC go/types.SelectionString from go/types/selection.go:
(defn ^"String" SelectionString
  "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo input arguments: (s *Selection, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go.std.go.types/Selection) s, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.SelectionString(s, *qf)"}
  [^types/Selection s, ^types/Qualifier qf])

JOKER FUNC go/types.SizesFor from go/types/sizes.go:
(defn SizesFor
  "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"sparc64\", \"wasm\".\n\nGo input arguments: (compiler string, arch string)\n\nGo return type: Sizes\n\nJoker input arguments: [^String compiler, ^String arch]\n\nJoker return type: go.std.go.types/Sizes"
  {:added "1.0"
   :go "__sizesFor(compiler, arch)"}
  [^String compiler, ^String arch])

JOKER FUNC go/types.TypeString from go/types/typestring.go:
(defn ^"String" TypeString
  "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (typ Type, qf Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]\n\nJoker return type: String"
  {:added "1.0"
   :go "types.TypeString(*typ, *qf)"}
  [^types/Type typ, ^types/Qualifier qf])

JOKER FUNC go/types.WriteExpr from go/types/exprstring.go:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (buf *bytes.Buffer, x ast.Expr)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.ast/Expr x]"
;;   {:added "1.0"
;;    :go "__writeExpr(buf, *x)"}
;;   [^bytes/Buffer buf, ^ast/Expr x])

JOKER FUNC go/types.WriteSignature from go/types/typestring.go:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, sig *Signature, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^(atom-of go.std.go.types/Signature) sig, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeSignature(buf, sig, *qf)"}
;;   [^bytes/Buffer buf, ^types/Signature sig, ^types/Qualifier qf])

JOKER FUNC go/types.WriteType from go/types/typestring.go:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, typ Type, qf Qualifier)\n\nJoker input arguments: [^(atom-of go.std.bytes/Buffer) buf, ^go.std.go.types/Type typ, ^go.std.go.types/Qualifier qf]"
;;   {:added "1.0"
;;    :go "__writeType(buf, *typ, *qf)"}
;;   [^bytes/Buffer buf, ^types/Type typ, ^types/Qualifier qf])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["go/types"]
    :doc "Provides a low-level interface to the go/types package."
    :empty false}
  go.std.go.types)
JOKER FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
;; (defn Checksum
;;   "Checksum returns the Adler-32 checksum of data.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC hash/adler32.New from hash/adler32/adler32.go:
(defn New
  "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/adler32 package."
    :empty false}
  go.std.hash.adler32)
JOKER TYPE hash/crc32.Table from hash/crc32/crc32.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc32.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
;; (defn Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data, ^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), tab)"}
;;   [^Object data, ^crc32/Table tab])

JOKER FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
;; (defn ChecksumIEEE
;;   "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo input arguments: (data []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksumIEEE(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint32)\n\nGo return type: *Table\n\nJoker input arguments: [^Number poly]\n\nJoker return type: (atom-of go.std.hash.crc32/Table)"
  {:added "1.0"
   :go "__makeTable(poly)"}
  [^Number poly])

JOKER FUNC hash/crc32.New from hash/crc32/crc32.go:
(defn New
  "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash32\n\nJoker input arguments: [^(atom-of go.std.hash.crc32/Table) tab]\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new(tab)"}
  [^crc32/Table tab])

JOKER FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
(defn NewIEEE
  "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__newIEEE()"}
  [])

JOKER FUNC hash/crc32.Update from hash/crc32/crc32.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint32, tab *Table, p []byte)\n\nGo return type: uint32\n\nJoker input arguments: [^Number crc, ^(atom-of go.std.hash.crc32/Table) tab, ^(vector-of Int) p]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__update(crc, tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Number crc, ^crc32/Table tab, ^Object p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/crc32 package."
    :empty false}
  go.std.hash.crc32)
JOKER TYPE hash/crc64.Table from hash/crc64/crc64.go:
;; (defn ^"GoObject" Table.
;;   "Constructor for crc64.Table"
;;   {:added "1.0"
;;    :go "_ConstructTable(_v)"}
;;   [^Object _v])

JOKER FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *Table)\n\nGo return type: uint64\n\nJoker input arguments: [^(vector-of Int) data, ^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__checksum(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), tab)"}
;;   [^Object data, ^crc64/Table tab])

JOKER FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
(defn MakeTable
  "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint64)\n\nGo return type: *Table\n\nJoker input arguments: [^Number poly]\n\nJoker return type: (atom-of go.std.hash.crc64/Table)"
  {:added "1.0"
   :go "__makeTable(poly)"}
  [^Number poly])

JOKER FUNC hash/crc64.New from hash/crc64/crc64.go:
(defn New
  "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *Table)\n\nGo return type: hash.Hash64\n\nJoker input arguments: [^(atom-of go.std.hash.crc64/Table) tab]\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new(tab)"}
  [^crc64/Table tab])

JOKER FUNC hash/crc64.Update from hash/crc64/crc64.go:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint64, tab *Table, p []byte)\n\nGo return type: uint64\n\nJoker input arguments: [^Number crc, ^(atom-of go.std.hash.crc64/Table) tab, ^(vector-of Int) p]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__update(crc, tab, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Number crc, ^crc64/Table tab, ^Object p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/crc64 package."
    :empty false}
  go.std.hash.crc64)
JOKER FUNC hash/fnv.New128 from hash/fnv/fnv.go:
(defn New128
  "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128()"}
  [])

JOKER FUNC hash/fnv.New128a from hash/fnv/fnv.go:
(defn New128a
  "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash"
  {:added "1.0"
   :go "__new128a()"}
  [])

JOKER FUNC hash/fnv.New32 from hash/fnv/fnv.go:
(defn New32
  "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32()"}
  [])

JOKER FUNC hash/fnv.New32a from hash/fnv/fnv.go:
(defn New32a
  "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash32\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash32"
  {:added "1.0"
   :go "__new32a()"}
  [])

JOKER FUNC hash/fnv.New64 from hash/fnv/fnv.go:
(defn New64
  "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64()"}
  [])

JOKER FUNC hash/fnv.New64a from hash/fnv/fnv.go:
(defn New64a
  "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: hash.Hash64\n\nJoker input arguments: []\n\nJoker return type: go.std.hash/Hash64"
  {:added "1.0"
   :go "__new64a()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the hash/fnv package."
    :empty false}
  go.std.hash.fnv)
JOKER FUNC html.EscapeString from html/escape.go:
(defn ^"String" EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(s)"}
  [^String s])

JOKER FUNC html.UnescapeString from html/escape.go:
(defn ^"String" UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(s)"}
  [^String s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html"]
    :doc "Provides a low-level interface to the html package."
    :empty false}
  go.std.html)
JOKER TYPE html/template.CSS from html/template/content.go:
(defn ^"GoObject" CSS.
  "Constructor for template.CSS"
  {:added "1.0"
   :go "_ConstructCSS(_v)"}
  [^Object _v])

JOKER TYPE html/template.Error from html/template/error.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for template.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.ErrorCode from html/template/error.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for template.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE html/template.FuncMap from html/template/template.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.HTML from html/template/content.go:
(defn ^"GoObject" HTML.
  "Constructor for template.HTML"
  {:added "1.0"
   :go "_ConstructHTML(_v)"}
  [^Object _v])

JOKER TYPE html/template.HTMLAttr from html/template/content.go:
(defn ^"GoObject" HTMLAttr.
  "Constructor for template.HTMLAttr"
  {:added "1.0"
   :go "_ConstructHTMLAttr(_v)"}
  [^Object _v])

JOKER TYPE html/template.JS from html/template/content.go:
(defn ^"GoObject" JS.
  "Constructor for template.JS"
  {:added "1.0"
   :go "_ConstructJS(_v)"}
  [^Object _v])

JOKER TYPE html/template.JSStr from html/template/content.go:
(defn ^"GoObject" JSStr.
  "Constructor for template.JSStr"
  {:added "1.0"
   :go "_ConstructJSStr(_v)"}
  [^Object _v])

JOKER TYPE html/template.Srcset from html/template/content.go:
(defn ^"GoObject" Srcset.
  "Constructor for template.Srcset"
  {:added "1.0"
   :go "_ConstructSrcset(_v)"}
  [^Object _v])

JOKER TYPE html/template.Template from html/template/template.go:
;; (defn ^"GoObject" Template.
;;   "Constructor for template.Template"
;;   {:added "1.0"
;;    :go "_ConstructTemplate(_v)"}
;;   [^Object _v])

JOKER TYPE html/template.URL from html/template/content.go:
(defn ^"GoObject" URL.
  "Constructor for template.URL"
  {:added "1.0"
   :go "_ConstructURL(_v)"}
  [^Object _v])

JOKER FUNC html/template.HTMLEscape from html/template/escape.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^io/Writer w, ^Object b])

JOKER FUNC html/template.HTMLEscapeString from html/template/escape.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(s)"}
  [^String s])

JOKER FUNC html/template.HTMLEscaper from html/template/escape.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

JOKER FUNC html/template.IsTrue from html/template/template.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> val])

JOKER FUNC html/template.JSEscape from html/template/escape.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^io/Writer w, ^Object b])

JOKER FUNC html/template.JSEscapeString from html/template/escape.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(s)"}
  [^String s])

JOKER FUNC html/template.JSEscaper from html/template/escape.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

JOKER FUNC html/template.Must from html/template/template.go:
(defn Must
  "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.html.template/Template) t, ^Error err]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "__must(t, err)"}
  [^template/Template t, ^Error err])

JOKER FUNC html/template.New from html/template/template.go:
(defn New
  "New allocates a new HTML template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.html.template/Template)"
  {:added "1.0"
   :go "__new(name)"}
  [^String name])

JOKER FUNC html/template.ParseFiles from html/template/template.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(filenames)))"}
;;   [^String filenames])

JOKER FUNC html/template.ParseGlob from html/template/template.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.html.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(pattern)"}
  [^String pattern])

JOKER FUNC html/template.URLQueryEscaper from html/template/escape.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["html/template"]
    :doc "Provides a low-level interface to the html/template package."
    :empty false}
  go.std.html.template)
JOKER TYPE image.Alpha from image/image.go:
;; (defn ^"GoObject" Alpha.
;;   "Constructor for image.Alpha"
;;   {:added "1.0"
;;    :go "_ConstructAlpha(_v)"}
;;   [^Object _v])

JOKER TYPE image.Alpha16 from image/image.go:
;; (defn ^"GoObject" Alpha16.
;;   "Constructor for image.Alpha16"
;;   {:added "1.0"
;;    :go "_ConstructAlpha16(_v)"}
;;   [^Object _v])

JOKER TYPE image.CMYK from image/image.go:
;; (defn ^"GoObject" CMYK.
;;   "Constructor for image.CMYK"
;;   {:added "1.0"
;;    :go "_ConstructCMYK(_v)"}
;;   [^Object _v])

JOKER TYPE image.Config from image/image.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for image.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE image.Gray from image/image.go:
;; (defn ^"GoObject" Gray.
;;   "Constructor for image.Gray"
;;   {:added "1.0"
;;    :go "_ConstructGray(_v)"}
;;   [^Object _v])

JOKER TYPE image.Gray16 from image/image.go:
;; (defn ^"GoObject" Gray16.
;;   "Constructor for image.Gray16"
;;   {:added "1.0"
;;    :go "_ConstructGray16(_v)"}
;;   [^Object _v])

JOKER TYPE image.Image from image/image.go:
;; (defn ^"GoObject" Image.
;;   "Constructor for image.Image"
;;   {:added "1.0"
;;    :go "_ConstructImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.NRGBA from image/image.go:
;; (defn ^"GoObject" NRGBA.
;;   "Constructor for image.NRGBA"
;;   {:added "1.0"
;;    :go "_ConstructNRGBA(_v)"}
;;   [^Object _v])

JOKER TYPE image.NRGBA64 from image/image.go:
;; (defn ^"GoObject" NRGBA64.
;;   "Constructor for image.NRGBA64"
;;   {:added "1.0"
;;    :go "_ConstructNRGBA64(_v)"}
;;   [^Object _v])

JOKER TYPE image.NYCbCrA from image/ycbcr.go:
;; (defn ^"GoObject" NYCbCrA.
;;   "Constructor for image.NYCbCrA"
;;   {:added "1.0"
;;    :go "_ConstructNYCbCrA(_v)"}
;;   [^Object _v])

JOKER TYPE image.Paletted from image/image.go:
;; (defn ^"GoObject" Paletted.
;;   "Constructor for image.Paletted"
;;   {:added "1.0"
;;    :go "_ConstructPaletted(_v)"}
;;   [^Object _v])

JOKER TYPE image.PalettedImage from image/image.go:
;; (defn ^"GoObject" PalettedImage.
;;   "Constructor for image.PalettedImage"
;;   {:added "1.0"
;;    :go "_ConstructPalettedImage(_v)"}
;;   [^Object _v])

JOKER TYPE image.Point from image/geom.go:
(defn ^"GoObject" Point.
  "Constructor for image.Point"
  {:added "1.0"
   :go "_ConstructPoint(_v)"}
  [^Object _v])

JOKER TYPE image.RGBA from image/image.go:
;; (defn ^"GoObject" RGBA.
;;   "Constructor for image.RGBA"
;;   {:added "1.0"
;;    :go "_ConstructRGBA(_v)"}
;;   [^Object _v])

JOKER TYPE image.RGBA64 from image/image.go:
;; (defn ^"GoObject" RGBA64.
;;   "Constructor for image.RGBA64"
;;   {:added "1.0"
;;    :go "_ConstructRGBA64(_v)"}
;;   [^Object _v])

JOKER TYPE image.Rectangle from image/geom.go:
;; (defn ^"GoObject" Rectangle.
;;   "Constructor for image.Rectangle"
;;   {:added "1.0"
;;    :go "_ConstructRectangle(_v)"}
;;   [^Object _v])

JOKER TYPE image.Uniform from image/names.go:
;; (defn ^"GoObject" Uniform.
;;   "Constructor for image.Uniform"
;;   {:added "1.0"
;;    :go "_ConstructUniform(_v)"}
;;   [^Object _v])

JOKER TYPE image.YCbCr from image/ycbcr.go:
;; (defn ^"GoObject" YCbCr.
;;   "Constructor for image.YCbCr"
;;   {:added "1.0"
;;    :go "_ConstructYCbCr(_v)"}
;;   [^Object _v])

JOKER TYPE image.YCbCrSubsampleRatio from image/ycbcr.go:
(defn ^"GoObject" YCbCrSubsampleRatio.
  "Constructor for image.YCbCrSubsampleRatio"
  {:added "1.0"
   :go "_ConstructYCbCrSubsampleRatio(_v)"}
  [^Object _v])

JOKER FUNC image.Decode from image/format.go:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Image, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image String Error]"
;;   {:added "1.0"
;;    :go "__decode(*r)"}
;;   [^io/Reader r])

JOKER FUNC image.DecodeConfig from image/format.go:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Config, string, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config String Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*r)"}
;;   [^io/Reader r])

JOKER FUNC image.NewAlpha from image/image.go:
(defn NewAlpha
  "NewAlpha returns a new Alpha image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha)"
  {:added "1.0"
   :go "__newAlpha(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewAlpha16 from image/image.go:
(defn NewAlpha16
  "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Alpha16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Alpha16)"
  {:added "1.0"
   :go "__newAlpha16(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewCMYK from image/image.go:
(defn NewCMYK
  "NewCMYK returns a new CMYK image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *CMYK\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/CMYK)"
  {:added "1.0"
   :go "__newCMYK(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewGray from image/image.go:
(defn NewGray
  "NewGray returns a new Gray image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray)"
  {:added "1.0"
   :go "__newGray(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewGray16 from image/image.go:
(defn NewGray16
  "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *Gray16\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/Gray16)"
  {:added "1.0"
   :go "__newGray16(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewNRGBA from image/image.go:
(defn NewNRGBA
  "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA)"
  {:added "1.0"
   :go "__newNRGBA(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewNRGBA64 from image/image.go:
(defn NewNRGBA64
  "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *NRGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/NRGBA64)"
  {:added "1.0"
   :go "__newNRGBA64(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewNYCbCrA from image/ycbcr.go:
(defn NewNYCbCrA
  "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *NYCbCrA\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/NYCbCrA)"
  {:added "1.0"
   :go "__newNYCbCrA(*r, *subsampleRatio)"}
  [^image/Rectangle r, ^image/YCbCrSubsampleRatio subsampleRatio])

JOKER FUNC image.NewPaletted from image/image.go:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo input arguments: (r Rectangle, p color.Palette)\n\nGo return type: *Paletted\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image.color/Palette p]\n\nJoker return type: (atom-of go.std.image/Paletted)"
;;   {:added "1.0"
;;    :go "__newPaletted(*r, *p)"}
;;   [^image/Rectangle r, ^color/Palette p])

JOKER FUNC image.NewRGBA from image/image.go:
(defn NewRGBA
  "NewRGBA returns a new RGBA image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA)"
  {:added "1.0"
   :go "__newRGBA(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewRGBA64 from image/image.go:
(defn NewRGBA64
  "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo input arguments: (r Rectangle)\n\nGo return type: *RGBA64\n\nJoker input arguments: [^go.std.image/Rectangle r]\n\nJoker return type: (atom-of go.std.image/RGBA64)"
  {:added "1.0"
   :go "__newRGBA64(*r)"}
  [^image/Rectangle r])

JOKER FUNC image.NewUniform from image/names.go:
;; (defn NewUniform
;;   "Go input arguments: (c color.Color)\n\nGo return type: *Uniform\n\nJoker input arguments: [^go.std.image.color/Color c]\n\nJoker return type: (atom-of go.std.image/Uniform)"
;;   {:added "1.0"
;;    :go "__newUniform(*c)"}
;;   [^color/Color c])

JOKER FUNC image.NewYCbCr from image/ycbcr.go:
(defn NewYCbCr
  "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo input arguments: (r Rectangle, subsampleRatio YCbCrSubsampleRatio)\n\nGo return type: *YCbCr\n\nJoker input arguments: [^go.std.image/Rectangle r, ^go.std.image/YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: (atom-of go.std.image/YCbCr)"
  {:added "1.0"
   :go "__newYCbCr(*r, *subsampleRatio)"}
  [^image/Rectangle r, ^image/YCbCrSubsampleRatio subsampleRatio])

JOKER FUNC image.Pt from image/geom.go:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo input arguments: (X int, Y int)\n\nGo return type: Point\n\nJoker input arguments: [^Int X, ^Int Y]\n\nJoker return type: go.std.image/Point"
  {:added "1.0"
   :go "__pt(X, Y)"}
  [^Int X, ^Int Y])

JOKER FUNC image.Rect from image/geom.go:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo input arguments: (x0 int, y0 int, x1 int, y1 int)\n\nGo return type: Rectangle\n\nJoker input arguments: [^Int x0, ^Int y0, ^Int x1, ^Int y1]\n\nJoker return type: go.std.image/Rectangle"
  {:added "1.0"
   :go "__rect(x0, y0, x1, y1)"}
  [^Int x0, ^Int y0, ^Int x1, ^Int y1])

JOKER FUNC image.RegisterFormat from image/format.go:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n\nGo input arguments: (name string, magic string, decode func, decodeConfig func)\n\nJoker input arguments: [^String name, ^String magic, ^fn decode, ^fn decodeConfig]"
;;   {:added "1.0"
;;    :go "__registerFormat(name, magic, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String name, ^String magic, ^fn decode, ^fn decodeConfig])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the image package."
    :empty false}
  go.std.image)
JOKER TYPE image/color.Alpha from image/color/color.go:
(defn ^"GoObject" Alpha.
  "Constructor for color.Alpha"
  {:added "1.0"
   :go "_ConstructAlpha(_v)"}
  [^Object _v])

JOKER TYPE image/color.Alpha16 from image/color/color.go:
(defn ^"GoObject" Alpha16.
  "Constructor for color.Alpha16"
  {:added "1.0"
   :go "_ConstructAlpha16(_v)"}
  [^Object _v])

JOKER TYPE image/color.CMYK from image/color/ycbcr.go:
(defn ^"GoObject" CMYK.
  "Constructor for color.CMYK"
  {:added "1.0"
   :go "_ConstructCMYK(_v)"}
  [^Object _v])

JOKER TYPE image/color.Color from image/color/color.go:
;; (defn ^"GoObject" Color.
;;   "Constructor for color.Color"
;;   {:added "1.0"
;;    :go "_ConstructColor(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.Gray from image/color/color.go:
(defn ^"GoObject" Gray.
  "Constructor for color.Gray"
  {:added "1.0"
   :go "_ConstructGray(_v)"}
  [^Object _v])

JOKER TYPE image/color.Gray16 from image/color/color.go:
(defn ^"GoObject" Gray16.
  "Constructor for color.Gray16"
  {:added "1.0"
   :go "_ConstructGray16(_v)"}
  [^Object _v])

JOKER TYPE image/color.Model from image/color/color.go:
;; (defn ^"GoObject" Model.
;;   "Constructor for color.Model"
;;   {:added "1.0"
;;    :go "_ConstructModel(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.NRGBA from image/color/color.go:
(defn ^"GoObject" NRGBA.
  "Constructor for color.NRGBA"
  {:added "1.0"
   :go "_ConstructNRGBA(_v)"}
  [^Object _v])

JOKER TYPE image/color.NRGBA64 from image/color/color.go:
(defn ^"GoObject" NRGBA64.
  "Constructor for color.NRGBA64"
  {:added "1.0"
   :go "_ConstructNRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image/color.NYCbCrA from image/color/ycbcr.go:
(defn ^"GoObject" NYCbCrA.
  "Constructor for color.NYCbCrA"
  {:added "1.0"
   :go "_ConstructNYCbCrA(_v)"}
  [^Object _v])

JOKER TYPE image/color.Palette from image/color/color.go:
;; (defn ^"GoObject" Palette.
;;   "Constructor for color.Palette"
;;   {:added "1.0"
;;    :go "_ConstructPalette(_v)"}
;;   [^Object _v])

JOKER TYPE image/color.RGBA from image/color/color.go:
(defn ^"GoObject" RGBA.
  "Constructor for color.RGBA"
  {:added "1.0"
   :go "_ConstructRGBA(_v)"}
  [^Object _v])

JOKER TYPE image/color.RGBA64 from image/color/color.go:
(defn ^"GoObject" RGBA64.
  "Constructor for color.RGBA64"
  {:added "1.0"
   :go "_ConstructRGBA64(_v)"}
  [^Object _v])

JOKER TYPE image/color.YCbCr from image/color/ycbcr.go:
(defn ^"GoObject" YCbCr.
  "Constructor for color.YCbCr"
  {:added "1.0"
   :go "_ConstructYCbCr(_v)"}
  [^Object _v])

JOKER FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
(defn CMYKToRGB
  "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo input arguments: (c uint8, m uint8, y uint8, k uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int c, ^Int m, ^Int y, ^Int k]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__cMYKToRGB(c, m, y, k)"}
  [^Int c, ^Int m, ^Int y, ^Int k])

JOKER FUNC image/color.ModelFunc from image/color/color.go:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo input arguments: (f func)\n\nGo return type: Model\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.image.color/Model"
;;   {:added "1.0"
;;    :go "__modelFunc(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn f])

JOKER FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
(defn RGBToCMYK
  "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (uint8, uint8, uint8, uint8)\n\nJoker input arguments: [^Int r, ^Int g, ^Int b]\n\nJoker return type: [Int Int Int Int]"
  {:added "1.0"
   :go "__rGBToCMYK(r, g, b)"}
  [^Int r, ^Int g, ^Int b])

JOKER FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
(defn RGBToYCbCr
  "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int r, ^Int g, ^Int b]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__rGBToYCbCr(r, g, b)"}
  [^Int r, ^Int g, ^Int b])

JOKER FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
(defn YCbCrToRGB
  "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo input arguments: (y uint8, cb uint8, cr uint8)\n\nGo return type: (uint8, uint8, uint8)\n\nJoker input arguments: [^Int y, ^Int cb, ^Int cr]\n\nJoker return type: [Int Int Int]"
  {:added "1.0"
   :go "__yCbCrToRGB(y, cb, cr)"}
  [^Int y, ^Int cb, ^Int cr])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the image/color package."
    :empty false}
  go.std.image.color)
JOKER FUNC image/draw.Draw from image/draw/draw.go:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__draw(*dst, *r, *src, *sp, *op)"}
;;   [^draw/Image dst, ^image/Rectangle r, ^image/Image src, ^image/Point sp, ^draw/Op op])

JOKER FUNC image/draw.DrawMask from image/draw/draw.go:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n\nGo input arguments: (dst Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op Op)\n\nJoker input arguments: [^go.std.image.draw/Image dst, ^go.std.image/Rectangle r, ^go.std.image/Image src, ^go.std.image/Point sp, ^go.std.image/Image mask, ^go.std.image/Point mp, ^go.std.image.draw/Op op]"
;;   {:added "1.0"
;;    :go "__drawMask(*dst, *r, *src, *sp, *mask, *mp, *op)"}
;;   [^draw/Image dst, ^image/Rectangle r, ^image/Image src, ^image/Point sp, ^image/Image mask, ^image/Point mp, ^draw/Op op])

JOKER FUNC image/gif.Decode from image/gif/reader.go:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/gif.DecodeAll from image/gif/reader.go:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*GIF, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.image.gif/GIF) Error]"
;;   {:added "1.0"
;;    :go "__decodeAll(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/gif.DecodeConfig from image/gif/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/gif.Encode from image/gif/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.gif/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(*w, *m, o)"}
;;   [^io/Writer w, ^image/Image m, ^gif/Options o])

JOKER FUNC image/gif.EncodeAll from image/gif/writer.go:
;; (defn ^"Error" EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo input arguments: (w io.Writer, g *GIF)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^(atom-of go.std.image.gif/GIF) g]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(*w, g)"}
;;   [^io/Writer w, ^gif/GIF g])

JOKER TYPE image/jpeg.FormatError from image/jpeg/reader.go:
(defn ^"GoObject" FormatError.
  "Constructor for jpeg.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE image/jpeg.Options from image/jpeg/writer.go:
(defn ^"GoObject" Options.
  "Constructor for jpeg.Options"
  {:added "1.0"
   :go "_ConstructOptions(_v)"}
  [^Object _v])

JOKER TYPE image/jpeg.Reader from image/jpeg/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for jpeg.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE image/jpeg.UnsupportedError from image/jpeg/reader.go:
(defn ^"GoObject" UnsupportedError.
  "Constructor for jpeg.UnsupportedError"
  {:added "1.0"
   :go "_ConstructUnsupportedError(_v)"}
  [^Object _v])

JOKER FUNC image/jpeg.Decode from image/jpeg/reader.go:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/jpeg.Encode from image/jpeg/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo input arguments: (w io.Writer, m image.Image, o *Options)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m, ^(atom-of go.std.image.jpeg/Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(*w, *m, o)"}
;;   [^io/Writer w, ^image/Image m, ^jpeg/Options o])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the image/jpeg package."
    :empty false}
  go.std.image.jpeg)
JOKER TYPE image/png.CompressionLevel from image/png/writer.go:
(defn ^"GoObject" CompressionLevel.
  "Constructor for png.CompressionLevel"
  {:added "1.0"
   :go "_ConstructCompressionLevel(_v)"}
  [^Object _v])

JOKER TYPE image/png.Encoder from image/png/writer.go:
;; (defn ^"GoObject" Encoder.
;;   "Constructor for png.Encoder"
;;   {:added "1.0"
;;    :go "_ConstructEncoder(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.EncoderBuffer from image/png/writer.go:
;; (defn ^"GoObject" EncoderBuffer.
;;   "Constructor for png.EncoderBuffer"
;;   {:added "1.0"
;;    :go "_ConstructEncoderBuffer(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.EncoderBufferPool from image/png/writer.go:
;; (defn ^"GoObject" EncoderBufferPool.
;;   "Constructor for png.EncoderBufferPool"
;;   {:added "1.0"
;;    :go "_ConstructEncoderBufferPool(_v)"}
;;   [^Object _v])

JOKER TYPE image/png.FormatError from image/png/reader.go:
(defn ^"GoObject" FormatError.
  "Constructor for png.FormatError"
  {:added "1.0"
   :go "_ConstructFormatError(_v)"}
  [^Object _v])

JOKER TYPE image/png.UnsupportedError from image/png/reader.go:
(defn ^"GoObject" UnsupportedError.
  "Constructor for png.UnsupportedError"
  {:added "1.0"
   :go "_ConstructUnsupportedError(_v)"}
  [^Object _v])

JOKER FUNC image/png.Decode from image/png/reader.go:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Image, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Image Error]"
;;   {:added "1.0"
;;    :go "__decode(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/png.DecodeConfig from image/png/reader.go:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (image.Config, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [go.std.image/Config Error]"
;;   {:added "1.0"
;;    :go "__decodeConfig(*r)"}
;;   [^io/Reader r])

JOKER FUNC image/png.Encode from image/png/writer.go:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo input arguments: (w io.Writer, m image.Image)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w, ^go.std.image/Image m]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(*w, *m)"}
;;   [^io/Writer w, ^image/Image m])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the image/png package."
    :empty false}
  go.std.image.png)
JOKER TYPE index/suffixarray.Index from index/suffixarray/suffixarray.go:
(defn ^"GoObject" Index.
  "Constructor for suffixarray.Index"
  {:added "1.0"
   :go "_ConstructIndex(_v)"}
  [^Object _v])

JOKER FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo input arguments: (data []byte)\n\nGo return type: *Index\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: (atom-of go.std.index.suffixarray/Index)"
;;   {:added "1.0"
;;    :go "__new(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the index/suffixarray package."
    :empty false}
  go.std.index.suffixarray)
JOKER TYPE io.ByteReader from io/io.go:
;; (defn ^"GoObject" ByteReader.
;;   "Constructor for io.ByteReader"
;;   {:added "1.0"
;;    :go "_ConstructByteReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteScanner from io/io.go:
;; (defn ^"GoObject" ByteScanner.
;;   "Constructor for io.ByteScanner"
;;   {:added "1.0"
;;    :go "_ConstructByteScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.ByteWriter from io/io.go:
;; (defn ^"GoObject" ByteWriter.
;;   "Constructor for io.ByteWriter"
;;   {:added "1.0"
;;    :go "_ConstructByteWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Closer from io/io.go:
;; (defn ^"GoObject" Closer.
;;   "Constructor for io.Closer"
;;   {:added "1.0"
;;    :go "_ConstructCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.LimitedReader from io/io.go:
;; (defn ^"GoObject" LimitedReader.
;;   "Constructor for io.LimitedReader"
;;   {:added "1.0"
;;    :go "_ConstructLimitedReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.PipeReader from io/pipe.go:
(defn ^"GoObject" PipeReader.
  "Constructor for io.PipeReader"
  {:added "1.0"
   :go "_ConstructPipeReader(_v)"}
  [^Object _v])

JOKER TYPE io.PipeWriter from io/pipe.go:
(defn ^"GoObject" PipeWriter.
  "Constructor for io.PipeWriter"
  {:added "1.0"
   :go "_ConstructPipeWriter(_v)"}
  [^Object _v])

JOKER TYPE io.ReadCloser from io/io.go:
;; (defn ^"GoObject" ReadCloser.
;;   "Constructor for io.ReadCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadSeeker from io/io.go:
;; (defn ^"GoObject" ReadSeeker.
;;   "Constructor for io.ReadSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteCloser from io/io.go:
;; (defn ^"GoObject" ReadWriteCloser.
;;   "Constructor for io.ReadWriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriteSeeker from io/io.go:
;; (defn ^"GoObject" ReadWriteSeeker.
;;   "Constructor for io.ReadWriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructReadWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReadWriter from io/io.go:
;; (defn ^"GoObject" ReadWriter.
;;   "Constructor for io.ReadWriter"
;;   {:added "1.0"
;;    :go "_ConstructReadWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.Reader from io/io.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for io.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderAt from io/io.go:
;; (defn ^"GoObject" ReaderAt.
;;   "Constructor for io.ReaderAt"
;;   {:added "1.0"
;;    :go "_ConstructReaderAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.ReaderFrom from io/io.go:
;; (defn ^"GoObject" ReaderFrom.
;;   "Constructor for io.ReaderFrom"
;;   {:added "1.0"
;;    :go "_ConstructReaderFrom(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneReader from io/io.go:
;; (defn ^"GoObject" RuneReader.
;;   "Constructor for io.RuneReader"
;;   {:added "1.0"
;;    :go "_ConstructRuneReader(_v)"}
;;   [^Object _v])

JOKER TYPE io.RuneScanner from io/io.go:
;; (defn ^"GoObject" RuneScanner.
;;   "Constructor for io.RuneScanner"
;;   {:added "1.0"
;;    :go "_ConstructRuneScanner(_v)"}
;;   [^Object _v])

JOKER TYPE io.SectionReader from io/io.go:
(defn ^"GoObject" SectionReader.
  "Constructor for io.SectionReader"
  {:added "1.0"
   :go "_ConstructSectionReader(_v)"}
  [^Object _v])

JOKER TYPE io.Seeker from io/io.go:
;; (defn ^"GoObject" Seeker.
;;   "Constructor for io.Seeker"
;;   {:added "1.0"
;;    :go "_ConstructSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.StringWriter from io/io.go:
;; (defn ^"GoObject" StringWriter.
;;   "Constructor for io.StringWriter"
;;   {:added "1.0"
;;    :go "_ConstructStringWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteCloser from io/io.go:
;; (defn ^"GoObject" WriteCloser.
;;   "Constructor for io.WriteCloser"
;;   {:added "1.0"
;;    :go "_ConstructWriteCloser(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriteSeeker from io/io.go:
;; (defn ^"GoObject" WriteSeeker.
;;   "Constructor for io.WriteSeeker"
;;   {:added "1.0"
;;    :go "_ConstructWriteSeeker(_v)"}
;;   [^Object _v])

JOKER TYPE io.Writer from io/io.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for io.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterAt from io/io.go:
;; (defn ^"GoObject" WriterAt.
;;   "Constructor for io.WriterAt"
;;   {:added "1.0"
;;    :go "_ConstructWriterAt(_v)"}
;;   [^Object _v])

JOKER TYPE io.WriterTo from io/io.go:
;; (defn ^"GoObject" WriterTo.
;;   "Constructor for io.WriterTo"
;;   {:added "1.0"
;;    :go "_ConstructWriterTo(_v)"}
;;   [^Object _v])

JOKER FUNC io.Copy from io/io.go:
(defn Copy
  "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo input arguments: (dst Writer, src Reader)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__copy(*dst, *src)"}
  [^io/Writer dst, ^io/Reader src])

JOKER FUNC io.CopyBuffer from io/io.go:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo input arguments: (dst Writer, src Reader, buf []byte)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^(vector-of Int) buf]\n\nJoker return type: [Number Error]"
;;   {:added "1.0"
;;    :go "__copyBuffer(*dst, *src, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^io/Writer dst, ^io/Reader src, ^Object buf])

JOKER FUNC io.CopyN from io/io.go:
(defn CopyN
  "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo input arguments: (dst Writer, src Reader, n int64)\n\nGo return type: (written int64, err error)\n\nJoker input arguments: [^go.std.io/Writer dst, ^go.std.io/Reader src, ^Number n]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__copyN(*dst, *src, n)"}
  [^io/Writer dst, ^io/Reader src, ^Number n])

JOKER FUNC io.LimitReader from io/io.go:
(defn LimitReader
  "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo input arguments: (r Reader, n int64)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^Number n]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__limitReader(*r, n)"}
  [^io/Reader r, ^Number n])

JOKER FUNC io.MultiReader from io/multi.go:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo input arguments: (readers ...Reader)\n\nGo return type: Reader\n\nJoker input arguments: [^(ellipsis-somehow io/Reader) readers]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__multiReader(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Reader(*readers)))"}
;;   [^io/Reader readers])

JOKER FUNC io.MultiWriter from io/multi.go:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo input arguments: (writers ...Writer)\n\nGo return type: Writer\n\nJoker input arguments: [^(ellipsis-somehow io/Writer) writers]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__multiWriter(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_io.Writer(*writers)))"}
;;   [^io/Writer writers])

JOKER FUNC io.NewSectionReader from io/io.go:
(defn NewSectionReader
  "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo input arguments: (r ReaderAt, off int64, n int64)\n\nGo return type: *SectionReader\n\nJoker input arguments: [^go.std.io/ReaderAt r, ^Number off, ^Number n]\n\nJoker return type: (atom-of go.std.io/SectionReader)"
  {:added "1.0"
   :go "__newSectionReader(*r, off, n)"}
  [^io/ReaderAt r, ^Number off, ^Number n])

JOKER FUNC io.Pipe from io/pipe.go:
(defn Pipe
  "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.io/PipeReader) (atom-of go.std.io/PipeWriter)]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC io.ReadAtLeast from io/io.go:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte, min int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) buf, ^Int min]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readAtLeast(*r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), min)"}
;;   [^io/Reader r, ^Object buf, ^Int min])

JOKER FUNC io.ReadFull from io/io.go:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo input arguments: (r Reader, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Reader r, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readFull(*r, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^io/Reader r, ^Object buf])

JOKER FUNC io.TeeReader from io/io.go:
(defn TeeReader
  "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo input arguments: (r Reader, w Writer)\n\nGo return type: Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Reader"
  {:added "1.0"
   :go "__teeReader(*r, *w)"}
  [^io/Reader r, ^io/Writer w])

JOKER FUNC io.WriteString from io/io.go:
(defn WriteString
  "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements StringWriter, its WriteString method is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo input arguments: (w Writer, s string)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^go.std.io/Writer w, ^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__writeString(*w, s)"}
  [^io/Writer w, ^String s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the io package."
    :empty false}
  go.std.io)
JOKER FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__nopCloser(*r)"}
;;   [^io/Reader r])

JOKER FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__readAll(*r)"}
;;   [^io/Reader r])

JOKER FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
(defn ReadDir
  "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo input arguments: (dirname string)\n\nGo return type: ([]os.FileInfo, error)\n\nJoker input arguments: [^String dirname]\n\nJoker return type: [(vector-of go.std.os/FileInfo) Error]"
  {:added "1.0"
   :go "__readDir(dirname)"}
  [^String dirname])

JOKER FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo input arguments: (filename string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String filename]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__readFile(filename)"}
  [^String filename])

JOKER FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo input arguments: (dir string, prefix string)\n\nGo return type: (name string, err error)\n\nJoker input arguments: [^String dir, ^String prefix]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__tempDir(dir, prefix)"}
  [^String dir, ^String prefix])

JOKER FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
(defn TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo input arguments: (dir string, pattern string)\n\nGo return type: (f *os.File, err error)\n\nJoker input arguments: [^String dir, ^String pattern]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__tempFile(dir, pattern)"}
  [^String dir, ^String pattern])

JOKER FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
;; (defn ^"Error" WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo input arguments: (filename string, data []byte, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String filename, ^(vector-of Int) data, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(filename, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)), *perm)"}
;;   [^String filename, ^Object data, ^os/FileMode perm])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the io/ioutil package."
    :empty false}
  go.std.io.ioutil)
JOKER TYPE log.Logger from log/log.go:
(defn ^"GoObject" Logger.
  "Constructor for log.Logger"
  {:added "1.0"
   :go "_ConstructLogger(_v)"}
  [^Object _v])

JOKER FUNC log.Fatal from log/log.go:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatal(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.Fatalf from log/log.go:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> v])

JOKER FUNC log.Fatalln from log/log.go:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__fatalln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.Flags from log/log.go:
(defn ^"Int" Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New from log/log.go:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo input arguments: (out io.Writer, prefix string, flag int)\n\nGo return type: *Logger\n\nJoker input arguments: [^go.std.io/Writer out, ^String prefix, ^Int flag]\n\nJoker return type: (atom-of go.std.log/Logger)"
;;   {:added "1.0"
;;    :go "__new(*out, prefix, flag)"}
;;   [^io/Writer out, ^String prefix, ^Int flag])

JOKER FUNC log.Output from log/log.go:
(defn ^"Error" Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo input arguments: (calldepth int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int calldepth, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(calldepth, s)"}
  [^Int calldepth, ^String s])

JOKER FUNC log.Panic from log/log.go:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panic(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.Panicf from log/log.go:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> v])

JOKER FUNC log.Panicln from log/log.go:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__panicln(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.Prefix from log/log.go:
(defn ^"String" Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print from log/log.go:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__print(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.Printf from log/log.go:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__printf(format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String format, ^<protocol-or-something> v])

JOKER FUNC log.Println from log/log.go:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "__println(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> v])

JOKER FUNC log.SetFlags from log/log.go:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n\nGo input arguments: (flag int)\n\nJoker input arguments: [^Int flag]"
;;   {:added "1.0"
;;    :go "__setFlags(flag)"}
;;   [^Int flag])

JOKER FUNC log.SetOutput from log/log.go:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n\nGo input arguments: (w io.Writer)\n\nJoker input arguments: [^go.std.io/Writer w]"
;;   {:added "1.0"
;;    :go "__setOutput(*w)"}
;;   [^io/Writer w])

JOKER FUNC log.SetPrefix from log/log.go:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n\nGo input arguments: (prefix string)\n\nJoker input arguments: [^String prefix]"
;;   {:added "1.0"
;;    :go "__setPrefix(prefix)"}
;;   [^String prefix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["log"]
    :doc "Provides a low-level interface to the log package."
    :empty false}
  go.std.log)
JOKER TYPE log/syslog.Priority from log/syslog/syslog.go:
(defn ^"GoObject" Priority.
  "Constructor for syslog.Priority"
  {:added "1.0"
   :go "_ConstructPriority(_v)"}
  [^Object _v])

JOKER TYPE log/syslog.Writer from log/syslog/syslog.go:
(defn ^"GoObject" Writer.
  "Constructor for syslog.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC log/syslog.Dial from log/syslog/syslog.go:
(defn Dial
  "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo input arguments: (network string, raddr string, priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^String network, ^String raddr, ^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__dial(network, raddr, *priority, tag)"}
  [^String network, ^String raddr, ^syslog/Priority priority, ^String tag])

JOKER FUNC log/syslog.New from log/syslog/syslog.go:
(defn New
  "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo input arguments: (priority Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority priority, ^String tag]\n\nJoker return type: [(atom-of go.std.log.syslog/Writer) Error]"
  {:added "1.0"
   :go "__new(*priority, tag)"}
  [^syslog/Priority priority, ^String tag])

JOKER FUNC log/syslog.NewLogger from log/syslog/syslog.go:
(defn NewLogger
  "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo input arguments: (p Priority, logFlag int)\n\nGo return type: (*log.Logger, error)\n\nJoker input arguments: [^go.std.log.syslog/Priority p, ^Int logFlag]\n\nJoker return type: [(atom-of go.std.log/Logger) Error]"
  {:added "1.0"
   :go "__newLogger(*p, logFlag)"}
  [^syslog/Priority p, ^Int logFlag])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the log/syslog package."
    :empty false}
  go.std.log.syslog)
JOKER FUNC math.Abs from math/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__abs(x)"}
;;   [^Double x])

JOKER FUNC math.Acos from math/asin.go:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__acos(x)"}
;;   [^Double x])

JOKER FUNC math.Acosh from math/acosh.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__acosh(x)"}
;;   [^Double x])

JOKER FUNC math.Asin from math/asin.go:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(0) = 0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__asin(x)"}
;;   [^Double x])

JOKER FUNC math.Asinh from math/asinh.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(0) = 0\n\tAsinh(Inf) = Inf\n\tAsinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__asinh(x)"}
;;   [^Double x])

JOKER FUNC math.Atan from math/atan.go:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(0) = 0\n     Atan(Inf) = Pi/2\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atan(x)"}
;;   [^Double x])

JOKER FUNC math.Atan2 from math/atan2.go:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo input arguments: (y float64, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double y, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atan2(y, x)"}
;;   [^Double y, ^Double x])

JOKER FUNC math.Atanh from math/atanh.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(0) = 0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__atanh(x)"}
;;   [^Double x])

JOKER FUNC math.Cbrt from math/cbrt.go:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(0) = 0\n\tCbrt(Inf) = Inf\n\tCbrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cbrt(x)"}
;;   [^Double x])

JOKER FUNC math.Ceil from math/floor.go:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(0) = 0\n\tCeil(Inf) = Inf\n\tCeil(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__ceil(x)"}
;;   [^Double x])

JOKER FUNC math.Copysign from math/copysign.go:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__copysign(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Cos from math/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(Inf) = NaN\n\tCos(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cos(x)"}
;;   [^Double x])

JOKER FUNC math.Cosh from math/sinh.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(0) = 1\n\tCosh(Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__cosh(x)"}
;;   [^Double x])

JOKER FUNC math.Dim from math/dim.go:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__dim(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Erf from math/erf.go:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erf(x)"}
;;   [^Double x])

JOKER FUNC math.Erfc from math/erf.go:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfc(x)"}
;;   [^Double x])

JOKER FUNC math.Erfcinv from math/erfinv.go:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfcinv(x)"}
;;   [^Double x])

JOKER FUNC math.Erfinv from math/erfinv.go:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__erfinv(x)"}
;;   [^Double x])

JOKER FUNC math.Exp from math/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__exp(x)"}
;;   [^Double x])

JOKER FUNC math.Exp2 from math/exp.go:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__exp2(x)"}
;;   [^Double x])

JOKER FUNC math.Expm1 from math/expm1.go:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__expm1(x)"}
;;   [^Double x])

JOKER FUNC math.Float32bits from math/unsafe.go:
(defn Float32bits
  "Float32bits returns the IEEE 754 binary representation of f,\nwith the sign bit of f and the result in the same bit position.\nFloat32bits(Float32frombits(x)) == x.\n\nGo input arguments: (f float32)\n\nGo return type: uint32\n\nJoker input arguments: [^Double f]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__float32bits(f)"}
  [^Double f])

JOKER FUNC math.Float32frombits from math/unsafe.go:
;; (defn Float32frombits
;;   "Float32frombits returns the floating-point number corresponding\nto the IEEE 754 binary representation b, with the sign bit of b\nand the result in the same bit position.\nFloat32frombits(Float32bits(x)) == x.\n\nGo input arguments: (b uint32)\n\nGo return type: float32\n\nJoker input arguments: [^Number b]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float32frombits(b)"}
;;   [^Number b])

JOKER FUNC math.Float64bits from math/unsafe.go:
(defn Float64bits
  "Float64bits returns the IEEE 754 binary representation of f,\nwith the sign bit of f and the result in the same bit position,\nand Float64bits(Float64frombits(x)) == x.\n\nGo input arguments: (f float64)\n\nGo return type: uint64\n\nJoker input arguments: [^Double f]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__float64bits(f)"}
  [^Double f])

JOKER FUNC math.Float64frombits from math/unsafe.go:
;; (defn Float64frombits
;;   "Float64frombits returns the floating-point number corresponding\nto the IEEE 754 binary representation b, with the sign bit of b\nand the result in the same bit position.\nFloat64frombits(Float64bits(x)) == x.\n\nGo input arguments: (b uint64)\n\nGo return type: float64\n\nJoker input arguments: [^Number b]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float64frombits(b)"}
;;   [^Number b])

JOKER FUNC math.Floor from math/floor.go:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(0) = 0\n\tFloor(Inf) = Inf\n\tFloor(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__floor(x)"}
;;   [^Double x])

JOKER FUNC math.Frexp from math/frexp.go:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac  2**exp,\nwith the absolute value of frac in the interval [, 1).\n\nSpecial cases are:\n\tFrexp(0) = 0, 0\n\tFrexp(Inf) = Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo input arguments: (f float64)\n\nGo return type: (frac float64, exp int)\n\nJoker input arguments: [^Double f]\n\nJoker return type: [Double Int]"
;;   {:added "1.0"
;;    :go "__frexp(f)"}
;;   [^Double f])

JOKER FUNC math.Gamma from math/gamma.go:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__gamma(x)"}
;;   [^Double x])

JOKER FUNC math.Hypot from math/hypot.go:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(Inf, q) = +Inf\n\tHypot(p, Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo input arguments: (p float64, q float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double p, ^Double q]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__hypot(p, q)"}
;;   [^Double p, ^Double q])

JOKER FUNC math.Ilogb from math/logb.go:
(defn ^"Int" Ilogb
  "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo input arguments: (x float64)\n\nGo return type: int\n\nJoker input arguments: [^Double x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "math.Ilogb(x)"}
  [^Double x])

JOKER FUNC math.Inf from math/bits.go:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo input arguments: (sign int)\n\nGo return type: float64\n\nJoker input arguments: [^Int sign]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__inf(sign)"}
;;   [^Int sign])

JOKER FUNC math.IsInf from math/bits.go:
(defn ^"Boolean" IsInf
  "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo input arguments: (f float64, sign int)\n\nGo return type: bool\n\nJoker input arguments: [^Double f, ^Int sign]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "math.IsInf(f, sign)"}
  [^Double f, ^Int sign])

JOKER FUNC math.IsNaN from math/bits.go:
(defn ^"Boolean" IsNaN
  "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo input arguments: (f float64)\n\nGo return type: bool\n\nJoker input arguments: [^Double f]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "math.IsNaN(f)"}
  [^Double f])

JOKER FUNC math.J0 from math/j0.go:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__j0(x)"}
;;   [^Double x])

JOKER FUNC math.J1 from math/j1.go:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(Inf) = 0\n\tJ1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__j1(x)"}
;;   [^Double x])

JOKER FUNC math.Jn from math/jn.go:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Int n, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__jn(n, x)"}
;;   [^Int n, ^Double x])

JOKER FUNC math.Ldexp from math/ldexp.go:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac  2**exp.\n\nSpecial cases are:\n\tLdexp(0, exp) = 0\n\tLdexp(Inf, exp) = Inf\n\tLdexp(NaN, exp) = NaN\n\nGo input arguments: (frac float64, exp int)\n\nGo return type: float64\n\nJoker input arguments: [^Double frac, ^Int exp]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__ldexp(frac, exp)"}
;;   [^Double frac, ^Int exp])

JOKER FUNC math.Lgamma from math/lgamma.go:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: (lgamma float64, sign int)\n\nJoker input arguments: [^Double x]\n\nJoker return type: [Double Int]"
;;   {:added "1.0"
;;    :go "__lgamma(x)"}
;;   [^Double x])

JOKER FUNC math.Log from math/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log(x)"}
;;   [^Double x])

JOKER FUNC math.Log10 from math/log10.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log10(x)"}
;;   [^Double x])

JOKER FUNC math.Log1p from math/log1p.go:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(0) = 0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log1p(x)"}
;;   [^Double x])

JOKER FUNC math.Log2 from math/log10.go:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__log2(x)"}
;;   [^Double x])

JOKER FUNC math.Logb from math/logb.go:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__logb(x)"}
;;   [^Double x])

JOKER FUNC math.Max from math/dim.go:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, 0) = Max(0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__max(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Min from math/dim.go:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, 0) = Min(0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__min(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Mod from math/mod.go:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, Inf) = x\n\tMod(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__mod(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Modf from math/modf.go:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(Inf) = Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo input arguments: (f float64)\n\nGo return type: (int float64, frac float64)\n\nJoker input arguments: [^Double f]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__modf(f)"}
;;   [^Double f])

JOKER FUNC math.NaN from math/bits.go:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math.Nextafter from math/nextafter.go:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__nextafter(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Nextafter32 from math/nextafter.go:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo input arguments: (x float32, y float32)\n\nGo return type: float32\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__nextafter32(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Pow from math/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, 0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(0, y) = Inf for y an odd integer < 0\n\tPow(0, -Inf) = +Inf\n\tPow(0, +Inf) = +0\n\tPow(0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(0, y) = 0 for y an odd integer > 0\n\tPow(0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__pow(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Pow10 from math/pow10.go:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo input arguments: (n int)\n\nGo return type: float64\n\nJoker input arguments: [^Int n]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__pow10(n)"}
;;   [^Int n])

JOKER FUNC math.Remainder from math/remainder.go:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x, ^Double y]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__remainder(x, y)"}
;;   [^Double x, ^Double y])

JOKER FUNC math.Round from math/floor.go:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(0) = 0\n\tRound(Inf) = Inf\n\tRound(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__round(x)"}
;;   [^Double x])

JOKER FUNC math.RoundToEven from math/floor.go:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(0) = 0\n\tRoundToEven(Inf) = Inf\n\tRoundToEven(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__roundToEven(x)"}
;;   [^Double x])

JOKER FUNC math.Signbit from math/signbit.go:
(defn ^"Boolean" Signbit
  "Signbit reports whether x is negative or negative zero.\n\nGo input arguments: (x float64)\n\nGo return type: bool\n\nJoker input arguments: [^Double x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "math.Signbit(x)"}
  [^Double x])

JOKER FUNC math.Sin from math/sin.go:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(0) = 0\n\tSin(Inf) = NaN\n\tSin(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sin(x)"}
;;   [^Double x])

JOKER FUNC math.Sincos from math/sincos.go:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(0) = 0, 1\n\tSincos(Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo input arguments: (x float64)\n\nGo return type: (sin float64, cos float64)\n\nJoker input arguments: [^Double x]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__sincos(x)"}
;;   [^Double x])

JOKER FUNC math.Sinh from math/sinh.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(0) = 0\n\tSinh(Inf) = Inf\n\tSinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sinh(x)"}
;;   [^Double x])

JOKER FUNC math.Sqrt from math/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(0) = 0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__sqrt(x)"}
;;   [^Double x])

JOKER FUNC math.Tan from math/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(0) = 0\n\tTan(Inf) = NaN\n\tTan(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__tan(x)"}
;;   [^Double x])

JOKER FUNC math.Tanh from math/tanh.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(0) = 0\n\tTanh(Inf) = 1\n\tTanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__tanh(x)"}
;;   [^Double x])

JOKER FUNC math.Trunc from math/floor.go:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(0) = 0\n\tTrunc(Inf) = Inf\n\tTrunc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__trunc(x)"}
;;   [^Double x])

JOKER FUNC math.Y0 from math/j0.go:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__y0(x)"}
;;   [^Double x])

JOKER FUNC math.Y1 from math/j1.go:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__y1(x)"}
;;   [^Double x])

JOKER FUNC math.Yn from math/jn.go:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n  0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: float64\n\nJoker input arguments: [^Int n, ^Double x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__yn(n, x)"}
;;   [^Int n, ^Double x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math"]
    :doc "Provides a low-level interface to the math package."
    :empty false}
  go.std.math)
JOKER TYPE math/big.Accuracy from math/big/float.go:
(defn ^"GoObject" Accuracy.
  "Constructor for big.Accuracy"
  {:added "1.0"
   :go "_ConstructAccuracy(_v)"}
  [^Object _v])

JOKER TYPE math/big.ErrNaN from math/big/float.go:
(defn ^"GoObject" ErrNaN.
  "Constructor for big.ErrNaN"
  {:added "1.0"
   :go "_ConstructErrNaN(_v)"}
  [^Object _v])

JOKER TYPE math/big.Float from math/big/float.go:
(defn ^"GoObject" Float.
  "Constructor for big.Float"
  {:added "1.0"
   :go "_ConstructFloat(_v)"}
  [^Object _v])

JOKER TYPE math/big.Int from math/big/int.go:
(defn ^"GoObject" Int.
  "Constructor for big.Int"
  {:added "1.0"
   :go "_ConstructInt(_v)"}
  [^Object _v])

JOKER TYPE math/big.Rat from math/big/rat.go:
(defn ^"GoObject" Rat.
  "Constructor for big.Rat"
  {:added "1.0"
   :go "_ConstructRat(_v)"}
  [^Object _v])

JOKER TYPE math/big.RoundingMode from math/big/float.go:
(defn ^"GoObject" RoundingMode.
  "Constructor for big.RoundingMode"
  {:added "1.0"
   :go "_ConstructRoundingMode(_v)"}
  [^Object _v])

JOKER TYPE math/big.Word from math/big/arith.go:
(defn ^"GoObject" Word.
  "Constructor for big.Word"
  {:added "1.0"
   :go "_ConstructWord(_v)"}
  [^Object _v])

JOKER FUNC math/big.Jacobi from math/big/int.go:
(defn ^"Int" Jacobi
  "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo input arguments: (x *Int, y *Int)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of go.std.math.big/Int) x, ^(atom-of go.std.math.big/Int) y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "big.Jacobi(x, y)"}
  [^big/Int x, ^big/Int y])

JOKER FUNC math/big.NewFloat from math/big/float.go:
(defn NewFloat
  "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo input arguments: (x float64)\n\nGo return type: *Float\n\nJoker input arguments: [^Double x]\n\nJoker return type: (atom-of go.std.math.big/Float)"
  {:added "1.0"
   :go "__newFloat(x)"}
  [^Double x])

JOKER FUNC math/big.NewInt from math/big/int.go:
(defn NewInt
  "NewInt allocates and returns a new Int set to x.\n\nGo input arguments: (x int64)\n\nGo return type: *Int\n\nJoker input arguments: [^Number x]\n\nJoker return type: (atom-of go.std.math.big/Int)"
  {:added "1.0"
   :go "__newInt(x)"}
  [^Number x])

JOKER FUNC math/big.NewRat from math/big/rat.go:
(defn NewRat
  "NewRat creates a new Rat with numerator a and denominator b.\n\nGo input arguments: (a int64, b int64)\n\nGo return type: *Rat\n\nJoker input arguments: [^Number a, ^Number b]\n\nJoker return type: (atom-of go.std.math.big/Rat)"
  {:added "1.0"
   :go "__newRat(a, b)"}
  [^Number a, ^Number b])

JOKER FUNC math/big.ParseFloat from math/big/floatconv.go:
(defn ParseFloat
  "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo input arguments: (s string, base int, prec uint, mode RoundingMode)\n\nGo return type: (f *Float, b int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Number prec, ^go.std.math.big/RoundingMode mode]\n\nJoker return type: [(atom-of go.std.math.big/Float) Int Error]"
  {:added "1.0"
   :go "__parseFloat(s, base, prec, *mode)"}
  [^String s, ^Int base, ^Number prec, ^big/RoundingMode mode])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/big"]
    :doc "Provides a low-level interface to the math/big package."
    :empty false}
  go.std.math.big)
JOKER FUNC math/bits.Add from math/bits/bits.go:
(defn Add
  "Add returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint, y uint, carry uint)\n\nGo return type: (sum uint, carryOut uint)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add(x, y, carry)"}
  [^Number x, ^Number y, ^Number carry])

JOKER FUNC math/bits.Add32 from math/bits/bits.go:
(defn Add32
  "Add32 returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint32, y uint32, carry uint32)\n\nGo return type: (sum uint32, carryOut uint32)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add32(x, y, carry)"}
  [^Number x, ^Number y, ^Number carry])

JOKER FUNC math/bits.Add64 from math/bits/bits.go:
(defn Add64
  "Add64 returns the sum with carry of x, y and carry: sum = x + y + carry.\nThe carry input must be 0 or 1; otherwise the behavior is undefined.\nThe carryOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint64, y uint64, carry uint64)\n\nGo return type: (sum uint64, carryOut uint64)\n\nJoker input arguments: [^Number x, ^Number y, ^Number carry]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__add64(x, y, carry)"}
  [^Number x, ^Number y, ^Number carry])

JOKER FUNC math/bits.Div from math/bits/bits.go:
(defn Div
  "Div returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint, lo uint, y uint)\n\nGo return type: (quo uint, rem uint)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div(hi, lo, y)"}
  [^Number hi, ^Number lo, ^Number y])

JOKER FUNC math/bits.Div32 from math/bits/bits.go:
(defn Div32
  "Div32 returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv32 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint32, lo uint32, y uint32)\n\nGo return type: (quo uint32, rem uint32)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div32(hi, lo, y)"}
  [^Number hi, ^Number lo, ^Number y])

JOKER FUNC math/bits.Div64 from math/bits/bits.go:
(defn Div64
  "Div64 returns the quotient and remainder of (hi, lo) divided by y:\nquo = (hi, lo)/y, rem = (hi, lo)%y with the dividend bits' upper\nhalf in parameter hi and the lower half in parameter lo.\nDiv64 panics for y == 0 (division by zero) or y <= hi (quotient overflow).\n\nGo input arguments: (hi uint64, lo uint64, y uint64)\n\nGo return type: (quo uint64, rem uint64)\n\nJoker input arguments: [^Number hi, ^Number lo, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__div64(hi, lo, y)"}
  [^Number hi, ^Number lo, ^Number y])

JOKER FUNC math/bits.LeadingZeros from math/bits/bits.go:
(defn ^"Int" LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(x)"}
  [^Number x])

JOKER FUNC math/bits.LeadingZeros16 from math/bits/bits.go:
(defn ^"Int" LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(x)"}
  [^Int x])

JOKER FUNC math/bits.LeadingZeros32 from math/bits/bits.go:
(defn ^"Int" LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(x)"}
  [^Number x])

JOKER FUNC math/bits.LeadingZeros64 from math/bits/bits.go:
(defn ^"Int" LeadingZeros64
  "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros64(x)"}
  [^Number x])

JOKER FUNC math/bits.LeadingZeros8 from math/bits/bits.go:
(defn ^"Int" LeadingZeros8
  "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros8(x)"}
  [^Int x])

JOKER FUNC math/bits.Len from math/bits/bits.go:
(defn ^"Int" Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(x)"}
  [^Number x])

JOKER FUNC math/bits.Len16 from math/bits/bits.go:
(defn ^"Int" Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(x)"}
  [^Int x])

JOKER FUNC math/bits.Len32 from math/bits/bits.go:
(defn ^"Int" Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(x)"}
  [^Number x])

JOKER FUNC math/bits.Len64 from math/bits/bits.go:
(defn ^"Int" Len64
  "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len64(x)"}
  [^Number x])

JOKER FUNC math/bits.Len8 from math/bits/bits.go:
(defn ^"Int" Len8
  "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len8(x)"}
  [^Int x])

JOKER FUNC math/bits.Mul from math/bits/bits.go:
(defn Mul
  "Mul returns the full-width product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint, y uint)\n\nGo return type: (hi uint, lo uint)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul(x, y)"}
  [^Number x, ^Number y])

JOKER FUNC math/bits.Mul32 from math/bits/bits.go:
(defn Mul32
  "Mul32 returns the 64-bit product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint32, y uint32)\n\nGo return type: (hi uint32, lo uint32)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul32(x, y)"}
  [^Number x, ^Number y])

JOKER FUNC math/bits.Mul64 from math/bits/bits.go:
(defn Mul64
  "Mul64 returns the 128-bit product of x and y: (hi, lo) = x * y\nwith the product bits' upper half returned in hi and the lower\nhalf returned in lo.\n\nGo input arguments: (x uint64, y uint64)\n\nGo return type: (hi uint64, lo uint64)\n\nJoker input arguments: [^Number x, ^Number y]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__mul64(x, y)"}
  [^Number x, ^Number y])

JOKER FUNC math/bits.OnesCount from math/bits/bits.go:
(defn ^"Int" OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(x)"}
  [^Number x])

JOKER FUNC math/bits.OnesCount16 from math/bits/bits.go:
(defn ^"Int" OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(x)"}
  [^Int x])

JOKER FUNC math/bits.OnesCount32 from math/bits/bits.go:
(defn ^"Int" OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(x)"}
  [^Number x])

JOKER FUNC math/bits.OnesCount64 from math/bits/bits.go:
(defn ^"Int" OnesCount64
  "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount64(x)"}
  [^Number x])

JOKER FUNC math/bits.OnesCount8 from math/bits/bits.go:
(defn ^"Int" OnesCount8
  "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount8(x)"}
  [^Int x])

JOKER FUNC math/bits.Reverse from math/bits/bits.go:
(defn Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse(x)"}
  [^Number x])

JOKER FUNC math/bits.Reverse16 from math/bits/bits.go:
(defn Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse16(x)"}
  [^Int x])

JOKER FUNC math/bits.Reverse32 from math/bits/bits.go:
(defn Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse32(x)"}
  [^Number x])

JOKER FUNC math/bits.Reverse64 from math/bits/bits.go:
(defn Reverse64
  "Reverse64 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverse64(x)"}
  [^Number x])

JOKER FUNC math/bits.Reverse8 from math/bits/bits.go:
(defn Reverse8
  "Reverse8 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint8)\n\nGo return type: uint8\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverse8(x)"}
  [^Int x])

JOKER FUNC math/bits.ReverseBytes from math/bits/bits.go:
(defn ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: uint\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes(x)"}
  [^Number x])

JOKER FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
(defn ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__reverseBytes16(x)"}
  [^Int x])

JOKER FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
(defn ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes32(x)"}
  [^Number x])

JOKER FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
(defn ReverseBytes64
  "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__reverseBytes64(x)"}
  [^Number x])

JOKER FUNC math/bits.RotateLeft from math/bits/bits.go:
(defn RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo input arguments: (x uint, k int)\n\nGo return type: uint\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft(x, k)"}
  [^Number x, ^Int k])

JOKER FUNC math/bits.RotateLeft16 from math/bits/bits.go:
(defn RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo input arguments: (x uint16, k int)\n\nGo return type: uint16\n\nJoker input arguments: [^Int x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft16(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC math/bits.RotateLeft32 from math/bits/bits.go:
(defn RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo input arguments: (x uint32, k int)\n\nGo return type: uint32\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft32(x, k)"}
  [^Number x, ^Int k])

JOKER FUNC math/bits.RotateLeft64 from math/bits/bits.go:
(defn RotateLeft64
  "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo input arguments: (x uint64, k int)\n\nGo return type: uint64\n\nJoker input arguments: [^Number x, ^Int k]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__rotateLeft64(x, k)"}
  [^Number x, ^Int k])

JOKER FUNC math/bits.RotateLeft8 from math/bits/bits.go:
(defn RotateLeft8
  "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo input arguments: (x uint8, k int)\n\nGo return type: uint8\n\nJoker input arguments: [^Int x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__rotateLeft8(x, k)"}
  [^Int x, ^Int k])

JOKER FUNC math/bits.Sub from math/bits/bits.go:
(defn Sub
  "Sub returns the difference of x, y and borrow: diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint, y uint, borrow uint)\n\nGo return type: (diff uint, borrowOut uint)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub(x, y, borrow)"}
  [^Number x, ^Number y, ^Number borrow])

JOKER FUNC math/bits.Sub32 from math/bits/bits.go:
(defn Sub32
  "Sub32 returns the difference of x, y and borrow, diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint32, y uint32, borrow uint32)\n\nGo return type: (diff uint32, borrowOut uint32)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub32(x, y, borrow)"}
  [^Number x, ^Number y, ^Number borrow])

JOKER FUNC math/bits.Sub64 from math/bits/bits.go:
(defn Sub64
  "Sub64 returns the difference of x, y and borrow: diff = x - y - borrow.\nThe borrow input must be 0 or 1; otherwise the behavior is undefined.\nThe borrowOut output is guaranteed to be 0 or 1.\n\nGo input arguments: (x uint64, y uint64, borrow uint64)\n\nGo return type: (diff uint64, borrowOut uint64)\n\nJoker input arguments: [^Number x, ^Number y, ^Number borrow]\n\nJoker return type: [Number Number]"
  {:added "1.0"
   :go "__sub64(x, y, borrow)"}
  [^Number x, ^Number y, ^Number borrow])

JOKER FUNC math/bits.TrailingZeros from math/bits/bits.go:
(defn ^"Int" TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(x)"}
  [^Number x])

JOKER FUNC math/bits.TrailingZeros16 from math/bits/bits.go:
(defn ^"Int" TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(x)"}
  [^Int x])

JOKER FUNC math/bits.TrailingZeros32 from math/bits/bits.go:
(defn ^"Int" TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(x)"}
  [^Number x])

JOKER FUNC math/bits.TrailingZeros64 from math/bits/bits.go:
(defn ^"Int" TrailingZeros64
  "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^Number x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros64(x)"}
  [^Number x])

JOKER FUNC math/bits.TrailingZeros8 from math/bits/bits.go:
(defn ^"Int" TrailingZeros8
  "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros8(x)"}
  [^Int x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/bits"]
    :doc "Provides a low-level interface to the math/bits package."
    :empty false}
  go.std.math.bits)
JOKER FUNC math/cmplx.Abs from math/cmplx/abs.go:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo input arguments: (x complex128)\n\nGo return type: float64\n\nJoker input arguments: [x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__abs(x)"}
;;   [x])

JOKER FUNC math/cmplx.Acos from math/cmplx/asin.go:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__acos(x)"}
;;   [x])

JOKER FUNC math/cmplx.Acosh from math/cmplx/asin.go:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__acosh(x)"}
;;   [x])

JOKER FUNC math/cmplx.Asin from math/cmplx/asin.go:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__asin(x)"}
;;   [x])

JOKER FUNC math/cmplx.Asinh from math/cmplx/asin.go:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__asinh(x)"}
;;   [x])

JOKER FUNC math/cmplx.Atan from math/cmplx/asin.go:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__atan(x)"}
;;   [x])

JOKER FUNC math/cmplx.Atanh from math/cmplx/asin.go:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__atanh(x)"}
;;   [x])

JOKER FUNC math/cmplx.Conj from math/cmplx/conj.go:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__conj(x)"}
;;   [x])

JOKER FUNC math/cmplx.Cos from math/cmplx/sin.go:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cos(x)"}
;;   [x])

JOKER FUNC math/cmplx.Cosh from math/cmplx/sin.go:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cosh(x)"}
;;   [x])

JOKER FUNC math/cmplx.Cot from math/cmplx/tan.go:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__cot(x)"}
;;   [x])

JOKER FUNC math/cmplx.Exp from math/cmplx/exp.go:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__exp(x)"}
;;   [x])

JOKER FUNC math/cmplx.Inf from math/cmplx/isinf.go:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: complex128\n\nJoker input arguments: []\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__inf()"}
;;   [])

JOKER FUNC math/cmplx.IsInf from math/cmplx/isinf.go:
(defn ^"Boolean" IsInf
  "IsInf reports whether either real(x) or imag(x) is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "cmplx.IsInf(x)"}
  [x])

JOKER FUNC math/cmplx.IsNaN from math/cmplx/isnan.go:
(defn ^"Boolean" IsNaN
  "IsNaN reports whether either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [x]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "cmplx.IsNaN(x)"}
  [x])

JOKER FUNC math/cmplx.Log from math/cmplx/log.go:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__log(x)"}
;;   [x])

JOKER FUNC math/cmplx.Log10 from math/cmplx/log.go:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__log10(x)"}
;;   [x])

JOKER FUNC math/cmplx.NaN from math/cmplx/isnan.go:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: complex128\n\nJoker input arguments: []\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__naN()"}
;;   [])

JOKER FUNC math/cmplx.Phase from math/cmplx/phase.go:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: float64\n\nJoker input arguments: [x]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__phase(x)"}
;;   [x])

JOKER FUNC math/cmplx.Polar from math/cmplx/polar.go:
;; (defn Polar
;;   "Polar returns the absolute value r and phase  of x,\nsuch that x = r * e**i.\nThe phase is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: (r float64,  float64)\n\nJoker input arguments: [x]\n\nJoker return type: [Double Double]"
;;   {:added "1.0"
;;    :go "__polar(x)"}
;;   [x])

JOKER FUNC math/cmplx.Pow from math/cmplx/pow.go:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, 0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo input arguments: (x complex128, y complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x, y]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__pow(x, y)"}
;;   [x, y])

JOKER FUNC math/cmplx.Rect from math/cmplx/rect.go:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, .\n\nGo input arguments: (r float64,  float64)\n\nGo return type: complex128\n\nJoker input arguments: [^Double r, ^Double ]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__rect(r, )"}
;;   [^Double r, ^Double ])

JOKER FUNC math/cmplx.Sin from math/cmplx/sin.go:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sin(x)"}
;;   [x])

JOKER FUNC math/cmplx.Sinh from math/cmplx/sin.go:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sinh(x)"}
;;   [x])

JOKER FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r)  0 and imag(r) has the same sign as imag(x).\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__sqrt(x)"}
;;   [x])

JOKER FUNC math/cmplx.Tan from math/cmplx/tan.go:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__tan(x)"}
;;   [x])

JOKER FUNC math/cmplx.Tanh from math/cmplx/tan.go:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: complex128\n\nJoker input arguments: [x]\n\nJoker return type: ABEND007(find these)"
;;   {:added "1.0"
;;    :go "__tanh(x)"}
;;   [x])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/cmplx"]
    :doc "Provides a low-level interface to the math/cmplx package."
    :empty false}
  go.std.math.cmplx)
JOKER TYPE math/rand.Rand from math/rand/rand.go:
(defn ^"GoObject" Rand.
  "Constructor for rand.Rand"
  {:added "1.0"
   :go "_ConstructRand(_v)"}
  [^Object _v])

JOKER TYPE math/rand.Source from math/rand/rand.go:
;; (defn ^"GoObject" Source.
;;   "Constructor for rand.Source"
;;   {:added "1.0"
;;    :go "_ConstructSource(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Source64 from math/rand/rand.go:
;; (defn ^"GoObject" Source64.
;;   "Constructor for rand.Source64"
;;   {:added "1.0"
;;    :go "_ConstructSource64(_v)"}
;;   [^Object _v])

JOKER TYPE math/rand.Zipf from math/rand/zipf.go:
(defn ^"GoObject" Zipf.
  "Constructor for rand.Zipf"
  {:added "1.0"
   :go "_ConstructZipf(_v)"}
  [^Object _v])

JOKER FUNC math/rand.ExpFloat64 from math/rand/rand.go:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__expFloat64()"}
;;   [])

JOKER FUNC math/rand.Float32 from math/rand/rand.go:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float32\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float32()"}
;;   [])

JOKER FUNC math/rand.Float64 from math/rand/rand.go:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__float64()"}
;;   [])

JOKER FUNC math/rand.Int from math/rand/rand.go:
(defn ^"Int" Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC math/rand.Int31 from math/rand/rand.go:
(defn Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int32\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31()"}
  [])

JOKER FUNC math/rand.Int31n from math/rand/rand.go:
(defn Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int32)\n\nGo return type: int32\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "__int31n(n)"}
  [^Int n])

JOKER FUNC math/rand.Int63 from math/rand/rand.go:
(defn Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__int63()"}
  [])

JOKER FUNC math/rand.Int63n from math/rand/rand.go:
(defn Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int64)\n\nGo return type: int64\n\nJoker input arguments: [^Number n]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__int63n(n)"}
  [^Number n])

JOKER FUNC math/rand.Intn from math/rand/rand.go:
(defn ^"Int" Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(n)"}
  [^Int n])

JOKER FUNC math/rand.New from math/rand/rand.go:
(defn New
  "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo input arguments: (src Source)\n\nGo return type: *Rand\n\nJoker input arguments: [^go.std.math.rand/Source src]\n\nJoker return type: (atom-of go.std.math.rand/Rand)"
  {:added "1.0"
   :go "__new(*src)"}
  [^rand/Source src])

JOKER FUNC math/rand.NewSource from math/rand/rand.go:
(defn NewSource
  "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo input arguments: (seed int64)\n\nGo return type: Source\n\nJoker input arguments: [^Number seed]\n\nJoker return type: go.std.math.rand/Source"
  {:added "1.0"
   :go "__newSource(seed)"}
  [^Number seed])

JOKER FUNC math/rand.NewZipf from math/rand/zipf.go:
(defn NewZipf
  "NewZipf returns a Zipf variate generator.\nThe generator generates values k  [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo input arguments: (r *Rand, s float64, v float64, imax uint64)\n\nGo return type: *Zipf\n\nJoker input arguments: [^(atom-of go.std.math.rand/Rand) r, ^Double s, ^Double v, ^Number imax]\n\nJoker return type: (atom-of go.std.math.rand/Zipf)"
  {:added "1.0"
   :go "__newZipf(r, s, v, imax)"}
  [^rand/Rand r, ^Double s, ^Double v, ^Number imax])

JOKER FUNC math/rand.NormFloat64 from math/rand/rand.go:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__normFloat64()"}
;;   [])

JOKER FUNC math/rand.Perm from math/rand/rand.go:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo input arguments: (n int)\n\nGo return type: []int\n\nJoker input arguments: [^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__perm(n)"}
  [^Int n])

JOKER FUNC math/rand.Read from math/rand/rand.go:
;; (defn Read
;;   "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo input arguments: (p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC math/rand.Seed from math/rand/rand.go:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n\nGo input arguments: (seed int64)\n\nJoker input arguments: [^Number seed]"
;;   {:added "1.0"
;;    :go "__seed(seed)"}
;;   [^Number seed])

JOKER FUNC math/rand.Shuffle from math/rand/rand.go:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n\nGo input arguments: (n int, swap func)\n\nJoker input arguments: [^Int n, ^fn swap]"
;;   {:added "1.0"
;;    :go "__shuffle(n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int n, ^fn swap])

JOKER FUNC math/rand.Uint32 from math/rand/rand.go:
(defn Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: uint32\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__uint32()"}
  [])

JOKER FUNC math/rand.Uint64 from math/rand/rand.go:
(defn Uint64
  "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: uint64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__uint64()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["math/rand"]
    :doc "Provides a low-level interface to the math/rand package."
    :empty false}
  go.std.math.rand)
JOKER TYPE mime.WordDecoder from mime/encodedword.go:
;; (defn ^"GoObject" WordDecoder.
;;   "Constructor for mime.WordDecoder"
;;   {:added "1.0"
;;    :go "_ConstructWordDecoder(_v)"}
;;   [^Object _v])

JOKER TYPE mime.WordEncoder from mime/encodedword.go:
(defn ^"GoObject" WordEncoder.
  "Constructor for mime.WordEncoder"
  {:added "1.0"
   :go "_ConstructWordEncoder(_v)"}
  [^Object _v])

JOKER FUNC mime.AddExtensionType from mime/type.go:
(defn ^"Error" AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo input arguments: (ext string, typ string)\n\nGo return type: error\n\nJoker input arguments: [^String ext, ^String typ]\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(ext, typ)"}
  [^String ext, ^String typ])

JOKER FUNC mime.ExtensionsByType from mime/type.go:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo input arguments: (typ string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String typ]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__extensionsByType(typ)"}
  [^String typ])

JOKER FUNC mime.FormatMediaType from mime/mediatype.go:
;; (defn ^"String" FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo input arguments: (t string, param map[])\n\nGo return type: string\n\nJoker input arguments: [^String t, ^{} param]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(t, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^String t, ^{} param])

JOKER FUNC mime.ParseMediaType from mime/mediatype.go:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo input arguments: (v string)\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker input arguments: [^String v]\n\nJoker return type: [String ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/mime/mediatype.go:112:57) Error]"
;;   {:added "1.0"
;;    :go "__parseMediaType(v)"}
;;   [^String v])

JOKER FUNC mime.TypeByExtension from mime/type.go:
(defn ^"String" TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo input arguments: (ext string)\n\nGo return type: string\n\nJoker input arguments: [^String ext]\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(ext)"}
  [^String ext])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["mime"]
    :doc "Provides a low-level interface to the mime package."
    :empty false}
  go.std.mime)
JOKER TYPE mime/multipart.File from mime/multipart/formdata.go:
;; (defn ^"GoObject" File.
;;   "Constructor for multipart.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.FileHeader from mime/multipart/formdata.go:
;; (defn ^"GoObject" FileHeader.
;;   "Constructor for multipart.FileHeader"
;;   {:added "1.0"
;;    :go "_ConstructFileHeader(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Form from mime/multipart/formdata.go:
;; (defn ^"GoObject" Form.
;;   "Constructor for multipart.Form"
;;   {:added "1.0"
;;    :go "_ConstructForm(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Part from mime/multipart/multipart.go:
;; (defn ^"GoObject" Part.
;;   "Constructor for multipart.Part"
;;   {:added "1.0"
;;    :go "_ConstructPart(_v)"}
;;   [^Object _v])

JOKER TYPE mime/multipart.Reader from mime/multipart/multipart.go:
(defn ^"GoObject" Reader.
  "Constructor for multipart.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE mime/multipart.Writer from mime/multipart/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for multipart.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo input arguments: (r io.Reader, boundary string)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r, ^String boundary]\n\nJoker return type: (atom-of go.std.mime.multipart/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*r, boundary)"}
;;   [^io/Reader r, ^String boundary])

JOKER FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.multipart/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the mime/multipart package."
    :empty false}
  go.std.mime.multipart)
JOKER TYPE mime/quotedprintable.Reader from mime/quotedprintable/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for quotedprintable.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE mime/quotedprintable.Writer from mime/quotedprintable/writer.go:
(defn ^"GoObject" Writer.
  "Constructor for quotedprintable.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: (atom-of go.std.mime.quotedprintable/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the mime/quotedprintable package."
    :empty false}
  go.std.mime.quotedprintable)
JOKER TYPE net.Addr from net/net.go:
;; (defn ^"GoObject" Addr.
;;   "Constructor for net.Addr"
;;   {:added "1.0"
;;    :go "_ConstructAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.AddrError from net/net.go:
(defn ^"GoObject" AddrError.
  "Constructor for net.AddrError"
  {:added "1.0"
   :go "_ConstructAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.Buffers from net/net.go:
;; (defn ^"GoObject" Buffers.
;;   "Constructor for net.Buffers"
;;   {:added "1.0"
;;    :go "_ConstructBuffers(_v)"}
;;   [^Object _v])

JOKER TYPE net.Conn from net/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for net.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.DNSConfigError from net/net.go:
(defn ^"GoObject" DNSConfigError.
  "Constructor for net.DNSConfigError"
  {:added "1.0"
   :go "_ConstructDNSConfigError(_v)"}
  [^Object _v])

JOKER TYPE net.DNSError from net/net.go:
(defn ^"GoObject" DNSError.
  "Constructor for net.DNSError"
  {:added "1.0"
   :go "_ConstructDNSError(_v)"}
  [^Object _v])

JOKER TYPE net.Dialer from net/dial.go:
;; (defn ^"GoObject" Dialer.
;;   "Constructor for net.Dialer"
;;   {:added "1.0"
;;    :go "_ConstructDialer(_v)"}
;;   [^Object _v])

JOKER TYPE net.Error from net/net.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for net.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE net.Flags from net/interface.go:
(defn ^"GoObject" Flags.
  "Constructor for net.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE net.HardwareAddr from net/mac.go:
;; (defn ^"GoObject" HardwareAddr.
;;   "Constructor for net.HardwareAddr"
;;   {:added "1.0"
;;    :go "_ConstructHardwareAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IP from net/ip.go:
;; (defn ^"GoObject" IP.
;;   "Constructor for net.IP"
;;   {:added "1.0"
;;    :go "_ConstructIP(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPAddr from net/iprawsock.go:
;; (defn ^"GoObject" IPAddr.
;;   "Constructor for net.IPAddr"
;;   {:added "1.0"
;;    :go "_ConstructIPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPConn from net/iprawsock.go:
(defn ^"GoObject" IPConn.
  "Constructor for net.IPConn"
  {:added "1.0"
   :go "_ConstructIPConn(_v)"}
  [^Object _v])

JOKER TYPE net.IPMask from net/ip.go:
;; (defn ^"GoObject" IPMask.
;;   "Constructor for net.IPMask"
;;   {:added "1.0"
;;    :go "_ConstructIPMask(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPNet from net/ip.go:
;; (defn ^"GoObject" IPNet.
;;   "Constructor for net.IPNet"
;;   {:added "1.0"
;;    :go "_ConstructIPNet(_v)"}
;;   [^Object _v])

JOKER TYPE net.Interface from net/interface.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for net.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE net.InvalidAddrError from net/net.go:
(defn ^"GoObject" InvalidAddrError.
  "Constructor for net.InvalidAddrError"
  {:added "1.0"
   :go "_ConstructInvalidAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.ListenConfig from net/dial.go:
;; (defn ^"GoObject" ListenConfig.
;;   "Constructor for net.ListenConfig"
;;   {:added "1.0"
;;    :go "_ConstructListenConfig(_v)"}
;;   [^Object _v])

JOKER TYPE net.Listener from net/net.go:
;; (defn ^"GoObject" Listener.
;;   "Constructor for net.Listener"
;;   {:added "1.0"
;;    :go "_ConstructListener(_v)"}
;;   [^Object _v])

JOKER TYPE net.MX from net/dnsclient.go:
(defn ^"GoObject" MX.
  "Constructor for net.MX"
  {:added "1.0"
   :go "_ConstructMX(_v)"}
  [^Object _v])

JOKER TYPE net.NS from net/dnsclient.go:
(defn ^"GoObject" NS.
  "Constructor for net.NS"
  {:added "1.0"
   :go "_ConstructNS(_v)"}
  [^Object _v])

JOKER TYPE net.OpError from net/net.go:
;; (defn ^"GoObject" OpError.
;;   "Constructor for net.OpError"
;;   {:added "1.0"
;;    :go "_ConstructOpError(_v)"}
;;   [^Object _v])

JOKER TYPE net.PacketConn from net/net.go:
;; (defn ^"GoObject" PacketConn.
;;   "Constructor for net.PacketConn"
;;   {:added "1.0"
;;    :go "_ConstructPacketConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.ParseError from net/net.go:
(defn ^"GoObject" ParseError.
  "Constructor for net.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE net.Resolver from net/lookup.go:
;; (defn ^"GoObject" Resolver.
;;   "Constructor for net.Resolver"
;;   {:added "1.0"
;;    :go "_ConstructResolver(_v)"}
;;   [^Object _v])

JOKER TYPE net.SRV from net/dnsclient.go:
(defn ^"GoObject" SRV.
  "Constructor for net.SRV"
  {:added "1.0"
   :go "_ConstructSRV(_v)"}
  [^Object _v])

JOKER TYPE net.TCPAddr from net/tcpsock.go:
;; (defn ^"GoObject" TCPAddr.
;;   "Constructor for net.TCPAddr"
;;   {:added "1.0"
;;    :go "_ConstructTCPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.TCPConn from net/tcpsock.go:
(defn ^"GoObject" TCPConn.
  "Constructor for net.TCPConn"
  {:added "1.0"
   :go "_ConstructTCPConn(_v)"}
  [^Object _v])

JOKER TYPE net.TCPListener from net/tcpsock.go:
(defn ^"GoObject" TCPListener.
  "Constructor for net.TCPListener"
  {:added "1.0"
   :go "_ConstructTCPListener(_v)"}
  [^Object _v])

JOKER TYPE net.UDPAddr from net/udpsock.go:
;; (defn ^"GoObject" UDPAddr.
;;   "Constructor for net.UDPAddr"
;;   {:added "1.0"
;;    :go "_ConstructUDPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.UDPConn from net/udpsock.go:
(defn ^"GoObject" UDPConn.
  "Constructor for net.UDPConn"
  {:added "1.0"
   :go "_ConstructUDPConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixAddr from net/unixsock.go:
(defn ^"GoObject" UnixAddr.
  "Constructor for net.UnixAddr"
  {:added "1.0"
   :go "_ConstructUnixAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UnixConn from net/unixsock.go:
(defn ^"GoObject" UnixConn.
  "Constructor for net.UnixConn"
  {:added "1.0"
   :go "_ConstructUnixConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixListener from net/unixsock.go:
(defn ^"GoObject" UnixListener.
  "Constructor for net.UnixListener"
  {:added "1.0"
   :go "_ConstructUnixListener(_v)"}
  [^Object _v])

JOKER TYPE net.UnknownNetworkError from net/net.go:
(defn ^"GoObject" UnknownNetworkError.
  "Constructor for net.UnknownNetworkError"
  {:added "1.0"
   :go "_ConstructUnknownNetworkError(_v)"}
  [^Object _v])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(ones, bits)"}
  [^Int ones, ^Int bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "__dial(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(network, laddr, raddr)"}
  [^String network, ^net/IPAddr laddr, ^net/IPAddr raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
  {:added "1.0"
   :go "__dialTCP(network, laddr, raddr)"}
  [^String network, ^net/TCPAddr laddr, ^net/TCPAddr raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__dialTimeout(network, address, *timeout)"}
;;   [^String network, ^String address, ^time/Duration timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__dialUDP(network, laddr, raddr)"}
  [^String network, ^net/UDPAddr laddr, ^net/UDPAddr raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__dialUnix(network, laddr, raddr)"}
  [^String network, ^net/UnixAddr laddr, ^net/UnixAddr raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__fileConn(f)"}
;;   [^os/File f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "__fileListener(f)"}
;;   [^os/File f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "__filePacketConn(f)"}
;;   [^os/File f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(a, b, c, d)"}
  [^Int a, ^Int b, ^Int c, ^Int d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(a, b, c, d)"}
  [^Int a, ^Int b, ^Int c, ^Int d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "__interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByIndex(index)"}
  [^Int index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByName(name)"}
  [^String name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(host, port)"}
  [^String host, ^String port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(network, laddr)"}
  [^String network, ^net/IPAddr laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenMulticastUDP(network, ifi, gaddr)"}
  [^String network, ^net/Interface ifi, ^net/UDPAddr gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "__listenPacket(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
  {:added "1.0"
   :go "__listenTCP(network, laddr)"}
  [^String network, ^net/TCPAddr laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenUDP(network, laddr)"}
  [^String network, ^net/UDPAddr laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
  {:added "1.0"
   :go "__listenUnix(network, laddr)"}
  [^String network, ^net/UnixAddr laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__listenUnixgram(network, laddr)"}
  [^String network, ^net/UnixAddr laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(addr)"}
  [^String addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(host)"}
  [^String host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(host)"}
  [^String host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(host)"}
  [^String host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(name)"}
  [^String name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(name)"}
  [^String name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(network, service)"}
  [^String network, ^String service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(service, proto, name)"}
  [^String service, ^String proto, ^String name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(name)"}
  [^String name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(s)"}
  [^String s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(s)"}
  [^String s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "__parseMAC(s)"}
  [^String s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "__resolveTCPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "__resolveUDPAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "__resolveUnixAddr(network, address)"}
  [^String network, ^String address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "__splitHostPort(hostport)"}
  [^String hostport])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net"]
    :doc "Provides a low-level interface to the net package."
    :empty false}
  go.std.net)
JOKER TYPE net/http.Client from net/http/client.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for http.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CloseNotifier from net/http/server.go:
;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ConnState from net/http/server.go:
(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

JOKER TYPE net/http.Cookie from net/http/cookie.go:
;; (defn ^"GoObject" Cookie.
;;   "Constructor for http.Cookie"
;;   {:added "1.0"
;;    :go "_ConstructCookie(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CookieJar from net/http/jar.go:
;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Dir from net/http/fs.go:
(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

JOKER TYPE net/http.File from net/http/fs.go:
;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.FileSystem from net/http/fs.go:
;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Flusher from net/http/server.go:
;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Handler from net/http/server.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.HandlerFunc from net/http/server.go:
;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Header from net/http/header.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Hijacker from net/http/server.go:
;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ProtocolError from net/http/request.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/http.PushOptions from net/http/http.go:
;; (defn ^"GoObject" PushOptions.
;;   "Constructor for http.PushOptions"
;;   {:added "1.0"
;;    :go "_ConstructPushOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Pusher from net/http/http.go:
;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Request from net/http/request.go:
;; (defn ^"GoObject" Request.
;;   "Constructor for http.Request"
;;   {:added "1.0"
;;    :go "_ConstructRequest(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Response from net/http/response.go:
;; (defn ^"GoObject" Response.
;;   "Constructor for http.Response"
;;   {:added "1.0"
;;    :go "_ConstructResponse(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ResponseWriter from net/http/server.go:
;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.RoundTripper from net/http/client.go:
;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.SameSite from net/http/cookie.go:
(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

JOKER TYPE net/http.ServeMux from net/http/server.go:
(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

JOKER TYPE net/http.Server from net/http/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for http.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Transport from net/http/transport.go:
;; (defn ^"GoObject" Transport.
;;   "Constructor for http.Transport"
;;   {:added "1.0"
;;    :go "_ConstructTransport(_v)"}
;;   [^Object _v])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(s)"}
  [^String s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^Object data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*w, error, code)"}
;;   [^http/ResponseWriter w, ^String error, ^Int code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*root)"}
  [^http/FileSystem root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(url)"}
  [^String url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(pattern, *handler)"}
;;   [^String pattern, ^http/Handler handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String pattern, ^fn handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(url)"}
  [^String url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(addr, *handler)"}
  [^String addr, ^http/Handler handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(addr, certFile, keyFile, *handler)"}
  [^String addr, ^String certFile, ^String keyFile, ^http/Handler handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: io.ReadCloser\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Number n]\n\nJoker return type: go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*w, *r, n)"}
;;   [^http/ResponseWriter w, ^io/ReadCloser r, ^Number n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*fs)"}
  [^http/FileSystem fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(method, url, *body)"}
;;   [^String method, ^String url, ^io/Reader body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(vers)"}
  [^String vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t time.Time, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseTime(text)"}
  [^String text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(url, contentType, *body)"}
;;   [^String url, ^String contentType, ^io/Reader body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(url, *data)"}
;;   [^String url, ^url/Values data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(req)"}
  [^http/Request req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go/src/net/http/transport.go:352:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(fixedURL)"}
;;   [^url/URL fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(b)"}
;;   [^bufio/Reader b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(r, req)"}
;;   [^bufio/Reader r, ^http/Request req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*w, r, url, code)"}
;;   [^http/ResponseWriter w, ^http/Request r, ^String url, ^Int code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(url, code)"}
  [^String url, ^Int code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*l, *handler)"}
;;   [^net/Listener l, ^http/Handler handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*w, req, name, *modtime, *content)"}
;;   [^http/ResponseWriter w, ^http/Request req, ^String name, ^time/Time modtime, ^io/ReadSeeker content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*w, r, name)"}
;;   [^http/ResponseWriter w, ^http/Request r, ^String name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*l, *handler, certFile, keyFile)"}
;;   [^net/Listener l, ^http/Handler handler, ^String certFile, ^String keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*w, cookie)"}
;;   [^http/ResponseWriter w, ^http/Cookie cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(code)"}
  [^Int code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(prefix, *h)"}
  [^String prefix, ^http/Handler h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*h, *dt, msg)"}
;;   [^http/Handler h, ^time/Duration dt, ^String msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/http"]
    :doc "Provides a low-level interface to the net/http package."
    :empty false}
  go.std.net.http)
JOKER TYPE net/http/cgi.Handler from net/http/cgi/host.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for cgi.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "__request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__requestFromMap(ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(*handler)"}
;;   [^http/Handler handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cgi package."
    :empty false}
  go.std.net.http.cgi)
JOKER TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
(defn ^"GoObject" Jar.
  "Constructor for cookiejar.Jar"
  {:added "1.0"
   :go "_ConstructJar(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" Options.
;;   "Constructor for cookiejar.Options"
;;   {:added "1.0"
;;    :go "_ConstructOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" PublicSuffixList.
;;   "Constructor for cookiejar.PublicSuffixList"
;;   {:added "1.0"
;;    :go "_ConstructPublicSuffixList(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
  {:added "1.0"
   :go "__new(o)"}
  [^cookiejar/Options o])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/cookiejar package."
    :empty false}
  go.std.net.http.cookiejar)
JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "__processEnv(r)"}
;;   [^http/Request r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(*l, *handler)"}
;;   [^net/Listener l, ^http/Handler handler])

JOKER TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
;; (defn ^"GoObject" ResponseRecorder.
;;   "Constructor for httptest.ResponseRecorder"
;;   {:added "1.0"
;;    :go "_ConstructResponseRecorder(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptest.Server from net/http/httptest/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for httptest.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "__newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "__newRequest(method, target, *body)"}
;;   [^String method, ^String target, ^io/Reader body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newServer(*handler)"}
;;   [^http/Handler handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newTLSServer(*handler)"}
;;   [^http/Handler handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newUnstartedServer(*handler)"}
;;   [^http/Handler handler])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/httptest package."
    :empty false}
  go.std.net.http.httptest)
JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "__contextClientTrace(*ctx)"}
;;   [^context/Context ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withClientTrace(*ctx, trace)"}
;;   [^context/Context ctx, ^httptrace/ClientTrace trace])

JOKER TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" BufferPool.
;;   "Constructor for httputil.BufferPool"
;;   {:added "1.0"
;;    :go "_ConstructBufferPool(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
(defn ^"GoObject" ClientConn.
  "Constructor for httputil.ClientConn"
  {:added "1.0"
   :go "_ConstructClientConn(_v)"}
  [^Object _v])

JOKER TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" ReverseProxy.
;;   "Constructor for httputil.ReverseProxy"
;;   {:added "1.0"
;;    :go "_ConstructReverseProxy(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
(defn ^"GoObject" ServerConn.
  "Constructor for httputil.ServerConn"
  {:added "1.0"
   :go "_ConstructServerConn(_v)"}
  [^Object _v])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequest(req, body)"}
;;   [^http/Request req, ^Boolean body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequestOut(req, body)"}
;;   [^http/Request req, ^Boolean body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpResponse(resp, body)"}
;;   [^http/Response resp, ^Boolean body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newChunkedReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: io.WriteCloser\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "__newChunkedWriter(*w)"}
;;   [^io/Writer w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newClientConn(*c, r)"}
;;   [^net/Conn c, ^bufio/Reader r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newProxyClientConn(*c, r)"}
;;   [^net/Conn c, ^bufio/Reader r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "__newServerConn(*c, r)"}
;;   [^net/Conn c, ^bufio/Reader r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "__newSingleHostReverseProxy(target)"}
;;   [^url/URL target])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/httputil package."
    :empty false}
  go.std.net.http.httputil)
JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__cmdline(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler(name)"}
  [^String name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__index(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__profile(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__symbol(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__trace(*w, r)"}
;;   [^http/ResponseWriter w, ^http/Request r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/http/pprof package."
    :empty false}
  go.std.net.http.pprof)
JOKER TYPE net/mail.Address from net/mail/message.go:
(defn ^"GoObject" Address.
  "Constructor for mail.Address"
  {:added "1.0"
   :go "_ConstructAddress(_v)"}
  [^Object _v])

JOKER TYPE net/mail.AddressParser from net/mail/message.go:
;; (defn ^"GoObject" AddressParser.
;;   "Constructor for mail.AddressParser"
;;   {:added "1.0"
;;    :go "_ConstructAddressParser(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Header from net/mail/message.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for mail.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Message from net/mail/message.go:
;; (defn ^"GoObject" Message.
;;   "Constructor for mail.Message"
;;   {:added "1.0"
;;    :go "_ConstructMessage(_v)"}
;;   [^Object _v])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "__parseAddress(address)"}
  [^String address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "__parseAddressList(list)"}
  [^String list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
(defn ParseDate
  "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (time.Time, error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseDate(date)"}
  [^String date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "__readMessage(*r)"}
;;   [^io/Reader r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/mail package."
    :empty false}
  go.std.net.mail)
JOKER TYPE net/rpc.Call from net/rpc/client.go:
;; (defn ^"GoObject" Call.
;;   "Constructor for rpc.Call"
;;   {:added "1.0"
;;    :go "_ConstructCall(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Client from net/rpc/client.go:
(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ClientCodec from net/rpc/client.go:
;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Request from net/rpc/server.go:
(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Response from net/rpc/server.go:
(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Server from net/rpc/server.go:
(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ServerCodec from net/rpc/server.go:
;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.ServerError from net/rpc/client.go:
(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*lis)"}
;;   [^net/Listener lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(network, address)"}
  [^String network, ^String address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(network, address)"}
  [^String network, ^String address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(network, address, path)"}
  [^String network, ^String address, ^String path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*codec)"}
  [^rpc/ClientCodec codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String name, ^<protocol-or-something> rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*codec)"}
;;   [^rpc/ServerCodec codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*codec)"}
  [^rpc/ServerCodec codec])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/rpc"]
    :doc "Provides a low-level interface to the net/rpc package."
    :empty false}
  go.std.net.rpc)
JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(network, address)"}
  [^String network, ^String address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "__newClientCodec(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "__newServerCodec(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*conn)"}
;;   [^io/ReadWriteCloser conn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/rpc/jsonrpc package."
    :empty false}
  go.std.net.rpc.jsonrpc)
JOKER TYPE net/smtp.Auth from net/smtp/auth.go:
;; (defn ^"GoObject" Auth.
;;   "Constructor for smtp.Auth"
;;   {:added "1.0"
;;    :go "_ConstructAuth(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.Client from net/smtp/smtp.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for smtp.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.ServerInfo from net/smtp/auth.go:
;; (defn ^"GoObject" ServerInfo.
;;   "Constructor for smtp.ServerInfo"
;;   {:added "1.0"
;;    :go "_ConstructServerInfo(_v)"}
;;   [^Object _v])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__cRAMMD5Auth(username, secret)"}
  [^String username, ^String secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "__dial(addr)"}
  [^String addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "__newClient(*conn, host)"}
;;   [^net/Conn conn, ^String host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__plainAuth(identity, username, password, host)"}
  [^String identity, ^String username, ^String password, ^String host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Int) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(addr, *a, from, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(to)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(msg)))"}
;;   [^String addr, ^smtp/Auth a, ^String from, ^Object to, ^Object msg])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the net/smtp package."
    :empty false}
  go.std.net.smtp)
JOKER TYPE net/textproto.Conn from net/textproto/textproto.go:
(defn ^"GoObject" Conn.
  "Constructor for textproto.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Error from net/textproto/textproto.go:
(defn ^"GoObject" Error.
  "Constructor for textproto.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.MIMEHeader from net/textproto/header.go:
;; (defn ^"GoObject" MIMEHeader.
;;   "Constructor for textproto.MIMEHeader"
;;   {:added "1.0"
;;    :go "_ConstructMIMEHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
(defn ^"GoObject" Pipeline.
  "Constructor for textproto.Pipeline"
  {:added "1.0"
   :go "_ConstructPipeline(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for textproto.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Reader from net/textproto/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for textproto.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Writer from net/textproto/writer.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for textproto.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(s)"}
  [^String s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "__dial(network, addr)"}
  [^String network, ^String addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "__newConn(*conn)"}
;;   [^io/ReadWriteCloser conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(r)"}
;;   [^bufio/Reader r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(w)"}
;;   [^bufio/Writer w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(s)"}
  [^String s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/textproto"]
    :doc "Provides a low-level interface to the net/textproto package."
    :empty false}
  go.std.net.textproto)
JOKER TYPE net/url.Error from net/url/url.go:
(defn ^"GoObject" Error.
  "Constructor for url.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/url.EscapeError from net/url/url.go:
(defn ^"GoObject" EscapeError.
  "Constructor for url.EscapeError"
  {:added "1.0"
   :go "_ConstructEscapeError(_v)"}
  [^Object _v])

JOKER TYPE net/url.InvalidHostError from net/url/url.go:
(defn ^"GoObject" InvalidHostError.
  "Constructor for url.InvalidHostError"
  {:added "1.0"
   :go "_ConstructInvalidHostError(_v)"}
  [^Object _v])

JOKER TYPE net/url.URL from net/url/url.go:
;; (defn ^"GoObject" URL.
;;   "Constructor for url.URL"
;;   {:added "1.0"
;;    :go "_ConstructURL(_v)"}
;;   [^Object _v])

JOKER TYPE net/url.Userinfo from net/url/url.go:
(defn ^"GoObject" Userinfo.
  "Constructor for url.Userinfo"
  {:added "1.0"
   :go "_ConstructUserinfo(_v)"}
  [^Object _v])

JOKER TYPE net/url.Values from net/url/url.go:
;; (defn ^"GoObject" Values.
;;   "Constructor for url.Values"
;;   {:added "1.0"
;;    :go "_ConstructValues(_v)"}
;;   [^Object _v])

JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(rawurl)"}
  [^String rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(query)"}
  [^String query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(rawurl)"}
  [^String rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(s)"}
  [^String s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(s)"}
  [^String s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(s)"}
  [^String s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(s)"}
  [^String s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(username)"}
  [^String username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(username, password)"}
  [^String username, ^String password])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["net/url"]
    :doc "Provides a low-level interface to the net/url package."
    :empty false}
  go.std.net.url)
JOKER TYPE os.File from os/types.go:
(defn ^"GoObject" File.
  "Constructor for os.File"
  {:added "1.0"
   :go "_ConstructFile(_v)"}
  [^Object _v])

JOKER TYPE os.FileInfo from os/types.go:
;; (defn ^"GoObject" FileInfo.
;;   "Constructor for os.FileInfo"
;;   {:added "1.0"
;;    :go "_ConstructFileInfo(_v)"}
;;   [^Object _v])

JOKER TYPE os.FileMode from os/types.go:
(defn ^"GoObject" FileMode.
  "Constructor for os.FileMode"
  {:added "1.0"
   :go "_ConstructFileMode(_v)"}
  [^Object _v])

JOKER TYPE os.LinkError from os/file.go:
(defn ^"GoObject" LinkError.
  "Constructor for os.LinkError"
  {:added "1.0"
   :go "_ConstructLinkError(_v)"}
  [^Object _v])

JOKER TYPE os.PathError from os/error.go:
(defn ^"GoObject" PathError.
  "Constructor for os.PathError"
  {:added "1.0"
   :go "_ConstructPathError(_v)"}
  [^Object _v])

JOKER TYPE os.ProcAttr from os/exec.go:
;; (defn ^"GoObject" ProcAttr.
;;   "Constructor for os.ProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE os.Process from os/exec.go:
(defn ^"GoObject" Process.
  "Constructor for os.Process"
  {:added "1.0"
   :go "_ConstructProcess(_v)"}
  [^Object _v])

JOKER TYPE os.ProcessState from os/exec_posix.go:
(defn ^"GoObject" ProcessState.
  "Constructor for os.ProcessState"
  {:added "1.0"
   :go "_ConstructProcessState(_v)"}
  [^Object _v])

JOKER TYPE os.Signal from os/exec.go:
;; (defn ^"GoObject" Signal.
;;   "Constructor for os.Signal"
;;   {:added "1.0"
;;    :go "_ConstructSignal(_v)"}
;;   [^Object _v])

JOKER TYPE os.SyscallError from os/error.go:
(defn ^"GoObject" SyscallError.
  "Constructor for os.SyscallError"
  {:added "1.0"
   :go "_ConstructSyscallError(_v)"}
  [^Object _v])

JOKER FUNC os.Chdir from os/file.go:
(defn ^"Error" Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (dir string)\n\nGo return type: error\n\nJoker input arguments: [^String dir]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(dir)"}
  [^String dir])

JOKER FUNC os.Chmod from os/file.go:
(defn ^"Error" Chmod
  "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo input arguments: (name string, mode FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chmod(name, *mode)"}
  [^String name, ^os/FileMode mode])

JOKER FUNC os.Chown from os/file_posix.go:
(defn ^"Error" Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Chtimes from os/file_posix.go:
;; (defn ^"Error" Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, atime time.Time, mtime time.Time)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.time/Time atime, ^go.std.time/Time mtime]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(name, *atime, *mtime)"}
;;   [^String name, ^time/Time atime, ^time/Time mtime])

JOKER FUNC os.Clearenv from os/env.go:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC os.Create from os/file.go:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__create(name)"}
  [^String name])

JOKER FUNC os.Environ from os/env.go:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC os.Executable from os/executable.go:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__executable()"}
  [])

JOKER FUNC os.Exit from os/proc.go:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n\nGo input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(code)"}
;;   [^Int code])

JOKER FUNC os.Expand from os/env.go:
;; (defn ^"String" Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo input arguments: (s string, mapping func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn mapping]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn mapping])

JOKER FUNC os.ExpandEnv from os/env.go:
(defn ^"String" ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(s)"}
  [^String s])

JOKER FUNC os.FindProcess from os/exec.go:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo input arguments: (pid int)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
  {:added "1.0"
   :go "__findProcess(pid)"}
  [^Int pid])

JOKER FUNC os.Getegid from os/proc.go:
(defn ^"Int" Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv from os/env.go:
(defn ^"String" Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo input arguments: (key string)\n\nGo return type: string\n\nJoker input arguments: [^String key]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(key)"}
  [^String key])

JOKER FUNC os.Geteuid from os/proc.go:
(defn ^"Int" Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid from os/proc.go:
(defn ^"Int" Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups from os/proc.go:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC os.Getpagesize from os/types.go:
(defn ^"Int" Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid from os/exec.go:
(defn ^"Int" Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid from os/exec.go:
(defn ^"Int" Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid from os/proc.go:
(defn ^"Int" Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd from os/getwd.go:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC os.Hostname from os/sys.go:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__hostname()"}
  [])

JOKER FUNC os.IsExist from os/error.go:
(defn ^"Boolean" IsExist
  "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsExist(err)"}
  [^Error err])

JOKER FUNC os.IsNotExist from os/error.go:
(defn ^"Boolean" IsNotExist
  "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsNotExist(err)"}
  [^Error err])

JOKER FUNC os.IsPathSeparator from os/path_unix.go:
(defn ^"Boolean" IsPathSeparator
  "IsPathSeparator reports whether c is a directory separator character.\n\nGo input arguments: (c uint8)\n\nGo return type: bool\n\nJoker input arguments: [^Int c]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsPathSeparator(c)"}
  [^Int c])

JOKER FUNC os.IsPermission from os/error.go:
(defn ^"Boolean" IsPermission
  "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsPermission(err)"}
  [^Error err])

JOKER FUNC os.IsTimeout from os/error.go:
(defn ^"Boolean" IsTimeout
  "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^Error err]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.IsTimeout(err)"}
  [^Error err])

JOKER FUNC os.Lchown from os/file_posix.go:
(defn ^"Error" Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(name, uid, gid)"}
  [^String name, ^Int uid, ^Int gid])

JOKER FUNC os.Link from os/file_unix.go:
(defn ^"Error" Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.LookupEnv from os/env.go:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo input arguments: (key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__lookupEnv(key)"}
  [^String key])

JOKER FUNC os.Lstat from os/stat.go:
(defn Lstat
  "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__lstat(name)"}
  [^String name])

JOKER FUNC os.Mkdir from os/file.go:
(defn ^"Error" Mkdir
  "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Mkdir(name, *perm)"}
  [^String name, ^os/FileMode perm])

JOKER FUNC os.MkdirAll from os/path.go:
(defn ^"Error" MkdirAll
  "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo input arguments: (path string, perm FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^go.std.os/FileMode perm]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.MkdirAll(path, *perm)"}
  [^String path, ^os/FileMode perm])

JOKER FUNC os.NewFile from os/file_unix.go:
(defn NewFile
  "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo input arguments: (fd uintptr, name string)\n\nGo return type: *File\n\nJoker input arguments: [^Number fd, ^String name]\n\nJoker return type: (atom-of go.std.os/File)"
  {:added "1.0"
   :go "__newFile(fd, name)"}
  [^Number fd, ^String name])

JOKER FUNC os.NewSyscallError from os/error.go:
(defn ^"Error" NewSyscallError
  "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo input arguments: (syscall string, err error)\n\nGo return type: error\n\nJoker input arguments: [^String syscall, ^Error err]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.NewSyscallError(syscall, err)"}
  [^String syscall, ^Error err])

JOKER FUNC os.Open from os/file.go:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__open(name)"}
  [^String name])

JOKER FUNC os.OpenFile from os/file.go:
(defn OpenFile
  "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, flag int, perm FileMode)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name, ^Int flag, ^go.std.os/FileMode perm]\n\nJoker return type: [(atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__openFile(name, flag, *perm)"}
  [^String name, ^Int flag, ^os/FileMode perm])

JOKER FUNC os.Pipe from os/pipe_bsd.go:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os/File) (atom-of go.std.os/File) Error]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC os.Readlink from os/file_posix.go:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__readlink(name)"}
  [^String name])

JOKER FUNC os.Remove from os/file_unix.go:
(defn ^"Error" Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(name)"}
  [^String name])

JOKER FUNC os.RemoveAll from os/path.go:
(defn ^"Error" RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(path)"}
  [^String path])

JOKER FUNC os.Rename from os/file.go:
(defn ^"Error" Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(oldpath, newpath)"}
  [^String oldpath, ^String newpath])

JOKER FUNC os.SameFile from os/types.go:
(defn ^"Boolean" SameFile
  "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo input arguments: (fi1 FileInfo, fi2 FileInfo)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/FileInfo fi1, ^go.std.os/FileInfo fi2]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "os.SameFile(*fi1, *fi2)"}
  [^os/FileInfo fi1, ^os/FileInfo fi2])

JOKER FUNC os.Setenv from os/env.go:
(defn ^"Error" Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC os.StartProcess from os/exec.go:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, argv []string, attr *ProcAttr)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^String name, ^(vector-of String) argv, ^(atom-of go.std.os/ProcAttr) attr]\n\nJoker return type: [(atom-of go.std.os/Process) Error]"
;;   {:added "1.0"
;;    :go "__startProcess(name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(argv)), attr)"}
;;   [^String name, ^Object argv, ^os/ProcAttr attr])

JOKER FUNC os.Stat from os/stat.go:
(defn Stat
  "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [go.std.os/FileInfo Error]"
  {:added "1.0"
   :go "__stat(name)"}
  [^String name])

JOKER FUNC os.Symlink from os/file_unix.go:
(defn ^"Error" Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(oldname, newname)"}
  [^String oldname, ^String newname])

JOKER FUNC os.TempDir from os/file.go:
(defn ^"String" TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate from os/file_unix.go:
(defn ^"Error" Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, size int64)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Number size]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(name, size)"}
  [^String name, ^Number size])

JOKER FUNC os.Unsetenv from os/env.go:
(defn ^"Error" Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(key)"}
  [^String key])

JOKER FUNC os.UserCacheDir from os/file.go:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__userCacheDir()"}
  [])

JOKER FUNC os.UserHomeDir from os/file.go:
(defn UserHomeDir
  "UserHomeDir returns the current user's home directory.\n\nOn Unix, including macOS, it returns the $HOME environment variable.\nOn Windows, it returns %USERPROFILE%.\nOn Plan 9, it returns the $home environment variable.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__userHomeDir()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["os"]
    :doc "Provides a low-level interface to the os package."
    :empty false}
  go.std.os)
JOKER TYPE os/exec.Cmd from os/exec/exec.go:
;; (defn ^"GoObject" Cmd.
;;   "Constructor for exec.Cmd"
;;   {:added "1.0"
;;    :go "_ConstructCmd(_v)"}
;;   [^Object _v])

JOKER TYPE os/exec.Error from os/exec/exec.go:
(defn ^"GoObject" Error.
  "Constructor for exec.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE os/exec.ExitError from os/exec/exec.go:
;; (defn ^"GoObject" ExitError.
;;   "Constructor for exec.ExitError"
;;   {:added "1.0"
;;    :go "_ConstructExitError(_v)"}
;;   [^Object _v])

JOKER FUNC os/exec.Command from os/exec/exec.go:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nOn Windows, processes receive the whole command line as a single string\nand do their own parsing. Command combines and quotes Args into a command\nline string with an algorithm compatible with applications using\nCommandLineToArgvW (which is the most common way). Notable exceptions are\nmsiexec.exe and cmd.exe (and thus, all batch files), which have a different\nunquoting algorithm. In these or other similar cases, you can do the\nquoting yourself and provide the full command line in SysProcAttr.CmdLine,\nleaving Args empty.\n\nGo input arguments: (name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__command(name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(arg)))"}
;;   [^String name, ^String arg])

JOKER FUNC os/exec.CommandContext from os/exec/exec.go:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo input arguments: (ctx context.Context, name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^go.std.context/Context ctx, ^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: (atom-of go.std.os.exec/Cmd)"
;;   {:added "1.0"
;;    :go "__commandContext(*ctx, name, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(arg)))"}
;;   [^context/Context ctx, ^String name, ^String arg])

JOKER FUNC os/exec.LookPath from os/exec/lp_unix.go:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo input arguments: (file string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String file]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookPath(file)"}
  [^String file])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/exec package."
    :empty false}
  go.std.os.exec)
JOKER FUNC os/signal.Ignore from os/signal/signal.go:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__ignore(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*sig))"}
;;   [^os/Signal sig])

JOKER FUNC os/signal.Ignored from os/signal/signal.go:
;; (defn ^"Boolean" Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo input arguments: (sig os.Signal)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.os/Signal sig]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "signal.Ignored(*sig)"}
;;   [^os/Signal sig])

JOKER FUNC os/signal.Notify from os/signal/signal.go:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n\nGo input arguments: (c <-chan, sig ...os.Signal)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c, ^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__notify(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()), ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*sig))"}
;;   [^<no-idea-about-chan-yet> c, ^os/Signal sig])

JOKER FUNC os/signal.Reset from os/signal/signal.go:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os/Signal) sig]"
;;   {:added "1.0"
;;    :go "__reset(ConvertToEllipsisHaHaABEND987(genutils.go: imports not yet supported: os.Signal)(*sig))"}
;;   [^os/Signal sig])

JOKER FUNC os/signal.Stop from os/signal/signal.go:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n\nGo input arguments: (c <-chan)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c]"
;;   {:added "1.0"
;;    :go "__stop(ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))"}
;;   [^<no-idea-about-chan-yet> c])

JOKER TYPE os/user.Group from os/user/user.go:
(defn ^"GoObject" Group.
  "Constructor for user.Group"
  {:added "1.0"
   :go "_ConstructGroup(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupError from os/user/user.go:
(defn ^"GoObject" UnknownGroupError.
  "Constructor for user.UnknownGroupError"
  {:added "1.0"
   :go "_ConstructUnknownGroupError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownGroupIdError from os/user/user.go:
(defn ^"GoObject" UnknownGroupIdError.
  "Constructor for user.UnknownGroupIdError"
  {:added "1.0"
   :go "_ConstructUnknownGroupIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserError from os/user/user.go:
(defn ^"GoObject" UnknownUserError.
  "Constructor for user.UnknownUserError"
  {:added "1.0"
   :go "_ConstructUnknownUserError(_v)"}
  [^Object _v])

JOKER TYPE os/user.UnknownUserIdError from os/user/user.go:
(defn ^"GoObject" UnknownUserIdError.
  "Constructor for user.UnknownUserIdError"
  {:added "1.0"
   :go "_ConstructUnknownUserIdError(_v)"}
  [^Object _v])

JOKER TYPE os/user.User from os/user/user.go:
(defn ^"GoObject" User.
  "Constructor for user.User"
  {:added "1.0"
   :go "_ConstructUser(_v)"}
  [^Object _v])

JOKER FUNC os/user.Current from os/user/lookup.go:
(defn Current
  "Current returns the current user.\n\nThe first call will cache the current user information.\nSubsequent calls will return the cached value and will not reflect\nchanges to the current user.\n\nGo return type: (*User, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__current()"}
  [])

JOKER FUNC os/user.Lookup from os/user/lookup.go:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo input arguments: (username string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String username]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookup(username)"}
  [^String username])

JOKER FUNC os/user.LookupGroup from os/user/lookup.go:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo input arguments: (name string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroup(name)"}
  [^String name])

JOKER FUNC os/user.LookupGroupId from os/user/lookup.go:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo input arguments: (gid string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String gid]\n\nJoker return type: [(atom-of go.std.os.user/Group) Error]"
  {:added "1.0"
   :go "__lookupGroupId(gid)"}
  [^String gid])

JOKER FUNC os/user.LookupId from os/user/lookup.go:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo input arguments: (uid string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String uid]\n\nJoker return type: [(atom-of go.std.os.user/User) Error]"
  {:added "1.0"
   :go "__lookupId(uid)"}
  [^String uid])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the os/user package."
    :empty false}
  go.std.os.user)
JOKER FUNC path.Base from path/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(path)"}
  [^String path])

JOKER FUNC path.Clean from path/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(path)"}
  [^String path])

JOKER FUNC path.Dir from path/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(path)"}
  [^String path])

JOKER FUNC path.Ext from path/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(path)"}
  [^String path])

JOKER FUNC path.IsAbs from path/path.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "path.IsAbs(path)"}
  [^String path])

JOKER FUNC path.Join from path/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(elem)))"}
;;   [^String elem])

JOKER FUNC path.Match from path/match.go:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC path.Split from path/path.go:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(path)"}
  [^String path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path"]
    :doc "Provides a low-level interface to the path package."
    :empty false}
  go.std.path)
JOKER TYPE path/filepath.WalkFunc from path/filepath/path.go:
;; (defn ^"GoObject" WalkFunc.
;;   "Constructor for filepath.WalkFunc"
;;   {:added "1.0"
;;    :go "_ConstructWalkFunc(_v)"}
;;   [^Object _v])

JOKER FUNC path/filepath.Abs from path/filepath/path.go:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__abs(path)"}
  [^String path])

JOKER FUNC path/filepath.Base from path/filepath/path.go:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(path)"}
  [^String path])

JOKER FUNC path/filepath.Clean from path/filepath/path.go:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(path)"}
  [^String path])

JOKER FUNC path/filepath.Dir from path/filepath/path.go:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(path)"}
  [^String path])

JOKER FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__evalSymlinks(path)"}
  [^String path])

JOKER FUNC path/filepath.Ext from path/filepath/path.go:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(path)"}
  [^String path])

JOKER FUNC path/filepath.FromSlash from path/filepath/path.go:
(defn ^"String" FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(path)"}
  [^String path])

JOKER FUNC path/filepath.Glob from path/filepath/match.go:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string)\n\nGo return type: (matches []string, err error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__glob(pattern)"}
  [^String pattern])

JOKER FUNC path/filepath.HasPrefix from path/filepath/path_unix.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo input arguments: (p string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String p, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.HasPrefix(p, prefix)"}
  [^String p, ^String prefix])

JOKER FUNC path/filepath.IsAbs from path/filepath/path_unix.go:
(defn ^"Boolean" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "filepath.IsAbs(path)"}
  [^String path])

JOKER FUNC path/filepath.Join from path/filepath/path.go:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(elem)))"}
;;   [^String elem])

JOKER FUNC path/filepath.Match from path/filepath/match.go:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__match(pattern, name)"}
  [^String pattern, ^String name])

JOKER FUNC path/filepath.Rel from path/filepath/path.go:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo input arguments: (basepath string, targpath string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String basepath, ^String targpath]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__rel(basepath, targpath)"}
  [^String basepath, ^String targpath])

JOKER FUNC path/filepath.Split from path/filepath/path.go:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "__split(path)"}
  [^String path])

JOKER FUNC path/filepath.SplitList from path/filepath/path.go:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo input arguments: (path string)\n\nGo return type: []string\n\nJoker input arguments: [^String path]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitList(path)"}
  [^String path])

JOKER FUNC path/filepath.ToSlash from path/filepath/path.go:
(defn ^"String" ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(path)"}
  [^String path])

JOKER FUNC path/filepath.VolumeName from path/filepath/path.go:
(defn ^"String" VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(path)"}
  [^String path])

JOKER FUNC path/filepath.Walk from path/filepath/path.go:
(defn ^"Error" Walk
  "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo input arguments: (root string, walkFn WalkFunc)\n\nGo return type: error\n\nJoker input arguments: [^String root, ^go.std.path.filepath/WalkFunc walkFn]\n\nJoker return type: Error"
  {:added "1.0"
   :go "filepath.Walk(root, *walkFn)"}
  [^String root, ^filepath/WalkFunc walkFn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["path/filepath"]
    :doc "Provides a low-level interface to the path/filepath package."
    :empty false}
  go.std.path.filepath)
JOKER TYPE plugin.Plugin from plugin/plugin.go:
(defn ^"GoObject" Plugin.
  "Constructor for plugin.Plugin"
  {:added "1.0"
   :go "_ConstructPlugin(_v)"}
  [^Object _v])

JOKER TYPE plugin.Symbol from plugin/plugin.go:
;; (defn ^"GoObject" Symbol.
;;   "Constructor for plugin.Symbol"
;;   {:added "1.0"
;;    :go "_ConstructSymbol(_v)"}
;;   [^Object _v])

JOKER FUNC plugin.Open from plugin/plugin.go:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo input arguments: (path string)\n\nGo return type: (*Plugin, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [(atom-of go.std.plugin/Plugin) Error]"
  {:added "1.0"
   :go "__open(path)"}
  [^String path])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the plugin package."
    :empty false}
  go.std.plugin)
JOKER TYPE reflect.ChanDir from reflect/type.go:
(defn ^"GoObject" ChanDir.
  "Constructor for reflect.ChanDir"
  {:added "1.0"
   :go "_ConstructChanDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.Kind from reflect/type.go:
(defn ^"GoObject" Kind.
  "Constructor for reflect.Kind"
  {:added "1.0"
   :go "_ConstructKind(_v)"}
  [^Object _v])

JOKER TYPE reflect.MapIter from reflect/value.go:
(defn ^"GoObject" MapIter.
  "Constructor for reflect.MapIter"
  {:added "1.0"
   :go "_ConstructMapIter(_v)"}
  [^Object _v])

JOKER TYPE reflect.Method from reflect/type.go:
;; (defn ^"GoObject" Method.
;;   "Constructor for reflect.Method"
;;   {:added "1.0"
;;    :go "_ConstructMethod(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.SelectCase from reflect/value.go:
;; (defn ^"GoObject" SelectCase.
;;   "Constructor for reflect.SelectCase"
;;   {:added "1.0"
;;    :go "_ConstructSelectCase(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.SelectDir from reflect/value.go:
(defn ^"GoObject" SelectDir.
  "Constructor for reflect.SelectDir"
  {:added "1.0"
   :go "_ConstructSelectDir(_v)"}
  [^Object _v])

JOKER TYPE reflect.SliceHeader from reflect/value.go:
(defn ^"GoObject" SliceHeader.
  "Constructor for reflect.SliceHeader"
  {:added "1.0"
   :go "_ConstructSliceHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StringHeader from reflect/value.go:
(defn ^"GoObject" StringHeader.
  "Constructor for reflect.StringHeader"
  {:added "1.0"
   :go "_ConstructStringHeader(_v)"}
  [^Object _v])

JOKER TYPE reflect.StructField from reflect/type.go:
;; (defn ^"GoObject" StructField.
;;   "Constructor for reflect.StructField"
;;   {:added "1.0"
;;    :go "_ConstructStructField(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.StructTag from reflect/type.go:
(defn ^"GoObject" StructTag.
  "Constructor for reflect.StructTag"
  {:added "1.0"
   :go "_ConstructStructTag(_v)"}
  [^Object _v])

JOKER TYPE reflect.Type from reflect/type.go:
;; (defn ^"GoObject" Type.
;;   "Constructor for reflect.Type"
;;   {:added "1.0"
;;    :go "_ConstructType(_v)"}
;;   [^Object _v])

JOKER TYPE reflect.Value from reflect/value.go:
(defn ^"GoObject" Value.
  "Constructor for reflect.Value"
  {:added "1.0"
   :go "_ConstructValue(_v)"}
  [^Object _v])

JOKER TYPE reflect.ValueError from reflect/value.go:
(defn ^"GoObject" ValueError.
  "Constructor for reflect.ValueError"
  {:added "1.0"
   :go "_ConstructValueError(_v)"}
  [^Object _v])

JOKER FUNC reflect.Append from reflect/value.go:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo input arguments: (s Value, x ...Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^(ellipsis-somehow reflect/Value) x]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__append(*s, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa_reflect.Value(*x)))"}
;;   [^reflect/Value s, ^reflect/Value x])

JOKER FUNC reflect.AppendSlice from reflect/value.go:
(defn AppendSlice
  "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo input arguments: (s Value, t Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value s, ^go.std.reflect/Value t]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__appendSlice(*s, *t)"}
  [^reflect/Value s, ^reflect/Value t])

JOKER FUNC reflect.ArrayOf from reflect/type.go:
(defn ArrayOf
  "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo input arguments: (count int, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^Int count, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__arrayOf(count, *elem)"}
  [^Int count, ^reflect/Type elem])

JOKER FUNC reflect.ChanOf from reflect/type.go:
(defn ChanOf
  "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo input arguments: (dir ChanDir, t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/ChanDir dir, ^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__chanOf(*dir, *t)"}
  [^reflect/ChanDir dir, ^reflect/Type t])

JOKER FUNC reflect.Copy from reflect/value.go:
(defn ^"Int" Copy
  "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo input arguments: (dst Value, src Value)\n\nGo return type: int\n\nJoker input arguments: [^go.std.reflect/Value dst, ^go.std.reflect/Value src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "reflect.Copy(*dst, *src)"}
  [^reflect/Value dst, ^reflect/Value src])

JOKER FUNC reflect.DeepEqual from reflect/deepequal.go:
;; (defn ^"Boolean" DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo input arguments: (x interface {}, y interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> x, ^<protocol-or-something> y]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> x, ^<protocol-or-something> y])

JOKER FUNC reflect.FuncOf from reflect/type.go:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo input arguments: (in []Type, out []Type, variadic bool)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/Type) in, ^(vector-of go.std.reflect/Type) out, ^Boolean variadic]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__funcOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*in)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Type(*out)), variadic)"}
;;   [^Object in, ^Object out, ^Boolean variadic])

JOKER FUNC reflect.Indirect from reflect/value.go:
(defn Indirect
  "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo input arguments: (v Value)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Value v]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__indirect(*v)"}
  [^reflect/Value v])

JOKER FUNC reflect.MakeChan from reflect/value.go:
(defn MakeChan
  "MakeChan creates a new channel with the specified type and buffer size.\n\nGo input arguments: (typ Type, buffer int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int buffer]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeChan(*typ, buffer)"}
  [^reflect/Type typ, ^Int buffer])

JOKER FUNC reflect.MakeFunc from reflect/makefunc.go:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo input arguments: (typ Type, fn func)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^fn fn]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__makeFunc(*typ, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^reflect/Type typ, ^fn fn])

JOKER FUNC reflect.MakeMap from reflect/value.go:
(defn MakeMap
  "MakeMap creates a new map with the specified type.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMap(*typ)"}
  [^reflect/Type typ])

JOKER FUNC reflect.MakeMapWithSize from reflect/value.go:
(defn MakeMapWithSize
  "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo input arguments: (typ Type, n int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int n]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeMapWithSize(*typ, n)"}
  [^reflect/Type typ, ^Int n])

JOKER FUNC reflect.MakeSlice from reflect/value.go:
(defn MakeSlice
  "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo input arguments: (typ Type, len int, cap int)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^Int len, ^Int cap]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__makeSlice(*typ, len, cap)"}
  [^reflect/Type typ, ^Int len, ^Int cap])

JOKER FUNC reflect.MapOf from reflect/type.go:
(defn MapOf
  "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo input arguments: (key Type, elem Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type key, ^go.std.reflect/Type elem]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__mapOf(*key, *elem)"}
  [^reflect/Type key, ^reflect/Type elem])

JOKER FUNC reflect.New from reflect/value.go:
(defn New
  "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__new(*typ)"}
  [^reflect/Type typ])

JOKER FUNC reflect.NewAt from reflect/value.go:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo input arguments: (typ Type, p unsafe.Pointer)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ, ^go.std.unsafe/Pointer p]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__newAt(*typ, *p)"}
;;   [^reflect/Type typ, ^unsafe/Pointer p])

JOKER FUNC reflect.PtrTo from reflect/type.go:
(defn PtrTo
  "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__ptrTo(*t)"}
  [^reflect/Type t])

JOKER FUNC reflect.Select from reflect/value.go:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo input arguments: (cases []SelectCase)\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker input arguments: [^(vector-of go.std.reflect/SelectCase) cases]\n\nJoker return type: [Int go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__select(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.SelectCase(*cases)))"}
;;   [^Object cases])

JOKER FUNC reflect.SliceOf from reflect/type.go:
(defn SliceOf
  "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo input arguments: (t Type)\n\nGo return type: Type\n\nJoker input arguments: [^go.std.reflect/Type t]\n\nJoker return type: go.std.reflect/Type"
  {:added "1.0"
   :go "__sliceOf(*t)"}
  [^reflect/Type t])

JOKER FUNC reflect.StructOf from reflect/type.go:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo input arguments: (fields []StructField)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of go.std.reflect/StructField) fields]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__structOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.StructField(*fields)))"}
;;   [^Object fields])

JOKER FUNC reflect.Swapper from reflect/swapper.go:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {})\n\nGo return type: ...\n\nJoker input arguments: [^<protocol-or-something> slice]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: /usr/local/go/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "__swapper(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> slice])

JOKER FUNC reflect.TypeOf from reflect/type.go:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo input arguments: (i interface {})\n\nGo return type: Type\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Type"
;;   {:added "1.0"
;;    :go "__typeOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> i])

JOKER FUNC reflect.ValueOf from reflect/value.go:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo input arguments: (i interface {})\n\nGo return type: Value\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: go.std.reflect/Value"
;;   {:added "1.0"
;;    :go "__valueOf(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> i])

JOKER FUNC reflect.Zero from reflect/value.go:
(defn Zero
  "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo input arguments: (typ Type)\n\nGo return type: Value\n\nJoker input arguments: [^go.std.reflect/Type typ]\n\nJoker return type: go.std.reflect/Value"
  {:added "1.0"
   :go "__zero(*typ)"}
  [^reflect/Type typ])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["reflect"]
    :doc "Provides a low-level interface to the reflect package."
    :empty false}
  go.std.reflect)
JOKER TYPE regexp.Regexp from regexp/regexp.go:
(defn ^"GoObject" Regexp.
  "Constructor for regexp.Regexp"
  {:added "1.0"
   :go "_ConstructRegexp(_v)"}
  [^Object _v])

JOKER FUNC regexp.Compile from regexp/regexp.go:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compile(expr)"}
  [^String expr])

JOKER FUNC regexp.CompilePOSIX from regexp/regexp.go:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [(atom-of go.std.regexp/Regexp) Error]"
  {:added "1.0"
   :go "__compilePOSIX(expr)"}
  [^String expr])

JOKER FUNC regexp.Match from regexp/regexp.go:
;; (defn Match
;;   "Match reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, b []byte)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^(vector-of Int) b]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__match(pattern, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^String pattern, ^Object b])

JOKER FUNC regexp.MatchReader from regexp/regexp.go:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, r io.RuneReader)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^go.std.io/RuneReader r]\n\nJoker return type: [Boolean Error]"
;;   {:added "1.0"
;;    :go "__matchReader(pattern, *r)"}
;;   [^String pattern, ^io/RuneReader r])

JOKER FUNC regexp.MatchString from regexp/regexp.go:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, s string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String s]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__matchString(pattern, s)"}
  [^String pattern, ^String s])

JOKER FUNC regexp.MustCompile from regexp/regexp.go:
(defn MustCompile
  "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompile(str)"}
  [^String str])

JOKER FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
(defn MustCompilePOSIX
  "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: (atom-of go.std.regexp/Regexp)"
  {:added "1.0"
   :go "__mustCompilePOSIX(str)"}
  [^String str])

JOKER FUNC regexp.QuoteMeta from regexp/regexp.go:
(defn ^"String" QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(s)"}
  [^String s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp"]
    :doc "Provides a low-level interface to the regexp package."
    :empty false}
  go.std.regexp)
JOKER TYPE regexp/syntax.EmptyOp from regexp/syntax/prog.go:
(defn ^"GoObject" EmptyOp.
  "Constructor for syntax.EmptyOp"
  {:added "1.0"
   :go "_ConstructEmptyOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Error from regexp/syntax/parse.go:
(defn ^"GoObject" Error.
  "Constructor for syntax.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.ErrorCode from regexp/syntax/parse.go:
(defn ^"GoObject" ErrorCode.
  "Constructor for syntax.ErrorCode"
  {:added "1.0"
   :go "_ConstructErrorCode(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Flags from regexp/syntax/parse.go:
(defn ^"GoObject" Flags.
  "Constructor for syntax.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Inst from regexp/syntax/prog.go:
;; (defn ^"GoObject" Inst.
;;   "Constructor for syntax.Inst"
;;   {:added "1.0"
;;    :go "_ConstructInst(_v)"}
;;   [^Object _v])

JOKER TYPE regexp/syntax.InstOp from regexp/syntax/prog.go:
(defn ^"GoObject" InstOp.
  "Constructor for syntax.InstOp"
  {:added "1.0"
   :go "_ConstructInstOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Op from regexp/syntax/regexp.go:
(defn ^"GoObject" Op.
  "Constructor for syntax.Op"
  {:added "1.0"
   :go "_ConstructOp(_v)"}
  [^Object _v])

JOKER TYPE regexp/syntax.Prog from regexp/syntax/prog.go:
;; (defn ^"GoObject" Prog.
;;   "Constructor for syntax.Prog"
;;   {:added "1.0"
;;    :go "_ConstructProg(_v)"}
;;   [^Object _v])

JOKER TYPE regexp/syntax.Regexp from regexp/syntax/regexp.go:
;; (defn ^"GoObject" Regexp.
;;   "Constructor for syntax.Regexp"
;;   {:added "1.0"
;;    :go "_ConstructRegexp(_v)"}
;;   [^Object _v])

JOKER FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
(defn Compile
  "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo input arguments: (re *Regexp)\n\nGo return type: (*Prog, error)\n\nJoker input arguments: [^(atom-of go.std.regexp.syntax/Regexp) re]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Prog) Error]"
  {:added "1.0"
   :go "__compile(re)"}
  [^syntax/Regexp re])

JOKER FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
(defn EmptyOpContext
  "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: EmptyOp\n\nJoker input arguments: [^Char r1, ^Char r2]\n\nJoker return type: go.std.regexp.syntax/EmptyOp"
  {:added "1.0"
   :go "__emptyOpContext(r1, r2)"}
  [^Char r1, ^Char r2])

JOKER FUNC regexp/syntax.IsWordChar from regexp/syntax/prog.go:
(defn ^"Boolean" IsWordChar
  "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "syntax.IsWordChar(r)"}
  [^Char r])

JOKER FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
(defn Parse
  "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo input arguments: (s string, flags Flags)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String s, ^go.std.regexp.syntax/Flags flags]\n\nJoker return type: [(atom-of go.std.regexp.syntax/Regexp) Error]"
  {:added "1.0"
   :go "__parse(s, *flags)"}
  [^String s, ^syntax/Flags flags])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["regexp/syntax"]
    :doc "Provides a low-level interface to the regexp/syntax package."
    :empty false}
  go.std.regexp.syntax)
JOKER TYPE runtime.BlockProfileRecord from runtime/mprof.go:
(defn ^"GoObject" BlockProfileRecord.
  "Constructor for runtime.BlockProfileRecord"
  {:added "1.0"
   :go "_ConstructBlockProfileRecord(_v)"}
  [^Object _v])

JOKER TYPE runtime.Error from runtime/error.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for runtime.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.Frame from runtime/symtab.go:
;; (defn ^"GoObject" Frame.
;;   "Constructor for runtime.Frame"
;;   {:added "1.0"
;;    :go "_ConstructFrame(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.Frames from runtime/symtab.go:
(defn ^"GoObject" Frames.
  "Constructor for runtime.Frames"
  {:added "1.0"
   :go "_ConstructFrames(_v)"}
  [^Object _v])

JOKER TYPE runtime.Func from runtime/symtab.go:
(defn ^"GoObject" Func.
  "Constructor for runtime.Func"
  {:added "1.0"
   :go "_ConstructFunc(_v)"}
  [^Object _v])

JOKER TYPE runtime.MemProfileRecord from runtime/mprof.go:
;; (defn ^"GoObject" MemProfileRecord.
;;   "Constructor for runtime.MemProfileRecord"
;;   {:added "1.0"
;;    :go "_ConstructMemProfileRecord(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.MemStats from runtime/mstats.go:
;; (defn ^"GoObject" MemStats.
;;   "Constructor for runtime.MemStats"
;;   {:added "1.0"
;;    :go "_ConstructMemStats(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.StackRecord from runtime/mprof.go:
;; (defn ^"GoObject" StackRecord.
;;   "Constructor for runtime.StackRecord"
;;   {:added "1.0"
;;    :go "_ConstructStackRecord(_v)"}
;;   [^Object _v])

JOKER TYPE runtime.TypeAssertionError from runtime/error.go:
(defn ^"GoObject" TypeAssertionError.
  "Constructor for runtime.TypeAssertionError"
  {:added "1.0"
   :go "_ConstructTypeAssertionError(_v)"}
  [^Object _v])

JOKER FUNC runtime.BlockProfile from runtime/mprof.go:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__blockProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*p)))"}
;;   [^Object p])

JOKER FUNC runtime.Breakpoint from runtime/proc.go:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile from runtime/cpuprof.go:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__cPUProfile()"}
  [])

JOKER FUNC runtime.Caller from runtime/extern.go:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo input arguments: (skip int)\n\nGo return type: (pc uintptr, file string, line int, ok bool)\n\nJoker input arguments: [^Int skip]\n\nJoker return type: [Number String Int Boolean]"
;;   {:added "1.0"
;;    :go "__caller(skip)"}
;;   [^Int skip])

JOKER FUNC runtime.Callers from runtime/extern.go:
;; (defn ^"Int" Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\ngo:noinline\n\nGo input arguments: (skip int, pc []uintptr)\n\nGo return type: int\n\nJoker input arguments: [^Int skip, ^(vector-of Number) pc]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(skip, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(pc)))"}
;;   [^Int skip, ^Object pc])

JOKER FUNC runtime.CallersFrames from runtime/symtab.go:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo input arguments: (callers []uintptr)\n\nGo return type: *Frames\n\nJoker input arguments: [^(vector-of Number) callers]\n\nJoker return type: (atom-of go.std.runtime/Frames)"
;;   {:added "1.0"
;;    :go "__callersFrames(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuintptr(callers)))"}
;;   [^Object callers])

JOKER FUNC runtime.FuncForPC from runtime/symtab.go:
(defn FuncForPC
  "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe a *Func describing the innermost function, but with an entry\nof the outermost function.\n\nGo input arguments: (pc uintptr)\n\nGo return type: *Func\n\nJoker input arguments: [^Number pc]\n\nJoker return type: (atom-of go.std.runtime/Func)"
  {:added "1.0"
   :go "__funcForPC(pc)"}
  [^Number pc])

JOKER FUNC runtime.GC from runtime/mgc.go:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS from runtime/debug.go:
(defn ^"Int" GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(n)"}
  [^Int n])

JOKER FUNC runtime.GOROOT from runtime/extern.go:
(defn ^"String" GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit from runtime/panic.go:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile from runtime/mprof.go:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__goroutineProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*p)))"}
;;   [^Object p])

JOKER FUNC runtime.Gosched from runtime/proc.go:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive from runtime/mfinal.go:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n\nGo input arguments: (x interface {})\n\nJoker input arguments: [^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "__keepAlive(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> x])

JOKER FUNC runtime.LockOSThread from runtime/proc.go:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile from runtime/mprof.go:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo input arguments: (p []MemProfileRecord, inuseZero bool)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/MemProfileRecord) p, ^Boolean inuseZero]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__memProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.MemProfileRecord(*p)), inuseZero)"}
;;   [^Object p, ^Boolean inuseZero])

JOKER FUNC runtime.MutexProfile from runtime/mprof.go:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo input arguments: (p []BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/BlockProfileRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__mutexProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.BlockProfileRecord(*p)))"}
;;   [^Object p])

JOKER FUNC runtime.NumCPU from runtime/debug.go:
(defn ^"Int" NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall from runtime/debug.go:
(defn NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int64\n\nJoker input arguments: []\n\nJoker return type: Number"
  {:added "1.0"
   :go "__numCgoCall()"}
  [])

JOKER FUNC runtime.NumGoroutine from runtime/debug.go:
(defn ^"Int" NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats from runtime/mstats.go:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n\nGo input arguments: (m *MemStats)\n\nJoker input arguments: [^(atom-of go.std.runtime/MemStats) m]"
;;   {:added "1.0"
;;    :go "__readMemStats(m)"}
;;   [^runtime/MemStats m])

JOKER FUNC runtime.ReadTrace from runtime/trace.go:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n\nGo input arguments: (rate int)\n\nJoker input arguments: [^Int rate]"
;;   {:added "1.0"
;;    :go "__setBlockProfileRate(rate)"}
;;   [^Int rate])

JOKER FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n\nGo input arguments: (hz int)\n\nJoker input arguments: [^Int hz]"
;;   {:added "1.0"
;;    :go "__setCPUProfileRate(hz)"}
;;   [^Int hz])

JOKER FUNC runtime.SetCgoTraceback from runtime/traceback.go:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n\nGo input arguments: (version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)\n\nJoker input arguments: [^Int version, ^go.std.unsafe/Pointer traceback, ^go.std.unsafe/Pointer context, ^go.std.unsafe/Pointer symbolizer]"
;;   {:added "1.0"
;;    :go "__setCgoTraceback(version, *traceback, *context, *symbolizer)"}
;;   [^Int version, ^unsafe/Pointer traceback, ^unsafe/Pointer context, ^unsafe/Pointer symbolizer])

JOKER FUNC runtime.SetFinalizer from runtime/mfinal.go:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n\nGo input arguments: (obj interface {}, finalizer interface {})\n\nJoker input arguments: [^<protocol-or-something> obj, ^<protocol-or-something> finalizer]"
;;   {:added "1.0"
;;    :go "__setFinalizer(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> obj, ^<protocol-or-something> finalizer])

JOKER FUNC runtime.SetMutexProfileFraction from runtime/mprof.go:
(defn ^"Int" SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo input arguments: (rate int)\n\nGo return type: int\n\nJoker input arguments: [^Int rate]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(rate)"}
  [^Int rate])

JOKER FUNC runtime.Stack from runtime/mprof.go:
;; (defn ^"Int" Stack
;;   "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo input arguments: (buf []byte, all bool)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) buf, ^Boolean all]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Stack(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), all)"}
;;   [^Object buf, ^Boolean all])

JOKER FUNC runtime.StartTrace from runtime/trace.go:
(defn ^"Error" StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace from runtime/trace.go:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo input arguments: (p []StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of go.std.runtime/StackRecord) p]\n\nJoker return type: [Int Boolean]"
;;   {:added "1.0"
;;    :go "__threadCreateProfile(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_runtime.StackRecord(*p)))"}
;;   [^Object p])

JOKER FUNC runtime.UnlockOSThread from runtime/proc.go:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version from runtime/extern.go:
(defn ^"String" Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime"]
    :doc "Provides a low-level interface to the runtime package."
    :empty false}
  go.std.runtime)
JOKER TYPE runtime/debug.BuildInfo from runtime/debug/mod.go:
;; (defn ^"GoObject" BuildInfo.
;;   "Constructor for debug.BuildInfo"
;;   {:added "1.0"
;;    :go "_ConstructBuildInfo(_v)"}
;;   [^Object _v])

JOKER TYPE runtime/debug.GCStats from runtime/debug/garbage.go:
;; (defn ^"GoObject" GCStats.
;;   "Constructor for debug.GCStats"
;;   {:added "1.0"
;;    :go "_ConstructGCStats(_v)"}
;;   [^Object _v])

JOKER TYPE runtime/debug.Module from runtime/debug/mod.go:
;; (defn ^"GoObject" Module.
;;   "Constructor for debug.Module"
;;   {:added "1.0"
;;    :go "_ConstructModule(_v)"}
;;   [^Object _v])

JOKER FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__freeOSMemory()"}
;;   [])

JOKER FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__printStack()"}
;;   [])

JOKER FUNC runtime/debug.ReadBuildInfo from runtime/debug/mod.go:
(defn ReadBuildInfo
  "ReadBuildInfo returns the build information embedded\nin the running binary. The information is available only\nin binaries built with module support.\n\nGo return type: (info *BuildInfo, ok bool)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.runtime.debug/BuildInfo) Boolean]"
  {:added "1.0"
   :go "__readBuildInfo()"}
  [])

JOKER FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n\nGo input arguments: (stats *GCStats)\n\nJoker input arguments: [^(atom-of go.std.runtime.debug/GCStats) stats]"
;;   {:added "1.0"
;;    :go "__readGCStats(stats)"}
;;   [^debug/GCStats stats])

JOKER FUNC runtime/debug.SetGCPercent from runtime/debug/garbage.go:
(defn ^"Int" SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo input arguments: (percent int)\n\nGo return type: int\n\nJoker input arguments: [^Int percent]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(percent)"}
  [^Int percent])

JOKER FUNC runtime/debug.SetMaxStack from runtime/debug/garbage.go:
(defn ^"Int" SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo input arguments: (bytes int)\n\nGo return type: int\n\nJoker input arguments: [^Int bytes]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(bytes)"}
  [^Int bytes])

JOKER FUNC runtime/debug.SetMaxThreads from runtime/debug/garbage.go:
(defn ^"Int" SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo input arguments: (threads int)\n\nGo return type: int\n\nJoker input arguments: [^Int threads]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(threads)"}
  [^Int threads])

JOKER FUNC runtime/debug.SetPanicOnFault from runtime/debug/garbage.go:
(defn ^"Boolean" SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo input arguments: (enabled bool)\n\nGo return type: bool\n\nJoker input arguments: [^Boolean enabled]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "debug.SetPanicOnFault(enabled)"}
  [^Boolean enabled])

JOKER FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n\nGo input arguments: (level string)\n\nJoker input arguments: [^String level]"
;;   {:added "1.0"
;;    :go "__setTraceback(level)"}
;;   [^String level])

JOKER FUNC runtime/debug.Stack from runtime/debug/stack.go:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []byte\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stack()"}
  [])

JOKER FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n\nGo input arguments: (fd uintptr)\n\nJoker input arguments: [^Number fd]"
;;   {:added "1.0"
;;    :go "__writeHeapDump(fd)"}
;;   [^Number fd])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/debug"]
    :doc "Provides a low-level interface to the runtime/debug package."
    :empty false}
  go.std.runtime.debug)
JOKER TYPE runtime/pprof.LabelSet from runtime/pprof/label.go:
(defn ^"GoObject" LabelSet.
  "Constructor for pprof.LabelSet"
  {:added "1.0"
   :go "_ConstructLabelSet(_v)"}
  [^Object _v])

JOKER TYPE runtime/pprof.Profile from runtime/pprof/pprof.go:
(defn ^"GoObject" Profile.
  "Constructor for pprof.Profile"
  {:added "1.0"
   :go "_ConstructProfile(_v)"}
  [^Object _v])

JOKER FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n\nGo input arguments: (ctx context.Context, labels LabelSet, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels, ^fn f]"
;;   {:added "1.0"
;;    :go "__do(*ctx, *labels, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context ctx, ^pprof/LabelSet labels, ^fn f])

JOKER FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n\nGo input arguments: (ctx context.Context, f func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^fn f]"
;;   {:added "1.0"
;;    :go "__forLabels(*ctx, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context ctx, ^fn f])

JOKER FUNC runtime/pprof.Label from runtime/pprof/label.go:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo input arguments: (ctx context.Context, key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String key]\n\nJoker return type: [String Boolean]"
;;   {:added "1.0"
;;    :go "__label(*ctx, key)"}
;;   [^context/Context ctx, ^String key])

JOKER FUNC runtime/pprof.Labels from runtime/pprof/label.go:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (args ...string)\n\nGo return type: LabelSet\n\nJoker input arguments: [^(ellipsis-somehow String) args]\n\nJoker return type: go.std.runtime.pprof/LabelSet"
;;   {:added "1.0"
;;    :go "__labels(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(args)))"}
;;   [^String args])

JOKER FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
(defn Lookup
  "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__lookup(name)"}
  [^String name])

JOKER FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
(defn NewProfile
  "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.runtime.pprof/Profile)"
  {:added "1.0"
   :go "__newProfile(name)"}
  [^String name])

JOKER FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
(defn Profiles
  "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker input arguments: []\n\nJoker return type: (vector-of (atom-of go.std.runtime.pprof/Profile))"
  {:added "1.0"
   :go "__profiles()"}
  [])

JOKER FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n\nGo input arguments: (ctx context.Context)\n\nJoker input arguments: [^go.std.context/Context ctx]"
;;   {:added "1.0"
;;    :go "__setGoroutineLabels(*ctx)"}
;;   [^context/Context ctx])

JOKER FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(*w)"}
;;   [^io/Writer w])

JOKER FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stopCPUProfile()"}
;;   [])

JOKER FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (ctx context.Context, labels LabelSet)\n\nGo return type: context.Context\n\nJoker input arguments: [^go.std.context/Context ctx, ^go.std.runtime.pprof/LabelSet labels]\n\nJoker return type: go.std.context/Context"
;;   {:added "1.0"
;;    :go "__withLabels(*ctx, *labels)"}
;;   [^context/Context ctx, ^pprof/LabelSet labels])

JOKER FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
;; (defn ^"Error" WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(*w)"}
;;   [^io/Writer w])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the runtime/pprof package."
    :empty false}
  go.std.runtime.pprof)
JOKER TYPE runtime/trace.Region from runtime/trace/annotation.go:
(defn ^"GoObject" Region.
  "Constructor for trace.Region"
  {:added "1.0"
   :go "_ConstructRegion(_v)"}
  [^Object _v])

JOKER TYPE runtime/trace.Task from runtime/trace/annotation.go:
(defn ^"GoObject" Task.
  "Constructor for trace.Task"
  {:added "1.0"
   :go "_ConstructTask(_v)"}
  [^Object _v])

JOKER FUNC runtime/trace.IsEnabled from runtime/trace/annotation.go:
(defn ^"Boolean" IsEnabled
  "IsEnabled reports whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC runtime/trace.Log from runtime/trace/annotation.go:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n\nGo input arguments: (ctx context.Context, category string, message string)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String message]"
;;   {:added "1.0"
;;    :go "__log(*ctx, category, message)"}
;;   [^context/Context ctx, ^String category, ^String message])

JOKER FUNC runtime/trace.Logf from runtime/trace/annotation.go:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n\nGo input arguments: (ctx context.Context, category string, format string, args ...interface {})\n\nJoker input arguments: [^go.std.context/Context ctx, ^String category, ^String format, ^(ellipsis-somehow <protocol-or-something>) args]"
;;   {:added "1.0"
;;    :go "__logf(*ctx, category, format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^context/Context ctx, ^String category, ^String format, ^<protocol-or-something> args])

JOKER FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo input arguments: (pctx context.Context, taskType string)\n\nGo return type: (ctx context.Context, task *Task)\n\nJoker input arguments: [^go.std.context/Context pctx, ^String taskType]\n\nJoker return type: [go.std.context/Context (atom-of go.std.runtime.trace/Task)]"
;;   {:added "1.0"
;;    :go "__newTask(*pctx, taskType)"}
;;   [^context/Context pctx, ^String taskType])

JOKER FUNC runtime/trace.Start from runtime/trace/trace.go:
;; (defn ^"Error" Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(*w)"}
;;   [^io/Writer w])

JOKER FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo input arguments: (ctx context.Context, regionType string)\n\nGo return type: *Region\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType]\n\nJoker return type: (atom-of go.std.runtime.trace/Region)"
;;   {:added "1.0"
;;    :go "__startRegion(*ctx, regionType)"}
;;   [^context/Context ctx, ^String regionType])

JOKER FUNC runtime/trace.Stop from runtime/trace/trace.go:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__stop()"}
;;   [])

JOKER FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n\nGo input arguments: (ctx context.Context, regionType string, fn func)\n\nJoker input arguments: [^go.std.context/Context ctx, ^String regionType, ^fn fn]"
;;   {:added "1.0"
;;    :go "__withRegion(*ctx, regionType, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^context/Context ctx, ^String regionType, ^fn fn])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["runtime/trace"]
    :doc "Provides a low-level interface to the runtime/trace package."
    :empty false}
  go.std.runtime.trace)
JOKER TYPE sort.Float64Slice from sort/sort.go:
;; (defn ^"GoObject" Float64Slice.
;;   "Constructor for sort.Float64Slice"
;;   {:added "1.0"
;;    :go "_ConstructFloat64Slice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.IntSlice from sort/sort.go:
;; (defn ^"GoObject" IntSlice.
;;   "Constructor for sort.IntSlice"
;;   {:added "1.0"
;;    :go "_ConstructIntSlice(_v)"}
;;   [^Object _v])

JOKER TYPE sort.Interface from sort/sort.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for sort.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE sort.StringSlice from sort/sort.go:
;; (defn ^"GoObject" StringSlice.
;;   "Constructor for sort.StringSlice"
;;   {:added "1.0"
;;    :go "_ConstructStringSlice(_v)"}
;;   [^Object _v])

JOKER FUNC sort.Float64s from sort/sort.go:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nJoker input arguments: [^(vector-of Double) a]"
;;   {:added "1.0"
;;    :go "__float64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(a)))"}
;;   [^Object a])

JOKER FUNC sort.Float64sAreSorted from sort/sort.go:
;; (defn ^"Boolean" Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Double) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(a)))"}
;;   [^Object a])

JOKER FUNC sort.Ints from sort/sort.go:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n\nGo input arguments: (a []int)\n\nJoker input arguments: [^(vector-of Int) a]"
;;   {:added "1.0"
;;    :go "__ints(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(a)))"}
;;   [^Object a])

JOKER FUNC sort.IntsAreSorted from sort/sort.go:
;; (defn ^"Boolean" IntsAreSorted
;;   "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo input arguments: (a []int)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.IntsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(a)))"}
;;   [^Object a])

JOKER FUNC sort.IsSorted from sort/sort.go:
(defn ^"Boolean" IsSorted
  "IsSorted reports whether data is sorted.\n\nGo input arguments: (data Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "sort.IsSorted(*data)"}
  [^sort/Interface data])

JOKER FUNC sort.Reverse from sort/sort.go:
(defn Reverse
  "Reverse returns the reverse order for data.\n\nGo input arguments: (data Interface)\n\nGo return type: Interface\n\nJoker input arguments: [^go.std.sort/Interface data]\n\nJoker return type: go.std.sort/Interface"
  {:added "1.0"
   :go "__reverse(*data)"}
  [^sort/Interface data])

JOKER FUNC sort.Search from sort/search.go:
;; (defn ^"Int" Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo input arguments: (n int, f func)\n\nGo return type: int\n\nJoker input arguments: [^Int n, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int n, ^fn f])

JOKER FUNC sort.SearchFloat64s from sort/search.go:
;; (defn ^"Int" SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []float64, x float64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Double) a, ^Double x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOffloat64(a)), x)"}
;;   [^Object a, ^Double x])

JOKER FUNC sort.SearchInts from sort/search.go:
;; (defn ^"Int" SearchInts
;;   "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []int, x int)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^Int x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchInts(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(a)), x)"}
;;   [^Object a, ^Int x])

JOKER FUNC sort.SearchStrings from sort/search.go:
;; (defn ^"Int" SearchStrings
;;   "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []string, x string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of String) a, ^String x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(a)), x)"}
;;   [^Object a, ^String x])

JOKER FUNC sort.Slice from sort/slice.go:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__slice(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> slice, ^fn less])

JOKER FUNC sort.SliceIsSorted from sort/slice.go:
;; (defn ^"Boolean" SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> slice, ^fn less])

JOKER FUNC sort.SliceStable from sort/slice.go:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "__sliceStable(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^<protocol-or-something> slice, ^fn less])

JOKER FUNC sort.Sort from sort/sort.go:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__sort(*data)"}
;;   [^sort/Interface data])

JOKER FUNC sort.Stable from sort/sort.go:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n\nGo input arguments: (data Interface)\n\nJoker input arguments: [^go.std.sort/Interface data]"
;;   {:added "1.0"
;;    :go "__stable(*data)"}
;;   [^sort/Interface data])

JOKER FUNC sort.Strings from sort/sort.go:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n\nGo input arguments: (a []string)\n\nJoker input arguments: [^(vector-of String) a]"
;;   {:added "1.0"
;;    :go "__strings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(a)))"}
;;   [^Object a])

JOKER FUNC sort.StringsAreSorted from sort/sort.go:
;; (defn ^"Boolean" StringsAreSorted
;;   "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo input arguments: (a []string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of String) a]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "sort.StringsAreSorted(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(a)))"}
;;   [^Object a])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["sort"]
    :doc "Provides a low-level interface to the sort package."
    :empty false}
  go.std.sort)
JOKER TYPE strconv.NumError from strconv/atoi.go:
(defn ^"GoObject" NumError.
  "Constructor for strconv.NumError"
  {:added "1.0"
   :go "_ConstructNumError(_v)"}
  [^Object _v])

JOKER FUNC strconv.AppendBool from strconv/atob.go:
;; (defn AppendBool
;;   "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, b bool)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Boolean b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendBool(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), b)"}
;;   [^Object dst, ^Boolean b])

JOKER FUNC strconv.AppendFloat from strconv/ftoa.go:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, f float64, fmt byte, prec int, bitSize int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Double f, ^Int fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendFloat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), f, fmt, prec, bitSize)"}
;;   [^Object dst, ^Double f, ^Int fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.AppendInt from strconv/itoa.go:
;; (defn AppendInt
;;   "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i int64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Number i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendInt(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), i, base)"}
;;   [^Object dst, ^Number i, ^Int base])

JOKER FUNC strconv.AppendQuote from strconv/quote.go:
;; (defn AppendQuote
;;   "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuote(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), s)"}
;;   [^Object dst, ^String s])

JOKER FUNC strconv.AppendQuoteRune from strconv/quote.go:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), r)"}
;;   [^Object dst, ^Char r])

JOKER FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), r)"}
;;   [^Object dst, ^Char r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Char r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteRuneToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), r)"}
;;   [^Object dst, ^Char r])

JOKER FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
;; (defn AppendQuoteToASCII
;;   "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToASCII(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), s)"}
;;   [^Object dst, ^String s])

JOKER FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
;; (defn AppendQuoteToGraphic
;;   "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^String s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendQuoteToGraphic(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), s)"}
;;   [^Object dst, ^String s])

JOKER FUNC strconv.AppendUint from strconv/itoa.go:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i uint64, base int)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) dst, ^Number i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__appendUint(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), i, base)"}
;;   [^Object dst, ^Number i, ^Int base])

JOKER FUNC strconv.Atoi from strconv/atoi.go:
(defn Atoi
  "Atoi is equivalent to ParseInt(s, 10, 0), converted to type int.\n\nGo input arguments: (s string)\n\nGo return type: (int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__atoi(s)"}
  [^String s])

JOKER FUNC strconv.CanBackquote from strconv/quote.go:
(defn ^"Boolean" CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.CanBackquote(s)"}
  [^String s])

JOKER FUNC strconv.FormatBool from strconv/atob.go:
(defn ^"String" FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo input arguments: (b bool)\n\nGo return type: string\n\nJoker input arguments: [^Boolean b]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(b)"}
  [^Boolean b])

JOKER FUNC strconv.FormatFloat from strconv/ftoa.go:
(defn ^"String" FormatFloat
  "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddpddd, a binary exponent),\n'e' (-d.ddddedd, a decimal exponent),\n'E' (-d.ddddEdd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo input arguments: (f float64, fmt byte, prec int, bitSize int)\n\nGo return type: string\n\nJoker input arguments: [^Double f, ^Int fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatFloat(f, fmt, prec, bitSize)"}
  [^Double f, ^Int fmt, ^Int prec, ^Int bitSize])

JOKER FUNC strconv.FormatInt from strconv/itoa.go:
(defn ^"String" FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i int64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Number i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(i, base)"}
  [^Number i, ^Int base])

JOKER FUNC strconv.FormatUint from strconv/itoa.go:
(defn ^"String" FormatUint
  "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i uint64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Number i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatUint(i, base)"}
  [^Number i, ^Int base])

JOKER FUNC strconv.IsGraphic from strconv/quote.go:
(defn ^"Boolean" IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.IsGraphic(r)"}
  [^Char r])

JOKER FUNC strconv.IsPrint from strconv/quote.go:
(defn ^"Boolean" IsPrint
  "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strconv.IsPrint(r)"}
  [^Char r])

JOKER FUNC strconv.Itoa from strconv/itoa.go:
(defn ^"String" Itoa
  "Itoa is equivalent to FormatInt(int64(i), 10).\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(i)"}
  [^Int i])

JOKER FUNC strconv.ParseBool from strconv/atob.go:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo input arguments: (str string)\n\nGo return type: (bool, error)\n\nJoker input arguments: [^String str]\n\nJoker return type: [Boolean Error]"
  {:added "1.0"
   :go "__parseBool(str)"}
  [^String str])

JOKER FUNC strconv.ParseFloat from strconv/atof.go:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = Inf, err.Err = ErrRange.\n\nGo input arguments: (s string, bitSize int)\n\nGo return type: (float64, error)\n\nJoker input arguments: [^String s, ^Int bitSize]\n\nJoker return type: [Double Error]"
;;   {:added "1.0"
;;    :go "__parseFloat(s, bitSize)"}
;;   [^String s, ^Int bitSize])

JOKER FUNC strconv.ParseInt from strconv/atoi.go:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (i int64, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__parseInt(s, base, bitSize)"}
  [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.ParseUint from strconv/atoi.go:
(defn ParseUint
  "ParseUint is like ParseInt but for unsigned numbers.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (uint64, error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__parseUint(s, base, bitSize)"}
  [^String s, ^Int base, ^Int bitSize])

JOKER FUNC strconv.Quote from strconv/quote.go:
(defn ^"String" Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(s)"}
  [^String s])

JOKER FUNC strconv.QuoteRune from strconv/quote.go:
(defn ^"String" QuoteRune
  "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRune(r)"}
  [^Char r])

JOKER FUNC strconv.QuoteRuneToASCII from strconv/quote.go:
(defn ^"String" QuoteRuneToASCII
  "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRuneToASCII(r)"}
  [^Char r])

JOKER FUNC strconv.QuoteRuneToGraphic from strconv/quote.go:
(defn ^"String" QuoteRuneToGraphic
  "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^Char r]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteRuneToGraphic(r)"}
  [^Char r])

JOKER FUNC strconv.QuoteToASCII from strconv/quote.go:
(defn ^"String" QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(s)"}
  [^String s])

JOKER FUNC strconv.QuoteToGraphic from strconv/quote.go:
(defn ^"String" QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(s)"}
  [^String s])

JOKER FUNC strconv.Unquote from strconv/quote.go:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__unquote(s)"}
  [^String s])

JOKER FUNC strconv.UnquoteChar from strconv/quote.go:
(defn UnquoteChar
  "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo input arguments: (s string, quote byte)\n\nGo return type: (value rune, multibyte bool, tail string, err error)\n\nJoker input arguments: [^String s, ^Int quote]\n\nJoker return type: [Char Boolean String Error]"
  {:added "1.0"
   :go "__unquoteChar(s, quote)"}
  [^String s, ^Int quote])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strconv"]
    :doc "Provides a low-level interface to the strconv package."
    :empty false}
  go.std.strconv)
JOKER TYPE strings.Builder from strings/builder.go:
(defn ^"GoObject" Builder.
  "Constructor for strings.Builder"
  {:added "1.0"
   :go "_ConstructBuilder(_v)"}
  [^Object _v])

JOKER TYPE strings.Reader from strings/reader.go:
(defn ^"GoObject" Reader.
  "Constructor for strings.Reader"
  {:added "1.0"
   :go "_ConstructReader(_v)"}
  [^Object _v])

JOKER TYPE strings.Replacer from strings/replace.go:
(defn ^"GoObject" Replacer.
  "Constructor for strings.Replacer"
  {:added "1.0"
   :go "_ConstructReplacer(_v)"}
  [^Object _v])

JOKER FUNC strings.Compare from strings/compare.go:
(defn ^"Int" Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo input arguments: (a string, b string)\n\nGo return type: int\n\nJoker input arguments: [^String a, ^String b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(a, b)"}
  [^String a, ^String b])

JOKER FUNC strings.Contains from strings/strings.go:
(defn ^"Boolean" Contains
  "Contains reports whether substr is within s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.Contains(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.ContainsAny from strings/strings.go:
(defn ^"Boolean" ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.ContainsAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.ContainsRune from strings/strings.go:
(defn ^"Boolean" ContainsRune
  "ContainsRune reports whether the Unicode code point r is within s.\n\nGo input arguments: (s string, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.ContainsRune(s, r)"}
  [^String s, ^Char r])

JOKER FUNC strings.Count from strings/strings.go:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.EqualFold from strings/strings.go:
(defn ^"Boolean" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s string, t string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String t]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.EqualFold(s, t)"}
  [^String s, ^String t])

JOKER FUNC strings.Fields from strings/strings.go:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s string)\n\nGo return type: []string\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__fields(s)"}
  [^String s])

JOKER FUNC strings.FieldsFunc from strings/strings.go:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s string, f func)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "__fieldsFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.HasPrefix from strings/strings.go:
(defn ^"Boolean" HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.HasSuffix from strings/strings.go:
(defn ^"Boolean" HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "strings.HasSuffix(s, suffix)"}
  [^String s, ^String suffix])

JOKER FUNC strings.Index from strings/strings.go:
(defn ^"Int" Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.IndexAny from strings/strings.go:
(defn ^"Int" IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.IndexByte from strings/strings.go:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Int c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(s, c)"}
  [^String s, ^Int c])

JOKER FUNC strings.IndexFunc from strings/strings.go:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.IndexRune from strings/strings.go:
(defn ^"Int" IndexRune
  "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s string, r rune)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Char r]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexRune(s, r)"}
  [^String s, ^Char r])

JOKER FUNC strings.Join from strings/strings.go:
;; (defn ^"String" Join
;;   "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo input arguments: (a []string, sep string)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of String) a, ^String sep]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Join(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(a)), sep)"}
;;   [^Object a, ^String sep])

JOKER FUNC strings.LastIndex from strings/strings.go:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(s, substr)"}
  [^String s, ^String substr])

JOKER FUNC strings.LastIndexAny from strings/strings.go:
(defn ^"Int" LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(s, chars)"}
  [^String s, ^String chars])

JOKER FUNC strings.LastIndexByte from strings/strings.go:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Int c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(s, c)"}
  [^String s, ^Int c])

JOKER FUNC strings.LastIndexFunc from strings/strings.go:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.Map from strings/strings.go:
;; (defn ^"String" Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo input arguments: (mapping func, s string)\n\nGo return type: string\n\nJoker input arguments: [^fn mapping, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), s)"}
;;   [^fn mapping, ^String s])

JOKER FUNC strings.NewReader from strings/reader.go:
(defn NewReader
  "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo input arguments: (s string)\n\nGo return type: *Reader\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of go.std.strings/Reader)"
  {:added "1.0"
   :go "__newReader(s)"}
  [^String s])

JOKER FUNC strings.NewReplacer from strings/replace.go:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo input arguments: (oldnew ...string)\n\nGo return type: *Replacer\n\nJoker input arguments: [^(ellipsis-somehow String) oldnew]\n\nJoker return type: (atom-of go.std.strings/Replacer)"
;;   {:added "1.0"
;;    :go "__newReplacer(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(oldnew)))"}
;;   [^String oldnew])

JOKER FUNC strings.Repeat from strings/strings.go:
(defn ^"String" Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo input arguments: (s string, count int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^Int count]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(s, count)"}
  [^String s, ^Int count])

JOKER FUNC strings.Replace from strings/strings.go:
(defn ^"String" Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s string, old string, new string, n int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new, ^Int n]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(s, old, new, n)"}
  [^String s, ^String old, ^String new, ^Int n])

JOKER FUNC strings.ReplaceAll from strings/strings.go:
(defn ^"String" ReplaceAll
  "ReplaceAll returns a copy of the string s with all\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\n\nGo input arguments: (s string, old string, new string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ReplaceAll(s, old, new)"}
  [^String s, ^String old, ^String new])

JOKER FUNC strings.Split from strings/strings.go:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__split(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfter from strings/strings.go:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfter(s, sep)"}
  [^String s, ^String sep])

JOKER FUNC strings.SplitAfterN from strings/strings.go:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitAfterN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.SplitN from strings/strings.go:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__splitN(s, sep, n)"}
  [^String s, ^String sep, ^Int n])

JOKER FUNC strings.Title from strings/strings.go:
(defn ^"String" Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(s)"}
  [^String s])

JOKER FUNC strings.ToLower from strings/strings.go:
(defn ^"String" ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(s)"}
  [^String s])

JOKER FUNC strings.ToLowerSpecial from strings/strings.go:
;; (defn ^"String" ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case using the case mapping specified by c.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(*c, s)"}
;;   [^unicode/SpecialCase c, ^String s])

JOKER FUNC strings.ToTitle from strings/strings.go:
(defn ^"String" ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(s)"}
  [^String s])

JOKER FUNC strings.ToTitleSpecial from strings/strings.go:
;; (defn ^"String" ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(*c, s)"}
;;   [^unicode/SpecialCase c, ^String s])

JOKER FUNC strings.ToUpper from strings/strings.go:
(defn ^"String" ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(s)"}
  [^String s])

JOKER FUNC strings.ToUpperSpecial from strings/strings.go:
;; (defn ^"String" ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case using the case mapping specified by c.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^go.std.unicode/SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(*c, s)"}
;;   [^unicode/SpecialCase c, ^String s])

JOKER FUNC strings.Trim from strings/strings.go:
(defn ^"String" Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimFunc from strings/strings.go:
;; (defn ^"String" TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.TrimLeft from strings/strings.go:
(defn ^"String" TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimLeftFunc from strings/strings.go:
;; (defn ^"String" TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.TrimPrefix from strings/strings.go:
(defn ^"String" TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(s, prefix)"}
  [^String s, ^String prefix])

JOKER FUNC strings.TrimRight from strings/strings.go:
(defn ^"String" TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(s, cutset)"}
  [^String s, ^String cutset])

JOKER FUNC strings.TrimRightFunc from strings/strings.go:
;; (defn ^"String" TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(s, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String s, ^fn f])

JOKER FUNC strings.TrimSpace from strings/strings.go:
(defn ^"String" TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(s)"}
  [^String s])

JOKER FUNC strings.TrimSuffix from strings/strings.go:
(defn ^"String" TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(s, suffix)"}
  [^String s, ^String suffix])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["strings"]
    :doc "Provides a low-level interface to the strings package."
    :empty false}
  go.std.strings)
JOKER TYPE sync.Cond from sync/cond.go:
;; (defn ^"GoObject" Cond.
;;   "Constructor for sync.Cond"
;;   {:added "1.0"
;;    :go "_ConstructCond(_v)"}
;;   [^Object _v])

JOKER TYPE sync.Locker from sync/mutex.go:
;; (defn ^"GoObject" Locker.
;;   "Constructor for sync.Locker"
;;   {:added "1.0"
;;    :go "_ConstructLocker(_v)"}
;;   [^Object _v])

JOKER TYPE sync.Map from sync/map.go:
(defn ^"GoObject" Map.
  "Constructor for sync.Map"
  {:added "1.0"
   :go "_ConstructMap(_v)"}
  [^Object _v])

JOKER TYPE sync.Mutex from sync/mutex.go:
(defn ^"GoObject" Mutex.
  "Constructor for sync.Mutex"
  {:added "1.0"
   :go "_ConstructMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.Once from sync/once.go:
(defn ^"GoObject" Once.
  "Constructor for sync.Once"
  {:added "1.0"
   :go "_ConstructOnce(_v)"}
  [^Object _v])

JOKER TYPE sync.Pool from sync/pool.go:
;; (defn ^"GoObject" Pool.
;;   "Constructor for sync.Pool"
;;   {:added "1.0"
;;    :go "_ConstructPool(_v)"}
;;   [^Object _v])

JOKER TYPE sync.RWMutex from sync/rwmutex.go:
(defn ^"GoObject" RWMutex.
  "Constructor for sync.RWMutex"
  {:added "1.0"
   :go "_ConstructRWMutex(_v)"}
  [^Object _v])

JOKER TYPE sync.WaitGroup from sync/waitgroup.go:
(defn ^"GoObject" WaitGroup.
  "Constructor for sync.WaitGroup"
  {:added "1.0"
   :go "_ConstructWaitGroup(_v)"}
  [^Object _v])

JOKER FUNC sync.NewCond from sync/cond.go:
(defn NewCond
  "NewCond returns a new Cond with Locker l.\n\nGo input arguments: (l Locker)\n\nGo return type: *Cond\n\nJoker input arguments: [^go.std.sync/Locker l]\n\nJoker return type: (atom-of go.std.sync/Cond)"
  {:added "1.0"
   :go "__newCond(*l)"}
  [^sync/Locker l])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the sync package."
    :empty false}
  go.std.sync)
JOKER FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
;; (defn AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int32, delta int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr, ^Int delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__addInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(addr)), delta)"}
;;   [^Object addr, ^Int delta])

JOKER FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
;; (defn AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int64, delta int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(addr)), delta)"}
;;   [^Object addr, ^Number delta])

JOKER FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
;; (defn AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo input arguments: (addr *uint32, delta uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(addr)), delta)"}
;;   [^Object addr, ^Number delta])

JOKER FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo input arguments: (addr *uint64, delta uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(addr)), delta)"}
;;   [^Object addr, ^Number delta])

JOKER FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *uintptr, delta uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr, ^Number delta]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__addUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(addr)), delta)"}
;;   [^Object addr, ^Number delta])

JOKER FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo input arguments: (addr *int32, old int32, new int32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int) addr, ^Int old, ^Int new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(addr)), old, new)"}
;;   [^Object addr, ^Int old, ^Int new])

JOKER FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo input arguments: (addr *int64, old int64, new int64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(addr)), old, new)"}
;;   [^Object addr, ^Number old, ^Number new])

JOKER FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo input arguments: (addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer old, ^go.std.unsafe/Pointer new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(addr, *old, *new)"}
;;   [^unsafe/Pointer addr, ^unsafe/Pointer old, ^unsafe/Pointer new])

JOKER FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo input arguments: (addr *uint32, old uint32, new uint32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(addr)), old, new)"}
;;   [^Object addr, ^Number old, ^Number new])

JOKER FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo input arguments: (addr *uint64, old uint64, new uint64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(addr)), old, new)"}
;;   [^Object addr, ^Number old, ^Number new])

JOKER FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
;; (defn ^"Boolean" CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo input arguments: (addr *uintptr, old uintptr, new uintptr)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Number) addr, ^Number old, ^Number new]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(addr)), old, new)"}
;;   [^Object addr, ^Number old, ^Number new])

JOKER FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
;; (defn LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo input arguments: (addr *int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__loadInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(addr)))"}
;;   [^Object addr])

JOKER FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
;; (defn LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo input arguments: (addr *int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(addr)))"}
;;   [^Object addr])

JOKER FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo input arguments: (addr *unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__loadPointer(addr)"}
;;   [^unsafe/Pointer addr])

JOKER FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
;; (defn LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo input arguments: (addr *uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(addr)))"}
;;   [^Object addr])

JOKER FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo input arguments: (addr *uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(addr)))"}
;;   [^Object addr])

JOKER FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo input arguments: (addr *uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__loadUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(addr)))"}
;;   [^Object addr])

JOKER FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n\nGo input arguments: (addr *int32, val int32)\n\nJoker input arguments: [^(atom-of Int) addr, ^Int val]"
;;   {:added "1.0"
;;    :go "__storeInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(addr)), val)"}
;;   [^Object addr, ^Int val])

JOKER FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n\nGo input arguments: (addr *int64, val int64)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(addr)), val)"}
;;   [^Object addr, ^Number val])

JOKER FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n\nGo input arguments: (addr *unsafe.Pointer, val unsafe.Pointer)\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer val]"
;;   {:added "1.0"
;;    :go "__storePointer(addr, *val)"}
;;   [^unsafe/Pointer addr, ^unsafe/Pointer val])

JOKER FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n\nGo input arguments: (addr *uint32, val uint32)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(addr)), val)"}
;;   [^Object addr, ^Number val])

JOKER FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n\nGo input arguments: (addr *uint64, val uint64)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(addr)), val)"}
;;   [^Object addr, ^Number val])

JOKER FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n\nGo input arguments: (addr *uintptr, val uintptr)\n\nJoker input arguments: [^(atom-of Number) addr, ^Number val]"
;;   {:added "1.0"
;;    :go "__storeUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(addr)), val)"}
;;   [^Object addr, ^Number val])

JOKER FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
;; (defn SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int32, new int32)\n\nGo return type: int32\n\nJoker input arguments: [^(atom-of Int) addr, ^Int new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "__swapInt32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint32(addr)), new)"}
;;   [^Object addr, ^Int new])

JOKER FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
;; (defn SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int64, new int64)\n\nGo return type: int64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapInt64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(addr)), new)"}
;;   [^Object addr, ^Number new])

JOKER FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.unsafe/Pointer) addr, ^go.std.unsafe/Pointer new]\n\nJoker return type: ABEND042(post.go: cannot find typename unsafe.Pointer)"
;;   {:added "1.0"
;;    :go "__swapPointer(addr, *new)"}
;;   [^unsafe/Pointer addr, ^unsafe/Pointer new])

JOKER FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
;; (defn SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint32, new uint32)\n\nGo return type: uint32\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUint32(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint32(addr)), new)"}
;;   [^Object addr, ^Number new])

JOKER FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint64, new uint64)\n\nGo return type: uint64\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUint64(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(addr)), new)"}
;;   [^Object addr, ^Number new])

JOKER FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uintptr, new uintptr)\n\nGo return type: uintptr\n\nJoker input arguments: [^(atom-of Number) addr, ^Number new]\n\nJoker return type: Number"
;;   {:added "1.0"
;;    :go "__swapUintptr(ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(addr)), new)"}
;;   [^Object addr, ^Number new])

JOKER TYPE syscall.BpfHdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" BpfHdr.
;;   "Constructor for syscall.BpfHdr"
;;   {:added "1.0"
;;    :go "_ConstructBpfHdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.BpfInsn from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" BpfInsn.
  "Constructor for syscall.BpfInsn"
  {:added "1.0"
   :go "_ConstructBpfInsn(_v)"}
  [^Object _v])

JOKER TYPE syscall.BpfProgram from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" BpfProgram.
;;   "Constructor for syscall.BpfProgram"
;;   {:added "1.0"
;;    :go "_ConstructBpfProgram(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.BpfStat from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" BpfStat.
  "Constructor for syscall.BpfStat"
  {:added "1.0"
   :go "_ConstructBpfStat(_v)"}
  [^Object _v])

JOKER TYPE syscall.BpfVersion from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" BpfVersion.
  "Constructor for syscall.BpfVersion"
  {:added "1.0"
   :go "_ConstructBpfVersion(_v)"}
  [^Object _v])

JOKER TYPE syscall.Cmsghdr from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Cmsghdr.
  "Constructor for syscall.Cmsghdr"
  {:added "1.0"
   :go "_ConstructCmsghdr(_v)"}
  [^Object _v])

JOKER TYPE syscall.Conn from syscall/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for syscall.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Credential from syscall/exec_unix.go:
;; (defn ^"GoObject" Credential.
;;   "Constructor for syscall.Credential"
;;   {:added "1.0"
;;    :go "_ConstructCredential(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Dirent from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Dirent.
;;   "Constructor for syscall.Dirent"
;;   {:added "1.0"
;;    :go "_ConstructDirent(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Errno from syscall/syscall_unix.go:
(defn ^"GoObject" Errno.
  "Constructor for syscall.Errno"
  {:added "1.0"
   :go "_ConstructErrno(_v)"}
  [^Object _v])

JOKER TYPE syscall.Fbootstraptransfer_t from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Fbootstraptransfer_t.
;;   "Constructor for syscall.Fbootstraptransfer_t"
;;   {:added "1.0"
;;    :go "_ConstructFbootstraptransfer_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.FdSet from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" FdSet.
;;   "Constructor for syscall.FdSet"
;;   {:added "1.0"
;;    :go "_ConstructFdSet(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Flock_t from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Flock_t.
  "Constructor for syscall.Flock_t"
  {:added "1.0"
   :go "_ConstructFlock_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Fsid from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Fsid.
;;   "Constructor for syscall.Fsid"
;;   {:added "1.0"
;;    :go "_ConstructFsid(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Fstore_t from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Fstore_t.
  "Constructor for syscall.Fstore_t"
  {:added "1.0"
   :go "_ConstructFstore_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.ICMPv6Filter from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" ICMPv6Filter.
;;   "Constructor for syscall.ICMPv6Filter"
;;   {:added "1.0"
;;    :go "_ConstructICMPv6Filter(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPMreq from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IPMreq.
;;   "Constructor for syscall.IPMreq"
;;   {:added "1.0"
;;    :go "_ConstructIPMreq(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPv6MTUInfo from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IPv6MTUInfo.
;;   "Constructor for syscall.IPv6MTUInfo"
;;   {:added "1.0"
;;    :go "_ConstructIPv6MTUInfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IPv6Mreq from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IPv6Mreq.
;;   "Constructor for syscall.IPv6Mreq"
;;   {:added "1.0"
;;    :go "_ConstructIPv6Mreq(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfData from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IfData.
;;   "Constructor for syscall.IfData"
;;   {:added "1.0"
;;    :go "_ConstructIfData(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfMsghdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IfMsghdr.
;;   "Constructor for syscall.IfMsghdr"
;;   {:added "1.0"
;;    :go "_ConstructIfMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfaMsghdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IfaMsghdr.
;;   "Constructor for syscall.IfaMsghdr"
;;   {:added "1.0"
;;    :go "_ConstructIfaMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfmaMsghdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IfmaMsghdr.
;;   "Constructor for syscall.IfmaMsghdr"
;;   {:added "1.0"
;;    :go "_ConstructIfmaMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.IfmaMsghdr2 from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" IfmaMsghdr2.
;;   "Constructor for syscall.IfmaMsghdr2"
;;   {:added "1.0"
;;    :go "_ConstructIfmaMsghdr2(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Inet4Pktinfo from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Inet4Pktinfo.
;;   "Constructor for syscall.Inet4Pktinfo"
;;   {:added "1.0"
;;    :go "_ConstructInet4Pktinfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Inet6Pktinfo from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Inet6Pktinfo.
;;   "Constructor for syscall.Inet6Pktinfo"
;;   {:added "1.0"
;;    :go "_ConstructInet6Pktinfo(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.InterfaceAddrMessage from syscall/route_bsd.go:
;; (defn ^"GoObject" InterfaceAddrMessage.
;;   "Constructor for syscall.InterfaceAddrMessage"
;;   {:added "1.0"
;;    :go "_ConstructInterfaceAddrMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.InterfaceMessage from syscall/route_bsd.go:
;; (defn ^"GoObject" InterfaceMessage.
;;   "Constructor for syscall.InterfaceMessage"
;;   {:added "1.0"
;;    :go "_ConstructInterfaceMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.InterfaceMulticastAddrMessage from syscall/route_darwin.go:
;; (defn ^"GoObject" InterfaceMulticastAddrMessage.
;;   "Constructor for syscall.InterfaceMulticastAddrMessage"
;;   {:added "1.0"
;;    :go "_ConstructInterfaceMulticastAddrMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Iovec from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Iovec.
;;   "Constructor for syscall.Iovec"
;;   {:added "1.0"
;;    :go "_ConstructIovec(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Kevent_t from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Kevent_t.
;;   "Constructor for syscall.Kevent_t"
;;   {:added "1.0"
;;    :go "_ConstructKevent_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Linger from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Linger.
  "Constructor for syscall.Linger"
  {:added "1.0"
   :go "_ConstructLinger(_v)"}
  [^Object _v])

JOKER TYPE syscall.Log2phys_t from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Log2phys_t.
  "Constructor for syscall.Log2phys_t"
  {:added "1.0"
   :go "_ConstructLog2phys_t(_v)"}
  [^Object _v])

JOKER TYPE syscall.Msghdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Msghdr.
;;   "Constructor for syscall.Msghdr"
;;   {:added "1.0"
;;    :go "_ConstructMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.ProcAttr from syscall/exec_unix.go:
;; (defn ^"GoObject" ProcAttr.
;;   "Constructor for syscall.ProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Radvisory_t from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Radvisory_t.
;;   "Constructor for syscall.Radvisory_t"
;;   {:added "1.0"
;;    :go "_ConstructRadvisory_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawConn from syscall/net.go:
;; (defn ^"GoObject" RawConn.
;;   "Constructor for syscall.RawConn"
;;   {:added "1.0"
;;    :go "_ConstructRawConn(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddr.
;;   "Constructor for syscall.RawSockaddr"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrAny from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddrAny.
;;   "Constructor for syscall.RawSockaddrAny"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrAny(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrDatalink from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddrDatalink.
;;   "Constructor for syscall.RawSockaddrDatalink"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrDatalink(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrInet4 from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddrInet4.
;;   "Constructor for syscall.RawSockaddrInet4"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrInet4(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrInet6 from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddrInet6.
;;   "Constructor for syscall.RawSockaddrInet6"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrInet6(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RawSockaddrUnix from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RawSockaddrUnix.
;;   "Constructor for syscall.RawSockaddrUnix"
;;   {:added "1.0"
;;    :go "_ConstructRawSockaddrUnix(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Rlimit from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Rlimit.
  "Constructor for syscall.Rlimit"
  {:added "1.0"
   :go "_ConstructRlimit(_v)"}
  [^Object _v])

JOKER TYPE syscall.RouteMessage from syscall/route_bsd.go:
;; (defn ^"GoObject" RouteMessage.
;;   "Constructor for syscall.RouteMessage"
;;   {:added "1.0"
;;    :go "_ConstructRouteMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RoutingMessage from syscall/route_bsd.go:
;; (defn ^"GoObject" RoutingMessage.
;;   "Constructor for syscall.RoutingMessage"
;;   {:added "1.0"
;;    :go "_ConstructRoutingMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RtMetrics from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RtMetrics.
;;   "Constructor for syscall.RtMetrics"
;;   {:added "1.0"
;;    :go "_ConstructRtMetrics(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.RtMsghdr from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" RtMsghdr.
;;   "Constructor for syscall.RtMsghdr"
;;   {:added "1.0"
;;    :go "_ConstructRtMsghdr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Rusage from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Rusage.
;;   "Constructor for syscall.Rusage"
;;   {:added "1.0"
;;    :go "_ConstructRusage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Signal from syscall/syscall_unix.go:
(defn ^"GoObject" Signal.
  "Constructor for syscall.Signal"
  {:added "1.0"
   :go "_ConstructSignal(_v)"}
  [^Object _v])

JOKER TYPE syscall.Sockaddr from syscall/syscall_unix.go:
;; (defn ^"GoObject" Sockaddr.
;;   "Constructor for syscall.Sockaddr"
;;   {:added "1.0"
;;    :go "_ConstructSockaddr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrDatalink from syscall/syscall_darwin.go:
;; (defn ^"GoObject" SockaddrDatalink.
;;   "Constructor for syscall.SockaddrDatalink"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrDatalink(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrInet4 from syscall/syscall_unix.go:
;; (defn ^"GoObject" SockaddrInet4.
;;   "Constructor for syscall.SockaddrInet4"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrInet4(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrInet6 from syscall/syscall_unix.go:
;; (defn ^"GoObject" SockaddrInet6.
;;   "Constructor for syscall.SockaddrInet6"
;;   {:added "1.0"
;;    :go "_ConstructSockaddrInet6(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SockaddrUnix from syscall/syscall_unix.go:
(defn ^"GoObject" SockaddrUnix.
  "Constructor for syscall.SockaddrUnix"
  {:added "1.0"
   :go "_ConstructSockaddrUnix(_v)"}
  [^Object _v])

JOKER TYPE syscall.SocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ^"GoObject" SocketControlMessage.
;;   "Constructor for syscall.SocketControlMessage"
;;   {:added "1.0"
;;    :go "_ConstructSocketControlMessage(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Stat_t from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Stat_t.
;;   "Constructor for syscall.Stat_t"
;;   {:added "1.0"
;;    :go "_ConstructStat_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Statfs_t from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Statfs_t.
;;   "Constructor for syscall.Statfs_t"
;;   {:added "1.0"
;;    :go "_ConstructStatfs_t(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.SysProcAttr from syscall/exec_darwin.go:
;; (defn ^"GoObject" SysProcAttr.
;;   "Constructor for syscall.SysProcAttr"
;;   {:added "1.0"
;;    :go "_ConstructSysProcAttr(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Termios from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Termios.
;;   "Constructor for syscall.Termios"
;;   {:added "1.0"
;;    :go "_ConstructTermios(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Timespec from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Timespec.
  "Constructor for syscall.Timespec"
  {:added "1.0"
   :go "_ConstructTimespec(_v)"}
  [^Object _v])

JOKER TYPE syscall.Timeval from syscall/ztypes_darwin_amd64.go:
;; (defn ^"GoObject" Timeval.
;;   "Constructor for syscall.Timeval"
;;   {:added "1.0"
;;    :go "_ConstructTimeval(_v)"}
;;   [^Object _v])

JOKER TYPE syscall.Timeval32 from syscall/ztypes_darwin_amd64.go:
(defn ^"GoObject" Timeval32.
  "Constructor for syscall.Timeval32"
  {:added "1.0"
   :go "_ConstructTimeval32(_v)"}
  [^Object _v])

JOKER TYPE syscall.WaitStatus from syscall/syscall_bsd.go:
(defn ^"GoObject" WaitStatus.
  "Constructor for syscall.WaitStatus"
  {:added "1.0"
   :go "_ConstructWaitStatus(_v)"}
  [^Object _v])

JOKER FUNC syscall.Accept from syscall/syscall_bsd.go:
(defn Accept
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__accept(fd)"}
  [^Int fd])

JOKER FUNC syscall.Access from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Access
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(path, mode)"}
  [^String path, ^Number mode])

JOKER FUNC syscall.Adjtime from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Adjtime
  "Go input arguments: (delta *Timeval, olddelta *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) delta, ^(atom-of go.std.syscall/Timeval) olddelta]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Adjtime(delta, olddelta)"}
  [^syscall/Timeval delta, ^syscall/Timeval olddelta])

JOKER FUNC syscall.Bind from syscall/syscall_unix.go:
(defn ^"Error" Bind
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Bind(fd, *sa)"}
  [^Int fd, ^syscall/Sockaddr sa])

JOKER FUNC syscall.BpfBuflen from syscall/bpf_darwin.go:
(defn BpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__bpfBuflen(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfDatalink from syscall/bpf_darwin.go:
(defn BpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__bpfDatalink(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfHeadercmpl from syscall/bpf_darwin.go:
(defn BpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__bpfHeadercmpl(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfInterface from syscall/bpf_darwin.go:
(defn BpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^Int fd, ^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__bpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.BpfJump from syscall/bpf_darwin.go:
(defn BpfJump
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int, jt int, jf int)\n\nGo return type: *BpfInsn\n\nJoker input arguments: [^Int code, ^Int k, ^Int jt, ^Int jf]\n\nJoker return type: (atom-of go.std.syscall/BpfInsn)"
  {:added "1.0"
   :go "__bpfJump(code, k, jt, jf)"}
  [^Int code, ^Int k, ^Int jt, ^Int jf])

JOKER FUNC syscall.BpfStats from syscall/bpf_darwin.go:
(defn BpfStats
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (*BpfStat, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [(atom-of go.std.syscall/BpfStat) Error]"
  {:added "1.0"
   :go "__bpfStats(fd)"}
  [^Int fd])

JOKER FUNC syscall.BpfStmt from syscall/bpf_darwin.go:
(defn BpfStmt
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int)\n\nGo return type: *BpfInsn\n\nJoker input arguments: [^Int code, ^Int k]\n\nJoker return type: (atom-of go.std.syscall/BpfInsn)"
  {:added "1.0"
   :go "__bpfStmt(code, k)"}
  [^Int code, ^Int k])

JOKER FUNC syscall.BpfTimeout from syscall/bpf_darwin.go:
(defn BpfTimeout
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: (*Timeval, error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [(atom-of go.std.syscall/Timeval) Error]"
  {:added "1.0"
   :go "__bpfTimeout(fd)"}
  [^Int fd])

JOKER FUNC syscall.BytePtrFromString from syscall/syscall.go:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: (*byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(atom-of Int) Error]"
  {:added "1.0"
   :go "__bytePtrFromString(s)"}
  [^String s])

JOKER FUNC syscall.ByteSliceFromString from syscall/syscall.go:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__byteSliceFromString(s)"}
  [^String s])

JOKER FUNC syscall.Chdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(path)"}
  [^String path])

JOKER FUNC syscall.CheckBpfVersion from syscall/bpf_darwin.go:
(defn ^"Error" CheckBpfVersion
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.CheckBpfVersion(fd)"}
  [^Int fd])

JOKER FUNC syscall.Chflags from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chflags
  "Go input arguments: (path string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chflags(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Chmod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chmod
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(path, mode)"}
  [^String path, ^Number mode])

JOKER FUNC syscall.Chown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Chroot from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Chroot
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(path)"}
  [^String path])

JOKER FUNC syscall.Clearenv from syscall/env_unix.go:
;; (defn Clearenv
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "__clearenv()"}
;;   [])

JOKER FUNC syscall.Close from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Close
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(fd)"}
  [^Int fd])

JOKER FUNC syscall.CloseOnExec from syscall/exec_unix.go:
;; (defn CloseOnExec
;;   "Go input arguments: (fd int)\n\nJoker input arguments: [^Int fd]"
;;   {:added "1.0"
;;    :go "__closeOnExec(fd)"}
;;   [^Int fd])

JOKER FUNC syscall.CmsgLen from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.CmsgSpace from syscall/sockcmsg_unix.go:
(defn ^"Int" CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(datalen)"}
  [^Int datalen])

JOKER FUNC syscall.Connect from syscall/syscall_unix.go:
(defn ^"Error" Connect
  "Go input arguments: (fd int, sa Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^go.std.syscall/Sockaddr sa]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Connect(fd, *sa)"}
  [^Int fd, ^syscall/Sockaddr sa])

JOKER FUNC syscall.Dup from syscall/zsyscall_darwin_amd64.go:
(defn Dup
  "Go input arguments: (fd int)\n\nGo return type: (nfd int, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__dup(fd)"}
  [^Int fd])

JOKER FUNC syscall.Dup2 from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Dup2
  "Go input arguments: (from int, to int)\n\nGo return type: error\n\nJoker input arguments: [^Int from, ^Int to]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(from, to)"}
  [^Int from, ^Int to])

JOKER FUNC syscall.Environ from syscall/env_unix.go:
(defn Environ
  "Go return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "__environ()"}
  [])

JOKER FUNC syscall.Exchangedata from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Exchangedata
  "Go input arguments: (path1 string, path2 string, options int)\n\nGo return type: error\n\nJoker input arguments: [^String path1, ^String path2, ^Int options]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Exchangedata(path1, path2, options)"}
  [^String path1, ^String path2, ^Int options])

JOKER FUNC syscall.Exec from syscall/exec_unix.go:
;; (defn ^"Error" Exec
;;   "Exec invokes the execve(2) system call.\n\nGo input arguments: (argv0 string, argv []string, envv []string)\n\nGo return type: error\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(vector-of String) envv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Exec(argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(argv)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(envv)))"}
;;   [^String argv0, ^Object argv, ^Object envv])

JOKER FUNC syscall.Exit from syscall/syscall.go:
;; (defn Exit
;;   "Go input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "__exit(code)"}
;;   [^Int code])

JOKER FUNC syscall.Fchdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchdir
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(fd)"}
  [^Int fd])

JOKER FUNC syscall.Fchflags from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchflags
  "Go input arguments: (fd int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchflags(fd, flags)"}
  [^Int fd, ^Int flags])

JOKER FUNC syscall.Fchmod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchmod
  "Go input arguments: (fd int, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(fd, mode)"}
  [^Int fd, ^Number mode])

JOKER FUNC syscall.Fchown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fchown
  "Go input arguments: (fd int, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(fd, uid, gid)"}
  [^Int fd, ^Int uid, ^Int gid])

JOKER FUNC syscall.FcntlFlock from syscall/flock_darwin.go:
(defn ^"Error" FcntlFlock
  "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo input arguments: (fd uintptr, cmd int, lk *Flock_t)\n\nGo return type: error\n\nJoker input arguments: [^Number fd, ^Int cmd, ^(atom-of go.std.syscall/Flock_t) lk]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FcntlFlock(fd, cmd, lk)"}
  [^Number fd, ^Int cmd, ^syscall/Flock_t lk])

JOKER FUNC syscall.Flock from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Flock
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(fd, how)"}
  [^Int fd, ^Int how])

JOKER FUNC syscall.FlushBpf from syscall/bpf_darwin.go:
(defn ^"Error" FlushBpf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.FlushBpf(fd)"}
  [^Int fd])

JOKER FUNC syscall.ForkExec from syscall/exec_unix.go:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__forkExec(argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(argv)), attr)"}
;;   [^String argv0, ^Object argv, ^syscall/ProcAttr attr])

JOKER FUNC syscall.Fpathconf from syscall/zsyscall_darwin_amd64.go:
(defn Fpathconf
  "Go input arguments: (fd int, name int)\n\nGo return type: (val int, err error)\n\nJoker input arguments: [^Int fd, ^Int name]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__fpathconf(fd, name)"}
  [^Int fd, ^Int name])

JOKER FUNC syscall.Fstat from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fstat
  "Go input arguments: (fd int, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstat(fd, stat)"}
  [^Int fd, ^syscall/Stat_t stat])

JOKER FUNC syscall.Fstatfs from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fstatfs
  "Go input arguments: (fd int, stat *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Statfs_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fstatfs(fd, stat)"}
  [^Int fd, ^syscall/Statfs_t stat])

JOKER FUNC syscall.Fsync from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Fsync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(fd)"}
  [^Int fd])

JOKER FUNC syscall.Ftruncate from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Ftruncate
  "Go input arguments: (fd int, length int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Number length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(fd, length)"}
  [^Int fd, ^Number length])

JOKER FUNC syscall.Futimes from syscall/syscall_bsd.go:
;; (defn ^"Error" Futimes
;;   "Go input arguments: (fd int, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*tv)))"}
;;   [^Int fd, ^Object tv])

JOKER FUNC syscall.Getdirentries from syscall/zsyscall_darwin_amd64.go:
;; (defn Getdirentries
;;   "Go input arguments: (fd int, buf []byte, basep *uintptr)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) buf, ^(atom-of Number) basep]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getdirentries(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuintptr(basep)))"}
;;   [^Int fd, ^Object buf, ^Object basep])

JOKER FUNC syscall.Getdtablesize from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getdtablesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getdtablesize()"}
  [])

JOKER FUNC syscall.Getegid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getegid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv from syscall/env_unix.go:
(defn Getenv
  "Go input arguments: (key string)\n\nGo return type: (value string, found bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Boolean]"
  {:added "1.0"
   :go "__getenv(key)"}
  [^String key])

JOKER FUNC syscall.Geteuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Geteuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getfsstat from syscall/syscall_darwin.go:
;; (defn Getfsstat
;;   "Go input arguments: (buf []Statfs_t, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of go.std.syscall/Statfs_t) buf, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__getfsstat(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Statfs_t(*buf)), flags)"}
;;   [^Object buf, ^Int flags])

JOKER FUNC syscall.Getgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getgid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups from syscall/syscall_bsd.go:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize from syscall/syscall.go:
(defn ^"Int" Getpagesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername from syscall/syscall_unix.go:
(defn Getpeername
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getpeername(fd)"}
  [^Int fd])

JOKER FUNC syscall.Getpgid from syscall/zsyscall_darwin_amd64.go:
(defn Getpgid
  "Go input arguments: (pid int)\n\nGo return type: (pgid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpgid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getpgrp from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getpgrp
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getpid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getppid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority from syscall/zsyscall_darwin_amd64.go:
(defn Getpriority
  "Go input arguments: (which int, who int)\n\nGo return type: (prio int, err error)\n\nJoker input arguments: [^Int which, ^Int who]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getpriority(which, who)"}
  [^Int which, ^Int who])

JOKER FUNC syscall.Getrlimit from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Getrlimit
  "Go input arguments: (which int, lim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^(atom-of go.std.syscall/Rlimit) lim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrlimit(which, lim)"}
  [^Int which, ^syscall/Rlimit lim])

JOKER FUNC syscall.Getrusage from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Getrusage
  "Go input arguments: (who int, rusage *Rusage)\n\nGo return type: error\n\nJoker input arguments: [^Int who, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Getrusage(who, rusage)"}
  [^Int who, ^syscall/Rusage rusage])

JOKER FUNC syscall.Getsid from syscall/zsyscall_darwin_amd64.go:
(defn Getsid
  "Go input arguments: (pid int)\n\nGo return type: (sid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getsid(pid)"}
  [^Int pid])

JOKER FUNC syscall.Getsockname from syscall/syscall_bsd.go:
(defn Getsockname
  "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [go.std.syscall/Sockaddr Error]"
  {:added "1.0"
   :go "__getsockname(fd)"}
  [^Int fd])

JOKER FUNC syscall.GetsockoptByte from syscall/syscall_bsd.go:
(defn GetsockoptByte
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getsockoptByte(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_bsd.go:
(defn GetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*ICMPv6Filter, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/ICMPv6Filter) Error]"
  {:added "1.0"
   :go "__getsockoptICMPv6Filter(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPMreq from syscall/syscall_bsd.go:
(defn GetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPMreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPMreq(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_bsd.go:
(defn GetsockoptIPv6MTUInfo
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6MTUInfo, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6MTUInfo) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6MTUInfo(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_bsd.go:
(defn GetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6Mreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(atom-of go.std.syscall/IPv6Mreq) Error]"
  {:added "1.0"
   :go "__getsockoptIPv6Mreq(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInet4Addr from syscall/syscall_bsd.go:
(defn GetsockoptInet4Addr
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value []byte, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__getsockoptInet4Addr(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
(defn GetsockoptInt
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__getsockoptInt(fd, level, opt)"}
  [^Int fd, ^Int level, ^Int opt])

JOKER FUNC syscall.Gettimeofday from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Gettimeofday
  "Go input arguments: (tp *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tp]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Gettimeofday(tp)"}
  [^syscall/Timeval tp])

JOKER FUNC syscall.Getuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Getuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd from syscall/syscall_darwin.go:
(defn Getwd
  "Go return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__getwd()"}
  [])

JOKER FUNC syscall.Issetugid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Boolean" Issetugid
  "Go return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "syscall.Issetugid()"}
  [])

JOKER FUNC syscall.Kevent from syscall/syscall_bsd.go:
;; (defn Kevent
;;   "Go input arguments: (kq int, changes []Kevent_t, events []Kevent_t, timeout *Timespec)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int kq, ^(vector-of go.std.syscall/Kevent_t) changes, ^(vector-of go.std.syscall/Kevent_t) events, ^(atom-of go.std.syscall/Timespec) timeout]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__kevent(kq, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Kevent_t(*changes)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Kevent_t(*events)), timeout)"}
;;   [^Int kq, ^Object changes, ^Object events, ^syscall/Timespec timeout])

JOKER FUNC syscall.Kill from syscall/syscall_darwin.go:
(defn ^"Error" Kill
  "Go input arguments: (pid int, signum Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^go.std.syscall/Signal signum]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Kill(pid, *signum)"}
  [^Int pid, ^syscall/Signal signum])

JOKER FUNC syscall.Kqueue from syscall/zsyscall_darwin_amd64.go:
(defn Kqueue
  "Go return type: (fd int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__kqueue()"}
  [])

JOKER FUNC syscall.Lchown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Lchown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(path, uid, gid)"}
  [^String path, ^Int uid, ^Int gid])

JOKER FUNC syscall.Link from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Link
  "Go input arguments: (path string, link string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String link]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Listen from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Listen
  "Go input arguments: (s int, backlog int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int backlog]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(s, backlog)"}
  [^Int s, ^Int backlog])

JOKER FUNC syscall.Lstat from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Lstat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lstat(path, stat)"}
  [^String path, ^syscall/Stat_t stat])

JOKER FUNC syscall.Mkdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mkdir
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(path, mode)"}
  [^String path, ^Number mode])

JOKER FUNC syscall.Mkfifo from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mkfifo
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(path, mode)"}
  [^String path, ^Number mode])

JOKER FUNC syscall.Mknod from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mknod
  "Go input arguments: (path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(path, mode, dev)"}
  [^String path, ^Number mode, ^Int dev])

JOKER FUNC syscall.Mlock from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Mlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC syscall.Mlockall from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Mlockall
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(flags)"}
  [^Int flags])

JOKER FUNC syscall.Mmap from syscall/syscall_bsd.go:
(defn Mmap
  "Go input arguments: (fd int, offset int64, length int, prot int, flags int)\n\nGo return type: (data []byte, err error)\n\nJoker input arguments: [^Int fd, ^Number offset, ^Int length, ^Int prot, ^Int flags]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__mmap(fd, offset, length, prot, flags)"}
  [^Int fd, ^Number offset, ^Int length, ^Int prot, ^Int flags])

JOKER FUNC syscall.Mprotect from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Mprotect
;;   "Go input arguments: (b []byte, prot int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b, ^Int prot]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mprotect(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), prot)"}
;;   [^Object b, ^Int prot])

JOKER FUNC syscall.Munlock from syscall/zsyscall_darwin_amd64.go:
;; (defn ^"Error" Munlock
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munlock(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC syscall.Munlockall from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Munlockall
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap from syscall/syscall_bsd.go:
;; (defn ^"Error" Munmap
;;   "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Munmap(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC syscall.NsecToTimespec from syscall/timestruct.go:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timespec\n\nJoker input arguments: [^Number nsec]\n\nJoker return type: go.std.syscall/Timespec"
  {:added "1.0"
   :go "__nsecToTimespec(nsec)"}
  [^Number nsec])

JOKER FUNC syscall.NsecToTimeval from syscall/timestruct.go:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timeval\n\nJoker input arguments: [^Number nsec]\n\nJoker return type: go.std.syscall/Timeval"
  {:added "1.0"
   :go "__nsecToTimeval(nsec)"}
  [^Number nsec])

JOKER FUNC syscall.Open from syscall/zsyscall_darwin_amd64.go:
(defn Open
  "Go input arguments: (path string, mode int, perm uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Int mode, ^Number perm]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__open(path, mode, perm)"}
  [^String path, ^Int mode, ^Number perm])

JOKER FUNC syscall.ParseDirent from syscall/dirent.go:
;; (defn ParseDirent
;;   "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo input arguments: (buf []byte, max int, names []string)\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker input arguments: [^(vector-of Int) buf, ^Int max, ^(vector-of String) names]\n\nJoker return type: [Int Int (vector-of String)]"
;;   {:added "1.0"
;;    :go "__parseDirent(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), max, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(names)))"}
;;   [^Object buf, ^Int max, ^Object names])

JOKER FUNC syscall.ParseRoutingMessage from syscall/route_bsd.go:
;; (defn ParseRoutingMessage
;;   "ParseRoutingMessage parses b as routing messages and returns the\nslice containing the RoutingMessage interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (b []byte)\n\nGo return type: (msgs []RoutingMessage, err error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [(vector-of go.std.syscall/RoutingMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseRoutingMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC syscall.ParseRoutingSockaddr from syscall/route_bsd.go:
(defn ParseRoutingSockaddr
  "ParseRoutingSockaddr parses msg's payload as raw sockaddrs and\nreturns the slice containing the Sockaddr interfaces.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (msg RoutingMessage)\n\nGo return type: ([]Sockaddr, error)\n\nJoker input arguments: [^go.std.syscall/RoutingMessage msg]\n\nJoker return type: [(vector-of go.std.syscall/Sockaddr) Error]"
  {:added "1.0"
   :go "__parseRoutingSockaddr(*msg)"}
  [^syscall/RoutingMessage msg])

JOKER FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: [(vector-of go.std.syscall/SocketControlMessage) Error]"
;;   {:added "1.0"
;;    :go "__parseSocketControlMessage(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^Object b])

JOKER FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
(defn ParseUnixRights
  "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo input arguments: (m *SocketControlMessage)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of go.std.syscall/SocketControlMessage) m]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__parseUnixRights(m)"}
  [^syscall/SocketControlMessage m])

JOKER FUNC syscall.Pathconf from syscall/zsyscall_darwin_amd64.go:
(defn Pathconf
  "Go input arguments: (path string, name int)\n\nGo return type: (val int, err error)\n\nJoker input arguments: [^String path, ^Int name]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__pathconf(path, name)"}
  [^String path, ^Int name])

JOKER FUNC syscall.Pipe from syscall/syscall_darwin.go:
;; (defn ^"Error" Pipe
;;   "Go input arguments: (p []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Pipe(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(p)))"}
;;   [^Object p])

JOKER FUNC syscall.Pread from syscall/zsyscall_darwin_amd64.go:
;; (defn Pread
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Number offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pread(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), offset)"}
;;   [^Int fd, ^Object p, ^Number offset])

JOKER FUNC syscall.PtraceAttach from syscall/syscall_darwin.go:
(defn ^"Error" PtraceAttach
  "sys   ptrace(request int, pid int, addr uintptr, data uintptr) (err error)\n\nGo input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(pid)"}
  [^Int pid])

JOKER FUNC syscall.PtraceDetach from syscall/syscall_darwin.go:
(defn ^"Error" PtraceDetach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(pid)"}
  [^Int pid])

JOKER FUNC syscall.Pwrite from syscall/zsyscall_darwin_amd64.go:
;; (defn Pwrite
;;   "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Number offset]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__pwrite(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), offset)"}
;;   [^Int fd, ^Object p, ^Number offset])

JOKER FUNC syscall.RawSyscall from syscall/syscall_unix.go:
;; (defn RawSyscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__rawSyscall(trap, a1, a2, a3)"}
;;   [^Number trap, ^Number a1, ^Number a2, ^Number a3])

JOKER FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
;; (defn RawSyscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__rawSyscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6])

JOKER FUNC syscall.Read from syscall/syscall_unix.go:
;; (defn Read
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__read(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Int fd, ^Object p])

JOKER FUNC syscall.ReadDirent from syscall/syscall_bsd.go:
;; (defn ReadDirent
;;   "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readDirent(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^Int fd, ^Object buf])

JOKER FUNC syscall.Readlink from syscall/zsyscall_darwin_amd64.go:
;; (defn Readlink
;;   "Go input arguments: (path string, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Int) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__readlink(path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))"}
;;   [^String path, ^Object buf])

JOKER FUNC syscall.Recvfrom from syscall/syscall_unix.go:
;; (defn Recvfrom
;;   "Go input arguments: (fd int, p []byte, flags int)\n\nGo return type: (n int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Int flags]\n\nJoker return type: [Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvfrom(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), flags)"}
;;   [^Int fd, ^Object p, ^Int flags])

JOKER FUNC syscall.Recvmsg from syscall/syscall_bsd.go:
;; (defn Recvmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, flags int)\n\nGo return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^Int flags]\n\nJoker return type: [Int Int Int go.std.syscall/Sockaddr Error]"
;;   {:added "1.0"
;;    :go "__recvmsg(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), flags)"}
;;   [^Int fd, ^Object p, ^Object oob, ^Int flags])

JOKER FUNC syscall.Rename from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Rename
  "Go input arguments: (from string, to string)\n\nGo return type: error\n\nJoker input arguments: [^String from, ^String to]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(from, to)"}
  [^String from, ^String to])

JOKER FUNC syscall.Revoke from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Revoke
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Revoke(path)"}
  [^String path])

JOKER FUNC syscall.Rmdir from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Rmdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(path)"}
  [^String path])

JOKER FUNC syscall.RouteRIB from syscall/route_bsd.go:
(defn RouteRIB
  "RouteRIB returns routing information base, as known as RIB,\nwhich consists of network facility information, states and\nparameters.\n\nDeprecated: Use golang.org/x/net/route instead.\n\nGo input arguments: (facility int, param int)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^Int facility, ^Int param]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__routeRIB(facility, param)"}
  [^Int facility, ^Int param])

JOKER FUNC syscall.Seek from syscall/zsyscall_darwin_amd64.go:
(defn Seek
  "Go input arguments: (fd int, offset int64, whence int)\n\nGo return type: (newoffset int64, err error)\n\nJoker input arguments: [^Int fd, ^Number offset, ^Int whence]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__seek(fd, offset, whence)"}
  [^Int fd, ^Number offset, ^Int whence])

JOKER FUNC syscall.Select from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Select
  "Go input arguments: (n int, r *FdSet, w *FdSet, e *FdSet, timeout *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int n, ^(atom-of go.std.syscall/FdSet) r, ^(atom-of go.std.syscall/FdSet) w, ^(atom-of go.std.syscall/FdSet) e, ^(atom-of go.std.syscall/Timeval) timeout]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Select(n, r, w, e, timeout)"}
  [^Int n, ^syscall/FdSet r, ^syscall/FdSet w, ^syscall/FdSet e, ^syscall/Timeval timeout])

JOKER FUNC syscall.Sendfile from syscall/syscall_unix.go:
;; (defn Sendfile
;;   "Go input arguments: (outfd int, infd int, offset *int64, count int)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^Int outfd, ^Int infd, ^(atom-of Number) offset, ^Int count]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendfile(outfd, infd, ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(offset)), count)"}
;;   [^Int outfd, ^Int infd, ^Object offset, ^Int count])

JOKER FUNC syscall.Sendmsg from syscall/syscall_bsd.go:
;; (defn ^"Error" Sendmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), *to, flags)"}
;;   [^Int fd, ^Object p, ^Object oob, ^syscall/Sockaddr to, ^Int flags])

JOKER FUNC syscall.SendmsgN from syscall/syscall_bsd.go:
;; (defn SendmsgN
;;   "Go input arguments: (fd int, p []byte, oob []byte, to Sockaddr, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^(vector-of Int) oob, ^go.std.syscall/Sockaddr to, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__sendmsgN(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), *to, flags)"}
;;   [^Int fd, ^Object p, ^Object oob, ^syscall/Sockaddr to, ^Int flags])

JOKER FUNC syscall.Sendto from syscall/syscall_unix.go:
;; (defn ^"Error" Sendto
;;   "Go input arguments: (fd int, p []byte, flags int, to Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p, ^Int flags, ^go.std.syscall/Sockaddr to]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), flags, *to)"}
;;   [^Int fd, ^Object p, ^Int flags, ^syscall/Sockaddr to])

JOKER FUNC syscall.SetBpf from syscall/bpf_darwin.go:
;; (defn ^"Error" SetBpf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, i []BpfInsn)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of go.std.syscall/BpfInsn) i]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetBpf(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.BpfInsn(*i)))"}
;;   [^Int fd, ^Object i])

JOKER FUNC syscall.SetBpfBuflen from syscall/bpf_darwin.go:
(defn SetBpfBuflen
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, l int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd, ^Int l]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__setBpfBuflen(fd, l)"}
  [^Int fd, ^Int l])

JOKER FUNC syscall.SetBpfDatalink from syscall/bpf_darwin.go:
(defn SetBpfDatalink
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, t int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int fd, ^Int t]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__setBpfDatalink(fd, t)"}
  [^Int fd, ^Int t])

JOKER FUNC syscall.SetBpfHeadercmpl from syscall/bpf_darwin.go:
(defn ^"Error" SetBpfHeadercmpl
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, f int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int f]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfHeadercmpl(fd, f)"}
  [^Int fd, ^Int f])

JOKER FUNC syscall.SetBpfImmediate from syscall/bpf_darwin.go:
(defn ^"Error" SetBpfImmediate
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, m int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfImmediate(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfInterface from syscall/bpf_darwin.go:
(defn ^"Error" SetBpfInterface
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, name string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfInterface(fd, name)"}
  [^Int fd, ^String name])

JOKER FUNC syscall.SetBpfPromisc from syscall/bpf_darwin.go:
(defn ^"Error" SetBpfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, m int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfPromisc(fd, m)"}
  [^Int fd, ^Int m])

JOKER FUNC syscall.SetBpfTimeout from syscall/bpf_darwin.go:
(defn ^"Error" SetBpfTimeout
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetBpfTimeout(fd, tv)"}
  [^Int fd, ^syscall/Timeval tv])

JOKER FUNC syscall.SetKevent from syscall/syscall_darwin_amd64.go:
;; (defn SetKevent
;;   "Go input arguments: (k *Kevent_t, fd int, mode int, flags int)\n\nJoker input arguments: [^(atom-of go.std.syscall/Kevent_t) k, ^Int fd, ^Int mode, ^Int flags]"
;;   {:added "1.0"
;;    :go "__setKevent(k, fd, mode, flags)"}
;;   [^syscall/Kevent_t k, ^Int fd, ^Int mode, ^Int flags])

JOKER FUNC syscall.SetNonblock from syscall/exec_unix.go:
(defn ^"Error" SetNonblock
  "Go input arguments: (fd int, nonblocking bool)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Boolean nonblocking]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(fd, nonblocking)"}
  [^Int fd, ^Boolean nonblocking])

JOKER FUNC syscall.Setegid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setegid
  "Go input arguments: (egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setegid(egid)"}
  [^Int egid])

JOKER FUNC syscall.Setenv from syscall/env_unix.go:
(defn ^"Error" Setenv
  "Go input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(key, value)"}
  [^String key, ^String value])

JOKER FUNC syscall.Seteuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Seteuid
  "Go input arguments: (euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Seteuid(euid)"}
  [^Int euid])

JOKER FUNC syscall.Setgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(gid)"}
  [^Int gid])

JOKER FUNC syscall.Setgroups from syscall/syscall_bsd.go:
;; (defn ^"Error" Setgroups
;;   "Go input arguments: (gids []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) gids]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setgroups(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(gids)))"}
;;   [^Object gids])

JOKER FUNC syscall.Setlogin from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setlogin
  "Go input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setlogin(name)"}
  [^String name])

JOKER FUNC syscall.Setpgid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setpgid
  "Go input arguments: (pid int, pgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int pgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(pid, pgid)"}
  [^Int pid, ^Int pgid])

JOKER FUNC syscall.Setpriority from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setpriority
  "Go input arguments: (which int, who int, prio int)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^Int who, ^Int prio]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(which, who, prio)"}
  [^Int which, ^Int who, ^Int prio])

JOKER FUNC syscall.Setprivexec from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setprivexec
  "Go input arguments: (flag int)\n\nGo return type: error\n\nJoker input arguments: [^Int flag]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setprivexec(flag)"}
  [^Int flag])

JOKER FUNC syscall.Setregid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setregid
  "Go input arguments: (rgid int, egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(rgid, egid)"}
  [^Int rgid, ^Int egid])

JOKER FUNC syscall.Setreuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setreuid
  "Go input arguments: (ruid int, euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(ruid, euid)"}
  [^Int ruid, ^Int euid])

JOKER FUNC syscall.Setrlimit from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setrlimit
  "Go input arguments: (which int, lim *Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^(atom-of go.std.syscall/Rlimit) lim]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setrlimit(which, lim)"}
  [^Int which, ^syscall/Rlimit lim])

JOKER FUNC syscall.Setsid from syscall/zsyscall_darwin_amd64.go:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptByte
  "Go input arguments: (fd int, level int, opt int, value byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptICMPv6Filter from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int, filter *ICMPv6Filter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/ICMPv6Filter) filter]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptICMPv6Filter(fd, level, opt, filter)"}
  [^Int fd, ^Int level, ^Int opt, ^syscall/ICMPv6Filter filter])

JOKER FUNC syscall.SetsockoptIPMreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPMreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPMreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPMreq(fd, level, opt, mreq)"}
  [^Int fd, ^Int level, ^Int opt, ^syscall/IPMreq mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int, mreq *IPv6Mreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/IPv6Mreq) mreq]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptIPv6Mreq(fd, level, opt, mreq)"}
  [^Int fd, ^Int level, ^Int opt, ^syscall/IPv6Mreq mreq])

JOKER FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
;; (defn ^"Error" SetsockoptInet4Addr
;;   "Go input arguments: (fd int, level int, opt int, value []byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(vector-of Int) value]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(fd, level, opt, ABEND901(pre.go: specific-length arrays not supported: ConvertToArrayOfbyte(value)))"}
;;   [^Int fd, ^Int level, ^Int opt, ^Object value])

JOKER FUNC syscall.SetsockoptInt from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptInt
  "Go input arguments: (fd int, level int, opt int, value int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(fd, level, opt, value)"}
  [^Int fd, ^Int level, ^Int opt, ^Int value])

JOKER FUNC syscall.SetsockoptLinger from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptLinger
  "Go input arguments: (fd int, level int, opt int, l *Linger)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Linger) l]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptLinger(fd, level, opt, l)"}
  [^Int fd, ^Int level, ^Int opt, ^syscall/Linger l])

JOKER FUNC syscall.SetsockoptString from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptString
  "Go input arguments: (fd int, level int, opt int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(fd, level, opt, s)"}
  [^Int fd, ^Int level, ^Int opt, ^String s])

JOKER FUNC syscall.SetsockoptTimeval from syscall/syscall_unix.go:
(defn ^"Error" SetsockoptTimeval
  "Go input arguments: (fd int, level int, opt int, tv *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptTimeval(fd, level, opt, tv)"}
  [^Int fd, ^Int level, ^Int opt, ^syscall/Timeval tv])

JOKER FUNC syscall.Settimeofday from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Settimeofday
  "Go input arguments: (tp *Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go.std.syscall/Timeval) tp]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Settimeofday(tp)"}
  [^syscall/Timeval tp])

JOKER FUNC syscall.Setuid from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Setuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(uid)"}
  [^Int uid])

JOKER FUNC syscall.Shutdown from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Shutdown
  "Go input arguments: (s int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(s, how)"}
  [^Int s, ^Int how])

JOKER FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
;; (defn SlicePtrFromStrings
;;   "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo input arguments: (ss []string)\n\nGo return type: ([]*byte, error)\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: [(vector-of (atom-of Int)) Error]"
;;   {:added "1.0"
;;    :go "__slicePtrFromStrings(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(ss)))"}
;;   [^Object ss])

JOKER FUNC syscall.Socket from syscall/syscall_unix.go:
(defn Socket
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__socket(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.Socketpair from syscall/syscall_unix.go:
(defn Socketpair
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd []int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "__socketpair(domain, typ, proto)"}
  [^Int domain, ^Int typ, ^Int proto])

JOKER FUNC syscall.StartProcess from syscall/exec_unix.go:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo input arguments: (argv0 string, argv []string, attr *ProcAttr)\n\nGo return type: (pid int, handle uintptr, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of go.std.syscall/ProcAttr) attr]\n\nJoker return type: [Int Number Error]"
;;   {:added "1.0"
;;    :go "__startProcess(argv0, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(argv)), attr)"}
;;   [^String argv0, ^Object argv, ^syscall/ProcAttr attr])

JOKER FUNC syscall.Stat from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Stat
  "Go input arguments: (path string, stat *Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Stat_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Stat(path, stat)"}
  [^String path, ^syscall/Stat_t stat])

JOKER FUNC syscall.Statfs from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Statfs
  "Go input arguments: (path string, stat *Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of go.std.syscall/Statfs_t) stat]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Statfs(path, stat)"}
  [^String path, ^syscall/Statfs_t stat])

JOKER FUNC syscall.StringBytePtr from syscall/syscall.go:
(defn StringBytePtr
  "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: *byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (atom-of Int)"
  {:added "1.0"
   :go "__stringBytePtr(s)"}
  [^String s])

JOKER FUNC syscall.StringByteSlice from syscall/syscall.go:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: []byte\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "__stringByteSlice(s)"}
  [^String s])

JOKER FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
;; (defn StringSlicePtr
;;   "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo input arguments: (ss []string)\n\nGo return type: []*byte\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: (vector-of (atom-of Int))"
;;   {:added "1.0"
;;    :go "__stringSlicePtr(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(ss)))"}
;;   [^Object ss])

JOKER FUNC syscall.Symlink from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Symlink
  "Go input arguments: (path string, link string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String link]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(path, link)"}
  [^String path, ^String link])

JOKER FUNC syscall.Sync from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Sync
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sync()"}
  [])

JOKER FUNC syscall.Syscall from syscall/syscall_unix.go:
;; (defn Syscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__syscall(trap, a1, a2, a3)"}
;;   [^Number trap, ^Number a1, ^Number a2, ^Number a3])

JOKER FUNC syscall.Syscall6 from syscall/syscall_unix.go:
;; (defn Syscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__syscall6(trap, a1, a2, a3, a4, a5, a6)"}
;;   [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6])

JOKER FUNC syscall.Syscall9 from syscall/syscall_darwin_amd64.go:
;; (defn Syscall9
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr)\n\nGo return type: (r1 uintptr, r2 uintptr, err Errno)\n\nJoker input arguments: [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6, ^Number a7, ^Number a8, ^Number a9]\n\nJoker return type: [Number Number go.std.syscall/Errno]"
;;   {:added "1.0"
;;    :go "__syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)"}
;;   [^Number trap, ^Number a1, ^Number a2, ^Number a3, ^Number a4, ^Number a5, ^Number a6, ^Number a7, ^Number a8, ^Number a9])

JOKER FUNC syscall.Sysctl from syscall/syscall_bsd.go:
(defn Sysctl
  "Go input arguments: (name string)\n\nGo return type: (value string, err error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__sysctl(name)"}
  [^String name])

JOKER FUNC syscall.SysctlUint32 from syscall/syscall_bsd.go:
(defn SysctlUint32
  "Go input arguments: (name string)\n\nGo return type: (value uint32, err error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [Number Error]"
  {:added "1.0"
   :go "__sysctlUint32(name)"}
  [^String name])

JOKER FUNC syscall.TimespecToNsec from syscall/timestruct.go:
(defn TimespecToNsec
  "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo input arguments: (ts Timespec)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timespec ts]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__timespecToNsec(*ts)"}
  [^syscall/Timespec ts])

JOKER FUNC syscall.TimevalToNsec from syscall/timestruct.go:
(defn TimevalToNsec
  "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo input arguments: (tv Timeval)\n\nGo return type: int64\n\nJoker input arguments: [^go.std.syscall/Timeval tv]\n\nJoker return type: Number"
  {:added "1.0"
   :go "__timevalToNsec(*tv)"}
  [^syscall/Timeval tv])

JOKER FUNC syscall.Truncate from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Truncate
  "Go input arguments: (path string, length int64)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Number length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(path, length)"}
  [^String path, ^Number length])

JOKER FUNC syscall.Umask from syscall/zsyscall_darwin_amd64.go:
(defn ^"Int" Umask
  "Go input arguments: (newmask int)\n\nGo return type: int\n\nJoker input arguments: [^Int newmask]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(newmask)"}
  [^Int newmask])

JOKER FUNC syscall.Undelete from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Undelete
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Undelete(path)"}
  [^String path])

JOKER FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo input arguments: (fds ...int)\n\nGo return type: []byte\n\nJoker input arguments: [^(ellipsis-somehow Int) fds]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__unixRights(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHaint(fds)))"}
;;   [^Int fds])

JOKER FUNC syscall.Unlink from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Unlink
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(path)"}
  [^String path])

JOKER FUNC syscall.Unmount from syscall/zsyscall_darwin_amd64.go:
(defn ^"Error" Unmount
  "Go input arguments: (path string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(path, flags)"}
  [^String path, ^Int flags])

JOKER FUNC syscall.Unsetenv from syscall/env_unix.go:
(defn ^"Error" Unsetenv
  "Go input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(key)"}
  [^String key])

JOKER FUNC syscall.Utimes from syscall/syscall_bsd.go:
;; (defn ^"Error" Utimes
;;   "Go input arguments: (path string, tv []Timeval)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timeval(*tv)))"}
;;   [^String path, ^Object tv])

JOKER FUNC syscall.UtimesNano from syscall/syscall_bsd.go:
;; (defn ^"Error" UtimesNano
;;   "Go input arguments: (path string, ts []Timespec)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of go.std.syscall/Timespec) ts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(path, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_syscall.Timespec(*ts)))"}
;;   [^String path, ^Object ts])

JOKER FUNC syscall.Wait4 from syscall/syscall_bsd.go:
(defn Wait4
  "Go input arguments: (pid int, wstatus *WaitStatus, options int, rusage *Rusage)\n\nGo return type: (wpid int, err error)\n\nJoker input arguments: [^Int pid, ^(atom-of go.std.syscall/WaitStatus) wstatus, ^Int options, ^(atom-of go.std.syscall/Rusage) rusage]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__wait4(pid, wstatus, options, rusage)"}
  [^Int pid, ^syscall/WaitStatus wstatus, ^Int options, ^syscall/Rusage rusage])

JOKER FUNC syscall.Write from syscall/syscall_unix.go:
;; (defn Write
;;   "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Int) p]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "__write(fd, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Int fd, ^Object p])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["syscall"]
    :doc "Provides a low-level interface to the syscall package."
    :empty false}
  go.std.syscall)
JOKER TYPE testing.B from testing/benchmark.go:
(defn ^"GoObject" B.
  "Constructor for testing.B"
  {:added "1.0"
   :go "_ConstructB(_v)"}
  [^Object _v])

JOKER TYPE testing.BenchmarkResult from testing/benchmark.go:
;; (defn ^"GoObject" BenchmarkResult.
;;   "Constructor for testing.BenchmarkResult"
;;   {:added "1.0"
;;    :go "_ConstructBenchmarkResult(_v)"}
;;   [^Object _v])

JOKER TYPE testing.Cover from testing/cover.go:
;; (defn ^"GoObject" Cover.
;;   "Constructor for testing.Cover"
;;   {:added "1.0"
;;    :go "_ConstructCover(_v)"}
;;   [^Object _v])

JOKER TYPE testing.CoverBlock from testing/cover.go:
(defn ^"GoObject" CoverBlock.
  "Constructor for testing.CoverBlock"
  {:added "1.0"
   :go "_ConstructCoverBlock(_v)"}
  [^Object _v])

JOKER TYPE testing.InternalBenchmark from testing/benchmark.go:
;; (defn ^"GoObject" InternalBenchmark.
;;   "Constructor for testing.InternalBenchmark"
;;   {:added "1.0"
;;    :go "_ConstructInternalBenchmark(_v)"}
;;   [^Object _v])

JOKER TYPE testing.InternalExample from testing/example.go:
;; (defn ^"GoObject" InternalExample.
;;   "Constructor for testing.InternalExample"
;;   {:added "1.0"
;;    :go "_ConstructInternalExample(_v)"}
;;   [^Object _v])

JOKER TYPE testing.InternalTest from testing/testing.go:
;; (defn ^"GoObject" InternalTest.
;;   "Constructor for testing.InternalTest"
;;   {:added "1.0"
;;    :go "_ConstructInternalTest(_v)"}
;;   [^Object _v])

JOKER TYPE testing.M from testing/testing.go:
(defn ^"GoObject" M.
  "Constructor for testing.M"
  {:added "1.0"
   :go "_ConstructM(_v)"}
  [^Object _v])

JOKER TYPE testing.PB from testing/benchmark.go:
(defn ^"GoObject" PB.
  "Constructor for testing.PB"
  {:added "1.0"
   :go "_ConstructPB(_v)"}
  [^Object _v])

JOKER TYPE testing.T from testing/testing.go:
(defn ^"GoObject" T.
  "Constructor for testing.T"
  {:added "1.0"
   :go "_ConstructT(_v)"}
  [^Object _v])

JOKER TYPE testing.TB from testing/testing.go:
;; (defn ^"GoObject" TB.
;;   "Constructor for testing.TB"
;;   {:added "1.0"
;;    :go "_ConstructTB(_v)"}
;;   [^Object _v])

JOKER FUNC testing.AllocsPerRun from testing/allocs.go:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo input arguments: (runs int, f func)\n\nGo return type: float64\n\nJoker input arguments: [^Int runs, ^fn f]\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__allocsPerRun(runs, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^Int runs, ^fn f])

JOKER FUNC testing.Benchmark from testing/benchmark.go:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo input arguments: (f func)\n\nGo return type: BenchmarkResult\n\nJoker input arguments: [^fn f]\n\nJoker return type: go.std.testing/BenchmarkResult"
;;   {:added "1.0"
;;    :go "__benchmark(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^fn f])

JOKER FUNC testing.CoverMode from testing/testing.go:
(defn ^"String" CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage from testing/cover.go:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: float64\n\nJoker input arguments: []\n\nJoker return type: Double"
;;   {:added "1.0"
;;    :go "__coverage()"}
;;   [])

JOKER FUNC testing.Main from testing/testing.go:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n\nGo input arguments: (matchString func, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]"
;;   {:added "1.0"
;;    :go "__main(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*examples)))"}
;;   [^fn matchString, ^Object tests, ^Object benchmarks, ^Object examples])

JOKER FUNC testing.MainStart from testing/testing.go:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo input arguments: (deps testDeps, tests []InternalTest, benchmarks []InternalBenchmark, examples []InternalExample)\n\nGo return type: *M\n\nJoker input arguments: [^testDeps deps, ^(vector-of go.std.testing/InternalTest) tests, ^(vector-of go.std.testing/InternalBenchmark) benchmarks, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: (atom-of go.std.testing/M)"
;;   {:added "1.0"
;;    :go "__mainStart(deps, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*tests)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*benchmarks)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*examples)))"}
;;   [^ABEND044(pre.go: unsupported built-in type testDeps) deps, ^Object tests, ^Object benchmarks, ^Object examples])

JOKER FUNC testing.RegisterCover from testing/cover.go:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n\nGo input arguments: (c Cover)\n\nJoker input arguments: [^go.std.testing/Cover c]"
;;   {:added "1.0"
;;    :go "__registerCover(*c)"}
;;   [^testing/Cover c])

JOKER FUNC testing.RunBenchmarks from testing/benchmark.go:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, benchmarks []InternalBenchmark)\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalBenchmark) benchmarks]"
;;   {:added "1.0"
;;    :go "__runBenchmarks(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalBenchmark(*benchmarks)))"}
;;   [^fn matchString, ^Object benchmarks])

JOKER FUNC testing.RunExamples from testing/example.go:
;; (defn ^"Boolean" RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, examples []InternalExample)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalExample) examples]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunExamples(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalExample(*examples)))"}
;;   [^fn matchString, ^Object examples])

JOKER FUNC testing.RunTests from testing/testing.go:
;; (defn ^"Boolean" RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, tests []InternalTest)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of go.std.testing/InternalTest) tests]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "testing.RunTests(ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_testing.InternalTest(*tests)))"}
;;   [^fn matchString, ^Object tests])

JOKER FUNC testing.Short from testing/testing.go:
(defn ^"Boolean" Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose from testing/testing.go:
(defn ^"Boolean" Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["testing"]
    :doc "Provides a low-level interface to the testing package."
    :empty false}
  go.std.testing)
JOKER FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__dataErrReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__halfReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo input arguments: (prefix string, r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^String prefix, ^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__newReadLogger(prefix, *r)"}
;;   [^String prefix, ^io/Reader r])

JOKER FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo input arguments: (prefix string, w io.Writer)\n\nGo return type: io.Writer\n\nJoker input arguments: [^String prefix, ^go.std.io/Writer w]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__newWriteLogger(prefix, *w)"}
;;   [^String prefix, ^io/Writer w])

JOKER FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__oneByteReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo input arguments: (r io.Reader)\n\nGo return type: io.Reader\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: go.std.io/Reader"
;;   {:added "1.0"
;;    :go "__timeoutReader(*r)"}
;;   [^io/Reader r])

JOKER FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo input arguments: (w io.Writer, n int64)\n\nGo return type: io.Writer\n\nJoker input arguments: [^go.std.io/Writer w, ^Number n]\n\nJoker return type: go.std.io/Writer"
;;   {:added "1.0"
;;    :go "__truncateWriter(*w, n)"}
;;   [^io/Writer w, ^Number n])

JOKER TYPE testing/quick.CheckEqualError from testing/quick/quick.go:
;; (defn ^"GoObject" CheckEqualError.
;;   "Constructor for quick.CheckEqualError"
;;   {:added "1.0"
;;    :go "_ConstructCheckEqualError(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.CheckError from testing/quick/quick.go:
;; (defn ^"GoObject" CheckError.
;;   "Constructor for quick.CheckError"
;;   {:added "1.0"
;;    :go "_ConstructCheckError(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.Config from testing/quick/quick.go:
;; (defn ^"GoObject" Config.
;;   "Constructor for quick.Config"
;;   {:added "1.0"
;;    :go "_ConstructConfig(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.Generator from testing/quick/quick.go:
;; (defn ^"GoObject" Generator.
;;   "Constructor for quick.Generator"
;;   {:added "1.0"
;;    :go "_ConstructGenerator(_v)"}
;;   [^Object _v])

JOKER TYPE testing/quick.SetupError from testing/quick/quick.go:
(defn ^"GoObject" SetupError.
  "Constructor for quick.SetupError"
  {:added "1.0"
   :go "_ConstructSetupError(_v)"}
  [^Object _v])

JOKER FUNC testing/quick.Check from testing/quick/quick.go:
;; (defn ^"Error" Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo input arguments: (f interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), config)"}
;;   [^<protocol-or-something> f, ^quick/Config config])

JOKER FUNC testing/quick.CheckEqual from testing/quick/quick.go:
;; (defn ^"Error" CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo input arguments: (f interface {}, g interface {}, config *Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^<protocol-or-something> g, ^(atom-of go.std.testing.quick/Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), config)"}
;;   [^<protocol-or-something> f, ^<protocol-or-something> g, ^quick/Config config])

JOKER FUNC testing/quick.Value from testing/quick/quick.go:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo input arguments: (t reflect.Type, rand *rand.Rand)\n\nGo return type: (value reflect.Value, ok bool)\n\nJoker input arguments: [^go.std.reflect/Type t, ^(atom-of go.std.math.rand/Rand) rand]\n\nJoker return type: [go.std.reflect/Value Boolean]"
;;   {:added "1.0"
;;    :go "__value(*t, rand)"}
;;   [^reflect/Type t, ^rand/Rand rand])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the testing/quick package."
    :empty false}
  go.std.testing.quick)
JOKER TYPE text/scanner.Position from text/scanner/scanner.go:
(defn ^"GoObject" Position.
  "Constructor for scanner.Position"
  {:added "1.0"
   :go "_ConstructPosition(_v)"}
  [^Object _v])

JOKER TYPE text/scanner.Scanner from text/scanner/scanner.go:
;; (defn ^"GoObject" Scanner.
;;   "Constructor for scanner.Scanner"
;;   {:added "1.0"
;;    :go "_ConstructScanner(_v)"}
;;   [^Object _v])

JOKER FUNC text/scanner.TokenString from text/scanner/scanner.go:
(defn ^"String" TokenString
  "TokenString returns a printable string for a token or Unicode character.\n\nGo input arguments: (tok rune)\n\nGo return type: string\n\nJoker input arguments: [^Char tok]\n\nJoker return type: String"
  {:added "1.0"
   :go "scanner.TokenString(tok)"}
  [^Char tok])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/scanner"]
    :doc "Provides a low-level interface to the text/scanner package."
    :empty false}
  go.std.text.scanner)
JOKER TYPE text/tabwriter.Writer from text/tabwriter/tabwriter.go:
(defn ^"GoObject" Writer.
  "Constructor for tabwriter.Writer"
  {:added "1.0"
   :go "_ConstructWriter(_v)"}
  [^Object _v])

JOKER FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo input arguments: (output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint)\n\nGo return type: *Writer\n\nJoker input arguments: [^go.std.io/Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Int padchar, ^Number flags]\n\nJoker return type: (atom-of go.std.text.tabwriter/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(*output, minwidth, tabwidth, padding, padchar, flags)"}
;;   [^io/Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Int padchar, ^Number flags])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the text/tabwriter package."
    :empty false}
  go.std.text.tabwriter)
JOKER TYPE text/template.ExecError from text/template/exec.go:
(defn ^"GoObject" ExecError.
  "Constructor for template.ExecError"
  {:added "1.0"
   :go "_ConstructExecError(_v)"}
  [^Object _v])

JOKER TYPE text/template.FuncMap from text/template/funcs.go:
;; (defn ^"GoObject" FuncMap.
;;   "Constructor for template.FuncMap"
;;   {:added "1.0"
;;    :go "_ConstructFuncMap(_v)"}
;;   [^Object _v])

JOKER TYPE text/template.Template from text/template/template.go:
(defn ^"GoObject" Template.
  "Constructor for template.Template"
  {:added "1.0"
   :go "_ConstructTemplate(_v)"}
  [^Object _v])

JOKER FUNC text/template.HTMLEscape from text/template/funcs.go:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__hTMLEscape(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^io/Writer w, ^Object b])

JOKER FUNC text/template.HTMLEscapeString from text/template/funcs.go:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(s)"}
  [^String s])

JOKER FUNC text/template.HTMLEscaper from text/template/funcs.go:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

JOKER FUNC text/template.IsTrue from text/template/exec.go:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Boolean Boolean]"
;;   {:added "1.0"
;;    :go "__isTrue(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> val])

JOKER FUNC text/template.JSEscape from text/template/funcs.go:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^go.std.io/Writer w, ^(vector-of Int) b]"
;;   {:added "1.0"
;;    :go "__jSEscape(*w, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))"}
;;   [^io/Writer w, ^Object b])

JOKER FUNC text/template.JSEscapeString from text/template/funcs.go:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(s)"}
  [^String s])

JOKER FUNC text/template.JSEscaper from text/template/funcs.go:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

JOKER FUNC text/template.Must from text/template/helper.go:
(defn Must
  "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo input arguments: (t *Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of go.std.text.template/Template) t, ^Error err]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "__must(t, err)"}
  [^template/Template t, ^Error err])

JOKER FUNC text/template.New from text/template/template.go:
(defn New
  "New allocates a new, undefined template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: (atom-of go.std.text.template/Template)"
  {:added "1.0"
   :go "__new(name)"}
  [^String name])

JOKER FUNC text/template.ParseFiles from text/template/helper.go:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
;;   {:added "1.0"
;;    :go "__parseFiles(ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(filenames)))"}
;;   [^String filenames])

JOKER FUNC text/template.ParseGlob from text/template/helper.go:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(atom-of go.std.text.template/Template) Error]"
  {:added "1.0"
   :go "__parseGlob(pattern)"}
  [^String pattern])

JOKER FUNC text/template.URLQueryEscaper from text/template/funcs.go:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> args])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template"]
    :doc "Provides a low-level interface to the text/template package."
    :empty false}
  go.std.text.template)
JOKER TYPE text/template/parse.ActionNode from text/template/parse/node.go:
;; (defn ^"GoObject" ActionNode.
;;   "Constructor for parse.ActionNode"
;;   {:added "1.0"
;;    :go "_ConstructActionNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.BoolNode from text/template/parse/node.go:
(defn ^"GoObject" BoolNode.
  "Constructor for parse.BoolNode"
  {:added "1.0"
   :go "_ConstructBoolNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.BranchNode from text/template/parse/node.go:
;; (defn ^"GoObject" BranchNode.
;;   "Constructor for parse.BranchNode"
;;   {:added "1.0"
;;    :go "_ConstructBranchNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.ChainNode from text/template/parse/node.go:
;; (defn ^"GoObject" ChainNode.
;;   "Constructor for parse.ChainNode"
;;   {:added "1.0"
;;    :go "_ConstructChainNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.CommandNode from text/template/parse/node.go:
;; (defn ^"GoObject" CommandNode.
;;   "Constructor for parse.CommandNode"
;;   {:added "1.0"
;;    :go "_ConstructCommandNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.DotNode from text/template/parse/node.go:
(defn ^"GoObject" DotNode.
  "Constructor for parse.DotNode"
  {:added "1.0"
   :go "_ConstructDotNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.FieldNode from text/template/parse/node.go:
;; (defn ^"GoObject" FieldNode.
;;   "Constructor for parse.FieldNode"
;;   {:added "1.0"
;;    :go "_ConstructFieldNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.IdentifierNode from text/template/parse/node.go:
(defn ^"GoObject" IdentifierNode.
  "Constructor for parse.IdentifierNode"
  {:added "1.0"
   :go "_ConstructIdentifierNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.IfNode from text/template/parse/node.go:
(defn ^"GoObject" IfNode.
  "Constructor for parse.IfNode"
  {:added "1.0"
   :go "_ConstructIfNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.ListNode from text/template/parse/node.go:
;; (defn ^"GoObject" ListNode.
;;   "Constructor for parse.ListNode"
;;   {:added "1.0"
;;    :go "_ConstructListNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.NilNode from text/template/parse/node.go:
(defn ^"GoObject" NilNode.
  "Constructor for parse.NilNode"
  {:added "1.0"
   :go "_ConstructNilNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.Node from text/template/parse/node.go:
;; (defn ^"GoObject" Node.
;;   "Constructor for parse.Node"
;;   {:added "1.0"
;;    :go "_ConstructNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.NodeType from text/template/parse/node.go:
(defn ^"GoObject" NodeType.
  "Constructor for parse.NodeType"
  {:added "1.0"
   :go "_ConstructNodeType(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.NumberNode from text/template/parse/node.go:
;; (defn ^"GoObject" NumberNode.
;;   "Constructor for parse.NumberNode"
;;   {:added "1.0"
;;    :go "_ConstructNumberNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.PipeNode from text/template/parse/node.go:
;; (defn ^"GoObject" PipeNode.
;;   "Constructor for parse.PipeNode"
;;   {:added "1.0"
;;    :go "_ConstructPipeNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.Pos from text/template/parse/node.go:
(defn ^"GoObject" Pos.
  "Constructor for parse.Pos"
  {:added "1.0"
   :go "_ConstructPos(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.RangeNode from text/template/parse/node.go:
(defn ^"GoObject" RangeNode.
  "Constructor for parse.RangeNode"
  {:added "1.0"
   :go "_ConstructRangeNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.StringNode from text/template/parse/node.go:
(defn ^"GoObject" StringNode.
  "Constructor for parse.StringNode"
  {:added "1.0"
   :go "_ConstructStringNode(_v)"}
  [^Object _v])

JOKER TYPE text/template/parse.TemplateNode from text/template/parse/node.go:
;; (defn ^"GoObject" TemplateNode.
;;   "Constructor for parse.TemplateNode"
;;   {:added "1.0"
;;    :go "_ConstructTemplateNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.TextNode from text/template/parse/node.go:
;; (defn ^"GoObject" TextNode.
;;   "Constructor for parse.TextNode"
;;   {:added "1.0"
;;    :go "_ConstructTextNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.Tree from text/template/parse/parse.go:
;; (defn ^"GoObject" Tree.
;;   "Constructor for parse.Tree"
;;   {:added "1.0"
;;    :go "_ConstructTree(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.VariableNode from text/template/parse/node.go:
;; (defn ^"GoObject" VariableNode.
;;   "Constructor for parse.VariableNode"
;;   {:added "1.0"
;;    :go "_ConstructVariableNode(_v)"}
;;   [^Object _v])

JOKER TYPE text/template/parse.WithNode from text/template/parse/node.go:
(defn ^"GoObject" WithNode.
  "Constructor for parse.WithNode"
  {:added "1.0"
   :go "_ConstructWithNode(_v)"}
  [^Object _v])

JOKER FUNC text/template/parse.IsEmptyTree from text/template/parse/parse.go:
(defn ^"Boolean" IsEmptyTree
  "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo input arguments: (n Node)\n\nGo return type: bool\n\nJoker input arguments: [^go.std.text.template.parse/Node n]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "parse.IsEmptyTree(*n)"}
  [^parse/Node n])

JOKER FUNC text/template/parse.New from text/template/parse/parse.go:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo input arguments: (name string, funcs ...map[])\n\nGo return type: *Tree\n\nJoker input arguments: [^String name, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: (atom-of go.std.text.template.parse/Tree)"
;;   {:added "1.0"
;;    :go "__new(name, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String name, ^{} funcs])

JOKER FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
(defn NewIdentifier
  "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo input arguments: (ident string)\n\nGo return type: *IdentifierNode\n\nJoker input arguments: [^String ident]\n\nJoker return type: (atom-of go.std.text.template.parse/IdentifierNode)"
  {:added "1.0"
   :go "__newIdentifier(ident)"}
  [^String ident])

JOKER FUNC text/template/parse.Parse from text/template/parse/parse.go:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo input arguments: (name string, text string, leftDelim string, rightDelim string, funcs ...map[])\n\nGo return type: (..., error)\n\nJoker input arguments: [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: [ABEND883(post.go: unrecognized Expr type *ast.MapType at: /usr/local/go/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "__parse(name, text, leftDelim, rightDelim, ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^{} funcs])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["text/template/parse"]
    :doc "Provides a low-level interface to the text/template/parse package."
    :empty false}
  go.std.text.template.parse)
JOKER TYPE time.Duration from time/time.go:
(defn ^"GoObject" Duration.
  "Constructor for time.Duration"
  {:added "1.0"
   :go "_ConstructDuration(_v)"}
  [^Object _v])

JOKER TYPE time.Location from time/zoneinfo.go:
(defn ^"GoObject" Location.
  "Constructor for time.Location"
  {:added "1.0"
   :go "_ConstructLocation(_v)"}
  [^Object _v])

JOKER TYPE time.Month from time/time.go:
(defn ^"GoObject" Month.
  "Constructor for time.Month"
  {:added "1.0"
   :go "_ConstructMonth(_v)"}
  [^Object _v])

JOKER TYPE time.ParseError from time/format.go:
(defn ^"GoObject" ParseError.
  "Constructor for time.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE time.Ticker from time/tick.go:
;; (defn ^"GoObject" Ticker.
;;   "Constructor for time.Ticker"
;;   {:added "1.0"
;;    :go "_ConstructTicker(_v)"}
;;   [^Object _v])

JOKER TYPE time.Time from time/time.go:
(defn ^"GoObject" Time.
  "Constructor for time.Time"
  {:added "1.0"
   :go "_ConstructTime(_v)"}
  [^Object _v])

JOKER TYPE time.Timer from time/sleep.go:
;; (defn ^"GoObject" Timer.
;;   "Constructor for time.Timer"
;;   {:added "1.0"
;;    :go "_ConstructTimer(_v)"}
;;   [^Object _v])

JOKER TYPE time.Weekday from time/time.go:
(defn ^"GoObject" Weekday.
  "Constructor for time.Weekday"
  {:added "1.0"
   :go "_ConstructWeekday(_v)"}
  [^Object _v])

JOKER FUNC time.After from time/sleep.go:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go/src/time/sleep.go:149:24)"
;;   {:added "1.0"
;;    :go "__after(*d)"}
;;   [^time/Duration d])

JOKER FUNC time.AfterFunc from time/sleep.go:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo input arguments: (d Duration, f func)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d, ^fn f]\n\nJoker return type: (atom-of go.std.time/Timer)"
;;   {:added "1.0"
;;    :go "__afterFunc(*d, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^time/Duration d, ^fn f])

JOKER FUNC time.Date from time/time.go:
(defn Date
  "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo input arguments: (year int, month Month, day int, hour int, min int, sec int, nsec int, loc *Location)\n\nGo return type: Time\n\nJoker input arguments: [^Int year, ^go.std.time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__date(year, *month, day, hour, min, sec, nsec, loc)"}
  [^Int year, ^time/Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^time/Location loc])

JOKER FUNC time.FixedZone from time/zoneinfo.go:
(defn FixedZone
  "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo input arguments: (name string, offset int)\n\nGo return type: *Location\n\nJoker input arguments: [^String name, ^Int offset]\n\nJoker return type: (atom-of go.std.time/Location)"
  {:added "1.0"
   :go "__fixedZone(name, offset)"}
  [^String name, ^Int offset])

JOKER FUNC time.LoadLocation from time/zoneinfo.go:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo input arguments: (name string)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
  {:added "1.0"
   :go "__loadLocation(name)"}
  [^String name])

JOKER FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
;; (defn LoadLocationFromTZData
;;   "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo input arguments: (name string, data []byte)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name, ^(vector-of Int) data]\n\nJoker return type: [(atom-of go.std.time/Location) Error]"
;;   {:added "1.0"
;;    :go "__loadLocationFromTZData(name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))"}
;;   [^String name, ^Object data])

JOKER FUNC time.NewTicker from time/tick.go:
(defn NewTicker
  "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo input arguments: (d Duration)\n\nGo return type: *Ticker\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Ticker)"
  {:added "1.0"
   :go "__newTicker(*d)"}
  [^time/Duration d])

JOKER FUNC time.NewTimer from time/sleep.go:
(defn NewTimer
  "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo input arguments: (d Duration)\n\nGo return type: *Timer\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: (atom-of go.std.time/Timer)"
  {:added "1.0"
   :go "__newTimer(*d)"}
  [^time/Duration d])

JOKER FUNC time.Now from time/time.go:
(defn Now
  "Now returns the current local time.\n\nGo return type: Time\n\nJoker input arguments: []\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__now()"}
  [])

JOKER FUNC time.Parse from time/format.go:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo input arguments: (layout string, value string)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parse(layout, value)"}
  [^String layout, ^String value])

JOKER FUNC time.ParseDuration from time/format.go:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo input arguments: (s string)\n\nGo return type: (Duration, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.time/Duration Error]"
  {:added "1.0"
   :go "__parseDuration(s)"}
  [^String s])

JOKER FUNC time.ParseInLocation from time/format.go:
(defn ParseInLocation
  "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo input arguments: (layout string, value string, loc *Location)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value, ^(atom-of go.std.time/Location) loc]\n\nJoker return type: [go.std.time/Time Error]"
  {:added "1.0"
   :go "__parseInLocation(layout, value, loc)"}
  [^String layout, ^String value, ^time/Location loc])

JOKER FUNC time.Since from time/time.go:
(defn Since
  "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__since(*t)"}
  [^time/Time t])

JOKER FUNC time.Sleep from time/sleep.go:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n\nGo input arguments: (d Duration)\n\nJoker input arguments: [^go.std.time/Duration d]"
;;   {:added "1.0"
;;    :go "__sleep(*d)"}
;;   [^time/Duration d])

JOKER FUNC time.Tick from time/tick.go:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo input arguments: (d Duration)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.time/Duration d]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.ChanType at: /usr/local/go/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "__tick(*d)"}
;;   [^time/Duration d])

JOKER FUNC time.Unix from time/time.go:
(defn Unix
  "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo input arguments: (sec int64, nsec int64)\n\nGo return type: Time\n\nJoker input arguments: [^Number sec, ^Number nsec]\n\nJoker return type: go.std.time/Time"
  {:added "1.0"
   :go "__unix(sec, nsec)"}
  [^Number sec, ^Number nsec])

JOKER FUNC time.Until from time/time.go:
(defn Until
  "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo input arguments: (t Time)\n\nGo return type: Duration\n\nJoker input arguments: [^go.std.time/Time t]\n\nJoker return type: go.std.time/Duration"
  {:added "1.0"
   :go "__until(*t)"}
  [^time/Time t])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports []
    :doc "Provides a low-level interface to the time package."
    :empty false}
  go.std.time)
JOKER TYPE unicode.CaseRange from unicode/letter.go:
;; (defn ^"GoObject" CaseRange.
;;   "Constructor for unicode.CaseRange"
;;   {:added "1.0"
;;    :go "_ConstructCaseRange(_v)"}
;;   [^Object _v])

JOKER TYPE unicode.Range16 from unicode/letter.go:
(defn ^"GoObject" Range16.
  "Constructor for unicode.Range16"
  {:added "1.0"
   :go "_ConstructRange16(_v)"}
  [^Object _v])

JOKER TYPE unicode.Range32 from unicode/letter.go:
(defn ^"GoObject" Range32.
  "Constructor for unicode.Range32"
  {:added "1.0"
   :go "_ConstructRange32(_v)"}
  [^Object _v])

JOKER TYPE unicode.RangeTable from unicode/letter.go:
;; (defn ^"GoObject" RangeTable.
;;   "Constructor for unicode.RangeTable"
;;   {:added "1.0"
;;    :go "_ConstructRangeTable(_v)"}
;;   [^Object _v])

JOKER TYPE unicode.SpecialCase from unicode/letter.go:
;; (defn ^"GoObject" SpecialCase.
;;   "Constructor for unicode.SpecialCase"
;;   {:added "1.0"
;;    :go "_ConstructSpecialCase(_v)"}
;;   [^Object _v])

JOKER FUNC unicode.In from unicode/graphic.go:
;; (defn ^"Boolean" In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo input arguments: (r rune, ranges ...*RangeTable)\n\nGo return type: bool\n\nJoker input arguments: [^Char r, ^(ellipsis-somehow unicode/RangeTable) ranges]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.In(r, ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHa*_unicode.RangeTable(ranges)))"}
;;   [^Char r, ^unicode/RangeTable ranges])

JOKER FUNC unicode.Is from unicode/letter.go:
(defn ^"Boolean" Is
  "Is reports whether the rune is in the specified table of ranges.\n\nGo input arguments: (rangeTab *RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go.std.unicode/RangeTable) rangeTab, ^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.Is(rangeTab, r)"}
  [^unicode/RangeTable rangeTab, ^Char r])

JOKER FUNC unicode.IsControl from unicode/graphic.go:
(defn ^"Boolean" IsControl
  "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsControl(r)"}
  [^Char r])

JOKER FUNC unicode.IsDigit from unicode/digit.go:
(defn ^"Boolean" IsDigit
  "IsDigit reports whether the rune is a decimal digit.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsDigit(r)"}
  [^Char r])

JOKER FUNC unicode.IsGraphic from unicode/graphic.go:
(defn ^"Boolean" IsGraphic
  "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsGraphic(r)"}
  [^Char r])

JOKER FUNC unicode.IsLetter from unicode/graphic.go:
(defn ^"Boolean" IsLetter
  "IsLetter reports whether the rune is a letter (category L).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsLetter(r)"}
  [^Char r])

JOKER FUNC unicode.IsLower from unicode/letter.go:
(defn ^"Boolean" IsLower
  "IsLower reports whether the rune is a lower case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsLower(r)"}
  [^Char r])

JOKER FUNC unicode.IsMark from unicode/graphic.go:
(defn ^"Boolean" IsMark
  "IsMark reports whether the rune is a mark character (category M).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsMark(r)"}
  [^Char r])

JOKER FUNC unicode.IsNumber from unicode/graphic.go:
(defn ^"Boolean" IsNumber
  "IsNumber reports whether the rune is a number (category N).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsNumber(r)"}
  [^Char r])

JOKER FUNC unicode.IsOneOf from unicode/graphic.go:
;; (defn ^"Boolean" IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo input arguments: (ranges []*RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of (atom-of go.std.unicode/RangeTable)) ranges, ^Char r]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_unicode.RangeTable(ranges)), r)"}
;;   [^Object ranges, ^Char r])

JOKER FUNC unicode.IsPrint from unicode/graphic.go:
(defn ^"Boolean" IsPrint
  "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsPrint(r)"}
  [^Char r])

JOKER FUNC unicode.IsPunct from unicode/graphic.go:
(defn ^"Boolean" IsPunct
  "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsPunct(r)"}
  [^Char r])

JOKER FUNC unicode.IsSpace from unicode/graphic.go:
(defn ^"Boolean" IsSpace
  "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsSpace(r)"}
  [^Char r])

JOKER FUNC unicode.IsSymbol from unicode/graphic.go:
(defn ^"Boolean" IsSymbol
  "IsSymbol reports whether the rune is a symbolic character.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsSymbol(r)"}
  [^Char r])

JOKER FUNC unicode.IsTitle from unicode/letter.go:
(defn ^"Boolean" IsTitle
  "IsTitle reports whether the rune is a title case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsTitle(r)"}
  [^Char r])

JOKER FUNC unicode.IsUpper from unicode/letter.go:
(defn ^"Boolean" IsUpper
  "IsUpper reports whether the rune is an upper case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "unicode.IsUpper(r)"}
  [^Char r])

JOKER FUNC unicode.SimpleFold from unicode/letter.go:
(defn SimpleFold
  "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, )\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__simpleFold(r)"}
  [^Char r])

JOKER FUNC unicode.To from unicode/letter.go:
(defn To
  "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo input arguments: (_case int, r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Int _case, ^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__to(_case, r)"}
  [^Int _case, ^Char r])

JOKER FUNC unicode.ToLower from unicode/letter.go:
(defn ToLower
  "ToLower maps the rune to lower case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toLower(r)"}
  [^Char r])

JOKER FUNC unicode.ToTitle from unicode/letter.go:
(defn ToTitle
  "ToTitle maps the rune to title case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toTitle(r)"}
  [^Char r])

JOKER FUNC unicode.ToUpper from unicode/letter.go:
(defn ToUpper
  "ToUpper maps the rune to upper case.\n\nGo input arguments: (r rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__toUpper(r)"}
  [^Char r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode"]
    :doc "Provides a low-level interface to the unicode package."
    :empty false}
  go.std.unicode)
JOKER FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo input arguments: (s []uint16)\n\nGo return type: []rune\n\nJoker input arguments: [^(vector-of Int) s]\n\nJoker return type: (vector-of Char)"
;;   {:added "1.0"
;;    :go "__decode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfuint16(s)))"}
;;   [^Object s])

JOKER FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
(defn DecodeRune
  "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: rune\n\nJoker input arguments: [^Char r1, ^Char r2]\n\nJoker return type: Char"
  {:added "1.0"
   :go "__decodeRune(r1, r2)"}
  [^Char r1, ^Char r2])

JOKER FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo input arguments: (s []rune)\n\nGo return type: []uint16\n\nJoker input arguments: [^(vector-of Char) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__encode(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfrune(s)))"}
;;   [^Object s])

JOKER FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
(defn EncodeRune
  "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo input arguments: (r rune)\n\nGo return type: (r1 rune, r2 rune)\n\nJoker input arguments: [^Char r]\n\nJoker return type: [Char Char]"
  {:added "1.0"
   :go "__encodeRune(r)"}
  [^Char r])

JOKER FUNC unicode/utf16.IsSurrogate from unicode/utf16/utf16.go:
(defn ^"Boolean" IsSurrogate
  "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf16.IsSurrogate(r)"}
  [^Char r])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf16"]
    :doc "Provides a low-level interface to the unicode/utf16 package."
    :empty false}
  go.std.unicode.utf16)
JOKER FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Char Int]"
;;   {:added "1.0"
;;    :go "__decodeLastRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
(defn DecodeLastRuneInString
  "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Char Int]"
  {:added "1.0"
   :go "__decodeLastRuneInString(s)"}
  [^String s])

JOKER FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: [Char Int]"
;;   {:added "1.0"
;;    :go "__decodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
(defn DecodeRuneInString
  "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r rune, size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Char Int]"
  {:added "1.0"
   :go "__decodeRuneInString(s)"}
  [^String s])

JOKER FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
;; (defn ^"Int" EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo input arguments: (p []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) p, ^Char r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), r)"}
;;   [^Object p, ^Char r])

JOKER FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
;; (defn ^"Boolean" FullRune
;;   "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.FullRune(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC unicode/utf8.FullRuneInString from unicode/utf8/utf8.go:
(defn ^"Boolean" FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.FullRuneInString(s)"}
  [^String s])

JOKER FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
;; (defn ^"Int" RuneCount
;;   "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo input arguments: (p []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneCount(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC unicode/utf8.RuneCountInString from unicode/utf8/utf8.go:
(defn ^"Int" RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(s)"}
  [^String s])

JOKER FUNC unicode/utf8.RuneLen from unicode/utf8/utf8.go:
(defn ^"Int" RuneLen
  "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo input arguments: (r rune)\n\nGo return type: int\n\nJoker input arguments: [^Char r]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneLen(r)"}
  [^Char r])

JOKER FUNC unicode/utf8.RuneStart from unicode/utf8/utf8.go:
(defn ^"Boolean" RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo input arguments: (b byte)\n\nGo return type: bool\n\nJoker input arguments: [^Int b]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.RuneStart(b)"}
  [^Int b])

JOKER FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
;; (defn ^"Boolean" Valid
;;   "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Boolean"
;;   {:added "1.0"
;;    :go "utf8.Valid(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))"}
;;   [^Object p])

JOKER FUNC unicode/utf8.ValidRune from unicode/utf8/utf8.go:
(defn ^"Boolean" ValidRune
  "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^Char r]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.ValidRune(r)"}
  [^Char r])

JOKER FUNC unicode/utf8.ValidString from unicode/utf8/utf8.go:
(defn ^"Boolean" ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Boolean"
  {:added "1.0"
   :go "utf8.ValidString(s)"}
  [^String s])

;;;; Auto-generated by gostd at (omitted for testing), do not edit!!

(ns
  ^{:go-imports ["unicode/utf8"]
    :doc "Provides a low-level interface to the unicode/utf8 package."
    :empty false}
  go.std.unicode.utf8)
GO TYPE archive/tar.Format from archive/tar/format.go:
func ExtractGoObjectFormat(args []Object, index int) *_tar.Format {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Format:
			return &r
		case *_tar.Format:
			return r
		}
	case Int:
		v := _tar.Format(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Format]"))
}

func _ConstructFormat(_v Object) _tar.Format {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Format:
			return _g
		case *_tar.Format:
			return *_g
		}
	case Number:
		return _tar.Format(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Format] or: Number"))
}

GO TYPE archive/tar.Header from archive/tar/common.go:
func ExtractGoObjectHeader(args []Object, index int) *_tar.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Header:
			return &r
		case *_tar.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Header]"))
}

// func _mapToHeader(o Map) *_tar.Header {
// 	return &_tar.Header{}
// }

// func _vectorToHeader(o *Vector) *_tar.Header {
// 	return &_tar.Header{
// 		Typeflag: byte(AssertInt(o.Nth(0), "").I),
// 		Name: AssertString(o.Nth(1), "").S,
// 		Linkname: AssertString(o.Nth(2), "").S,
// 		Size: AssertNumber(o.Nth(3), "").BigInt().Int64(),
// 		Mode: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		Uid: AssertInt(o.Nth(5), "").I,
// 		Gid: AssertInt(o.Nth(6), "").I,
// 		Uname: AssertString(o.Nth(7), "").S,
// 		Gname: AssertString(o.Nth(8), "").S,
// 		ModTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		AccessTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ChangeTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Devmajor: AssertNumber(o.Nth(12), "").BigInt().Int64(),
// 		Devminor: AssertNumber(o.Nth(13), "").BigInt().Int64(),
// 		Xattrs: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		PAXRecords: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Format: _tar.Format(AssertInt(o.Nth(16), "").I),
// 	}
// }

// func _ConstructHeader(_v Object) *_tar.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tar.Header:
// 			return &_g
// 		case *_tar.Header:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Header] or: Map or Vector"))
// }

GO TYPE archive/tar.Reader from archive/tar/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_tar.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Reader:
			return &r
		case *_tar.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Reader]"))
}

func _mapToReader(o Map) *_tar.Reader {
	return &_tar.Reader{}
}

func _vectorToReader(o *Vector) *_tar.Reader {
	return &_tar.Reader{}
}

func _ConstructReader(_v Object) *_tar.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Reader:
			return &_g
		case *_tar.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Reader] or: Map or Vector"))
}

GO TYPE archive/tar.Writer from archive/tar/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_tar.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tar.Writer:
			return &r
		case *_tar.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/tar.Writer]"))
}

func _mapToWriter(o Map) *_tar.Writer {
	return &_tar.Writer{}
}

func _vectorToWriter(o *Vector) *_tar.Writer {
	return &_tar.Writer{}
}

func _ConstructWriter(_v Object) *_tar.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tar.Writer:
			return &_g
		case *_tar.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tar.Writer] or: Map or Vector"))
}

GO FUNC archive/tar.FileInfoHeader from archive/tar/common.go:
// func __fileInfoHeader(fi ABEND987(genutils.go: imports not yet supported: os.FileInfo), link string) Object {
// 	_res1, _res2 := _tar.FileInfoHeader(fi, link)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/tar.NewReader from archive/tar/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _tar.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.NewWriter from archive/tar/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _tar.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/tar.__format_String from archive/tar/format.go:
func __format_String(o GoObject, args Object) Object {
	CheckGoArity("(_archive/tar.Format)String()", args, 0, 0)
	_res := o.O.(_tar.Format).String()
	return MakeString(_res)
}

GO FUNC archive/tar.__ptrTo_Header_FileInfo from archive/tar/common.go:
func __ptrTo_Header_FileInfo(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Header)FileInfo()", args, 0, 0)
	_res := o.O.(*_tar.Header).FileInfo()
	return MakeGoObject(_res)
}

GO FUNC archive/tar.__ptrTo_Reader_Next from archive/tar/reader.go:
func __ptrTo_Reader_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Reader)Next()", args, 0, 0)
	_res1, _res2 := o.O.(*_tar.Reader).Next()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/tar.__ptrTo_Reader_Read from archive/tar/reader.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC archive/tar.__ptrTo_Writer_Close from archive/tar/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Writer)Close()", args, 0, 0)
	_res := o.O.(*_tar.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/tar.__ptrTo_Writer_Flush from archive/tar/writer.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/tar.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_tar.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/tar.__ptrTo_Writer_Write from archive/tar/writer.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC archive/tar.__ptrTo_Writer_WriteHeader from archive/tar/writer.go:
// func __ptrTo_Writer_WriteHeader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_archive/tar.Writer)WriteHeader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for hdr at: /usr/local/go/src/archive/tar/writer.go:67:35)
// 	_res := o.O.(*_tar.Writer).WriteHeader(hdr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package tar

import (
	_tar "archive/tar"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_Format = GoTypeInfo{Members: GoMembers{
	"String": __format_String,
}}

var members_PtrTo_Header = GoTypeInfo{Members: GoMembers{
	"FileInfo": __ptrTo_Header_FileInfo,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_Reader_Next,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
	"Flush": __ptrTo_Writer_Flush,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_tar.Format)(nil)).Elem()] = &members_Format
	GoTypes[_reflect.TypeOf((*_tar.Header)(nil))] = &members_PtrTo_Header
	GoTypes[_reflect.TypeOf((*_tar.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_tar.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE archive/zip.Compressor from archive/zip/register.go:
func ExtractGoObjectCompressor(args []Object, index int) *_zip.Compressor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Compressor:
			return &r
		case *_zip.Compressor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Compressor]"))
}

// func _ConstructCompressor(_v Object) _zip.Compressor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.Compressor:
// 			return _g
// 		case *_zip.Compressor:
// 			return *_g
// 		}
// 	default:
// 		return _zip.Compressor(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Compressor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Compressor] or: whatever"))
// }

GO TYPE archive/zip.Decompressor from archive/zip/register.go:
func ExtractGoObjectDecompressor(args []Object, index int) *_zip.Decompressor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Decompressor:
			return &r
		case *_zip.Decompressor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Decompressor]"))
}

// func _ConstructDecompressor(_v Object) _zip.Decompressor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.Decompressor:
// 			return _g
// 		case *_zip.Decompressor:
// 			return *_g
// 		}
// 	default:
// 		return _zip.Decompressor(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Decompressor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Decompressor] or: whatever"))
// }

GO TYPE archive/zip.File from archive/zip/reader.go:
func ExtractGoObjectFile(args []Object, index int) *_zip.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.File:
			return &r
		case *_zip.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.File]"))
}

func _mapToFile(o Map) *_zip.File {
	return &_zip.File{}
}

func _vectorToFile(o *Vector) *_zip.File {
	return &_zip.File{}
}

func _ConstructFile(_v Object) *_zip.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.File:
			return &_g
		case *_zip.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.File] or: Map or Vector"))
}

GO TYPE archive/zip.FileHeader from archive/zip/struct.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_zip.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.FileHeader:
			return &r
		case *_zip.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.FileHeader]"))
}

// func _mapToFileHeader(o Map) *_zip.FileHeader {
// 	return &_zip.FileHeader{}
// }

// func _vectorToFileHeader(o *Vector) *_zip.FileHeader {
// 	return &_zip.FileHeader{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Comment: AssertString(o.Nth(1), "").S,
// 		NonUTF8: ToBool(o.Nth(2)),
// 		CreatorVersion: uint16(AssertInt(o.Nth(3), "").I),
// 		ReaderVersion: uint16(AssertInt(o.Nth(4), "").I),
// 		Flags: uint16(AssertInt(o.Nth(5), "").I),
// 		Method: uint16(AssertInt(o.Nth(6), "").I),
// 		Modified: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ModifiedTime: uint16(AssertInt(o.Nth(8), "").I),
// 		ModifiedDate: uint16(AssertInt(o.Nth(9), "").I),
// 		CRC32: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		CompressedSize: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 		UncompressedSize: uint32(AssertNumber(o.Nth(12), "").BigInt().Uint64()),
// 		CompressedSize64: AssertNumber(o.Nth(13), "").BigInt().Uint64(),
// 		UncompressedSize64: AssertNumber(o.Nth(14), "").BigInt().Uint64(),
// 		Extra: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		ExternalAttrs: uint32(AssertNumber(o.Nth(16), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructFileHeader(_v Object) *_zip.FileHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.FileHeader:
// 			return &_g
// 		case *_zip.FileHeader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFileHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToFileHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.FileHeader] or: Map or Vector"))
// }

GO TYPE archive/zip.ReadCloser from archive/zip/reader.go:
func ExtractGoObjectReadCloser(args []Object, index int) *_zip.ReadCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.ReadCloser:
			return &r
		case *_zip.ReadCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.ReadCloser]"))
}

func _mapToReadCloser(o Map) *_zip.ReadCloser {
	return &_zip.ReadCloser{}
}

func _vectorToReadCloser(o *Vector) *_zip.ReadCloser {
	return &_zip.ReadCloser{}
}

func _ConstructReadCloser(_v Object) *_zip.ReadCloser {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.ReadCloser:
			return &_g
		case *_zip.ReadCloser:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReadCloser(_o.(Map))
	case *Vector:
		return _vectorToReadCloser(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.ReadCloser] or: Map or Vector"))
}

GO TYPE archive/zip.Reader from archive/zip/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_zip.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Reader:
			return &r
		case *_zip.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Reader]"))
}

// func _mapToReader(o Map) *_zip.Reader {
// 	return &_zip.Reader{}
// }

// func _vectorToReader(o *Vector) *_zip.Reader {
// 	return &_zip.Reader{
// 		File: ABEND048(codegen.go: no conversion from Clojure for []*archive/zip.File (*archive/zip.File)),
// 		Comment: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructReader(_v Object) *_zip.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zip.Reader:
// 			return &_g
// 		case *_zip.Reader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Reader] or: Map or Vector"))
// }

GO TYPE archive/zip.Writer from archive/zip/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_zip.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zip.Writer:
			return &r
		case *_zip.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[archive/zip.Writer]"))
}

func _mapToWriter(o Map) *_zip.Writer {
	return &_zip.Writer{}
}

func _vectorToWriter(o *Vector) *_zip.Writer {
	return &_zip.Writer{}
}

func _ConstructWriter(_v Object) *_zip.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zip.Writer:
			return &_g
		case *_zip.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zip.Writer] or: Map or Vector"))
}

GO FUNC archive/zip.FileInfoHeader from archive/zip/struct.go:
// func __fileInfoHeader(fi ABEND987(genutils.go: imports not yet supported: os.FileInfo)) Object {
// 	_res1, _res2 := _zip.FileInfoHeader(fi)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewReader from archive/zip/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt), size int64) Object {
// 	_res1, _res2 := _zip.NewReader(r, size)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewWriter from archive/zip/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _zip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC archive/zip.OpenReader from archive/zip/reader.go:
func __openReader(name string) Object {
	_res1, _res2 := _zip.OpenReader(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.RegisterCompressor from archive/zip/register.go:
// func __registerCompressor(method uint16, comp _zip.Compressor) Object {
// 	_zip.RegisterCompressor(method, comp)
// 	...ABEND675: TODO...
// }

GO FUNC archive/zip.RegisterDecompressor from archive/zip/register.go:
// func __registerDecompressor(method uint16, dcomp _zip.Decompressor) Object {
// 	_zip.RegisterDecompressor(method, dcomp)
// 	...ABEND675: TODO...
// }

GO FUNC archive/zip.__ptrTo_FileHeader_FileInfo from archive/zip/struct.go:
func __ptrTo_FileHeader_FileInfo(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.FileHeader)FileInfo()", args, 0, 0)
	_res := o.O.(*_zip.FileHeader).FileInfo()
	return MakeGoObject(_res)
}

GO FUNC archive/zip.__ptrTo_FileHeader_ModTime from archive/zip/struct.go:
func __ptrTo_FileHeader_ModTime(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.FileHeader)ModTime()", args, 0, 0)
	_res := o.O.(*_zip.FileHeader).ModTime()
	return MakeGoObject(_res)
}

GO FUNC archive/zip.__ptrTo_FileHeader_Mode from archive/zip/struct.go:
func __ptrTo_FileHeader_Mode(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.FileHeader)Mode()", args, 0, 0)
	_res := o.O.(*_zip.FileHeader).Mode()
	return MakeGoObject(_res)
}

GO FUNC archive/zip.__ptrTo_FileHeader_SetModTime from archive/zip/struct.go:
// func __ptrTo_FileHeader_SetModTime(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC archive/zip.__ptrTo_FileHeader_SetMode from archive/zip/struct.go:
// func __ptrTo_FileHeader_SetMode(o GoObject, args Object) Object {
// mode ABEND987(genutils.go: imports not yet supported: os.FileMode)}

GO FUNC archive/zip.__ptrTo_File_DataOffset from archive/zip/reader.go:
func __ptrTo_File_DataOffset(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.File)DataOffset()", args, 0, 0)
	offset, err := o.O.(*_zip.File).DataOffset()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(offset))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC archive/zip.__ptrTo_File_Open from archive/zip/reader.go:
func __ptrTo_File_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.File)Open()", args, 0, 0)
	_res1, _res2 := o.O.(*_zip.File).Open()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.__ptrTo_ReadCloser_Close from archive/zip/reader.go:
func __ptrTo_ReadCloser_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.ReadCloser)Close()", args, 0, 0)
	_res := o.O.(*_zip.ReadCloser).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/zip.__ptrTo_Reader_RegisterDecompressor from archive/zip/reader.go:
// func __ptrTo_Reader_RegisterDecompressor(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC archive/zip.__ptrTo_Writer_Close from archive/zip/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.Writer)Close()", args, 0, 0)
	_res := o.O.(*_zip.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/zip.__ptrTo_Writer_Create from archive/zip/writer.go:
func __ptrTo_Writer_Create(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_archive/zip.Writer)Create()", args, 1, 1)
	name := ExtractGoString("(*_archive/zip.Writer)Create()", "name", _argList, 0)
	_res1, _res2 := o.O.(*_zip.Writer).Create(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.__ptrTo_Writer_CreateHeader from archive/zip/writer.go:
// func __ptrTo_Writer_CreateHeader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_archive/zip.Writer)CreateHeader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for fh at: /usr/local/go/src/archive/zip/writer.go:255:34)
// 	_res1, _res2 := o.O.(*_zip.Writer).CreateHeader(fh)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.__ptrTo_Writer_Flush from archive/zip/writer.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_archive/zip.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_zip.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/zip.__ptrTo_Writer_RegisterCompressor from archive/zip/writer.go:
// func __ptrTo_Writer_RegisterCompressor(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC archive/zip.__ptrTo_Writer_SetComment from archive/zip/writer.go:
func __ptrTo_Writer_SetComment(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_archive/zip.Writer)SetComment()", args, 1, 1)
	comment := ExtractGoString("(*_archive/zip.Writer)SetComment()", "comment", _argList, 0)
	_res := o.O.(*_zip.Writer).SetComment(comment)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC archive/zip.__ptrTo_Writer_SetOffset from archive/zip/writer.go:
// func __ptrTo_Writer_SetOffset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package zip

import (
	_zip "archive/zip"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"DataOffset": __ptrTo_File_DataOffset,
	"Open": __ptrTo_File_Open,
}}

var members_PtrTo_FileHeader = GoTypeInfo{Members: GoMembers{
	"FileInfo": __ptrTo_FileHeader_FileInfo,
	"ModTime": __ptrTo_FileHeader_ModTime,
	"Mode": __ptrTo_FileHeader_Mode,
}}

var members_PtrTo_ReadCloser = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_ReadCloser_Close,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
	"Create": __ptrTo_Writer_Create,
	"Flush": __ptrTo_Writer_Flush,
	"SetComment": __ptrTo_Writer_SetComment,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_zip.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_zip.FileHeader)(nil))] = &members_PtrTo_FileHeader
	GoTypes[_reflect.TypeOf((*_zip.ReadCloser)(nil))] = &members_PtrTo_ReadCloser
	GoTypes[_reflect.TypeOf((*_zip.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE bufio.ReadWriter from bufio/bufio.go:
func ExtractGoObjectReadWriter(args []Object, index int) *_bufio.ReadWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.ReadWriter:
			return &r
		case *_bufio.ReadWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.ReadWriter]"))
}

func _mapToReadWriter(o Map) *_bufio.ReadWriter {
	return &_bufio.ReadWriter{}
}

func _vectorToReadWriter(o *Vector) *_bufio.ReadWriter {
	return &_bufio.ReadWriter{}
}

func _ConstructReadWriter(_v Object) *_bufio.ReadWriter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.ReadWriter:
			return &_g
		case *_bufio.ReadWriter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReadWriter(_o.(Map))
	case *Vector:
		return _vectorToReadWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.ReadWriter] or: Map or Vector"))
}

GO TYPE bufio.Reader from bufio/bufio.go:
func ExtractGoObjectReader(args []Object, index int) *_bufio.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Reader:
			return &r
		case *_bufio.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Reader]"))
}

func _mapToReader(o Map) *_bufio.Reader {
	return &_bufio.Reader{}
}

func _vectorToReader(o *Vector) *_bufio.Reader {
	return &_bufio.Reader{}
}

func _ConstructReader(_v Object) *_bufio.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Reader:
			return &_g
		case *_bufio.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Reader] or: Map or Vector"))
}

GO TYPE bufio.Scanner from bufio/scan.go:
func ExtractGoObjectScanner(args []Object, index int) *_bufio.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Scanner:
			return &r
		case *_bufio.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Scanner]"))
}

func _mapToScanner(o Map) *_bufio.Scanner {
	return &_bufio.Scanner{}
}

func _vectorToScanner(o *Vector) *_bufio.Scanner {
	return &_bufio.Scanner{}
}

func _ConstructScanner(_v Object) *_bufio.Scanner {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Scanner:
			return &_g
		case *_bufio.Scanner:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScanner(_o.(Map))
	case *Vector:
		return _vectorToScanner(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Scanner] or: Map or Vector"))
}

GO TYPE bufio.SplitFunc from bufio/scan.go:
func ExtractGoObjectSplitFunc(args []Object, index int) *_bufio.SplitFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.SplitFunc:
			return &r
		case *_bufio.SplitFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.SplitFunc]"))
}

// func _ConstructSplitFunc(_v Object) _bufio.SplitFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _bufio.SplitFunc:
// 			return _g
// 		case *_bufio.SplitFunc:
// 			return *_g
// 		}
// 	default:
// 		return _bufio.SplitFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for SplitFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.SplitFunc] or: whatever"))
// }

GO TYPE bufio.Writer from bufio/bufio.go:
func ExtractGoObjectWriter(args []Object, index int) *_bufio.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bufio.Writer:
			return &r
		case *_bufio.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bufio.Writer]"))
}

func _mapToWriter(o Map) *_bufio.Writer {
	return &_bufio.Writer{}
}

func _vectorToWriter(o *Vector) *_bufio.Writer {
	return &_bufio.Writer{}
}

func _ConstructWriter(_v Object) *_bufio.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bufio.Writer:
			return &_g
		case *_bufio.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bufio.Writer] or: Map or Vector"))
}

GO FUNC bufio.NewReadWriter from bufio/bufio.go:
func __newReadWriter(r *_bufio.Reader, w *_bufio.Writer) Object {
	_res := _bufio.NewReadWriter(r, w)
	return MakeGoObject(_res)
}

GO FUNC bufio.NewReader from bufio/bufio.go:
// func __newReader(rd ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bufio.NewReader(rd)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewReaderSize from bufio/bufio.go:
// func __newReaderSize(rd ABEND987(genutils.go: imports not yet supported: io.Reader), size int) Object {
// 	_res := _bufio.NewReaderSize(rd, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewScanner from bufio/scan.go:
// func __newScanner(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bufio.NewScanner(r)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriter from bufio/bufio.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _bufio.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.NewWriterSize from bufio/bufio.go:
// func __newWriterSize(w ABEND987(genutils.go: imports not yet supported: io.Writer), size int) Object {
// 	_res := _bufio.NewWriterSize(w, size)
// 	return MakeGoObject(_res)
// }

GO FUNC bufio.ScanBytes from bufio/scan.go:
// func __scanBytes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanBytes(data, atEOF)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanLines from bufio/scan.go:
// func __scanLines(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanLines(data, atEOF)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanRunes from bufio/scan.go:
// func __scanRunes(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanRunes(data, atEOF)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.ScanWords from bufio/scan.go:
// func __scanWords(data []byte, atEOF bool) Object {
// 	advance, token, err := _bufio.ScanWords(data, atEOF)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(advance))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range token {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC bufio.__ptrTo_Reader_Buffered from bufio/bufio.go:
func __ptrTo_Reader_Buffered(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)Buffered()", args, 0, 0)
	_res := o.O.(*_bufio.Reader).Buffered()
	return MakeInt(_res)
}

GO FUNC bufio.__ptrTo_Reader_Discard from bufio/bufio.go:
func __ptrTo_Reader_Discard(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Reader)Discard()", args, 1, 1)
	n := ExtractGoInt("(*_bufio.Reader)Discard()", "n", _argList, 0)
	discarded, err := o.O.(*_bufio.Reader).Discard(n)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(discarded))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_Peek from bufio/bufio.go:
func __ptrTo_Reader_Peek(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Reader)Peek()", args, 1, 1)
	n := ExtractGoInt("(*_bufio.Reader)Peek()", "n", _argList, 0)
	_res1, _res2 := o.O.(*_bufio.Reader).Peek(n)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_Read from bufio/bufio.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC bufio.__ptrTo_Reader_ReadByte from bufio/bufio.go:
func __ptrTo_Reader_ReadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)ReadByte()", args, 0, 0)
	_res1, _res2 := o.O.(*_bufio.Reader).ReadByte()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_ReadBytes from bufio/bufio.go:
func __ptrTo_Reader_ReadBytes(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Reader)ReadBytes()", args, 1, 1)
	delim := ExtractGoByte("(*_bufio.Reader)ReadBytes()", "delim", _argList, 0)
	_res1, _res2 := o.O.(*_bufio.Reader).ReadBytes(delim)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_ReadLine from bufio/bufio.go:
func __ptrTo_Reader_ReadLine(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)ReadLine()", args, 0, 0)
	line, isPrefix, err := o.O.(*_bufio.Reader).ReadLine()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range line {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(MakeBoolean(isPrefix))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_ReadRune from bufio/bufio.go:
func __ptrTo_Reader_ReadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)ReadRune()", args, 0, 0)
	r, size, err := o.O.(*_bufio.Reader).ReadRune()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(r))
	_res = _res.Conjoin(MakeInt(size))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_ReadSlice from bufio/bufio.go:
func __ptrTo_Reader_ReadSlice(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Reader)ReadSlice()", args, 1, 1)
	delim := ExtractGoByte("(*_bufio.Reader)ReadSlice()", "delim", _argList, 0)
	line, err := o.O.(*_bufio.Reader).ReadSlice(delim)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range line {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_ReadString from bufio/bufio.go:
func __ptrTo_Reader_ReadString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Reader)ReadString()", args, 1, 1)
	delim := ExtractGoByte("(*_bufio.Reader)ReadString()", "delim", _argList, 0)
	_res1, _res2 := o.O.(*_bufio.Reader).ReadString(delim)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Reader_Reset from bufio/bufio.go:
// func __ptrTo_Reader_Reset(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC bufio.__ptrTo_Reader_Size from bufio/bufio.go:
func __ptrTo_Reader_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)Size()", args, 0, 0)
	_res := o.O.(*_bufio.Reader).Size()
	return MakeInt(_res)
}

GO FUNC bufio.__ptrTo_Reader_UnreadByte from bufio/bufio.go:
func __ptrTo_Reader_UnreadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)UnreadByte()", args, 0, 0)
	_res := o.O.(*_bufio.Reader).UnreadByte()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bufio.__ptrTo_Reader_UnreadRune from bufio/bufio.go:
func __ptrTo_Reader_UnreadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Reader)UnreadRune()", args, 0, 0)
	_res := o.O.(*_bufio.Reader).UnreadRune()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bufio.__ptrTo_Reader_WriteTo from bufio/bufio.go:
// func __ptrTo_Reader_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC bufio.__ptrTo_Scanner_Buffer from bufio/scan.go:
// func __ptrTo_Scanner_Buffer(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), max)}

GO FUNC bufio.__ptrTo_Scanner_Bytes from bufio/scan.go:
func __ptrTo_Scanner_Bytes(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Scanner)Bytes()", args, 0, 0)
	_res := o.O.(*_bufio.Scanner).Bytes()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bufio.__ptrTo_Scanner_Err from bufio/scan.go:
func __ptrTo_Scanner_Err(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Scanner)Err()", args, 0, 0)
	_res := o.O.(*_bufio.Scanner).Err()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bufio.__ptrTo_Scanner_Scan from bufio/scan.go:
func __ptrTo_Scanner_Scan(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Scanner)Scan()", args, 0, 0)
	_res := o.O.(*_bufio.Scanner).Scan()
	return MakeBoolean(_res)
}

GO FUNC bufio.__ptrTo_Scanner_Split from bufio/scan.go:
// func __ptrTo_Scanner_Split(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC bufio.__ptrTo_Scanner_Text from bufio/scan.go:
func __ptrTo_Scanner_Text(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Scanner)Text()", args, 0, 0)
	_res := o.O.(*_bufio.Scanner).Text()
	return MakeString(_res)
}

GO FUNC bufio.__ptrTo_Writer_Available from bufio/bufio.go:
func __ptrTo_Writer_Available(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Writer)Available()", args, 0, 0)
	_res := o.O.(*_bufio.Writer).Available()
	return MakeInt(_res)
}

GO FUNC bufio.__ptrTo_Writer_Buffered from bufio/bufio.go:
func __ptrTo_Writer_Buffered(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Writer)Buffered()", args, 0, 0)
	_res := o.O.(*_bufio.Writer).Buffered()
	return MakeInt(_res)
}

GO FUNC bufio.__ptrTo_Writer_Flush from bufio/bufio.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_bufio.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bufio.__ptrTo_Writer_ReadFrom from bufio/bufio.go:
// func __ptrTo_Writer_ReadFrom(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC bufio.__ptrTo_Writer_Reset from bufio/bufio.go:
// func __ptrTo_Writer_Reset(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC bufio.__ptrTo_Writer_Size from bufio/bufio.go:
func __ptrTo_Writer_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_bufio.Writer)Size()", args, 0, 0)
	_res := o.O.(*_bufio.Writer).Size()
	return MakeInt(_res)
}

GO FUNC bufio.__ptrTo_Writer_Write from bufio/bufio.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC bufio.__ptrTo_Writer_WriteByte from bufio/bufio.go:
func __ptrTo_Writer_WriteByte(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Writer)WriteByte()", args, 1, 1)
	c := ExtractGoByte("(*_bufio.Writer)WriteByte()", "c", _argList, 0)
	_res := o.O.(*_bufio.Writer).WriteByte(c)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bufio.__ptrTo_Writer_WriteRune from bufio/bufio.go:
func __ptrTo_Writer_WriteRune(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Writer)WriteRune()", args, 1, 1)
	r := ExtractGoChar("(*_bufio.Writer)WriteRune()", "r", _argList, 0)
	size, err := o.O.(*_bufio.Writer).WriteRune(r)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(size))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.__ptrTo_Writer_WriteString from bufio/bufio.go:
func __ptrTo_Writer_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bufio.Writer)WriteString()", args, 1, 1)
	s := ExtractGoString("(*_bufio.Writer)WriteString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_bufio.Writer).WriteString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bufio

import (
	_bufio "bufio"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Buffered": __ptrTo_Reader_Buffered,
	"Discard": __ptrTo_Reader_Discard,
	"Peek": __ptrTo_Reader_Peek,
	"ReadByte": __ptrTo_Reader_ReadByte,
	"ReadBytes": __ptrTo_Reader_ReadBytes,
	"ReadLine": __ptrTo_Reader_ReadLine,
	"ReadRune": __ptrTo_Reader_ReadRune,
	"ReadSlice": __ptrTo_Reader_ReadSlice,
	"ReadString": __ptrTo_Reader_ReadString,
	"Size": __ptrTo_Reader_Size,
	"UnreadByte": __ptrTo_Reader_UnreadByte,
	"UnreadRune": __ptrTo_Reader_UnreadRune,
}}

var members_PtrTo_Scanner = GoTypeInfo{Members: GoMembers{
	"Bytes": __ptrTo_Scanner_Bytes,
	"Err": __ptrTo_Scanner_Err,
	"Scan": __ptrTo_Scanner_Scan,
	"Text": __ptrTo_Scanner_Text,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Available": __ptrTo_Writer_Available,
	"Buffered": __ptrTo_Writer_Buffered,
	"Flush": __ptrTo_Writer_Flush,
	"Size": __ptrTo_Writer_Size,
	"WriteByte": __ptrTo_Writer_WriteByte,
	"WriteRune": __ptrTo_Writer_WriteRune,
	"WriteString": __ptrTo_Writer_WriteString,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_bufio.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_bufio.Scanner)(nil))] = &members_PtrTo_Scanner
	GoTypes[_reflect.TypeOf((*_bufio.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE bytes.Buffer from bytes/buffer.go:
func ExtractGoObjectBuffer(args []Object, index int) *_bytes.Buffer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bytes.Buffer:
			return &r
		case *_bytes.Buffer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bytes.Buffer]"))
}

func _mapToBuffer(o Map) *_bytes.Buffer {
	return &_bytes.Buffer{}
}

func _vectorToBuffer(o *Vector) *_bytes.Buffer {
	return &_bytes.Buffer{}
}

func _ConstructBuffer(_v Object) *_bytes.Buffer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bytes.Buffer:
			return &_g
		case *_bytes.Buffer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuffer(_o.(Map))
	case *Vector:
		return _vectorToBuffer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bytes.Buffer] or: Map or Vector"))
}

GO TYPE bytes.Reader from bytes/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_bytes.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bytes.Reader:
			return &r
		case *_bytes.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[bytes.Reader]"))
}

func _mapToReader(o Map) *_bytes.Reader {
	return &_bytes.Reader{}
}

func _vectorToReader(o *Vector) *_bytes.Reader {
	return &_bytes.Reader{}
}

func _ConstructReader(_v Object) *_bytes.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bytes.Reader:
			return &_g
		case *_bytes.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bytes.Reader] or: Map or Vector"))
}

GO FUNC bytes.Compare from bytes/bytes.go:
// func __compare(a []byte, b []byte)  {
// 	_res := _bytes.Compare(a, b)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Contains from bytes/bytes.go:
// func __contains(b []byte, subslice []byte)  {
// 	_res := _bytes.Contains(b, subslice)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.ContainsAny from bytes/bytes.go:
// func __containsAny(b []byte, chars string)  {
// 	_res := _bytes.ContainsAny(b, chars)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.ContainsRune from bytes/bytes.go:
// func __containsRune(b []byte, r rune)  {
// 	_res := _bytes.ContainsRune(b, r)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Count from bytes/bytes.go:
// func __count(s []byte, sep []byte)  {
// 	_res := _bytes.Count(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Equal from bytes/bytes.go:
// func __equal(a []byte, b []byte)  {
// 	_res := _bytes.Equal(a, b)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.EqualFold from bytes/bytes.go:
// func __equalFold(s []byte, t []byte)  {
// 	_res := _bytes.EqualFold(s, t)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Fields from bytes/bytes.go:
// func __fields(s []byte) Object {
// 	_res := _bytes.Fields(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.FieldsFunc from bytes/bytes.go:
// func __fieldsFunc(s []byte, f func) Object {
// 	_res := _bytes.FieldsFunc(s, f)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.HasPrefix from bytes/bytes.go:
// func __hasPrefix(s []byte, prefix []byte)  {
// 	_res := _bytes.HasPrefix(s, prefix)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.HasSuffix from bytes/bytes.go:
// func __hasSuffix(s []byte, suffix []byte)  {
// 	_res := _bytes.HasSuffix(s, suffix)
// 	return MakeBoolean(_res)
// }

GO FUNC bytes.Index from bytes/bytes.go:
// func __index(s []byte, sep []byte)  {
// 	_res := _bytes.Index(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexAny from bytes/bytes.go:
// func __indexAny(s []byte, chars string)  {
// 	_res := _bytes.IndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexByte from bytes/bytes.go:
// func __indexByte(b []byte, c byte)  {
// 	_res := _bytes.IndexByte(b, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexFunc from bytes/bytes.go:
// func __indexFunc(s []byte, f func)  {
// 	_res := _bytes.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.IndexRune from bytes/bytes.go:
// func __indexRune(s []byte, r rune)  {
// 	_res := _bytes.IndexRune(s, r)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Join from bytes/bytes.go:
// func __join(s [][]byte, sep []byte) Object {
// 	_res := _bytes.Join(s, sep)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.LastIndex from bytes/bytes.go:
// func __lastIndex(s []byte, sep []byte)  {
// 	_res := _bytes.LastIndex(s, sep)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexAny from bytes/bytes.go:
// func __lastIndexAny(s []byte, chars string)  {
// 	_res := _bytes.LastIndexAny(s, chars)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexByte from bytes/bytes.go:
// func __lastIndexByte(s []byte, c byte)  {
// 	_res := _bytes.LastIndexByte(s, c)
// 	return MakeInt(_res)
// }

GO FUNC bytes.LastIndexFunc from bytes/bytes.go:
// func __lastIndexFunc(s []byte, f func)  {
// 	_res := _bytes.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC bytes.Map from bytes/bytes.go:
// func __map(mapping func, s []byte) Object {
// 	_res := _bytes.Map(mapping, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.NewBuffer from bytes/buffer.go:
// func __newBuffer(buf []byte) Object {
// 	_res := _bytes.NewBuffer(buf)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.NewBufferString from bytes/buffer.go:
func __newBufferString(s string) Object {
	_res := _bytes.NewBufferString(s)
	return MakeGoObject(_res)
}

GO FUNC bytes.NewReader from bytes/reader.go:
// func __newReader(b []byte) Object {
// 	_res := _bytes.NewReader(b)
// 	return MakeGoObject(_res)
// }

GO FUNC bytes.Repeat from bytes/bytes.go:
// func __repeat(b []byte, count int) Object {
// 	_res := _bytes.Repeat(b, count)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Replace from bytes/bytes.go:
// func __replace(s []byte, old []byte, new []byte, n int) Object {
// 	_res := _bytes.Replace(s, old, new, n)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ReplaceAll from bytes/bytes.go:
// func __replaceAll(s []byte, old []byte, new []byte) Object {
// 	_res := _bytes.ReplaceAll(s, old, new)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Runes from bytes/bytes.go:
// func __runes(s []byte) Object {
// 	_res := _bytes.Runes(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeChar(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Split from bytes/bytes.go:
// func __split(s []byte, sep []byte) Object {
// 	_res := _bytes.Split(s, sep)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfter from bytes/bytes.go:
// func __splitAfter(s []byte, sep []byte) Object {
// 	_res := _bytes.SplitAfter(s, sep)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitAfterN from bytes/bytes.go:
// func __splitAfterN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitAfterN(s, sep, n)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.SplitN from bytes/bytes.go:
// func __splitN(s []byte, sep []byte, n int) Object {
// 	_res := _bytes.SplitN(s, sep, n)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Title from bytes/bytes.go:
// func __title(s []byte) Object {
// 	_res := _bytes.Title(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLower from bytes/bytes.go:
// func __toLower(s []byte) Object {
// 	_res := _bytes.ToLower(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToLowerSpecial from bytes/bytes.go:
// func __toLowerSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToLowerSpecial(c, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitle from bytes/bytes.go:
// func __toTitle(s []byte) Object {
// 	_res := _bytes.ToTitle(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitleSpecial from bytes/bytes.go:
// func __toTitleSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToTitleSpecial(c, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpper from bytes/bytes.go:
// func __toUpper(s []byte) Object {
// 	_res := _bytes.ToUpper(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpperSpecial from bytes/bytes.go:
// func __toUpperSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s []byte) Object {
// 	_res := _bytes.ToUpperSpecial(c, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Trim from bytes/bytes.go:
// func __trim(s []byte, cutset string) Object {
// 	_res := _bytes.Trim(s, cutset)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimFunc from bytes/bytes.go:
// func __trimFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimFunc(s, f)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeft from bytes/bytes.go:
// func __trimLeft(s []byte, cutset string) Object {
// 	_res := _bytes.TrimLeft(s, cutset)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeftFunc from bytes/bytes.go:
// func __trimLeftFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimLeftFunc(s, f)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimPrefix from bytes/bytes.go:
// func __trimPrefix(s []byte, prefix []byte) Object {
// 	_res := _bytes.TrimPrefix(s, prefix)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRight from bytes/bytes.go:
// func __trimRight(s []byte, cutset string) Object {
// 	_res := _bytes.TrimRight(s, cutset)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimRightFunc from bytes/bytes.go:
// func __trimRightFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimRightFunc(s, f)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSpace from bytes/bytes.go:
// func __trimSpace(s []byte) Object {
// 	_res := _bytes.TrimSpace(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSuffix from bytes/bytes.go:
// func __trimSuffix(s []byte, suffix []byte) Object {
// 	_res := _bytes.TrimSuffix(s, suffix)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.__ptrTo_Buffer_Bytes from bytes/buffer.go:
func __ptrTo_Buffer_Bytes(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)Bytes()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).Bytes()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.__ptrTo_Buffer_Cap from bytes/buffer.go:
func __ptrTo_Buffer_Cap(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)Cap()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).Cap()
	return MakeInt(_res)
}

GO FUNC bytes.__ptrTo_Buffer_Grow from bytes/buffer.go:
// func __ptrTo_Buffer_Grow(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC bytes.__ptrTo_Buffer_Len from bytes/buffer.go:
func __ptrTo_Buffer_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)Len()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).Len()
	return MakeInt(_res)
}

GO FUNC bytes.__ptrTo_Buffer_Next from bytes/buffer.go:
func __ptrTo_Buffer_Next(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)Next()", args, 1, 1)
	n := ExtractGoInt("(*_bytes.Buffer)Next()", "n", _argList, 0)
	_res := o.O.(*_bytes.Buffer).Next(n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.__ptrTo_Buffer_Read from bytes/buffer.go:
// func __ptrTo_Buffer_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC bytes.__ptrTo_Buffer_ReadByte from bytes/buffer.go:
func __ptrTo_Buffer_ReadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)ReadByte()", args, 0, 0)
	_res1, _res2 := o.O.(*_bytes.Buffer).ReadByte()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_ReadBytes from bytes/buffer.go:
func __ptrTo_Buffer_ReadBytes(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)ReadBytes()", args, 1, 1)
	delim := ExtractGoByte("(*_bytes.Buffer)ReadBytes()", "delim", _argList, 0)
	line, err := o.O.(*_bytes.Buffer).ReadBytes(delim)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range line {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_ReadFrom from bytes/buffer.go:
// func __ptrTo_Buffer_ReadFrom(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC bytes.__ptrTo_Buffer_ReadRune from bytes/buffer.go:
func __ptrTo_Buffer_ReadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)ReadRune()", args, 0, 0)
	r, size, err := o.O.(*_bytes.Buffer).ReadRune()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(r))
	_res = _res.Conjoin(MakeInt(size))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_ReadString from bytes/buffer.go:
func __ptrTo_Buffer_ReadString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)ReadString()", args, 1, 1)
	delim := ExtractGoByte("(*_bytes.Buffer)ReadString()", "delim", _argList, 0)
	line, err := o.O.(*_bytes.Buffer).ReadString(delim)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(line))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_Reset from bytes/buffer.go:
// func __ptrTo_Buffer_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC bytes.__ptrTo_Buffer_String from bytes/buffer.go:
func __ptrTo_Buffer_String(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)String()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).String()
	return MakeString(_res)
}

GO FUNC bytes.__ptrTo_Buffer_Truncate from bytes/buffer.go:
// func __ptrTo_Buffer_Truncate(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC bytes.__ptrTo_Buffer_UnreadByte from bytes/buffer.go:
func __ptrTo_Buffer_UnreadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)UnreadByte()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).UnreadByte()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bytes.__ptrTo_Buffer_UnreadRune from bytes/buffer.go:
func __ptrTo_Buffer_UnreadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Buffer)UnreadRune()", args, 0, 0)
	_res := o.O.(*_bytes.Buffer).UnreadRune()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bytes.__ptrTo_Buffer_Write from bytes/buffer.go:
// func __ptrTo_Buffer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC bytes.__ptrTo_Buffer_WriteByte from bytes/buffer.go:
func __ptrTo_Buffer_WriteByte(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)WriteByte()", args, 1, 1)
	c := ExtractGoByte("(*_bytes.Buffer)WriteByte()", "c", _argList, 0)
	_res := o.O.(*_bytes.Buffer).WriteByte(c)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bytes.__ptrTo_Buffer_WriteRune from bytes/buffer.go:
func __ptrTo_Buffer_WriteRune(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)WriteRune()", args, 1, 1)
	r := ExtractGoChar("(*_bytes.Buffer)WriteRune()", "r", _argList, 0)
	n, err := o.O.(*_bytes.Buffer).WriteRune(r)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_WriteString from bytes/buffer.go:
func __ptrTo_Buffer_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Buffer)WriteString()", args, 1, 1)
	s := ExtractGoString("(*_bytes.Buffer)WriteString()", "s", _argList, 0)
	n, err := o.O.(*_bytes.Buffer).WriteString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Buffer_WriteTo from bytes/buffer.go:
// func __ptrTo_Buffer_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC bytes.__ptrTo_Reader_Len from bytes/reader.go:
func __ptrTo_Reader_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)Len()", args, 0, 0)
	_res := o.O.(*_bytes.Reader).Len()
	return MakeInt(_res)
}

GO FUNC bytes.__ptrTo_Reader_Read from bytes/reader.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC bytes.__ptrTo_Reader_ReadAt from bytes/reader.go:
// func __ptrTo_Reader_ReadAt(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), off)}

GO FUNC bytes.__ptrTo_Reader_ReadByte from bytes/reader.go:
func __ptrTo_Reader_ReadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)ReadByte()", args, 0, 0)
	_res1, _res2 := o.O.(*_bytes.Reader).ReadByte()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Reader_ReadRune from bytes/reader.go:
func __ptrTo_Reader_ReadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)ReadRune()", args, 0, 0)
	ch, size, err := o.O.(*_bytes.Reader).ReadRune()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(ch))
	_res = _res.Conjoin(MakeInt(size))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Reader_Reset from bytes/reader.go:
// func __ptrTo_Reader_Reset(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC bytes.__ptrTo_Reader_Seek from bytes/reader.go:
func __ptrTo_Reader_Seek(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_bytes.Reader)Seek()", args, 2, 2)
	offset := ExtractGoInt64("(*_bytes.Reader)Seek()", "offset", _argList, 0)
	whence := ExtractGoInt("(*_bytes.Reader)Seek()", "whence", _argList, 1)
	_res1, _res2 := o.O.(*_bytes.Reader).Seek(offset, whence)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC bytes.__ptrTo_Reader_Size from bytes/reader.go:
func __ptrTo_Reader_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)Size()", args, 0, 0)
	_res := o.O.(*_bytes.Reader).Size()
	return MakeBigInt(_res)
}

GO FUNC bytes.__ptrTo_Reader_UnreadByte from bytes/reader.go:
func __ptrTo_Reader_UnreadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)UnreadByte()", args, 0, 0)
	_res := o.O.(*_bytes.Reader).UnreadByte()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bytes.__ptrTo_Reader_UnreadRune from bytes/reader.go:
func __ptrTo_Reader_UnreadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_bytes.Reader)UnreadRune()", args, 0, 0)
	_res := o.O.(*_bytes.Reader).UnreadRune()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC bytes.__ptrTo_Reader_WriteTo from bytes/reader.go:
// func __ptrTo_Reader_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bytes

import (
	_bytes "bytes"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Buffer = GoTypeInfo{Members: GoMembers{
	"Bytes": __ptrTo_Buffer_Bytes,
	"Cap": __ptrTo_Buffer_Cap,
	"Len": __ptrTo_Buffer_Len,
	"Next": __ptrTo_Buffer_Next,
	"ReadByte": __ptrTo_Buffer_ReadByte,
	"ReadBytes": __ptrTo_Buffer_ReadBytes,
	"ReadRune": __ptrTo_Buffer_ReadRune,
	"ReadString": __ptrTo_Buffer_ReadString,
	"String": __ptrTo_Buffer_String,
	"UnreadByte": __ptrTo_Buffer_UnreadByte,
	"UnreadRune": __ptrTo_Buffer_UnreadRune,
	"WriteByte": __ptrTo_Buffer_WriteByte,
	"WriteRune": __ptrTo_Buffer_WriteRune,
	"WriteString": __ptrTo_Buffer_WriteString,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Len": __ptrTo_Reader_Len,
	"ReadByte": __ptrTo_Reader_ReadByte,
	"ReadRune": __ptrTo_Reader_ReadRune,
	"Seek": __ptrTo_Reader_Seek,
	"Size": __ptrTo_Reader_Size,
	"UnreadByte": __ptrTo_Reader_UnreadByte,
	"UnreadRune": __ptrTo_Reader_UnreadRune,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_bytes.Buffer)(nil))] = &members_PtrTo_Buffer
	GoTypes[_reflect.TypeOf((*_bytes.Reader)(nil))] = &members_PtrTo_Reader
}

GO TYPE compress/bzip2.StructuralError from compress/bzip2/bzip2.go:
func ExtractGoObjectStructuralError(args []Object, index int) *_bzip2.StructuralError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _bzip2.StructuralError:
			return &r
		case *_bzip2.StructuralError:
			return r
		}
	case String:
		v := _bzip2.StructuralError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/bzip2.StructuralError]"))
}

func _ConstructStructuralError(_v Object) _bzip2.StructuralError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _bzip2.StructuralError:
			return _g
		case *_bzip2.StructuralError:
			return *_g
		}
	case String:
		return _bzip2.StructuralError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[bzip2.StructuralError] or: String"))
}

GO FUNC compress/bzip2.NewReader from compress/bzip2/bzip2.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _bzip2.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/bzip2.__structuralError_Error from compress/bzip2/bzip2.go:
func __structuralError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_compress/bzip2.StructuralError)Error()", args, 0, 0)
	_res := o.O.(_bzip2.StructuralError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bzip2

import (
	_bzip2 "compress/bzip2"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_StructuralError = GoTypeInfo{Members: GoMembers{
	"Error": __structuralError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_bzip2.StructuralError)(nil)).Elem()] = &members_StructuralError
}

GO TYPE compress/flate.CorruptInputError from compress/flate/inflate.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_flate.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.CorruptInputError:
			return &r
		case *_flate.CorruptInputError:
			return r
		}
	case Number:
		v := _flate.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _flate.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flate.CorruptInputError:
			return _g
		case *_flate.CorruptInputError:
			return *_g
		}
	case Number:
		return _flate.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.CorruptInputError] or: Number"))
}

GO TYPE compress/flate.InternalError from compress/flate/inflate.go:
func ExtractGoObjectInternalError(args []Object, index int) *_flate.InternalError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.InternalError:
			return &r
		case *_flate.InternalError:
			return r
		}
	case String:
		v := _flate.InternalError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.InternalError]"))
}

func _ConstructInternalError(_v Object) _flate.InternalError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flate.InternalError:
			return _g
		case *_flate.InternalError:
			return *_g
		}
	case String:
		return _flate.InternalError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.InternalError] or: String"))
}

GO TYPE compress/flate.ReadError from compress/flate/inflate.go:
func ExtractGoObjectReadError(args []Object, index int) *_flate.ReadError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.ReadError:
			return &r
		case *_flate.ReadError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.ReadError]"))
}

func _mapToReadError(o Map) *_flate.ReadError {
	return &_flate.ReadError{}
}

func _vectorToReadError(o *Vector) *_flate.ReadError {
	return &_flate.ReadError{
		Offset: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Err: _errors.New(AssertString(o.Nth(1), "").S),
	}
}

func _ConstructReadError(_v Object) *_flate.ReadError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flate.ReadError:
			return &_g
		case *_flate.ReadError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReadError(_o.(Map))
	case *Vector:
		return _vectorToReadError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.ReadError] or: Map or Vector"))
}

GO TYPE compress/flate.Reader from compress/flate/inflate.go:
func ExtractGoObjectReader(args []Object, index int) *_flate.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.Reader:
			return &r
		case *_flate.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.Reader]"))
}

// func _ConstructReader(_v Object) _flate.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flate.Reader:
// 			return _g
// 		case *_flate.Reader:
// 			return *_g
// 		}
// 	default:
// 		return _flate.Reader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Reader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.Reader] or: whatever"))
// }

GO TYPE compress/flate.Resetter from compress/flate/inflate.go:
func ExtractGoObjectResetter(args []Object, index int) *_flate.Resetter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.Resetter:
			return &r
		case *_flate.Resetter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.Resetter]"))
}

// func _ConstructResetter(_v Object) _flate.Resetter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flate.Resetter:
// 			return _g
// 		case *_flate.Resetter:
// 			return *_g
// 		}
// 	default:
// 		return _flate.Resetter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Resetter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.Resetter] or: whatever"))
// }

GO TYPE compress/flate.WriteError from compress/flate/inflate.go:
func ExtractGoObjectWriteError(args []Object, index int) *_flate.WriteError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.WriteError:
			return &r
		case *_flate.WriteError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.WriteError]"))
}

func _mapToWriteError(o Map) *_flate.WriteError {
	return &_flate.WriteError{}
}

func _vectorToWriteError(o *Vector) *_flate.WriteError {
	return &_flate.WriteError{
		Offset: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Err: _errors.New(AssertString(o.Nth(1), "").S),
	}
}

func _ConstructWriteError(_v Object) *_flate.WriteError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flate.WriteError:
			return &_g
		case *_flate.WriteError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriteError(_o.(Map))
	case *Vector:
		return _vectorToWriteError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.WriteError] or: Map or Vector"))
}

GO TYPE compress/flate.Writer from compress/flate/deflate.go:
func ExtractGoObjectWriter(args []Object, index int) *_flate.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flate.Writer:
			return &r
		case *_flate.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/flate.Writer]"))
}

func _mapToWriter(o Map) *_flate.Writer {
	return &_flate.Writer{}
}

func _vectorToWriter(o *Vector) *_flate.Writer {
	return &_flate.Writer{}
}

func _ConstructWriter(_v Object) *_flate.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flate.Writer:
			return &_g
		case *_flate.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flate.Writer] or: Map or Vector"))
}

GO FUNC compress/flate.NewReader from compress/flate/inflate.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _flate.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewReaderDict from compress/flate/inflate.go:
// func __newReaderDict(r ABEND987(genutils.go: imports not yet supported: io.Reader), dict []byte) Object {
// 	_res := _flate.NewReaderDict(r, dict)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/flate.NewWriter from compress/flate/deflate.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _flate.NewWriter(w, level)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/flate.NewWriterDict from compress/flate/deflate.go:
// func __newWriterDict(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int, dict []byte) Object {
// 	_res1, _res2 := _flate.NewWriterDict(w, level, dict)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/flate.__corruptInputError_Error from compress/flate/inflate.go:
func __corruptInputError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_compress/flate.CorruptInputError)Error()", args, 0, 0)
	_res := o.O.(_flate.CorruptInputError).Error()
	return MakeString(_res)
}

GO FUNC compress/flate.__internalError_Error from compress/flate/inflate.go:
func __internalError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_compress/flate.InternalError)Error()", args, 0, 0)
	_res := o.O.(_flate.InternalError).Error()
	return MakeString(_res)
}

GO FUNC compress/flate.__ptrTo_ReadError_Error from compress/flate/inflate.go:
func __ptrTo_ReadError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/flate.ReadError)Error()", args, 0, 0)
	_res := o.O.(*_flate.ReadError).Error()
	return MakeString(_res)
}

GO FUNC compress/flate.__ptrTo_WriteError_Error from compress/flate/inflate.go:
func __ptrTo_WriteError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/flate.WriteError)Error()", args, 0, 0)
	_res := o.O.(*_flate.WriteError).Error()
	return MakeString(_res)
}

GO FUNC compress/flate.__ptrTo_Writer_Close from compress/flate/deflate.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/flate.Writer)Close()", args, 0, 0)
	_res := o.O.(*_flate.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/flate.__ptrTo_Writer_Flush from compress/flate/deflate.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/flate.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_flate.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/flate.__ptrTo_Writer_Reset from compress/flate/deflate.go:
// func __ptrTo_Writer_Reset(o GoObject, args Object) Object {
// dst ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC compress/flate.__ptrTo_Writer_Write from compress/flate/deflate.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package flate

import (
	_flate "compress/flate"
	_errors "errors"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_CorruptInputError = GoTypeInfo{Members: GoMembers{
	"Error": __corruptInputError_Error,
}}

var members_InternalError = GoTypeInfo{Members: GoMembers{
	"Error": __internalError_Error,
}}

var members_PtrTo_ReadError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ReadError_Error,
}}

var members_PtrTo_WriteError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_WriteError_Error,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
	"Flush": __ptrTo_Writer_Flush,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_flate.CorruptInputError)(nil)).Elem()] = &members_CorruptInputError
	GoTypes[_reflect.TypeOf((*_flate.InternalError)(nil)).Elem()] = &members_InternalError
	GoTypes[_reflect.TypeOf((*_flate.ReadError)(nil))] = &members_PtrTo_ReadError
	GoTypes[_reflect.TypeOf((*_flate.WriteError)(nil))] = &members_PtrTo_WriteError
	GoTypes[_reflect.TypeOf((*_flate.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE compress/gzip.Header from compress/gzip/gunzip.go:
func ExtractGoObjectHeader(args []Object, index int) *_gzip.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gzip.Header:
			return &r
		case *_gzip.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/gzip.Header]"))
}

// func _mapToHeader(o Map) *_gzip.Header {
// 	return &_gzip.Header{}
// }

// func _vectorToHeader(o *Vector) *_gzip.Header {
// 	return &_gzip.Header{
// 		Comment: AssertString(o.Nth(0), "").S,
// 		Extra: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		ModTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Name: AssertString(o.Nth(3), "").S,
// 		OS: byte(AssertInt(o.Nth(4), "").I),
// 	}
// }

// func _ConstructHeader(_v Object) *_gzip.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gzip.Header:
// 			return &_g
// 		case *_gzip.Header:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gzip.Header] or: Map or Vector"))
// }

GO TYPE compress/gzip.Reader from compress/gzip/gunzip.go:
func ExtractGoObjectReader(args []Object, index int) *_gzip.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gzip.Reader:
			return &r
		case *_gzip.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/gzip.Reader]"))
}

func _mapToReader(o Map) *_gzip.Reader {
	return &_gzip.Reader{}
}

func _vectorToReader(o *Vector) *_gzip.Reader {
	return &_gzip.Reader{}
}

func _ConstructReader(_v Object) *_gzip.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _gzip.Reader:
			return &_g
		case *_gzip.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[gzip.Reader] or: Map or Vector"))
}

GO TYPE compress/gzip.Writer from compress/gzip/gzip.go:
func ExtractGoObjectWriter(args []Object, index int) *_gzip.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gzip.Writer:
			return &r
		case *_gzip.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/gzip.Writer]"))
}

func _mapToWriter(o Map) *_gzip.Writer {
	return &_gzip.Writer{}
}

func _vectorToWriter(o *Vector) *_gzip.Writer {
	return &_gzip.Writer{}
}

func _ConstructWriter(_v Object) *_gzip.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _gzip.Writer:
			return &_g
		case *_gzip.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[gzip.Writer] or: Map or Vector"))
}

GO FUNC compress/gzip.NewReader from compress/gzip/gunzip.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gzip.NewReader(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewWriter from compress/gzip/gzip.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _gzip.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/gzip.NewWriterLevel from compress/gzip/gzip.go:
// func __newWriterLevel(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _gzip.NewWriterLevel(w, level)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.__ptrTo_Reader_Close from compress/gzip/gunzip.go:
func __ptrTo_Reader_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/gzip.Reader)Close()", args, 0, 0)
	_res := o.O.(*_gzip.Reader).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/gzip.__ptrTo_Reader_Multistream from compress/gzip/gunzip.go:
// func __ptrTo_Reader_Multistream(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC compress/gzip.__ptrTo_Reader_Read from compress/gzip/gunzip.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC compress/gzip.__ptrTo_Reader_Reset from compress/gzip/gunzip.go:
// func __ptrTo_Reader_Reset(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC compress/gzip.__ptrTo_Writer_Close from compress/gzip/gzip.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/gzip.Writer)Close()", args, 0, 0)
	_res := o.O.(*_gzip.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/gzip.__ptrTo_Writer_Flush from compress/gzip/gzip.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/gzip.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_gzip.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/gzip.__ptrTo_Writer_Reset from compress/gzip/gzip.go:
// func __ptrTo_Writer_Reset(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC compress/gzip.__ptrTo_Writer_Write from compress/gzip/gzip.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package gzip

import (
	_gzip "compress/gzip"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Reader_Close,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
	"Flush": __ptrTo_Writer_Flush,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_gzip.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_gzip.Writer)(nil))] = &members_PtrTo_Writer
}

GO FUNC compress/lzw.NewReader from compress/lzw/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader), order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewReader(r, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/lzw.NewWriter from compress/lzw/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), order _lzw.Order, litWidth int) Object {
// 	_res := _lzw.NewWriter(w, order, litWidth)
// 	return MakeGoObject(_res)
// }

GO TYPE compress/zlib.Resetter from compress/zlib/reader.go:
func ExtractGoObjectResetter(args []Object, index int) *_zlib.Resetter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zlib.Resetter:
			return &r
		case *_zlib.Resetter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/zlib.Resetter]"))
}

// func _ConstructResetter(_v Object) _zlib.Resetter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _zlib.Resetter:
// 			return _g
// 		case *_zlib.Resetter:
// 			return *_g
// 		}
// 	default:
// 		return _zlib.Resetter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Resetter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[zlib.Resetter] or: whatever"))
// }

GO TYPE compress/zlib.Writer from compress/zlib/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_zlib.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _zlib.Writer:
			return &r
		case *_zlib.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[compress/zlib.Writer]"))
}

func _mapToWriter(o Map) *_zlib.Writer {
	return &_zlib.Writer{}
}

func _vectorToWriter(o *Vector) *_zlib.Writer {
	return &_zlib.Writer{}
}

func _ConstructWriter(_v Object) *_zlib.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _zlib.Writer:
			return &_g
		case *_zlib.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[zlib.Writer] or: Map or Vector"))
}

GO FUNC compress/zlib.NewReader from compress/zlib/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _zlib.NewReader(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewReaderDict from compress/zlib/reader.go:
// func __newReaderDict(r ABEND987(genutils.go: imports not yet supported: io.Reader), dict []byte) Object {
// 	_res1, _res2 := _zlib.NewReaderDict(r, dict)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriter from compress/zlib/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _zlib.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC compress/zlib.NewWriterLevel from compress/zlib/writer.go:
// func __newWriterLevel(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int) Object {
// 	_res1, _res2 := _zlib.NewWriterLevel(w, level)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriterLevelDict from compress/zlib/writer.go:
// func __newWriterLevelDict(w ABEND987(genutils.go: imports not yet supported: io.Writer), level int, dict []byte) Object {
// 	_res1, _res2 := _zlib.NewWriterLevelDict(w, level, dict)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.__ptrTo_Writer_Close from compress/zlib/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/zlib.Writer)Close()", args, 0, 0)
	_res := o.O.(*_zlib.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/zlib.__ptrTo_Writer_Flush from compress/zlib/writer.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_compress/zlib.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_zlib.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC compress/zlib.__ptrTo_Writer_Reset from compress/zlib/writer.go:
// func __ptrTo_Writer_Reset(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC compress/zlib.__ptrTo_Writer_Write from compress/zlib/writer.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package zlib

import (
	_zlib "compress/zlib"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
	"Flush": __ptrTo_Writer_Flush,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_zlib.Writer)(nil))] = &members_PtrTo_Writer
}

GO FUNC container/heap.Fix from container/heap/heap.go:
// func __fix(h _heap.Interface, i int) Object {
// 	_heap.Fix(h, i)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Init from container/heap/heap.go:
// func __init(h _heap.Interface) Object {
// 	_heap.Init(h)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Pop from container/heap/heap.go:
// func __pop(h _heap.Interface) Object {
// 	return _heap.Pop(h)
// }

GO FUNC container/heap.Push from container/heap/heap.go:
// func __push(h _heap.Interface, x interface {}) Object {
// 	_heap.Push(h, x)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Remove from container/heap/heap.go:
// func __remove(h _heap.Interface, i int) Object {
// 	return _heap.Remove(h, i)
// }

GO TYPE container/list.Element from container/list/list.go:
func ExtractGoObjectElement(args []Object, index int) *_list.Element {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _list.Element:
			return &r
		case *_list.Element:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/list.Element]"))
}

// func _mapToElement(o Map) *_list.Element {
// 	return &_list.Element{}
// }

// func _vectorToElement(o *Vector) *_list.Element {
// 	return &_list.Element{
// 		Value: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructElement(_v Object) *_list.Element {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _list.Element:
// 			return &_g
// 		case *_list.Element:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToElement(_o.(Map))
// 	case *Vector:
// 		return _vectorToElement(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[list.Element] or: Map or Vector"))
// }

GO TYPE container/list.List from container/list/list.go:
func ExtractGoObjectList(args []Object, index int) *_list.List {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _list.List:
			return &r
		case *_list.List:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/list.List]"))
}

func _mapToList(o Map) *_list.List {
	return &_list.List{}
}

func _vectorToList(o *Vector) *_list.List {
	return &_list.List{}
}

func _ConstructList(_v Object) *_list.List {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _list.List:
			return &_g
		case *_list.List:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToList(_o.(Map))
	case *Vector:
		return _vectorToList(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[list.List] or: Map or Vector"))
}

GO FUNC container/list.New from container/list/list.go:
func __new() Object {
	_res := _list.New()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_Element_Next from container/list/list.go:
func __ptrTo_Element_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.Element)Next()", args, 0, 0)
	_res := o.O.(*_list.Element).Next()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_Element_Prev from container/list/list.go:
func __ptrTo_Element_Prev(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.Element)Prev()", args, 0, 0)
	_res := o.O.(*_list.Element).Prev()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_List_Back from container/list/list.go:
func __ptrTo_List_Back(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.List)Back()", args, 0, 0)
	_res := o.O.(*_list.List).Back()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_List_Front from container/list/list.go:
func __ptrTo_List_Front(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.List)Front()", args, 0, 0)
	_res := o.O.(*_list.List).Front()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_List_Init from container/list/list.go:
func __ptrTo_List_Init(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.List)Init()", args, 0, 0)
	_res := o.O.(*_list.List).Init()
	return MakeGoObject(_res)
}

GO FUNC container/list.__ptrTo_List_InsertAfter from container/list/list.go:
// func __ptrTo_List_InsertAfter(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), mark)}

GO FUNC container/list.__ptrTo_List_InsertBefore from container/list/list.go:
// func __ptrTo_List_InsertBefore(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), mark)}

GO FUNC container/list.__ptrTo_List_Len from container/list/list.go:
func __ptrTo_List_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_container/list.List)Len()", args, 0, 0)
	_res := o.O.(*_list.List).Len()
	return MakeInt(_res)
}

GO FUNC container/list.__ptrTo_List_MoveAfter from container/list/list.go:
// func __ptrTo_List_MoveAfter(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_MoveBefore from container/list/list.go:
// func __ptrTo_List_MoveBefore(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_MoveToBack from container/list/list.go:
// func __ptrTo_List_MoveToBack(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_MoveToFront from container/list/list.go:
// func __ptrTo_List_MoveToFront(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_PushBack from container/list/list.go:
// func __ptrTo_List_PushBack(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC container/list.__ptrTo_List_PushBackList from container/list/list.go:
// func __ptrTo_List_PushBackList(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_PushFront from container/list/list.go:
// func __ptrTo_List_PushFront(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC container/list.__ptrTo_List_PushFrontList from container/list/list.go:
// func __ptrTo_List_PushFrontList(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC container/list.__ptrTo_List_Remove from container/list/list.go:
// func __ptrTo_List_Remove(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/container/list/list.go:139:35)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package list

import (
	_list "container/list"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Element = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_Element_Next,
	"Prev": __ptrTo_Element_Prev,
}}

var members_PtrTo_List = GoTypeInfo{Members: GoMembers{
	"Back": __ptrTo_List_Back,
	"Front": __ptrTo_List_Front,
	"Init": __ptrTo_List_Init,
	"Len": __ptrTo_List_Len,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_list.Element)(nil))] = &members_PtrTo_Element
	GoTypes[_reflect.TypeOf((*_list.List)(nil))] = &members_PtrTo_List
}

GO TYPE container/ring.Ring from container/ring/ring.go:
func ExtractGoObjectRing(args []Object, index int) *_ring.Ring {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ring.Ring:
			return &r
		case *_ring.Ring:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[container/ring.Ring]"))
}

// func _mapToRing(o Map) *_ring.Ring {
// 	return &_ring.Ring{}
// }

// func _vectorToRing(o *Vector) *_ring.Ring {
// 	return &_ring.Ring{
// 		Value: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructRing(_v Object) *_ring.Ring {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ring.Ring:
// 			return &_g
// 		case *_ring.Ring:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRing(_o.(Map))
// 	case *Vector:
// 		return _vectorToRing(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ring.Ring] or: Map or Vector"))
// }

GO FUNC container/ring.New from container/ring/ring.go:
func __new(n int) Object {
	_res := _ring.New(n)
	return MakeGoObject(_res)
}

GO FUNC container/ring.__ptrTo_Ring_Do from container/ring/ring.go:
// func __ptrTo_Ring_Do(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC container/ring.__ptrTo_Ring_Len from container/ring/ring.go:
func __ptrTo_Ring_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_container/ring.Ring)Len()", args, 0, 0)
	_res := o.O.(*_ring.Ring).Len()
	return MakeInt(_res)
}

GO FUNC container/ring.__ptrTo_Ring_Link from container/ring/ring.go:
// func __ptrTo_Ring_Link(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_container/ring.Ring)Link()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for s at: /usr/local/go/src/container/ring/ring.go:93:23)
// 	_res := o.O.(*_ring.Ring).Link(s)
// 	return MakeGoObject(_res)
// }

GO FUNC container/ring.__ptrTo_Ring_Move from container/ring/ring.go:
func __ptrTo_Ring_Move(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_container/ring.Ring)Move()", args, 1, 1)
	n := ExtractGoInt("(*_container/ring.Ring)Move()", "n", _argList, 0)
	_res := o.O.(*_ring.Ring).Move(n)
	return MakeGoObject(_res)
}

GO FUNC container/ring.__ptrTo_Ring_Next from container/ring/ring.go:
func __ptrTo_Ring_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_container/ring.Ring)Next()", args, 0, 0)
	_res := o.O.(*_ring.Ring).Next()
	return MakeGoObject(_res)
}

GO FUNC container/ring.__ptrTo_Ring_Prev from container/ring/ring.go:
func __ptrTo_Ring_Prev(o GoObject, args Object) Object {
	CheckGoArity("(*_container/ring.Ring)Prev()", args, 0, 0)
	_res := o.O.(*_ring.Ring).Prev()
	return MakeGoObject(_res)
}

GO FUNC container/ring.__ptrTo_Ring_Unlink from container/ring/ring.go:
func __ptrTo_Ring_Unlink(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_container/ring.Ring)Unlink()", args, 1, 1)
	n := ExtractGoInt("(*_container/ring.Ring)Unlink()", "n", _argList, 0)
	_res := o.O.(*_ring.Ring).Unlink(n)
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ring

import (
	_ring "container/ring"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Ring = GoTypeInfo{Members: GoMembers{
	"Len": __ptrTo_Ring_Len,
	"Move": __ptrTo_Ring_Move,
	"Next": __ptrTo_Ring_Next,
	"Prev": __ptrTo_Ring_Prev,
	"Unlink": __ptrTo_Ring_Unlink,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_ring.Ring)(nil))] = &members_PtrTo_Ring
}

GO TYPE context.CancelFunc from context/context.go:
func ExtractGoObjectCancelFunc(args []Object, index int) *_context.CancelFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _context.CancelFunc:
			return &r
		case *_context.CancelFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[context.CancelFunc]"))
}

// func _ConstructCancelFunc(_v Object) _context.CancelFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _context.CancelFunc:
// 			return _g
// 		case *_context.CancelFunc:
// 			return *_g
// 		}
// 	default:
// 		return _context.CancelFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for CancelFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[context.CancelFunc] or: whatever"))
// }

GO TYPE context.Context from context/context.go:
func ExtractGoObjectContext(args []Object, index int) *_context.Context {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _context.Context:
			return &r
		case *_context.Context:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[context.Context]"))
}

// func _ConstructContext(_v Object) _context.Context {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _context.Context:
// 			return _g
// 		case *_context.Context:
// 			return *_g
// 		}
// 	default:
// 		return _context.Context(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Context))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[context.Context] or: whatever"))
// }

GO FUNC context.Background from context/context.go:
func __background() Object {
	_res := _context.Background()
	return MakeGoObject(_res)
}

GO FUNC context.TODO from context/context.go:
func __tODO() Object {
	_res := _context.TODO()
	return MakeGoObject(_res)
}

GO FUNC context.WithCancel from context/context.go:
func __withCancel(parent _context.Context) Object {
	ctx, cancel := _context.WithCancel(parent)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(ctx))
	_res = _res.Conjoin(MakeGoObject(cancel))
	return _res
}

GO FUNC context.WithDeadline from context/context.go:
// func __withDeadline(parent _context.Context, d ABEND987(genutils.go: imports not yet supported: time.Time)) Object {
// 	_res1, _res2 := _context.WithDeadline(parent, d)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithTimeout from context/context.go:
// func __withTimeout(parent _context.Context, timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _context.WithTimeout(parent, timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC context.WithValue from context/context.go:
// func __withValue(parent _context.Context, key interface {}, val interface {}) Object {
// 	_res := _context.WithValue(parent, key, val)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package context

import (
	_context "context"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO TYPE crypto.Decrypter from crypto/crypto.go:
func ExtractGoObjectDecrypter(args []Object, index int) *_crypto.Decrypter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.Decrypter:
			return &r
		case *_crypto.Decrypter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.Decrypter]"))
}

// func _ConstructDecrypter(_v Object) _crypto.Decrypter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.Decrypter:
// 			return _g
// 		case *_crypto.Decrypter:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.Decrypter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Decrypter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.Decrypter] or: whatever"))
// }

GO TYPE crypto.DecrypterOpts from crypto/crypto.go:
func ExtractGoObjectDecrypterOpts(args []Object, index int) *_crypto.DecrypterOpts {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.DecrypterOpts:
			return &r
		case *_crypto.DecrypterOpts:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.DecrypterOpts]"))
}

// func _ConstructDecrypterOpts(_v Object) _crypto.DecrypterOpts {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.DecrypterOpts:
// 			return _g
// 		case *_crypto.DecrypterOpts:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.DecrypterOpts(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for DecrypterOpts))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.DecrypterOpts] or: whatever"))
// }

GO TYPE crypto.Hash from crypto/crypto.go:
func ExtractGoObjectHash(args []Object, index int) *_crypto.Hash {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.Hash:
			return &r
		case *_crypto.Hash:
			return r
		}
	case Number:
		v := _crypto.Hash(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.Hash]"))
}

func _ConstructHash(_v Object) _crypto.Hash {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _crypto.Hash:
			return _g
		case *_crypto.Hash:
			return *_g
		}
	case Number:
		return _crypto.Hash(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.Hash] or: Number"))
}

GO TYPE crypto.PrivateKey from crypto/crypto.go:
func ExtractGoObjectPrivateKey(args []Object, index int) *_crypto.PrivateKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.PrivateKey:
			return &r
		case *_crypto.PrivateKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.PrivateKey]"))
}

// func _ConstructPrivateKey(_v Object) _crypto.PrivateKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.PrivateKey:
// 			return _g
// 		case *_crypto.PrivateKey:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.PrivateKey(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PrivateKey))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.PrivateKey] or: whatever"))
// }

GO TYPE crypto.PublicKey from crypto/crypto.go:
func ExtractGoObjectPublicKey(args []Object, index int) *_crypto.PublicKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.PublicKey:
			return &r
		case *_crypto.PublicKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.PublicKey]"))
}

// func _ConstructPublicKey(_v Object) _crypto.PublicKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.PublicKey:
// 			return _g
// 		case *_crypto.PublicKey:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.PublicKey(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PublicKey))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.PublicKey] or: whatever"))
// }

GO TYPE crypto.Signer from crypto/crypto.go:
func ExtractGoObjectSigner(args []Object, index int) *_crypto.Signer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.Signer:
			return &r
		case *_crypto.Signer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.Signer]"))
}

// func _ConstructSigner(_v Object) _crypto.Signer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.Signer:
// 			return _g
// 		case *_crypto.Signer:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.Signer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Signer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.Signer] or: whatever"))
// }

GO TYPE crypto.SignerOpts from crypto/crypto.go:
func ExtractGoObjectSignerOpts(args []Object, index int) *_crypto.SignerOpts {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crypto.SignerOpts:
			return &r
		case *_crypto.SignerOpts:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto.SignerOpts]"))
}

// func _ConstructSignerOpts(_v Object) _crypto.SignerOpts {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crypto.SignerOpts:
// 			return _g
// 		case *_crypto.SignerOpts:
// 			return *_g
// 		}
// 	default:
// 		return _crypto.SignerOpts(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for SignerOpts))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crypto.SignerOpts] or: whatever"))
// }

GO FUNC crypto.RegisterHash from crypto/crypto.go:
// func __registerHash(h _crypto.Hash, f func) Object {
// 	_crypto.RegisterHash(h, f)
// 	...ABEND675: TODO...
// }

GO FUNC crypto.__hash_Available from crypto/crypto.go:
func __hash_Available(o GoObject, args Object) Object {
	CheckGoArity("(_crypto.Hash)Available()", args, 0, 0)
	_res := o.O.(_crypto.Hash).Available()
	return MakeBoolean(_res)
}

GO FUNC crypto.__hash_HashFunc from crypto/crypto.go:
func __hash_HashFunc(o GoObject, args Object) Object {
	CheckGoArity("(_crypto.Hash)HashFunc()", args, 0, 0)
	_res := o.O.(_crypto.Hash).HashFunc()
	return MakeGoObject(_res)
}

GO FUNC crypto.__hash_New from crypto/crypto.go:
func __hash_New(o GoObject, args Object) Object {
	CheckGoArity("(_crypto.Hash)New()", args, 0, 0)
	_res := o.O.(_crypto.Hash).New()
	return MakeGoObject(_res)
}

GO FUNC crypto.__hash_Size from crypto/crypto.go:
func __hash_Size(o GoObject, args Object) Object {
	CheckGoArity("(_crypto.Hash)Size()", args, 0, 0)
	_res := o.O.(_crypto.Hash).Size()
	return MakeInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crypto

import (
	_crypto "crypto"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_Hash = GoTypeInfo{Members: GoMembers{
	"Available": __hash_Available,
	"HashFunc": __hash_HashFunc,
	"New": __hash_New,
	"Size": __hash_Size,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_crypto.Hash)(nil)).Elem()] = &members_Hash
}

GO TYPE crypto/aes.KeySizeError from crypto/aes/cipher.go:
func ExtractGoObjectKeySizeError(args []Object, index int) *_aes.KeySizeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _aes.KeySizeError:
			return &r
		case *_aes.KeySizeError:
			return r
		}
	case Int:
		v := _aes.KeySizeError(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/aes.KeySizeError]"))
}

func _ConstructKeySizeError(_v Object) _aes.KeySizeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _aes.KeySizeError:
			return _g
		case *_aes.KeySizeError:
			return *_g
		}
	case Number:
		return _aes.KeySizeError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[aes.KeySizeError] or: Number"))
}

GO FUNC crypto/aes.NewCipher from crypto/aes/cipher.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _aes.NewCipher(key)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/aes.__keySizeError_Error from crypto/aes/cipher.go:
func __keySizeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/aes.KeySizeError)Error()", args, 0, 0)
	_res := o.O.(_aes.KeySizeError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package aes

import (
	_aes "crypto/aes"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_KeySizeError = GoTypeInfo{Members: GoMembers{
	"Error": __keySizeError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_aes.KeySizeError)(nil)).Elem()] = &members_KeySizeError
}

GO TYPE crypto/cipher.AEAD from crypto/cipher/gcm.go:
func ExtractGoObjectAEAD(args []Object, index int) *_cipher.AEAD {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.AEAD:
			return &r
		case *_cipher.AEAD:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.AEAD]"))
}

// func _ConstructAEAD(_v Object) _cipher.AEAD {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.AEAD:
// 			return _g
// 		case *_cipher.AEAD:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.AEAD(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for AEAD))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.AEAD] or: whatever"))
// }

GO TYPE crypto/cipher.Block from crypto/cipher/cipher.go:
func ExtractGoObjectBlock(args []Object, index int) *_cipher.Block {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.Block:
			return &r
		case *_cipher.Block:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.Block]"))
}

// func _ConstructBlock(_v Object) _cipher.Block {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.Block:
// 			return _g
// 		case *_cipher.Block:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.Block(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Block))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.Block] or: whatever"))
// }

GO TYPE crypto/cipher.BlockMode from crypto/cipher/cipher.go:
func ExtractGoObjectBlockMode(args []Object, index int) *_cipher.BlockMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.BlockMode:
			return &r
		case *_cipher.BlockMode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.BlockMode]"))
}

// func _ConstructBlockMode(_v Object) _cipher.BlockMode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.BlockMode:
// 			return _g
// 		case *_cipher.BlockMode:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.BlockMode(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for BlockMode))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.BlockMode] or: whatever"))
// }

GO TYPE crypto/cipher.Stream from crypto/cipher/cipher.go:
func ExtractGoObjectStream(args []Object, index int) *_cipher.Stream {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.Stream:
			return &r
		case *_cipher.Stream:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.Stream]"))
}

// func _ConstructStream(_v Object) _cipher.Stream {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.Stream:
// 			return _g
// 		case *_cipher.Stream:
// 			return *_g
// 		}
// 	default:
// 		return _cipher.Stream(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Stream))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.Stream] or: whatever"))
// }

GO TYPE crypto/cipher.StreamReader from crypto/cipher/io.go:
func ExtractGoObjectStreamReader(args []Object, index int) *_cipher.StreamReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.StreamReader:
			return &r
		case *_cipher.StreamReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.StreamReader]"))
}

// func _mapToStreamReader(o Map) *_cipher.StreamReader {
// 	return &_cipher.StreamReader{}
// }

// func _vectorToStreamReader(o *Vector) *_cipher.StreamReader {
// 	return &_cipher.StreamReader{
// 		S: ABEND048(codegen.go: no conversion from Clojure for crypto/cipher.Stream (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		R: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructStreamReader(_v Object) *_cipher.StreamReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.StreamReader:
// 			return &_g
// 		case *_cipher.StreamReader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStreamReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToStreamReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.StreamReader] or: Map or Vector"))
// }

GO TYPE crypto/cipher.StreamWriter from crypto/cipher/io.go:
func ExtractGoObjectStreamWriter(args []Object, index int) *_cipher.StreamWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cipher.StreamWriter:
			return &r
		case *_cipher.StreamWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/cipher.StreamWriter]"))
}

// func _mapToStreamWriter(o Map) *_cipher.StreamWriter {
// 	return &_cipher.StreamWriter{}
// }

// func _vectorToStreamWriter(o *Vector) *_cipher.StreamWriter {
// 	return &_cipher.StreamWriter{
// 		S: ABEND048(codegen.go: no conversion from Clojure for crypto/cipher.Stream (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		W: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Err: _errors.New(AssertString(o.Nth(2), "").S),
// 	}
// }

// func _ConstructStreamWriter(_v Object) *_cipher.StreamWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cipher.StreamWriter:
// 			return &_g
// 		case *_cipher.StreamWriter:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStreamWriter(_o.(Map))
// 	case *Vector:
// 		return _vectorToStreamWriter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cipher.StreamWriter] or: Map or Vector"))
// }

GO FUNC crypto/cipher.NewCBCDecrypter from crypto/cipher/cbc.go:
// func __newCBCDecrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCDecrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCBCEncrypter from crypto/cipher/cbc.go:
// func __newCBCEncrypter(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCBCEncrypter(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBDecrypter from crypto/cipher/cfb.go:
// func __newCFBDecrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBDecrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCFBEncrypter from crypto/cipher/cfb.go:
// func __newCFBEncrypter(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCFBEncrypter(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewCTR from crypto/cipher/ctr.go:
// func __newCTR(block _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewCTR(block, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.NewGCM from crypto/cipher/gcm.go:
func __newGCM(cipher _cipher.Block) Object {
	_res1, _res2 := _cipher.NewGCM(cipher)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithNonceSize from crypto/cipher/gcm.go:
func __newGCMWithNonceSize(cipher _cipher.Block, size int) Object {
	_res1, _res2 := _cipher.NewGCMWithNonceSize(cipher, size)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewGCMWithTagSize from crypto/cipher/gcm.go:
func __newGCMWithTagSize(cipher _cipher.Block, tagSize int) Object {
	_res1, _res2 := _cipher.NewGCMWithTagSize(cipher, tagSize)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/cipher.NewOFB from crypto/cipher/ofb.go:
// func __newOFB(b _cipher.Block, iv []byte) Object {
// 	_res := _cipher.NewOFB(b, iv)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/cipher.__streamReader_Read from crypto/cipher/io.go:
// func __streamReader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)))}

GO FUNC crypto/cipher.__streamWriter_Close from crypto/cipher/io.go:
func __streamWriter_Close(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/cipher.StreamWriter)Close()", args, 0, 0)
	_res := o.O.(_cipher.StreamWriter).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/cipher.__streamWriter_Write from crypto/cipher/io.go:
// func __streamWriter_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cipher

import (
	_cipher "crypto/cipher"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_StreamWriter = GoTypeInfo{Members: GoMembers{
	"Close": __streamWriter_Close,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_cipher.StreamWriter)(nil)).Elem()] = &members_StreamWriter
}

GO TYPE crypto/des.KeySizeError from crypto/des/cipher.go:
func ExtractGoObjectKeySizeError(args []Object, index int) *_des.KeySizeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _des.KeySizeError:
			return &r
		case *_des.KeySizeError:
			return r
		}
	case Int:
		v := _des.KeySizeError(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/des.KeySizeError]"))
}

func _ConstructKeySizeError(_v Object) _des.KeySizeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _des.KeySizeError:
			return _g
		case *_des.KeySizeError:
			return *_g
		}
	case Number:
		return _des.KeySizeError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[des.KeySizeError] or: Number"))
}

GO FUNC crypto/des.NewCipher from crypto/des/cipher.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewCipher(key)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/des.NewTripleDESCipher from crypto/des/cipher.go:
// func __newTripleDESCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewTripleDESCipher(key)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/des.__keySizeError_Error from crypto/des/cipher.go:
func __keySizeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/des.KeySizeError)Error()", args, 0, 0)
	_res := o.O.(_des.KeySizeError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package des

import (
	_des "crypto/des"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_KeySizeError = GoTypeInfo{Members: GoMembers{
	"Error": __keySizeError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_des.KeySizeError)(nil)).Elem()] = &members_KeySizeError
}

GO FUNC crypto/dsa.GenerateKey from crypto/dsa/dsa.go:
// func __generateKey(priv *_dsa.PrivateKey, rand ABEND987(genutils.go: imports not yet supported: io.Reader))  {
// 	_res := _dsa.GenerateKey(priv, rand)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.GenerateParameters from crypto/dsa/dsa.go:
// func __generateParameters(params *_dsa.Parameters, rand ABEND987(genutils.go: imports not yet supported: io.Reader), sizes _dsa.ParameterSizes)  {
// 	_res := _dsa.GenerateParameters(params, rand, sizes)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/dsa.Sign from crypto/dsa/dsa.go:
// func __sign(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_dsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _dsa.Sign(rand, priv, hash)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/dsa.Verify from crypto/dsa/dsa.go:
// func __verify(pub *_dsa.PublicKey, hash []byte, r *ABEND987(genutils.go: imports not yet supported: big.Int), s *ABEND987(genutils.go: imports not yet supported: big.Int))  {
// 	_res := _dsa.Verify(pub, hash, r, s)
// 	return MakeBoolean(_res)
// }

GO TYPE crypto/ecdsa.PrivateKey from crypto/ecdsa/ecdsa.go:
func ExtractGoObjectPrivateKey(args []Object, index int) *_ecdsa.PrivateKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ecdsa.PrivateKey:
			return &r
		case *_ecdsa.PrivateKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/ecdsa.PrivateKey]"))
}

// func _mapToPrivateKey(o Map) *_ecdsa.PrivateKey {
// 	return &_ecdsa.PrivateKey{}
// }

// func _vectorToPrivateKey(o *Vector) *_ecdsa.PrivateKey {
// 	return &_ecdsa.PrivateKey{
// 		D: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructPrivateKey(_v Object) *_ecdsa.PrivateKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ecdsa.PrivateKey:
// 			return &_g
// 		case *_ecdsa.PrivateKey:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPrivateKey(_o.(Map))
// 	case *Vector:
// 		return _vectorToPrivateKey(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ecdsa.PrivateKey] or: Map or Vector"))
// }

GO TYPE crypto/ecdsa.PublicKey from crypto/ecdsa/ecdsa.go:
func ExtractGoObjectPublicKey(args []Object, index int) *_ecdsa.PublicKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ecdsa.PublicKey:
			return &r
		case *_ecdsa.PublicKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/ecdsa.PublicKey]"))
}

// func _mapToPublicKey(o Map) *_ecdsa.PublicKey {
// 	return &_ecdsa.PublicKey{}
// }

// func _vectorToPublicKey(o *Vector) *_ecdsa.PublicKey {
// 	return &_ecdsa.PublicKey{
// 		X: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Y: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructPublicKey(_v Object) *_ecdsa.PublicKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ecdsa.PublicKey:
// 			return &_g
// 		case *_ecdsa.PublicKey:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPublicKey(_o.(Map))
// 	case *Vector:
// 		return _vectorToPublicKey(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ecdsa.PublicKey] or: Map or Vector"))
// }

GO FUNC crypto/ecdsa.GenerateKey from crypto/ecdsa/ecdsa.go:
// func __generateKey(c ABEND987(genutils.go: imports not yet supported: elliptic.Curve), rand ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _ecdsa.GenerateKey(c, rand)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Sign from crypto/ecdsa/ecdsa.go:
// func __sign(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_ecdsa.PrivateKey, hash []byte) Object {
// 	r, s, err := _ecdsa.Sign(rand, priv, hash)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(r))
// 	_res = _res.Conjoin(MakeGoObject(s))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Verify from crypto/ecdsa/ecdsa.go:
// func __verify(pub *_ecdsa.PublicKey, hash []byte, r *ABEND987(genutils.go: imports not yet supported: big.Int), s *ABEND987(genutils.go: imports not yet supported: big.Int))  {
// 	_res := _ecdsa.Verify(pub, hash, r, s)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/ecdsa.__ptrTo_PrivateKey_Public from crypto/ecdsa/ecdsa.go:
func __ptrTo_PrivateKey_Public(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/ecdsa.PrivateKey)Public()", args, 0, 0)
	_res := o.O.(*_ecdsa.PrivateKey).Public()
	return MakeGoObject(_res)
}

GO FUNC crypto/ecdsa.__ptrTo_PrivateKey_Sign from crypto/ecdsa/ecdsa.go:
// func __ptrTo_PrivateKey_Sign(o GoObject, args Object) Object {
// rand ABEND987(genutils.go: imports not yet supported: io.Reader), digest []byte, opts ABEND987(genutils.go: imports not yet supported: crypto.SignerOpts)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ecdsa

import (
	_ecdsa "crypto/ecdsa"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_PrivateKey = GoTypeInfo{Members: GoMembers{
	"Public": __ptrTo_PrivateKey_Public,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_ecdsa.PrivateKey)(nil))] = &members_PtrTo_PrivateKey
}

GO TYPE crypto/elliptic.Curve from crypto/elliptic/elliptic.go:
func ExtractGoObjectCurve(args []Object, index int) *_elliptic.Curve {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elliptic.Curve:
			return &r
		case *_elliptic.Curve:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/elliptic.Curve]"))
}

// func _ConstructCurve(_v Object) _elliptic.Curve {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elliptic.Curve:
// 			return _g
// 		case *_elliptic.Curve:
// 			return *_g
// 		}
// 	default:
// 		return _elliptic.Curve(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Curve))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elliptic.Curve] or: whatever"))
// }

GO TYPE crypto/elliptic.CurveParams from crypto/elliptic/elliptic.go:
func ExtractGoObjectCurveParams(args []Object, index int) *_elliptic.CurveParams {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elliptic.CurveParams:
			return &r
		case *_elliptic.CurveParams:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/elliptic.CurveParams]"))
}

// func _mapToCurveParams(o Map) *_elliptic.CurveParams {
// 	return &_elliptic.CurveParams{}
// }

// func _vectorToCurveParams(o *Vector) *_elliptic.CurveParams {
// 	return &_elliptic.CurveParams{
// 		P: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		N: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		B: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Gx: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Gy: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		BitSize: AssertInt(o.Nth(5), "").I,
// 		Name: AssertString(o.Nth(6), "").S,
// 	}
// }

// func _ConstructCurveParams(_v Object) *_elliptic.CurveParams {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elliptic.CurveParams:
// 			return &_g
// 		case *_elliptic.CurveParams:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCurveParams(_o.(Map))
// 	case *Vector:
// 		return _vectorToCurveParams(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elliptic.CurveParams] or: Map or Vector"))
// }

GO FUNC crypto/elliptic.GenerateKey from crypto/elliptic/elliptic.go:
// func __generateKey(curve _elliptic.Curve, rand ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	priv, x, y, err := _elliptic.GenerateKey(curve, rand)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range priv {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/elliptic.Marshal from crypto/elliptic/elliptic.go:
// func __marshal(curve _elliptic.Curve, x *ABEND987(genutils.go: imports not yet supported: big.Int), y *ABEND987(genutils.go: imports not yet supported: big.Int)) Object {
// 	_res := _elliptic.Marshal(curve, x, y)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/elliptic.P224 from crypto/elliptic/p224.go:
func __p224() Object {
	_res := _elliptic.P224()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P256 from crypto/elliptic/elliptic.go:
func __p256() Object {
	_res := _elliptic.P256()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P384 from crypto/elliptic/elliptic.go:
func __p384() Object {
	_res := _elliptic.P384()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.P521 from crypto/elliptic/elliptic.go:
func __p521() Object {
	_res := _elliptic.P521()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.Unmarshal from crypto/elliptic/elliptic.go:
// func __unmarshal(curve _elliptic.Curve, data []byte) Object {
// 	x, y := _elliptic.Unmarshal(curve, data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(x))
// 	_res = _res.Conjoin(MakeGoObject(y))
// 	return _res
// }

GO FUNC crypto/elliptic.__ptrTo_CurveParams_Add from crypto/elliptic/elliptic.go:
// func __ptrTo_CurveParams_Add(o GoObject, args Object) Object {
// x1 *ABEND987(genutils.go: imports not yet supported: big.Int), y1 *ABEND987(genutils.go: imports not yet supported: big.Int), x2 *ABEND987(genutils.go: imports not yet supported: big.Int), y2 *ABEND987(genutils.go: imports not yet supported: big.Int)}

GO FUNC crypto/elliptic.__ptrTo_CurveParams_Double from crypto/elliptic/elliptic.go:
// func __ptrTo_CurveParams_Double(o GoObject, args Object) Object {
// x1 *ABEND987(genutils.go: imports not yet supported: big.Int), y1 *ABEND987(genutils.go: imports not yet supported: big.Int)}

GO FUNC crypto/elliptic.__ptrTo_CurveParams_IsOnCurve from crypto/elliptic/elliptic.go:
// func __ptrTo_CurveParams_IsOnCurve(o GoObject, args Object) Object {
// x *ABEND987(genutils.go: imports not yet supported: big.Int), y *ABEND987(genutils.go: imports not yet supported: big.Int)}

GO FUNC crypto/elliptic.__ptrTo_CurveParams_Params from crypto/elliptic/elliptic.go:
func __ptrTo_CurveParams_Params(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/elliptic.CurveParams)Params()", args, 0, 0)
	_res := o.O.(*_elliptic.CurveParams).Params()
	return MakeGoObject(_res)
}

GO FUNC crypto/elliptic.__ptrTo_CurveParams_ScalarBaseMult from crypto/elliptic/elliptic.go:
// func __ptrTo_CurveParams_ScalarBaseMult(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(k)))}

GO FUNC crypto/elliptic.__ptrTo_CurveParams_ScalarMult from crypto/elliptic/elliptic.go:
// func __ptrTo_CurveParams_ScalarMult(o GoObject, args Object) Object {
// Bx *ABEND987(genutils.go: imports not yet supported: big.Int), By *ABEND987(genutils.go: imports not yet supported: big.Int), k []byte}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elliptic

import (
	_elliptic "crypto/elliptic"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_CurveParams = GoTypeInfo{Members: GoMembers{
	"Params": __ptrTo_CurveParams_Params,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_elliptic.CurveParams)(nil))] = &members_PtrTo_CurveParams
}

GO FUNC crypto/hmac.Equal from crypto/hmac/hmac.go:
// func __equal(mac1 []byte, mac2 []byte)  {
// 	_res := _hmac.Equal(mac1, mac2)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/hmac.New from crypto/hmac/hmac.go:
// func __new(h func, key []byte) Object {
// 	_res := _hmac.New(h, key)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/md5.New from crypto/md5/md5.go:
func __new() Object {
	_res := _md5.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/md5.Sum from crypto/md5/md5.go:
// func __sum(data []byte) Object {
// 	_res := _md5.Sum(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package md5

import (
	_md5 "crypto/md5"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO FUNC crypto/rand.Int from crypto/rand/util.go:
// func __int(rand ABEND987(genutils.go: imports not yet supported: io.Reader), max *ABEND987(genutils.go: imports not yet supported: big.Int)) Object {
// 	n, err := _rand.Int(rand, max)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Prime from crypto/rand/util.go:
// func __prime(rand ABEND987(genutils.go: imports not yet supported: io.Reader), bits int) Object {
// 	p, err := _rand.Prime(rand, bits)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Read from crypto/rand/rand.go:
// func __read(b []byte) Object {
// 	n, err := _rand.Read(b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO TYPE crypto/rc4.Cipher from crypto/rc4/rc4.go:
func ExtractGoObjectCipher(args []Object, index int) *_rc4.Cipher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rc4.Cipher:
			return &r
		case *_rc4.Cipher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rc4.Cipher]"))
}

func _mapToCipher(o Map) *_rc4.Cipher {
	return &_rc4.Cipher{}
}

func _vectorToCipher(o *Vector) *_rc4.Cipher {
	return &_rc4.Cipher{}
}

func _ConstructCipher(_v Object) *_rc4.Cipher {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rc4.Cipher:
			return &_g
		case *_rc4.Cipher:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCipher(_o.(Map))
	case *Vector:
		return _vectorToCipher(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rc4.Cipher] or: Map or Vector"))
}

GO TYPE crypto/rc4.KeySizeError from crypto/rc4/rc4.go:
func ExtractGoObjectKeySizeError(args []Object, index int) *_rc4.KeySizeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rc4.KeySizeError:
			return &r
		case *_rc4.KeySizeError:
			return r
		}
	case Int:
		v := _rc4.KeySizeError(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rc4.KeySizeError]"))
}

func _ConstructKeySizeError(_v Object) _rc4.KeySizeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rc4.KeySizeError:
			return _g
		case *_rc4.KeySizeError:
			return *_g
		}
	case Number:
		return _rc4.KeySizeError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rc4.KeySizeError] or: Number"))
}

GO FUNC crypto/rc4.NewCipher from crypto/rc4/rc4.go:
// func __newCipher(key []byte) Object {
// 	_res1, _res2 := _rc4.NewCipher(key)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rc4.__keySizeError_Error from crypto/rc4/rc4.go:
func __keySizeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/rc4.KeySizeError)Error()", args, 0, 0)
	_res := o.O.(_rc4.KeySizeError).Error()
	return MakeString(_res)
}

GO FUNC crypto/rc4.__ptrTo_Cipher_Reset from crypto/rc4/rc4.go:
// func __ptrTo_Cipher_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC crypto/rc4.__ptrTo_Cipher_XORKeyStream from crypto/rc4/rc4.go:
// func __ptrTo_Cipher_XORKeyStream(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rc4

import (
	_rc4 "crypto/rc4"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_KeySizeError = GoTypeInfo{Members: GoMembers{
	"Error": __keySizeError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_rc4.KeySizeError)(nil)).Elem()] = &members_KeySizeError
}

GO TYPE crypto/rsa.CRTValue from crypto/rsa/rsa.go:
func ExtractGoObjectCRTValue(args []Object, index int) *_rsa.CRTValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.CRTValue:
			return &r
		case *_rsa.CRTValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.CRTValue]"))
}

// func _mapToCRTValue(o Map) *_rsa.CRTValue {
// 	return &_rsa.CRTValue{}
// }

// func _vectorToCRTValue(o *Vector) *_rsa.CRTValue {
// 	return &_rsa.CRTValue{
// 		Exp: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Coeff: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		R: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCRTValue(_v Object) *_rsa.CRTValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.CRTValue:
// 			return &_g
// 		case *_rsa.CRTValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCRTValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToCRTValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.CRTValue] or: Map or Vector"))
// }

GO TYPE crypto/rsa.OAEPOptions from crypto/rsa/rsa.go:
func ExtractGoObjectOAEPOptions(args []Object, index int) *_rsa.OAEPOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.OAEPOptions:
			return &r
		case *_rsa.OAEPOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.OAEPOptions]"))
}

// func _mapToOAEPOptions(o Map) *_rsa.OAEPOptions {
// 	return &_rsa.OAEPOptions{}
// }

// func _vectorToOAEPOptions(o *Vector) *_rsa.OAEPOptions {
// 	return &_rsa.OAEPOptions{
// 		Hash: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Label: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructOAEPOptions(_v Object) *_rsa.OAEPOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.OAEPOptions:
// 			return &_g
// 		case *_rsa.OAEPOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOAEPOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToOAEPOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.OAEPOptions] or: Map or Vector"))
// }

GO TYPE crypto/rsa.PKCS1v15DecryptOptions from crypto/rsa/pkcs1v15.go:
func ExtractGoObjectPKCS1v15DecryptOptions(args []Object, index int) *_rsa.PKCS1v15DecryptOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.PKCS1v15DecryptOptions:
			return &r
		case *_rsa.PKCS1v15DecryptOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.PKCS1v15DecryptOptions]"))
}

func _mapToPKCS1v15DecryptOptions(o Map) *_rsa.PKCS1v15DecryptOptions {
	return &_rsa.PKCS1v15DecryptOptions{}
}

func _vectorToPKCS1v15DecryptOptions(o *Vector) *_rsa.PKCS1v15DecryptOptions {
	return &_rsa.PKCS1v15DecryptOptions{
		SessionKeyLen: AssertInt(o.Nth(0), "").I,
	}
}

func _ConstructPKCS1v15DecryptOptions(_v Object) *_rsa.PKCS1v15DecryptOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rsa.PKCS1v15DecryptOptions:
			return &_g
		case *_rsa.PKCS1v15DecryptOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPKCS1v15DecryptOptions(_o.(Map))
	case *Vector:
		return _vectorToPKCS1v15DecryptOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.PKCS1v15DecryptOptions] or: Map or Vector"))
}

GO TYPE crypto/rsa.PSSOptions from crypto/rsa/pss.go:
func ExtractGoObjectPSSOptions(args []Object, index int) *_rsa.PSSOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.PSSOptions:
			return &r
		case *_rsa.PSSOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.PSSOptions]"))
}

// func _mapToPSSOptions(o Map) *_rsa.PSSOptions {
// 	return &_rsa.PSSOptions{}
// }

// func _vectorToPSSOptions(o *Vector) *_rsa.PSSOptions {
// 	return &_rsa.PSSOptions{
// 		SaltLength: AssertInt(o.Nth(0), "").I,
// 		Hash: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructPSSOptions(_v Object) *_rsa.PSSOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.PSSOptions:
// 			return &_g
// 		case *_rsa.PSSOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPSSOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToPSSOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.PSSOptions] or: Map or Vector"))
// }

GO TYPE crypto/rsa.PrecomputedValues from crypto/rsa/rsa.go:
func ExtractGoObjectPrecomputedValues(args []Object, index int) *_rsa.PrecomputedValues {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.PrecomputedValues:
			return &r
		case *_rsa.PrecomputedValues:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.PrecomputedValues]"))
}

// func _mapToPrecomputedValues(o Map) *_rsa.PrecomputedValues {
// 	return &_rsa.PrecomputedValues{}
// }

// func _vectorToPrecomputedValues(o *Vector) *_rsa.PrecomputedValues {
// 	return &_rsa.PrecomputedValues{
// 		Dp: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Dq: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Qinv: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		CRTValues: ABEND048(codegen.go: no conversion from Clojure for []crypto/rsa.CRTValue (crypto/rsa.CRTValue)),
// 	}
// }

// func _ConstructPrecomputedValues(_v Object) *_rsa.PrecomputedValues {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.PrecomputedValues:
// 			return &_g
// 		case *_rsa.PrecomputedValues:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPrecomputedValues(_o.(Map))
// 	case *Vector:
// 		return _vectorToPrecomputedValues(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.PrecomputedValues] or: Map or Vector"))
// }

GO TYPE crypto/rsa.PrivateKey from crypto/rsa/rsa.go:
func ExtractGoObjectPrivateKey(args []Object, index int) *_rsa.PrivateKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.PrivateKey:
			return &r
		case *_rsa.PrivateKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.PrivateKey]"))
}

// func _mapToPrivateKey(o Map) *_rsa.PrivateKey {
// 	return &_rsa.PrivateKey{}
// }

// func _vectorToPrivateKey(o *Vector) *_rsa.PrivateKey {
// 	return &_rsa.PrivateKey{
// 		D: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Primes: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Precomputed: ABEND048(codegen.go: no conversion from Clojure for crypto/rsa.PrecomputedValues (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructPrivateKey(_v Object) *_rsa.PrivateKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.PrivateKey:
// 			return &_g
// 		case *_rsa.PrivateKey:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPrivateKey(_o.(Map))
// 	case *Vector:
// 		return _vectorToPrivateKey(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.PrivateKey] or: Map or Vector"))
// }

GO TYPE crypto/rsa.PublicKey from crypto/rsa/rsa.go:
func ExtractGoObjectPublicKey(args []Object, index int) *_rsa.PublicKey {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rsa.PublicKey:
			return &r
		case *_rsa.PublicKey:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/rsa.PublicKey]"))
}

// func _mapToPublicKey(o Map) *_rsa.PublicKey {
// 	return &_rsa.PublicKey{}
// }

// func _vectorToPublicKey(o *Vector) *_rsa.PublicKey {
// 	return &_rsa.PublicKey{
// 		N: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		E: AssertInt(o.Nth(1), "").I,
// 	}
// }

// func _ConstructPublicKey(_v Object) *_rsa.PublicKey {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rsa.PublicKey:
// 			return &_g
// 		case *_rsa.PublicKey:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPublicKey(_o.(Map))
// 	case *Vector:
// 		return _vectorToPublicKey(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rsa.PublicKey] or: Map or Vector"))
// }

GO FUNC crypto/rsa.DecryptOAEP from crypto/rsa/rsa.go:
// func __decryptOAEP(hash ABEND987(genutils.go: imports not yet supported: hash.Hash), random ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __decryptPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte) Object {
// 	_res1, _res2 := _rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15SessionKey from crypto/rsa/pkcs1v15.go:
// func __decryptPKCS1v15SessionKey(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, ciphertext []byte, key []byte)  {
// 	_res := _rsa.DecryptPKCS1v15SessionKey(rand, priv, ciphertext, key)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.EncryptOAEP from crypto/rsa/rsa.go:
// func __encryptOAEP(hash ABEND987(genutils.go: imports not yet supported: hash.Hash), random ABEND987(genutils.go: imports not yet supported: io.Reader), pub *_rsa.PublicKey, msg []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.EncryptPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __encryptPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), pub *_rsa.PublicKey, msg []byte) Object {
// 	_res1, _res2 := _rsa.EncryptPKCS1v15(rand, pub, msg)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateKey from crypto/rsa/rsa.go:
// func __generateKey(random ABEND987(genutils.go: imports not yet supported: io.Reader), bits int) Object {
// 	_res1, _res2 := _rsa.GenerateKey(random, bits)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateMultiPrimeKey from crypto/rsa/rsa.go:
// func __generateMultiPrimeKey(random ABEND987(genutils.go: imports not yet supported: io.Reader), nprimes int, bits int) Object {
// 	_res1, _res2 := _rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __signPKCS1v15(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte) Object {
// 	_res1, _res2 := _rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPSS from crypto/rsa/pss.go:
// func __signPSS(rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv *_rsa.PrivateKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, opts *_rsa.PSSOptions) Object {
// 	_res1, _res2 := _rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.VerifyPKCS1v15 from crypto/rsa/pkcs1v15.go:
// func __verifyPKCS1v15(pub *_rsa.PublicKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, sig []byte)  {
// 	_res := _rsa.VerifyPKCS1v15(pub, hash, hashed, sig)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.VerifyPSS from crypto/rsa/pss.go:
// func __verifyPSS(pub *_rsa.PublicKey, hash ABEND987(genutils.go: imports not yet supported: crypto.Hash), hashed []byte, sig []byte, opts *_rsa.PSSOptions)  {
// 	_res := _rsa.VerifyPSS(pub, hash, hashed, sig, opts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/rsa.__ptrTo_PSSOptions_HashFunc from crypto/rsa/pss.go:
func __ptrTo_PSSOptions_HashFunc(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/rsa.PSSOptions)HashFunc()", args, 0, 0)
	_res := o.O.(*_rsa.PSSOptions).HashFunc()
	return MakeGoObject(_res)
}

GO FUNC crypto/rsa.__ptrTo_PrivateKey_Decrypt from crypto/rsa/rsa.go:
// func __ptrTo_PrivateKey_Decrypt(o GoObject, args Object) Object {
// rand ABEND987(genutils.go: imports not yet supported: io.Reader), ciphertext []byte, opts ABEND987(genutils.go: imports not yet supported: crypto.DecrypterOpts)}

GO FUNC crypto/rsa.__ptrTo_PrivateKey_Precompute from crypto/rsa/rsa.go:
// func __ptrTo_PrivateKey_Precompute(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC crypto/rsa.__ptrTo_PrivateKey_Public from crypto/rsa/rsa.go:
func __ptrTo_PrivateKey_Public(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/rsa.PrivateKey)Public()", args, 0, 0)
	_res := o.O.(*_rsa.PrivateKey).Public()
	return MakeGoObject(_res)
}

GO FUNC crypto/rsa.__ptrTo_PrivateKey_Sign from crypto/rsa/rsa.go:
// func __ptrTo_PrivateKey_Sign(o GoObject, args Object) Object {
// rand ABEND987(genutils.go: imports not yet supported: io.Reader), digest []byte, opts ABEND987(genutils.go: imports not yet supported: crypto.SignerOpts)}

GO FUNC crypto/rsa.__ptrTo_PrivateKey_Validate from crypto/rsa/rsa.go:
func __ptrTo_PrivateKey_Validate(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/rsa.PrivateKey)Validate()", args, 0, 0)
	_res := o.O.(*_rsa.PrivateKey).Validate()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/rsa.__ptrTo_PublicKey_Size from crypto/rsa/rsa.go:
func __ptrTo_PublicKey_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/rsa.PublicKey)Size()", args, 0, 0)
	_res := o.O.(*_rsa.PublicKey).Size()
	return MakeInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rsa

import (
	_rsa "crypto/rsa"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_PSSOptions = GoTypeInfo{Members: GoMembers{
	"HashFunc": __ptrTo_PSSOptions_HashFunc,
}}

var members_PtrTo_PrivateKey = GoTypeInfo{Members: GoMembers{
	"Public": __ptrTo_PrivateKey_Public,
	"Validate": __ptrTo_PrivateKey_Validate,
}}

var members_PtrTo_PublicKey = GoTypeInfo{Members: GoMembers{
	"Size": __ptrTo_PublicKey_Size,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_rsa.PSSOptions)(nil))] = &members_PtrTo_PSSOptions
	GoTypes[_reflect.TypeOf((*_rsa.PrivateKey)(nil))] = &members_PtrTo_PrivateKey
	GoTypes[_reflect.TypeOf((*_rsa.PublicKey)(nil))] = &members_PtrTo_PublicKey
}

GO FUNC crypto/sha1.New from crypto/sha1/sha1.go:
func __new() Object {
	_res := _sha1.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha1.Sum from crypto/sha1/sha1.go:
// func __sum(data []byte) Object {
// 	_res := _sha1.Sum(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha1

import (
	_sha1 "crypto/sha1"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO FUNC crypto/sha256.New from crypto/sha256/sha256.go:
func __new() Object {
	_res := _sha256.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.New224 from crypto/sha256/sha256.go:
func __new224() Object {
	_res := _sha256.New224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha256.Sum224 from crypto/sha256/sha256.go:
// func __sum224(data []byte) Object {
// 	_res := _sha256.Sum224(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha256.Sum256 from crypto/sha256/sha256.go:
// func __sum256(data []byte) Object {
// 	_res := _sha256.Sum256(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha256

import (
	_sha256 "crypto/sha256"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO FUNC crypto/sha512.New from crypto/sha512/sha512.go:
func __new() Object {
	_res := _sha512.New()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New384 from crypto/sha512/sha512.go:
func __new384() Object {
	_res := _sha512.New384()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_224 from crypto/sha512/sha512.go:
func __new512_224() Object {
	_res := _sha512.New512_224()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.New512_256 from crypto/sha512/sha512.go:
func __new512_256() Object {
	_res := _sha512.New512_256()
	return MakeGoObject(_res)
}

GO FUNC crypto/sha512.Sum384 from crypto/sha512/sha512.go:
// func __sum384(data []byte) Object {
// 	_res := _sha512.Sum384(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512 from crypto/sha512/sha512.go:
// func __sum512(data []byte) Object {
// 	_res := _sha512.Sum512(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_224 from crypto/sha512/sha512.go:
// func __sum512_224(data []byte) Object {
// 	_res := _sha512.Sum512_224(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/sha512.Sum512_256 from crypto/sha512/sha512.go:
// func __sum512_256(data []byte) Object {
// 	_res := _sha512.Sum512_256(data)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sha512

import (
	_sha512 "crypto/sha512"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO FUNC crypto/subtle.ConstantTimeCompare from crypto/subtle/constant_time.go:
// func __constantTimeCompare(x []byte, y []byte)  {
// 	_res := _subtle.ConstantTimeCompare(x, y)
// 	return MakeInt(_res)
// }

GO FUNC crypto/subtle.ConstantTimeCopy from crypto/subtle/constant_time.go:
// func __constantTimeCopy(v int, x []byte, y []byte) Object {
// 	_subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package subtle

import (
)

func init() {
}

GO TYPE crypto/tls.Certificate from crypto/tls/common.go:
func ExtractGoObjectCertificate(args []Object, index int) *_tls.Certificate {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Certificate:
			return &r
		case *_tls.Certificate:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Certificate]"))
}

// func _mapToCertificate(o Map) *_tls.Certificate {
// 	return &_tls.Certificate{}
// }

// func _vectorToCertificate(o *Vector) *_tls.Certificate {
// 	return &_tls.Certificate{
// 		Certificate: ABEND048(codegen.go: no conversion from Clojure for [][]byte ([]byte)),
// 		PrivateKey: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		OCSPStaple: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		SignedCertificateTimestamps: ABEND048(codegen.go: no conversion from Clojure for [][]byte ([]byte)),
// 		Leaf: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCertificate(_v Object) *_tls.Certificate {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.Certificate:
// 			return &_g
// 		case *_tls.Certificate:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificate(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificate(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Certificate] or: Map or Vector"))
// }

GO TYPE crypto/tls.CertificateRequestInfo from crypto/tls/common.go:
func ExtractGoObjectCertificateRequestInfo(args []Object, index int) *_tls.CertificateRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.CertificateRequestInfo:
			return &r
		case *_tls.CertificateRequestInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.CertificateRequestInfo]"))
}

// func _mapToCertificateRequestInfo(o Map) *_tls.CertificateRequestInfo {
// 	return &_tls.CertificateRequestInfo{}
// }

// func _vectorToCertificateRequestInfo(o *Vector) *_tls.CertificateRequestInfo {
// 	return &_tls.CertificateRequestInfo{
// 		AcceptableCAs: ABEND048(codegen.go: no conversion from Clojure for [][]byte ([]byte)),
// 		SignatureSchemes: ABEND048(codegen.go: no conversion from Clojure for []crypto/tls.SignatureScheme (crypto/tls.SignatureScheme)),
// 	}
// }

// func _ConstructCertificateRequestInfo(_v Object) *_tls.CertificateRequestInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.CertificateRequestInfo:
// 			return &_g
// 		case *_tls.CertificateRequestInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificateRequestInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificateRequestInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.CertificateRequestInfo] or: Map or Vector"))
// }

GO TYPE crypto/tls.ClientAuthType from crypto/tls/common.go:
func ExtractGoObjectClientAuthType(args []Object, index int) *_tls.ClientAuthType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientAuthType:
			return &r
		case *_tls.ClientAuthType:
			return r
		}
	case Int:
		v := _tls.ClientAuthType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientAuthType]"))
}

func _ConstructClientAuthType(_v Object) _tls.ClientAuthType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ClientAuthType:
			return _g
		case *_tls.ClientAuthType:
			return *_g
		}
	case Number:
		return _tls.ClientAuthType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientAuthType] or: Number"))
}

GO TYPE crypto/tls.ClientHelloInfo from crypto/tls/common.go:
func ExtractGoObjectClientHelloInfo(args []Object, index int) *_tls.ClientHelloInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientHelloInfo:
			return &r
		case *_tls.ClientHelloInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientHelloInfo]"))
}

// func _mapToClientHelloInfo(o Map) *_tls.ClientHelloInfo {
// 	return &_tls.ClientHelloInfo{}
// }

// func _vectorToClientHelloInfo(o *Vector) *_tls.ClientHelloInfo {
// 	return &_tls.ClientHelloInfo{
// 		CipherSuites: ABEND048(codegen.go: no conversion from Clojure for []uint16 (uint16)),
// 		ServerName: AssertString(o.Nth(1), "").S,
// 		SupportedCurves: ABEND048(codegen.go: no conversion from Clojure for []crypto/tls.CurveID (crypto/tls.CurveID)),
// 		SupportedPoints: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		SignatureSchemes: ABEND048(codegen.go: no conversion from Clojure for []crypto/tls.SignatureScheme (crypto/tls.SignatureScheme)),
// 		SupportedProtos: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SupportedVersions: ABEND048(codegen.go: no conversion from Clojure for []uint16 (uint16)),
// 		Conn: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClientHelloInfo(_v Object) *_tls.ClientHelloInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.ClientHelloInfo:
// 			return &_g
// 		case *_tls.ClientHelloInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClientHelloInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToClientHelloInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientHelloInfo] or: Map or Vector"))
// }

GO TYPE crypto/tls.ClientSessionCache from crypto/tls/common.go:
func ExtractGoObjectClientSessionCache(args []Object, index int) *_tls.ClientSessionCache {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientSessionCache:
			return &r
		case *_tls.ClientSessionCache:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientSessionCache]"))
}

// func _ConstructClientSessionCache(_v Object) _tls.ClientSessionCache {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.ClientSessionCache:
// 			return _g
// 		case *_tls.ClientSessionCache:
// 			return *_g
// 		}
// 	default:
// 		return _tls.ClientSessionCache(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ClientSessionCache))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientSessionCache] or: whatever"))
// }

GO TYPE crypto/tls.ClientSessionState from crypto/tls/common.go:
func ExtractGoObjectClientSessionState(args []Object, index int) *_tls.ClientSessionState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ClientSessionState:
			return &r
		case *_tls.ClientSessionState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ClientSessionState]"))
}

func _mapToClientSessionState(o Map) *_tls.ClientSessionState {
	return &_tls.ClientSessionState{}
}

func _vectorToClientSessionState(o *Vector) *_tls.ClientSessionState {
	return &_tls.ClientSessionState{}
}

func _ConstructClientSessionState(_v Object) *_tls.ClientSessionState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.ClientSessionState:
			return &_g
		case *_tls.ClientSessionState:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientSessionState(_o.(Map))
	case *Vector:
		return _vectorToClientSessionState(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ClientSessionState] or: Map or Vector"))
}

GO TYPE crypto/tls.Config from crypto/tls/common.go:
func ExtractGoObjectConfig(args []Object, index int) *_tls.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Config:
			return &r
		case *_tls.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Config]"))
}

// func _mapToConfig(o Map) *_tls.Config {
// 	return &_tls.Config{}
// }

// func _vectorToConfig(o *Vector) *_tls.Config {
// 	return &_tls.Config{
// 		Rand: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Time: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Certificates: ABEND048(codegen.go: no conversion from Clojure for []crypto/tls.Certificate (crypto/tls.Certificate)),
// 		NameToCertificate: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		GetCertificate: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		GetClientCertificate: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		GetConfigForClient: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		VerifyPeerCertificate: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		RootCAs: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		NextProtos: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ServerName: AssertString(o.Nth(10), "").S,
// 		ClientAuth: _tls.ClientAuthType(AssertInt(o.Nth(11), "").I),
// 		ClientCAs: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		InsecureSkipVerify: ToBool(o.Nth(13)),
// 		CipherSuites: ABEND048(codegen.go: no conversion from Clojure for []uint16 (uint16)),
// 		PreferServerCipherSuites: ToBool(o.Nth(15)),
// 		SessionTicketsDisabled: ToBool(o.Nth(16)),
// 		SessionTicketKey: ABEND048(codegen.go: no conversion from Clojure for [32]byte (byte)),
// 		ClientSessionCache: ABEND048(codegen.go: no conversion from Clojure for crypto/tls.ClientSessionCache (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		MinVersion: uint16(AssertInt(o.Nth(19), "").I),
// 		MaxVersion: uint16(AssertInt(o.Nth(20), "").I),
// 		CurvePreferences: ABEND048(codegen.go: no conversion from Clojure for []crypto/tls.CurveID (crypto/tls.CurveID)),
// 		DynamicRecordSizingDisabled: ToBool(o.Nth(22)),
// 		Renegotiation: _tls.RenegotiationSupport(AssertInt(o.Nth(23), "").I),
// 		KeyLogWriter: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructConfig(_v Object) *_tls.Config {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.Config:
// 			return &_g
// 		case *_tls.Config:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Config] or: Map or Vector"))
// }

GO TYPE crypto/tls.Conn from crypto/tls/conn.go:
func ExtractGoObjectConn(args []Object, index int) *_tls.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.Conn:
			return &r
		case *_tls.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.Conn]"))
}

func _mapToConn(o Map) *_tls.Conn {
	return &_tls.Conn{}
}

func _vectorToConn(o *Vector) *_tls.Conn {
	return &_tls.Conn{}
}

func _ConstructConn(_v Object) *_tls.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.Conn:
			return &_g
		case *_tls.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.Conn] or: Map or Vector"))
}

GO TYPE crypto/tls.ConnectionState from crypto/tls/common.go:
func ExtractGoObjectConnectionState(args []Object, index int) *_tls.ConnectionState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.ConnectionState:
			return &r
		case *_tls.ConnectionState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.ConnectionState]"))
}

// func _mapToConnectionState(o Map) *_tls.ConnectionState {
// 	return &_tls.ConnectionState{}
// }

// func _vectorToConnectionState(o *Vector) *_tls.ConnectionState {
// 	return &_tls.ConnectionState{
// 		Version: uint16(AssertInt(o.Nth(0), "").I),
// 		HandshakeComplete: ToBool(o.Nth(1)),
// 		DidResume: ToBool(o.Nth(2)),
// 		CipherSuite: uint16(AssertInt(o.Nth(3), "").I),
// 		NegotiatedProtocol: AssertString(o.Nth(4), "").S,
// 		NegotiatedProtocolIsMutual: ToBool(o.Nth(5)),
// 		ServerName: AssertString(o.Nth(6), "").S,
// 		PeerCertificates: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		VerifiedChains: [][]*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		SignedCertificateTimestamps: ABEND048(codegen.go: no conversion from Clojure for [][]byte ([]byte)),
// 		OCSPResponse: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		TLSUnique: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructConnectionState(_v Object) *_tls.ConnectionState {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.ConnectionState:
// 			return &_g
// 		case *_tls.ConnectionState:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToConnectionState(_o.(Map))
// 	case *Vector:
// 		return _vectorToConnectionState(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.ConnectionState] or: Map or Vector"))
// }

GO TYPE crypto/tls.CurveID from crypto/tls/common.go:
func ExtractGoObjectCurveID(args []Object, index int) *_tls.CurveID {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.CurveID:
			return &r
		case *_tls.CurveID:
			return r
		}
	case Int:
		v := _tls.CurveID(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.CurveID]"))
}

func _ConstructCurveID(_v Object) _tls.CurveID {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.CurveID:
			return _g
		case *_tls.CurveID:
			return *_g
		}
	case Number:
		return _tls.CurveID(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.CurveID] or: Number"))
}

GO TYPE crypto/tls.RecordHeaderError from crypto/tls/conn.go:
func ExtractGoObjectRecordHeaderError(args []Object, index int) *_tls.RecordHeaderError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.RecordHeaderError:
			return &r
		case *_tls.RecordHeaderError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.RecordHeaderError]"))
}

// func _mapToRecordHeaderError(o Map) *_tls.RecordHeaderError {
// 	return &_tls.RecordHeaderError{}
// }

// func _vectorToRecordHeaderError(o *Vector) *_tls.RecordHeaderError {
// 	return &_tls.RecordHeaderError{
// 		Msg: AssertString(o.Nth(0), "").S,
// 		RecordHeader: ABEND048(codegen.go: no conversion from Clojure for [5]byte (byte)),
// 		Conn: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructRecordHeaderError(_v Object) *_tls.RecordHeaderError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _tls.RecordHeaderError:
// 			return &_g
// 		case *_tls.RecordHeaderError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRecordHeaderError(_o.(Map))
// 	case *Vector:
// 		return _vectorToRecordHeaderError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.RecordHeaderError] or: Map or Vector"))
// }

GO TYPE crypto/tls.RenegotiationSupport from crypto/tls/common.go:
func ExtractGoObjectRenegotiationSupport(args []Object, index int) *_tls.RenegotiationSupport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.RenegotiationSupport:
			return &r
		case *_tls.RenegotiationSupport:
			return r
		}
	case Int:
		v := _tls.RenegotiationSupport(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.RenegotiationSupport]"))
}

func _ConstructRenegotiationSupport(_v Object) _tls.RenegotiationSupport {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.RenegotiationSupport:
			return _g
		case *_tls.RenegotiationSupport:
			return *_g
		}
	case Number:
		return _tls.RenegotiationSupport(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.RenegotiationSupport] or: Number"))
}

GO TYPE crypto/tls.SignatureScheme from crypto/tls/common.go:
func ExtractGoObjectSignatureScheme(args []Object, index int) *_tls.SignatureScheme {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tls.SignatureScheme:
			return &r
		case *_tls.SignatureScheme:
			return r
		}
	case Int:
		v := _tls.SignatureScheme(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/tls.SignatureScheme]"))
}

func _ConstructSignatureScheme(_v Object) _tls.SignatureScheme {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tls.SignatureScheme:
			return _g
		case *_tls.SignatureScheme:
			return *_g
		}
	case Number:
		return _tls.SignatureScheme(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tls.SignatureScheme] or: Number"))
}

GO FUNC crypto/tls.Client from crypto/tls/tls.go:
// func __client(conn ABEND987(genutils.go: imports not yet supported: net.Conn), config *_tls.Config) Object {
// 	_res := _tls.Client(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Dial from crypto/tls/tls.go:
func __dial(network string, addr string, config *_tls.Config) Object {
	_res1, _res2 := _tls.Dial(network, addr, config)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.DialWithDialer from crypto/tls/tls.go:
// func __dialWithDialer(dialer *ABEND987(genutils.go: imports not yet supported: net.Dialer), network string, addr string, config *_tls.Config) Object {
// 	_res1, _res2 := _tls.DialWithDialer(dialer, network, addr, config)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.Listen from crypto/tls/tls.go:
func __listen(network string, laddr string, config *_tls.Config) Object {
	_res1, _res2 := _tls.Listen(network, laddr, config)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.LoadX509KeyPair from crypto/tls/tls.go:
func __loadX509KeyPair(certFile string, keyFile string) Object {
	_res1, _res2 := _tls.LoadX509KeyPair(certFile, keyFile)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/tls.NewLRUClientSessionCache from crypto/tls/common.go:
func __newLRUClientSessionCache(capacity int) Object {
	_res := _tls.NewLRUClientSessionCache(capacity)
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.NewListener from crypto/tls/tls.go:
// func __newListener(inner ABEND987(genutils.go: imports not yet supported: net.Listener), config *_tls.Config) Object {
// 	_res := _tls.NewListener(inner, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.Server from crypto/tls/tls.go:
// func __server(conn ABEND987(genutils.go: imports not yet supported: net.Conn), config *_tls.Config) Object {
// 	_res := _tls.Server(conn, config)
// 	return MakeGoObject(_res)
// }

GO FUNC crypto/tls.X509KeyPair from crypto/tls/tls.go:
// func __x509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) Object {
// 	_res1, _res2 := _tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.__ptrTo_Config_BuildNameToCertificate from crypto/tls/common.go:
// func __ptrTo_Config_BuildNameToCertificate(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC crypto/tls.__ptrTo_Config_Clone from crypto/tls/common.go:
func __ptrTo_Config_Clone(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Config)Clone()", args, 0, 0)
	_res := o.O.(*_tls.Config).Clone()
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.__ptrTo_Config_SetSessionTicketKeys from crypto/tls/common.go:
// func __ptrTo_Config_SetSessionTicketKeys(o GoObject, args Object) Object {
// (ConvertToArrayOf[]byte(ABEND901(pre.go: specific-length arrays not supported: ConvertToArrayOfbyte(keys))))}

GO FUNC crypto/tls.__ptrTo_Conn_Close from crypto/tls/conn.go:
func __ptrTo_Conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)Close()", args, 0, 0)
	_res := o.O.(*_tls.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/tls.__ptrTo_Conn_CloseWrite from crypto/tls/conn.go:
func __ptrTo_Conn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_tls.Conn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/tls.__ptrTo_Conn_ConnectionState from crypto/tls/conn.go:
func __ptrTo_Conn_ConnectionState(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)ConnectionState()", args, 0, 0)
	_res := o.O.(*_tls.Conn).ConnectionState()
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.__ptrTo_Conn_Handshake from crypto/tls/conn.go:
func __ptrTo_Conn_Handshake(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)Handshake()", args, 0, 0)
	_res := o.O.(*_tls.Conn).Handshake()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/tls.__ptrTo_Conn_LocalAddr from crypto/tls/conn.go:
func __ptrTo_Conn_LocalAddr(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)LocalAddr()", args, 0, 0)
	_res := o.O.(*_tls.Conn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.__ptrTo_Conn_OCSPResponse from crypto/tls/conn.go:
func __ptrTo_Conn_OCSPResponse(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)OCSPResponse()", args, 0, 0)
	_res := o.O.(*_tls.Conn).OCSPResponse()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/tls.__ptrTo_Conn_Read from crypto/tls/conn.go:
// func __ptrTo_Conn_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC crypto/tls.__ptrTo_Conn_RemoteAddr from crypto/tls/conn.go:
func __ptrTo_Conn_RemoteAddr(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/tls.Conn)RemoteAddr()", args, 0, 0)
	_res := o.O.(*_tls.Conn).RemoteAddr()
	return MakeGoObject(_res)
}

GO FUNC crypto/tls.__ptrTo_Conn_SetDeadline from crypto/tls/conn.go:
// func __ptrTo_Conn_SetDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC crypto/tls.__ptrTo_Conn_SetReadDeadline from crypto/tls/conn.go:
// func __ptrTo_Conn_SetReadDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC crypto/tls.__ptrTo_Conn_SetWriteDeadline from crypto/tls/conn.go:
// func __ptrTo_Conn_SetWriteDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC crypto/tls.__ptrTo_Conn_VerifyHostname from crypto/tls/conn.go:
func __ptrTo_Conn_VerifyHostname(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_crypto/tls.Conn)VerifyHostname()", args, 1, 1)
	host := ExtractGoString("(*_crypto/tls.Conn)VerifyHostname()", "host", _argList, 0)
	_res := o.O.(*_tls.Conn).VerifyHostname(host)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/tls.__ptrTo_Conn_Write from crypto/tls/conn.go:
// func __ptrTo_Conn_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC crypto/tls.__ptrTo_ConnectionState_ExportKeyingMaterial from crypto/tls/common.go:
// func __ptrTo_ConnectionState_ExportKeyingMaterial(o GoObject, args Object) Object {
// (label, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(context)), length)}

GO FUNC crypto/tls.__recordHeaderError_Error from crypto/tls/conn.go:
func __recordHeaderError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/tls.RecordHeaderError)Error()", args, 0, 0)
	_res := o.O.(_tls.RecordHeaderError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package tls

import (
	_tls "crypto/tls"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Config = GoTypeInfo{Members: GoMembers{
	"Clone": __ptrTo_Config_Clone,
}}

var members_PtrTo_Conn = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Conn_Close,
	"CloseWrite": __ptrTo_Conn_CloseWrite,
	"ConnectionState": __ptrTo_Conn_ConnectionState,
	"Handshake": __ptrTo_Conn_Handshake,
	"LocalAddr": __ptrTo_Conn_LocalAddr,
	"OCSPResponse": __ptrTo_Conn_OCSPResponse,
	"RemoteAddr": __ptrTo_Conn_RemoteAddr,
	"VerifyHostname": __ptrTo_Conn_VerifyHostname,
}}

var members_RecordHeaderError = GoTypeInfo{Members: GoMembers{
	"Error": __recordHeaderError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_tls.Config)(nil))] = &members_PtrTo_Config
	GoTypes[_reflect.TypeOf((*_tls.Conn)(nil))] = &members_PtrTo_Conn
	GoTypes[_reflect.TypeOf((*_tls.RecordHeaderError)(nil)).Elem()] = &members_RecordHeaderError
}

GO TYPE crypto/x509.CertPool from crypto/x509/cert_pool.go:
func ExtractGoObjectCertPool(args []Object, index int) *_x509.CertPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertPool:
			return &r
		case *_x509.CertPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertPool]"))
}

func _mapToCertPool(o Map) *_x509.CertPool {
	return &_x509.CertPool{}
}

func _vectorToCertPool(o *Vector) *_x509.CertPool {
	return &_x509.CertPool{}
}

func _ConstructCertPool(_v Object) *_x509.CertPool {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.CertPool:
			return &_g
		case *_x509.CertPool:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCertPool(_o.(Map))
	case *Vector:
		return _vectorToCertPool(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertPool] or: Map or Vector"))
}

GO TYPE crypto/x509.Certificate from crypto/x509/x509.go:
func ExtractGoObjectCertificate(args []Object, index int) *_x509.Certificate {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.Certificate:
			return &r
		case *_x509.Certificate:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.Certificate]"))
}

// func _mapToCertificate(o Map) *_x509.Certificate {
// 	return &_x509.Certificate{}
// }

// func _vectorToCertificate(o *Vector) *_x509.Certificate {
// 	return &_x509.Certificate{
// 		Raw: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawTBSCertificate: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawSubjectPublicKeyInfo: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawSubject: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawIssuer: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		Signature: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		SignatureAlgorithm: _x509.SignatureAlgorithm(AssertInt(o.Nth(6), "").I),
// 		PublicKeyAlgorithm: _x509.PublicKeyAlgorithm(AssertInt(o.Nth(7), "").I),
// 		PublicKey: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Version: AssertInt(o.Nth(9), "").I,
// 		SerialNumber: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Issuer: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Subject: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		NotBefore: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		NotAfter: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeyUsage: _x509.KeyUsage(AssertInt(o.Nth(15), "").I),
// 		Extensions: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExtraExtensions: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		UnhandledCriticalExtensions: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExtKeyUsage: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509.ExtKeyUsage (crypto/x509.ExtKeyUsage)),
// 		UnknownExtKeyUsage: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		BasicConstraintsValid: ToBool(o.Nth(21)),
// 		IsCA: ToBool(o.Nth(22)),
// 		MaxPathLen: AssertInt(o.Nth(23), "").I,
// 		MaxPathLenZero: ToBool(o.Nth(24)),
// 		SubjectKeyId: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		AuthorityKeyId: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		OCSPServer: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		IssuingCertificateURL: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		DNSNames: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		EmailAddresses: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		IPAddresses: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		URIs: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PermittedDNSDomainsCritical: ToBool(o.Nth(33)),
// 		PermittedDNSDomains: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ExcludedDNSDomains: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		PermittedIPRanges: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExcludedIPRanges: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PermittedEmailAddresses: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ExcludedEmailAddresses: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		PermittedURIDomains: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ExcludedURIDomains: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CRLDistributionPoints: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		PolicyIdentifiers: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCertificate(_v Object) *_x509.Certificate {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.Certificate:
// 			return &_g
// 		case *_x509.Certificate:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificate(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificate(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.Certificate] or: Map or Vector"))
// }

GO TYPE crypto/x509.CertificateInvalidError from crypto/x509/verify.go:
func ExtractGoObjectCertificateInvalidError(args []Object, index int) *_x509.CertificateInvalidError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertificateInvalidError:
			return &r
		case *_x509.CertificateInvalidError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertificateInvalidError]"))
}

// func _mapToCertificateInvalidError(o Map) *_x509.CertificateInvalidError {
// 	return &_x509.CertificateInvalidError{}
// }

// func _vectorToCertificateInvalidError(o *Vector) *_x509.CertificateInvalidError {
// 	return &_x509.CertificateInvalidError{
// 		Cert: ABEND048(codegen.go: no conversion from Clojure for *crypto/x509.Certificate (crypto/x509.Certificate)),
// 		Reason: _x509.InvalidReason(AssertInt(o.Nth(1), "").I),
// 		Detail: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructCertificateInvalidError(_v Object) *_x509.CertificateInvalidError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.CertificateInvalidError:
// 			return &_g
// 		case *_x509.CertificateInvalidError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificateInvalidError(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificateInvalidError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertificateInvalidError] or: Map or Vector"))
// }

GO TYPE crypto/x509.CertificateRequest from crypto/x509/x509.go:
func ExtractGoObjectCertificateRequest(args []Object, index int) *_x509.CertificateRequest {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.CertificateRequest:
			return &r
		case *_x509.CertificateRequest:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.CertificateRequest]"))
}

// func _mapToCertificateRequest(o Map) *_x509.CertificateRequest {
// 	return &_x509.CertificateRequest{}
// }

// func _vectorToCertificateRequest(o *Vector) *_x509.CertificateRequest {
// 	return &_x509.CertificateRequest{
// 		Raw: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawTBSCertificateRequest: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawSubjectPublicKeyInfo: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		RawSubject: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		Version: AssertInt(o.Nth(4), "").I,
// 		Signature: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		SignatureAlgorithm: _x509.SignatureAlgorithm(AssertInt(o.Nth(6), "").I),
// 		PublicKeyAlgorithm: _x509.PublicKeyAlgorithm(AssertInt(o.Nth(7), "").I),
// 		PublicKey: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Subject: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Attributes: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Extensions: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExtraExtensions: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		DNSNames: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		EmailAddresses: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		IPAddresses: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		URIs: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCertificateRequest(_v Object) *_x509.CertificateRequest {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.CertificateRequest:
// 			return &_g
// 		case *_x509.CertificateRequest:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificateRequest(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificateRequest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.CertificateRequest] or: Map or Vector"))
// }

GO TYPE crypto/x509.ConstraintViolationError from crypto/x509/x509.go:
func ExtractGoObjectConstraintViolationError(args []Object, index int) *_x509.ConstraintViolationError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.ConstraintViolationError:
			return &r
		case *_x509.ConstraintViolationError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.ConstraintViolationError]"))
}

func _mapToConstraintViolationError(o Map) *_x509.ConstraintViolationError {
	return &_x509.ConstraintViolationError{}
}

func _vectorToConstraintViolationError(o *Vector) *_x509.ConstraintViolationError {
	return &_x509.ConstraintViolationError{}
}

func _ConstructConstraintViolationError(_v Object) *_x509.ConstraintViolationError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.ConstraintViolationError:
			return &_g
		case *_x509.ConstraintViolationError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConstraintViolationError(_o.(Map))
	case *Vector:
		return _vectorToConstraintViolationError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.ConstraintViolationError] or: Map or Vector"))
}

GO TYPE crypto/x509.ExtKeyUsage from crypto/x509/x509.go:
func ExtractGoObjectExtKeyUsage(args []Object, index int) *_x509.ExtKeyUsage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.ExtKeyUsage:
			return &r
		case *_x509.ExtKeyUsage:
			return r
		}
	case Int:
		v := _x509.ExtKeyUsage(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.ExtKeyUsage]"))
}

func _ConstructExtKeyUsage(_v Object) _x509.ExtKeyUsage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.ExtKeyUsage:
			return _g
		case *_x509.ExtKeyUsage:
			return *_g
		}
	case Number:
		return _x509.ExtKeyUsage(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.ExtKeyUsage] or: Number"))
}

GO TYPE crypto/x509.HostnameError from crypto/x509/verify.go:
func ExtractGoObjectHostnameError(args []Object, index int) *_x509.HostnameError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.HostnameError:
			return &r
		case *_x509.HostnameError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.HostnameError]"))
}

// func _mapToHostnameError(o Map) *_x509.HostnameError {
// 	return &_x509.HostnameError{}
// }

// func _vectorToHostnameError(o *Vector) *_x509.HostnameError {
// 	return &_x509.HostnameError{
// 		Certificate: ABEND048(codegen.go: no conversion from Clojure for *crypto/x509.Certificate (crypto/x509.Certificate)),
// 		Host: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructHostnameError(_v Object) *_x509.HostnameError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.HostnameError:
// 			return &_g
// 		case *_x509.HostnameError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHostnameError(_o.(Map))
// 	case *Vector:
// 		return _vectorToHostnameError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.HostnameError] or: Map or Vector"))
// }

GO TYPE crypto/x509.InsecureAlgorithmError from crypto/x509/x509.go:
func ExtractGoObjectInsecureAlgorithmError(args []Object, index int) *_x509.InsecureAlgorithmError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.InsecureAlgorithmError:
			return &r
		case *_x509.InsecureAlgorithmError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.InsecureAlgorithmError]"))
}

// func _ConstructInsecureAlgorithmError(_v Object) _x509.InsecureAlgorithmError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.InsecureAlgorithmError:
// 			return _g
// 		case *_x509.InsecureAlgorithmError:
// 			return *_g
// 		}
// 	case  /* ABEND171(missing go object type or clojure-object extraction for crypto/x509.SignatureAlgorithm) */:
// 		return _x509.InsecureAlgorithmError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.InsecureAlgorithmError] or: "))
// }

GO TYPE crypto/x509.InvalidReason from crypto/x509/verify.go:
func ExtractGoObjectInvalidReason(args []Object, index int) *_x509.InvalidReason {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.InvalidReason:
			return &r
		case *_x509.InvalidReason:
			return r
		}
	case Int:
		v := _x509.InvalidReason(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.InvalidReason]"))
}

func _ConstructInvalidReason(_v Object) _x509.InvalidReason {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.InvalidReason:
			return _g
		case *_x509.InvalidReason:
			return *_g
		}
	case Number:
		return _x509.InvalidReason(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.InvalidReason] or: Number"))
}

GO TYPE crypto/x509.KeyUsage from crypto/x509/x509.go:
func ExtractGoObjectKeyUsage(args []Object, index int) *_x509.KeyUsage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.KeyUsage:
			return &r
		case *_x509.KeyUsage:
			return r
		}
	case Int:
		v := _x509.KeyUsage(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.KeyUsage]"))
}

func _ConstructKeyUsage(_v Object) _x509.KeyUsage {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.KeyUsage:
			return _g
		case *_x509.KeyUsage:
			return *_g
		}
	case Number:
		return _x509.KeyUsage(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.KeyUsage] or: Number"))
}

GO TYPE crypto/x509.PEMCipher from crypto/x509/pem_decrypt.go:
func ExtractGoObjectPEMCipher(args []Object, index int) *_x509.PEMCipher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.PEMCipher:
			return &r
		case *_x509.PEMCipher:
			return r
		}
	case Int:
		v := _x509.PEMCipher(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.PEMCipher]"))
}

func _ConstructPEMCipher(_v Object) _x509.PEMCipher {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.PEMCipher:
			return _g
		case *_x509.PEMCipher:
			return *_g
		}
	case Number:
		return _x509.PEMCipher(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.PEMCipher] or: Number"))
}

GO TYPE crypto/x509.PublicKeyAlgorithm from crypto/x509/x509.go:
func ExtractGoObjectPublicKeyAlgorithm(args []Object, index int) *_x509.PublicKeyAlgorithm {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.PublicKeyAlgorithm:
			return &r
		case *_x509.PublicKeyAlgorithm:
			return r
		}
	case Int:
		v := _x509.PublicKeyAlgorithm(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.PublicKeyAlgorithm]"))
}

func _ConstructPublicKeyAlgorithm(_v Object) _x509.PublicKeyAlgorithm {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.PublicKeyAlgorithm:
			return _g
		case *_x509.PublicKeyAlgorithm:
			return *_g
		}
	case Number:
		return _x509.PublicKeyAlgorithm(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.PublicKeyAlgorithm] or: Number"))
}

GO TYPE crypto/x509.SignatureAlgorithm from crypto/x509/x509.go:
func ExtractGoObjectSignatureAlgorithm(args []Object, index int) *_x509.SignatureAlgorithm {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.SignatureAlgorithm:
			return &r
		case *_x509.SignatureAlgorithm:
			return r
		}
	case Int:
		v := _x509.SignatureAlgorithm(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.SignatureAlgorithm]"))
}

func _ConstructSignatureAlgorithm(_v Object) _x509.SignatureAlgorithm {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.SignatureAlgorithm:
			return _g
		case *_x509.SignatureAlgorithm:
			return *_g
		}
	case Number:
		return _x509.SignatureAlgorithm(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.SignatureAlgorithm] or: Number"))
}

GO TYPE crypto/x509.SystemRootsError from crypto/x509/verify.go:
func ExtractGoObjectSystemRootsError(args []Object, index int) *_x509.SystemRootsError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.SystemRootsError:
			return &r
		case *_x509.SystemRootsError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.SystemRootsError]"))
}

func _mapToSystemRootsError(o Map) *_x509.SystemRootsError {
	return &_x509.SystemRootsError{}
}

func _vectorToSystemRootsError(o *Vector) *_x509.SystemRootsError {
	return &_x509.SystemRootsError{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructSystemRootsError(_v Object) *_x509.SystemRootsError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.SystemRootsError:
			return &_g
		case *_x509.SystemRootsError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSystemRootsError(_o.(Map))
	case *Vector:
		return _vectorToSystemRootsError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.SystemRootsError] or: Map or Vector"))
}

GO TYPE crypto/x509.UnhandledCriticalExtension from crypto/x509/x509.go:
func ExtractGoObjectUnhandledCriticalExtension(args []Object, index int) *_x509.UnhandledCriticalExtension {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.UnhandledCriticalExtension:
			return &r
		case *_x509.UnhandledCriticalExtension:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.UnhandledCriticalExtension]"))
}

func _mapToUnhandledCriticalExtension(o Map) *_x509.UnhandledCriticalExtension {
	return &_x509.UnhandledCriticalExtension{}
}

func _vectorToUnhandledCriticalExtension(o *Vector) *_x509.UnhandledCriticalExtension {
	return &_x509.UnhandledCriticalExtension{}
}

func _ConstructUnhandledCriticalExtension(_v Object) *_x509.UnhandledCriticalExtension {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _x509.UnhandledCriticalExtension:
			return &_g
		case *_x509.UnhandledCriticalExtension:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnhandledCriticalExtension(_o.(Map))
	case *Vector:
		return _vectorToUnhandledCriticalExtension(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.UnhandledCriticalExtension] or: Map or Vector"))
}

GO TYPE crypto/x509.UnknownAuthorityError from crypto/x509/verify.go:
func ExtractGoObjectUnknownAuthorityError(args []Object, index int) *_x509.UnknownAuthorityError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.UnknownAuthorityError:
			return &r
		case *_x509.UnknownAuthorityError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.UnknownAuthorityError]"))
}

// func _mapToUnknownAuthorityError(o Map) *_x509.UnknownAuthorityError {
// 	return &_x509.UnknownAuthorityError{}
// }

// func _vectorToUnknownAuthorityError(o *Vector) *_x509.UnknownAuthorityError {
// 	return &_x509.UnknownAuthorityError{
// 		Cert: ABEND048(codegen.go: no conversion from Clojure for *crypto/x509.Certificate (crypto/x509.Certificate)),
// 	}
// }

// func _ConstructUnknownAuthorityError(_v Object) *_x509.UnknownAuthorityError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.UnknownAuthorityError:
// 			return &_g
// 		case *_x509.UnknownAuthorityError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnknownAuthorityError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnknownAuthorityError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.UnknownAuthorityError] or: Map or Vector"))
// }

GO TYPE crypto/x509.VerifyOptions from crypto/x509/verify.go:
func ExtractGoObjectVerifyOptions(args []Object, index int) *_x509.VerifyOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _x509.VerifyOptions:
			return &r
		case *_x509.VerifyOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509.VerifyOptions]"))
}

// func _mapToVerifyOptions(o Map) *_x509.VerifyOptions {
// 	return &_x509.VerifyOptions{}
// }

// func _vectorToVerifyOptions(o *Vector) *_x509.VerifyOptions {
// 	return &_x509.VerifyOptions{
// 		DNSName: AssertString(o.Nth(0), "").S,
// 		Intermediates: ABEND048(codegen.go: no conversion from Clojure for *crypto/x509.CertPool (crypto/x509.CertPool)),
// 		Roots: ABEND048(codegen.go: no conversion from Clojure for *crypto/x509.CertPool (crypto/x509.CertPool)),
// 		CurrentTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeyUsages: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509.ExtKeyUsage (crypto/x509.ExtKeyUsage)),
// 		MaxConstraintComparisions: AssertInt(o.Nth(5), "").I,
// 	}
// }

// func _ConstructVerifyOptions(_v Object) *_x509.VerifyOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _x509.VerifyOptions:
// 			return &_g
// 		case *_x509.VerifyOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToVerifyOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToVerifyOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[x509.VerifyOptions] or: Map or Vector"))
// }

GO FUNC crypto/x509.CreateCertificate from crypto/x509/x509.go:
// func __createCertificate(rand ABEND987(genutils.go: imports not yet supported: io.Reader), template *_x509.Certificate, parent *_x509.Certificate, pub interface {}, priv interface {}) Object {
// 	cert, err := _x509.CreateCertificate(rand, template, parent, pub, priv)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range cert {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.CreateCertificateRequest from crypto/x509/x509.go:
// func __createCertificateRequest(rand ABEND987(genutils.go: imports not yet supported: io.Reader), template *_x509.CertificateRequest, priv interface {}) Object {
// 	csr, err := _x509.CreateCertificateRequest(rand, template, priv)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range csr {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.DecryptPEMBlock from crypto/x509/pem_decrypt.go:
// func __decryptPEMBlock(b *ABEND987(genutils.go: imports not yet supported: pem.Block), password []byte) Object {
// 	_res1, _res2 := _x509.DecryptPEMBlock(b, password)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.EncryptPEMBlock from crypto/x509/pem_decrypt.go:
// func __encryptPEMBlock(rand ABEND987(genutils.go: imports not yet supported: io.Reader), blockType string, data []byte, password []byte, alg _x509.PEMCipher) Object {
// 	_res1, _res2 := _x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.IsEncryptedPEMBlock from crypto/x509/pem_decrypt.go:
// func __isEncryptedPEMBlock(b *ABEND987(genutils.go: imports not yet supported: pem.Block))  {
// 	_res := _x509.IsEncryptedPEMBlock(b)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/x509.MarshalECPrivateKey from crypto/x509/sec1.go:
// func __marshalECPrivateKey(key *ABEND987(genutils.go: imports not yet supported: ecdsa.PrivateKey)) Object {
// 	_res1, _res2 := _x509.MarshalECPrivateKey(key)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKCS1PrivateKey from crypto/x509/pkcs1.go:
// func __marshalPKCS1PrivateKey(key *ABEND987(genutils.go: imports not yet supported: rsa.PrivateKey)) Object {
// 	_res := _x509.MarshalPKCS1PrivateKey(key)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS1PublicKey from crypto/x509/pkcs1.go:
// func __marshalPKCS1PublicKey(key *ABEND987(genutils.go: imports not yet supported: rsa.PublicKey)) Object {
// 	_res := _x509.MarshalPKCS1PublicKey(key)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS8PrivateKey from crypto/x509/pkcs8.go:
// func __marshalPKCS8PrivateKey(key interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKCS8PrivateKey(key)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKIXPublicKey from crypto/x509/x509.go:
// func __marshalPKIXPublicKey(pub interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKIXPublicKey(pub)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.NewCertPool from crypto/x509/cert_pool.go:
func __newCertPool() Object {
	_res := _x509.NewCertPool()
	return MakeGoObject(_res)
}

GO FUNC crypto/x509.ParseCRL from crypto/x509/x509.go:
// func __parseCRL(crlBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseCRL(crlBytes)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificate from crypto/x509/x509.go:
// func __parseCertificate(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificate(asn1Data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificateRequest from crypto/x509/x509.go:
// func __parseCertificateRequest(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificateRequest(asn1Data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificates from crypto/x509/x509.go:
// func __parseCertificates(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificates(asn1Data)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseDERCRL from crypto/x509/x509.go:
// func __parseDERCRL(derBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseDERCRL(derBytes)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseECPrivateKey from crypto/x509/sec1.go:
// func __parseECPrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParseECPrivateKey(der)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PrivateKey from crypto/x509/pkcs1.go:
// func __parsePKCS1PrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PrivateKey(der)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PublicKey from crypto/x509/pkcs1.go:
// func __parsePKCS1PublicKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PublicKey(der)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS8PrivateKey from crypto/x509/pkcs8.go:
// func __parsePKCS8PrivateKey(der []byte) Object {
// 	key, err := _x509.ParsePKCS8PrivateKey(der)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(key)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKIXPublicKey from crypto/x509/x509.go:
// func __parsePKIXPublicKey(derBytes []byte) Object {
// 	pub, err := _x509.ParsePKIXPublicKey(derBytes)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(pub)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.SystemCertPool from crypto/x509/cert_pool.go:
func __systemCertPool() Object {
	_res1, _res2 := _x509.SystemCertPool()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/x509.__certificateInvalidError_Error from crypto/x509/verify.go:
func __certificateInvalidError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.CertificateInvalidError)Error()", args, 0, 0)
	_res := o.O.(_x509.CertificateInvalidError).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__constraintViolationError_Error from crypto/x509/x509.go:
func __constraintViolationError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.ConstraintViolationError)Error()", args, 0, 0)
	_res := o.O.(_x509.ConstraintViolationError).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__hostnameError_Error from crypto/x509/verify.go:
func __hostnameError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.HostnameError)Error()", args, 0, 0)
	_res := o.O.(_x509.HostnameError).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__insecureAlgorithmError_Error from crypto/x509/x509.go:
func __insecureAlgorithmError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.InsecureAlgorithmError)Error()", args, 0, 0)
	_res := o.O.(_x509.InsecureAlgorithmError).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__ptrTo_CertPool_AddCert from crypto/x509/cert_pool.go:
// func __ptrTo_CertPool_AddCert(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC crypto/x509.__ptrTo_CertPool_AppendCertsFromPEM from crypto/x509/cert_pool.go:
// func __ptrTo_CertPool_AppendCertsFromPEM(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(pemCerts)))}

GO FUNC crypto/x509.__ptrTo_CertPool_Subjects from crypto/x509/cert_pool.go:
func __ptrTo_CertPool_Subjects(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/x509.CertPool)Subjects()", args, 0, 0)
	_res := o.O.(*_x509.CertPool).Subjects()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC crypto/x509.__ptrTo_CertificateRequest_CheckSignature from crypto/x509/x509.go:
func __ptrTo_CertificateRequest_CheckSignature(o GoObject, args Object) Object {
	CheckGoArity("(*_crypto/x509.CertificateRequest)CheckSignature()", args, 0, 0)
	_res := o.O.(*_x509.CertificateRequest).CheckSignature()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/x509.__ptrTo_Certificate_CheckCRLSignature from crypto/x509/x509.go:
// func __ptrTo_Certificate_CheckCRLSignature(o GoObject, args Object) Object {
// crl *ABEND987(genutils.go: imports not yet supported: pkix.CertificateList)}

GO FUNC crypto/x509.__ptrTo_Certificate_CheckSignature from crypto/x509/x509.go:
// func __ptrTo_Certificate_CheckSignature(o GoObject, args Object) Object {
// (*algo, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(signed)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(signature)))}

GO FUNC crypto/x509.__ptrTo_Certificate_CheckSignatureFrom from crypto/x509/x509.go:
// func __ptrTo_Certificate_CheckSignatureFrom(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_crypto/x509.Certificate)CheckSignatureFrom()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for parent at: /usr/local/go/src/crypto/x509/x509.go:810:49)
// 	_res := o.O.(*_x509.Certificate).CheckSignatureFrom(parent)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC crypto/x509.__ptrTo_Certificate_CreateCRL from crypto/x509/x509.go:
// func __ptrTo_Certificate_CreateCRL(o GoObject, args Object) Object {
// rand ABEND987(genutils.go: imports not yet supported: io.Reader), priv interface {}, revokedCerts []ABEND987(genutils.go: imports not yet supported: pkix.RevokedCertificate), now ABEND987(genutils.go: imports not yet supported: time.Time), expiry ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC crypto/x509.__ptrTo_Certificate_Equal from crypto/x509/x509.go:
// func __ptrTo_Certificate_Equal(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_crypto/x509.Certificate)Equal()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for other at: /usr/local/go/src/crypto/x509/x509.go:751:35)
// 	_res := o.O.(*_x509.Certificate).Equal(other)
// 	return MakeBoolean(_res)
// }

GO FUNC crypto/x509.__ptrTo_Certificate_Verify from crypto/x509/verify.go:
func __ptrTo_Certificate_Verify(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_crypto/x509.Certificate)Verify()", args, 1, 1)
	opts := ExtractGo_go_std_crypto_x509__VerifyOptions("(*_crypto/x509.Certificate)Verify()", "opts", _argList, 0)
	chains, err := o.O.(*_x509.Certificate).Verify(opts)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range chains {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeGoObject(_elem2))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC crypto/x509.__ptrTo_Certificate_VerifyHostname from crypto/x509/verify.go:
func __ptrTo_Certificate_VerifyHostname(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_crypto/x509.Certificate)VerifyHostname()", args, 1, 1)
	h := ExtractGoString("(*_crypto/x509.Certificate)VerifyHostname()", "h", _argList, 0)
	_res := o.O.(*_x509.Certificate).VerifyHostname(h)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC crypto/x509.__publicKeyAlgorithm_String from crypto/x509/x509.go:
func __publicKeyAlgorithm_String(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.PublicKeyAlgorithm)String()", args, 0, 0)
	_res := o.O.(_x509.PublicKeyAlgorithm).String()
	return MakeString(_res)
}

GO FUNC crypto/x509.__signatureAlgorithm_String from crypto/x509/x509.go:
func __signatureAlgorithm_String(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.SignatureAlgorithm)String()", args, 0, 0)
	_res := o.O.(_x509.SignatureAlgorithm).String()
	return MakeString(_res)
}

GO FUNC crypto/x509.__systemRootsError_Error from crypto/x509/verify.go:
func __systemRootsError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.SystemRootsError)Error()", args, 0, 0)
	_res := o.O.(_x509.SystemRootsError).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__unhandledCriticalExtension_Error from crypto/x509/x509.go:
func __unhandledCriticalExtension_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.UnhandledCriticalExtension)Error()", args, 0, 0)
	_res := o.O.(_x509.UnhandledCriticalExtension).Error()
	return MakeString(_res)
}

GO FUNC crypto/x509.__unknownAuthorityError_Error from crypto/x509/verify.go:
func __unknownAuthorityError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509.UnknownAuthorityError)Error()", args, 0, 0)
	_res := o.O.(_x509.UnknownAuthorityError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package x509

import (
	_x509 "crypto/x509"
	_errors "errors"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_CertPool = GoTypeInfo{Members: GoMembers{
	"Subjects": __ptrTo_CertPool_Subjects,
}}

var members_PtrTo_Certificate = GoTypeInfo{Members: GoMembers{
	"Verify": __ptrTo_Certificate_Verify,
	"VerifyHostname": __ptrTo_Certificate_VerifyHostname,
}}

var members_CertificateInvalidError = GoTypeInfo{Members: GoMembers{
	"Error": __certificateInvalidError_Error,
}}

var members_PtrTo_CertificateRequest = GoTypeInfo{Members: GoMembers{
	"CheckSignature": __ptrTo_CertificateRequest_CheckSignature,
}}

var members_ConstraintViolationError = GoTypeInfo{Members: GoMembers{
	"Error": __constraintViolationError_Error,
}}

var members_HostnameError = GoTypeInfo{Members: GoMembers{
	"Error": __hostnameError_Error,
}}

var members_InsecureAlgorithmError = GoTypeInfo{Members: GoMembers{
	"Error": __insecureAlgorithmError_Error,
}}

var members_PublicKeyAlgorithm = GoTypeInfo{Members: GoMembers{
	"String": __publicKeyAlgorithm_String,
}}

var members_SignatureAlgorithm = GoTypeInfo{Members: GoMembers{
	"String": __signatureAlgorithm_String,
}}

var members_SystemRootsError = GoTypeInfo{Members: GoMembers{
	"Error": __systemRootsError_Error,
}}

var members_UnhandledCriticalExtension = GoTypeInfo{Members: GoMembers{
	"Error": __unhandledCriticalExtension_Error,
}}

var members_UnknownAuthorityError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownAuthorityError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_x509.CertPool)(nil))] = &members_PtrTo_CertPool
	GoTypes[_reflect.TypeOf((*_x509.Certificate)(nil))] = &members_PtrTo_Certificate
	GoTypes[_reflect.TypeOf((*_x509.CertificateInvalidError)(nil)).Elem()] = &members_CertificateInvalidError
	GoTypes[_reflect.TypeOf((*_x509.CertificateRequest)(nil))] = &members_PtrTo_CertificateRequest
	GoTypes[_reflect.TypeOf((*_x509.ConstraintViolationError)(nil)).Elem()] = &members_ConstraintViolationError
	GoTypes[_reflect.TypeOf((*_x509.HostnameError)(nil)).Elem()] = &members_HostnameError
	GoTypes[_reflect.TypeOf((*_x509.InsecureAlgorithmError)(nil)).Elem()] = &members_InsecureAlgorithmError
	GoTypes[_reflect.TypeOf((*_x509.PublicKeyAlgorithm)(nil)).Elem()] = &members_PublicKeyAlgorithm
	GoTypes[_reflect.TypeOf((*_x509.SignatureAlgorithm)(nil)).Elem()] = &members_SignatureAlgorithm
	GoTypes[_reflect.TypeOf((*_x509.SystemRootsError)(nil)).Elem()] = &members_SystemRootsError
	GoTypes[_reflect.TypeOf((*_x509.UnhandledCriticalExtension)(nil)).Elem()] = &members_UnhandledCriticalExtension
	GoTypes[_reflect.TypeOf((*_x509.UnknownAuthorityError)(nil)).Elem()] = &members_UnknownAuthorityError
}

GO TYPE crypto/x509/pkix.AlgorithmIdentifier from crypto/x509/pkix/pkix.go:
func ExtractGoObjectAlgorithmIdentifier(args []Object, index int) *_pkix.AlgorithmIdentifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.AlgorithmIdentifier:
			return &r
		case *_pkix.AlgorithmIdentifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.AlgorithmIdentifier]"))
}

// func _mapToAlgorithmIdentifier(o Map) *_pkix.AlgorithmIdentifier {
// 	return &_pkix.AlgorithmIdentifier{}
// }

// func _vectorToAlgorithmIdentifier(o *Vector) *_pkix.AlgorithmIdentifier {
// 	return &_pkix.AlgorithmIdentifier{
// 		Algorithm: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Parameters: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructAlgorithmIdentifier(_v Object) *_pkix.AlgorithmIdentifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.AlgorithmIdentifier:
// 			return &_g
// 		case *_pkix.AlgorithmIdentifier:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAlgorithmIdentifier(_o.(Map))
// 	case *Vector:
// 		return _vectorToAlgorithmIdentifier(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.AlgorithmIdentifier] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.AttributeTypeAndValue from crypto/x509/pkix/pkix.go:
func ExtractGoObjectAttributeTypeAndValue(args []Object, index int) *_pkix.AttributeTypeAndValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.AttributeTypeAndValue:
			return &r
		case *_pkix.AttributeTypeAndValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.AttributeTypeAndValue]"))
}

// func _mapToAttributeTypeAndValue(o Map) *_pkix.AttributeTypeAndValue {
// 	return &_pkix.AttributeTypeAndValue{}
// }

// func _vectorToAttributeTypeAndValue(o *Vector) *_pkix.AttributeTypeAndValue {
// 	return &_pkix.AttributeTypeAndValue{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Value: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructAttributeTypeAndValue(_v Object) *_pkix.AttributeTypeAndValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.AttributeTypeAndValue:
// 			return &_g
// 		case *_pkix.AttributeTypeAndValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAttributeTypeAndValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToAttributeTypeAndValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.AttributeTypeAndValue] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.AttributeTypeAndValueSET from crypto/x509/pkix/pkix.go:
func ExtractGoObjectAttributeTypeAndValueSET(args []Object, index int) *_pkix.AttributeTypeAndValueSET {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.AttributeTypeAndValueSET:
			return &r
		case *_pkix.AttributeTypeAndValueSET:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.AttributeTypeAndValueSET]"))
}

// func _mapToAttributeTypeAndValueSET(o Map) *_pkix.AttributeTypeAndValueSET {
// 	return &_pkix.AttributeTypeAndValueSET{}
// }

// func _vectorToAttributeTypeAndValueSET(o *Vector) *_pkix.AttributeTypeAndValueSET {
// 	return &_pkix.AttributeTypeAndValueSET{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for [][]crypto/x509/pkix.AttributeTypeAndValue ([]crypto/x509/pkix.AttributeTypeAndValue)),
// 	}
// }

// func _ConstructAttributeTypeAndValueSET(_v Object) *_pkix.AttributeTypeAndValueSET {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.AttributeTypeAndValueSET:
// 			return &_g
// 		case *_pkix.AttributeTypeAndValueSET:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAttributeTypeAndValueSET(_o.(Map))
// 	case *Vector:
// 		return _vectorToAttributeTypeAndValueSET(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.AttributeTypeAndValueSET] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.CertificateList from crypto/x509/pkix/pkix.go:
func ExtractGoObjectCertificateList(args []Object, index int) *_pkix.CertificateList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.CertificateList:
			return &r
		case *_pkix.CertificateList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.CertificateList]"))
}

// func _mapToCertificateList(o Map) *_pkix.CertificateList {
// 	return &_pkix.CertificateList{}
// }

// func _vectorToCertificateList(o *Vector) *_pkix.CertificateList {
// 	return &_pkix.CertificateList{
// 		TBSCertList: ABEND048(codegen.go: no conversion from Clojure for crypto/x509/pkix.TBSCertificateList (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		SignatureAlgorithm: ABEND048(codegen.go: no conversion from Clojure for crypto/x509/pkix.AlgorithmIdentifier (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		SignatureValue: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCertificateList(_v Object) *_pkix.CertificateList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.CertificateList:
// 			return &_g
// 		case *_pkix.CertificateList:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCertificateList(_o.(Map))
// 	case *Vector:
// 		return _vectorToCertificateList(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.CertificateList] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.Extension from crypto/x509/pkix/pkix.go:
func ExtractGoObjectExtension(args []Object, index int) *_pkix.Extension {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.Extension:
			return &r
		case *_pkix.Extension:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.Extension]"))
}

// func _mapToExtension(o Map) *_pkix.Extension {
// 	return &_pkix.Extension{}
// }

// func _vectorToExtension(o *Vector) *_pkix.Extension {
// 	return &_pkix.Extension{
// 		Id: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Critical: ToBool(o.Nth(1)),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructExtension(_v Object) *_pkix.Extension {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.Extension:
// 			return &_g
// 		case *_pkix.Extension:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToExtension(_o.(Map))
// 	case *Vector:
// 		return _vectorToExtension(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.Extension] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.Name from crypto/x509/pkix/pkix.go:
func ExtractGoObjectName(args []Object, index int) *_pkix.Name {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.Name:
			return &r
		case *_pkix.Name:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.Name]"))
}

// func _mapToName(o Map) *_pkix.Name {
// 	return &_pkix.Name{}
// }

// func _vectorToName(o *Vector) *_pkix.Name {
// 	return &_pkix.Name{
// 		Country: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Organization: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		OrganizationalUnit: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Locality: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Province: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		StreetAddress: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		PostalCode: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SerialNumber: AssertString(o.Nth(7), "").S,
// 		CommonName: AssertString(o.Nth(8), "").S,
// 		Names: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509/pkix.AttributeTypeAndValue (crypto/x509/pkix.AttributeTypeAndValue)),
// 		ExtraNames: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509/pkix.AttributeTypeAndValue (crypto/x509/pkix.AttributeTypeAndValue)),
// 	}
// }

// func _ConstructName(_v Object) *_pkix.Name {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.Name:
// 			return &_g
// 		case *_pkix.Name:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToName(_o.(Map))
// 	case *Vector:
// 		return _vectorToName(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.Name] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.RDNSequence from crypto/x509/pkix/pkix.go:
func ExtractGoObjectRDNSequence(args []Object, index int) *_pkix.RDNSequence {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.RDNSequence:
			return &r
		case *_pkix.RDNSequence:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.RDNSequence]"))
}

// func _ConstructRDNSequence(_v Object) _pkix.RDNSequence {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.RDNSequence:
// 			return _g
// 		case *_pkix.RDNSequence:
// 			return *_g
// 		}
// 	default:
// 		return _pkix.RDNSequence(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for RDNSequence))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.RDNSequence] or: whatever"))
// }

GO TYPE crypto/x509/pkix.RelativeDistinguishedNameSET from crypto/x509/pkix/pkix.go:
func ExtractGoObjectRelativeDistinguishedNameSET(args []Object, index int) *_pkix.RelativeDistinguishedNameSET {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.RelativeDistinguishedNameSET:
			return &r
		case *_pkix.RelativeDistinguishedNameSET:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.RelativeDistinguishedNameSET]"))
}

// func _ConstructRelativeDistinguishedNameSET(_v Object) _pkix.RelativeDistinguishedNameSET {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.RelativeDistinguishedNameSET:
// 			return _g
// 		case *_pkix.RelativeDistinguishedNameSET:
// 			return *_g
// 		}
// 	default:
// 		return _pkix.RelativeDistinguishedNameSET(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for RelativeDistinguishedNameSET))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.RelativeDistinguishedNameSET] or: whatever"))
// }

GO TYPE crypto/x509/pkix.RevokedCertificate from crypto/x509/pkix/pkix.go:
func ExtractGoObjectRevokedCertificate(args []Object, index int) *_pkix.RevokedCertificate {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.RevokedCertificate:
			return &r
		case *_pkix.RevokedCertificate:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.RevokedCertificate]"))
}

// func _mapToRevokedCertificate(o Map) *_pkix.RevokedCertificate {
// 	return &_pkix.RevokedCertificate{}
// }

// func _vectorToRevokedCertificate(o *Vector) *_pkix.RevokedCertificate {
// 	return &_pkix.RevokedCertificate{
// 		SerialNumber: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RevocationTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Extensions: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509/pkix.Extension (crypto/x509/pkix.Extension)),
// 	}
// }

// func _ConstructRevokedCertificate(_v Object) *_pkix.RevokedCertificate {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.RevokedCertificate:
// 			return &_g
// 		case *_pkix.RevokedCertificate:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRevokedCertificate(_o.(Map))
// 	case *Vector:
// 		return _vectorToRevokedCertificate(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.RevokedCertificate] or: Map or Vector"))
// }

GO TYPE crypto/x509/pkix.TBSCertificateList from crypto/x509/pkix/pkix.go:
func ExtractGoObjectTBSCertificateList(args []Object, index int) *_pkix.TBSCertificateList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pkix.TBSCertificateList:
			return &r
		case *_pkix.TBSCertificateList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[crypto/x509/pkix.TBSCertificateList]"))
}

// func _mapToTBSCertificateList(o Map) *_pkix.TBSCertificateList {
// 	return &_pkix.TBSCertificateList{}
// }

// func _vectorToTBSCertificateList(o *Vector) *_pkix.TBSCertificateList {
// 	return &_pkix.TBSCertificateList{
// 		Raw: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Version: AssertInt(o.Nth(1), "").I,
// 		Signature: ABEND048(codegen.go: no conversion from Clojure for crypto/x509/pkix.AlgorithmIdentifier (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Issuer: ABEND048(codegen.go: no conversion from Clojure for crypto/x509/pkix.RDNSequence ([]crypto/x509/pkix.RelativeDistinguishedNameSET)),
// 		ThisUpdate: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		NextUpdate: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RevokedCertificates: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509/pkix.RevokedCertificate (crypto/x509/pkix.RevokedCertificate)),
// 		Extensions: ABEND048(codegen.go: no conversion from Clojure for []crypto/x509/pkix.Extension (crypto/x509/pkix.Extension)),
// 	}
// }

// func _ConstructTBSCertificateList(_v Object) *_pkix.TBSCertificateList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pkix.TBSCertificateList:
// 			return &_g
// 		case *_pkix.TBSCertificateList:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTBSCertificateList(_o.(Map))
// 	case *Vector:
// 		return _vectorToTBSCertificateList(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pkix.TBSCertificateList] or: Map or Vector"))
// }

GO FUNC crypto/x509/pkix.__name_String from crypto/x509/pkix/pkix.go:
func __name_String(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509/pkix.Name)String()", args, 0, 0)
	_res := o.O.(_pkix.Name).String()
	return MakeString(_res)
}

GO FUNC crypto/x509/pkix.__name_ToRDNSequence from crypto/x509/pkix/pkix.go:
func __name_ToRDNSequence(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509/pkix.Name)ToRDNSequence()", args, 0, 0)
	_res := o.O.(_pkix.Name).ToRDNSequence()
	return MakeGoObject(_res)
}

GO FUNC crypto/x509/pkix.__ptrTo_CertificateList_HasExpired from crypto/x509/pkix/pkix.go:
// func __ptrTo_CertificateList_HasExpired(o GoObject, args Object) Object {
// now ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC crypto/x509/pkix.__ptrTo_Name_FillFromRDNSequence from crypto/x509/pkix/pkix.go:
// func __ptrTo_Name_FillFromRDNSequence(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC crypto/x509/pkix.__rDNSequence_String from crypto/x509/pkix/pkix.go:
func __rDNSequence_String(o GoObject, args Object) Object {
	CheckGoArity("(_crypto/x509/pkix.RDNSequence)String()", args, 0, 0)
	_res := o.O.(_pkix.RDNSequence).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pkix

import (
	_pkix "crypto/x509/pkix"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_Name = GoTypeInfo{Members: GoMembers{
	"String": __name_String,
	"ToRDNSequence": __name_ToRDNSequence,
}}

var members_RDNSequence = GoTypeInfo{Members: GoMembers{
	"String": __rDNSequence_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_pkix.Name)(nil)).Elem()] = &members_Name
	GoTypes[_reflect.TypeOf((*_pkix.RDNSequence)(nil)).Elem()] = &members_RDNSequence
}

GO TYPE database/sql.ColumnType from database/sql/sql.go:
func ExtractGoObjectColumnType(args []Object, index int) *_sql.ColumnType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.ColumnType:
			return &r
		case *_sql.ColumnType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.ColumnType]"))
}

func _mapToColumnType(o Map) *_sql.ColumnType {
	return &_sql.ColumnType{}
}

func _vectorToColumnType(o *Vector) *_sql.ColumnType {
	return &_sql.ColumnType{}
}

func _ConstructColumnType(_v Object) *_sql.ColumnType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.ColumnType:
			return &_g
		case *_sql.ColumnType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToColumnType(_o.(Map))
	case *Vector:
		return _vectorToColumnType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.ColumnType] or: Map or Vector"))
}

GO TYPE database/sql.Conn from database/sql/sql.go:
func ExtractGoObjectConn(args []Object, index int) *_sql.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Conn:
			return &r
		case *_sql.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Conn]"))
}

func _mapToConn(o Map) *_sql.Conn {
	return &_sql.Conn{}
}

func _vectorToConn(o *Vector) *_sql.Conn {
	return &_sql.Conn{}
}

func _ConstructConn(_v Object) *_sql.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Conn:
			return &_g
		case *_sql.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Conn] or: Map or Vector"))
}

GO TYPE database/sql.DB from database/sql/sql.go:
func ExtractGoObjectDB(args []Object, index int) *_sql.DB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.DB:
			return &r
		case *_sql.DB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.DB]"))
}

func _mapToDB(o Map) *_sql.DB {
	return &_sql.DB{}
}

func _vectorToDB(o *Vector) *_sql.DB {
	return &_sql.DB{}
}

func _ConstructDB(_v Object) *_sql.DB {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.DB:
			return &_g
		case *_sql.DB:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDB(_o.(Map))
	case *Vector:
		return _vectorToDB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.DB] or: Map or Vector"))
}

GO TYPE database/sql.DBStats from database/sql/sql.go:
func ExtractGoObjectDBStats(args []Object, index int) *_sql.DBStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.DBStats:
			return &r
		case *_sql.DBStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.DBStats]"))
}

// func _mapToDBStats(o Map) *_sql.DBStats {
// 	return &_sql.DBStats{}
// }

// func _vectorToDBStats(o *Vector) *_sql.DBStats {
// 	return &_sql.DBStats{
// 		MaxOpenConnections: AssertInt(o.Nth(0), "").I,
// 		OpenConnections: AssertInt(o.Nth(1), "").I,
// 		InUse: AssertInt(o.Nth(2), "").I,
// 		Idle: AssertInt(o.Nth(3), "").I,
// 		WaitCount: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		WaitDuration: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MaxIdleClosed: AssertNumber(o.Nth(6), "").BigInt().Int64(),
// 		MaxLifetimeClosed: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 	}
// }

// func _ConstructDBStats(_v Object) *_sql.DBStats {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.DBStats:
// 			return &_g
// 		case *_sql.DBStats:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDBStats(_o.(Map))
// 	case *Vector:
// 		return _vectorToDBStats(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.DBStats] or: Map or Vector"))
// }

GO TYPE database/sql.IsolationLevel from database/sql/sql.go:
func ExtractGoObjectIsolationLevel(args []Object, index int) *_sql.IsolationLevel {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.IsolationLevel:
			return &r
		case *_sql.IsolationLevel:
			return r
		}
	case Int:
		v := _sql.IsolationLevel(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.IsolationLevel]"))
}

func _ConstructIsolationLevel(_v Object) _sql.IsolationLevel {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.IsolationLevel:
			return _g
		case *_sql.IsolationLevel:
			return *_g
		}
	case Number:
		return _sql.IsolationLevel(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.IsolationLevel] or: Number"))
}

GO TYPE database/sql.NamedArg from database/sql/sql.go:
func ExtractGoObjectNamedArg(args []Object, index int) *_sql.NamedArg {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NamedArg:
			return &r
		case *_sql.NamedArg:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NamedArg]"))
}

// func _mapToNamedArg(o Map) *_sql.NamedArg {
// 	return &_sql.NamedArg{}
// }

// func _vectorToNamedArg(o *Vector) *_sql.NamedArg {
// 	return &_sql.NamedArg{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Value: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructNamedArg(_v Object) *_sql.NamedArg {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.NamedArg:
// 			return &_g
// 		case *_sql.NamedArg:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNamedArg(_o.(Map))
// 	case *Vector:
// 		return _vectorToNamedArg(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NamedArg] or: Map or Vector"))
// }

GO TYPE database/sql.NullBool from database/sql/sql.go:
func ExtractGoObjectNullBool(args []Object, index int) *_sql.NullBool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullBool:
			return &r
		case *_sql.NullBool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullBool]"))
}

func _mapToNullBool(o Map) *_sql.NullBool {
	return &_sql.NullBool{}
}

func _vectorToNullBool(o *Vector) *_sql.NullBool {
	return &_sql.NullBool{
		Bool: ToBool(o.Nth(0)),
		Valid: ToBool(o.Nth(1)),
	}
}

func _ConstructNullBool(_v Object) *_sql.NullBool {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullBool:
			return &_g
		case *_sql.NullBool:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullBool(_o.(Map))
	case *Vector:
		return _vectorToNullBool(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullBool] or: Map or Vector"))
}

GO TYPE database/sql.NullFloat64 from database/sql/sql.go:
func ExtractGoObjectNullFloat64(args []Object, index int) *_sql.NullFloat64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullFloat64:
			return &r
		case *_sql.NullFloat64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullFloat64]"))
}

func _mapToNullFloat64(o Map) *_sql.NullFloat64 {
	return &_sql.NullFloat64{}
}

func _vectorToNullFloat64(o *Vector) *_sql.NullFloat64 {
	return &_sql.NullFloat64{
		Float64: float64(AssertDouble(o.Nth(0), "").D),
		Valid: ToBool(o.Nth(1)),
	}
}

func _ConstructNullFloat64(_v Object) *_sql.NullFloat64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullFloat64:
			return &_g
		case *_sql.NullFloat64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullFloat64(_o.(Map))
	case *Vector:
		return _vectorToNullFloat64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullFloat64] or: Map or Vector"))
}

GO TYPE database/sql.NullInt64 from database/sql/sql.go:
func ExtractGoObjectNullInt64(args []Object, index int) *_sql.NullInt64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullInt64:
			return &r
		case *_sql.NullInt64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullInt64]"))
}

func _mapToNullInt64(o Map) *_sql.NullInt64 {
	return &_sql.NullInt64{}
}

func _vectorToNullInt64(o *Vector) *_sql.NullInt64 {
	return &_sql.NullInt64{
		Int64: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Valid: ToBool(o.Nth(1)),
	}
}

func _ConstructNullInt64(_v Object) *_sql.NullInt64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullInt64:
			return &_g
		case *_sql.NullInt64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullInt64(_o.(Map))
	case *Vector:
		return _vectorToNullInt64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullInt64] or: Map or Vector"))
}

GO TYPE database/sql.NullString from database/sql/sql.go:
func ExtractGoObjectNullString(args []Object, index int) *_sql.NullString {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.NullString:
			return &r
		case *_sql.NullString:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.NullString]"))
}

func _mapToNullString(o Map) *_sql.NullString {
	return &_sql.NullString{}
}

func _vectorToNullString(o *Vector) *_sql.NullString {
	return &_sql.NullString{
		String: AssertString(o.Nth(0), "").S,
		Valid: ToBool(o.Nth(1)),
	}
}

func _ConstructNullString(_v Object) *_sql.NullString {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.NullString:
			return &_g
		case *_sql.NullString:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNullString(_o.(Map))
	case *Vector:
		return _vectorToNullString(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.NullString] or: Map or Vector"))
}

GO TYPE database/sql.Out from database/sql/sql.go:
func ExtractGoObjectOut(args []Object, index int) *_sql.Out {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Out:
			return &r
		case *_sql.Out:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Out]"))
}

// func _mapToOut(o Map) *_sql.Out {
// 	return &_sql.Out{}
// }

// func _vectorToOut(o *Vector) *_sql.Out {
// 	return &_sql.Out{
// 		Dest: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		In: ToBool(o.Nth(1)),
// 	}
// }

// func _ConstructOut(_v Object) *_sql.Out {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.Out:
// 			return &_g
// 		case *_sql.Out:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOut(_o.(Map))
// 	case *Vector:
// 		return _vectorToOut(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Out] or: Map or Vector"))
// }

GO TYPE database/sql.RawBytes from database/sql/sql.go:
func ExtractGoObjectRawBytes(args []Object, index int) *_sql.RawBytes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.RawBytes:
			return &r
		case *_sql.RawBytes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.RawBytes]"))
}

// func _ConstructRawBytes(_v Object) _sql.RawBytes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.RawBytes:
// 			return _g
// 		case *_sql.RawBytes:
// 			return *_g
// 		}
// 	default:
// 		return _sql.RawBytes(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for RawBytes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.RawBytes] or: whatever"))
// }

GO TYPE database/sql.Result from database/sql/sql.go:
func ExtractGoObjectResult(args []Object, index int) *_sql.Result {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Result:
			return &r
		case *_sql.Result:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Result]"))
}

// func _ConstructResult(_v Object) _sql.Result {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.Result:
// 			return _g
// 		case *_sql.Result:
// 			return *_g
// 		}
// 	default:
// 		return _sql.Result(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Result))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Result] or: whatever"))
// }

GO TYPE database/sql.Row from database/sql/sql.go:
func ExtractGoObjectRow(args []Object, index int) *_sql.Row {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Row:
			return &r
		case *_sql.Row:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Row]"))
}

func _mapToRow(o Map) *_sql.Row {
	return &_sql.Row{}
}

func _vectorToRow(o *Vector) *_sql.Row {
	return &_sql.Row{}
}

func _ConstructRow(_v Object) *_sql.Row {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Row:
			return &_g
		case *_sql.Row:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRow(_o.(Map))
	case *Vector:
		return _vectorToRow(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Row] or: Map or Vector"))
}

GO TYPE database/sql.Rows from database/sql/sql.go:
func ExtractGoObjectRows(args []Object, index int) *_sql.Rows {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Rows:
			return &r
		case *_sql.Rows:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Rows]"))
}

func _mapToRows(o Map) *_sql.Rows {
	return &_sql.Rows{}
}

func _vectorToRows(o *Vector) *_sql.Rows {
	return &_sql.Rows{}
}

func _ConstructRows(_v Object) *_sql.Rows {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Rows:
			return &_g
		case *_sql.Rows:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRows(_o.(Map))
	case *Vector:
		return _vectorToRows(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Rows] or: Map or Vector"))
}

GO TYPE database/sql.Scanner from database/sql/sql.go:
func ExtractGoObjectScanner(args []Object, index int) *_sql.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Scanner:
			return &r
		case *_sql.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Scanner]"))
}

// func _ConstructScanner(_v Object) _sql.Scanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sql.Scanner:
// 			return _g
// 		case *_sql.Scanner:
// 			return *_g
// 		}
// 	default:
// 		return _sql.Scanner(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Scanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Scanner] or: whatever"))
// }

GO TYPE database/sql.Stmt from database/sql/sql.go:
func ExtractGoObjectStmt(args []Object, index int) *_sql.Stmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Stmt:
			return &r
		case *_sql.Stmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Stmt]"))
}

func _mapToStmt(o Map) *_sql.Stmt {
	return &_sql.Stmt{}
}

func _vectorToStmt(o *Vector) *_sql.Stmt {
	return &_sql.Stmt{}
}

func _ConstructStmt(_v Object) *_sql.Stmt {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Stmt:
			return &_g
		case *_sql.Stmt:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStmt(_o.(Map))
	case *Vector:
		return _vectorToStmt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Stmt] or: Map or Vector"))
}

GO TYPE database/sql.Tx from database/sql/sql.go:
func ExtractGoObjectTx(args []Object, index int) *_sql.Tx {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.Tx:
			return &r
		case *_sql.Tx:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.Tx]"))
}

func _mapToTx(o Map) *_sql.Tx {
	return &_sql.Tx{}
}

func _vectorToTx(o *Vector) *_sql.Tx {
	return &_sql.Tx{}
}

func _ConstructTx(_v Object) *_sql.Tx {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.Tx:
			return &_g
		case *_sql.Tx:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTx(_o.(Map))
	case *Vector:
		return _vectorToTx(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.Tx] or: Map or Vector"))
}

GO TYPE database/sql.TxOptions from database/sql/sql.go:
func ExtractGoObjectTxOptions(args []Object, index int) *_sql.TxOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sql.TxOptions:
			return &r
		case *_sql.TxOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql.TxOptions]"))
}

func _mapToTxOptions(o Map) *_sql.TxOptions {
	return &_sql.TxOptions{}
}

func _vectorToTxOptions(o *Vector) *_sql.TxOptions {
	return &_sql.TxOptions{
		Isolation: _sql.IsolationLevel(AssertInt(o.Nth(0), "").I),
		ReadOnly: ToBool(o.Nth(1)),
	}
}

func _ConstructTxOptions(_v Object) *_sql.TxOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sql.TxOptions:
			return &_g
		case *_sql.TxOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTxOptions(_o.(Map))
	case *Vector:
		return _vectorToTxOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sql.TxOptions] or: Map or Vector"))
}

GO FUNC database/sql.Drivers from database/sql/sql.go:
func __drivers() Object {
	_res := _sql.Drivers()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC database/sql.Named from database/sql/sql.go:
// func __named(name string, value interface {}) Object {
// 	_res := _sql.Named(name, value)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Open from database/sql/sql.go:
func __open(driverName string, dataSourceName string) Object {
	_res1, _res2 := _sql.Open(driverName, dataSourceName)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.OpenDB from database/sql/sql.go:
// func __openDB(c ABEND987(genutils.go: imports not yet supported: driver.Connector)) Object {
// 	_res := _sql.OpenDB(c)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.Register from database/sql/sql.go:
// func __register(name string, driver ABEND987(genutils.go: imports not yet supported: driver.Driver)) Object {
// 	_sql.Register(name, driver)
// 	...ABEND675: TODO...
// }

GO FUNC database/sql.__isolationLevel_String from database/sql/sql.go:
func __isolationLevel_String(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql.IsolationLevel)String()", args, 0, 0)
	_res := o.O.(_sql.IsolationLevel).String()
	return MakeString(_res)
}

GO FUNC database/sql.__nullBool_Value from database/sql/sql.go:
func __nullBool_Value(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql.NullBool)Value()", args, 0, 0)
	_res1, _res2 := o.O.(_sql.NullBool).Value()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__nullFloat64_Value from database/sql/sql.go:
func __nullFloat64_Value(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql.NullFloat64)Value()", args, 0, 0)
	_res1, _res2 := o.O.(_sql.NullFloat64).Value()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__nullInt64_Value from database/sql/sql.go:
func __nullInt64_Value(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql.NullInt64)Value()", args, 0, 0)
	_res1, _res2 := o.O.(_sql.NullInt64).Value()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__nullString_Value from database/sql/sql.go:
func __nullString_Value(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql.NullString)Value()", args, 0, 0)
	_res1, _res2 := o.O.(_sql.NullString).Value()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_ColumnType_DatabaseTypeName from database/sql/sql.go:
func __ptrTo_ColumnType_DatabaseTypeName(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)DatabaseTypeName()", args, 0, 0)
	_res := o.O.(*_sql.ColumnType).DatabaseTypeName()
	return MakeString(_res)
}

GO FUNC database/sql.__ptrTo_ColumnType_DecimalSize from database/sql/sql.go:
func __ptrTo_ColumnType_DecimalSize(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)DecimalSize()", args, 0, 0)
	precision, scale, ok := o.O.(*_sql.ColumnType).DecimalSize()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(precision))
	_res = _res.Conjoin(MakeBigInt(scale))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC database/sql.__ptrTo_ColumnType_Length from database/sql/sql.go:
func __ptrTo_ColumnType_Length(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)Length()", args, 0, 0)
	length, ok := o.O.(*_sql.ColumnType).Length()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(length))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC database/sql.__ptrTo_ColumnType_Name from database/sql/sql.go:
func __ptrTo_ColumnType_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)Name()", args, 0, 0)
	_res := o.O.(*_sql.ColumnType).Name()
	return MakeString(_res)
}

GO FUNC database/sql.__ptrTo_ColumnType_Nullable from database/sql/sql.go:
func __ptrTo_ColumnType_Nullable(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)Nullable()", args, 0, 0)
	nullable, ok := o.O.(*_sql.ColumnType).Nullable()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(nullable))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC database/sql.__ptrTo_ColumnType_ScanType from database/sql/sql.go:
func __ptrTo_ColumnType_ScanType(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.ColumnType)ScanType()", args, 0, 0)
	_res := o.O.(*_sql.ColumnType).ScanType()
	return MakeGoObject(_res)
}

GO FUNC database/sql.__ptrTo_Conn_BeginTx from database/sql/sql.go:
// func __ptrTo_Conn_BeginTx(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), opts *_sql.TxOptions}

GO FUNC database/sql.__ptrTo_Conn_Close from database/sql/sql.go:
func __ptrTo_Conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Conn)Close()", args, 0, 0)
	_res := o.O.(*_sql.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Conn_ExecContext from database/sql/sql.go:
// func __ptrTo_Conn_ExecContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_Conn_PingContext from database/sql/sql.go:
// func __ptrTo_Conn_PingContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC database/sql.__ptrTo_Conn_PrepareContext from database/sql/sql.go:
// func __ptrTo_Conn_PrepareContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string}

GO FUNC database/sql.__ptrTo_Conn_QueryContext from database/sql/sql.go:
// func __ptrTo_Conn_QueryContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_Conn_QueryRowContext from database/sql/sql.go:
// func __ptrTo_Conn_QueryRowContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_DB_Begin from database/sql/sql.go:
func __ptrTo_DB_Begin(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.DB)Begin()", args, 0, 0)
	_res1, _res2 := o.O.(*_sql.DB).Begin()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_DB_BeginTx from database/sql/sql.go:
// func __ptrTo_DB_BeginTx(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), opts *_sql.TxOptions}

GO FUNC database/sql.__ptrTo_DB_Close from database/sql/sql.go:
func __ptrTo_DB_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.DB)Close()", args, 0, 0)
	_res := o.O.(*_sql.DB).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_DB_Conn from database/sql/sql.go:
// func __ptrTo_DB_Conn(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC database/sql.__ptrTo_DB_Driver from database/sql/sql.go:
func __ptrTo_DB_Driver(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.DB)Driver()", args, 0, 0)
	_res := o.O.(*_sql.DB).Driver()
	return MakeGoObject(_res)
}

GO FUNC database/sql.__ptrTo_DB_Exec from database/sql/sql.go:
// func __ptrTo_DB_Exec(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_DB_ExecContext from database/sql/sql.go:
// func __ptrTo_DB_ExecContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_DB_Ping from database/sql/sql.go:
func __ptrTo_DB_Ping(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.DB)Ping()", args, 0, 0)
	_res := o.O.(*_sql.DB).Ping()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_DB_PingContext from database/sql/sql.go:
// func __ptrTo_DB_PingContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC database/sql.__ptrTo_DB_Prepare from database/sql/sql.go:
func __ptrTo_DB_Prepare(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_database/sql.DB)Prepare()", args, 1, 1)
	query := ExtractGoString("(*_database/sql.DB)Prepare()", "query", _argList, 0)
	_res1, _res2 := o.O.(*_sql.DB).Prepare(query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_DB_PrepareContext from database/sql/sql.go:
// func __ptrTo_DB_PrepareContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string}

GO FUNC database/sql.__ptrTo_DB_Query from database/sql/sql.go:
// func __ptrTo_DB_Query(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_DB_QueryContext from database/sql/sql.go:
// func __ptrTo_DB_QueryContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_DB_QueryRow from database/sql/sql.go:
// func __ptrTo_DB_QueryRow(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_DB_QueryRowContext from database/sql/sql.go:
// func __ptrTo_DB_QueryRowContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_DB_SetConnMaxLifetime from database/sql/sql.go:
// func __ptrTo_DB_SetConnMaxLifetime(o GoObject, args Object) Object {
// d ABEND987(genutils.go: imports not yet supported: time.Duration)}

GO FUNC database/sql.__ptrTo_DB_SetMaxIdleConns from database/sql/sql.go:
// func __ptrTo_DB_SetMaxIdleConns(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC database/sql.__ptrTo_DB_SetMaxOpenConns from database/sql/sql.go:
// func __ptrTo_DB_SetMaxOpenConns(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC database/sql.__ptrTo_DB_Stats from database/sql/sql.go:
func __ptrTo_DB_Stats(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.DB)Stats()", args, 0, 0)
	_res := o.O.(*_sql.DB).Stats()
	return MakeGoObject(_res)
}

GO FUNC database/sql.__ptrTo_NullBool_Scan from database/sql/sql.go:
// func __ptrTo_NullBool_Scan(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql.__ptrTo_NullFloat64_Scan from database/sql/sql.go:
// func __ptrTo_NullFloat64_Scan(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql.__ptrTo_NullInt64_Scan from database/sql/sql.go:
// func __ptrTo_NullInt64_Scan(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql.__ptrTo_NullString_Scan from database/sql/sql.go:
// func __ptrTo_NullString_Scan(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql.__ptrTo_Row_Scan from database/sql/sql.go:
// func __ptrTo_Row_Scan(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Rows_Close from database/sql/sql.go:
func __ptrTo_Rows_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)Close()", args, 0, 0)
	_res := o.O.(*_sql.Rows).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Rows_ColumnTypes from database/sql/sql.go:
func __ptrTo_Rows_ColumnTypes(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)ColumnTypes()", args, 0, 0)
	_res1, _res2 := o.O.(*_sql.Rows).ColumnTypes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_Rows_Columns from database/sql/sql.go:
func __ptrTo_Rows_Columns(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)Columns()", args, 0, 0)
	_res1, _res2 := o.O.(*_sql.Rows).Columns()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_Rows_Err from database/sql/sql.go:
func __ptrTo_Rows_Err(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)Err()", args, 0, 0)
	_res := o.O.(*_sql.Rows).Err()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Rows_Next from database/sql/sql.go:
func __ptrTo_Rows_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)Next()", args, 0, 0)
	_res := o.O.(*_sql.Rows).Next()
	return MakeBoolean(_res)
}

GO FUNC database/sql.__ptrTo_Rows_NextResultSet from database/sql/sql.go:
func __ptrTo_Rows_NextResultSet(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Rows)NextResultSet()", args, 0, 0)
	_res := o.O.(*_sql.Rows).NextResultSet()
	return MakeBoolean(_res)
}

GO FUNC database/sql.__ptrTo_Rows_Scan from database/sql/sql.go:
// func __ptrTo_Rows_Scan(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Stmt_Close from database/sql/sql.go:
func __ptrTo_Stmt_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Stmt)Close()", args, 0, 0)
	_res := o.O.(*_sql.Stmt).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Stmt_Exec from database/sql/sql.go:
// func __ptrTo_Stmt_Exec(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Stmt_ExecContext from database/sql/sql.go:
// func __ptrTo_Stmt_ExecContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), args ...interface {}}

GO FUNC database/sql.__ptrTo_Stmt_Query from database/sql/sql.go:
// func __ptrTo_Stmt_Query(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Stmt_QueryContext from database/sql/sql.go:
// func __ptrTo_Stmt_QueryContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), args ...interface {}}

GO FUNC database/sql.__ptrTo_Stmt_QueryRow from database/sql/sql.go:
// func __ptrTo_Stmt_QueryRow(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Stmt_QueryRowContext from database/sql/sql.go:
// func __ptrTo_Stmt_QueryRowContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), args ...interface {}}

GO FUNC database/sql.__ptrTo_Tx_Commit from database/sql/sql.go:
func __ptrTo_Tx_Commit(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Tx)Commit()", args, 0, 0)
	_res := o.O.(*_sql.Tx).Commit()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Tx_Exec from database/sql/sql.go:
// func __ptrTo_Tx_Exec(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Tx_ExecContext from database/sql/sql.go:
// func __ptrTo_Tx_ExecContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_Tx_Prepare from database/sql/sql.go:
func __ptrTo_Tx_Prepare(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_database/sql.Tx)Prepare()", args, 1, 1)
	query := ExtractGoString("(*_database/sql.Tx)Prepare()", "query", _argList, 0)
	_res1, _res2 := o.O.(*_sql.Tx).Prepare(query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.__ptrTo_Tx_PrepareContext from database/sql/sql.go:
// func __ptrTo_Tx_PrepareContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string}

GO FUNC database/sql.__ptrTo_Tx_Query from database/sql/sql.go:
// func __ptrTo_Tx_Query(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Tx_QueryContext from database/sql/sql.go:
// func __ptrTo_Tx_QueryContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_Tx_QueryRow from database/sql/sql.go:
// func __ptrTo_Tx_QueryRow(o GoObject, args Object) Object {
// (query, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC database/sql.__ptrTo_Tx_QueryRowContext from database/sql/sql.go:
// func __ptrTo_Tx_QueryRowContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), query string, args ...interface {}}

GO FUNC database/sql.__ptrTo_Tx_Rollback from database/sql/sql.go:
func __ptrTo_Tx_Rollback(o GoObject, args Object) Object {
	CheckGoArity("(*_database/sql.Tx)Rollback()", args, 0, 0)
	_res := o.O.(*_sql.Tx).Rollback()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC database/sql.__ptrTo_Tx_Stmt from database/sql/sql.go:
// func __ptrTo_Tx_Stmt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_database/sql.Tx)Stmt()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for stmt at: /usr/local/go/src/database/sql/sql.go:2177:25)
// 	_res := o.O.(*_sql.Tx).Stmt(stmt)
// 	return MakeGoObject(_res)
// }

GO FUNC database/sql.__ptrTo_Tx_StmtContext from database/sql/sql.go:
// func __ptrTo_Tx_StmtContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), stmt *_sql.Stmt}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sql

import (
	_sql "database/sql"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_ColumnType = GoTypeInfo{Members: GoMembers{
	"DatabaseTypeName": __ptrTo_ColumnType_DatabaseTypeName,
	"DecimalSize": __ptrTo_ColumnType_DecimalSize,
	"Length": __ptrTo_ColumnType_Length,
	"Name": __ptrTo_ColumnType_Name,
	"Nullable": __ptrTo_ColumnType_Nullable,
	"ScanType": __ptrTo_ColumnType_ScanType,
}}

var members_PtrTo_Conn = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Conn_Close,
}}

var members_PtrTo_DB = GoTypeInfo{Members: GoMembers{
	"Begin": __ptrTo_DB_Begin,
	"Close": __ptrTo_DB_Close,
	"Driver": __ptrTo_DB_Driver,
	"Ping": __ptrTo_DB_Ping,
	"Prepare": __ptrTo_DB_Prepare,
	"Stats": __ptrTo_DB_Stats,
}}

var members_IsolationLevel = GoTypeInfo{Members: GoMembers{
	"String": __isolationLevel_String,
}}

var members_NullBool = GoTypeInfo{Members: GoMembers{
	"Value": __nullBool_Value,
}}

var members_NullFloat64 = GoTypeInfo{Members: GoMembers{
	"Value": __nullFloat64_Value,
}}

var members_NullInt64 = GoTypeInfo{Members: GoMembers{
	"Value": __nullInt64_Value,
}}

var members_NullString = GoTypeInfo{Members: GoMembers{
	"Value": __nullString_Value,
}}

var members_PtrTo_Rows = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Rows_Close,
	"ColumnTypes": __ptrTo_Rows_ColumnTypes,
	"Columns": __ptrTo_Rows_Columns,
	"Err": __ptrTo_Rows_Err,
	"Next": __ptrTo_Rows_Next,
	"NextResultSet": __ptrTo_Rows_NextResultSet,
}}

var members_PtrTo_Stmt = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Stmt_Close,
}}

var members_PtrTo_Tx = GoTypeInfo{Members: GoMembers{
	"Commit": __ptrTo_Tx_Commit,
	"Prepare": __ptrTo_Tx_Prepare,
	"Rollback": __ptrTo_Tx_Rollback,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_sql.ColumnType)(nil))] = &members_PtrTo_ColumnType
	GoTypes[_reflect.TypeOf((*_sql.Conn)(nil))] = &members_PtrTo_Conn
	GoTypes[_reflect.TypeOf((*_sql.DB)(nil))] = &members_PtrTo_DB
	GoTypes[_reflect.TypeOf((*_sql.IsolationLevel)(nil)).Elem()] = &members_IsolationLevel
	GoTypes[_reflect.TypeOf((*_sql.NullBool)(nil)).Elem()] = &members_NullBool
	GoTypes[_reflect.TypeOf((*_sql.NullFloat64)(nil)).Elem()] = &members_NullFloat64
	GoTypes[_reflect.TypeOf((*_sql.NullInt64)(nil)).Elem()] = &members_NullInt64
	GoTypes[_reflect.TypeOf((*_sql.NullString)(nil)).Elem()] = &members_NullString
	GoTypes[_reflect.TypeOf((*_sql.Rows)(nil))] = &members_PtrTo_Rows
	GoTypes[_reflect.TypeOf((*_sql.Stmt)(nil))] = &members_PtrTo_Stmt
	GoTypes[_reflect.TypeOf((*_sql.Tx)(nil))] = &members_PtrTo_Tx
}

GO TYPE database/sql/driver.ColumnConverter from database/sql/driver/driver.go:
func ExtractGoObjectColumnConverter(args []Object, index int) *_driver.ColumnConverter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.ColumnConverter:
			return &r
		case *_driver.ColumnConverter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.ColumnConverter]"))
}

// func _ConstructColumnConverter(_v Object) _driver.ColumnConverter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.ColumnConverter:
// 			return _g
// 		case *_driver.ColumnConverter:
// 			return *_g
// 		}
// 	default:
// 		return _driver.ColumnConverter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ColumnConverter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.ColumnConverter] or: whatever"))
// }

GO TYPE database/sql/driver.Conn from database/sql/driver/driver.go:
func ExtractGoObjectConn(args []Object, index int) *_driver.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Conn:
			return &r
		case *_driver.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Conn]"))
}

// func _ConstructConn(_v Object) _driver.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Conn:
// 			return _g
// 		case *_driver.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Conn] or: whatever"))
// }

GO TYPE database/sql/driver.ConnBeginTx from database/sql/driver/driver.go:
func ExtractGoObjectConnBeginTx(args []Object, index int) *_driver.ConnBeginTx {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.ConnBeginTx:
			return &r
		case *_driver.ConnBeginTx:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.ConnBeginTx]"))
}

// func _ConstructConnBeginTx(_v Object) _driver.ConnBeginTx {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.ConnBeginTx:
// 			return _g
// 		case *_driver.ConnBeginTx:
// 			return *_g
// 		}
// 	default:
// 		return _driver.ConnBeginTx(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ConnBeginTx))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.ConnBeginTx] or: whatever"))
// }

GO TYPE database/sql/driver.ConnPrepareContext from database/sql/driver/driver.go:
func ExtractGoObjectConnPrepareContext(args []Object, index int) *_driver.ConnPrepareContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.ConnPrepareContext:
			return &r
		case *_driver.ConnPrepareContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.ConnPrepareContext]"))
}

// func _ConstructConnPrepareContext(_v Object) _driver.ConnPrepareContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.ConnPrepareContext:
// 			return _g
// 		case *_driver.ConnPrepareContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.ConnPrepareContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ConnPrepareContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.ConnPrepareContext] or: whatever"))
// }

GO TYPE database/sql/driver.Connector from database/sql/driver/driver.go:
func ExtractGoObjectConnector(args []Object, index int) *_driver.Connector {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Connector:
			return &r
		case *_driver.Connector:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Connector]"))
}

// func _ConstructConnector(_v Object) _driver.Connector {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Connector:
// 			return _g
// 		case *_driver.Connector:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Connector(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Connector))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Connector] or: whatever"))
// }

GO TYPE database/sql/driver.Driver from database/sql/driver/driver.go:
func ExtractGoObjectDriver(args []Object, index int) *_driver.Driver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Driver:
			return &r
		case *_driver.Driver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Driver]"))
}

// func _ConstructDriver(_v Object) _driver.Driver {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Driver:
// 			return _g
// 		case *_driver.Driver:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Driver(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Driver))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Driver] or: whatever"))
// }

GO TYPE database/sql/driver.DriverContext from database/sql/driver/driver.go:
func ExtractGoObjectDriverContext(args []Object, index int) *_driver.DriverContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.DriverContext:
			return &r
		case *_driver.DriverContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.DriverContext]"))
}

// func _ConstructDriverContext(_v Object) _driver.DriverContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.DriverContext:
// 			return _g
// 		case *_driver.DriverContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.DriverContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for DriverContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.DriverContext] or: whatever"))
// }

GO TYPE database/sql/driver.Execer from database/sql/driver/driver.go:
func ExtractGoObjectExecer(args []Object, index int) *_driver.Execer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Execer:
			return &r
		case *_driver.Execer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Execer]"))
}

// func _ConstructExecer(_v Object) _driver.Execer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Execer:
// 			return _g
// 		case *_driver.Execer:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Execer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Execer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Execer] or: whatever"))
// }

GO TYPE database/sql/driver.ExecerContext from database/sql/driver/driver.go:
func ExtractGoObjectExecerContext(args []Object, index int) *_driver.ExecerContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.ExecerContext:
			return &r
		case *_driver.ExecerContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.ExecerContext]"))
}

// func _ConstructExecerContext(_v Object) _driver.ExecerContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.ExecerContext:
// 			return _g
// 		case *_driver.ExecerContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.ExecerContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ExecerContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.ExecerContext] or: whatever"))
// }

GO TYPE database/sql/driver.IsolationLevel from database/sql/driver/driver.go:
func ExtractGoObjectIsolationLevel(args []Object, index int) *_driver.IsolationLevel {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.IsolationLevel:
			return &r
		case *_driver.IsolationLevel:
			return r
		}
	case Int:
		v := _driver.IsolationLevel(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.IsolationLevel]"))
}

func _ConstructIsolationLevel(_v Object) _driver.IsolationLevel {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _driver.IsolationLevel:
			return _g
		case *_driver.IsolationLevel:
			return *_g
		}
	case Number:
		return _driver.IsolationLevel(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.IsolationLevel] or: Number"))
}

GO TYPE database/sql/driver.NamedValue from database/sql/driver/driver.go:
func ExtractGoObjectNamedValue(args []Object, index int) *_driver.NamedValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.NamedValue:
			return &r
		case *_driver.NamedValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.NamedValue]"))
}

// func _mapToNamedValue(o Map) *_driver.NamedValue {
// 	return &_driver.NamedValue{}
// }

// func _vectorToNamedValue(o *Vector) *_driver.NamedValue {
// 	return &_driver.NamedValue{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Ordinal: AssertInt(o.Nth(1), "").I,
// 		Value: ABEND048(codegen.go: no conversion from Clojure for database/sql/driver.Value (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructNamedValue(_v Object) *_driver.NamedValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.NamedValue:
// 			return &_g
// 		case *_driver.NamedValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNamedValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToNamedValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.NamedValue] or: Map or Vector"))
// }

GO TYPE database/sql/driver.NamedValueChecker from database/sql/driver/driver.go:
func ExtractGoObjectNamedValueChecker(args []Object, index int) *_driver.NamedValueChecker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.NamedValueChecker:
			return &r
		case *_driver.NamedValueChecker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.NamedValueChecker]"))
}

// func _ConstructNamedValueChecker(_v Object) _driver.NamedValueChecker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.NamedValueChecker:
// 			return _g
// 		case *_driver.NamedValueChecker:
// 			return *_g
// 		}
// 	default:
// 		return _driver.NamedValueChecker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for NamedValueChecker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.NamedValueChecker] or: whatever"))
// }

GO TYPE database/sql/driver.NotNull from database/sql/driver/types.go:
func ExtractGoObjectNotNull(args []Object, index int) *_driver.NotNull {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.NotNull:
			return &r
		case *_driver.NotNull:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.NotNull]"))
}

// func _mapToNotNull(o Map) *_driver.NotNull {
// 	return &_driver.NotNull{}
// }

// func _vectorToNotNull(o *Vector) *_driver.NotNull {
// 	return &_driver.NotNull{
// 		Converter: ABEND048(codegen.go: no conversion from Clojure for database/sql/driver.ValueConverter (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructNotNull(_v Object) *_driver.NotNull {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.NotNull:
// 			return &_g
// 		case *_driver.NotNull:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNotNull(_o.(Map))
// 	case *Vector:
// 		return _vectorToNotNull(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.NotNull] or: Map or Vector"))
// }

GO TYPE database/sql/driver.Null from database/sql/driver/types.go:
func ExtractGoObjectNull(args []Object, index int) *_driver.Null {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Null:
			return &r
		case *_driver.Null:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Null]"))
}

// func _mapToNull(o Map) *_driver.Null {
// 	return &_driver.Null{}
// }

// func _vectorToNull(o *Vector) *_driver.Null {
// 	return &_driver.Null{
// 		Converter: ABEND048(codegen.go: no conversion from Clojure for database/sql/driver.ValueConverter (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructNull(_v Object) *_driver.Null {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Null:
// 			return &_g
// 		case *_driver.Null:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNull(_o.(Map))
// 	case *Vector:
// 		return _vectorToNull(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Null] or: Map or Vector"))
// }

GO TYPE database/sql/driver.Pinger from database/sql/driver/driver.go:
func ExtractGoObjectPinger(args []Object, index int) *_driver.Pinger {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Pinger:
			return &r
		case *_driver.Pinger:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Pinger]"))
}

// func _ConstructPinger(_v Object) _driver.Pinger {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Pinger:
// 			return _g
// 		case *_driver.Pinger:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Pinger(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Pinger))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Pinger] or: whatever"))
// }

GO TYPE database/sql/driver.Queryer from database/sql/driver/driver.go:
func ExtractGoObjectQueryer(args []Object, index int) *_driver.Queryer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Queryer:
			return &r
		case *_driver.Queryer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Queryer]"))
}

// func _ConstructQueryer(_v Object) _driver.Queryer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Queryer:
// 			return _g
// 		case *_driver.Queryer:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Queryer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Queryer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Queryer] or: whatever"))
// }

GO TYPE database/sql/driver.QueryerContext from database/sql/driver/driver.go:
func ExtractGoObjectQueryerContext(args []Object, index int) *_driver.QueryerContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.QueryerContext:
			return &r
		case *_driver.QueryerContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.QueryerContext]"))
}

// func _ConstructQueryerContext(_v Object) _driver.QueryerContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.QueryerContext:
// 			return _g
// 		case *_driver.QueryerContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.QueryerContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for QueryerContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.QueryerContext] or: whatever"))
// }

GO TYPE database/sql/driver.Result from database/sql/driver/driver.go:
func ExtractGoObjectResult(args []Object, index int) *_driver.Result {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Result:
			return &r
		case *_driver.Result:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Result]"))
}

// func _ConstructResult(_v Object) _driver.Result {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Result:
// 			return _g
// 		case *_driver.Result:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Result(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Result))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Result] or: whatever"))
// }

GO TYPE database/sql/driver.Rows from database/sql/driver/driver.go:
func ExtractGoObjectRows(args []Object, index int) *_driver.Rows {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Rows:
			return &r
		case *_driver.Rows:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Rows]"))
}

// func _ConstructRows(_v Object) _driver.Rows {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Rows:
// 			return _g
// 		case *_driver.Rows:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Rows(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Rows))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Rows] or: whatever"))
// }

GO TYPE database/sql/driver.RowsAffected from database/sql/driver/driver.go:
func ExtractGoObjectRowsAffected(args []Object, index int) *_driver.RowsAffected {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsAffected:
			return &r
		case *_driver.RowsAffected:
			return r
		}
	case Number:
		v := _driver.RowsAffected(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsAffected]"))
}

func _ConstructRowsAffected(_v Object) _driver.RowsAffected {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _driver.RowsAffected:
			return _g
		case *_driver.RowsAffected:
			return *_g
		}
	case Number:
		return _driver.RowsAffected(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsAffected] or: Number"))
}

GO TYPE database/sql/driver.RowsColumnTypeDatabaseTypeName from database/sql/driver/driver.go:
func ExtractGoObjectRowsColumnTypeDatabaseTypeName(args []Object, index int) *_driver.RowsColumnTypeDatabaseTypeName {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsColumnTypeDatabaseTypeName:
			return &r
		case *_driver.RowsColumnTypeDatabaseTypeName:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsColumnTypeDatabaseTypeName]"))
}

// func _ConstructRowsColumnTypeDatabaseTypeName(_v Object) _driver.RowsColumnTypeDatabaseTypeName {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsColumnTypeDatabaseTypeName:
// 			return _g
// 		case *_driver.RowsColumnTypeDatabaseTypeName:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsColumnTypeDatabaseTypeName(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsColumnTypeDatabaseTypeName))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsColumnTypeDatabaseTypeName] or: whatever"))
// }

GO TYPE database/sql/driver.RowsColumnTypeLength from database/sql/driver/driver.go:
func ExtractGoObjectRowsColumnTypeLength(args []Object, index int) *_driver.RowsColumnTypeLength {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsColumnTypeLength:
			return &r
		case *_driver.RowsColumnTypeLength:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsColumnTypeLength]"))
}

// func _ConstructRowsColumnTypeLength(_v Object) _driver.RowsColumnTypeLength {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsColumnTypeLength:
// 			return _g
// 		case *_driver.RowsColumnTypeLength:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsColumnTypeLength(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsColumnTypeLength))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsColumnTypeLength] or: whatever"))
// }

GO TYPE database/sql/driver.RowsColumnTypeNullable from database/sql/driver/driver.go:
func ExtractGoObjectRowsColumnTypeNullable(args []Object, index int) *_driver.RowsColumnTypeNullable {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsColumnTypeNullable:
			return &r
		case *_driver.RowsColumnTypeNullable:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsColumnTypeNullable]"))
}

// func _ConstructRowsColumnTypeNullable(_v Object) _driver.RowsColumnTypeNullable {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsColumnTypeNullable:
// 			return _g
// 		case *_driver.RowsColumnTypeNullable:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsColumnTypeNullable(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsColumnTypeNullable))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsColumnTypeNullable] or: whatever"))
// }

GO TYPE database/sql/driver.RowsColumnTypePrecisionScale from database/sql/driver/driver.go:
func ExtractGoObjectRowsColumnTypePrecisionScale(args []Object, index int) *_driver.RowsColumnTypePrecisionScale {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsColumnTypePrecisionScale:
			return &r
		case *_driver.RowsColumnTypePrecisionScale:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsColumnTypePrecisionScale]"))
}

// func _ConstructRowsColumnTypePrecisionScale(_v Object) _driver.RowsColumnTypePrecisionScale {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsColumnTypePrecisionScale:
// 			return _g
// 		case *_driver.RowsColumnTypePrecisionScale:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsColumnTypePrecisionScale(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsColumnTypePrecisionScale))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsColumnTypePrecisionScale] or: whatever"))
// }

GO TYPE database/sql/driver.RowsColumnTypeScanType from database/sql/driver/driver.go:
func ExtractGoObjectRowsColumnTypeScanType(args []Object, index int) *_driver.RowsColumnTypeScanType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsColumnTypeScanType:
			return &r
		case *_driver.RowsColumnTypeScanType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsColumnTypeScanType]"))
}

// func _ConstructRowsColumnTypeScanType(_v Object) _driver.RowsColumnTypeScanType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsColumnTypeScanType:
// 			return _g
// 		case *_driver.RowsColumnTypeScanType:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsColumnTypeScanType(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsColumnTypeScanType))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsColumnTypeScanType] or: whatever"))
// }

GO TYPE database/sql/driver.RowsNextResultSet from database/sql/driver/driver.go:
func ExtractGoObjectRowsNextResultSet(args []Object, index int) *_driver.RowsNextResultSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.RowsNextResultSet:
			return &r
		case *_driver.RowsNextResultSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.RowsNextResultSet]"))
}

// func _ConstructRowsNextResultSet(_v Object) _driver.RowsNextResultSet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.RowsNextResultSet:
// 			return _g
// 		case *_driver.RowsNextResultSet:
// 			return *_g
// 		}
// 	default:
// 		return _driver.RowsNextResultSet(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RowsNextResultSet))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.RowsNextResultSet] or: whatever"))
// }

GO TYPE database/sql/driver.SessionResetter from database/sql/driver/driver.go:
func ExtractGoObjectSessionResetter(args []Object, index int) *_driver.SessionResetter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.SessionResetter:
			return &r
		case *_driver.SessionResetter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.SessionResetter]"))
}

// func _ConstructSessionResetter(_v Object) _driver.SessionResetter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.SessionResetter:
// 			return _g
// 		case *_driver.SessionResetter:
// 			return *_g
// 		}
// 	default:
// 		return _driver.SessionResetter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for SessionResetter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.SessionResetter] or: whatever"))
// }

GO TYPE database/sql/driver.Stmt from database/sql/driver/driver.go:
func ExtractGoObjectStmt(args []Object, index int) *_driver.Stmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Stmt:
			return &r
		case *_driver.Stmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Stmt]"))
}

// func _ConstructStmt(_v Object) _driver.Stmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Stmt:
// 			return _g
// 		case *_driver.Stmt:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Stmt(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Stmt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Stmt] or: whatever"))
// }

GO TYPE database/sql/driver.StmtExecContext from database/sql/driver/driver.go:
func ExtractGoObjectStmtExecContext(args []Object, index int) *_driver.StmtExecContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.StmtExecContext:
			return &r
		case *_driver.StmtExecContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.StmtExecContext]"))
}

// func _ConstructStmtExecContext(_v Object) _driver.StmtExecContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.StmtExecContext:
// 			return _g
// 		case *_driver.StmtExecContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.StmtExecContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for StmtExecContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.StmtExecContext] or: whatever"))
// }

GO TYPE database/sql/driver.StmtQueryContext from database/sql/driver/driver.go:
func ExtractGoObjectStmtQueryContext(args []Object, index int) *_driver.StmtQueryContext {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.StmtQueryContext:
			return &r
		case *_driver.StmtQueryContext:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.StmtQueryContext]"))
}

// func _ConstructStmtQueryContext(_v Object) _driver.StmtQueryContext {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.StmtQueryContext:
// 			return _g
// 		case *_driver.StmtQueryContext:
// 			return *_g
// 		}
// 	default:
// 		return _driver.StmtQueryContext(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for StmtQueryContext))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.StmtQueryContext] or: whatever"))
// }

GO TYPE database/sql/driver.Tx from database/sql/driver/driver.go:
func ExtractGoObjectTx(args []Object, index int) *_driver.Tx {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Tx:
			return &r
		case *_driver.Tx:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Tx]"))
}

// func _ConstructTx(_v Object) _driver.Tx {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Tx:
// 			return _g
// 		case *_driver.Tx:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Tx(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Tx))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Tx] or: whatever"))
// }

GO TYPE database/sql/driver.TxOptions from database/sql/driver/driver.go:
func ExtractGoObjectTxOptions(args []Object, index int) *_driver.TxOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.TxOptions:
			return &r
		case *_driver.TxOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.TxOptions]"))
}

func _mapToTxOptions(o Map) *_driver.TxOptions {
	return &_driver.TxOptions{}
}

func _vectorToTxOptions(o *Vector) *_driver.TxOptions {
	return &_driver.TxOptions{
		Isolation: _driver.IsolationLevel(AssertInt(o.Nth(0), "").I),
		ReadOnly: ToBool(o.Nth(1)),
	}
}

func _ConstructTxOptions(_v Object) *_driver.TxOptions {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _driver.TxOptions:
			return &_g
		case *_driver.TxOptions:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTxOptions(_o.(Map))
	case *Vector:
		return _vectorToTxOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.TxOptions] or: Map or Vector"))
}

GO TYPE database/sql/driver.Value from database/sql/driver/driver.go:
func ExtractGoObjectValue(args []Object, index int) *_driver.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Value:
			return &r
		case *_driver.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Value]"))
}

// func _ConstructValue(_v Object) _driver.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Value:
// 			return _g
// 		case *_driver.Value:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Value(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Value))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Value] or: whatever"))
// }

GO TYPE database/sql/driver.ValueConverter from database/sql/driver/types.go:
func ExtractGoObjectValueConverter(args []Object, index int) *_driver.ValueConverter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.ValueConverter:
			return &r
		case *_driver.ValueConverter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.ValueConverter]"))
}

// func _ConstructValueConverter(_v Object) _driver.ValueConverter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.ValueConverter:
// 			return _g
// 		case *_driver.ValueConverter:
// 			return *_g
// 		}
// 	default:
// 		return _driver.ValueConverter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ValueConverter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.ValueConverter] or: whatever"))
// }

GO TYPE database/sql/driver.Valuer from database/sql/driver/types.go:
func ExtractGoObjectValuer(args []Object, index int) *_driver.Valuer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _driver.Valuer:
			return &r
		case *_driver.Valuer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[database/sql/driver.Valuer]"))
}

// func _ConstructValuer(_v Object) _driver.Valuer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _driver.Valuer:
// 			return _g
// 		case *_driver.Valuer:
// 			return *_g
// 		}
// 	default:
// 		return _driver.Valuer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Valuer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[driver.Valuer] or: whatever"))
// }

GO FUNC database/sql/driver.IsScanValue from database/sql/driver/types.go:
// func __isScanValue(v interface {})  {
// 	_res := _driver.IsScanValue(v)
// 	return MakeBoolean(_res)
// }

GO FUNC database/sql/driver.IsValue from database/sql/driver/types.go:
// func __isValue(v interface {})  {
// 	_res := _driver.IsValue(v)
// 	return MakeBoolean(_res)
// }

GO FUNC database/sql/driver.__notNull_ConvertValue from database/sql/driver/types.go:
// func __notNull_ConvertValue(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql/driver.__null_ConvertValue from database/sql/driver/types.go:
// func __null_ConvertValue(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC database/sql/driver.__rowsAffected_LastInsertId from database/sql/driver/driver.go:
func __rowsAffected_LastInsertId(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql/driver.RowsAffected)LastInsertId()", args, 0, 0)
	_res1, _res2 := o.O.(_driver.RowsAffected).LastInsertId()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql/driver.__rowsAffected_RowsAffected from database/sql/driver/driver.go:
func __rowsAffected_RowsAffected(o GoObject, args Object) Object {
	CheckGoArity("(_database/sql/driver.RowsAffected)RowsAffected()", args, 0, 0)
	_res1, _res2 := o.O.(_driver.RowsAffected).RowsAffected()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package driver

import (
	_driver "database/sql/driver"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_RowsAffected = GoTypeInfo{Members: GoMembers{
	"LastInsertId": __rowsAffected_LastInsertId,
	"RowsAffected": __rowsAffected_RowsAffected,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_driver.RowsAffected)(nil)).Elem()] = &members_RowsAffected
}

GO TYPE debug/dwarf.AddrType from debug/dwarf/type.go:
func ExtractGoObjectAddrType(args []Object, index int) *_dwarf.AddrType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.AddrType:
			return &r
		case *_dwarf.AddrType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.AddrType]"))
}

func _mapToAddrType(o Map) *_dwarf.AddrType {
	return &_dwarf.AddrType{}
}

func _vectorToAddrType(o *Vector) *_dwarf.AddrType {
	return &_dwarf.AddrType{}
}

func _ConstructAddrType(_v Object) *_dwarf.AddrType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.AddrType:
			return &_g
		case *_dwarf.AddrType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrType(_o.(Map))
	case *Vector:
		return _vectorToAddrType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.AddrType] or: Map or Vector"))
}

GO TYPE debug/dwarf.ArrayType from debug/dwarf/type.go:
func ExtractGoObjectArrayType(args []Object, index int) *_dwarf.ArrayType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.ArrayType:
			return &r
		case *_dwarf.ArrayType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.ArrayType]"))
}

// func _mapToArrayType(o Map) *_dwarf.ArrayType {
// 	return &_dwarf.ArrayType{}
// }

// func _vectorToArrayType(o *Vector) *_dwarf.ArrayType {
// 	return &_dwarf.ArrayType{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		StrideBitSize: AssertNumber(o.Nth(1), "").BigInt().Int64(),
// 		Count: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 	}
// }

// func _ConstructArrayType(_v Object) *_dwarf.ArrayType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.ArrayType:
// 			return &_g
// 		case *_dwarf.ArrayType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToArrayType(_o.(Map))
// 	case *Vector:
// 		return _vectorToArrayType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.ArrayType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.Attr from debug/dwarf/const.go:
func ExtractGoObjectAttr(args []Object, index int) *_dwarf.Attr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Attr:
			return &r
		case *_dwarf.Attr:
			return r
		}
	case Number:
		v := _dwarf.Attr(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Attr]"))
}

func _ConstructAttr(_v Object) _dwarf.Attr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Attr:
			return _g
		case *_dwarf.Attr:
			return *_g
		}
	case Number:
		return _dwarf.Attr(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Attr] or: Number"))
}

GO TYPE debug/dwarf.BasicType from debug/dwarf/type.go:
func ExtractGoObjectBasicType(args []Object, index int) *_dwarf.BasicType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.BasicType:
			return &r
		case *_dwarf.BasicType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.BasicType]"))
}

func _mapToBasicType(o Map) *_dwarf.BasicType {
	return &_dwarf.BasicType{}
}

func _vectorToBasicType(o *Vector) *_dwarf.BasicType {
	return &_dwarf.BasicType{
		BitSize: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		BitOffset: AssertNumber(o.Nth(1), "").BigInt().Int64(),
	}
}

func _ConstructBasicType(_v Object) *_dwarf.BasicType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.BasicType:
			return &_g
		case *_dwarf.BasicType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBasicType(_o.(Map))
	case *Vector:
		return _vectorToBasicType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.BasicType] or: Map or Vector"))
}

GO TYPE debug/dwarf.BoolType from debug/dwarf/type.go:
func ExtractGoObjectBoolType(args []Object, index int) *_dwarf.BoolType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.BoolType:
			return &r
		case *_dwarf.BoolType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.BoolType]"))
}

func _mapToBoolType(o Map) *_dwarf.BoolType {
	return &_dwarf.BoolType{}
}

func _vectorToBoolType(o *Vector) *_dwarf.BoolType {
	return &_dwarf.BoolType{}
}

func _ConstructBoolType(_v Object) *_dwarf.BoolType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.BoolType:
			return &_g
		case *_dwarf.BoolType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBoolType(_o.(Map))
	case *Vector:
		return _vectorToBoolType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.BoolType] or: Map or Vector"))
}

GO TYPE debug/dwarf.CharType from debug/dwarf/type.go:
func ExtractGoObjectCharType(args []Object, index int) *_dwarf.CharType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.CharType:
			return &r
		case *_dwarf.CharType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.CharType]"))
}

func _mapToCharType(o Map) *_dwarf.CharType {
	return &_dwarf.CharType{}
}

func _vectorToCharType(o *Vector) *_dwarf.CharType {
	return &_dwarf.CharType{}
}

func _ConstructCharType(_v Object) *_dwarf.CharType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.CharType:
			return &_g
		case *_dwarf.CharType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCharType(_o.(Map))
	case *Vector:
		return _vectorToCharType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.CharType] or: Map or Vector"))
}

GO TYPE debug/dwarf.Class from debug/dwarf/entry.go:
func ExtractGoObjectClass(args []Object, index int) *_dwarf.Class {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Class:
			return &r
		case *_dwarf.Class:
			return r
		}
	case Int:
		v := _dwarf.Class(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Class]"))
}

func _ConstructClass(_v Object) _dwarf.Class {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Class:
			return _g
		case *_dwarf.Class:
			return *_g
		}
	case Number:
		return _dwarf.Class(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Class] or: Number"))
}

GO TYPE debug/dwarf.CommonType from debug/dwarf/type.go:
func ExtractGoObjectCommonType(args []Object, index int) *_dwarf.CommonType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.CommonType:
			return &r
		case *_dwarf.CommonType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.CommonType]"))
}

func _mapToCommonType(o Map) *_dwarf.CommonType {
	return &_dwarf.CommonType{}
}

func _vectorToCommonType(o *Vector) *_dwarf.CommonType {
	return &_dwarf.CommonType{
		ByteSize: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Name: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructCommonType(_v Object) *_dwarf.CommonType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.CommonType:
			return &_g
		case *_dwarf.CommonType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCommonType(_o.(Map))
	case *Vector:
		return _vectorToCommonType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.CommonType] or: Map or Vector"))
}

GO TYPE debug/dwarf.ComplexType from debug/dwarf/type.go:
func ExtractGoObjectComplexType(args []Object, index int) *_dwarf.ComplexType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.ComplexType:
			return &r
		case *_dwarf.ComplexType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.ComplexType]"))
}

func _mapToComplexType(o Map) *_dwarf.ComplexType {
	return &_dwarf.ComplexType{}
}

func _vectorToComplexType(o *Vector) *_dwarf.ComplexType {
	return &_dwarf.ComplexType{}
}

func _ConstructComplexType(_v Object) *_dwarf.ComplexType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.ComplexType:
			return &_g
		case *_dwarf.ComplexType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToComplexType(_o.(Map))
	case *Vector:
		return _vectorToComplexType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.ComplexType] or: Map or Vector"))
}

GO TYPE debug/dwarf.Data from debug/dwarf/open.go:
func ExtractGoObjectData(args []Object, index int) *_dwarf.Data {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Data:
			return &r
		case *_dwarf.Data:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Data]"))
}

func _mapToData(o Map) *_dwarf.Data {
	return &_dwarf.Data{}
}

func _vectorToData(o *Vector) *_dwarf.Data {
	return &_dwarf.Data{}
}

func _ConstructData(_v Object) *_dwarf.Data {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Data:
			return &_g
		case *_dwarf.Data:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToData(_o.(Map))
	case *Vector:
		return _vectorToData(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Data] or: Map or Vector"))
}

GO TYPE debug/dwarf.DecodeError from debug/dwarf/buf.go:
func ExtractGoObjectDecodeError(args []Object, index int) *_dwarf.DecodeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.DecodeError:
			return &r
		case *_dwarf.DecodeError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.DecodeError]"))
}

func _mapToDecodeError(o Map) *_dwarf.DecodeError {
	return &_dwarf.DecodeError{}
}

func _vectorToDecodeError(o *Vector) *_dwarf.DecodeError {
	return &_dwarf.DecodeError{
		Name: AssertString(o.Nth(0), "").S,
		Offset: _dwarf.Offset(uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64())),
		Err: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructDecodeError(_v Object) *_dwarf.DecodeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.DecodeError:
			return &_g
		case *_dwarf.DecodeError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDecodeError(_o.(Map))
	case *Vector:
		return _vectorToDecodeError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.DecodeError] or: Map or Vector"))
}

GO TYPE debug/dwarf.DotDotDotType from debug/dwarf/type.go:
func ExtractGoObjectDotDotDotType(args []Object, index int) *_dwarf.DotDotDotType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.DotDotDotType:
			return &r
		case *_dwarf.DotDotDotType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.DotDotDotType]"))
}

func _mapToDotDotDotType(o Map) *_dwarf.DotDotDotType {
	return &_dwarf.DotDotDotType{}
}

func _vectorToDotDotDotType(o *Vector) *_dwarf.DotDotDotType {
	return &_dwarf.DotDotDotType{}
}

func _ConstructDotDotDotType(_v Object) *_dwarf.DotDotDotType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.DotDotDotType:
			return &_g
		case *_dwarf.DotDotDotType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDotDotDotType(_o.(Map))
	case *Vector:
		return _vectorToDotDotDotType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.DotDotDotType] or: Map or Vector"))
}

GO TYPE debug/dwarf.Entry from debug/dwarf/entry.go:
func ExtractGoObjectEntry(args []Object, index int) *_dwarf.Entry {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Entry:
			return &r
		case *_dwarf.Entry:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Entry]"))
}

// func _mapToEntry(o Map) *_dwarf.Entry {
// 	return &_dwarf.Entry{}
// }

// func _vectorToEntry(o *Vector) *_dwarf.Entry {
// 	return &_dwarf.Entry{
// 		Offset: _dwarf.Offset(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
// 		Tag: _dwarf.Tag(uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64())),
// 		Children: ToBool(o.Nth(2)),
// 		Field: ABEND048(codegen.go: no conversion from Clojure for []debug/dwarf.Field (debug/dwarf.Field)),
// 	}
// }

// func _ConstructEntry(_v Object) *_dwarf.Entry {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.Entry:
// 			return &_g
// 		case *_dwarf.Entry:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEntry(_o.(Map))
// 	case *Vector:
// 		return _vectorToEntry(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Entry] or: Map or Vector"))
// }

GO TYPE debug/dwarf.EnumType from debug/dwarf/type.go:
func ExtractGoObjectEnumType(args []Object, index int) *_dwarf.EnumType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.EnumType:
			return &r
		case *_dwarf.EnumType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.EnumType]"))
}

// func _mapToEnumType(o Map) *_dwarf.EnumType {
// 	return &_dwarf.EnumType{}
// }

// func _vectorToEnumType(o *Vector) *_dwarf.EnumType {
// 	return &_dwarf.EnumType{
// 		EnumName: AssertString(o.Nth(0), "").S,
// 		Val: ABEND048(codegen.go: no conversion from Clojure for []*debug/dwarf.EnumValue (*debug/dwarf.EnumValue)),
// 	}
// }

// func _ConstructEnumType(_v Object) *_dwarf.EnumType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.EnumType:
// 			return &_g
// 		case *_dwarf.EnumType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEnumType(_o.(Map))
// 	case *Vector:
// 		return _vectorToEnumType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.EnumType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.EnumValue from debug/dwarf/type.go:
func ExtractGoObjectEnumValue(args []Object, index int) *_dwarf.EnumValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.EnumValue:
			return &r
		case *_dwarf.EnumValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.EnumValue]"))
}

func _mapToEnumValue(o Map) *_dwarf.EnumValue {
	return &_dwarf.EnumValue{}
}

func _vectorToEnumValue(o *Vector) *_dwarf.EnumValue {
	return &_dwarf.EnumValue{
		Name: AssertString(o.Nth(0), "").S,
		Val: AssertNumber(o.Nth(1), "").BigInt().Int64(),
	}
}

func _ConstructEnumValue(_v Object) *_dwarf.EnumValue {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.EnumValue:
			return &_g
		case *_dwarf.EnumValue:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEnumValue(_o.(Map))
	case *Vector:
		return _vectorToEnumValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.EnumValue] or: Map or Vector"))
}

GO TYPE debug/dwarf.Field from debug/dwarf/entry.go:
func ExtractGoObjectField(args []Object, index int) *_dwarf.Field {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Field:
			return &r
		case *_dwarf.Field:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Field]"))
}

// func _mapToField(o Map) *_dwarf.Field {
// 	return &_dwarf.Field{}
// }

// func _vectorToField(o *Vector) *_dwarf.Field {
// 	return &_dwarf.Field{
// 		Attr: _dwarf.Attr(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
// 		Val: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Class: _dwarf.Class(AssertInt(o.Nth(2), "").I),
// 	}
// }

// func _ConstructField(_v Object) *_dwarf.Field {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.Field:
// 			return &_g
// 		case *_dwarf.Field:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToField(_o.(Map))
// 	case *Vector:
// 		return _vectorToField(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Field] or: Map or Vector"))
// }

GO TYPE debug/dwarf.FloatType from debug/dwarf/type.go:
func ExtractGoObjectFloatType(args []Object, index int) *_dwarf.FloatType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.FloatType:
			return &r
		case *_dwarf.FloatType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.FloatType]"))
}

func _mapToFloatType(o Map) *_dwarf.FloatType {
	return &_dwarf.FloatType{}
}

func _vectorToFloatType(o *Vector) *_dwarf.FloatType {
	return &_dwarf.FloatType{}
}

func _ConstructFloatType(_v Object) *_dwarf.FloatType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.FloatType:
			return &_g
		case *_dwarf.FloatType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFloatType(_o.(Map))
	case *Vector:
		return _vectorToFloatType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.FloatType] or: Map or Vector"))
}

GO TYPE debug/dwarf.FuncType from debug/dwarf/type.go:
func ExtractGoObjectFuncType(args []Object, index int) *_dwarf.FuncType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.FuncType:
			return &r
		case *_dwarf.FuncType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.FuncType]"))
}

// func _mapToFuncType(o Map) *_dwarf.FuncType {
// 	return &_dwarf.FuncType{}
// }

// func _vectorToFuncType(o *Vector) *_dwarf.FuncType {
// 	return &_dwarf.FuncType{
// 		ReturnType: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		ParamType: ABEND048(codegen.go: no conversion from Clojure for []debug/dwarf.Type (debug/dwarf.Type)),
// 	}
// }

// func _ConstructFuncType(_v Object) *_dwarf.FuncType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.FuncType:
// 			return &_g
// 		case *_dwarf.FuncType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFuncType(_o.(Map))
// 	case *Vector:
// 		return _vectorToFuncType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.FuncType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.IntType from debug/dwarf/type.go:
func ExtractGoObjectIntType(args []Object, index int) *_dwarf.IntType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.IntType:
			return &r
		case *_dwarf.IntType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.IntType]"))
}

func _mapToIntType(o Map) *_dwarf.IntType {
	return &_dwarf.IntType{}
}

func _vectorToIntType(o *Vector) *_dwarf.IntType {
	return &_dwarf.IntType{}
}

func _ConstructIntType(_v Object) *_dwarf.IntType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.IntType:
			return &_g
		case *_dwarf.IntType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIntType(_o.(Map))
	case *Vector:
		return _vectorToIntType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.IntType] or: Map or Vector"))
}

GO TYPE debug/dwarf.LineEntry from debug/dwarf/line.go:
func ExtractGoObjectLineEntry(args []Object, index int) *_dwarf.LineEntry {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.LineEntry:
			return &r
		case *_dwarf.LineEntry:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.LineEntry]"))
}

// func _mapToLineEntry(o Map) *_dwarf.LineEntry {
// 	return &_dwarf.LineEntry{}
// }

// func _vectorToLineEntry(o *Vector) *_dwarf.LineEntry {
// 	return &_dwarf.LineEntry{
// 		Address: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		OpIndex: AssertInt(o.Nth(1), "").I,
// 		File: ABEND048(codegen.go: no conversion from Clojure for *debug/dwarf.LineFile (debug/dwarf.LineFile)),
// 		Line: AssertInt(o.Nth(3), "").I,
// 		Column: AssertInt(o.Nth(4), "").I,
// 		IsStmt: ToBool(o.Nth(5)),
// 		BasicBlock: ToBool(o.Nth(6)),
// 		PrologueEnd: ToBool(o.Nth(7)),
// 		EpilogueBegin: ToBool(o.Nth(8)),
// 		ISA: AssertInt(o.Nth(9), "").I,
// 		Discriminator: AssertInt(o.Nth(10), "").I,
// 		EndSequence: ToBool(o.Nth(11)),
// 	}
// }

// func _ConstructLineEntry(_v Object) *_dwarf.LineEntry {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.LineEntry:
// 			return &_g
// 		case *_dwarf.LineEntry:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToLineEntry(_o.(Map))
// 	case *Vector:
// 		return _vectorToLineEntry(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.LineEntry] or: Map or Vector"))
// }

GO TYPE debug/dwarf.LineFile from debug/dwarf/line.go:
func ExtractGoObjectLineFile(args []Object, index int) *_dwarf.LineFile {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.LineFile:
			return &r
		case *_dwarf.LineFile:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.LineFile]"))
}

func _mapToLineFile(o Map) *_dwarf.LineFile {
	return &_dwarf.LineFile{}
}

func _vectorToLineFile(o *Vector) *_dwarf.LineFile {
	return &_dwarf.LineFile{
		Name: AssertString(o.Nth(0), "").S,
		Mtime: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Length: AssertInt(o.Nth(2), "").I,
	}
}

func _ConstructLineFile(_v Object) *_dwarf.LineFile {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.LineFile:
			return &_g
		case *_dwarf.LineFile:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLineFile(_o.(Map))
	case *Vector:
		return _vectorToLineFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.LineFile] or: Map or Vector"))
}

GO TYPE debug/dwarf.LineReader from debug/dwarf/line.go:
func ExtractGoObjectLineReader(args []Object, index int) *_dwarf.LineReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.LineReader:
			return &r
		case *_dwarf.LineReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.LineReader]"))
}

func _mapToLineReader(o Map) *_dwarf.LineReader {
	return &_dwarf.LineReader{}
}

func _vectorToLineReader(o *Vector) *_dwarf.LineReader {
	return &_dwarf.LineReader{}
}

func _ConstructLineReader(_v Object) *_dwarf.LineReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.LineReader:
			return &_g
		case *_dwarf.LineReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLineReader(_o.(Map))
	case *Vector:
		return _vectorToLineReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.LineReader] or: Map or Vector"))
}

GO TYPE debug/dwarf.LineReaderPos from debug/dwarf/line.go:
func ExtractGoObjectLineReaderPos(args []Object, index int) *_dwarf.LineReaderPos {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.LineReaderPos:
			return &r
		case *_dwarf.LineReaderPos:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.LineReaderPos]"))
}

func _mapToLineReaderPos(o Map) *_dwarf.LineReaderPos {
	return &_dwarf.LineReaderPos{}
}

func _vectorToLineReaderPos(o *Vector) *_dwarf.LineReaderPos {
	return &_dwarf.LineReaderPos{}
}

func _ConstructLineReaderPos(_v Object) *_dwarf.LineReaderPos {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.LineReaderPos:
			return &_g
		case *_dwarf.LineReaderPos:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLineReaderPos(_o.(Map))
	case *Vector:
		return _vectorToLineReaderPos(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.LineReaderPos] or: Map or Vector"))
}

GO TYPE debug/dwarf.Offset from debug/dwarf/entry.go:
func ExtractGoObjectOffset(args []Object, index int) *_dwarf.Offset {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Offset:
			return &r
		case *_dwarf.Offset:
			return r
		}
	case Number:
		v := _dwarf.Offset(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Offset]"))
}

func _ConstructOffset(_v Object) _dwarf.Offset {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Offset:
			return _g
		case *_dwarf.Offset:
			return *_g
		}
	case Number:
		return _dwarf.Offset(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Offset] or: Number"))
}

GO TYPE debug/dwarf.PtrType from debug/dwarf/type.go:
func ExtractGoObjectPtrType(args []Object, index int) *_dwarf.PtrType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.PtrType:
			return &r
		case *_dwarf.PtrType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.PtrType]"))
}

// func _mapToPtrType(o Map) *_dwarf.PtrType {
// 	return &_dwarf.PtrType{}
// }

// func _vectorToPtrType(o *Vector) *_dwarf.PtrType {
// 	return &_dwarf.PtrType{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructPtrType(_v Object) *_dwarf.PtrType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.PtrType:
// 			return &_g
// 		case *_dwarf.PtrType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPtrType(_o.(Map))
// 	case *Vector:
// 		return _vectorToPtrType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.PtrType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.QualType from debug/dwarf/type.go:
func ExtractGoObjectQualType(args []Object, index int) *_dwarf.QualType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.QualType:
			return &r
		case *_dwarf.QualType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.QualType]"))
}

// func _mapToQualType(o Map) *_dwarf.QualType {
// 	return &_dwarf.QualType{}
// }

// func _vectorToQualType(o *Vector) *_dwarf.QualType {
// 	return &_dwarf.QualType{
// 		Qual: AssertString(o.Nth(0), "").S,
// 		Type: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructQualType(_v Object) *_dwarf.QualType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.QualType:
// 			return &_g
// 		case *_dwarf.QualType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToQualType(_o.(Map))
// 	case *Vector:
// 		return _vectorToQualType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.QualType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.Reader from debug/dwarf/entry.go:
func ExtractGoObjectReader(args []Object, index int) *_dwarf.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Reader:
			return &r
		case *_dwarf.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Reader]"))
}

func _mapToReader(o Map) *_dwarf.Reader {
	return &_dwarf.Reader{}
}

func _vectorToReader(o *Vector) *_dwarf.Reader {
	return &_dwarf.Reader{}
}

func _ConstructReader(_v Object) *_dwarf.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Reader:
			return &_g
		case *_dwarf.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Reader] or: Map or Vector"))
}

GO TYPE debug/dwarf.StructField from debug/dwarf/type.go:
func ExtractGoObjectStructField(args []Object, index int) *_dwarf.StructField {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.StructField:
			return &r
		case *_dwarf.StructField:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.StructField]"))
}

// func _mapToStructField(o Map) *_dwarf.StructField {
// 	return &_dwarf.StructField{}
// }

// func _vectorToStructField(o *Vector) *_dwarf.StructField {
// 	return &_dwarf.StructField{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Type: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		ByteOffset: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 		ByteSize: AssertNumber(o.Nth(3), "").BigInt().Int64(),
// 		BitOffset: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		BitSize: AssertNumber(o.Nth(5), "").BigInt().Int64(),
// 	}
// }

// func _ConstructStructField(_v Object) *_dwarf.StructField {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.StructField:
// 			return &_g
// 		case *_dwarf.StructField:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStructField(_o.(Map))
// 	case *Vector:
// 		return _vectorToStructField(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.StructField] or: Map or Vector"))
// }

GO TYPE debug/dwarf.StructType from debug/dwarf/type.go:
func ExtractGoObjectStructType(args []Object, index int) *_dwarf.StructType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.StructType:
			return &r
		case *_dwarf.StructType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.StructType]"))
}

// func _mapToStructType(o Map) *_dwarf.StructType {
// 	return &_dwarf.StructType{}
// }

// func _vectorToStructType(o *Vector) *_dwarf.StructType {
// 	return &_dwarf.StructType{
// 		StructName: AssertString(o.Nth(0), "").S,
// 		Kind: AssertString(o.Nth(1), "").S,
// 		Field: ABEND048(codegen.go: no conversion from Clojure for []*debug/dwarf.StructField (*debug/dwarf.StructField)),
// 		Incomplete: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructStructType(_v Object) *_dwarf.StructType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.StructType:
// 			return &_g
// 		case *_dwarf.StructType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStructType(_o.(Map))
// 	case *Vector:
// 		return _vectorToStructType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.StructType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.Tag from debug/dwarf/const.go:
func ExtractGoObjectTag(args []Object, index int) *_dwarf.Tag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Tag:
			return &r
		case *_dwarf.Tag:
			return r
		}
	case Number:
		v := _dwarf.Tag(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Tag]"))
}

func _ConstructTag(_v Object) _dwarf.Tag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.Tag:
			return _g
		case *_dwarf.Tag:
			return *_g
		}
	case Number:
		return _dwarf.Tag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Tag] or: Number"))
}

GO TYPE debug/dwarf.Type from debug/dwarf/type.go:
func ExtractGoObjectType(args []Object, index int) *_dwarf.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.Type:
			return &r
		case *_dwarf.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.Type]"))
}

// func _ConstructType(_v Object) _dwarf.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.Type:
// 			return _g
// 		case *_dwarf.Type:
// 			return *_g
// 		}
// 	default:
// 		return _dwarf.Type(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.Type] or: whatever"))
// }

GO TYPE debug/dwarf.TypedefType from debug/dwarf/type.go:
func ExtractGoObjectTypedefType(args []Object, index int) *_dwarf.TypedefType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.TypedefType:
			return &r
		case *_dwarf.TypedefType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.TypedefType]"))
}

// func _mapToTypedefType(o Map) *_dwarf.TypedefType {
// 	return &_dwarf.TypedefType{}
// }

// func _vectorToTypedefType(o *Vector) *_dwarf.TypedefType {
// 	return &_dwarf.TypedefType{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for debug/dwarf.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructTypedefType(_v Object) *_dwarf.TypedefType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _dwarf.TypedefType:
// 			return &_g
// 		case *_dwarf.TypedefType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTypedefType(_o.(Map))
// 	case *Vector:
// 		return _vectorToTypedefType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.TypedefType] or: Map or Vector"))
// }

GO TYPE debug/dwarf.UcharType from debug/dwarf/type.go:
func ExtractGoObjectUcharType(args []Object, index int) *_dwarf.UcharType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.UcharType:
			return &r
		case *_dwarf.UcharType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.UcharType]"))
}

func _mapToUcharType(o Map) *_dwarf.UcharType {
	return &_dwarf.UcharType{}
}

func _vectorToUcharType(o *Vector) *_dwarf.UcharType {
	return &_dwarf.UcharType{}
}

func _ConstructUcharType(_v Object) *_dwarf.UcharType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.UcharType:
			return &_g
		case *_dwarf.UcharType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUcharType(_o.(Map))
	case *Vector:
		return _vectorToUcharType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.UcharType] or: Map or Vector"))
}

GO TYPE debug/dwarf.UintType from debug/dwarf/type.go:
func ExtractGoObjectUintType(args []Object, index int) *_dwarf.UintType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.UintType:
			return &r
		case *_dwarf.UintType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.UintType]"))
}

func _mapToUintType(o Map) *_dwarf.UintType {
	return &_dwarf.UintType{}
}

func _vectorToUintType(o *Vector) *_dwarf.UintType {
	return &_dwarf.UintType{}
}

func _ConstructUintType(_v Object) *_dwarf.UintType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.UintType:
			return &_g
		case *_dwarf.UintType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUintType(_o.(Map))
	case *Vector:
		return _vectorToUintType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.UintType] or: Map or Vector"))
}

GO TYPE debug/dwarf.UnspecifiedType from debug/dwarf/type.go:
func ExtractGoObjectUnspecifiedType(args []Object, index int) *_dwarf.UnspecifiedType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.UnspecifiedType:
			return &r
		case *_dwarf.UnspecifiedType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.UnspecifiedType]"))
}

func _mapToUnspecifiedType(o Map) *_dwarf.UnspecifiedType {
	return &_dwarf.UnspecifiedType{}
}

func _vectorToUnspecifiedType(o *Vector) *_dwarf.UnspecifiedType {
	return &_dwarf.UnspecifiedType{}
}

func _ConstructUnspecifiedType(_v Object) *_dwarf.UnspecifiedType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.UnspecifiedType:
			return &_g
		case *_dwarf.UnspecifiedType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnspecifiedType(_o.(Map))
	case *Vector:
		return _vectorToUnspecifiedType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.UnspecifiedType] or: Map or Vector"))
}

GO TYPE debug/dwarf.VoidType from debug/dwarf/type.go:
func ExtractGoObjectVoidType(args []Object, index int) *_dwarf.VoidType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _dwarf.VoidType:
			return &r
		case *_dwarf.VoidType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/dwarf.VoidType]"))
}

func _mapToVoidType(o Map) *_dwarf.VoidType {
	return &_dwarf.VoidType{}
}

func _vectorToVoidType(o *Vector) *_dwarf.VoidType {
	return &_dwarf.VoidType{}
}

func _ConstructVoidType(_v Object) *_dwarf.VoidType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _dwarf.VoidType:
			return &_g
		case *_dwarf.VoidType:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToVoidType(_o.(Map))
	case *Vector:
		return _vectorToVoidType(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[dwarf.VoidType] or: Map or Vector"))
}

GO FUNC debug/dwarf.New from debug/dwarf/open.go:
// func __new(abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte) Object {
// 	_res1, _res2 := _dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/dwarf.__attr_GoString from debug/dwarf/const.go:
func __attr_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Attr)GoString()", args, 0, 0)
	_res := o.O.(_dwarf.Attr).GoString()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__attr_String from debug/dwarf/attr_string.go:
func __attr_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Attr)String()", args, 0, 0)
	_res := o.O.(_dwarf.Attr).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__class_GoString from debug/dwarf/entry.go:
func __class_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Class)GoString()", args, 0, 0)
	_res := o.O.(_dwarf.Class).GoString()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__class_String from debug/dwarf/class_string.go:
func __class_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Class)String()", args, 0, 0)
	_res := o.O.(_dwarf.Class).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__decodeError_Error from debug/dwarf/buf.go:
func __decodeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.DecodeError)Error()", args, 0, 0)
	_res := o.O.(_dwarf.DecodeError).Error()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_ArrayType_Size from debug/dwarf/type.go:
func __ptrTo_ArrayType_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.ArrayType)Size()", args, 0, 0)
	_res := o.O.(*_dwarf.ArrayType).Size()
	return MakeBigInt(_res)
}

GO FUNC debug/dwarf.__ptrTo_ArrayType_String from debug/dwarf/type.go:
func __ptrTo_ArrayType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.ArrayType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.ArrayType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_BasicType_Basic from debug/dwarf/type.go:
func __ptrTo_BasicType_Basic(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.BasicType)Basic()", args, 0, 0)
	_res := o.O.(*_dwarf.BasicType).Basic()
	return MakeGoObject(_res)
}

GO FUNC debug/dwarf.__ptrTo_BasicType_String from debug/dwarf/type.go:
func __ptrTo_BasicType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.BasicType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.BasicType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_CommonType_Common from debug/dwarf/type.go:
func __ptrTo_CommonType_Common(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.CommonType)Common()", args, 0, 0)
	_res := o.O.(*_dwarf.CommonType).Common()
	return MakeGoObject(_res)
}

GO FUNC debug/dwarf.__ptrTo_CommonType_Size from debug/dwarf/type.go:
func __ptrTo_CommonType_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.CommonType)Size()", args, 0, 0)
	_res := o.O.(*_dwarf.CommonType).Size()
	return MakeBigInt(_res)
}

GO FUNC debug/dwarf.__ptrTo_Data_AddTypes from debug/dwarf/open.go:
// func __ptrTo_Data_AddTypes(o GoObject, args Object) Object {
// (name, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(types)))}

GO FUNC debug/dwarf.__ptrTo_Data_LineReader from debug/dwarf/line.go:
// func __ptrTo_Data_LineReader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_debug/dwarf.Data)LineReader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for cu at: /usr/local/go/src/debug/dwarf/line.go:138:30)
// 	_res1, _res2 := o.O.(*_dwarf.Data).LineReader(cu)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/dwarf.__ptrTo_Data_Ranges from debug/dwarf/entry.go:
// func __ptrTo_Data_Ranges(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_debug/dwarf.Data)Ranges()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for e at: /usr/local/go/src/debug/dwarf/entry.go:695:25)
// 	_res1, _res2 := o.O.(*_dwarf.Data).Ranges(e)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec2 := EmptyVector()
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeBigIntU(_elem2))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/dwarf.__ptrTo_Data_Reader from debug/dwarf/entry.go:
func __ptrTo_Data_Reader(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.Data)Reader()", args, 0, 0)
	_res := o.O.(*_dwarf.Data).Reader()
	return MakeGoObject(_res)
}

GO FUNC debug/dwarf.__ptrTo_Data_Type from debug/dwarf/type.go:
func __ptrTo_Data_Type(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/dwarf.Data)Type()", args, 1, 1)
	off := ExtractGo_go_std_debug_dwarf__Offset("(*_debug/dwarf.Data)Type()", "off", _argList, 0)
	_res1, _res2 := o.O.(*_dwarf.Data).Type(off)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/dwarf.__ptrTo_DotDotDotType_String from debug/dwarf/type.go:
func __ptrTo_DotDotDotType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.DotDotDotType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.DotDotDotType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_Entry_AttrField from debug/dwarf/entry.go:
func __ptrTo_Entry_AttrField(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/dwarf.Entry)AttrField()", args, 1, 1)
	a := ExtractGo_go_std_debug_dwarf__Attr("(*_debug/dwarf.Entry)AttrField()", "a", _argList, 0)
	_res := o.O.(*_dwarf.Entry).AttrField(a)
	return MakeGoObject(_res)
}

GO FUNC debug/dwarf.__ptrTo_Entry_Val from debug/dwarf/entry.go:
// func __ptrTo_Entry_Val(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/debug/dwarf/entry.go:342:29)}

GO FUNC debug/dwarf.__ptrTo_EnumType_String from debug/dwarf/type.go:
func __ptrTo_EnumType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.EnumType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.EnumType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_FuncType_String from debug/dwarf/type.go:
func __ptrTo_FuncType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.FuncType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.FuncType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_LineReader_Next from debug/dwarf/line.go:
// func __ptrTo_LineReader_Next(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_debug/dwarf.LineReader)Next()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for entry at: /usr/local/go/src/debug/dwarf/line.go:316:33)
// 	_res := o.O.(*_dwarf.LineReader).Next(entry)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC debug/dwarf.__ptrTo_LineReader_Reset from debug/dwarf/line.go:
// func __ptrTo_LineReader_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC debug/dwarf.__ptrTo_LineReader_Seek from debug/dwarf/line.go:
// func __ptrTo_LineReader_Seek(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC debug/dwarf.__ptrTo_LineReader_SeekPC from debug/dwarf/line.go:
// func __ptrTo_LineReader_SeekPC(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_debug/dwarf.LineReader)SeekPC()", args, 2, 2)
// 	pc := ExtractGoUInt64("(*_debug/dwarf.LineReader)SeekPC()", "pc", _argList, 0)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for entry at: /usr/local/go/src/debug/dwarf/line.go:552:46)
// 	_res := o.O.(*_dwarf.LineReader).SeekPC(pc, entry)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC debug/dwarf.__ptrTo_LineReader_Tell from debug/dwarf/line.go:
func __ptrTo_LineReader_Tell(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.LineReader)Tell()", args, 0, 0)
	_res := o.O.(*_dwarf.LineReader).Tell()
	return MakeGoObject(_res)
}

GO FUNC debug/dwarf.__ptrTo_PtrType_String from debug/dwarf/type.go:
func __ptrTo_PtrType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.PtrType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.PtrType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_QualType_Size from debug/dwarf/type.go:
func __ptrTo_QualType_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.QualType)Size()", args, 0, 0)
	_res := o.O.(*_dwarf.QualType).Size()
	return MakeBigInt(_res)
}

GO FUNC debug/dwarf.__ptrTo_QualType_String from debug/dwarf/type.go:
func __ptrTo_QualType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.QualType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.QualType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_Reader_AddressSize from debug/dwarf/entry.go:
func __ptrTo_Reader_AddressSize(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.Reader)AddressSize()", args, 0, 0)
	_res := o.O.(*_dwarf.Reader).AddressSize()
	return MakeInt(_res)
}

GO FUNC debug/dwarf.__ptrTo_Reader_Next from debug/dwarf/entry.go:
func __ptrTo_Reader_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.Reader)Next()", args, 0, 0)
	_res1, _res2 := o.O.(*_dwarf.Reader).Next()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/dwarf.__ptrTo_Reader_Seek from debug/dwarf/entry.go:
// func __ptrTo_Reader_Seek(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC debug/dwarf.__ptrTo_Reader_SeekPC from debug/dwarf/entry.go:
func __ptrTo_Reader_SeekPC(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/dwarf.Reader)SeekPC()", args, 1, 1)
	pc := ExtractGoUInt64("(*_debug/dwarf.Reader)SeekPC()", "pc", _argList, 0)
	_res1, _res2 := o.O.(*_dwarf.Reader).SeekPC(pc)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/dwarf.__ptrTo_Reader_SkipChildren from debug/dwarf/entry.go:
// func __ptrTo_Reader_SkipChildren(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC debug/dwarf.__ptrTo_StructType_Defn from debug/dwarf/type.go:
func __ptrTo_StructType_Defn(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.StructType)Defn()", args, 0, 0)
	_res := o.O.(*_dwarf.StructType).Defn()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_StructType_String from debug/dwarf/type.go:
func __ptrTo_StructType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.StructType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.StructType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_TypedefType_Size from debug/dwarf/type.go:
func __ptrTo_TypedefType_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.TypedefType)Size()", args, 0, 0)
	_res := o.O.(*_dwarf.TypedefType).Size()
	return MakeBigInt(_res)
}

GO FUNC debug/dwarf.__ptrTo_TypedefType_String from debug/dwarf/type.go:
func __ptrTo_TypedefType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.TypedefType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.TypedefType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__ptrTo_VoidType_String from debug/dwarf/type.go:
func __ptrTo_VoidType_String(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/dwarf.VoidType)String()", args, 0, 0)
	_res := o.O.(*_dwarf.VoidType).String()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__tag_GoString from debug/dwarf/const.go:
func __tag_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Tag)GoString()", args, 0, 0)
	_res := o.O.(_dwarf.Tag).GoString()
	return MakeString(_res)
}

GO FUNC debug/dwarf.__tag_String from debug/dwarf/tag_string.go:
func __tag_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/dwarf.Tag)String()", args, 0, 0)
	_res := o.O.(_dwarf.Tag).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package dwarf

import (
	_dwarf "debug/dwarf"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_ArrayType = GoTypeInfo{Members: GoMembers{
	"Size": __ptrTo_ArrayType_Size,
	"String": __ptrTo_ArrayType_String,
}}

var members_Attr = GoTypeInfo{Members: GoMembers{
	"GoString": __attr_GoString,
	"String": __attr_String,
}}

var members_PtrTo_BasicType = GoTypeInfo{Members: GoMembers{
	"Basic": __ptrTo_BasicType_Basic,
	"String": __ptrTo_BasicType_String,
}}

var members_Class = GoTypeInfo{Members: GoMembers{
	"GoString": __class_GoString,
	"String": __class_String,
}}

var members_PtrTo_CommonType = GoTypeInfo{Members: GoMembers{
	"Common": __ptrTo_CommonType_Common,
	"Size": __ptrTo_CommonType_Size,
}}

var members_PtrTo_Data = GoTypeInfo{Members: GoMembers{
	"Reader": __ptrTo_Data_Reader,
	"Type": __ptrTo_Data_Type,
}}

var members_DecodeError = GoTypeInfo{Members: GoMembers{
	"Error": __decodeError_Error,
}}

var members_PtrTo_DotDotDotType = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_DotDotDotType_String,
}}

var members_PtrTo_Entry = GoTypeInfo{Members: GoMembers{
	"AttrField": __ptrTo_Entry_AttrField,
}}

var members_PtrTo_EnumType = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_EnumType_String,
}}

var members_PtrTo_FuncType = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_FuncType_String,
}}

var members_PtrTo_LineReader = GoTypeInfo{Members: GoMembers{
	"Tell": __ptrTo_LineReader_Tell,
}}

var members_PtrTo_PtrType = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_PtrType_String,
}}

var members_PtrTo_QualType = GoTypeInfo{Members: GoMembers{
	"Size": __ptrTo_QualType_Size,
	"String": __ptrTo_QualType_String,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"AddressSize": __ptrTo_Reader_AddressSize,
	"Next": __ptrTo_Reader_Next,
	"SeekPC": __ptrTo_Reader_SeekPC,
}}

var members_PtrTo_StructType = GoTypeInfo{Members: GoMembers{
	"Defn": __ptrTo_StructType_Defn,
	"String": __ptrTo_StructType_String,
}}

var members_Tag = GoTypeInfo{Members: GoMembers{
	"GoString": __tag_GoString,
	"String": __tag_String,
}}

var members_PtrTo_TypedefType = GoTypeInfo{Members: GoMembers{
	"Size": __ptrTo_TypedefType_Size,
	"String": __ptrTo_TypedefType_String,
}}

var members_PtrTo_VoidType = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_VoidType_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_dwarf.ArrayType)(nil))] = &members_PtrTo_ArrayType
	GoTypes[_reflect.TypeOf((*_dwarf.Attr)(nil)).Elem()] = &members_Attr
	GoTypes[_reflect.TypeOf((*_dwarf.BasicType)(nil))] = &members_PtrTo_BasicType
	GoTypes[_reflect.TypeOf((*_dwarf.Class)(nil)).Elem()] = &members_Class
	GoTypes[_reflect.TypeOf((*_dwarf.CommonType)(nil))] = &members_PtrTo_CommonType
	GoTypes[_reflect.TypeOf((*_dwarf.Data)(nil))] = &members_PtrTo_Data
	GoTypes[_reflect.TypeOf((*_dwarf.DecodeError)(nil)).Elem()] = &members_DecodeError
	GoTypes[_reflect.TypeOf((*_dwarf.DotDotDotType)(nil))] = &members_PtrTo_DotDotDotType
	GoTypes[_reflect.TypeOf((*_dwarf.Entry)(nil))] = &members_PtrTo_Entry
	GoTypes[_reflect.TypeOf((*_dwarf.EnumType)(nil))] = &members_PtrTo_EnumType
	GoTypes[_reflect.TypeOf((*_dwarf.FuncType)(nil))] = &members_PtrTo_FuncType
	GoTypes[_reflect.TypeOf((*_dwarf.LineReader)(nil))] = &members_PtrTo_LineReader
	GoTypes[_reflect.TypeOf((*_dwarf.PtrType)(nil))] = &members_PtrTo_PtrType
	GoTypes[_reflect.TypeOf((*_dwarf.QualType)(nil))] = &members_PtrTo_QualType
	GoTypes[_reflect.TypeOf((*_dwarf.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_dwarf.StructType)(nil))] = &members_PtrTo_StructType
	GoTypes[_reflect.TypeOf((*_dwarf.Tag)(nil)).Elem()] = &members_Tag
	GoTypes[_reflect.TypeOf((*_dwarf.TypedefType)(nil))] = &members_PtrTo_TypedefType
	GoTypes[_reflect.TypeOf((*_dwarf.VoidType)(nil))] = &members_PtrTo_VoidType
}

GO TYPE debug/elf.Chdr32 from debug/elf/elf.go:
func ExtractGoObjectChdr32(args []Object, index int) *_elf.Chdr32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Chdr32:
			return &r
		case *_elf.Chdr32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Chdr32]"))
}

func _mapToChdr32(o Map) *_elf.Chdr32 {
	return &_elf.Chdr32{}
}

func _vectorToChdr32(o *Vector) *_elf.Chdr32 {
	return &_elf.Chdr32{
		Type: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Addralign: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
	}
}

func _ConstructChdr32(_v Object) *_elf.Chdr32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Chdr32:
			return &_g
		case *_elf.Chdr32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChdr32(_o.(Map))
	case *Vector:
		return _vectorToChdr32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Chdr32] or: Map or Vector"))
}

GO TYPE debug/elf.Chdr64 from debug/elf/elf.go:
func ExtractGoObjectChdr64(args []Object, index int) *_elf.Chdr64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Chdr64:
			return &r
		case *_elf.Chdr64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Chdr64]"))
}

func _mapToChdr64(o Map) *_elf.Chdr64 {
	return &_elf.Chdr64{}
}

func _vectorToChdr64(o *Vector) *_elf.Chdr64 {
	return &_elf.Chdr64{
		Type: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Size: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Addralign: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
	}
}

func _ConstructChdr64(_v Object) *_elf.Chdr64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Chdr64:
			return &_g
		case *_elf.Chdr64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChdr64(_o.(Map))
	case *Vector:
		return _vectorToChdr64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Chdr64] or: Map or Vector"))
}

GO TYPE debug/elf.Class from debug/elf/elf.go:
func ExtractGoObjectClass(args []Object, index int) *_elf.Class {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Class:
			return &r
		case *_elf.Class:
			return r
		}
	case Int:
		v := _elf.Class(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Class]"))
}

func _ConstructClass(_v Object) _elf.Class {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Class:
			return _g
		case *_elf.Class:
			return *_g
		}
	case Number:
		return _elf.Class(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Class] or: Number"))
}

GO TYPE debug/elf.CompressionType from debug/elf/elf.go:
func ExtractGoObjectCompressionType(args []Object, index int) *_elf.CompressionType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.CompressionType:
			return &r
		case *_elf.CompressionType:
			return r
		}
	case Int:
		v := _elf.CompressionType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.CompressionType]"))
}

func _ConstructCompressionType(_v Object) _elf.CompressionType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.CompressionType:
			return _g
		case *_elf.CompressionType:
			return *_g
		}
	case Number:
		return _elf.CompressionType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.CompressionType] or: Number"))
}

GO TYPE debug/elf.Data from debug/elf/elf.go:
func ExtractGoObjectData(args []Object, index int) *_elf.Data {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Data:
			return &r
		case *_elf.Data:
			return r
		}
	case Int:
		v := _elf.Data(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Data]"))
}

func _ConstructData(_v Object) _elf.Data {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Data:
			return _g
		case *_elf.Data:
			return *_g
		}
	case Number:
		return _elf.Data(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Data] or: Number"))
}

GO TYPE debug/elf.Dyn32 from debug/elf/elf.go:
func ExtractGoObjectDyn32(args []Object, index int) *_elf.Dyn32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Dyn32:
			return &r
		case *_elf.Dyn32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Dyn32]"))
}

func _mapToDyn32(o Map) *_elf.Dyn32 {
	return &_elf.Dyn32{}
}

func _vectorToDyn32(o *Vector) *_elf.Dyn32 {
	return &_elf.Dyn32{
		Tag: int32(AssertInt(o.Nth(0), "").I),
		Val: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
	}
}

func _ConstructDyn32(_v Object) *_elf.Dyn32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Dyn32:
			return &_g
		case *_elf.Dyn32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDyn32(_o.(Map))
	case *Vector:
		return _vectorToDyn32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Dyn32] or: Map or Vector"))
}

GO TYPE debug/elf.Dyn64 from debug/elf/elf.go:
func ExtractGoObjectDyn64(args []Object, index int) *_elf.Dyn64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Dyn64:
			return &r
		case *_elf.Dyn64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Dyn64]"))
}

func _mapToDyn64(o Map) *_elf.Dyn64 {
	return &_elf.Dyn64{}
}

func _vectorToDyn64(o *Vector) *_elf.Dyn64 {
	return &_elf.Dyn64{
		Tag: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Val: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructDyn64(_v Object) *_elf.Dyn64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Dyn64:
			return &_g
		case *_elf.Dyn64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDyn64(_o.(Map))
	case *Vector:
		return _vectorToDyn64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Dyn64] or: Map or Vector"))
}

GO TYPE debug/elf.DynFlag from debug/elf/elf.go:
func ExtractGoObjectDynFlag(args []Object, index int) *_elf.DynFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.DynFlag:
			return &r
		case *_elf.DynFlag:
			return r
		}
	case Int:
		v := _elf.DynFlag(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.DynFlag]"))
}

func _ConstructDynFlag(_v Object) _elf.DynFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.DynFlag:
			return _g
		case *_elf.DynFlag:
			return *_g
		}
	case Number:
		return _elf.DynFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.DynFlag] or: Number"))
}

GO TYPE debug/elf.DynTag from debug/elf/elf.go:
func ExtractGoObjectDynTag(args []Object, index int) *_elf.DynTag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.DynTag:
			return &r
		case *_elf.DynTag:
			return r
		}
	case Int:
		v := _elf.DynTag(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.DynTag]"))
}

func _ConstructDynTag(_v Object) _elf.DynTag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.DynTag:
			return _g
		case *_elf.DynTag:
			return *_g
		}
	case Number:
		return _elf.DynTag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.DynTag] or: Number"))
}

GO TYPE debug/elf.File from debug/elf/file.go:
func ExtractGoObjectFile(args []Object, index int) *_elf.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.File:
			return &r
		case *_elf.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.File]"))
}

// func _mapToFile(o Map) *_elf.File {
// 	return &_elf.File{}
// }

// func _vectorToFile(o *Vector) *_elf.File {
// 	return &_elf.File{
// 		Sections: ABEND048(codegen.go: no conversion from Clojure for []*debug/elf.Section (*debug/elf.Section)),
// 		Progs: ABEND048(codegen.go: no conversion from Clojure for []*debug/elf.Prog (*debug/elf.Prog)),
// 	}
// }

// func _ConstructFile(_v Object) *_elf.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.File:
// 			return &_g
// 		case *_elf.File:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.File] or: Map or Vector"))
// }

GO TYPE debug/elf.FileHeader from debug/elf/file.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_elf.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.FileHeader:
			return &r
		case *_elf.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.FileHeader]"))
}

// func _mapToFileHeader(o Map) *_elf.FileHeader {
// 	return &_elf.FileHeader{}
// }

// func _vectorToFileHeader(o *Vector) *_elf.FileHeader {
// 	return &_elf.FileHeader{
// 		Class: _elf.Class(byte(AssertInt(o.Nth(0), "").I)),
// 		Data: _elf.Data(byte(AssertInt(o.Nth(1), "").I)),
// 		Version: _elf.Version(byte(AssertInt(o.Nth(2), "").I)),
// 		OSABI: _elf.OSABI(byte(AssertInt(o.Nth(3), "").I)),
// 		ABIVersion: uint8(AssertInt(o.Nth(4), "").I),
// 		ByteOrder: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Type: _elf.Type(uint16(AssertInt(o.Nth(6), "").I)),
// 		Machine: _elf.Machine(uint16(AssertInt(o.Nth(7), "").I)),
// 		Entry: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
// 	}
// }

// func _ConstructFileHeader(_v Object) *_elf.FileHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.FileHeader:
// 			return &_g
// 		case *_elf.FileHeader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFileHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToFileHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.FileHeader] or: Map or Vector"))
// }

GO TYPE debug/elf.FormatError from debug/elf/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_elf.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.FormatError:
			return &r
		case *_elf.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.FormatError]"))
}

func _mapToFormatError(o Map) *_elf.FormatError {
	return &_elf.FormatError{}
}

func _vectorToFormatError(o *Vector) *_elf.FormatError {
	return &_elf.FormatError{}
}

func _ConstructFormatError(_v Object) *_elf.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.FormatError:
			return &_g
		case *_elf.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.FormatError] or: Map or Vector"))
}

GO TYPE debug/elf.Header32 from debug/elf/elf.go:
func ExtractGoObjectHeader32(args []Object, index int) *_elf.Header32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Header32:
			return &r
		case *_elf.Header32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Header32]"))
}

// func _mapToHeader32(o Map) *_elf.Header32 {
// 	return &_elf.Header32{}
// }

// func _vectorToHeader32(o *Vector) *_elf.Header32 {
// 	return &_elf.Header32{
// 		Ident: ABEND048(codegen.go: no conversion from Clojure for [EI_NIDENT]byte (byte)),
// 		Type: uint16(AssertInt(o.Nth(1), "").I),
// 		Machine: uint16(AssertInt(o.Nth(2), "").I),
// 		Version: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Entry: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Phoff: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Shoff: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		Flags: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Ehsize: uint16(AssertInt(o.Nth(8), "").I),
// 		Phentsize: uint16(AssertInt(o.Nth(9), "").I),
// 		Phnum: uint16(AssertInt(o.Nth(10), "").I),
// 		Shentsize: uint16(AssertInt(o.Nth(11), "").I),
// 		Shnum: uint16(AssertInt(o.Nth(12), "").I),
// 		Shstrndx: uint16(AssertInt(o.Nth(13), "").I),
// 	}
// }

// func _ConstructHeader32(_v Object) *_elf.Header32 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.Header32:
// 			return &_g
// 		case *_elf.Header32:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHeader32(_o.(Map))
// 	case *Vector:
// 		return _vectorToHeader32(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Header32] or: Map or Vector"))
// }

GO TYPE debug/elf.Header64 from debug/elf/elf.go:
func ExtractGoObjectHeader64(args []Object, index int) *_elf.Header64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Header64:
			return &r
		case *_elf.Header64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Header64]"))
}

// func _mapToHeader64(o Map) *_elf.Header64 {
// 	return &_elf.Header64{}
// }

// func _vectorToHeader64(o *Vector) *_elf.Header64 {
// 	return &_elf.Header64{
// 		Ident: ABEND048(codegen.go: no conversion from Clojure for [EI_NIDENT]byte (byte)),
// 		Type: uint16(AssertInt(o.Nth(1), "").I),
// 		Machine: uint16(AssertInt(o.Nth(2), "").I),
// 		Version: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Entry: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
// 		Phoff: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
// 		Shoff: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
// 		Flags: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Ehsize: uint16(AssertInt(o.Nth(8), "").I),
// 		Phentsize: uint16(AssertInt(o.Nth(9), "").I),
// 		Phnum: uint16(AssertInt(o.Nth(10), "").I),
// 		Shentsize: uint16(AssertInt(o.Nth(11), "").I),
// 		Shnum: uint16(AssertInt(o.Nth(12), "").I),
// 		Shstrndx: uint16(AssertInt(o.Nth(13), "").I),
// 	}
// }

// func _ConstructHeader64(_v Object) *_elf.Header64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _elf.Header64:
// 			return &_g
// 		case *_elf.Header64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHeader64(_o.(Map))
// 	case *Vector:
// 		return _vectorToHeader64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Header64] or: Map or Vector"))
// }

GO TYPE debug/elf.ImportedSymbol from debug/elf/file.go:
func ExtractGoObjectImportedSymbol(args []Object, index int) *_elf.ImportedSymbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ImportedSymbol:
			return &r
		case *_elf.ImportedSymbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ImportedSymbol]"))
}

func _mapToImportedSymbol(o Map) *_elf.ImportedSymbol {
	return &_elf.ImportedSymbol{}
}

func _vectorToImportedSymbol(o *Vector) *_elf.ImportedSymbol {
	return &_elf.ImportedSymbol{
		Name: AssertString(o.Nth(0), "").S,
		Version: AssertString(o.Nth(1), "").S,
		Library: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructImportedSymbol(_v Object) *_elf.ImportedSymbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ImportedSymbol:
			return &_g
		case *_elf.ImportedSymbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToImportedSymbol(_o.(Map))
	case *Vector:
		return _vectorToImportedSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ImportedSymbol] or: Map or Vector"))
}

GO TYPE debug/elf.Machine from debug/elf/elf.go:
func ExtractGoObjectMachine(args []Object, index int) *_elf.Machine {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Machine:
			return &r
		case *_elf.Machine:
			return r
		}
	case Int:
		v := _elf.Machine(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Machine]"))
}

func _ConstructMachine(_v Object) _elf.Machine {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Machine:
			return _g
		case *_elf.Machine:
			return *_g
		}
	case Number:
		return _elf.Machine(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Machine] or: Number"))
}

GO TYPE debug/elf.NType from debug/elf/elf.go:
func ExtractGoObjectNType(args []Object, index int) *_elf.NType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.NType:
			return &r
		case *_elf.NType:
			return r
		}
	case Int:
		v := _elf.NType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.NType]"))
}

func _ConstructNType(_v Object) _elf.NType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.NType:
			return _g
		case *_elf.NType:
			return *_g
		}
	case Number:
		return _elf.NType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.NType] or: Number"))
}

GO TYPE debug/elf.OSABI from debug/elf/elf.go:
func ExtractGoObjectOSABI(args []Object, index int) *_elf.OSABI {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.OSABI:
			return &r
		case *_elf.OSABI:
			return r
		}
	case Int:
		v := _elf.OSABI(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.OSABI]"))
}

func _ConstructOSABI(_v Object) _elf.OSABI {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.OSABI:
			return _g
		case *_elf.OSABI:
			return *_g
		}
	case Number:
		return _elf.OSABI(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.OSABI] or: Number"))
}

GO TYPE debug/elf.Prog from debug/elf/file.go:
func ExtractGoObjectProg(args []Object, index int) *_elf.Prog {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog:
			return &r
		case *_elf.Prog:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog]"))
}

func _mapToProg(o Map) *_elf.Prog {
	return &_elf.Prog{}
}

func _vectorToProg(o *Vector) *_elf.Prog {
	return &_elf.Prog{}
}

func _ConstructProg(_v Object) *_elf.Prog {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog:
			return &_g
		case *_elf.Prog:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg(_o.(Map))
	case *Vector:
		return _vectorToProg(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog] or: Map or Vector"))
}

GO TYPE debug/elf.Prog32 from debug/elf/elf.go:
func ExtractGoObjectProg32(args []Object, index int) *_elf.Prog32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog32:
			return &r
		case *_elf.Prog32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog32]"))
}

func _mapToProg32(o Map) *_elf.Prog32 {
	return &_elf.Prog32{}
}

func _vectorToProg32(o *Vector) *_elf.Prog32 {
	return &_elf.Prog32{
		Type: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Off: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Vaddr: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Paddr: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Filesz: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Memsz: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		Flags: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Align: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
	}
}

func _ConstructProg32(_v Object) *_elf.Prog32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog32:
			return &_g
		case *_elf.Prog32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg32(_o.(Map))
	case *Vector:
		return _vectorToProg32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog32] or: Map or Vector"))
}

GO TYPE debug/elf.Prog64 from debug/elf/elf.go:
func ExtractGoObjectProg64(args []Object, index int) *_elf.Prog64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Prog64:
			return &r
		case *_elf.Prog64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Prog64]"))
}

func _mapToProg64(o Map) *_elf.Prog64 {
	return &_elf.Prog64{}
}

func _vectorToProg64(o *Vector) *_elf.Prog64 {
	return &_elf.Prog64{
		Type: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Flags: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Off: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		Vaddr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Paddr: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Filesz: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		Memsz: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
		Align: AssertNumber(o.Nth(7), "").BigInt().Uint64(),
	}
}

func _ConstructProg64(_v Object) *_elf.Prog64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Prog64:
			return &_g
		case *_elf.Prog64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProg64(_o.(Map))
	case *Vector:
		return _vectorToProg64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Prog64] or: Map or Vector"))
}

GO TYPE debug/elf.ProgFlag from debug/elf/elf.go:
func ExtractGoObjectProgFlag(args []Object, index int) *_elf.ProgFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgFlag:
			return &r
		case *_elf.ProgFlag:
			return r
		}
	case Number:
		v := _elf.ProgFlag(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgFlag]"))
}

func _ConstructProgFlag(_v Object) _elf.ProgFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgFlag:
			return _g
		case *_elf.ProgFlag:
			return *_g
		}
	case Number:
		return _elf.ProgFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgFlag] or: Number"))
}

GO TYPE debug/elf.ProgHeader from debug/elf/file.go:
func ExtractGoObjectProgHeader(args []Object, index int) *_elf.ProgHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgHeader:
			return &r
		case *_elf.ProgHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgHeader]"))
}

func _mapToProgHeader(o Map) *_elf.ProgHeader {
	return &_elf.ProgHeader{}
}

func _vectorToProgHeader(o *Vector) *_elf.ProgHeader {
	return &_elf.ProgHeader{
		Type: _elf.ProgType(AssertInt(o.Nth(0), "").I),
		Flags: _elf.ProgFlag(uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64())),
		Off: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		Vaddr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Paddr: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Filesz: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		Memsz: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
		Align: AssertNumber(o.Nth(7), "").BigInt().Uint64(),
	}
}

func _ConstructProgHeader(_v Object) *_elf.ProgHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgHeader:
			return &_g
		case *_elf.ProgHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProgHeader(_o.(Map))
	case *Vector:
		return _vectorToProgHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgHeader] or: Map or Vector"))
}

GO TYPE debug/elf.ProgType from debug/elf/elf.go:
func ExtractGoObjectProgType(args []Object, index int) *_elf.ProgType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.ProgType:
			return &r
		case *_elf.ProgType:
			return r
		}
	case Int:
		v := _elf.ProgType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.ProgType]"))
}

func _ConstructProgType(_v Object) _elf.ProgType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.ProgType:
			return _g
		case *_elf.ProgType:
			return *_g
		}
	case Number:
		return _elf.ProgType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.ProgType] or: Number"))
}

GO TYPE debug/elf.R_386 from debug/elf/elf.go:
func ExtractGoObjectR_386(args []Object, index int) *_elf.R_386 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_386:
			return &r
		case *_elf.R_386:
			return r
		}
	case Int:
		v := _elf.R_386(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_386]"))
}

func _ConstructR_386(_v Object) _elf.R_386 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_386:
			return _g
		case *_elf.R_386:
			return *_g
		}
	case Number:
		return _elf.R_386(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_386] or: Number"))
}

GO TYPE debug/elf.R_390 from debug/elf/elf.go:
func ExtractGoObjectR_390(args []Object, index int) *_elf.R_390 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_390:
			return &r
		case *_elf.R_390:
			return r
		}
	case Int:
		v := _elf.R_390(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_390]"))
}

func _ConstructR_390(_v Object) _elf.R_390 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_390:
			return _g
		case *_elf.R_390:
			return *_g
		}
	case Number:
		return _elf.R_390(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_390] or: Number"))
}

GO TYPE debug/elf.R_AARCH64 from debug/elf/elf.go:
func ExtractGoObjectR_AARCH64(args []Object, index int) *_elf.R_AARCH64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_AARCH64:
			return &r
		case *_elf.R_AARCH64:
			return r
		}
	case Int:
		v := _elf.R_AARCH64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_AARCH64]"))
}

func _ConstructR_AARCH64(_v Object) _elf.R_AARCH64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_AARCH64:
			return _g
		case *_elf.R_AARCH64:
			return *_g
		}
	case Number:
		return _elf.R_AARCH64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_AARCH64] or: Number"))
}

GO TYPE debug/elf.R_ALPHA from debug/elf/elf.go:
func ExtractGoObjectR_ALPHA(args []Object, index int) *_elf.R_ALPHA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_ALPHA:
			return &r
		case *_elf.R_ALPHA:
			return r
		}
	case Int:
		v := _elf.R_ALPHA(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_ALPHA]"))
}

func _ConstructR_ALPHA(_v Object) _elf.R_ALPHA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_ALPHA:
			return _g
		case *_elf.R_ALPHA:
			return *_g
		}
	case Number:
		return _elf.R_ALPHA(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_ALPHA] or: Number"))
}

GO TYPE debug/elf.R_ARM from debug/elf/elf.go:
func ExtractGoObjectR_ARM(args []Object, index int) *_elf.R_ARM {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_ARM:
			return &r
		case *_elf.R_ARM:
			return r
		}
	case Int:
		v := _elf.R_ARM(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_ARM]"))
}

func _ConstructR_ARM(_v Object) _elf.R_ARM {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_ARM:
			return _g
		case *_elf.R_ARM:
			return *_g
		}
	case Number:
		return _elf.R_ARM(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_ARM] or: Number"))
}

GO TYPE debug/elf.R_MIPS from debug/elf/elf.go:
func ExtractGoObjectR_MIPS(args []Object, index int) *_elf.R_MIPS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_MIPS:
			return &r
		case *_elf.R_MIPS:
			return r
		}
	case Int:
		v := _elf.R_MIPS(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_MIPS]"))
}

func _ConstructR_MIPS(_v Object) _elf.R_MIPS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_MIPS:
			return _g
		case *_elf.R_MIPS:
			return *_g
		}
	case Number:
		return _elf.R_MIPS(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_MIPS] or: Number"))
}

GO TYPE debug/elf.R_PPC from debug/elf/elf.go:
func ExtractGoObjectR_PPC(args []Object, index int) *_elf.R_PPC {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_PPC:
			return &r
		case *_elf.R_PPC:
			return r
		}
	case Int:
		v := _elf.R_PPC(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_PPC]"))
}

func _ConstructR_PPC(_v Object) _elf.R_PPC {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_PPC:
			return _g
		case *_elf.R_PPC:
			return *_g
		}
	case Number:
		return _elf.R_PPC(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_PPC] or: Number"))
}

GO TYPE debug/elf.R_PPC64 from debug/elf/elf.go:
func ExtractGoObjectR_PPC64(args []Object, index int) *_elf.R_PPC64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_PPC64:
			return &r
		case *_elf.R_PPC64:
			return r
		}
	case Int:
		v := _elf.R_PPC64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_PPC64]"))
}

func _ConstructR_PPC64(_v Object) _elf.R_PPC64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_PPC64:
			return _g
		case *_elf.R_PPC64:
			return *_g
		}
	case Number:
		return _elf.R_PPC64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_PPC64] or: Number"))
}

GO TYPE debug/elf.R_RISCV from debug/elf/elf.go:
func ExtractGoObjectR_RISCV(args []Object, index int) *_elf.R_RISCV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_RISCV:
			return &r
		case *_elf.R_RISCV:
			return r
		}
	case Int:
		v := _elf.R_RISCV(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_RISCV]"))
}

func _ConstructR_RISCV(_v Object) _elf.R_RISCV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_RISCV:
			return _g
		case *_elf.R_RISCV:
			return *_g
		}
	case Number:
		return _elf.R_RISCV(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_RISCV] or: Number"))
}

GO TYPE debug/elf.R_SPARC from debug/elf/elf.go:
func ExtractGoObjectR_SPARC(args []Object, index int) *_elf.R_SPARC {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_SPARC:
			return &r
		case *_elf.R_SPARC:
			return r
		}
	case Int:
		v := _elf.R_SPARC(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_SPARC]"))
}

func _ConstructR_SPARC(_v Object) _elf.R_SPARC {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_SPARC:
			return _g
		case *_elf.R_SPARC:
			return *_g
		}
	case Number:
		return _elf.R_SPARC(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_SPARC] or: Number"))
}

GO TYPE debug/elf.R_X86_64 from debug/elf/elf.go:
func ExtractGoObjectR_X86_64(args []Object, index int) *_elf.R_X86_64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.R_X86_64:
			return &r
		case *_elf.R_X86_64:
			return r
		}
	case Int:
		v := _elf.R_X86_64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.R_X86_64]"))
}

func _ConstructR_X86_64(_v Object) _elf.R_X86_64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.R_X86_64:
			return _g
		case *_elf.R_X86_64:
			return *_g
		}
	case Number:
		return _elf.R_X86_64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.R_X86_64] or: Number"))
}

GO TYPE debug/elf.Rel32 from debug/elf/elf.go:
func ExtractGoObjectRel32(args []Object, index int) *_elf.Rel32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rel32:
			return &r
		case *_elf.Rel32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rel32]"))
}

func _mapToRel32(o Map) *_elf.Rel32 {
	return &_elf.Rel32{}
}

func _vectorToRel32(o *Vector) *_elf.Rel32 {
	return &_elf.Rel32{
		Off: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Info: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
	}
}

func _ConstructRel32(_v Object) *_elf.Rel32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rel32:
			return &_g
		case *_elf.Rel32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRel32(_o.(Map))
	case *Vector:
		return _vectorToRel32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rel32] or: Map or Vector"))
}

GO TYPE debug/elf.Rel64 from debug/elf/elf.go:
func ExtractGoObjectRel64(args []Object, index int) *_elf.Rel64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rel64:
			return &r
		case *_elf.Rel64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rel64]"))
}

func _mapToRel64(o Map) *_elf.Rel64 {
	return &_elf.Rel64{}
}

func _vectorToRel64(o *Vector) *_elf.Rel64 {
	return &_elf.Rel64{
		Off: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
		Info: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRel64(_v Object) *_elf.Rel64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rel64:
			return &_g
		case *_elf.Rel64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRel64(_o.(Map))
	case *Vector:
		return _vectorToRel64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rel64] or: Map or Vector"))
}

GO TYPE debug/elf.Rela32 from debug/elf/elf.go:
func ExtractGoObjectRela32(args []Object, index int) *_elf.Rela32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rela32:
			return &r
		case *_elf.Rela32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rela32]"))
}

func _mapToRela32(o Map) *_elf.Rela32 {
	return &_elf.Rela32{}
}

func _vectorToRela32(o *Vector) *_elf.Rela32 {
	return &_elf.Rela32{
		Off: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Info: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Addend: int32(AssertInt(o.Nth(2), "").I),
	}
}

func _ConstructRela32(_v Object) *_elf.Rela32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rela32:
			return &_g
		case *_elf.Rela32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRela32(_o.(Map))
	case *Vector:
		return _vectorToRela32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rela32] or: Map or Vector"))
}

GO TYPE debug/elf.Rela64 from debug/elf/elf.go:
func ExtractGoObjectRela64(args []Object, index int) *_elf.Rela64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Rela64:
			return &r
		case *_elf.Rela64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Rela64]"))
}

func _mapToRela64(o Map) *_elf.Rela64 {
	return &_elf.Rela64{}
}

func _vectorToRela64(o *Vector) *_elf.Rela64 {
	return &_elf.Rela64{
		Off: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
		Info: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Addend: AssertNumber(o.Nth(2), "").BigInt().Int64(),
	}
}

func _ConstructRela64(_v Object) *_elf.Rela64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Rela64:
			return &_g
		case *_elf.Rela64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRela64(_o.(Map))
	case *Vector:
		return _vectorToRela64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Rela64] or: Map or Vector"))
}

GO TYPE debug/elf.Section from debug/elf/file.go:
func ExtractGoObjectSection(args []Object, index int) *_elf.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section:
			return &r
		case *_elf.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section]"))
}

func _mapToSection(o Map) *_elf.Section {
	return &_elf.Section{}
}

func _vectorToSection(o *Vector) *_elf.Section {
	return &_elf.Section{}
}

func _ConstructSection(_v Object) *_elf.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section:
			return &_g
		case *_elf.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section] or: Map or Vector"))
}

GO TYPE debug/elf.Section32 from debug/elf/elf.go:
func ExtractGoObjectSection32(args []Object, index int) *_elf.Section32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section32:
			return &r
		case *_elf.Section32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section32]"))
}

func _mapToSection32(o Map) *_elf.Section32 {
	return &_elf.Section32{}
}

func _vectorToSection32(o *Vector) *_elf.Section32 {
	return &_elf.Section32{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Type: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Flags: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Addr: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Off: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		Link: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Info: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Addralign: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
		Entsize: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
	}
}

func _ConstructSection32(_v Object) *_elf.Section32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section32:
			return &_g
		case *_elf.Section32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection32(_o.(Map))
	case *Vector:
		return _vectorToSection32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section32] or: Map or Vector"))
}

GO TYPE debug/elf.Section64 from debug/elf/elf.go:
func ExtractGoObjectSection64(args []Object, index int) *_elf.Section64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Section64:
			return &r
		case *_elf.Section64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Section64]"))
}

func _mapToSection64(o Map) *_elf.Section64 {
	return &_elf.Section64{}
}

func _vectorToSection64(o *Vector) *_elf.Section64 {
	return &_elf.Section64{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Type: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Flags: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		Addr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Off: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Size: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		Link: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Info: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Addralign: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
		Entsize: AssertNumber(o.Nth(9), "").BigInt().Uint64(),
	}
}

func _ConstructSection64(_v Object) *_elf.Section64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Section64:
			return &_g
		case *_elf.Section64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection64(_o.(Map))
	case *Vector:
		return _vectorToSection64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Section64] or: Map or Vector"))
}

GO TYPE debug/elf.SectionFlag from debug/elf/elf.go:
func ExtractGoObjectSectionFlag(args []Object, index int) *_elf.SectionFlag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionFlag:
			return &r
		case *_elf.SectionFlag:
			return r
		}
	case Number:
		v := _elf.SectionFlag(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionFlag]"))
}

func _ConstructSectionFlag(_v Object) _elf.SectionFlag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionFlag:
			return _g
		case *_elf.SectionFlag:
			return *_g
		}
	case Number:
		return _elf.SectionFlag(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionFlag] or: Number"))
}

GO TYPE debug/elf.SectionHeader from debug/elf/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_elf.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionHeader:
			return &r
		case *_elf.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_elf.SectionHeader {
	return &_elf.SectionHeader{}
}

func _vectorToSectionHeader(o *Vector) *_elf.SectionHeader {
	return &_elf.SectionHeader{
		Name: AssertString(o.Nth(0), "").S,
		Type: _elf.SectionType(uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64())),
		Flags: _elf.SectionFlag(uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64())),
		Addr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Offset: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Size: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		Link: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Info: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Addralign: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
		Entsize: AssertNumber(o.Nth(9), "").BigInt().Uint64(),
		FileSize: AssertNumber(o.Nth(10), "").BigInt().Uint64(),
	}
}

func _ConstructSectionHeader(_v Object) *_elf.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionHeader:
			return &_g
		case *_elf.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionHeader] or: Map or Vector"))
}

GO TYPE debug/elf.SectionIndex from debug/elf/elf.go:
func ExtractGoObjectSectionIndex(args []Object, index int) *_elf.SectionIndex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionIndex:
			return &r
		case *_elf.SectionIndex:
			return r
		}
	case Int:
		v := _elf.SectionIndex(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionIndex]"))
}

func _ConstructSectionIndex(_v Object) _elf.SectionIndex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionIndex:
			return _g
		case *_elf.SectionIndex:
			return *_g
		}
	case Number:
		return _elf.SectionIndex(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionIndex] or: Number"))
}

GO TYPE debug/elf.SectionType from debug/elf/elf.go:
func ExtractGoObjectSectionType(args []Object, index int) *_elf.SectionType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SectionType:
			return &r
		case *_elf.SectionType:
			return r
		}
	case Number:
		v := _elf.SectionType(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SectionType]"))
}

func _ConstructSectionType(_v Object) _elf.SectionType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SectionType:
			return _g
		case *_elf.SectionType:
			return *_g
		}
	case Number:
		return _elf.SectionType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SectionType] or: Number"))
}

GO TYPE debug/elf.Sym32 from debug/elf/elf.go:
func ExtractGoObjectSym32(args []Object, index int) *_elf.Sym32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Sym32:
			return &r
		case *_elf.Sym32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Sym32]"))
}

func _mapToSym32(o Map) *_elf.Sym32 {
	return &_elf.Sym32{}
}

func _vectorToSym32(o *Vector) *_elf.Sym32 {
	return &_elf.Sym32{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Value: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Info: uint8(AssertInt(o.Nth(3), "").I),
		Other: uint8(AssertInt(o.Nth(4), "").I),
		Shndx: uint16(AssertInt(o.Nth(5), "").I),
	}
}

func _ConstructSym32(_v Object) *_elf.Sym32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Sym32:
			return &_g
		case *_elf.Sym32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym32(_o.(Map))
	case *Vector:
		return _vectorToSym32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Sym32] or: Map or Vector"))
}

GO TYPE debug/elf.Sym64 from debug/elf/elf.go:
func ExtractGoObjectSym64(args []Object, index int) *_elf.Sym64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Sym64:
			return &r
		case *_elf.Sym64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Sym64]"))
}

func _mapToSym64(o Map) *_elf.Sym64 {
	return &_elf.Sym64{}
}

func _vectorToSym64(o *Vector) *_elf.Sym64 {
	return &_elf.Sym64{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Info: uint8(AssertInt(o.Nth(1), "").I),
		Other: uint8(AssertInt(o.Nth(2), "").I),
		Shndx: uint16(AssertInt(o.Nth(3), "").I),
		Value: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Size: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
	}
}

func _ConstructSym64(_v Object) *_elf.Sym64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Sym64:
			return &_g
		case *_elf.Sym64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym64(_o.(Map))
	case *Vector:
		return _vectorToSym64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Sym64] or: Map or Vector"))
}

GO TYPE debug/elf.SymBind from debug/elf/elf.go:
func ExtractGoObjectSymBind(args []Object, index int) *_elf.SymBind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymBind:
			return &r
		case *_elf.SymBind:
			return r
		}
	case Int:
		v := _elf.SymBind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymBind]"))
}

func _ConstructSymBind(_v Object) _elf.SymBind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymBind:
			return _g
		case *_elf.SymBind:
			return *_g
		}
	case Number:
		return _elf.SymBind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymBind] or: Number"))
}

GO TYPE debug/elf.SymType from debug/elf/elf.go:
func ExtractGoObjectSymType(args []Object, index int) *_elf.SymType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymType:
			return &r
		case *_elf.SymType:
			return r
		}
	case Int:
		v := _elf.SymType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymType]"))
}

func _ConstructSymType(_v Object) _elf.SymType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymType:
			return _g
		case *_elf.SymType:
			return *_g
		}
	case Number:
		return _elf.SymType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymType] or: Number"))
}

GO TYPE debug/elf.SymVis from debug/elf/elf.go:
func ExtractGoObjectSymVis(args []Object, index int) *_elf.SymVis {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.SymVis:
			return &r
		case *_elf.SymVis:
			return r
		}
	case Int:
		v := _elf.SymVis(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.SymVis]"))
}

func _ConstructSymVis(_v Object) _elf.SymVis {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.SymVis:
			return _g
		case *_elf.SymVis:
			return *_g
		}
	case Number:
		return _elf.SymVis(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.SymVis] or: Number"))
}

GO TYPE debug/elf.Symbol from debug/elf/file.go:
func ExtractGoObjectSymbol(args []Object, index int) *_elf.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Symbol:
			return &r
		case *_elf.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Symbol]"))
}

func _mapToSymbol(o Map) *_elf.Symbol {
	return &_elf.Symbol{}
}

func _vectorToSymbol(o *Vector) *_elf.Symbol {
	return &_elf.Symbol{
		Name: AssertString(o.Nth(0), "").S,
		Info: byte(AssertInt(o.Nth(1), "").I),
		Other: byte(AssertInt(o.Nth(2), "").I),
		Section: _elf.SectionIndex(AssertInt(o.Nth(3), "").I),
		Value: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Size: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
	}
}

func _ConstructSymbol(_v Object) *_elf.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Symbol:
			return &_g
		case *_elf.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Symbol] or: Map or Vector"))
}

GO TYPE debug/elf.Type from debug/elf/elf.go:
func ExtractGoObjectType(args []Object, index int) *_elf.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Type:
			return &r
		case *_elf.Type:
			return r
		}
	case Int:
		v := _elf.Type(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Type]"))
}

func _ConstructType(_v Object) _elf.Type {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Type:
			return _g
		case *_elf.Type:
			return *_g
		}
	case Number:
		return _elf.Type(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Type] or: Number"))
}

GO TYPE debug/elf.Version from debug/elf/elf.go:
func ExtractGoObjectVersion(args []Object, index int) *_elf.Version {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _elf.Version:
			return &r
		case *_elf.Version:
			return r
		}
	case Int:
		v := _elf.Version(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/elf.Version]"))
}

func _ConstructVersion(_v Object) _elf.Version {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _elf.Version:
			return _g
		case *_elf.Version:
			return *_g
		}
	case Number:
		return _elf.Version(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[elf.Version] or: Number"))
}

GO FUNC debug/elf.NewFile from debug/elf/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _elf.NewFile(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/elf.Open from debug/elf/file.go:
func __open(name string) Object {
	_res1, _res2 := _elf.Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.R_INFO from debug/elf/elf.go:
func __r_INFO(sym uint32, typ uint32) Object {
	_res := _elf.R_INFO(sym, typ)
	return MakeBigIntU(_res)
}

GO FUNC debug/elf.R_INFO32 from debug/elf/elf.go:
func __r_INFO32(sym uint32, typ uint32) Object {
	_res := _elf.R_INFO32(sym, typ)
	return MakeBigIntU(uint64(_res))
}

GO FUNC debug/elf.R_SYM32 from debug/elf/elf.go:
func __r_SYM32(info uint32) Object {
	_res := _elf.R_SYM32(info)
	return MakeBigIntU(uint64(_res))
}

GO FUNC debug/elf.R_SYM64 from debug/elf/elf.go:
func __r_SYM64(info uint64) Object {
	_res := _elf.R_SYM64(info)
	return MakeBigIntU(uint64(_res))
}

GO FUNC debug/elf.R_TYPE32 from debug/elf/elf.go:
func __r_TYPE32(info uint32) Object {
	_res := _elf.R_TYPE32(info)
	return MakeBigIntU(uint64(_res))
}

GO FUNC debug/elf.R_TYPE64 from debug/elf/elf.go:
func __r_TYPE64(info uint64) Object {
	_res := _elf.R_TYPE64(info)
	return MakeBigIntU(uint64(_res))
}

GO FUNC debug/elf.ST_BIND from debug/elf/elf.go:
func __sT_BIND(info uint8) Object {
	_res := _elf.ST_BIND(info)
	return MakeGoObject(_res)
}

GO FUNC debug/elf.ST_INFO from debug/elf/elf.go:
func __sT_INFO(bind _elf.SymBind, typ _elf.SymType) Object {
	_res := _elf.ST_INFO(bind, typ)
	return MakeInt(int(_res))
}

GO FUNC debug/elf.ST_TYPE from debug/elf/elf.go:
func __sT_TYPE(info uint8) Object {
	_res := _elf.ST_TYPE(info)
	return MakeGoObject(_res)
}

GO FUNC debug/elf.ST_VISIBILITY from debug/elf/elf.go:
func __sT_VISIBILITY(other uint8) Object {
	_res := _elf.ST_VISIBILITY(other)
	return MakeGoObject(_res)
}

GO FUNC debug/elf.__class_GoString from debug/elf/elf.go:
func __class_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Class)GoString()", args, 0, 0)
	_res := o.O.(_elf.Class).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__class_String from debug/elf/elf.go:
func __class_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Class)String()", args, 0, 0)
	_res := o.O.(_elf.Class).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__compressionType_GoString from debug/elf/elf.go:
func __compressionType_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.CompressionType)GoString()", args, 0, 0)
	_res := o.O.(_elf.CompressionType).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__compressionType_String from debug/elf/elf.go:
func __compressionType_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.CompressionType)String()", args, 0, 0)
	_res := o.O.(_elf.CompressionType).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__data_GoString from debug/elf/elf.go:
func __data_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Data)GoString()", args, 0, 0)
	_res := o.O.(_elf.Data).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__data_String from debug/elf/elf.go:
func __data_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Data)String()", args, 0, 0)
	_res := o.O.(_elf.Data).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__dynFlag_GoString from debug/elf/elf.go:
func __dynFlag_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.DynFlag)GoString()", args, 0, 0)
	_res := o.O.(_elf.DynFlag).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__dynFlag_String from debug/elf/elf.go:
func __dynFlag_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.DynFlag)String()", args, 0, 0)
	_res := o.O.(_elf.DynFlag).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__dynTag_GoString from debug/elf/elf.go:
func __dynTag_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.DynTag)GoString()", args, 0, 0)
	_res := o.O.(_elf.DynTag).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__dynTag_String from debug/elf/elf.go:
func __dynTag_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.DynTag)String()", args, 0, 0)
	_res := o.O.(_elf.DynTag).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__machine_GoString from debug/elf/elf.go:
func __machine_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Machine)GoString()", args, 0, 0)
	_res := o.O.(_elf.Machine).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__machine_String from debug/elf/elf.go:
func __machine_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Machine)String()", args, 0, 0)
	_res := o.O.(_elf.Machine).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__nType_GoString from debug/elf/elf.go:
func __nType_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.NType)GoString()", args, 0, 0)
	_res := o.O.(_elf.NType).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__nType_String from debug/elf/elf.go:
func __nType_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.NType)String()", args, 0, 0)
	_res := o.O.(_elf.NType).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__oSABI_GoString from debug/elf/elf.go:
func __oSABI_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.OSABI)GoString()", args, 0, 0)
	_res := o.O.(_elf.OSABI).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__oSABI_String from debug/elf/elf.go:
func __oSABI_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.OSABI)String()", args, 0, 0)
	_res := o.O.(_elf.OSABI).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__progFlag_GoString from debug/elf/elf.go:
func __progFlag_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.ProgFlag)GoString()", args, 0, 0)
	_res := o.O.(_elf.ProgFlag).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__progFlag_String from debug/elf/elf.go:
func __progFlag_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.ProgFlag)String()", args, 0, 0)
	_res := o.O.(_elf.ProgFlag).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__progType_GoString from debug/elf/elf.go:
func __progType_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.ProgType)GoString()", args, 0, 0)
	_res := o.O.(_elf.ProgType).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__progType_String from debug/elf/elf.go:
func __progType_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.ProgType)String()", args, 0, 0)
	_res := o.O.(_elf.ProgType).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__ptrTo_File_Close from debug/elf/file.go:
func __ptrTo_File_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)Close()", args, 0, 0)
	_res := o.O.(*_elf.File).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC debug/elf.__ptrTo_File_DWARF from debug/elf/file.go:
func __ptrTo_File_DWARF(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)DWARF()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.File).DWARF()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_File_DynString from debug/elf/file.go:
func __ptrTo_File_DynString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/elf.File)DynString()", args, 1, 1)
	tag := ExtractGo_go_std_debug_elf__DynTag("(*_debug/elf.File)DynString()", "tag", _argList, 0)
	_res1, _res2 := o.O.(*_elf.File).DynString(tag)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_File_DynamicSymbols from debug/elf/file.go:
func __ptrTo_File_DynamicSymbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)DynamicSymbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.File).DynamicSymbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_File_ImportedLibraries from debug/elf/file.go:
func __ptrTo_File_ImportedLibraries(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)ImportedLibraries()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.File).ImportedLibraries()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_File_ImportedSymbols from debug/elf/file.go:
func __ptrTo_File_ImportedSymbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)ImportedSymbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.File).ImportedSymbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_File_Section from debug/elf/file.go:
func __ptrTo_File_Section(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/elf.File)Section()", args, 1, 1)
	name := ExtractGoString("(*_debug/elf.File)Section()", "name", _argList, 0)
	_res := o.O.(*_elf.File).Section(name)
	return MakeGoObject(_res)
}

GO FUNC debug/elf.__ptrTo_File_SectionByType from debug/elf/file.go:
func __ptrTo_File_SectionByType(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/elf.File)SectionByType()", args, 1, 1)
	typ := ExtractGo_go_std_debug_elf__SectionType("(*_debug/elf.File)SectionByType()", "typ", _argList, 0)
	_res := o.O.(*_elf.File).SectionByType(typ)
	return MakeGoObject(_res)
}

GO FUNC debug/elf.__ptrTo_File_Symbols from debug/elf/file.go:
func __ptrTo_File_Symbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.File)Symbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.File).Symbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_FormatError_Error from debug/elf/file.go:
func __ptrTo_FormatError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.FormatError)Error()", args, 0, 0)
	_res := o.O.(*_elf.FormatError).Error()
	return MakeString(_res)
}

GO FUNC debug/elf.__ptrTo_Prog_Open from debug/elf/file.go:
func __ptrTo_Prog_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.Prog)Open()", args, 0, 0)
	_res := o.O.(*_elf.Prog).Open()
	return MakeGoObject(_res)
}

GO FUNC debug/elf.__ptrTo_Section_Data from debug/elf/file.go:
func __ptrTo_Section_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.Section)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_elf.Section).Data()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.__ptrTo_Section_Open from debug/elf/file.go:
func __ptrTo_Section_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/elf.Section)Open()", args, 0, 0)
	_res := o.O.(*_elf.Section).Open()
	return MakeGoObject(_res)
}

GO FUNC debug/elf.__r_386_GoString from debug/elf/elf.go:
func __r_386_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_386)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_386).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_386_String from debug/elf/elf.go:
func __r_386_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_386)String()", args, 0, 0)
	_res := o.O.(_elf.R_386).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_390_GoString from debug/elf/elf.go:
func __r_390_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_390)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_390).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_390_String from debug/elf/elf.go:
func __r_390_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_390)String()", args, 0, 0)
	_res := o.O.(_elf.R_390).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_AARCH64_GoString from debug/elf/elf.go:
func __r_AARCH64_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_AARCH64)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_AARCH64).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_AARCH64_String from debug/elf/elf.go:
func __r_AARCH64_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_AARCH64)String()", args, 0, 0)
	_res := o.O.(_elf.R_AARCH64).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_ALPHA_GoString from debug/elf/elf.go:
func __r_ALPHA_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_ALPHA)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_ALPHA).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_ALPHA_String from debug/elf/elf.go:
func __r_ALPHA_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_ALPHA)String()", args, 0, 0)
	_res := o.O.(_elf.R_ALPHA).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_ARM_GoString from debug/elf/elf.go:
func __r_ARM_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_ARM)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_ARM).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_ARM_String from debug/elf/elf.go:
func __r_ARM_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_ARM)String()", args, 0, 0)
	_res := o.O.(_elf.R_ARM).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_MIPS_GoString from debug/elf/elf.go:
func __r_MIPS_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_MIPS)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_MIPS).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_MIPS_String from debug/elf/elf.go:
func __r_MIPS_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_MIPS)String()", args, 0, 0)
	_res := o.O.(_elf.R_MIPS).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_PPC64_GoString from debug/elf/elf.go:
func __r_PPC64_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_PPC64)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_PPC64).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_PPC64_String from debug/elf/elf.go:
func __r_PPC64_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_PPC64)String()", args, 0, 0)
	_res := o.O.(_elf.R_PPC64).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_PPC_GoString from debug/elf/elf.go:
func __r_PPC_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_PPC)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_PPC).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_PPC_String from debug/elf/elf.go:
func __r_PPC_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_PPC)String()", args, 0, 0)
	_res := o.O.(_elf.R_PPC).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_RISCV_GoString from debug/elf/elf.go:
func __r_RISCV_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_RISCV)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_RISCV).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_RISCV_String from debug/elf/elf.go:
func __r_RISCV_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_RISCV)String()", args, 0, 0)
	_res := o.O.(_elf.R_RISCV).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_SPARC_GoString from debug/elf/elf.go:
func __r_SPARC_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_SPARC)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_SPARC).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_SPARC_String from debug/elf/elf.go:
func __r_SPARC_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_SPARC)String()", args, 0, 0)
	_res := o.O.(_elf.R_SPARC).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_X86_64_GoString from debug/elf/elf.go:
func __r_X86_64_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_X86_64)GoString()", args, 0, 0)
	_res := o.O.(_elf.R_X86_64).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__r_X86_64_String from debug/elf/elf.go:
func __r_X86_64_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.R_X86_64)String()", args, 0, 0)
	_res := o.O.(_elf.R_X86_64).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionFlag_GoString from debug/elf/elf.go:
func __sectionFlag_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionFlag)GoString()", args, 0, 0)
	_res := o.O.(_elf.SectionFlag).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionFlag_String from debug/elf/elf.go:
func __sectionFlag_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionFlag)String()", args, 0, 0)
	_res := o.O.(_elf.SectionFlag).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionIndex_GoString from debug/elf/elf.go:
func __sectionIndex_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionIndex)GoString()", args, 0, 0)
	_res := o.O.(_elf.SectionIndex).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionIndex_String from debug/elf/elf.go:
func __sectionIndex_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionIndex)String()", args, 0, 0)
	_res := o.O.(_elf.SectionIndex).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionType_GoString from debug/elf/elf.go:
func __sectionType_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionType)GoString()", args, 0, 0)
	_res := o.O.(_elf.SectionType).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__sectionType_String from debug/elf/elf.go:
func __sectionType_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SectionType)String()", args, 0, 0)
	_res := o.O.(_elf.SectionType).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__symBind_GoString from debug/elf/elf.go:
func __symBind_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymBind)GoString()", args, 0, 0)
	_res := o.O.(_elf.SymBind).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__symBind_String from debug/elf/elf.go:
func __symBind_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymBind)String()", args, 0, 0)
	_res := o.O.(_elf.SymBind).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__symType_GoString from debug/elf/elf.go:
func __symType_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymType)GoString()", args, 0, 0)
	_res := o.O.(_elf.SymType).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__symType_String from debug/elf/elf.go:
func __symType_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymType)String()", args, 0, 0)
	_res := o.O.(_elf.SymType).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__symVis_GoString from debug/elf/elf.go:
func __symVis_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymVis)GoString()", args, 0, 0)
	_res := o.O.(_elf.SymVis).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__symVis_String from debug/elf/elf.go:
func __symVis_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.SymVis)String()", args, 0, 0)
	_res := o.O.(_elf.SymVis).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__type_GoString from debug/elf/elf.go:
func __type_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Type)GoString()", args, 0, 0)
	_res := o.O.(_elf.Type).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__type_String from debug/elf/elf.go:
func __type_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Type)String()", args, 0, 0)
	_res := o.O.(_elf.Type).String()
	return MakeString(_res)
}

GO FUNC debug/elf.__version_GoString from debug/elf/elf.go:
func __version_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Version)GoString()", args, 0, 0)
	_res := o.O.(_elf.Version).GoString()
	return MakeString(_res)
}

GO FUNC debug/elf.__version_String from debug/elf/elf.go:
func __version_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/elf.Version)String()", args, 0, 0)
	_res := o.O.(_elf.Version).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package elf

import (
	_elf "debug/elf"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_Class = GoTypeInfo{Members: GoMembers{
	"GoString": __class_GoString,
	"String": __class_String,
}}

var members_CompressionType = GoTypeInfo{Members: GoMembers{
	"GoString": __compressionType_GoString,
	"String": __compressionType_String,
}}

var members_Data = GoTypeInfo{Members: GoMembers{
	"GoString": __data_GoString,
	"String": __data_String,
}}

var members_DynFlag = GoTypeInfo{Members: GoMembers{
	"GoString": __dynFlag_GoString,
	"String": __dynFlag_String,
}}

var members_DynTag = GoTypeInfo{Members: GoMembers{
	"GoString": __dynTag_GoString,
	"String": __dynTag_String,
}}

var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_File_Close,
	"DWARF": __ptrTo_File_DWARF,
	"DynString": __ptrTo_File_DynString,
	"DynamicSymbols": __ptrTo_File_DynamicSymbols,
	"ImportedLibraries": __ptrTo_File_ImportedLibraries,
	"ImportedSymbols": __ptrTo_File_ImportedSymbols,
	"Section": __ptrTo_File_Section,
	"SectionByType": __ptrTo_File_SectionByType,
	"Symbols": __ptrTo_File_Symbols,
}}

var members_PtrTo_FormatError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_FormatError_Error,
}}

var members_Machine = GoTypeInfo{Members: GoMembers{
	"GoString": __machine_GoString,
	"String": __machine_String,
}}

var members_NType = GoTypeInfo{Members: GoMembers{
	"GoString": __nType_GoString,
	"String": __nType_String,
}}

var members_OSABI = GoTypeInfo{Members: GoMembers{
	"GoString": __oSABI_GoString,
	"String": __oSABI_String,
}}

var members_PtrTo_Prog = GoTypeInfo{Members: GoMembers{
	"Open": __ptrTo_Prog_Open,
}}

var members_ProgFlag = GoTypeInfo{Members: GoMembers{
	"GoString": __progFlag_GoString,
	"String": __progFlag_String,
}}

var members_ProgType = GoTypeInfo{Members: GoMembers{
	"GoString": __progType_GoString,
	"String": __progType_String,
}}

var members_R_386 = GoTypeInfo{Members: GoMembers{
	"GoString": __r_386_GoString,
	"String": __r_386_String,
}}

var members_R_390 = GoTypeInfo{Members: GoMembers{
	"GoString": __r_390_GoString,
	"String": __r_390_String,
}}

var members_R_AARCH64 = GoTypeInfo{Members: GoMembers{
	"GoString": __r_AARCH64_GoString,
	"String": __r_AARCH64_String,
}}

var members_R_ALPHA = GoTypeInfo{Members: GoMembers{
	"GoString": __r_ALPHA_GoString,
	"String": __r_ALPHA_String,
}}

var members_R_ARM = GoTypeInfo{Members: GoMembers{
	"GoString": __r_ARM_GoString,
	"String": __r_ARM_String,
}}

var members_R_MIPS = GoTypeInfo{Members: GoMembers{
	"GoString": __r_MIPS_GoString,
	"String": __r_MIPS_String,
}}

var members_R_PPC = GoTypeInfo{Members: GoMembers{
	"GoString": __r_PPC_GoString,
	"String": __r_PPC_String,
}}

var members_R_PPC64 = GoTypeInfo{Members: GoMembers{
	"GoString": __r_PPC64_GoString,
	"String": __r_PPC64_String,
}}

var members_R_RISCV = GoTypeInfo{Members: GoMembers{
	"GoString": __r_RISCV_GoString,
	"String": __r_RISCV_String,
}}

var members_R_SPARC = GoTypeInfo{Members: GoMembers{
	"GoString": __r_SPARC_GoString,
	"String": __r_SPARC_String,
}}

var members_R_X86_64 = GoTypeInfo{Members: GoMembers{
	"GoString": __r_X86_64_GoString,
	"String": __r_X86_64_String,
}}

var members_PtrTo_Section = GoTypeInfo{Members: GoMembers{
	"Data": __ptrTo_Section_Data,
	"Open": __ptrTo_Section_Open,
}}

var members_SectionFlag = GoTypeInfo{Members: GoMembers{
	"GoString": __sectionFlag_GoString,
	"String": __sectionFlag_String,
}}

var members_SectionIndex = GoTypeInfo{Members: GoMembers{
	"GoString": __sectionIndex_GoString,
	"String": __sectionIndex_String,
}}

var members_SectionType = GoTypeInfo{Members: GoMembers{
	"GoString": __sectionType_GoString,
	"String": __sectionType_String,
}}

var members_SymBind = GoTypeInfo{Members: GoMembers{
	"GoString": __symBind_GoString,
	"String": __symBind_String,
}}

var members_SymType = GoTypeInfo{Members: GoMembers{
	"GoString": __symType_GoString,
	"String": __symType_String,
}}

var members_SymVis = GoTypeInfo{Members: GoMembers{
	"GoString": __symVis_GoString,
	"String": __symVis_String,
}}

var members_Type = GoTypeInfo{Members: GoMembers{
	"GoString": __type_GoString,
	"String": __type_String,
}}

var members_Version = GoTypeInfo{Members: GoMembers{
	"GoString": __version_GoString,
	"String": __version_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_elf.Class)(nil)).Elem()] = &members_Class
	GoTypes[_reflect.TypeOf((*_elf.CompressionType)(nil)).Elem()] = &members_CompressionType
	GoTypes[_reflect.TypeOf((*_elf.Data)(nil)).Elem()] = &members_Data
	GoTypes[_reflect.TypeOf((*_elf.DynFlag)(nil)).Elem()] = &members_DynFlag
	GoTypes[_reflect.TypeOf((*_elf.DynTag)(nil)).Elem()] = &members_DynTag
	GoTypes[_reflect.TypeOf((*_elf.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_elf.FormatError)(nil))] = &members_PtrTo_FormatError
	GoTypes[_reflect.TypeOf((*_elf.Machine)(nil)).Elem()] = &members_Machine
	GoTypes[_reflect.TypeOf((*_elf.NType)(nil)).Elem()] = &members_NType
	GoTypes[_reflect.TypeOf((*_elf.OSABI)(nil)).Elem()] = &members_OSABI
	GoTypes[_reflect.TypeOf((*_elf.Prog)(nil))] = &members_PtrTo_Prog
	GoTypes[_reflect.TypeOf((*_elf.ProgFlag)(nil)).Elem()] = &members_ProgFlag
	GoTypes[_reflect.TypeOf((*_elf.ProgType)(nil)).Elem()] = &members_ProgType
	GoTypes[_reflect.TypeOf((*_elf.R_386)(nil)).Elem()] = &members_R_386
	GoTypes[_reflect.TypeOf((*_elf.R_390)(nil)).Elem()] = &members_R_390
	GoTypes[_reflect.TypeOf((*_elf.R_AARCH64)(nil)).Elem()] = &members_R_AARCH64
	GoTypes[_reflect.TypeOf((*_elf.R_ALPHA)(nil)).Elem()] = &members_R_ALPHA
	GoTypes[_reflect.TypeOf((*_elf.R_ARM)(nil)).Elem()] = &members_R_ARM
	GoTypes[_reflect.TypeOf((*_elf.R_MIPS)(nil)).Elem()] = &members_R_MIPS
	GoTypes[_reflect.TypeOf((*_elf.R_PPC)(nil)).Elem()] = &members_R_PPC
	GoTypes[_reflect.TypeOf((*_elf.R_PPC64)(nil)).Elem()] = &members_R_PPC64
	GoTypes[_reflect.TypeOf((*_elf.R_RISCV)(nil)).Elem()] = &members_R_RISCV
	GoTypes[_reflect.TypeOf((*_elf.R_SPARC)(nil)).Elem()] = &members_R_SPARC
	GoTypes[_reflect.TypeOf((*_elf.R_X86_64)(nil)).Elem()] = &members_R_X86_64
	GoTypes[_reflect.TypeOf((*_elf.Section)(nil))] = &members_PtrTo_Section
	GoTypes[_reflect.TypeOf((*_elf.SectionFlag)(nil)).Elem()] = &members_SectionFlag
	GoTypes[_reflect.TypeOf((*_elf.SectionIndex)(nil)).Elem()] = &members_SectionIndex
	GoTypes[_reflect.TypeOf((*_elf.SectionType)(nil)).Elem()] = &members_SectionType
	GoTypes[_reflect.TypeOf((*_elf.SymBind)(nil)).Elem()] = &members_SymBind
	GoTypes[_reflect.TypeOf((*_elf.SymType)(nil)).Elem()] = &members_SymType
	GoTypes[_reflect.TypeOf((*_elf.SymVis)(nil)).Elem()] = &members_SymVis
	GoTypes[_reflect.TypeOf((*_elf.Type)(nil)).Elem()] = &members_Type
	GoTypes[_reflect.TypeOf((*_elf.Version)(nil)).Elem()] = &members_Version
}

GO TYPE debug/gosym.DecodingError from debug/gosym/symtab.go:
func ExtractGoObjectDecodingError(args []Object, index int) *_gosym.DecodingError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.DecodingError:
			return &r
		case *_gosym.DecodingError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.DecodingError]"))
}

func _mapToDecodingError(o Map) *_gosym.DecodingError {
	return &_gosym.DecodingError{}
}

func _vectorToDecodingError(o *Vector) *_gosym.DecodingError {
	return &_gosym.DecodingError{}
}

func _ConstructDecodingError(_v Object) *_gosym.DecodingError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _gosym.DecodingError:
			return &_g
		case *_gosym.DecodingError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDecodingError(_o.(Map))
	case *Vector:
		return _vectorToDecodingError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.DecodingError] or: Map or Vector"))
}

GO TYPE debug/gosym.Func from debug/gosym/symtab.go:
func ExtractGoObjectFunc(args []Object, index int) *_gosym.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.Func:
			return &r
		case *_gosym.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.Func]"))
}

// func _mapToFunc(o Map) *_gosym.Func {
// 	return &_gosym.Func{}
// }

// func _vectorToFunc(o *Vector) *_gosym.Func {
// 	return &_gosym.Func{
// 		Entry: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		End: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Params: ABEND048(codegen.go: no conversion from Clojure for []*debug/gosym.Sym (*debug/gosym.Sym)),
// 		Locals: ABEND048(codegen.go: no conversion from Clojure for []*debug/gosym.Sym (*debug/gosym.Sym)),
// 		FrameSize: AssertInt(o.Nth(4), "").I,
// 		LineTable: ABEND048(codegen.go: no conversion from Clojure for *debug/gosym.LineTable (debug/gosym.LineTable)),
// 		Obj: ABEND048(codegen.go: no conversion from Clojure for *debug/gosym.Obj (debug/gosym.Obj)),
// 	}
// }

// func _ConstructFunc(_v Object) *_gosym.Func {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gosym.Func:
// 			return &_g
// 		case *_gosym.Func:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFunc(_o.(Map))
// 	case *Vector:
// 		return _vectorToFunc(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.Func] or: Map or Vector"))
// }

GO TYPE debug/gosym.LineTable from debug/gosym/pclntab.go:
func ExtractGoObjectLineTable(args []Object, index int) *_gosym.LineTable {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.LineTable:
			return &r
		case *_gosym.LineTable:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.LineTable]"))
}

// func _mapToLineTable(o Map) *_gosym.LineTable {
// 	return &_gosym.LineTable{}
// }

// func _vectorToLineTable(o *Vector) *_gosym.LineTable {
// 	return &_gosym.LineTable{
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		PC: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Line: AssertInt(o.Nth(2), "").I,
// 	}
// }

// func _ConstructLineTable(_v Object) *_gosym.LineTable {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gosym.LineTable:
// 			return &_g
// 		case *_gosym.LineTable:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToLineTable(_o.(Map))
// 	case *Vector:
// 		return _vectorToLineTable(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.LineTable] or: Map or Vector"))
// }

GO TYPE debug/gosym.Obj from debug/gosym/symtab.go:
func ExtractGoObjectObj(args []Object, index int) *_gosym.Obj {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.Obj:
			return &r
		case *_gosym.Obj:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.Obj]"))
}

// func _mapToObj(o Map) *_gosym.Obj {
// 	return &_gosym.Obj{}
// }

// func _vectorToObj(o *Vector) *_gosym.Obj {
// 	return &_gosym.Obj{
// 		Funcs: ABEND048(codegen.go: no conversion from Clojure for []debug/gosym.Func (debug/gosym.Func)),
// 		Paths: ABEND048(codegen.go: no conversion from Clojure for []debug/gosym.Sym (debug/gosym.Sym)),
// 	}
// }

// func _ConstructObj(_v Object) *_gosym.Obj {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gosym.Obj:
// 			return &_g
// 		case *_gosym.Obj:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToObj(_o.(Map))
// 	case *Vector:
// 		return _vectorToObj(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.Obj] or: Map or Vector"))
// }

GO TYPE debug/gosym.Sym from debug/gosym/symtab.go:
func ExtractGoObjectSym(args []Object, index int) *_gosym.Sym {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.Sym:
			return &r
		case *_gosym.Sym:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.Sym]"))
}

// func _mapToSym(o Map) *_gosym.Sym {
// 	return &_gosym.Sym{}
// }

// func _vectorToSym(o *Vector) *_gosym.Sym {
// 	return &_gosym.Sym{
// 		Value: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		Type: byte(AssertInt(o.Nth(1), "").I),
// 		Name: AssertString(o.Nth(2), "").S,
// 		GoType: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Func: ABEND048(codegen.go: no conversion from Clojure for *debug/gosym.Func (debug/gosym.Func)),
// 	}
// }

// func _ConstructSym(_v Object) *_gosym.Sym {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gosym.Sym:
// 			return &_g
// 		case *_gosym.Sym:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSym(_o.(Map))
// 	case *Vector:
// 		return _vectorToSym(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.Sym] or: Map or Vector"))
// }

GO TYPE debug/gosym.Table from debug/gosym/symtab.go:
func ExtractGoObjectTable(args []Object, index int) *_gosym.Table {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.Table:
			return &r
		case *_gosym.Table:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.Table]"))
}

// func _mapToTable(o Map) *_gosym.Table {
// 	return &_gosym.Table{}
// }

// func _vectorToTable(o *Vector) *_gosym.Table {
// 	return &_gosym.Table{
// 		Syms: ABEND048(codegen.go: no conversion from Clojure for []debug/gosym.Sym (debug/gosym.Sym)),
// 		Funcs: ABEND048(codegen.go: no conversion from Clojure for []debug/gosym.Func (debug/gosym.Func)),
// 		Files: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Objs: ABEND048(codegen.go: no conversion from Clojure for []debug/gosym.Obj (debug/gosym.Obj)),
// 	}
// }

// func _ConstructTable(_v Object) *_gosym.Table {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _gosym.Table:
// 			return &_g
// 		case *_gosym.Table:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTable(_o.(Map))
// 	case *Vector:
// 		return _vectorToTable(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.Table] or: Map or Vector"))
// }

GO TYPE debug/gosym.UnknownFileError from debug/gosym/symtab.go:
func ExtractGoObjectUnknownFileError(args []Object, index int) *_gosym.UnknownFileError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.UnknownFileError:
			return &r
		case *_gosym.UnknownFileError:
			return r
		}
	case String:
		v := _gosym.UnknownFileError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.UnknownFileError]"))
}

func _ConstructUnknownFileError(_v Object) _gosym.UnknownFileError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _gosym.UnknownFileError:
			return _g
		case *_gosym.UnknownFileError:
			return *_g
		}
	case String:
		return _gosym.UnknownFileError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.UnknownFileError] or: String"))
}

GO TYPE debug/gosym.UnknownLineError from debug/gosym/symtab.go:
func ExtractGoObjectUnknownLineError(args []Object, index int) *_gosym.UnknownLineError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _gosym.UnknownLineError:
			return &r
		case *_gosym.UnknownLineError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/gosym.UnknownLineError]"))
}

func _mapToUnknownLineError(o Map) *_gosym.UnknownLineError {
	return &_gosym.UnknownLineError{}
}

func _vectorToUnknownLineError(o *Vector) *_gosym.UnknownLineError {
	return &_gosym.UnknownLineError{
		File: AssertString(o.Nth(0), "").S,
		Line: AssertInt(o.Nth(1), "").I,
	}
}

func _ConstructUnknownLineError(_v Object) *_gosym.UnknownLineError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _gosym.UnknownLineError:
			return &_g
		case *_gosym.UnknownLineError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnknownLineError(_o.(Map))
	case *Vector:
		return _vectorToUnknownLineError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[gosym.UnknownLineError] or: Map or Vector"))
}

GO FUNC debug/gosym.NewLineTable from debug/gosym/pclntab.go:
// func __newLineTable(data []byte, text uint64) Object {
// 	_res := _gosym.NewLineTable(data, text)
// 	return MakeGoObject(_res)
// }

GO FUNC debug/gosym.NewTable from debug/gosym/symtab.go:
// func __newTable(symtab []byte, pcln *_gosym.LineTable) Object {
// 	_res1, _res2 := _gosym.NewTable(symtab, pcln)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/gosym.__ptrTo_DecodingError_Error from debug/gosym/symtab.go:
func __ptrTo_DecodingError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.DecodingError)Error()", args, 0, 0)
	_res := o.O.(*_gosym.DecodingError).Error()
	return MakeString(_res)
}

GO FUNC debug/gosym.__ptrTo_LineTable_LineToPC from debug/gosym/pclntab.go:
func __ptrTo_LineTable_LineToPC(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.LineTable)LineToPC()", args, 2, 2)
	line := ExtractGoInt("(*_debug/gosym.LineTable)LineToPC()", "line", _argList, 0)
	maxpc := ExtractGoUInt64("(*_debug/gosym.LineTable)LineToPC()", "maxpc", _argList, 1)
	_res := o.O.(*_gosym.LineTable).LineToPC(line, maxpc)
	return MakeBigIntU(_res)
}

GO FUNC debug/gosym.__ptrTo_LineTable_PCToLine from debug/gosym/pclntab.go:
func __ptrTo_LineTable_PCToLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.LineTable)PCToLine()", args, 1, 1)
	pc := ExtractGoUInt64("(*_debug/gosym.LineTable)PCToLine()", "pc", _argList, 0)
	_res := o.O.(*_gosym.LineTable).PCToLine(pc)
	return MakeInt(_res)
}

GO FUNC debug/gosym.__ptrTo_Sym_BaseName from debug/gosym/symtab.go:
func __ptrTo_Sym_BaseName(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.Sym)BaseName()", args, 0, 0)
	_res := o.O.(*_gosym.Sym).BaseName()
	return MakeString(_res)
}

GO FUNC debug/gosym.__ptrTo_Sym_PackageName from debug/gosym/symtab.go:
func __ptrTo_Sym_PackageName(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.Sym)PackageName()", args, 0, 0)
	_res := o.O.(*_gosym.Sym).PackageName()
	return MakeString(_res)
}

GO FUNC debug/gosym.__ptrTo_Sym_ReceiverName from debug/gosym/symtab.go:
func __ptrTo_Sym_ReceiverName(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.Sym)ReceiverName()", args, 0, 0)
	_res := o.O.(*_gosym.Sym).ReceiverName()
	return MakeString(_res)
}

GO FUNC debug/gosym.__ptrTo_Sym_Static from debug/gosym/symtab.go:
func __ptrTo_Sym_Static(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.Sym)Static()", args, 0, 0)
	_res := o.O.(*_gosym.Sym).Static()
	return MakeBoolean(_res)
}

GO FUNC debug/gosym.__ptrTo_Table_LineToPC from debug/gosym/symtab.go:
func __ptrTo_Table_LineToPC(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)LineToPC()", args, 2, 2)
	file := ExtractGoString("(*_debug/gosym.Table)LineToPC()", "file", _argList, 0)
	line := ExtractGoInt("(*_debug/gosym.Table)LineToPC()", "line", _argList, 1)
	pc, fn, err := o.O.(*_gosym.Table).LineToPC(file, line)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(pc))
	_res = _res.Conjoin(MakeGoObject(fn))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC debug/gosym.__ptrTo_Table_LookupFunc from debug/gosym/symtab.go:
func __ptrTo_Table_LookupFunc(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)LookupFunc()", args, 1, 1)
	name := ExtractGoString("(*_debug/gosym.Table)LookupFunc()", "name", _argList, 0)
	_res := o.O.(*_gosym.Table).LookupFunc(name)
	return MakeGoObject(_res)
}

GO FUNC debug/gosym.__ptrTo_Table_LookupSym from debug/gosym/symtab.go:
func __ptrTo_Table_LookupSym(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)LookupSym()", args, 1, 1)
	name := ExtractGoString("(*_debug/gosym.Table)LookupSym()", "name", _argList, 0)
	_res := o.O.(*_gosym.Table).LookupSym(name)
	return MakeGoObject(_res)
}

GO FUNC debug/gosym.__ptrTo_Table_PCToFunc from debug/gosym/symtab.go:
func __ptrTo_Table_PCToFunc(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)PCToFunc()", args, 1, 1)
	pc := ExtractGoUInt64("(*_debug/gosym.Table)PCToFunc()", "pc", _argList, 0)
	_res := o.O.(*_gosym.Table).PCToFunc(pc)
	return MakeGoObject(_res)
}

GO FUNC debug/gosym.__ptrTo_Table_PCToLine from debug/gosym/symtab.go:
func __ptrTo_Table_PCToLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)PCToLine()", args, 1, 1)
	pc := ExtractGoUInt64("(*_debug/gosym.Table)PCToLine()", "pc", _argList, 0)
	file, line, fn := o.O.(*_gosym.Table).PCToLine(pc)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(file))
	_res = _res.Conjoin(MakeInt(line))
	_res = _res.Conjoin(MakeGoObject(fn))
	return _res
}

GO FUNC debug/gosym.__ptrTo_Table_SymByAddr from debug/gosym/symtab.go:
func __ptrTo_Table_SymByAddr(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/gosym.Table)SymByAddr()", args, 1, 1)
	addr := ExtractGoUInt64("(*_debug/gosym.Table)SymByAddr()", "addr", _argList, 0)
	_res := o.O.(*_gosym.Table).SymByAddr(addr)
	return MakeGoObject(_res)
}

GO FUNC debug/gosym.__ptrTo_UnknownLineError_Error from debug/gosym/symtab.go:
func __ptrTo_UnknownLineError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/gosym.UnknownLineError)Error()", args, 0, 0)
	_res := o.O.(*_gosym.UnknownLineError).Error()
	return MakeString(_res)
}

GO FUNC debug/gosym.__unknownFileError_Error from debug/gosym/symtab.go:
func __unknownFileError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_debug/gosym.UnknownFileError)Error()", args, 0, 0)
	_res := o.O.(_gosym.UnknownFileError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package gosym

import (
	_gosym "debug/gosym"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_DecodingError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_DecodingError_Error,
}}

var members_PtrTo_LineTable = GoTypeInfo{Members: GoMembers{
	"LineToPC": __ptrTo_LineTable_LineToPC,
	"PCToLine": __ptrTo_LineTable_PCToLine,
}}

var members_PtrTo_Sym = GoTypeInfo{Members: GoMembers{
	"BaseName": __ptrTo_Sym_BaseName,
	"PackageName": __ptrTo_Sym_PackageName,
	"ReceiverName": __ptrTo_Sym_ReceiverName,
	"Static": __ptrTo_Sym_Static,
}}

var members_PtrTo_Table = GoTypeInfo{Members: GoMembers{
	"LineToPC": __ptrTo_Table_LineToPC,
	"LookupFunc": __ptrTo_Table_LookupFunc,
	"LookupSym": __ptrTo_Table_LookupSym,
	"PCToFunc": __ptrTo_Table_PCToFunc,
	"PCToLine": __ptrTo_Table_PCToLine,
	"SymByAddr": __ptrTo_Table_SymByAddr,
}}

var members_UnknownFileError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownFileError_Error,
}}

var members_PtrTo_UnknownLineError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnknownLineError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_gosym.DecodingError)(nil))] = &members_PtrTo_DecodingError
	GoTypes[_reflect.TypeOf((*_gosym.LineTable)(nil))] = &members_PtrTo_LineTable
	GoTypes[_reflect.TypeOf((*_gosym.Sym)(nil))] = &members_PtrTo_Sym
	GoTypes[_reflect.TypeOf((*_gosym.Table)(nil))] = &members_PtrTo_Table
	GoTypes[_reflect.TypeOf((*_gosym.UnknownFileError)(nil)).Elem()] = &members_UnknownFileError
	GoTypes[_reflect.TypeOf((*_gosym.UnknownLineError)(nil))] = &members_PtrTo_UnknownLineError
}

GO TYPE debug/macho.Cpu from debug/macho/macho.go:
func ExtractGoObjectCpu(args []Object, index int) *_macho.Cpu {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Cpu:
			return &r
		case *_macho.Cpu:
			return r
		}
	case Number:
		v := _macho.Cpu(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Cpu]"))
}

func _ConstructCpu(_v Object) _macho.Cpu {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Cpu:
			return _g
		case *_macho.Cpu:
			return *_g
		}
	case Number:
		return _macho.Cpu(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Cpu] or: Number"))
}

GO TYPE debug/macho.Dylib from debug/macho/file.go:
func ExtractGoObjectDylib(args []Object, index int) *_macho.Dylib {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Dylib:
			return &r
		case *_macho.Dylib:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Dylib]"))
}

func _mapToDylib(o Map) *_macho.Dylib {
	return &_macho.Dylib{}
}

func _vectorToDylib(o *Vector) *_macho.Dylib {
	return &_macho.Dylib{
		Name: AssertString(o.Nth(0), "").S,
		Time: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		CurrentVersion: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		CompatVersion: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
	}
}

func _ConstructDylib(_v Object) *_macho.Dylib {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Dylib:
			return &_g
		case *_macho.Dylib:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDylib(_o.(Map))
	case *Vector:
		return _vectorToDylib(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Dylib] or: Map or Vector"))
}

GO TYPE debug/macho.DylibCmd from debug/macho/macho.go:
func ExtractGoObjectDylibCmd(args []Object, index int) *_macho.DylibCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.DylibCmd:
			return &r
		case *_macho.DylibCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.DylibCmd]"))
}

func _mapToDylibCmd(o Map) *_macho.DylibCmd {
	return &_macho.DylibCmd{}
}

func _vectorToDylibCmd(o *Vector) *_macho.DylibCmd {
	return &_macho.DylibCmd{
		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Name: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Time: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		CurrentVersion: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		CompatVersion: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
	}
}

func _ConstructDylibCmd(_v Object) *_macho.DylibCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.DylibCmd:
			return &_g
		case *_macho.DylibCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDylibCmd(_o.(Map))
	case *Vector:
		return _vectorToDylibCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.DylibCmd] or: Map or Vector"))
}

GO TYPE debug/macho.Dysymtab from debug/macho/file.go:
func ExtractGoObjectDysymtab(args []Object, index int) *_macho.Dysymtab {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Dysymtab:
			return &r
		case *_macho.Dysymtab:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Dysymtab]"))
}

// func _mapToDysymtab(o Map) *_macho.Dysymtab {
// 	return &_macho.Dysymtab{}
// }

// func _vectorToDysymtab(o *Vector) *_macho.Dysymtab {
// 	return &_macho.Dysymtab{
// 		IndirectSyms: ABEND048(codegen.go: no conversion from Clojure for []uint32 (uint32)),
// 	}
// }

// func _ConstructDysymtab(_v Object) *_macho.Dysymtab {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Dysymtab:
// 			return &_g
// 		case *_macho.Dysymtab:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDysymtab(_o.(Map))
// 	case *Vector:
// 		return _vectorToDysymtab(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Dysymtab] or: Map or Vector"))
// }

GO TYPE debug/macho.DysymtabCmd from debug/macho/macho.go:
func ExtractGoObjectDysymtabCmd(args []Object, index int) *_macho.DysymtabCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.DysymtabCmd:
			return &r
		case *_macho.DysymtabCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.DysymtabCmd]"))
}

func _mapToDysymtabCmd(o Map) *_macho.DysymtabCmd {
	return &_macho.DysymtabCmd{}
}

func _vectorToDysymtabCmd(o *Vector) *_macho.DysymtabCmd {
	return &_macho.DysymtabCmd{
		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Ilocalsym: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Nlocalsym: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Iextdefsym: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Nextdefsym: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		Iundefsym: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Nundefsym: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Tocoffset: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
		Ntoc: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
		Modtaboff: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
		Nmodtab: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
		Extrefsymoff: uint32(AssertNumber(o.Nth(12), "").BigInt().Uint64()),
		Nextrefsyms: uint32(AssertNumber(o.Nth(13), "").BigInt().Uint64()),
		Indirectsymoff: uint32(AssertNumber(o.Nth(14), "").BigInt().Uint64()),
		Nindirectsyms: uint32(AssertNumber(o.Nth(15), "").BigInt().Uint64()),
		Extreloff: uint32(AssertNumber(o.Nth(16), "").BigInt().Uint64()),
		Nextrel: uint32(AssertNumber(o.Nth(17), "").BigInt().Uint64()),
		Locreloff: uint32(AssertNumber(o.Nth(18), "").BigInt().Uint64()),
		Nlocrel: uint32(AssertNumber(o.Nth(19), "").BigInt().Uint64()),
	}
}

func _ConstructDysymtabCmd(_v Object) *_macho.DysymtabCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.DysymtabCmd:
			return &_g
		case *_macho.DysymtabCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDysymtabCmd(_o.(Map))
	case *Vector:
		return _vectorToDysymtabCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.DysymtabCmd] or: Map or Vector"))
}

GO TYPE debug/macho.FatArch from debug/macho/fat.go:
func ExtractGoObjectFatArch(args []Object, index int) *_macho.FatArch {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatArch:
			return &r
		case *_macho.FatArch:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatArch]"))
}

func _mapToFatArch(o Map) *_macho.FatArch {
	return &_macho.FatArch{}
}

func _vectorToFatArch(o *Vector) *_macho.FatArch {
	return &_macho.FatArch{}
}

func _ConstructFatArch(_v Object) *_macho.FatArch {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FatArch:
			return &_g
		case *_macho.FatArch:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFatArch(_o.(Map))
	case *Vector:
		return _vectorToFatArch(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatArch] or: Map or Vector"))
}

GO TYPE debug/macho.FatArchHeader from debug/macho/fat.go:
func ExtractGoObjectFatArchHeader(args []Object, index int) *_macho.FatArchHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatArchHeader:
			return &r
		case *_macho.FatArchHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatArchHeader]"))
}

func _mapToFatArchHeader(o Map) *_macho.FatArchHeader {
	return &_macho.FatArchHeader{}
}

func _vectorToFatArchHeader(o *Vector) *_macho.FatArchHeader {
	return &_macho.FatArchHeader{
		Cpu: _macho.Cpu(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		SubCpu: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Offset: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Align: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
	}
}

func _ConstructFatArchHeader(_v Object) *_macho.FatArchHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FatArchHeader:
			return &_g
		case *_macho.FatArchHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFatArchHeader(_o.(Map))
	case *Vector:
		return _vectorToFatArchHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatArchHeader] or: Map or Vector"))
}

GO TYPE debug/macho.FatFile from debug/macho/fat.go:
func ExtractGoObjectFatFile(args []Object, index int) *_macho.FatFile {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FatFile:
			return &r
		case *_macho.FatFile:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FatFile]"))
}

// func _mapToFatFile(o Map) *_macho.FatFile {
// 	return &_macho.FatFile{}
// }

// func _vectorToFatFile(o *Vector) *_macho.FatFile {
// 	return &_macho.FatFile{
// 		Magic: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Arches: ABEND048(codegen.go: no conversion from Clojure for []debug/macho.FatArch (debug/macho.FatArch)),
// 	}
// }

// func _ConstructFatFile(_v Object) *_macho.FatFile {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.FatFile:
// 			return &_g
// 		case *_macho.FatFile:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFatFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFatFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FatFile] or: Map or Vector"))
// }

GO TYPE debug/macho.File from debug/macho/file.go:
func ExtractGoObjectFile(args []Object, index int) *_macho.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.File:
			return &r
		case *_macho.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.File]"))
}

// func _mapToFile(o Map) *_macho.File {
// 	return &_macho.File{}
// }

// func _vectorToFile(o *Vector) *_macho.File {
// 	return &_macho.File{
// 		ByteOrder: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Loads: ABEND048(codegen.go: no conversion from Clojure for []debug/macho.Load (debug/macho.Load)),
// 		Sections: ABEND048(codegen.go: no conversion from Clojure for []*debug/macho.Section (*debug/macho.Section)),
// 		Symtab: ABEND048(codegen.go: no conversion from Clojure for *debug/macho.Symtab (debug/macho.Symtab)),
// 		Dysymtab: ABEND048(codegen.go: no conversion from Clojure for *debug/macho.Dysymtab (debug/macho.Dysymtab)),
// 	}
// }

// func _ConstructFile(_v Object) *_macho.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.File:
// 			return &_g
// 		case *_macho.File:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.File] or: Map or Vector"))
// }

GO TYPE debug/macho.FileHeader from debug/macho/macho.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_macho.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FileHeader:
			return &r
		case *_macho.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FileHeader]"))
}

func _mapToFileHeader(o Map) *_macho.FileHeader {
	return &_macho.FileHeader{}
}

func _vectorToFileHeader(o *Vector) *_macho.FileHeader {
	return &_macho.FileHeader{
		Magic: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Cpu: _macho.Cpu(uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64())),
		SubCpu: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Type: _macho.Type(uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64())),
		Ncmd: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Cmdsz: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		Flags: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
	}
}

func _ConstructFileHeader(_v Object) *_macho.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FileHeader:
			return &_g
		case *_macho.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FileHeader] or: Map or Vector"))
}

GO TYPE debug/macho.FormatError from debug/macho/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_macho.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.FormatError:
			return &r
		case *_macho.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.FormatError]"))
}

func _mapToFormatError(o Map) *_macho.FormatError {
	return &_macho.FormatError{}
}

func _vectorToFormatError(o *Vector) *_macho.FormatError {
	return &_macho.FormatError{}
}

func _ConstructFormatError(_v Object) *_macho.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.FormatError:
			return &_g
		case *_macho.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.FormatError] or: Map or Vector"))
}

GO TYPE debug/macho.Load from debug/macho/file.go:
func ExtractGoObjectLoad(args []Object, index int) *_macho.Load {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Load:
			return &r
		case *_macho.Load:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Load]"))
}

// func _ConstructLoad(_v Object) _macho.Load {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Load:
// 			return _g
// 		case *_macho.Load:
// 			return *_g
// 		}
// 	default:
// 		return _macho.Load(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Load))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Load] or: whatever"))
// }

GO TYPE debug/macho.LoadBytes from debug/macho/file.go:
func ExtractGoObjectLoadBytes(args []Object, index int) *_macho.LoadBytes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.LoadBytes:
			return &r
		case *_macho.LoadBytes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.LoadBytes]"))
}

// func _ConstructLoadBytes(_v Object) _macho.LoadBytes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.LoadBytes:
// 			return _g
// 		case *_macho.LoadBytes:
// 			return *_g
// 		}
// 	default:
// 		return _macho.LoadBytes(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for LoadBytes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.LoadBytes] or: whatever"))
// }

GO TYPE debug/macho.LoadCmd from debug/macho/macho.go:
func ExtractGoObjectLoadCmd(args []Object, index int) *_macho.LoadCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.LoadCmd:
			return &r
		case *_macho.LoadCmd:
			return r
		}
	case Number:
		v := _macho.LoadCmd(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.LoadCmd]"))
}

func _ConstructLoadCmd(_v Object) _macho.LoadCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.LoadCmd:
			return _g
		case *_macho.LoadCmd:
			return *_g
		}
	case Number:
		return _macho.LoadCmd(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.LoadCmd] or: Number"))
}

GO TYPE debug/macho.Nlist32 from debug/macho/macho.go:
func ExtractGoObjectNlist32(args []Object, index int) *_macho.Nlist32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Nlist32:
			return &r
		case *_macho.Nlist32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Nlist32]"))
}

func _mapToNlist32(o Map) *_macho.Nlist32 {
	return &_macho.Nlist32{}
}

func _vectorToNlist32(o *Vector) *_macho.Nlist32 {
	return &_macho.Nlist32{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Type: uint8(AssertInt(o.Nth(1), "").I),
		Sect: uint8(AssertInt(o.Nth(2), "").I),
		Desc: uint16(AssertInt(o.Nth(3), "").I),
		Value: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
	}
}

func _ConstructNlist32(_v Object) *_macho.Nlist32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Nlist32:
			return &_g
		case *_macho.Nlist32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlist32(_o.(Map))
	case *Vector:
		return _vectorToNlist32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Nlist32] or: Map or Vector"))
}

GO TYPE debug/macho.Nlist64 from debug/macho/macho.go:
func ExtractGoObjectNlist64(args []Object, index int) *_macho.Nlist64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Nlist64:
			return &r
		case *_macho.Nlist64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Nlist64]"))
}

func _mapToNlist64(o Map) *_macho.Nlist64 {
	return &_macho.Nlist64{}
}

func _vectorToNlist64(o *Vector) *_macho.Nlist64 {
	return &_macho.Nlist64{
		Name: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Type: uint8(AssertInt(o.Nth(1), "").I),
		Sect: uint8(AssertInt(o.Nth(2), "").I),
		Desc: uint16(AssertInt(o.Nth(3), "").I),
		Value: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
	}
}

func _ConstructNlist64(_v Object) *_macho.Nlist64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Nlist64:
			return &_g
		case *_macho.Nlist64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNlist64(_o.(Map))
	case *Vector:
		return _vectorToNlist64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Nlist64] or: Map or Vector"))
}

GO TYPE debug/macho.Regs386 from debug/macho/macho.go:
func ExtractGoObjectRegs386(args []Object, index int) *_macho.Regs386 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Regs386:
			return &r
		case *_macho.Regs386:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Regs386]"))
}

func _mapToRegs386(o Map) *_macho.Regs386 {
	return &_macho.Regs386{}
}

func _vectorToRegs386(o *Vector) *_macho.Regs386 {
	return &_macho.Regs386{
		AX: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		BX: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		CX: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		DX: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		DI: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		SI: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		BP: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		SP: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		SS: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
		FLAGS: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
		IP: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
		CS: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
		DS: uint32(AssertNumber(o.Nth(12), "").BigInt().Uint64()),
		ES: uint32(AssertNumber(o.Nth(13), "").BigInt().Uint64()),
		FS: uint32(AssertNumber(o.Nth(14), "").BigInt().Uint64()),
		GS: uint32(AssertNumber(o.Nth(15), "").BigInt().Uint64()),
	}
}

func _ConstructRegs386(_v Object) *_macho.Regs386 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Regs386:
			return &_g
		case *_macho.Regs386:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegs386(_o.(Map))
	case *Vector:
		return _vectorToRegs386(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Regs386] or: Map or Vector"))
}

GO TYPE debug/macho.RegsAMD64 from debug/macho/macho.go:
func ExtractGoObjectRegsAMD64(args []Object, index int) *_macho.RegsAMD64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RegsAMD64:
			return &r
		case *_macho.RegsAMD64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RegsAMD64]"))
}

func _mapToRegsAMD64(o Map) *_macho.RegsAMD64 {
	return &_macho.RegsAMD64{}
}

func _vectorToRegsAMD64(o *Vector) *_macho.RegsAMD64 {
	return &_macho.RegsAMD64{
		AX: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
		BX: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		CX: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		DX: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		DI: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		SI: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		BP: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
		SP: AssertNumber(o.Nth(7), "").BigInt().Uint64(),
		R8: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
		R9: AssertNumber(o.Nth(9), "").BigInt().Uint64(),
		R10: AssertNumber(o.Nth(10), "").BigInt().Uint64(),
		R11: AssertNumber(o.Nth(11), "").BigInt().Uint64(),
		R12: AssertNumber(o.Nth(12), "").BigInt().Uint64(),
		R13: AssertNumber(o.Nth(13), "").BigInt().Uint64(),
		R14: AssertNumber(o.Nth(14), "").BigInt().Uint64(),
		R15: AssertNumber(o.Nth(15), "").BigInt().Uint64(),
		IP: AssertNumber(o.Nth(16), "").BigInt().Uint64(),
		FLAGS: AssertNumber(o.Nth(17), "").BigInt().Uint64(),
		CS: AssertNumber(o.Nth(18), "").BigInt().Uint64(),
		FS: AssertNumber(o.Nth(19), "").BigInt().Uint64(),
		GS: AssertNumber(o.Nth(20), "").BigInt().Uint64(),
	}
}

func _ConstructRegsAMD64(_v Object) *_macho.RegsAMD64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RegsAMD64:
			return &_g
		case *_macho.RegsAMD64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegsAMD64(_o.(Map))
	case *Vector:
		return _vectorToRegsAMD64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RegsAMD64] or: Map or Vector"))
}

GO TYPE debug/macho.Reloc from debug/macho/file.go:
func ExtractGoObjectReloc(args []Object, index int) *_macho.Reloc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Reloc:
			return &r
		case *_macho.Reloc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Reloc]"))
}

func _mapToReloc(o Map) *_macho.Reloc {
	return &_macho.Reloc{}
}

func _vectorToReloc(o *Vector) *_macho.Reloc {
	return &_macho.Reloc{
		Addr: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Value: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Type: uint8(AssertInt(o.Nth(2), "").I),
		Len: uint8(AssertInt(o.Nth(3), "").I),
		Pcrel: ToBool(o.Nth(4)),
		Extern: ToBool(o.Nth(5)),
		Scattered: ToBool(o.Nth(6)),
	}
}

func _ConstructReloc(_v Object) *_macho.Reloc {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Reloc:
			return &_g
		case *_macho.Reloc:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReloc(_o.(Map))
	case *Vector:
		return _vectorToReloc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Reloc] or: Map or Vector"))
}

GO TYPE debug/macho.RelocTypeARM from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeARM(args []Object, index int) *_macho.RelocTypeARM {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeARM:
			return &r
		case *_macho.RelocTypeARM:
			return r
		}
	case Int:
		v := _macho.RelocTypeARM(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeARM]"))
}

func _ConstructRelocTypeARM(_v Object) _macho.RelocTypeARM {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeARM:
			return _g
		case *_macho.RelocTypeARM:
			return *_g
		}
	case Number:
		return _macho.RelocTypeARM(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeARM] or: Number"))
}

GO TYPE debug/macho.RelocTypeARM64 from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeARM64(args []Object, index int) *_macho.RelocTypeARM64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeARM64:
			return &r
		case *_macho.RelocTypeARM64:
			return r
		}
	case Int:
		v := _macho.RelocTypeARM64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeARM64]"))
}

func _ConstructRelocTypeARM64(_v Object) _macho.RelocTypeARM64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeARM64:
			return _g
		case *_macho.RelocTypeARM64:
			return *_g
		}
	case Number:
		return _macho.RelocTypeARM64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeARM64] or: Number"))
}

GO TYPE debug/macho.RelocTypeGeneric from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeGeneric(args []Object, index int) *_macho.RelocTypeGeneric {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeGeneric:
			return &r
		case *_macho.RelocTypeGeneric:
			return r
		}
	case Int:
		v := _macho.RelocTypeGeneric(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeGeneric]"))
}

func _ConstructRelocTypeGeneric(_v Object) _macho.RelocTypeGeneric {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeGeneric:
			return _g
		case *_macho.RelocTypeGeneric:
			return *_g
		}
	case Number:
		return _macho.RelocTypeGeneric(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeGeneric] or: Number"))
}

GO TYPE debug/macho.RelocTypeX86_64 from debug/macho/reloctype.go:
func ExtractGoObjectRelocTypeX86_64(args []Object, index int) *_macho.RelocTypeX86_64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RelocTypeX86_64:
			return &r
		case *_macho.RelocTypeX86_64:
			return r
		}
	case Int:
		v := _macho.RelocTypeX86_64(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RelocTypeX86_64]"))
}

func _ConstructRelocTypeX86_64(_v Object) _macho.RelocTypeX86_64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RelocTypeX86_64:
			return _g
		case *_macho.RelocTypeX86_64:
			return *_g
		}
	case Number:
		return _macho.RelocTypeX86_64(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RelocTypeX86_64] or: Number"))
}

GO TYPE debug/macho.Rpath from debug/macho/file.go:
func ExtractGoObjectRpath(args []Object, index int) *_macho.Rpath {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Rpath:
			return &r
		case *_macho.Rpath:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Rpath]"))
}

func _mapToRpath(o Map) *_macho.Rpath {
	return &_macho.Rpath{}
}

func _vectorToRpath(o *Vector) *_macho.Rpath {
	return &_macho.Rpath{
		Path: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructRpath(_v Object) *_macho.Rpath {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Rpath:
			return &_g
		case *_macho.Rpath:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRpath(_o.(Map))
	case *Vector:
		return _vectorToRpath(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Rpath] or: Map or Vector"))
}

GO TYPE debug/macho.RpathCmd from debug/macho/macho.go:
func ExtractGoObjectRpathCmd(args []Object, index int) *_macho.RpathCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.RpathCmd:
			return &r
		case *_macho.RpathCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.RpathCmd]"))
}

func _mapToRpathCmd(o Map) *_macho.RpathCmd {
	return &_macho.RpathCmd{}
}

func _vectorToRpathCmd(o *Vector) *_macho.RpathCmd {
	return &_macho.RpathCmd{
		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Path: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
	}
}

func _ConstructRpathCmd(_v Object) *_macho.RpathCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.RpathCmd:
			return &_g
		case *_macho.RpathCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRpathCmd(_o.(Map))
	case *Vector:
		return _vectorToRpathCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.RpathCmd] or: Map or Vector"))
}

GO TYPE debug/macho.Section from debug/macho/file.go:
func ExtractGoObjectSection(args []Object, index int) *_macho.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section:
			return &r
		case *_macho.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section]"))
}

// func _mapToSection(o Map) *_macho.Section {
// 	return &_macho.Section{}
// }

// func _vectorToSection(o *Vector) *_macho.Section {
// 	return &_macho.Section{
// 		Relocs: ABEND048(codegen.go: no conversion from Clojure for []debug/macho.Reloc (debug/macho.Reloc)),
// 	}
// }

// func _ConstructSection(_v Object) *_macho.Section {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Section:
// 			return &_g
// 		case *_macho.Section:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSection(_o.(Map))
// 	case *Vector:
// 		return _vectorToSection(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section] or: Map or Vector"))
// }

GO TYPE debug/macho.Section32 from debug/macho/macho.go:
func ExtractGoObjectSection32(args []Object, index int) *_macho.Section32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section32:
			return &r
		case *_macho.Section32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section32]"))
}

// func _mapToSection32(o Map) *_macho.Section32 {
// 	return &_macho.Section32{}
// }

// func _vectorToSection32(o *Vector) *_macho.Section32 {
// 	return &_macho.Section32{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Seg: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Addr: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		Size: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Offset: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Align: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Reloff: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		Nreloc: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Flags: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Reserve1: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Reserve2: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructSection32(_v Object) *_macho.Section32 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Section32:
// 			return &_g
// 		case *_macho.Section32:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSection32(_o.(Map))
// 	case *Vector:
// 		return _vectorToSection32(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section32] or: Map or Vector"))
// }

GO TYPE debug/macho.Section64 from debug/macho/macho.go:
func ExtractGoObjectSection64(args []Object, index int) *_macho.Section64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Section64:
			return &r
		case *_macho.Section64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Section64]"))
}

// func _mapToSection64(o Map) *_macho.Section64 {
// 	return &_macho.Section64{}
// }

// func _vectorToSection64(o *Vector) *_macho.Section64 {
// 	return &_macho.Section64{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Seg: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Addr: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
// 		Size: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Offset: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Align: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Reloff: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		Nreloc: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Flags: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Reserve1: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Reserve2: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		Reserve3: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructSection64(_v Object) *_macho.Section64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Section64:
// 			return &_g
// 		case *_macho.Section64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSection64(_o.(Map))
// 	case *Vector:
// 		return _vectorToSection64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Section64] or: Map or Vector"))
// }

GO TYPE debug/macho.SectionHeader from debug/macho/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_macho.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SectionHeader:
			return &r
		case *_macho.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_macho.SectionHeader {
	return &_macho.SectionHeader{}
}

func _vectorToSectionHeader(o *Vector) *_macho.SectionHeader {
	return &_macho.SectionHeader{
		Name: AssertString(o.Nth(0), "").S,
		Seg: AssertString(o.Nth(1), "").S,
		Addr: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		Size: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Offset: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Align: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		Reloff: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		Nreloc: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Flags: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
	}
}

func _ConstructSectionHeader(_v Object) *_macho.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SectionHeader:
			return &_g
		case *_macho.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SectionHeader] or: Map or Vector"))
}

GO TYPE debug/macho.Segment from debug/macho/file.go:
func ExtractGoObjectSegment(args []Object, index int) *_macho.Segment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment:
			return &r
		case *_macho.Segment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment]"))
}

func _mapToSegment(o Map) *_macho.Segment {
	return &_macho.Segment{}
}

func _vectorToSegment(o *Vector) *_macho.Segment {
	return &_macho.Segment{}
}

func _ConstructSegment(_v Object) *_macho.Segment {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Segment:
			return &_g
		case *_macho.Segment:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegment(_o.(Map))
	case *Vector:
		return _vectorToSegment(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment] or: Map or Vector"))
}

GO TYPE debug/macho.Segment32 from debug/macho/macho.go:
func ExtractGoObjectSegment32(args []Object, index int) *_macho.Segment32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment32:
			return &r
		case *_macho.Segment32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment32]"))
}

// func _mapToSegment32(o Map) *_macho.Segment32 {
// 	return &_macho.Segment32{}
// }

// func _vectorToSegment32(o *Vector) *_macho.Segment32 {
// 	return &_macho.Segment32{
// 		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
// 		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Addr: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Memsz: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Offset: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Filesz: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		Maxprot: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Prot: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Nsect: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Flag: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructSegment32(_v Object) *_macho.Segment32 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Segment32:
// 			return &_g
// 		case *_macho.Segment32:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSegment32(_o.(Map))
// 	case *Vector:
// 		return _vectorToSegment32(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment32] or: Map or Vector"))
// }

GO TYPE debug/macho.Segment64 from debug/macho/macho.go:
func ExtractGoObjectSegment64(args []Object, index int) *_macho.Segment64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Segment64:
			return &r
		case *_macho.Segment64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Segment64]"))
}

// func _mapToSegment64(o Map) *_macho.Segment64 {
// 	return &_macho.Segment64{}
// }

// func _vectorToSegment64(o *Vector) *_macho.Segment64 {
// 	return &_macho.Segment64{
// 		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
// 		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Addr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Memsz: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
// 		Offset: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
// 		Filesz: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
// 		Maxprot: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Prot: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Nsect: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Flag: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructSegment64(_v Object) *_macho.Segment64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Segment64:
// 			return &_g
// 		case *_macho.Segment64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSegment64(_o.(Map))
// 	case *Vector:
// 		return _vectorToSegment64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Segment64] or: Map or Vector"))
// }

GO TYPE debug/macho.SegmentHeader from debug/macho/file.go:
func ExtractGoObjectSegmentHeader(args []Object, index int) *_macho.SegmentHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SegmentHeader:
			return &r
		case *_macho.SegmentHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SegmentHeader]"))
}

func _mapToSegmentHeader(o Map) *_macho.SegmentHeader {
	return &_macho.SegmentHeader{}
}

func _vectorToSegmentHeader(o *Vector) *_macho.SegmentHeader {
	return &_macho.SegmentHeader{
		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Name: AssertString(o.Nth(2), "").S,
		Addr: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
		Memsz: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		Offset: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
		Filesz: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
		Maxprot: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
		Prot: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
		Nsect: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
		Flag: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
	}
}

func _ConstructSegmentHeader(_v Object) *_macho.SegmentHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SegmentHeader:
			return &_g
		case *_macho.SegmentHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSegmentHeader(_o.(Map))
	case *Vector:
		return _vectorToSegmentHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SegmentHeader] or: Map or Vector"))
}

GO TYPE debug/macho.Symbol from debug/macho/file.go:
func ExtractGoObjectSymbol(args []Object, index int) *_macho.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Symbol:
			return &r
		case *_macho.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Symbol]"))
}

func _mapToSymbol(o Map) *_macho.Symbol {
	return &_macho.Symbol{}
}

func _vectorToSymbol(o *Vector) *_macho.Symbol {
	return &_macho.Symbol{
		Name: AssertString(o.Nth(0), "").S,
		Type: uint8(AssertInt(o.Nth(1), "").I),
		Sect: uint8(AssertInt(o.Nth(2), "").I),
		Desc: uint16(AssertInt(o.Nth(3), "").I),
		Value: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
	}
}

func _ConstructSymbol(_v Object) *_macho.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Symbol:
			return &_g
		case *_macho.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Symbol] or: Map or Vector"))
}

GO TYPE debug/macho.Symtab from debug/macho/file.go:
func ExtractGoObjectSymtab(args []Object, index int) *_macho.Symtab {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Symtab:
			return &r
		case *_macho.Symtab:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Symtab]"))
}

// func _mapToSymtab(o Map) *_macho.Symtab {
// 	return &_macho.Symtab{}
// }

// func _vectorToSymtab(o *Vector) *_macho.Symtab {
// 	return &_macho.Symtab{
// 		Syms: ABEND048(codegen.go: no conversion from Clojure for []debug/macho.Symbol (debug/macho.Symbol)),
// 	}
// }

// func _ConstructSymtab(_v Object) *_macho.Symtab {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Symtab:
// 			return &_g
// 		case *_macho.Symtab:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSymtab(_o.(Map))
// 	case *Vector:
// 		return _vectorToSymtab(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Symtab] or: Map or Vector"))
// }

GO TYPE debug/macho.SymtabCmd from debug/macho/macho.go:
func ExtractGoObjectSymtabCmd(args []Object, index int) *_macho.SymtabCmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.SymtabCmd:
			return &r
		case *_macho.SymtabCmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.SymtabCmd]"))
}

func _mapToSymtabCmd(o Map) *_macho.SymtabCmd {
	return &_macho.SymtabCmd{}
}

func _vectorToSymtabCmd(o *Vector) *_macho.SymtabCmd {
	return &_macho.SymtabCmd{
		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Symoff: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Nsyms: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Stroff: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		Strsize: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
	}
}

func _ConstructSymtabCmd(_v Object) *_macho.SymtabCmd {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.SymtabCmd:
			return &_g
		case *_macho.SymtabCmd:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymtabCmd(_o.(Map))
	case *Vector:
		return _vectorToSymtabCmd(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.SymtabCmd] or: Map or Vector"))
}

GO TYPE debug/macho.Thread from debug/macho/macho.go:
func ExtractGoObjectThread(args []Object, index int) *_macho.Thread {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Thread:
			return &r
		case *_macho.Thread:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Thread]"))
}

// func _mapToThread(o Map) *_macho.Thread {
// 	return &_macho.Thread{}
// }

// func _vectorToThread(o *Vector) *_macho.Thread {
// 	return &_macho.Thread{
// 		Cmd: _macho.LoadCmd(uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64())),
// 		Len: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Type: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []uint32 (uint32)),
// 	}
// }

// func _ConstructThread(_v Object) *_macho.Thread {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _macho.Thread:
// 			return &_g
// 		case *_macho.Thread:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToThread(_o.(Map))
// 	case *Vector:
// 		return _vectorToThread(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Thread] or: Map or Vector"))
// }

GO TYPE debug/macho.Type from debug/macho/macho.go:
func ExtractGoObjectType(args []Object, index int) *_macho.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _macho.Type:
			return &r
		case *_macho.Type:
			return r
		}
	case Number:
		v := _macho.Type(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/macho.Type]"))
}

func _ConstructType(_v Object) _macho.Type {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _macho.Type:
			return _g
		case *_macho.Type:
			return *_g
		}
	case Number:
		return _macho.Type(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[macho.Type] or: Number"))
}

GO FUNC debug/macho.NewFatFile from debug/macho/fat.go:
// func __newFatFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _macho.NewFatFile(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFile from debug/macho/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _macho.NewFile(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.Open from debug/macho/file.go:
func __open(name string) Object {
	_res1, _res2 := _macho.Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.OpenFat from debug/macho/fat.go:
func __openFat(name string) Object {
	_res1, _res2 := _macho.OpenFat(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__cpu_GoString from debug/macho/macho.go:
func __cpu_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.Cpu)GoString()", args, 0, 0)
	_res := o.O.(_macho.Cpu).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__cpu_String from debug/macho/macho.go:
func __cpu_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.Cpu)String()", args, 0, 0)
	_res := o.O.(_macho.Cpu).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__loadBytes_Raw from debug/macho/file.go:
func __loadBytes_Raw(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.LoadBytes)Raw()", args, 0, 0)
	_res := o.O.(_macho.LoadBytes).Raw()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC debug/macho.__loadCmd_GoString from debug/macho/macho.go:
func __loadCmd_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.LoadCmd)GoString()", args, 0, 0)
	_res := o.O.(_macho.LoadCmd).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__loadCmd_String from debug/macho/macho.go:
func __loadCmd_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.LoadCmd)String()", args, 0, 0)
	_res := o.O.(_macho.LoadCmd).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__ptrTo_FatFile_Close from debug/macho/fat.go:
func __ptrTo_FatFile_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.FatFile)Close()", args, 0, 0)
	_res := o.O.(*_macho.FatFile).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC debug/macho.__ptrTo_File_Close from debug/macho/file.go:
func __ptrTo_File_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.File)Close()", args, 0, 0)
	_res := o.O.(*_macho.File).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC debug/macho.__ptrTo_File_DWARF from debug/macho/file.go:
func __ptrTo_File_DWARF(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.File)DWARF()", args, 0, 0)
	_res1, _res2 := o.O.(*_macho.File).DWARF()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__ptrTo_File_ImportedLibraries from debug/macho/file.go:
func __ptrTo_File_ImportedLibraries(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.File)ImportedLibraries()", args, 0, 0)
	_res1, _res2 := o.O.(*_macho.File).ImportedLibraries()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__ptrTo_File_ImportedSymbols from debug/macho/file.go:
func __ptrTo_File_ImportedSymbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.File)ImportedSymbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_macho.File).ImportedSymbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__ptrTo_File_Section from debug/macho/file.go:
func __ptrTo_File_Section(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/macho.File)Section()", args, 1, 1)
	name := ExtractGoString("(*_debug/macho.File)Section()", "name", _argList, 0)
	_res := o.O.(*_macho.File).Section(name)
	return MakeGoObject(_res)
}

GO FUNC debug/macho.__ptrTo_File_Segment from debug/macho/file.go:
func __ptrTo_File_Segment(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/macho.File)Segment()", args, 1, 1)
	name := ExtractGoString("(*_debug/macho.File)Segment()", "name", _argList, 0)
	_res := o.O.(*_macho.File).Segment(name)
	return MakeGoObject(_res)
}

GO FUNC debug/macho.__ptrTo_FormatError_Error from debug/macho/file.go:
func __ptrTo_FormatError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.FormatError)Error()", args, 0, 0)
	_res := o.O.(*_macho.FormatError).Error()
	return MakeString(_res)
}

GO FUNC debug/macho.__ptrTo_Section_Data from debug/macho/file.go:
func __ptrTo_Section_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.Section)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_macho.Section).Data()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__ptrTo_Section_Open from debug/macho/file.go:
func __ptrTo_Section_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.Section)Open()", args, 0, 0)
	_res := o.O.(*_macho.Section).Open()
	return MakeGoObject(_res)
}

GO FUNC debug/macho.__ptrTo_Segment_Data from debug/macho/file.go:
func __ptrTo_Segment_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.Segment)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_macho.Segment).Data()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/macho.__ptrTo_Segment_Open from debug/macho/file.go:
func __ptrTo_Segment_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/macho.Segment)Open()", args, 0, 0)
	_res := o.O.(*_macho.Segment).Open()
	return MakeGoObject(_res)
}

GO FUNC debug/macho.__relocTypeARM64_GoString from debug/macho/reloctype.go:
func __relocTypeARM64_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeARM64)GoString()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeARM64).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeARM64_String from debug/macho/reloctype_string.go:
func __relocTypeARM64_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeARM64)String()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeARM64).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeARM_GoString from debug/macho/reloctype.go:
func __relocTypeARM_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeARM)GoString()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeARM).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeARM_String from debug/macho/reloctype_string.go:
func __relocTypeARM_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeARM)String()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeARM).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeGeneric_GoString from debug/macho/reloctype.go:
func __relocTypeGeneric_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeGeneric)GoString()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeGeneric).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeGeneric_String from debug/macho/reloctype_string.go:
func __relocTypeGeneric_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeGeneric)String()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeGeneric).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeX86_64_GoString from debug/macho/reloctype.go:
func __relocTypeX86_64_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeX86_64)GoString()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeX86_64).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__relocTypeX86_64_String from debug/macho/reloctype_string.go:
func __relocTypeX86_64_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.RelocTypeX86_64)String()", args, 0, 0)
	_res := o.O.(_macho.RelocTypeX86_64).String()
	return MakeString(_res)
}

GO FUNC debug/macho.__type_GoString from debug/macho/macho.go:
func __type_GoString(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.Type)GoString()", args, 0, 0)
	_res := o.O.(_macho.Type).GoString()
	return MakeString(_res)
}

GO FUNC debug/macho.__type_String from debug/macho/macho.go:
func __type_String(o GoObject, args Object) Object {
	CheckGoArity("(_debug/macho.Type)String()", args, 0, 0)
	_res := o.O.(_macho.Type).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package macho

import (
	_macho "debug/macho"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_Cpu = GoTypeInfo{Members: GoMembers{
	"GoString": __cpu_GoString,
	"String": __cpu_String,
}}

var members_PtrTo_FatFile = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_FatFile_Close,
}}

var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_File_Close,
	"DWARF": __ptrTo_File_DWARF,
	"ImportedLibraries": __ptrTo_File_ImportedLibraries,
	"ImportedSymbols": __ptrTo_File_ImportedSymbols,
	"Section": __ptrTo_File_Section,
	"Segment": __ptrTo_File_Segment,
}}

var members_PtrTo_FormatError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_FormatError_Error,
}}

var members_LoadBytes = GoTypeInfo{Members: GoMembers{
	"Raw": __loadBytes_Raw,
}}

var members_LoadCmd = GoTypeInfo{Members: GoMembers{
	"GoString": __loadCmd_GoString,
	"String": __loadCmd_String,
}}

var members_RelocTypeARM = GoTypeInfo{Members: GoMembers{
	"GoString": __relocTypeARM_GoString,
	"String": __relocTypeARM_String,
}}

var members_RelocTypeARM64 = GoTypeInfo{Members: GoMembers{
	"GoString": __relocTypeARM64_GoString,
	"String": __relocTypeARM64_String,
}}

var members_RelocTypeGeneric = GoTypeInfo{Members: GoMembers{
	"GoString": __relocTypeGeneric_GoString,
	"String": __relocTypeGeneric_String,
}}

var members_RelocTypeX86_64 = GoTypeInfo{Members: GoMembers{
	"GoString": __relocTypeX86_64_GoString,
	"String": __relocTypeX86_64_String,
}}

var members_PtrTo_Section = GoTypeInfo{Members: GoMembers{
	"Data": __ptrTo_Section_Data,
	"Open": __ptrTo_Section_Open,
}}

var members_PtrTo_Segment = GoTypeInfo{Members: GoMembers{
	"Data": __ptrTo_Segment_Data,
	"Open": __ptrTo_Segment_Open,
}}

var members_Type = GoTypeInfo{Members: GoMembers{
	"GoString": __type_GoString,
	"String": __type_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_macho.Cpu)(nil)).Elem()] = &members_Cpu
	GoTypes[_reflect.TypeOf((*_macho.FatFile)(nil))] = &members_PtrTo_FatFile
	GoTypes[_reflect.TypeOf((*_macho.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_macho.FormatError)(nil))] = &members_PtrTo_FormatError
	GoTypes[_reflect.TypeOf((*_macho.LoadBytes)(nil)).Elem()] = &members_LoadBytes
	GoTypes[_reflect.TypeOf((*_macho.LoadCmd)(nil)).Elem()] = &members_LoadCmd
	GoTypes[_reflect.TypeOf((*_macho.RelocTypeARM)(nil)).Elem()] = &members_RelocTypeARM
	GoTypes[_reflect.TypeOf((*_macho.RelocTypeARM64)(nil)).Elem()] = &members_RelocTypeARM64
	GoTypes[_reflect.TypeOf((*_macho.RelocTypeGeneric)(nil)).Elem()] = &members_RelocTypeGeneric
	GoTypes[_reflect.TypeOf((*_macho.RelocTypeX86_64)(nil)).Elem()] = &members_RelocTypeX86_64
	GoTypes[_reflect.TypeOf((*_macho.Section)(nil))] = &members_PtrTo_Section
	GoTypes[_reflect.TypeOf((*_macho.Segment)(nil))] = &members_PtrTo_Segment
	GoTypes[_reflect.TypeOf((*_macho.Type)(nil)).Elem()] = &members_Type
}

GO TYPE debug/pe.COFFSymbol from debug/pe/symbol.go:
func ExtractGoObjectCOFFSymbol(args []Object, index int) *_pe.COFFSymbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.COFFSymbol:
			return &r
		case *_pe.COFFSymbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.COFFSymbol]"))
}

// func _mapToCOFFSymbol(o Map) *_pe.COFFSymbol {
// 	return &_pe.COFFSymbol{}
// }

// func _vectorToCOFFSymbol(o *Vector) *_pe.COFFSymbol {
// 	return &_pe.COFFSymbol{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [8]uint8 (uint8)),
// 		Value: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		SectionNumber: int16(AssertInt(o.Nth(2), "").I),
// 		Type: uint16(AssertInt(o.Nth(3), "").I),
// 		StorageClass: uint8(AssertInt(o.Nth(4), "").I),
// 		NumberOfAuxSymbols: uint8(AssertInt(o.Nth(5), "").I),
// 	}
// }

// func _ConstructCOFFSymbol(_v Object) *_pe.COFFSymbol {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.COFFSymbol:
// 			return &_g
// 		case *_pe.COFFSymbol:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCOFFSymbol(_o.(Map))
// 	case *Vector:
// 		return _vectorToCOFFSymbol(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.COFFSymbol] or: Map or Vector"))
// }

GO TYPE debug/pe.DataDirectory from debug/pe/pe.go:
func ExtractGoObjectDataDirectory(args []Object, index int) *_pe.DataDirectory {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.DataDirectory:
			return &r
		case *_pe.DataDirectory:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.DataDirectory]"))
}

func _mapToDataDirectory(o Map) *_pe.DataDirectory {
	return &_pe.DataDirectory{}
}

func _vectorToDataDirectory(o *Vector) *_pe.DataDirectory {
	return &_pe.DataDirectory{
		VirtualAddress: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
	}
}

func _ConstructDataDirectory(_v Object) *_pe.DataDirectory {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.DataDirectory:
			return &_g
		case *_pe.DataDirectory:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDataDirectory(_o.(Map))
	case *Vector:
		return _vectorToDataDirectory(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.DataDirectory] or: Map or Vector"))
}

GO TYPE debug/pe.File from debug/pe/file.go:
func ExtractGoObjectFile(args []Object, index int) *_pe.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.File:
			return &r
		case *_pe.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.File]"))
}

// func _mapToFile(o Map) *_pe.File {
// 	return &_pe.File{}
// }

// func _vectorToFile(o *Vector) *_pe.File {
// 	return &_pe.File{
// 		OptionalHeader: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Sections: ABEND048(codegen.go: no conversion from Clojure for []*debug/pe.Section (*debug/pe.Section)),
// 		Symbols: ABEND048(codegen.go: no conversion from Clojure for []*debug/pe.Symbol (*debug/pe.Symbol)),
// 		COFFSymbols: ABEND048(codegen.go: no conversion from Clojure for []debug/pe.COFFSymbol (debug/pe.COFFSymbol)),
// 		StringTable: ABEND048(codegen.go: no conversion from Clojure for debug/pe.StringTable ([]byte)),
// 	}
// }

// func _ConstructFile(_v Object) *_pe.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.File:
// 			return &_g
// 		case *_pe.File:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.File] or: Map or Vector"))
// }

GO TYPE debug/pe.FileHeader from debug/pe/pe.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_pe.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.FileHeader:
			return &r
		case *_pe.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.FileHeader]"))
}

func _mapToFileHeader(o Map) *_pe.FileHeader {
	return &_pe.FileHeader{}
}

func _vectorToFileHeader(o *Vector) *_pe.FileHeader {
	return &_pe.FileHeader{
		Machine: uint16(AssertInt(o.Nth(0), "").I),
		NumberOfSections: uint16(AssertInt(o.Nth(1), "").I),
		TimeDateStamp: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		PointerToSymbolTable: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		NumberOfSymbols: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		SizeOfOptionalHeader: uint16(AssertInt(o.Nth(5), "").I),
		Characteristics: uint16(AssertInt(o.Nth(6), "").I),
	}
}

func _ConstructFileHeader(_v Object) *_pe.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.FileHeader:
			return &_g
		case *_pe.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.FileHeader] or: Map or Vector"))
}

GO TYPE debug/pe.FormatError from debug/pe/file.go:
func ExtractGoObjectFormatError(args []Object, index int) *_pe.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.FormatError:
			return &r
		case *_pe.FormatError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.FormatError]"))
}

func _mapToFormatError(o Map) *_pe.FormatError {
	return &_pe.FormatError{}
}

func _vectorToFormatError(o *Vector) *_pe.FormatError {
	return &_pe.FormatError{}
}

func _ConstructFormatError(_v Object) *_pe.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.FormatError:
			return &_g
		case *_pe.FormatError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFormatError(_o.(Map))
	case *Vector:
		return _vectorToFormatError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.FormatError] or: Map or Vector"))
}

GO TYPE debug/pe.ImportDirectory from debug/pe/file.go:
func ExtractGoObjectImportDirectory(args []Object, index int) *_pe.ImportDirectory {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.ImportDirectory:
			return &r
		case *_pe.ImportDirectory:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.ImportDirectory]"))
}

func _mapToImportDirectory(o Map) *_pe.ImportDirectory {
	return &_pe.ImportDirectory{}
}

func _vectorToImportDirectory(o *Vector) *_pe.ImportDirectory {
	return &_pe.ImportDirectory{
		OriginalFirstThunk: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		TimeDateStamp: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		ForwarderChain: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Name: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		FirstThunk: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
	}
}

func _ConstructImportDirectory(_v Object) *_pe.ImportDirectory {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.ImportDirectory:
			return &_g
		case *_pe.ImportDirectory:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToImportDirectory(_o.(Map))
	case *Vector:
		return _vectorToImportDirectory(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.ImportDirectory] or: Map or Vector"))
}

GO TYPE debug/pe.OptionalHeader32 from debug/pe/pe.go:
func ExtractGoObjectOptionalHeader32(args []Object, index int) *_pe.OptionalHeader32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.OptionalHeader32:
			return &r
		case *_pe.OptionalHeader32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.OptionalHeader32]"))
}

// func _mapToOptionalHeader32(o Map) *_pe.OptionalHeader32 {
// 	return &_pe.OptionalHeader32{}
// }

// func _vectorToOptionalHeader32(o *Vector) *_pe.OptionalHeader32 {
// 	return &_pe.OptionalHeader32{
// 		Magic: uint16(AssertInt(o.Nth(0), "").I),
// 		MajorLinkerVersion: uint8(AssertInt(o.Nth(1), "").I),
// 		MinorLinkerVersion: uint8(AssertInt(o.Nth(2), "").I),
// 		SizeOfCode: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		SizeOfInitializedData: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		SizeOfUninitializedData: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		AddressOfEntryPoint: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		BaseOfCode: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		BaseOfData: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		ImageBase: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		SectionAlignment: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		FileAlignment: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 		MajorOperatingSystemVersion: uint16(AssertInt(o.Nth(12), "").I),
// 		MinorOperatingSystemVersion: uint16(AssertInt(o.Nth(13), "").I),
// 		MajorImageVersion: uint16(AssertInt(o.Nth(14), "").I),
// 		MinorImageVersion: uint16(AssertInt(o.Nth(15), "").I),
// 		MajorSubsystemVersion: uint16(AssertInt(o.Nth(16), "").I),
// 		MinorSubsystemVersion: uint16(AssertInt(o.Nth(17), "").I),
// 		Win32VersionValue: uint32(AssertNumber(o.Nth(18), "").BigInt().Uint64()),
// 		SizeOfImage: uint32(AssertNumber(o.Nth(19), "").BigInt().Uint64()),
// 		SizeOfHeaders: uint32(AssertNumber(o.Nth(20), "").BigInt().Uint64()),
// 		CheckSum: uint32(AssertNumber(o.Nth(21), "").BigInt().Uint64()),
// 		Subsystem: uint16(AssertInt(o.Nth(22), "").I),
// 		DllCharacteristics: uint16(AssertInt(o.Nth(23), "").I),
// 		SizeOfStackReserve: uint32(AssertNumber(o.Nth(24), "").BigInt().Uint64()),
// 		SizeOfStackCommit: uint32(AssertNumber(o.Nth(25), "").BigInt().Uint64()),
// 		SizeOfHeapReserve: uint32(AssertNumber(o.Nth(26), "").BigInt().Uint64()),
// 		SizeOfHeapCommit: uint32(AssertNumber(o.Nth(27), "").BigInt().Uint64()),
// 		LoaderFlags: uint32(AssertNumber(o.Nth(28), "").BigInt().Uint64()),
// 		NumberOfRvaAndSizes: uint32(AssertNumber(o.Nth(29), "").BigInt().Uint64()),
// 		DataDirectory: ABEND048(codegen.go: no conversion from Clojure for [16]debug/pe.DataDirectory (debug/pe.DataDirectory)),
// 	}
// }

// func _ConstructOptionalHeader32(_v Object) *_pe.OptionalHeader32 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.OptionalHeader32:
// 			return &_g
// 		case *_pe.OptionalHeader32:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptionalHeader32(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptionalHeader32(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.OptionalHeader32] or: Map or Vector"))
// }

GO TYPE debug/pe.OptionalHeader64 from debug/pe/pe.go:
func ExtractGoObjectOptionalHeader64(args []Object, index int) *_pe.OptionalHeader64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.OptionalHeader64:
			return &r
		case *_pe.OptionalHeader64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.OptionalHeader64]"))
}

// func _mapToOptionalHeader64(o Map) *_pe.OptionalHeader64 {
// 	return &_pe.OptionalHeader64{}
// }

// func _vectorToOptionalHeader64(o *Vector) *_pe.OptionalHeader64 {
// 	return &_pe.OptionalHeader64{
// 		Magic: uint16(AssertInt(o.Nth(0), "").I),
// 		MajorLinkerVersion: uint8(AssertInt(o.Nth(1), "").I),
// 		MinorLinkerVersion: uint8(AssertInt(o.Nth(2), "").I),
// 		SizeOfCode: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		SizeOfInitializedData: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		SizeOfUninitializedData: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		AddressOfEntryPoint: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		BaseOfCode: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		ImageBase: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
// 		SectionAlignment: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		FileAlignment: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		MajorOperatingSystemVersion: uint16(AssertInt(o.Nth(11), "").I),
// 		MinorOperatingSystemVersion: uint16(AssertInt(o.Nth(12), "").I),
// 		MajorImageVersion: uint16(AssertInt(o.Nth(13), "").I),
// 		MinorImageVersion: uint16(AssertInt(o.Nth(14), "").I),
// 		MajorSubsystemVersion: uint16(AssertInt(o.Nth(15), "").I),
// 		MinorSubsystemVersion: uint16(AssertInt(o.Nth(16), "").I),
// 		Win32VersionValue: uint32(AssertNumber(o.Nth(17), "").BigInt().Uint64()),
// 		SizeOfImage: uint32(AssertNumber(o.Nth(18), "").BigInt().Uint64()),
// 		SizeOfHeaders: uint32(AssertNumber(o.Nth(19), "").BigInt().Uint64()),
// 		CheckSum: uint32(AssertNumber(o.Nth(20), "").BigInt().Uint64()),
// 		Subsystem: uint16(AssertInt(o.Nth(21), "").I),
// 		DllCharacteristics: uint16(AssertInt(o.Nth(22), "").I),
// 		SizeOfStackReserve: AssertNumber(o.Nth(23), "").BigInt().Uint64(),
// 		SizeOfStackCommit: AssertNumber(o.Nth(24), "").BigInt().Uint64(),
// 		SizeOfHeapReserve: AssertNumber(o.Nth(25), "").BigInt().Uint64(),
// 		SizeOfHeapCommit: AssertNumber(o.Nth(26), "").BigInt().Uint64(),
// 		LoaderFlags: uint32(AssertNumber(o.Nth(27), "").BigInt().Uint64()),
// 		NumberOfRvaAndSizes: uint32(AssertNumber(o.Nth(28), "").BigInt().Uint64()),
// 		DataDirectory: ABEND048(codegen.go: no conversion from Clojure for [16]debug/pe.DataDirectory (debug/pe.DataDirectory)),
// 	}
// }

// func _ConstructOptionalHeader64(_v Object) *_pe.OptionalHeader64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.OptionalHeader64:
// 			return &_g
// 		case *_pe.OptionalHeader64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptionalHeader64(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptionalHeader64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.OptionalHeader64] or: Map or Vector"))
// }

GO TYPE debug/pe.Reloc from debug/pe/section.go:
func ExtractGoObjectReloc(args []Object, index int) *_pe.Reloc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Reloc:
			return &r
		case *_pe.Reloc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Reloc]"))
}

func _mapToReloc(o Map) *_pe.Reloc {
	return &_pe.Reloc{}
}

func _vectorToReloc(o *Vector) *_pe.Reloc {
	return &_pe.Reloc{
		VirtualAddress: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		SymbolTableIndex: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Type: uint16(AssertInt(o.Nth(2), "").I),
	}
}

func _ConstructReloc(_v Object) *_pe.Reloc {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.Reloc:
			return &_g
		case *_pe.Reloc:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReloc(_o.(Map))
	case *Vector:
		return _vectorToReloc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Reloc] or: Map or Vector"))
}

GO TYPE debug/pe.Section from debug/pe/section.go:
func ExtractGoObjectSection(args []Object, index int) *_pe.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Section:
			return &r
		case *_pe.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Section]"))
}

// func _mapToSection(o Map) *_pe.Section {
// 	return &_pe.Section{}
// }

// func _vectorToSection(o *Vector) *_pe.Section {
// 	return &_pe.Section{
// 		Relocs: ABEND048(codegen.go: no conversion from Clojure for []debug/pe.Reloc (debug/pe.Reloc)),
// 	}
// }

// func _ConstructSection(_v Object) *_pe.Section {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.Section:
// 			return &_g
// 		case *_pe.Section:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSection(_o.(Map))
// 	case *Vector:
// 		return _vectorToSection(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Section] or: Map or Vector"))
// }

GO TYPE debug/pe.SectionHeader from debug/pe/section.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_pe.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.SectionHeader:
			return &r
		case *_pe.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_pe.SectionHeader {
	return &_pe.SectionHeader{}
}

func _vectorToSectionHeader(o *Vector) *_pe.SectionHeader {
	return &_pe.SectionHeader{
		Name: AssertString(o.Nth(0), "").S,
		VirtualSize: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		VirtualAddress: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Size: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
		Offset: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
		PointerToRelocations: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
		PointerToLineNumbers: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
		NumberOfRelocations: uint16(AssertInt(o.Nth(7), "").I),
		NumberOfLineNumbers: uint16(AssertInt(o.Nth(8), "").I),
		Characteristics: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
	}
}

func _ConstructSectionHeader(_v Object) *_pe.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.SectionHeader:
			return &_g
		case *_pe.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.SectionHeader] or: Map or Vector"))
}

GO TYPE debug/pe.SectionHeader32 from debug/pe/section.go:
func ExtractGoObjectSectionHeader32(args []Object, index int) *_pe.SectionHeader32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.SectionHeader32:
			return &r
		case *_pe.SectionHeader32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.SectionHeader32]"))
}

// func _mapToSectionHeader32(o Map) *_pe.SectionHeader32 {
// 	return &_pe.SectionHeader32{}
// }

// func _vectorToSectionHeader32(o *Vector) *_pe.SectionHeader32 {
// 	return &_pe.SectionHeader32{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [8]uint8 (uint8)),
// 		VirtualSize: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		VirtualAddress: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		SizeOfRawData: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		PointerToRawData: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		PointerToRelocations: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		PointerToLineNumbers: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		NumberOfRelocations: uint16(AssertInt(o.Nth(7), "").I),
// 		NumberOfLineNumbers: uint16(AssertInt(o.Nth(8), "").I),
// 		Characteristics: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructSectionHeader32(_v Object) *_pe.SectionHeader32 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.SectionHeader32:
// 			return &_g
// 		case *_pe.SectionHeader32:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSectionHeader32(_o.(Map))
// 	case *Vector:
// 		return _vectorToSectionHeader32(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.SectionHeader32] or: Map or Vector"))
// }

GO TYPE debug/pe.StringTable from debug/pe/string.go:
func ExtractGoObjectStringTable(args []Object, index int) *_pe.StringTable {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.StringTable:
			return &r
		case *_pe.StringTable:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.StringTable]"))
}

// func _ConstructStringTable(_v Object) _pe.StringTable {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pe.StringTable:
// 			return _g
// 		case *_pe.StringTable:
// 			return *_g
// 		}
// 	default:
// 		return _pe.StringTable(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for StringTable))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.StringTable] or: whatever"))
// }

GO TYPE debug/pe.Symbol from debug/pe/symbol.go:
func ExtractGoObjectSymbol(args []Object, index int) *_pe.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pe.Symbol:
			return &r
		case *_pe.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/pe.Symbol]"))
}

func _mapToSymbol(o Map) *_pe.Symbol {
	return &_pe.Symbol{}
}

func _vectorToSymbol(o *Vector) *_pe.Symbol {
	return &_pe.Symbol{
		Name: AssertString(o.Nth(0), "").S,
		Value: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		SectionNumber: int16(AssertInt(o.Nth(2), "").I),
		Type: uint16(AssertInt(o.Nth(3), "").I),
		StorageClass: uint8(AssertInt(o.Nth(4), "").I),
	}
}

func _ConstructSymbol(_v Object) *_pe.Symbol {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pe.Symbol:
			return &_g
		case *_pe.Symbol:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSymbol(_o.(Map))
	case *Vector:
		return _vectorToSymbol(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pe.Symbol] or: Map or Vector"))
}

GO FUNC debug/pe.NewFile from debug/pe/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _pe.NewFile(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/pe.Open from debug/pe/file.go:
func __open(name string) Object {
	_res1, _res2 := _pe.Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_COFFSymbol_FullName from debug/pe/symbol.go:
func __ptrTo_COFFSymbol_FullName(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/pe.COFFSymbol)FullName()", args, 1, 1)
	st := ExtractGo_go_std_debug_pe__StringTable("(*_debug/pe.COFFSymbol)FullName()", "st", _argList, 0)
	_res1, _res2 := o.O.(*_pe.COFFSymbol).FullName(st)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_File_Close from debug/pe/file.go:
func __ptrTo_File_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.File)Close()", args, 0, 0)
	_res := o.O.(*_pe.File).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC debug/pe.__ptrTo_File_DWARF from debug/pe/file.go:
func __ptrTo_File_DWARF(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.File)DWARF()", args, 0, 0)
	_res1, _res2 := o.O.(*_pe.File).DWARF()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_File_ImportedLibraries from debug/pe/file.go:
func __ptrTo_File_ImportedLibraries(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.File)ImportedLibraries()", args, 0, 0)
	_res1, _res2 := o.O.(*_pe.File).ImportedLibraries()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_File_ImportedSymbols from debug/pe/file.go:
func __ptrTo_File_ImportedSymbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.File)ImportedSymbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_pe.File).ImportedSymbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_File_Section from debug/pe/file.go:
func __ptrTo_File_Section(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/pe.File)Section()", args, 1, 1)
	name := ExtractGoString("(*_debug/pe.File)Section()", "name", _argList, 0)
	_res := o.O.(*_pe.File).Section(name)
	return MakeGoObject(_res)
}

GO FUNC debug/pe.__ptrTo_FormatError_Error from debug/pe/file.go:
func __ptrTo_FormatError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.FormatError)Error()", args, 0, 0)
	_res := o.O.(*_pe.FormatError).Error()
	return MakeString(_res)
}

GO FUNC debug/pe.__ptrTo_Section_Data from debug/pe/section.go:
func __ptrTo_Section_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.Section)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_pe.Section).Data()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.__ptrTo_Section_Open from debug/pe/section.go:
func __ptrTo_Section_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/pe.Section)Open()", args, 0, 0)
	_res := o.O.(*_pe.Section).Open()
	return MakeGoObject(_res)
}

GO FUNC debug/pe.__stringTable_String from debug/pe/string.go:
func __stringTable_String(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_debug/pe.StringTable)String()", args, 1, 1)
	start := ExtractGoUInt32("(_debug/pe.StringTable)String()", "start", _argList, 0)
	_res1, _res2 := o.O.(_pe.StringTable).String(start)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pe

import (
	_pe "debug/pe"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_COFFSymbol = GoTypeInfo{Members: GoMembers{
	"FullName": __ptrTo_COFFSymbol_FullName,
}}

var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_File_Close,
	"DWARF": __ptrTo_File_DWARF,
	"ImportedLibraries": __ptrTo_File_ImportedLibraries,
	"ImportedSymbols": __ptrTo_File_ImportedSymbols,
	"Section": __ptrTo_File_Section,
}}

var members_PtrTo_FormatError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_FormatError_Error,
}}

var members_PtrTo_Section = GoTypeInfo{Members: GoMembers{
	"Data": __ptrTo_Section_Data,
	"Open": __ptrTo_Section_Open,
}}

var members_StringTable = GoTypeInfo{Members: GoMembers{
	"String": __stringTable_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_pe.COFFSymbol)(nil))] = &members_PtrTo_COFFSymbol
	GoTypes[_reflect.TypeOf((*_pe.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_pe.FormatError)(nil))] = &members_PtrTo_FormatError
	GoTypes[_reflect.TypeOf((*_pe.Section)(nil))] = &members_PtrTo_Section
	GoTypes[_reflect.TypeOf((*_pe.StringTable)(nil)).Elem()] = &members_StringTable
}

GO TYPE debug/plan9obj.File from debug/plan9obj/file.go:
func ExtractGoObjectFile(args []Object, index int) *_plan9obj.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.File:
			return &r
		case *_plan9obj.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.File]"))
}

// func _mapToFile(o Map) *_plan9obj.File {
// 	return &_plan9obj.File{}
// }

// func _vectorToFile(o *Vector) *_plan9obj.File {
// 	return &_plan9obj.File{
// 		Sections: ABEND048(codegen.go: no conversion from Clojure for []*debug/plan9obj.Section (*debug/plan9obj.Section)),
// 	}
// }

// func _ConstructFile(_v Object) *_plan9obj.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _plan9obj.File:
// 			return &_g
// 		case *_plan9obj.File:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.File] or: Map or Vector"))
// }

GO TYPE debug/plan9obj.FileHeader from debug/plan9obj/file.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_plan9obj.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.FileHeader:
			return &r
		case *_plan9obj.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.FileHeader]"))
}

func _mapToFileHeader(o Map) *_plan9obj.FileHeader {
	return &_plan9obj.FileHeader{}
}

func _vectorToFileHeader(o *Vector) *_plan9obj.FileHeader {
	return &_plan9obj.FileHeader{
		Magic: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Bss: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Entry: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
		PtrSize: AssertInt(o.Nth(3), "").I,
		LoadAddress: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
		HdrSize: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
	}
}

func _ConstructFileHeader(_v Object) *_plan9obj.FileHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.FileHeader:
			return &_g
		case *_plan9obj.FileHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileHeader(_o.(Map))
	case *Vector:
		return _vectorToFileHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.FileHeader] or: Map or Vector"))
}

GO TYPE debug/plan9obj.Section from debug/plan9obj/file.go:
func ExtractGoObjectSection(args []Object, index int) *_plan9obj.Section {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.Section:
			return &r
		case *_plan9obj.Section:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.Section]"))
}

func _mapToSection(o Map) *_plan9obj.Section {
	return &_plan9obj.Section{}
}

func _vectorToSection(o *Vector) *_plan9obj.Section {
	return &_plan9obj.Section{}
}

func _ConstructSection(_v Object) *_plan9obj.Section {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.Section:
			return &_g
		case *_plan9obj.Section:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSection(_o.(Map))
	case *Vector:
		return _vectorToSection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.Section] or: Map or Vector"))
}

GO TYPE debug/plan9obj.SectionHeader from debug/plan9obj/file.go:
func ExtractGoObjectSectionHeader(args []Object, index int) *_plan9obj.SectionHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.SectionHeader:
			return &r
		case *_plan9obj.SectionHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.SectionHeader]"))
}

func _mapToSectionHeader(o Map) *_plan9obj.SectionHeader {
	return &_plan9obj.SectionHeader{}
}

func _vectorToSectionHeader(o *Vector) *_plan9obj.SectionHeader {
	return &_plan9obj.SectionHeader{
		Name: AssertString(o.Nth(0), "").S,
		Size: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Offset: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
	}
}

func _ConstructSectionHeader(_v Object) *_plan9obj.SectionHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.SectionHeader:
			return &_g
		case *_plan9obj.SectionHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionHeader(_o.(Map))
	case *Vector:
		return _vectorToSectionHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.SectionHeader] or: Map or Vector"))
}

GO TYPE debug/plan9obj.Sym from debug/plan9obj/file.go:
func ExtractGoObjectSym(args []Object, index int) *_plan9obj.Sym {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plan9obj.Sym:
			return &r
		case *_plan9obj.Sym:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[debug/plan9obj.Sym]"))
}

func _mapToSym(o Map) *_plan9obj.Sym {
	return &_plan9obj.Sym{}
}

func _vectorToSym(o *Vector) *_plan9obj.Sym {
	return &_plan9obj.Sym{
		Value: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
		Type: AssertChar(o.Nth(1), "").Ch,
		Name: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructSym(_v Object) *_plan9obj.Sym {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plan9obj.Sym:
			return &_g
		case *_plan9obj.Sym:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSym(_o.(Map))
	case *Vector:
		return _vectorToSym(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plan9obj.Sym] or: Map or Vector"))
}

GO FUNC debug/plan9obj.NewFile from debug/plan9obj/file.go:
// func __newFile(r ABEND987(genutils.go: imports not yet supported: io.ReaderAt)) Object {
// 	_res1, _res2 := _plan9obj.NewFile(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/plan9obj.Open from debug/plan9obj/file.go:
func __open(name string) Object {
	_res1, _res2 := _plan9obj.Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/plan9obj.__ptrTo_File_Close from debug/plan9obj/file.go:
func __ptrTo_File_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/plan9obj.File)Close()", args, 0, 0)
	_res := o.O.(*_plan9obj.File).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC debug/plan9obj.__ptrTo_File_Section from debug/plan9obj/file.go:
func __ptrTo_File_Section(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_debug/plan9obj.File)Section()", args, 1, 1)
	name := ExtractGoString("(*_debug/plan9obj.File)Section()", "name", _argList, 0)
	_res := o.O.(*_plan9obj.File).Section(name)
	return MakeGoObject(_res)
}

GO FUNC debug/plan9obj.__ptrTo_File_Symbols from debug/plan9obj/file.go:
func __ptrTo_File_Symbols(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/plan9obj.File)Symbols()", args, 0, 0)
	_res1, _res2 := o.O.(*_plan9obj.File).Symbols()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/plan9obj.__ptrTo_Section_Data from debug/plan9obj/file.go:
func __ptrTo_Section_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/plan9obj.Section)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_plan9obj.Section).Data()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/plan9obj.__ptrTo_Section_Open from debug/plan9obj/file.go:
func __ptrTo_Section_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_debug/plan9obj.Section)Open()", args, 0, 0)
	_res := o.O.(*_plan9obj.Section).Open()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plan9obj

import (
	_plan9obj "debug/plan9obj"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_File_Close,
	"Section": __ptrTo_File_Section,
	"Symbols": __ptrTo_File_Symbols,
}}

var members_PtrTo_Section = GoTypeInfo{Members: GoMembers{
	"Data": __ptrTo_Section_Data,
	"Open": __ptrTo_Section_Open,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_plan9obj.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_plan9obj.Section)(nil))] = &members_PtrTo_Section
}

GO TYPE encoding/ascii85.CorruptInputError from encoding/ascii85/ascii85.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_ascii85.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ascii85.CorruptInputError:
			return &r
		case *_ascii85.CorruptInputError:
			return r
		}
	case Number:
		v := _ascii85.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/ascii85.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _ascii85.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ascii85.CorruptInputError:
			return _g
		case *_ascii85.CorruptInputError:
			return *_g
		}
	case Number:
		return _ascii85.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ascii85.CorruptInputError] or: Number"))
}

GO FUNC encoding/ascii85.Decode from encoding/ascii85/ascii85.go:
// func __decode(dst []byte, src []byte, flush bool) Object {
// 	ndst, nsrc, err := _ascii85.Decode(dst, src, flush)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(ndst))
// 	_res = _res.Conjoin(MakeInt(nsrc))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/ascii85.Encode from encoding/ascii85/ascii85.go:
// func __encode(dst []byte, src []byte)  {
// 	_res := _ascii85.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/ascii85.NewDecoder from encoding/ascii85/ascii85.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _ascii85.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/ascii85.NewEncoder from encoding/ascii85/ascii85.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _ascii85.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/ascii85.__corruptInputError_Error from encoding/ascii85/ascii85.go:
func __corruptInputError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/ascii85.CorruptInputError)Error()", args, 0, 0)
	_res := o.O.(_ascii85.CorruptInputError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ascii85

import (
	_ascii85 "encoding/ascii85"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_CorruptInputError = GoTypeInfo{Members: GoMembers{
	"Error": __corruptInputError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_ascii85.CorruptInputError)(nil)).Elem()] = &members_CorruptInputError
}

GO TYPE encoding/asn1.BitString from encoding/asn1/asn1.go:
func ExtractGoObjectBitString(args []Object, index int) *_asn1.BitString {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.BitString:
			return &r
		case *_asn1.BitString:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.BitString]"))
}

// func _mapToBitString(o Map) *_asn1.BitString {
// 	return &_asn1.BitString{}
// }

// func _vectorToBitString(o *Vector) *_asn1.BitString {
// 	return &_asn1.BitString{
// 		Bytes: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		BitLength: AssertInt(o.Nth(1), "").I,
// 	}
// }

// func _ConstructBitString(_v Object) *_asn1.BitString {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _asn1.BitString:
// 			return &_g
// 		case *_asn1.BitString:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBitString(_o.(Map))
// 	case *Vector:
// 		return _vectorToBitString(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.BitString] or: Map or Vector"))
// }

GO TYPE encoding/asn1.Enumerated from encoding/asn1/asn1.go:
func ExtractGoObjectEnumerated(args []Object, index int) *_asn1.Enumerated {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.Enumerated:
			return &r
		case *_asn1.Enumerated:
			return r
		}
	case Int:
		v := _asn1.Enumerated(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.Enumerated]"))
}

func _ConstructEnumerated(_v Object) _asn1.Enumerated {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _asn1.Enumerated:
			return _g
		case *_asn1.Enumerated:
			return *_g
		}
	case Number:
		return _asn1.Enumerated(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.Enumerated] or: Number"))
}

GO TYPE encoding/asn1.Flag from encoding/asn1/asn1.go:
func ExtractGoObjectFlag(args []Object, index int) *_asn1.Flag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.Flag:
			return &r
		case *_asn1.Flag:
			return r
		}
	case Boolean:
		v := _asn1.Flag(ExtractBoolean(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.Flag]"))
}

func _ConstructFlag(_v Object) _asn1.Flag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _asn1.Flag:
			return _g
		case *_asn1.Flag:
			return *_g
		}
	case Boolean:
		return _asn1.Flag(_o.B)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.Flag] or: Boolean"))
}

GO TYPE encoding/asn1.ObjectIdentifier from encoding/asn1/asn1.go:
func ExtractGoObjectObjectIdentifier(args []Object, index int) *_asn1.ObjectIdentifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.ObjectIdentifier:
			return &r
		case *_asn1.ObjectIdentifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.ObjectIdentifier]"))
}

// func _ConstructObjectIdentifier(_v Object) _asn1.ObjectIdentifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _asn1.ObjectIdentifier:
// 			return _g
// 		case *_asn1.ObjectIdentifier:
// 			return *_g
// 		}
// 	default:
// 		return _asn1.ObjectIdentifier(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for ObjectIdentifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.ObjectIdentifier] or: whatever"))
// }

GO TYPE encoding/asn1.RawContent from encoding/asn1/asn1.go:
func ExtractGoObjectRawContent(args []Object, index int) *_asn1.RawContent {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.RawContent:
			return &r
		case *_asn1.RawContent:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.RawContent]"))
}

// func _ConstructRawContent(_v Object) _asn1.RawContent {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _asn1.RawContent:
// 			return _g
// 		case *_asn1.RawContent:
// 			return *_g
// 		}
// 	default:
// 		return _asn1.RawContent(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for RawContent))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.RawContent] or: whatever"))
// }

GO TYPE encoding/asn1.RawValue from encoding/asn1/asn1.go:
func ExtractGoObjectRawValue(args []Object, index int) *_asn1.RawValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.RawValue:
			return &r
		case *_asn1.RawValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.RawValue]"))
}

// func _mapToRawValue(o Map) *_asn1.RawValue {
// 	return &_asn1.RawValue{}
// }

// func _vectorToRawValue(o *Vector) *_asn1.RawValue {
// 	return &_asn1.RawValue{
// 		Class: AssertInt(o.Nth(0), "").I,
// 		Tag: AssertInt(o.Nth(1), "").I,
// 		IsCompound: ToBool(o.Nth(2)),
// 		Bytes: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 		FullBytes: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructRawValue(_v Object) *_asn1.RawValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _asn1.RawValue:
// 			return &_g
// 		case *_asn1.RawValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.RawValue] or: Map or Vector"))
// }

GO TYPE encoding/asn1.StructuralError from encoding/asn1/asn1.go:
func ExtractGoObjectStructuralError(args []Object, index int) *_asn1.StructuralError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.StructuralError:
			return &r
		case *_asn1.StructuralError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.StructuralError]"))
}

func _mapToStructuralError(o Map) *_asn1.StructuralError {
	return &_asn1.StructuralError{}
}

func _vectorToStructuralError(o *Vector) *_asn1.StructuralError {
	return &_asn1.StructuralError{
		Msg: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructStructuralError(_v Object) *_asn1.StructuralError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _asn1.StructuralError:
			return &_g
		case *_asn1.StructuralError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStructuralError(_o.(Map))
	case *Vector:
		return _vectorToStructuralError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.StructuralError] or: Map or Vector"))
}

GO TYPE encoding/asn1.SyntaxError from encoding/asn1/asn1.go:
func ExtractGoObjectSyntaxError(args []Object, index int) *_asn1.SyntaxError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _asn1.SyntaxError:
			return &r
		case *_asn1.SyntaxError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/asn1.SyntaxError]"))
}

func _mapToSyntaxError(o Map) *_asn1.SyntaxError {
	return &_asn1.SyntaxError{}
}

func _vectorToSyntaxError(o *Vector) *_asn1.SyntaxError {
	return &_asn1.SyntaxError{
		Msg: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructSyntaxError(_v Object) *_asn1.SyntaxError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _asn1.SyntaxError:
			return &_g
		case *_asn1.SyntaxError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyntaxError(_o.(Map))
	case *Vector:
		return _vectorToSyntaxError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[asn1.SyntaxError] or: Map or Vector"))
}

GO FUNC encoding/asn1.Marshal from encoding/asn1/marshal.go:
// func __marshal(val interface {}) Object {
// 	_res1, _res2 := _asn1.Marshal(val)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.MarshalWithParams from encoding/asn1/marshal.go:
// func __marshalWithParams(val interface {}, params string) Object {
// 	_res1, _res2 := _asn1.MarshalWithParams(val, params)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.Unmarshal from encoding/asn1/asn1.go:
// func __unmarshal(b []byte, val interface {}) Object {
// 	rest, err := _asn1.Unmarshal(b, val)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/asn1.UnmarshalWithParams from encoding/asn1/asn1.go:
// func __unmarshalWithParams(b []byte, val interface {}, params string) Object {
// 	rest, err := _asn1.UnmarshalWithParams(b, val, params)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/asn1.__bitString_At from encoding/asn1/asn1.go:
func __bitString_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_encoding/asn1.BitString)At()", args, 1, 1)
	i := ExtractGoInt("(_encoding/asn1.BitString)At()", "i", _argList, 0)
	_res := o.O.(_asn1.BitString).At(i)
	return MakeInt(_res)
}

GO FUNC encoding/asn1.__bitString_RightAlign from encoding/asn1/asn1.go:
func __bitString_RightAlign(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/asn1.BitString)RightAlign()", args, 0, 0)
	_res := o.O.(_asn1.BitString).RightAlign()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC encoding/asn1.__objectIdentifier_Equal from encoding/asn1/asn1.go:
func __objectIdentifier_Equal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_encoding/asn1.ObjectIdentifier)Equal()", args, 1, 1)
	other := ExtractGo_go_std_encoding_asn1__ObjectIdentifier("(_encoding/asn1.ObjectIdentifier)Equal()", "other", _argList, 0)
	_res := o.O.(_asn1.ObjectIdentifier).Equal(other)
	return MakeBoolean(_res)
}

GO FUNC encoding/asn1.__objectIdentifier_String from encoding/asn1/asn1.go:
func __objectIdentifier_String(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/asn1.ObjectIdentifier)String()", args, 0, 0)
	_res := o.O.(_asn1.ObjectIdentifier).String()
	return MakeString(_res)
}

GO FUNC encoding/asn1.__structuralError_Error from encoding/asn1/asn1.go:
func __structuralError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/asn1.StructuralError)Error()", args, 0, 0)
	_res := o.O.(_asn1.StructuralError).Error()
	return MakeString(_res)
}

GO FUNC encoding/asn1.__syntaxError_Error from encoding/asn1/asn1.go:
func __syntaxError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/asn1.SyntaxError)Error()", args, 0, 0)
	_res := o.O.(_asn1.SyntaxError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package asn1

import (
	_asn1 "encoding/asn1"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_BitString = GoTypeInfo{Members: GoMembers{
	"At": __bitString_At,
	"RightAlign": __bitString_RightAlign,
}}

var members_ObjectIdentifier = GoTypeInfo{Members: GoMembers{
	"Equal": __objectIdentifier_Equal,
	"String": __objectIdentifier_String,
}}

var members_StructuralError = GoTypeInfo{Members: GoMembers{
	"Error": __structuralError_Error,
}}

var members_SyntaxError = GoTypeInfo{Members: GoMembers{
	"Error": __syntaxError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_asn1.BitString)(nil)).Elem()] = &members_BitString
	GoTypes[_reflect.TypeOf((*_asn1.ObjectIdentifier)(nil)).Elem()] = &members_ObjectIdentifier
	GoTypes[_reflect.TypeOf((*_asn1.StructuralError)(nil)).Elem()] = &members_StructuralError
	GoTypes[_reflect.TypeOf((*_asn1.SyntaxError)(nil)).Elem()] = &members_SyntaxError
}

GO TYPE encoding/base32.CorruptInputError from encoding/base32/base32.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_base32.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base32.CorruptInputError:
			return &r
		case *_base32.CorruptInputError:
			return r
		}
	case Number:
		v := _base32.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base32.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _base32.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base32.CorruptInputError:
			return _g
		case *_base32.CorruptInputError:
			return *_g
		}
	case Number:
		return _base32.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base32.CorruptInputError] or: Number"))
}

GO TYPE encoding/base32.Encoding from encoding/base32/base32.go:
func ExtractGoObjectEncoding(args []Object, index int) *_base32.Encoding {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base32.Encoding:
			return &r
		case *_base32.Encoding:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base32.Encoding]"))
}

func _mapToEncoding(o Map) *_base32.Encoding {
	return &_base32.Encoding{}
}

func _vectorToEncoding(o *Vector) *_base32.Encoding {
	return &_base32.Encoding{}
}

func _ConstructEncoding(_v Object) *_base32.Encoding {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base32.Encoding:
			return &_g
		case *_base32.Encoding:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoding(_o.(Map))
	case *Vector:
		return _vectorToEncoding(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base32.Encoding] or: Map or Vector"))
}

GO FUNC encoding/base32.NewDecoder from encoding/base32/base32.go:
// func __newDecoder(enc *_base32.Encoding, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _base32.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoder from encoding/base32/base32.go:
// func __newEncoder(enc *_base32.Encoding, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _base32.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base32.NewEncoding from encoding/base32/base32.go:
func __newEncoding(encoder string) Object {
	_res := _base32.NewEncoding(encoder)
	return MakeGoObject(_res)
}

GO FUNC encoding/base32.__corruptInputError_Error from encoding/base32/base32.go:
func __corruptInputError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/base32.CorruptInputError)Error()", args, 0, 0)
	_res := o.O.(_base32.CorruptInputError).Error()
	return MakeString(_res)
}

GO FUNC encoding/base32.__encoding_WithPadding from encoding/base32/base32.go:
func __encoding_WithPadding(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_encoding/base32.Encoding)WithPadding()", args, 1, 1)
	padding := ExtractGoChar("(_encoding/base32.Encoding)WithPadding()", "padding", _argList, 0)
	_res := o.O.(_base32.Encoding).WithPadding(padding)
	return MakeGoObject(_res)
}

GO FUNC encoding/base32.__ptrTo_Encoding_Decode from encoding/base32/base32.go:
// func __ptrTo_Encoding_Decode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base32.__ptrTo_Encoding_DecodeString from encoding/base32/base32.go:
func __ptrTo_Encoding_DecodeString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base32.Encoding)DecodeString()", args, 1, 1)
	s := ExtractGoString("(*_encoding/base32.Encoding)DecodeString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_base32.Encoding).DecodeString(s)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/base32.__ptrTo_Encoding_DecodedLen from encoding/base32/base32.go:
func __ptrTo_Encoding_DecodedLen(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base32.Encoding)DecodedLen()", args, 1, 1)
	n := ExtractGoInt("(*_encoding/base32.Encoding)DecodedLen()", "n", _argList, 0)
	_res := o.O.(*_base32.Encoding).DecodedLen(n)
	return MakeInt(_res)
}

GO FUNC encoding/base32.__ptrTo_Encoding_Encode from encoding/base32/base32.go:
// func __ptrTo_Encoding_Encode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base32.__ptrTo_Encoding_EncodeToString from encoding/base32/base32.go:
// func __ptrTo_Encoding_EncodeToString(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base32.__ptrTo_Encoding_EncodedLen from encoding/base32/base32.go:
func __ptrTo_Encoding_EncodedLen(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base32.Encoding)EncodedLen()", args, 1, 1)
	n := ExtractGoInt("(*_encoding/base32.Encoding)EncodedLen()", "n", _argList, 0)
	_res := o.O.(*_base32.Encoding).EncodedLen(n)
	return MakeInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base32

import (
	_base32 "encoding/base32"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_CorruptInputError = GoTypeInfo{Members: GoMembers{
	"Error": __corruptInputError_Error,
}}

var members_PtrTo_Encoding = GoTypeInfo{Members: GoMembers{
	"DecodeString": __ptrTo_Encoding_DecodeString,
	"DecodedLen": __ptrTo_Encoding_DecodedLen,
	"EncodedLen": __ptrTo_Encoding_EncodedLen,
}}

var members_Encoding = GoTypeInfo{Members: GoMembers{
	"WithPadding": __encoding_WithPadding,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_base32.CorruptInputError)(nil)).Elem()] = &members_CorruptInputError
	GoTypes[_reflect.TypeOf((*_base32.Encoding)(nil))] = &members_PtrTo_Encoding
	GoTypes[_reflect.TypeOf((*_base32.Encoding)(nil)).Elem()] = &members_Encoding
}

GO TYPE encoding/base64.CorruptInputError from encoding/base64/base64.go:
func ExtractGoObjectCorruptInputError(args []Object, index int) *_base64.CorruptInputError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base64.CorruptInputError:
			return &r
		case *_base64.CorruptInputError:
			return r
		}
	case Number:
		v := _base64.CorruptInputError(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base64.CorruptInputError]"))
}

func _ConstructCorruptInputError(_v Object) _base64.CorruptInputError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base64.CorruptInputError:
			return _g
		case *_base64.CorruptInputError:
			return *_g
		}
	case Number:
		return _base64.CorruptInputError(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base64.CorruptInputError] or: Number"))
}

GO TYPE encoding/base64.Encoding from encoding/base64/base64.go:
func ExtractGoObjectEncoding(args []Object, index int) *_base64.Encoding {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _base64.Encoding:
			return &r
		case *_base64.Encoding:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/base64.Encoding]"))
}

func _mapToEncoding(o Map) *_base64.Encoding {
	return &_base64.Encoding{}
}

func _vectorToEncoding(o *Vector) *_base64.Encoding {
	return &_base64.Encoding{}
}

func _ConstructEncoding(_v Object) *_base64.Encoding {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _base64.Encoding:
			return &_g
		case *_base64.Encoding:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoding(_o.(Map))
	case *Vector:
		return _vectorToEncoding(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[base64.Encoding] or: Map or Vector"))
}

GO FUNC encoding/base64.NewDecoder from encoding/base64/base64.go:
// func __newDecoder(enc *_base64.Encoding, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _base64.NewDecoder(enc, r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoder from encoding/base64/base64.go:
// func __newEncoder(enc *_base64.Encoding, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _base64.NewEncoder(enc, w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/base64.NewEncoding from encoding/base64/base64.go:
func __newEncoding(encoder string) Object {
	_res := _base64.NewEncoding(encoder)
	return MakeGoObject(_res)
}

GO FUNC encoding/base64.__corruptInputError_Error from encoding/base64/base64.go:
func __corruptInputError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/base64.CorruptInputError)Error()", args, 0, 0)
	_res := o.O.(_base64.CorruptInputError).Error()
	return MakeString(_res)
}

GO FUNC encoding/base64.__encoding_Strict from encoding/base64/base64.go:
func __encoding_Strict(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/base64.Encoding)Strict()", args, 0, 0)
	_res := o.O.(_base64.Encoding).Strict()
	return MakeGoObject(_res)
}

GO FUNC encoding/base64.__encoding_WithPadding from encoding/base64/base64.go:
func __encoding_WithPadding(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_encoding/base64.Encoding)WithPadding()", args, 1, 1)
	padding := ExtractGoChar("(_encoding/base64.Encoding)WithPadding()", "padding", _argList, 0)
	_res := o.O.(_base64.Encoding).WithPadding(padding)
	return MakeGoObject(_res)
}

GO FUNC encoding/base64.__ptrTo_Encoding_Decode from encoding/base64/base64.go:
// func __ptrTo_Encoding_Decode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base64.__ptrTo_Encoding_DecodeString from encoding/base64/base64.go:
func __ptrTo_Encoding_DecodeString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base64.Encoding)DecodeString()", args, 1, 1)
	s := ExtractGoString("(*_encoding/base64.Encoding)DecodeString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_base64.Encoding).DecodeString(s)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/base64.__ptrTo_Encoding_DecodedLen from encoding/base64/base64.go:
func __ptrTo_Encoding_DecodedLen(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base64.Encoding)DecodedLen()", args, 1, 1)
	n := ExtractGoInt("(*_encoding/base64.Encoding)DecodedLen()", "n", _argList, 0)
	_res := o.O.(*_base64.Encoding).DecodedLen(n)
	return MakeInt(_res)
}

GO FUNC encoding/base64.__ptrTo_Encoding_Encode from encoding/base64/base64.go:
// func __ptrTo_Encoding_Encode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base64.__ptrTo_Encoding_EncodeToString from encoding/base64/base64.go:
// func __ptrTo_Encoding_EncodeToString(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)))}

GO FUNC encoding/base64.__ptrTo_Encoding_EncodedLen from encoding/base64/base64.go:
func __ptrTo_Encoding_EncodedLen(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/base64.Encoding)EncodedLen()", args, 1, 1)
	n := ExtractGoInt("(*_encoding/base64.Encoding)EncodedLen()", "n", _argList, 0)
	_res := o.O.(*_base64.Encoding).EncodedLen(n)
	return MakeInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package base64

import (
	_base64 "encoding/base64"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_CorruptInputError = GoTypeInfo{Members: GoMembers{
	"Error": __corruptInputError_Error,
}}

var members_PtrTo_Encoding = GoTypeInfo{Members: GoMembers{
	"DecodeString": __ptrTo_Encoding_DecodeString,
	"DecodedLen": __ptrTo_Encoding_DecodedLen,
	"EncodedLen": __ptrTo_Encoding_EncodedLen,
}}

var members_Encoding = GoTypeInfo{Members: GoMembers{
	"Strict": __encoding_Strict,
	"WithPadding": __encoding_WithPadding,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_base64.CorruptInputError)(nil)).Elem()] = &members_CorruptInputError
	GoTypes[_reflect.TypeOf((*_base64.Encoding)(nil))] = &members_PtrTo_Encoding
	GoTypes[_reflect.TypeOf((*_base64.Encoding)(nil)).Elem()] = &members_Encoding
}

GO FUNC encoding/binary.PutUvarint from encoding/binary/varint.go:
// func __putUvarint(buf []byte, x uint64)  {
// 	_res := _binary.PutUvarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.PutVarint from encoding/binary/varint.go:
// func __putVarint(buf []byte, x int64)  {
// 	_res := _binary.PutVarint(buf, x)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Read from encoding/binary/binary.go:
// func __read(r ABEND987(genutils.go: imports not yet supported: io.Reader), order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Read(r, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/binary.ReadUvarint from encoding/binary/varint.go:
// func __readUvarint(r ABEND987(genutils.go: imports not yet supported: io.ByteReader)) Object {
// 	_res1, _res2 := _binary.ReadUvarint(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBigIntU(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.ReadVarint from encoding/binary/varint.go:
// func __readVarint(r ABEND987(genutils.go: imports not yet supported: io.ByteReader)) Object {
// 	_res1, _res2 := _binary.ReadVarint(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBigInt(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.Size from encoding/binary/binary.go:
// func __size(v interface {})  {
// 	_res := _binary.Size(v)
// 	return MakeInt(_res)
// }

GO FUNC encoding/binary.Uvarint from encoding/binary/varint.go:
// func __uvarint(buf []byte) Object {
// 	_res1, _res2 := _binary.Uvarint(buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBigIntU(_res1))
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Varint from encoding/binary/varint.go:
// func __varint(buf []byte) Object {
// 	_res1, _res2 := _binary.Varint(buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBigInt(_res1))
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Write from encoding/binary/binary.go:
// func __write(w ABEND987(genutils.go: imports not yet supported: io.Writer), order _binary.ByteOrder, data interface {})  {
// 	_res := _binary.Write(w, order, data)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE encoding/csv.ParseError from encoding/csv/reader.go:
func ExtractGoObjectParseError(args []Object, index int) *_csv.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _csv.ParseError:
			return &r
		case *_csv.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/csv.ParseError]"))
}

func _mapToParseError(o Map) *_csv.ParseError {
	return &_csv.ParseError{}
}

func _vectorToParseError(o *Vector) *_csv.ParseError {
	return &_csv.ParseError{
		StartLine: AssertInt(o.Nth(0), "").I,
		Line: AssertInt(o.Nth(1), "").I,
		Column: AssertInt(o.Nth(2), "").I,
		Err: _errors.New(AssertString(o.Nth(3), "").S),
	}
}

func _ConstructParseError(_v Object) *_csv.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _csv.ParseError:
			return &_g
		case *_csv.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[csv.ParseError] or: Map or Vector"))
}

GO TYPE encoding/csv.Reader from encoding/csv/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_csv.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _csv.Reader:
			return &r
		case *_csv.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/csv.Reader]"))
}

func _mapToReader(o Map) *_csv.Reader {
	return &_csv.Reader{}
}

func _vectorToReader(o *Vector) *_csv.Reader {
	return &_csv.Reader{
		Comma: AssertChar(o.Nth(0), "").Ch,
		Comment: AssertChar(o.Nth(1), "").Ch,
		FieldsPerRecord: AssertInt(o.Nth(2), "").I,
		LazyQuotes: ToBool(o.Nth(3)),
		TrimLeadingSpace: ToBool(o.Nth(4)),
		ReuseRecord: ToBool(o.Nth(5)),
		TrailingComma: ToBool(o.Nth(6)),
	}
}

func _ConstructReader(_v Object) *_csv.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _csv.Reader:
			return &_g
		case *_csv.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[csv.Reader] or: Map or Vector"))
}

GO TYPE encoding/csv.Writer from encoding/csv/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_csv.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _csv.Writer:
			return &r
		case *_csv.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/csv.Writer]"))
}

func _mapToWriter(o Map) *_csv.Writer {
	return &_csv.Writer{}
}

func _vectorToWriter(o *Vector) *_csv.Writer {
	return &_csv.Writer{
		Comma: AssertChar(o.Nth(0), "").Ch,
		UseCRLF: ToBool(o.Nth(1)),
	}
}

func _ConstructWriter(_v Object) *_csv.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _csv.Writer:
			return &_g
		case *_csv.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[csv.Writer] or: Map or Vector"))
}

GO FUNC encoding/csv.NewReader from encoding/csv/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _csv.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/csv.NewWriter from encoding/csv/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _csv.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/csv.__ptrTo_ParseError_Error from encoding/csv/reader.go:
func __ptrTo_ParseError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/csv.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_csv.ParseError).Error()
	return MakeString(_res)
}

GO FUNC encoding/csv.__ptrTo_Reader_Read from encoding/csv/reader.go:
func __ptrTo_Reader_Read(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/csv.Reader)Read()", args, 0, 0)
	record, err := o.O.(*_csv.Reader).Read()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range record {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC encoding/csv.__ptrTo_Reader_ReadAll from encoding/csv/reader.go:
func __ptrTo_Reader_ReadAll(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/csv.Reader)ReadAll()", args, 0, 0)
	records, err := o.O.(*_csv.Reader).ReadAll()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range records {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeString(_elem2))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC encoding/csv.__ptrTo_Writer_Error from encoding/csv/writer.go:
func __ptrTo_Writer_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/csv.Writer)Error()", args, 0, 0)
	_res := o.O.(*_csv.Writer).Error()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC encoding/csv.__ptrTo_Writer_Flush from encoding/csv/writer.go:
// func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/csv.__ptrTo_Writer_Write from encoding/csv/writer.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(record)))}

GO FUNC encoding/csv.__ptrTo_Writer_WriteAll from encoding/csv/writer.go:
// func __ptrTo_Writer_WriteAll(o GoObject, args Object) Object {
// (ConvertToArrayOf[]string(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(records))))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package csv

import (
	_csv "encoding/csv"
	_errors "errors"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_ParseError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ParseError_Error,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Read": __ptrTo_Reader_Read,
	"ReadAll": __ptrTo_Reader_ReadAll,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Writer_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_csv.ParseError)(nil))] = &members_PtrTo_ParseError
	GoTypes[_reflect.TypeOf((*_csv.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_csv.Writer)(nil))] = &members_PtrTo_Writer
}

GO FUNC encoding/gob.NewDecoder from encoding/gob/decoder.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _gob.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.NewEncoder from encoding/gob/encoder.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _gob.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/gob.Register from encoding/gob/type.go:
// func __register(value interface {}) Object {
// 	_gob.Register(value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/gob.RegisterName from encoding/gob/type.go:
// func __registerName(name string, value interface {}) Object {
// 	_gob.RegisterName(name, value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/gob.__ptrTo_Decoder_Decode from encoding/gob/decoder.go:
// func __ptrTo_Decoder_Decode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/gob.__ptrTo_Decoder_DecodeValue from encoding/gob/decoder.go:
// func __ptrTo_Decoder_DecodeValue(o GoObject, args Object) Object {
// v ABEND987(genutils.go: imports not yet supported: reflect.Value)}

GO FUNC encoding/gob.__ptrTo_Encoder_Encode from encoding/gob/encoder.go:
// func __ptrTo_Encoder_Encode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/gob.__ptrTo_Encoder_EncodeValue from encoding/gob/encoder.go:
// func __ptrTo_Encoder_EncodeValue(o GoObject, args Object) Object {
// value ABEND987(genutils.go: imports not yet supported: reflect.Value)}

GO TYPE encoding/hex.InvalidByteError from encoding/hex/hex.go:
func ExtractGoObjectInvalidByteError(args []Object, index int) *_hex.InvalidByteError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _hex.InvalidByteError:
			return &r
		case *_hex.InvalidByteError:
			return r
		}
	case Int:
		v := _hex.InvalidByteError(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/hex.InvalidByteError]"))
}

func _ConstructInvalidByteError(_v Object) _hex.InvalidByteError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _hex.InvalidByteError:
			return _g
		case *_hex.InvalidByteError:
			return *_g
		}
	case Number:
		return _hex.InvalidByteError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[hex.InvalidByteError] or: Number"))
}

GO FUNC encoding/hex.Decode from encoding/hex/hex.go:
// func __decode(dst []byte, src []byte) Object {
// 	_res1, _res2 := _hex.Decode(dst, src)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/hex.DecodeString from encoding/hex/hex.go:
func __decodeString(s string) Object {
	_res1, _res2 := _hex.DecodeString(s)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/hex.Dump from encoding/hex/hex.go:
// func __dump(data []byte)  {
// 	_res := _hex.Dump(data)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.Dumper from encoding/hex/hex.go:
// func __dumper(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _hex.Dumper(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.Encode from encoding/hex/hex.go:
// func __encode(dst []byte, src []byte)  {
// 	_res := _hex.Encode(dst, src)
// 	return MakeInt(_res)
// }

GO FUNC encoding/hex.EncodeToString from encoding/hex/hex.go:
// func __encodeToString(src []byte)  {
// 	_res := _hex.EncodeToString(src)
// 	return MakeString(_res)
// }

GO FUNC encoding/hex.NewDecoder from encoding/hex/hex.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _hex.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.NewEncoder from encoding/hex/hex.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _hex.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/hex.__invalidByteError_Error from encoding/hex/hex.go:
func __invalidByteError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/hex.InvalidByteError)Error()", args, 0, 0)
	_res := o.O.(_hex.InvalidByteError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package hex

import (
	_hex "encoding/hex"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_InvalidByteError = GoTypeInfo{Members: GoMembers{
	"Error": __invalidByteError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_hex.InvalidByteError)(nil)).Elem()] = &members_InvalidByteError
}

GO TYPE encoding/json.Decoder from encoding/json/stream.go:
func ExtractGoObjectDecoder(args []Object, index int) *_json.Decoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Decoder:
			return &r
		case *_json.Decoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Decoder]"))
}

func _mapToDecoder(o Map) *_json.Decoder {
	return &_json.Decoder{}
}

func _vectorToDecoder(o *Vector) *_json.Decoder {
	return &_json.Decoder{}
}

func _ConstructDecoder(_v Object) *_json.Decoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.Decoder:
			return &_g
		case *_json.Decoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDecoder(_o.(Map))
	case *Vector:
		return _vectorToDecoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Decoder] or: Map or Vector"))
}

GO TYPE encoding/json.Delim from encoding/json/stream.go:
func ExtractGoObjectDelim(args []Object, index int) *_json.Delim {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Delim:
			return &r
		case *_json.Delim:
			return r
		}
	case Char:
		v := _json.Delim(ExtractChar(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Delim]"))
}

func _ConstructDelim(_v Object) _json.Delim {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.Delim:
			return _g
		case *_json.Delim:
			return *_g
		}
	case Char:
		return _json.Delim(_o.Ch)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Delim] or: Char"))
}

GO TYPE encoding/json.Encoder from encoding/json/stream.go:
func ExtractGoObjectEncoder(args []Object, index int) *_json.Encoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Encoder:
			return &r
		case *_json.Encoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Encoder]"))
}

func _mapToEncoder(o Map) *_json.Encoder {
	return &_json.Encoder{}
}

func _vectorToEncoder(o *Vector) *_json.Encoder {
	return &_json.Encoder{}
}

func _ConstructEncoder(_v Object) *_json.Encoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.Encoder:
			return &_g
		case *_json.Encoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoder(_o.(Map))
	case *Vector:
		return _vectorToEncoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Encoder] or: Map or Vector"))
}

GO TYPE encoding/json.InvalidUTF8Error from encoding/json/encode.go:
func ExtractGoObjectInvalidUTF8Error(args []Object, index int) *_json.InvalidUTF8Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.InvalidUTF8Error:
			return &r
		case *_json.InvalidUTF8Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.InvalidUTF8Error]"))
}

func _mapToInvalidUTF8Error(o Map) *_json.InvalidUTF8Error {
	return &_json.InvalidUTF8Error{}
}

func _vectorToInvalidUTF8Error(o *Vector) *_json.InvalidUTF8Error {
	return &_json.InvalidUTF8Error{
		S: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructInvalidUTF8Error(_v Object) *_json.InvalidUTF8Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.InvalidUTF8Error:
			return &_g
		case *_json.InvalidUTF8Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInvalidUTF8Error(_o.(Map))
	case *Vector:
		return _vectorToInvalidUTF8Error(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.InvalidUTF8Error] or: Map or Vector"))
}

GO TYPE encoding/json.InvalidUnmarshalError from encoding/json/decode.go:
func ExtractGoObjectInvalidUnmarshalError(args []Object, index int) *_json.InvalidUnmarshalError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.InvalidUnmarshalError:
			return &r
		case *_json.InvalidUnmarshalError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.InvalidUnmarshalError]"))
}

// func _mapToInvalidUnmarshalError(o Map) *_json.InvalidUnmarshalError {
// 	return &_json.InvalidUnmarshalError{}
// }

// func _vectorToInvalidUnmarshalError(o *Vector) *_json.InvalidUnmarshalError {
// 	return &_json.InvalidUnmarshalError{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructInvalidUnmarshalError(_v Object) *_json.InvalidUnmarshalError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.InvalidUnmarshalError:
// 			return &_g
// 		case *_json.InvalidUnmarshalError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInvalidUnmarshalError(_o.(Map))
// 	case *Vector:
// 		return _vectorToInvalidUnmarshalError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.InvalidUnmarshalError] or: Map or Vector"))
// }

GO TYPE encoding/json.Marshaler from encoding/json/encode.go:
func ExtractGoObjectMarshaler(args []Object, index int) *_json.Marshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Marshaler:
			return &r
		case *_json.Marshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Marshaler]"))
}

// func _ConstructMarshaler(_v Object) _json.Marshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.Marshaler:
// 			return _g
// 		case *_json.Marshaler:
// 			return *_g
// 		}
// 	default:
// 		return _json.Marshaler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Marshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Marshaler] or: whatever"))
// }

GO TYPE encoding/json.MarshalerError from encoding/json/encode.go:
func ExtractGoObjectMarshalerError(args []Object, index int) *_json.MarshalerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.MarshalerError:
			return &r
		case *_json.MarshalerError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.MarshalerError]"))
}

// func _mapToMarshalerError(o Map) *_json.MarshalerError {
// 	return &_json.MarshalerError{}
// }

// func _vectorToMarshalerError(o *Vector) *_json.MarshalerError {
// 	return &_json.MarshalerError{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Err: _errors.New(AssertString(o.Nth(1), "").S),
// 	}
// }

// func _ConstructMarshalerError(_v Object) *_json.MarshalerError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.MarshalerError:
// 			return &_g
// 		case *_json.MarshalerError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMarshalerError(_o.(Map))
// 	case *Vector:
// 		return _vectorToMarshalerError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.MarshalerError] or: Map or Vector"))
// }

GO TYPE encoding/json.Number from encoding/json/decode.go:
func ExtractGoObjectNumber(args []Object, index int) *_json.Number {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Number:
			return &r
		case *_json.Number:
			return r
		}
	case String:
		v := _json.Number(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Number]"))
}

func _ConstructNumber(_v Object) _json.Number {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.Number:
			return _g
		case *_json.Number:
			return *_g
		}
	case String:
		return _json.Number(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Number] or: String"))
}

GO TYPE encoding/json.RawMessage from encoding/json/stream.go:
func ExtractGoObjectRawMessage(args []Object, index int) *_json.RawMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.RawMessage:
			return &r
		case *_json.RawMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.RawMessage]"))
}

// func _ConstructRawMessage(_v Object) _json.RawMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.RawMessage:
// 			return _g
// 		case *_json.RawMessage:
// 			return *_g
// 		}
// 	default:
// 		return _json.RawMessage(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for RawMessage))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.RawMessage] or: whatever"))
// }

GO TYPE encoding/json.SyntaxError from encoding/json/scanner.go:
func ExtractGoObjectSyntaxError(args []Object, index int) *_json.SyntaxError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.SyntaxError:
			return &r
		case *_json.SyntaxError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.SyntaxError]"))
}

func _mapToSyntaxError(o Map) *_json.SyntaxError {
	return &_json.SyntaxError{}
}

func _vectorToSyntaxError(o *Vector) *_json.SyntaxError {
	return &_json.SyntaxError{
		Offset: AssertNumber(o.Nth(0), "").BigInt().Int64(),
	}
}

func _ConstructSyntaxError(_v Object) *_json.SyntaxError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _json.SyntaxError:
			return &_g
		case *_json.SyntaxError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyntaxError(_o.(Map))
	case *Vector:
		return _vectorToSyntaxError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[json.SyntaxError] or: Map or Vector"))
}

GO TYPE encoding/json.Token from encoding/json/stream.go:
func ExtractGoObjectToken(args []Object, index int) *_json.Token {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Token:
			return &r
		case *_json.Token:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Token]"))
}

// func _ConstructToken(_v Object) _json.Token {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.Token:
// 			return _g
// 		case *_json.Token:
// 			return *_g
// 		}
// 	default:
// 		return _json.Token(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Token))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Token] or: whatever"))
// }

GO TYPE encoding/json.UnmarshalFieldError from encoding/json/decode.go:
func ExtractGoObjectUnmarshalFieldError(args []Object, index int) *_json.UnmarshalFieldError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.UnmarshalFieldError:
			return &r
		case *_json.UnmarshalFieldError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.UnmarshalFieldError]"))
}

// func _mapToUnmarshalFieldError(o Map) *_json.UnmarshalFieldError {
// 	return &_json.UnmarshalFieldError{}
// }

// func _vectorToUnmarshalFieldError(o *Vector) *_json.UnmarshalFieldError {
// 	return &_json.UnmarshalFieldError{
// 		Key: AssertString(o.Nth(0), "").S,
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Field: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructUnmarshalFieldError(_v Object) *_json.UnmarshalFieldError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.UnmarshalFieldError:
// 			return &_g
// 		case *_json.UnmarshalFieldError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnmarshalFieldError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnmarshalFieldError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.UnmarshalFieldError] or: Map or Vector"))
// }

GO TYPE encoding/json.UnmarshalTypeError from encoding/json/decode.go:
func ExtractGoObjectUnmarshalTypeError(args []Object, index int) *_json.UnmarshalTypeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.UnmarshalTypeError:
			return &r
		case *_json.UnmarshalTypeError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.UnmarshalTypeError]"))
}

// func _mapToUnmarshalTypeError(o Map) *_json.UnmarshalTypeError {
// 	return &_json.UnmarshalTypeError{}
// }

// func _vectorToUnmarshalTypeError(o *Vector) *_json.UnmarshalTypeError {
// 	return &_json.UnmarshalTypeError{
// 		Value: AssertString(o.Nth(0), "").S,
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Offset: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 		Struct: AssertString(o.Nth(3), "").S,
// 		Field: AssertString(o.Nth(4), "").S,
// 	}
// }

// func _ConstructUnmarshalTypeError(_v Object) *_json.UnmarshalTypeError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.UnmarshalTypeError:
// 			return &_g
// 		case *_json.UnmarshalTypeError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnmarshalTypeError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnmarshalTypeError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.UnmarshalTypeError] or: Map or Vector"))
// }

GO TYPE encoding/json.Unmarshaler from encoding/json/decode.go:
func ExtractGoObjectUnmarshaler(args []Object, index int) *_json.Unmarshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.Unmarshaler:
			return &r
		case *_json.Unmarshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.Unmarshaler]"))
}

// func _ConstructUnmarshaler(_v Object) _json.Unmarshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.Unmarshaler:
// 			return _g
// 		case *_json.Unmarshaler:
// 			return *_g
// 		}
// 	default:
// 		return _json.Unmarshaler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Unmarshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.Unmarshaler] or: whatever"))
// }

GO TYPE encoding/json.UnsupportedTypeError from encoding/json/encode.go:
func ExtractGoObjectUnsupportedTypeError(args []Object, index int) *_json.UnsupportedTypeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.UnsupportedTypeError:
			return &r
		case *_json.UnsupportedTypeError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.UnsupportedTypeError]"))
}

// func _mapToUnsupportedTypeError(o Map) *_json.UnsupportedTypeError {
// 	return &_json.UnsupportedTypeError{}
// }

// func _vectorToUnsupportedTypeError(o *Vector) *_json.UnsupportedTypeError {
// 	return &_json.UnsupportedTypeError{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructUnsupportedTypeError(_v Object) *_json.UnsupportedTypeError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.UnsupportedTypeError:
// 			return &_g
// 		case *_json.UnsupportedTypeError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnsupportedTypeError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnsupportedTypeError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.UnsupportedTypeError] or: Map or Vector"))
// }

GO TYPE encoding/json.UnsupportedValueError from encoding/json/encode.go:
func ExtractGoObjectUnsupportedValueError(args []Object, index int) *_json.UnsupportedValueError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _json.UnsupportedValueError:
			return &r
		case *_json.UnsupportedValueError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/json.UnsupportedValueError]"))
}

// func _mapToUnsupportedValueError(o Map) *_json.UnsupportedValueError {
// 	return &_json.UnsupportedValueError{}
// }

// func _vectorToUnsupportedValueError(o *Vector) *_json.UnsupportedValueError {
// 	return &_json.UnsupportedValueError{
// 		Value: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Str: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructUnsupportedValueError(_v Object) *_json.UnsupportedValueError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _json.UnsupportedValueError:
// 			return &_g
// 		case *_json.UnsupportedValueError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnsupportedValueError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnsupportedValueError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[json.UnsupportedValueError] or: Map or Vector"))
// }

GO FUNC encoding/json.Compact from encoding/json/indent.go:
// func __compact(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte)  {
// 	_res := _json.Compact(dst, src)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.HTMLEscape from encoding/json/encode.go:
// func __hTMLEscape(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte) Object {
// 	_json.HTMLEscape(dst, src)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/json.Indent from encoding/json/indent.go:
// func __indent(dst *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), src []byte, prefix string, indent string)  {
// 	_res := _json.Indent(dst, src, prefix, indent)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Marshal from encoding/json/encode.go:
// func __marshal(v interface {}) Object {
// 	_res1, _res2 := _json.Marshal(v)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.MarshalIndent from encoding/json/encode.go:
// func __marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _json.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.NewDecoder from encoding/json/stream.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _json.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.NewEncoder from encoding/json/stream.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _json.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/json.Unmarshal from encoding/json/decode.go:
// func __unmarshal(data []byte, v interface {})  {
// 	_res := _json.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/json.Valid from encoding/json/scanner.go:
// func __valid(data []byte)  {
// 	_res := _json.Valid(data)
// 	return MakeBoolean(_res)
// }

GO FUNC encoding/json.__delim_String from encoding/json/stream.go:
func __delim_String(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/json.Delim)String()", args, 0, 0)
	_res := o.O.(_json.Delim).String()
	return MakeString(_res)
}

GO FUNC encoding/json.__number_Float64 from encoding/json/decode.go:
// func __number_Float64(o GoObject, args Object) Object {
// [ABEND007(find these) Error]}

GO FUNC encoding/json.__number_Int64 from encoding/json/decode.go:
func __number_Int64(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/json.Number)Int64()", args, 0, 0)
	_res1, _res2 := o.O.(_json.Number).Int64()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/json.__number_String from encoding/json/decode.go:
func __number_String(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/json.Number)String()", args, 0, 0)
	_res := o.O.(_json.Number).String()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_Decoder_Buffered from encoding/json/stream.go:
func __ptrTo_Decoder_Buffered(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.Decoder)Buffered()", args, 0, 0)
	_res := o.O.(*_json.Decoder).Buffered()
	return MakeGoObject(_res)
}

GO FUNC encoding/json.__ptrTo_Decoder_Decode from encoding/json/stream.go:
// func __ptrTo_Decoder_Decode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/json.__ptrTo_Decoder_DisallowUnknownFields from encoding/json/stream.go:
// func __ptrTo_Decoder_DisallowUnknownFields(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/json.__ptrTo_Decoder_More from encoding/json/stream.go:
func __ptrTo_Decoder_More(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.Decoder)More()", args, 0, 0)
	_res := o.O.(*_json.Decoder).More()
	return MakeBoolean(_res)
}

GO FUNC encoding/json.__ptrTo_Decoder_Token from encoding/json/stream.go:
func __ptrTo_Decoder_Token(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.Decoder)Token()", args, 0, 0)
	_res1, _res2 := o.O.(*_json.Decoder).Token()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/json.__ptrTo_Decoder_UseNumber from encoding/json/stream.go:
// func __ptrTo_Decoder_UseNumber(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/json.__ptrTo_Encoder_Encode from encoding/json/stream.go:
// func __ptrTo_Encoder_Encode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/json.__ptrTo_Encoder_SetEscapeHTML from encoding/json/stream.go:
// func __ptrTo_Encoder_SetEscapeHTML(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/json.__ptrTo_Encoder_SetIndent from encoding/json/stream.go:
// func __ptrTo_Encoder_SetIndent(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/json.__ptrTo_InvalidUTF8Error_Error from encoding/json/encode.go:
func __ptrTo_InvalidUTF8Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.InvalidUTF8Error)Error()", args, 0, 0)
	_res := o.O.(*_json.InvalidUTF8Error).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_InvalidUnmarshalError_Error from encoding/json/decode.go:
func __ptrTo_InvalidUnmarshalError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.InvalidUnmarshalError)Error()", args, 0, 0)
	_res := o.O.(*_json.InvalidUnmarshalError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_MarshalerError_Error from encoding/json/encode.go:
func __ptrTo_MarshalerError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.MarshalerError)Error()", args, 0, 0)
	_res := o.O.(*_json.MarshalerError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_RawMessage_UnmarshalJSON from encoding/json/stream.go:
// func __ptrTo_RawMessage_UnmarshalJSON(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC encoding/json.__ptrTo_SyntaxError_Error from encoding/json/scanner.go:
func __ptrTo_SyntaxError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.SyntaxError)Error()", args, 0, 0)
	_res := o.O.(*_json.SyntaxError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_UnmarshalFieldError_Error from encoding/json/decode.go:
func __ptrTo_UnmarshalFieldError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.UnmarshalFieldError)Error()", args, 0, 0)
	_res := o.O.(*_json.UnmarshalFieldError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_UnmarshalTypeError_Error from encoding/json/decode.go:
func __ptrTo_UnmarshalTypeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.UnmarshalTypeError)Error()", args, 0, 0)
	_res := o.O.(*_json.UnmarshalTypeError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_UnsupportedTypeError_Error from encoding/json/encode.go:
func __ptrTo_UnsupportedTypeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.UnsupportedTypeError)Error()", args, 0, 0)
	_res := o.O.(*_json.UnsupportedTypeError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__ptrTo_UnsupportedValueError_Error from encoding/json/encode.go:
func __ptrTo_UnsupportedValueError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/json.UnsupportedValueError)Error()", args, 0, 0)
	_res := o.O.(*_json.UnsupportedValueError).Error()
	return MakeString(_res)
}

GO FUNC encoding/json.__rawMessage_MarshalJSON from encoding/json/stream.go:
func __rawMessage_MarshalJSON(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/json.RawMessage)MarshalJSON()", args, 0, 0)
	_res1, _res2 := o.O.(_json.RawMessage).MarshalJSON()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package json

import (
	_json "encoding/json"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Decoder = GoTypeInfo{Members: GoMembers{
	"Buffered": __ptrTo_Decoder_Buffered,
	"More": __ptrTo_Decoder_More,
	"Token": __ptrTo_Decoder_Token,
}}

var members_Delim = GoTypeInfo{Members: GoMembers{
	"String": __delim_String,
}}

var members_PtrTo_InvalidUTF8Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_InvalidUTF8Error_Error,
}}

var members_PtrTo_InvalidUnmarshalError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_InvalidUnmarshalError_Error,
}}

var members_PtrTo_MarshalerError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_MarshalerError_Error,
}}

var members_Number = GoTypeInfo{Members: GoMembers{
	"Int64": __number_Int64,
	"String": __number_String,
}}

var members_RawMessage = GoTypeInfo{Members: GoMembers{
	"MarshalJSON": __rawMessage_MarshalJSON,
}}

var members_PtrTo_SyntaxError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_SyntaxError_Error,
}}

var members_PtrTo_UnmarshalFieldError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnmarshalFieldError_Error,
}}

var members_PtrTo_UnmarshalTypeError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnmarshalTypeError_Error,
}}

var members_PtrTo_UnsupportedTypeError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnsupportedTypeError_Error,
}}

var members_PtrTo_UnsupportedValueError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnsupportedValueError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_json.Decoder)(nil))] = &members_PtrTo_Decoder
	GoTypes[_reflect.TypeOf((*_json.Delim)(nil)).Elem()] = &members_Delim
	GoTypes[_reflect.TypeOf((*_json.InvalidUTF8Error)(nil))] = &members_PtrTo_InvalidUTF8Error
	GoTypes[_reflect.TypeOf((*_json.InvalidUnmarshalError)(nil))] = &members_PtrTo_InvalidUnmarshalError
	GoTypes[_reflect.TypeOf((*_json.MarshalerError)(nil))] = &members_PtrTo_MarshalerError
	GoTypes[_reflect.TypeOf((*_json.Number)(nil)).Elem()] = &members_Number
	GoTypes[_reflect.TypeOf((*_json.RawMessage)(nil)).Elem()] = &members_RawMessage
	GoTypes[_reflect.TypeOf((*_json.SyntaxError)(nil))] = &members_PtrTo_SyntaxError
	GoTypes[_reflect.TypeOf((*_json.UnmarshalFieldError)(nil))] = &members_PtrTo_UnmarshalFieldError
	GoTypes[_reflect.TypeOf((*_json.UnmarshalTypeError)(nil))] = &members_PtrTo_UnmarshalTypeError
	GoTypes[_reflect.TypeOf((*_json.UnsupportedTypeError)(nil))] = &members_PtrTo_UnsupportedTypeError
	GoTypes[_reflect.TypeOf((*_json.UnsupportedValueError)(nil))] = &members_PtrTo_UnsupportedValueError
}

GO TYPE encoding/pem.Block from encoding/pem/pem.go:
func ExtractGoObjectBlock(args []Object, index int) *_pem.Block {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pem.Block:
			return &r
		case *_pem.Block:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/pem.Block]"))
}

// func _mapToBlock(o Map) *_pem.Block {
// 	return &_pem.Block{}
// }

// func _vectorToBlock(o *Vector) *_pem.Block {
// 	return &_pem.Block{
// 		Type: AssertString(o.Nth(0), "").S,
// 		Headers: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Bytes: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructBlock(_v Object) *_pem.Block {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _pem.Block:
// 			return &_g
// 		case *_pem.Block:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBlock(_o.(Map))
// 	case *Vector:
// 		return _vectorToBlock(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[pem.Block] or: Map or Vector"))
// }

GO FUNC encoding/pem.Decode from encoding/pem/pem.go:
// func __decode(data []byte) Object {
// 	p, rest := _pem.Decode(data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(p))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC encoding/pem.Encode from encoding/pem/pem.go:
// func __encode(out ABEND987(genutils.go: imports not yet supported: io.Writer), b *_pem.Block)  {
// 	_res := _pem.Encode(out, b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/pem.EncodeToMemory from encoding/pem/pem.go:
func __encodeToMemory(b *_pem.Block) Object {
	_res := _pem.EncodeToMemory(b)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pem

import (
	_pem "encoding/pem"
	. "github.com/candid82/joker/core"
)

func init() {
}

GO TYPE encoding/xml.Attr from encoding/xml/xml.go:
func ExtractGoObjectAttr(args []Object, index int) *_xml.Attr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Attr:
			return &r
		case *_xml.Attr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Attr]"))
}

// func _mapToAttr(o Map) *_xml.Attr {
// 	return &_xml.Attr{}
// }

// func _vectorToAttr(o *Vector) *_xml.Attr {
// 	return &_xml.Attr{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for encoding/xml.Name (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Value: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructAttr(_v Object) *_xml.Attr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Attr:
// 			return &_g
// 		case *_xml.Attr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAttr(_o.(Map))
// 	case *Vector:
// 		return _vectorToAttr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Attr] or: Map or Vector"))
// }

GO TYPE encoding/xml.CharData from encoding/xml/xml.go:
func ExtractGoObjectCharData(args []Object, index int) *_xml.CharData {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.CharData:
			return &r
		case *_xml.CharData:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.CharData]"))
}

// func _ConstructCharData(_v Object) _xml.CharData {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.CharData:
// 			return _g
// 		case *_xml.CharData:
// 			return *_g
// 		}
// 	default:
// 		return _xml.CharData(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for CharData))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.CharData] or: whatever"))
// }

GO TYPE encoding/xml.Comment from encoding/xml/xml.go:
func ExtractGoObjectComment(args []Object, index int) *_xml.Comment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Comment:
			return &r
		case *_xml.Comment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Comment]"))
}

// func _ConstructComment(_v Object) _xml.Comment {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Comment:
// 			return _g
// 		case *_xml.Comment:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Comment(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Comment))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Comment] or: whatever"))
// }

GO TYPE encoding/xml.Decoder from encoding/xml/xml.go:
func ExtractGoObjectDecoder(args []Object, index int) *_xml.Decoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Decoder:
			return &r
		case *_xml.Decoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Decoder]"))
}

// func _mapToDecoder(o Map) *_xml.Decoder {
// 	return &_xml.Decoder{}
// }

// func _vectorToDecoder(o *Vector) *_xml.Decoder {
// 	return &_xml.Decoder{
// 		Strict: ToBool(o.Nth(0)),
// 		AutoClose: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Entity: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		CharsetReader: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DefaultSpace: AssertString(o.Nth(4), "").S,
// 	}
// }

// func _ConstructDecoder(_v Object) *_xml.Decoder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Decoder:
// 			return &_g
// 		case *_xml.Decoder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDecoder(_o.(Map))
// 	case *Vector:
// 		return _vectorToDecoder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Decoder] or: Map or Vector"))
// }

GO TYPE encoding/xml.Directive from encoding/xml/xml.go:
func ExtractGoObjectDirective(args []Object, index int) *_xml.Directive {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Directive:
			return &r
		case *_xml.Directive:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Directive]"))
}

// func _ConstructDirective(_v Object) _xml.Directive {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Directive:
// 			return _g
// 		case *_xml.Directive:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Directive(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Directive))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Directive] or: whatever"))
// }

GO TYPE encoding/xml.Encoder from encoding/xml/marshal.go:
func ExtractGoObjectEncoder(args []Object, index int) *_xml.Encoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Encoder:
			return &r
		case *_xml.Encoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Encoder]"))
}

func _mapToEncoder(o Map) *_xml.Encoder {
	return &_xml.Encoder{}
}

func _vectorToEncoder(o *Vector) *_xml.Encoder {
	return &_xml.Encoder{}
}

func _ConstructEncoder(_v Object) *_xml.Encoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Encoder:
			return &_g
		case *_xml.Encoder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToEncoder(_o.(Map))
	case *Vector:
		return _vectorToEncoder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Encoder] or: Map or Vector"))
}

GO TYPE encoding/xml.EndElement from encoding/xml/xml.go:
func ExtractGoObjectEndElement(args []Object, index int) *_xml.EndElement {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.EndElement:
			return &r
		case *_xml.EndElement:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.EndElement]"))
}

// func _mapToEndElement(o Map) *_xml.EndElement {
// 	return &_xml.EndElement{}
// }

// func _vectorToEndElement(o *Vector) *_xml.EndElement {
// 	return &_xml.EndElement{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for encoding/xml.Name (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructEndElement(_v Object) *_xml.EndElement {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.EndElement:
// 			return &_g
// 		case *_xml.EndElement:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEndElement(_o.(Map))
// 	case *Vector:
// 		return _vectorToEndElement(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.EndElement] or: Map or Vector"))
// }

GO TYPE encoding/xml.Marshaler from encoding/xml/marshal.go:
func ExtractGoObjectMarshaler(args []Object, index int) *_xml.Marshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Marshaler:
			return &r
		case *_xml.Marshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Marshaler]"))
}

// func _ConstructMarshaler(_v Object) _xml.Marshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Marshaler:
// 			return _g
// 		case *_xml.Marshaler:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Marshaler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Marshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Marshaler] or: whatever"))
// }

GO TYPE encoding/xml.MarshalerAttr from encoding/xml/marshal.go:
func ExtractGoObjectMarshalerAttr(args []Object, index int) *_xml.MarshalerAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.MarshalerAttr:
			return &r
		case *_xml.MarshalerAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.MarshalerAttr]"))
}

// func _ConstructMarshalerAttr(_v Object) _xml.MarshalerAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.MarshalerAttr:
// 			return _g
// 		case *_xml.MarshalerAttr:
// 			return *_g
// 		}
// 	default:
// 		return _xml.MarshalerAttr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for MarshalerAttr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.MarshalerAttr] or: whatever"))
// }

GO TYPE encoding/xml.Name from encoding/xml/xml.go:
func ExtractGoObjectName(args []Object, index int) *_xml.Name {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Name:
			return &r
		case *_xml.Name:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Name]"))
}

func _mapToName(o Map) *_xml.Name {
	return &_xml.Name{}
}

func _vectorToName(o *Vector) *_xml.Name {
	return &_xml.Name{
		Space: AssertString(o.Nth(0), "").S,
		Local: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructName(_v Object) *_xml.Name {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.Name:
			return &_g
		case *_xml.Name:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToName(_o.(Map))
	case *Vector:
		return _vectorToName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Name] or: Map or Vector"))
}

GO TYPE encoding/xml.ProcInst from encoding/xml/xml.go:
func ExtractGoObjectProcInst(args []Object, index int) *_xml.ProcInst {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.ProcInst:
			return &r
		case *_xml.ProcInst:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.ProcInst]"))
}

// func _mapToProcInst(o Map) *_xml.ProcInst {
// 	return &_xml.ProcInst{}
// }

// func _vectorToProcInst(o *Vector) *_xml.ProcInst {
// 	return &_xml.ProcInst{
// 		Target: AssertString(o.Nth(0), "").S,
// 		Inst: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructProcInst(_v Object) *_xml.ProcInst {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.ProcInst:
// 			return &_g
// 		case *_xml.ProcInst:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToProcInst(_o.(Map))
// 	case *Vector:
// 		return _vectorToProcInst(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.ProcInst] or: Map or Vector"))
// }

GO TYPE encoding/xml.StartElement from encoding/xml/xml.go:
func ExtractGoObjectStartElement(args []Object, index int) *_xml.StartElement {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.StartElement:
			return &r
		case *_xml.StartElement:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.StartElement]"))
}

// func _mapToStartElement(o Map) *_xml.StartElement {
// 	return &_xml.StartElement{}
// }

// func _vectorToStartElement(o *Vector) *_xml.StartElement {
// 	return &_xml.StartElement{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for encoding/xml.Name (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Attr: ABEND048(codegen.go: no conversion from Clojure for []encoding/xml.Attr (encoding/xml.Attr)),
// 	}
// }

// func _ConstructStartElement(_v Object) *_xml.StartElement {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.StartElement:
// 			return &_g
// 		case *_xml.StartElement:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStartElement(_o.(Map))
// 	case *Vector:
// 		return _vectorToStartElement(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.StartElement] or: Map or Vector"))
// }

GO TYPE encoding/xml.SyntaxError from encoding/xml/xml.go:
func ExtractGoObjectSyntaxError(args []Object, index int) *_xml.SyntaxError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.SyntaxError:
			return &r
		case *_xml.SyntaxError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.SyntaxError]"))
}

func _mapToSyntaxError(o Map) *_xml.SyntaxError {
	return &_xml.SyntaxError{}
}

func _vectorToSyntaxError(o *Vector) *_xml.SyntaxError {
	return &_xml.SyntaxError{
		Msg: AssertString(o.Nth(0), "").S,
		Line: AssertInt(o.Nth(1), "").I,
	}
}

func _ConstructSyntaxError(_v Object) *_xml.SyntaxError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.SyntaxError:
			return &_g
		case *_xml.SyntaxError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyntaxError(_o.(Map))
	case *Vector:
		return _vectorToSyntaxError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.SyntaxError] or: Map or Vector"))
}

GO TYPE encoding/xml.TagPathError from encoding/xml/typeinfo.go:
func ExtractGoObjectTagPathError(args []Object, index int) *_xml.TagPathError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.TagPathError:
			return &r
		case *_xml.TagPathError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.TagPathError]"))
}

// func _mapToTagPathError(o Map) *_xml.TagPathError {
// 	return &_xml.TagPathError{}
// }

// func _vectorToTagPathError(o *Vector) *_xml.TagPathError {
// 	return &_xml.TagPathError{
// 		Struct: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Field1: AssertString(o.Nth(1), "").S,
// 		Tag1: AssertString(o.Nth(2), "").S,
// 		Field2: AssertString(o.Nth(3), "").S,
// 		Tag2: AssertString(o.Nth(4), "").S,
// 	}
// }

// func _ConstructTagPathError(_v Object) *_xml.TagPathError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.TagPathError:
// 			return &_g
// 		case *_xml.TagPathError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTagPathError(_o.(Map))
// 	case *Vector:
// 		return _vectorToTagPathError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.TagPathError] or: Map or Vector"))
// }

GO TYPE encoding/xml.Token from encoding/xml/xml.go:
func ExtractGoObjectToken(args []Object, index int) *_xml.Token {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Token:
			return &r
		case *_xml.Token:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Token]"))
}

// func _ConstructToken(_v Object) _xml.Token {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Token:
// 			return _g
// 		case *_xml.Token:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Token(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Token))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Token] or: whatever"))
// }

GO TYPE encoding/xml.TokenReader from encoding/xml/xml.go:
func ExtractGoObjectTokenReader(args []Object, index int) *_xml.TokenReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.TokenReader:
			return &r
		case *_xml.TokenReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.TokenReader]"))
}

// func _ConstructTokenReader(_v Object) _xml.TokenReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.TokenReader:
// 			return _g
// 		case *_xml.TokenReader:
// 			return *_g
// 		}
// 	default:
// 		return _xml.TokenReader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for TokenReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.TokenReader] or: whatever"))
// }

GO TYPE encoding/xml.UnmarshalError from encoding/xml/read.go:
func ExtractGoObjectUnmarshalError(args []Object, index int) *_xml.UnmarshalError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnmarshalError:
			return &r
		case *_xml.UnmarshalError:
			return r
		}
	case String:
		v := _xml.UnmarshalError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnmarshalError]"))
}

func _ConstructUnmarshalError(_v Object) _xml.UnmarshalError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _xml.UnmarshalError:
			return _g
		case *_xml.UnmarshalError:
			return *_g
		}
	case String:
		return _xml.UnmarshalError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnmarshalError] or: String"))
}

GO TYPE encoding/xml.Unmarshaler from encoding/xml/read.go:
func ExtractGoObjectUnmarshaler(args []Object, index int) *_xml.Unmarshaler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.Unmarshaler:
			return &r
		case *_xml.Unmarshaler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.Unmarshaler]"))
}

// func _ConstructUnmarshaler(_v Object) _xml.Unmarshaler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.Unmarshaler:
// 			return _g
// 		case *_xml.Unmarshaler:
// 			return *_g
// 		}
// 	default:
// 		return _xml.Unmarshaler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Unmarshaler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.Unmarshaler] or: whatever"))
// }

GO TYPE encoding/xml.UnmarshalerAttr from encoding/xml/read.go:
func ExtractGoObjectUnmarshalerAttr(args []Object, index int) *_xml.UnmarshalerAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnmarshalerAttr:
			return &r
		case *_xml.UnmarshalerAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnmarshalerAttr]"))
}

// func _ConstructUnmarshalerAttr(_v Object) _xml.UnmarshalerAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.UnmarshalerAttr:
// 			return _g
// 		case *_xml.UnmarshalerAttr:
// 			return *_g
// 		}
// 	default:
// 		return _xml.UnmarshalerAttr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for UnmarshalerAttr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnmarshalerAttr] or: whatever"))
// }

GO TYPE encoding/xml.UnsupportedTypeError from encoding/xml/marshal.go:
func ExtractGoObjectUnsupportedTypeError(args []Object, index int) *_xml.UnsupportedTypeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _xml.UnsupportedTypeError:
			return &r
		case *_xml.UnsupportedTypeError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[encoding/xml.UnsupportedTypeError]"))
}

// func _mapToUnsupportedTypeError(o Map) *_xml.UnsupportedTypeError {
// 	return &_xml.UnsupportedTypeError{}
// }

// func _vectorToUnsupportedTypeError(o *Vector) *_xml.UnsupportedTypeError {
// 	return &_xml.UnsupportedTypeError{
// 		Type: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructUnsupportedTypeError(_v Object) *_xml.UnsupportedTypeError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _xml.UnsupportedTypeError:
// 			return &_g
// 		case *_xml.UnsupportedTypeError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnsupportedTypeError(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnsupportedTypeError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[xml.UnsupportedTypeError] or: Map or Vector"))
// }

GO FUNC encoding/xml.CopyToken from encoding/xml/xml.go:
func __copyToken(t _xml.Token) Object {
	_res := _xml.CopyToken(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Escape from encoding/xml/xml.go:
// func __escape(w ABEND987(genutils.go: imports not yet supported: io.Writer), s []byte) Object {
// 	_xml.Escape(w, s)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/xml.EscapeText from encoding/xml/xml.go:
// func __escapeText(w ABEND987(genutils.go: imports not yet supported: io.Writer), s []byte)  {
// 	_res := _xml.EscapeText(w, s)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/xml.Marshal from encoding/xml/marshal.go:
// func __marshal(v interface {}) Object {
// 	_res1, _res2 := _xml.Marshal(v)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.MarshalIndent from encoding/xml/marshal.go:
// func __marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _xml.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.NewDecoder from encoding/xml/xml.go:
// func __newDecoder(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _xml.NewDecoder(r)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewEncoder from encoding/xml/marshal.go:
// func __newEncoder(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _xml.NewEncoder(w)
// 	return MakeGoObject(_res)
// }

GO FUNC encoding/xml.NewTokenDecoder from encoding/xml/xml.go:
func __newTokenDecoder(t _xml.TokenReader) Object {
	_res := _xml.NewTokenDecoder(t)
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.Unmarshal from encoding/xml/read.go:
// func __unmarshal(data []byte, v interface {})  {
// 	_res := _xml.Unmarshal(data, v)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC encoding/xml.__charData_Copy from encoding/xml/xml.go:
func __charData_Copy(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.CharData)Copy()", args, 0, 0)
	_res := o.O.(_xml.CharData).Copy()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__comment_Copy from encoding/xml/xml.go:
func __comment_Copy(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.Comment)Copy()", args, 0, 0)
	_res := o.O.(_xml.Comment).Copy()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__directive_Copy from encoding/xml/xml.go:
func __directive_Copy(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.Directive)Copy()", args, 0, 0)
	_res := o.O.(_xml.Directive).Copy()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__procInst_Copy from encoding/xml/xml.go:
func __procInst_Copy(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.ProcInst)Copy()", args, 0, 0)
	_res := o.O.(_xml.ProcInst).Copy()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__ptrTo_Decoder_Decode from encoding/xml/read.go:
// func __ptrTo_Decoder_Decode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/xml.__ptrTo_Decoder_DecodeElement from encoding/xml/read.go:
// func __ptrTo_Decoder_DecodeElement(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), start)}

GO FUNC encoding/xml.__ptrTo_Decoder_InputOffset from encoding/xml/xml.go:
func __ptrTo_Decoder_InputOffset(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.Decoder)InputOffset()", args, 0, 0)
	_res := o.O.(*_xml.Decoder).InputOffset()
	return MakeBigInt(_res)
}

GO FUNC encoding/xml.__ptrTo_Decoder_RawToken from encoding/xml/xml.go:
func __ptrTo_Decoder_RawToken(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.Decoder)RawToken()", args, 0, 0)
	_res1, _res2 := o.O.(*_xml.Decoder).RawToken()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/xml.__ptrTo_Decoder_Skip from encoding/xml/read.go:
func __ptrTo_Decoder_Skip(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.Decoder)Skip()", args, 0, 0)
	_res := o.O.(*_xml.Decoder).Skip()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC encoding/xml.__ptrTo_Decoder_Token from encoding/xml/xml.go:
func __ptrTo_Decoder_Token(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.Decoder)Token()", args, 0, 0)
	_res1, _res2 := o.O.(*_xml.Decoder).Token()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/xml.__ptrTo_Encoder_Encode from encoding/xml/marshal.go:
// func __ptrTo_Encoder_Encode(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC encoding/xml.__ptrTo_Encoder_EncodeElement from encoding/xml/marshal.go:
// func __ptrTo_Encoder_EncodeElement(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), *start)}

GO FUNC encoding/xml.__ptrTo_Encoder_EncodeToken from encoding/xml/marshal.go:
func __ptrTo_Encoder_EncodeToken(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_encoding/xml.Encoder)EncodeToken()", args, 1, 1)
	t := ExtractGo_go_std_encoding_xml__Token("(*_encoding/xml.Encoder)EncodeToken()", "t", _argList, 0)
	_res := o.O.(*_xml.Encoder).EncodeToken(t)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC encoding/xml.__ptrTo_Encoder_Flush from encoding/xml/marshal.go:
func __ptrTo_Encoder_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.Encoder)Flush()", args, 0, 0)
	_res := o.O.(*_xml.Encoder).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC encoding/xml.__ptrTo_Encoder_Indent from encoding/xml/marshal.go:
// func __ptrTo_Encoder_Indent(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC encoding/xml.__ptrTo_SyntaxError_Error from encoding/xml/xml.go:
func __ptrTo_SyntaxError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.SyntaxError)Error()", args, 0, 0)
	_res := o.O.(*_xml.SyntaxError).Error()
	return MakeString(_res)
}

GO FUNC encoding/xml.__ptrTo_TagPathError_Error from encoding/xml/typeinfo.go:
func __ptrTo_TagPathError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.TagPathError)Error()", args, 0, 0)
	_res := o.O.(*_xml.TagPathError).Error()
	return MakeString(_res)
}

GO FUNC encoding/xml.__ptrTo_UnsupportedTypeError_Error from encoding/xml/marshal.go:
func __ptrTo_UnsupportedTypeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_encoding/xml.UnsupportedTypeError)Error()", args, 0, 0)
	_res := o.O.(*_xml.UnsupportedTypeError).Error()
	return MakeString(_res)
}

GO FUNC encoding/xml.__startElement_Copy from encoding/xml/xml.go:
func __startElement_Copy(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.StartElement)Copy()", args, 0, 0)
	_res := o.O.(_xml.StartElement).Copy()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__startElement_End from encoding/xml/xml.go:
func __startElement_End(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.StartElement)End()", args, 0, 0)
	_res := o.O.(_xml.StartElement).End()
	return MakeGoObject(_res)
}

GO FUNC encoding/xml.__unmarshalError_Error from encoding/xml/read.go:
func __unmarshalError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_encoding/xml.UnmarshalError)Error()", args, 0, 0)
	_res := o.O.(_xml.UnmarshalError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package xml

import (
	_xml "encoding/xml"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_CharData = GoTypeInfo{Members: GoMembers{
	"Copy": __charData_Copy,
}}

var members_Comment = GoTypeInfo{Members: GoMembers{
	"Copy": __comment_Copy,
}}

var members_PtrTo_Decoder = GoTypeInfo{Members: GoMembers{
	"InputOffset": __ptrTo_Decoder_InputOffset,
	"RawToken": __ptrTo_Decoder_RawToken,
	"Skip": __ptrTo_Decoder_Skip,
	"Token": __ptrTo_Decoder_Token,
}}

var members_Directive = GoTypeInfo{Members: GoMembers{
	"Copy": __directive_Copy,
}}

var members_PtrTo_Encoder = GoTypeInfo{Members: GoMembers{
	"EncodeToken": __ptrTo_Encoder_EncodeToken,
	"Flush": __ptrTo_Encoder_Flush,
}}

var members_ProcInst = GoTypeInfo{Members: GoMembers{
	"Copy": __procInst_Copy,
}}

var members_StartElement = GoTypeInfo{Members: GoMembers{
	"Copy": __startElement_Copy,
	"End": __startElement_End,
}}

var members_PtrTo_SyntaxError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_SyntaxError_Error,
}}

var members_PtrTo_TagPathError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_TagPathError_Error,
}}

var members_UnmarshalError = GoTypeInfo{Members: GoMembers{
	"Error": __unmarshalError_Error,
}}

var members_PtrTo_UnsupportedTypeError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_UnsupportedTypeError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_xml.CharData)(nil)).Elem()] = &members_CharData
	GoTypes[_reflect.TypeOf((*_xml.Comment)(nil)).Elem()] = &members_Comment
	GoTypes[_reflect.TypeOf((*_xml.Decoder)(nil))] = &members_PtrTo_Decoder
	GoTypes[_reflect.TypeOf((*_xml.Directive)(nil)).Elem()] = &members_Directive
	GoTypes[_reflect.TypeOf((*_xml.Encoder)(nil))] = &members_PtrTo_Encoder
	GoTypes[_reflect.TypeOf((*_xml.ProcInst)(nil)).Elem()] = &members_ProcInst
	GoTypes[_reflect.TypeOf((*_xml.StartElement)(nil)).Elem()] = &members_StartElement
	GoTypes[_reflect.TypeOf((*_xml.SyntaxError)(nil))] = &members_PtrTo_SyntaxError
	GoTypes[_reflect.TypeOf((*_xml.TagPathError)(nil))] = &members_PtrTo_TagPathError
	GoTypes[_reflect.TypeOf((*_xml.UnmarshalError)(nil)).Elem()] = &members_UnmarshalError
	GoTypes[_reflect.TypeOf((*_xml.UnsupportedTypeError)(nil))] = &members_PtrTo_UnsupportedTypeError
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package errors

import (
)

func init() {
}

GO TYPE expvar.Float from expvar/expvar.go:
func ExtractGoObjectFloat(args []Object, index int) *_expvar.Float {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Float:
			return &r
		case *_expvar.Float:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Float]"))
}

func _mapToFloat(o Map) *_expvar.Float {
	return &_expvar.Float{}
}

func _vectorToFloat(o *Vector) *_expvar.Float {
	return &_expvar.Float{}
}

func _ConstructFloat(_v Object) *_expvar.Float {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Float:
			return &_g
		case *_expvar.Float:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFloat(_o.(Map))
	case *Vector:
		return _vectorToFloat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Float] or: Map or Vector"))
}

GO TYPE expvar.Func from expvar/expvar.go:
func ExtractGoObjectFunc(args []Object, index int) *_expvar.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Func:
			return &r
		case *_expvar.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Func]"))
}

// func _ConstructFunc(_v Object) _expvar.Func {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _expvar.Func:
// 			return _g
// 		case *_expvar.Func:
// 			return *_g
// 		}
// 	default:
// 		return _expvar.Func(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Func))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Func] or: whatever"))
// }

GO TYPE expvar.Int from expvar/expvar.go:
func ExtractGoObjectInt(args []Object, index int) *_expvar.Int {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Int:
			return &r
		case *_expvar.Int:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Int]"))
}

func _mapToInt(o Map) *_expvar.Int {
	return &_expvar.Int{}
}

func _vectorToInt(o *Vector) *_expvar.Int {
	return &_expvar.Int{}
}

func _ConstructInt(_v Object) *_expvar.Int {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Int:
			return &_g
		case *_expvar.Int:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInt(_o.(Map))
	case *Vector:
		return _vectorToInt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Int] or: Map or Vector"))
}

GO TYPE expvar.KeyValue from expvar/expvar.go:
func ExtractGoObjectKeyValue(args []Object, index int) *_expvar.KeyValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.KeyValue:
			return &r
		case *_expvar.KeyValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.KeyValue]"))
}

// func _mapToKeyValue(o Map) *_expvar.KeyValue {
// 	return &_expvar.KeyValue{}
// }

// func _vectorToKeyValue(o *Vector) *_expvar.KeyValue {
// 	return &_expvar.KeyValue{
// 		Key: AssertString(o.Nth(0), "").S,
// 		Value: ABEND048(codegen.go: no conversion from Clojure for expvar.Var (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructKeyValue(_v Object) *_expvar.KeyValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _expvar.KeyValue:
// 			return &_g
// 		case *_expvar.KeyValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToKeyValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToKeyValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.KeyValue] or: Map or Vector"))
// }

GO TYPE expvar.Map from expvar/expvar.go:
func ExtractGoObjectMap(args []Object, index int) *_expvar.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Map:
			return &r
		case *_expvar.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Map]"))
}

func _mapToMap(o Map) *_expvar.Map {
	return &_expvar.Map{}
}

func _vectorToMap(o *Vector) *_expvar.Map {
	return &_expvar.Map{}
}

func _ConstructMap(_v Object) *_expvar.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.Map:
			return &_g
		case *_expvar.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Map] or: Map or Vector"))
}

GO TYPE expvar.String from expvar/expvar.go:
func ExtractGoObjectString(args []Object, index int) *_expvar.String {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.String:
			return &r
		case *_expvar.String:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.String]"))
}

func _mapToString(o Map) *_expvar.String {
	return &_expvar.String{}
}

func _vectorToString(o *Vector) *_expvar.String {
	return &_expvar.String{}
}

func _ConstructString(_v Object) *_expvar.String {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _expvar.String:
			return &_g
		case *_expvar.String:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToString(_o.(Map))
	case *Vector:
		return _vectorToString(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.String] or: Map or Vector"))
}

GO TYPE expvar.Var from expvar/expvar.go:
func ExtractGoObjectVar(args []Object, index int) *_expvar.Var {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _expvar.Var:
			return &r
		case *_expvar.Var:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[expvar.Var]"))
}

// func _ConstructVar(_v Object) _expvar.Var {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _expvar.Var:
// 			return _g
// 		case *_expvar.Var:
// 			return *_g
// 		}
// 	default:
// 		return _expvar.Var(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Var))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[expvar.Var] or: whatever"))
// }

GO FUNC expvar.Do from expvar/expvar.go:
// func __do(f func) Object {
// 	_expvar.Do(f)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.Get from expvar/expvar.go:
func __get(name string) Object {
	_res := _expvar.Get(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Handler from expvar/expvar.go:
func __handler() Object {
	_res := _expvar.Handler()
	return MakeGoObject(_res)
}

GO FUNC expvar.NewFloat from expvar/expvar.go:
func __newFloat(name string) Object {
	_res := _expvar.NewFloat(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewInt from expvar/expvar.go:
func __newInt(name string) Object {
	_res := _expvar.NewInt(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewMap from expvar/expvar.go:
func __newMap(name string) Object {
	_res := _expvar.NewMap(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.NewString from expvar/expvar.go:
func __newString(name string) Object {
	_res := _expvar.NewString(name)
	return MakeGoObject(_res)
}

GO FUNC expvar.Publish from expvar/expvar.go:
// func __publish(name string, v _expvar.Var) Object {
// 	_expvar.Publish(name, v)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.__func_String from expvar/expvar.go:
func __func_String(o GoObject, args Object) Object {
	CheckGoArity("(_expvar.Func)String()", args, 0, 0)
	_res := o.O.(_expvar.Func).String()
	return MakeString(_res)
}

GO FUNC expvar.__func_Value from expvar/expvar.go:
// func __func_Value(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/expvar/expvar.go:251:23)}

GO FUNC expvar.__ptrTo_Float_Add from expvar/expvar.go:
// func __ptrTo_Float_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Float_Set from expvar/expvar.go:
// func __ptrTo_Float_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Float_String from expvar/expvar.go:
func __ptrTo_Float_String(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.Float)String()", args, 0, 0)
	_res := o.O.(*_expvar.Float).String()
	return MakeString(_res)
}

GO FUNC expvar.__ptrTo_Float_Value from expvar/expvar.go:
// func __ptrTo_Float_Value(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC expvar.__ptrTo_Int_Add from expvar/expvar.go:
// func __ptrTo_Int_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Int_Set from expvar/expvar.go:
// func __ptrTo_Int_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Int_String from expvar/expvar.go:
func __ptrTo_Int_String(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.Int)String()", args, 0, 0)
	_res := o.O.(*_expvar.Int).String()
	return MakeString(_res)
}

GO FUNC expvar.__ptrTo_Int_Value from expvar/expvar.go:
func __ptrTo_Int_Value(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.Int)Value()", args, 0, 0)
	_res := o.O.(*_expvar.Int).Value()
	return MakeBigInt(_res)
}

GO FUNC expvar.__ptrTo_Map_Add from expvar/expvar.go:
// func __ptrTo_Map_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Map_AddFloat from expvar/expvar.go:
// func __ptrTo_Map_AddFloat(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Map_Delete from expvar/expvar.go:
// func __ptrTo_Map_Delete(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Map_Do from expvar/expvar.go:
// func __ptrTo_Map_Do(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC expvar.__ptrTo_Map_Get from expvar/expvar.go:
func __ptrTo_Map_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_expvar.Map)Get()", args, 1, 1)
	key := ExtractGoString("(*_expvar.Map)Get()", "key", _argList, 0)
	_res := o.O.(*_expvar.Map).Get(key)
	return MakeGoObject(_res)
}

GO FUNC expvar.__ptrTo_Map_Init from expvar/expvar.go:
func __ptrTo_Map_Init(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.Map)Init()", args, 0, 0)
	_res := o.O.(*_expvar.Map).Init()
	return MakeGoObject(_res)
}

GO FUNC expvar.__ptrTo_Map_Set from expvar/expvar.go:
// func __ptrTo_Map_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_Map_String from expvar/expvar.go:
func __ptrTo_Map_String(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.Map)String()", args, 0, 0)
	_res := o.O.(*_expvar.Map).String()
	return MakeString(_res)
}

GO FUNC expvar.__ptrTo_String_Set from expvar/expvar.go:
// func __ptrTo_String_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC expvar.__ptrTo_String_String from expvar/expvar.go:
func __ptrTo_String_String(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.String)String()", args, 0, 0)
	_res := o.O.(*_expvar.String).String()
	return MakeString(_res)
}

GO FUNC expvar.__ptrTo_String_Value from expvar/expvar.go:
func __ptrTo_String_Value(o GoObject, args Object) Object {
	CheckGoArity("(*_expvar.String)Value()", args, 0, 0)
	_res := o.O.(*_expvar.String).Value()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package expvar

import (
	_expvar "expvar"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_Float = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Float_String,
}}

var members_Func = GoTypeInfo{Members: GoMembers{
	"String": __func_String,
}}

var members_PtrTo_Int = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Int_String,
	"Value": __ptrTo_Int_Value,
}}

var members_PtrTo_Map = GoTypeInfo{Members: GoMembers{
	"Get": __ptrTo_Map_Get,
	"Init": __ptrTo_Map_Init,
	"String": __ptrTo_Map_String,
}}

var members_PtrTo_String = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_String_String,
	"Value": __ptrTo_String_Value,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_expvar.Float)(nil))] = &members_PtrTo_Float
	GoTypes[_reflect.TypeOf((*_expvar.Func)(nil)).Elem()] = &members_Func
	GoTypes[_reflect.TypeOf((*_expvar.Int)(nil))] = &members_PtrTo_Int
	GoTypes[_reflect.TypeOf((*_expvar.Map)(nil))] = &members_PtrTo_Map
	GoTypes[_reflect.TypeOf((*_expvar.String)(nil))] = &members_PtrTo_String
}

GO TYPE flag.ErrorHandling from flag/flag.go:
func ExtractGoObjectErrorHandling(args []Object, index int) *_flag.ErrorHandling {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.ErrorHandling:
			return &r
		case *_flag.ErrorHandling:
			return r
		}
	case Int:
		v := _flag.ErrorHandling(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.ErrorHandling]"))
}

func _ConstructErrorHandling(_v Object) _flag.ErrorHandling {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _flag.ErrorHandling:
			return _g
		case *_flag.ErrorHandling:
			return *_g
		}
	case Number:
		return _flag.ErrorHandling(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.ErrorHandling] or: Number"))
}

GO TYPE flag.Flag from flag/flag.go:
func ExtractGoObjectFlag(args []Object, index int) *_flag.Flag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Flag:
			return &r
		case *_flag.Flag:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Flag]"))
}

// func _mapToFlag(o Map) *_flag.Flag {
// 	return &_flag.Flag{}
// }

// func _vectorToFlag(o *Vector) *_flag.Flag {
// 	return &_flag.Flag{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Usage: AssertString(o.Nth(1), "").S,
// 		Value: ABEND048(codegen.go: no conversion from Clojure for flag.Value (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		DefValue: AssertString(o.Nth(3), "").S,
// 	}
// }

// func _ConstructFlag(_v Object) *_flag.Flag {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.Flag:
// 			return &_g
// 		case *_flag.Flag:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFlag(_o.(Map))
// 	case *Vector:
// 		return _vectorToFlag(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Flag] or: Map or Vector"))
// }

GO TYPE flag.FlagSet from flag/flag.go:
func ExtractGoObjectFlagSet(args []Object, index int) *_flag.FlagSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.FlagSet:
			return &r
		case *_flag.FlagSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.FlagSet]"))
}

// func _mapToFlagSet(o Map) *_flag.FlagSet {
// 	return &_flag.FlagSet{}
// }

// func _vectorToFlagSet(o *Vector) *_flag.FlagSet {
// 	return &_flag.FlagSet{
// 		Usage: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructFlagSet(_v Object) *_flag.FlagSet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.FlagSet:
// 			return &_g
// 		case *_flag.FlagSet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFlagSet(_o.(Map))
// 	case *Vector:
// 		return _vectorToFlagSet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.FlagSet] or: Map or Vector"))
// }

GO TYPE flag.Getter from flag/flag.go:
func ExtractGoObjectGetter(args []Object, index int) *_flag.Getter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Getter:
			return &r
		case *_flag.Getter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Getter]"))
}

// func _ConstructGetter(_v Object) _flag.Getter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.Getter:
// 			return _g
// 		case *_flag.Getter:
// 			return *_g
// 		}
// 	default:
// 		return _flag.Getter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Getter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Getter] or: whatever"))
// }

GO TYPE flag.Value from flag/flag.go:
func ExtractGoObjectValue(args []Object, index int) *_flag.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _flag.Value:
			return &r
		case *_flag.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[flag.Value]"))
}

// func _ConstructValue(_v Object) _flag.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _flag.Value:
// 			return _g
// 		case *_flag.Value:
// 			return *_g
// 		}
// 	default:
// 		return _flag.Value(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Value))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[flag.Value] or: whatever"))
// }

GO FUNC flag.Args from flag/flag.go:
func __args() Object {
	_res := _flag.Args()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC flag.Bool from flag/flag.go:
func __bool(name string, value bool, usage string) Object {
	_res := _flag.Bool(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.BoolVar from flag/flag.go:
// func __boolVar(p *bool, name string, value bool, usage string) Object {
// 	_flag.BoolVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Duration from flag/flag.go:
// func __duration(name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string) Object {
// 	_res := _flag.Duration(name, value, usage)
// 	return MakeGoObject(_res)
// }

GO FUNC flag.DurationVar from flag/flag.go:
// func __durationVar(p *ABEND987(genutils.go: imports not yet supported: time.Duration), name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string) Object {
// 	_flag.DurationVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Float64 from flag/flag.go:
func __float64(name string, value float64, usage string) Object {
	_res := _flag.Float64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Float64Var from flag/flag.go:
// func __float64Var(p *float64, name string, value float64, usage string) Object {
// 	_flag.Float64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Int from flag/flag.go:
func __int(name string, value int, usage string) Object {
	_res := _flag.Int(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64 from flag/flag.go:
func __int64(name string, value int64, usage string) Object {
	_res := _flag.Int64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Int64Var from flag/flag.go:
// func __int64Var(p *int64, name string, value int64, usage string) Object {
// 	_flag.Int64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.IntVar from flag/flag.go:
// func __intVar(p *int, name string, value int, usage string) Object {
// 	_flag.IntVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Lookup from flag/flag.go:
func __lookup(name string) Object {
	_res := _flag.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC flag.NewFlagSet from flag/flag.go:
func __newFlagSet(name string, errorHandling _flag.ErrorHandling) Object {
	_res := _flag.NewFlagSet(name, errorHandling)
	return MakeGoObject(_res)
}

GO FUNC flag.Parse from flag/flag.go:
// func __parse() Object {
// 	_flag.Parse()
// 	...ABEND675: TODO...
// }

GO FUNC flag.PrintDefaults from flag/flag.go:
// func __printDefaults() Object {
// 	_flag.PrintDefaults()
// 	...ABEND675: TODO...
// }

GO FUNC flag.String from flag/flag.go:
func __string(name string, value string, usage string) Object {
	_res := _flag.String(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.StringVar from flag/flag.go:
// func __stringVar(p *string, name string, value string, usage string) Object {
// 	_flag.StringVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Uint from flag/flag.go:
func __uint(name string, value uint, usage string) Object {
	_res := _flag.Uint(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Uint64 from flag/flag.go:
func __uint64(name string, value uint64, usage string) Object {
	_res := _flag.Uint64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.Uint64Var from flag/flag.go:
// func __uint64Var(p *uint64, name string, value uint64, usage string) Object {
// 	_flag.Uint64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UintVar from flag/flag.go:
// func __uintVar(p *uint, name string, value uint, usage string) Object {
// 	_flag.UintVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UnquoteUsage from flag/flag.go:
func __unquoteUsage(flag *_flag.Flag) Object {
	name, usage := _flag.UnquoteUsage(flag)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(MakeString(usage))
	return _res
}

GO FUNC flag.Var from flag/flag.go:
// func __var(value _flag.Value, name string, usage string) Object {
// 	_flag.Var(value, name, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Visit from flag/flag.go:
// func __visit(fn func) Object {
// 	_flag.Visit(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.VisitAll from flag/flag.go:
// func __visitAll(fn func) Object {
// 	_flag.VisitAll(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.__ptrTo_FlagSet_Arg from flag/flag.go:
func __ptrTo_FlagSet_Arg(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Arg()", args, 1, 1)
	i := ExtractGoInt("(*_flag.FlagSet)Arg()", "i", _argList, 0)
	_res := o.O.(*_flag.FlagSet).Arg(i)
	return MakeString(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Args from flag/flag.go:
func __ptrTo_FlagSet_Args(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)Args()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).Args()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC flag.__ptrTo_FlagSet_Bool from flag/flag.go:
func __ptrTo_FlagSet_Bool(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Bool()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)Bool()", "name", _argList, 0)
	value := ExtractGoBoolean("(*_flag.FlagSet)Bool()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)Bool()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).Bool(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_BoolVar from flag/flag.go:
// func __ptrTo_FlagSet_BoolVar(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfbool(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_Duration from flag/flag.go:
// func __ptrTo_FlagSet_Duration(o GoObject, args Object) Object {
// name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string}

GO FUNC flag.__ptrTo_FlagSet_DurationVar from flag/flag.go:
// func __ptrTo_FlagSet_DurationVar(o GoObject, args Object) Object {
// p *ABEND987(genutils.go: imports not yet supported: time.Duration), name string, value ABEND987(genutils.go: imports not yet supported: time.Duration), usage string}

GO FUNC flag.__ptrTo_FlagSet_ErrorHandling from flag/flag.go:
func __ptrTo_FlagSet_ErrorHandling(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)ErrorHandling()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).ErrorHandling()
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Float64 from flag/flag.go:
// func __ptrTo_FlagSet_Float64(o GoObject, args Object) Object {
// (atom-of ABEND007(find these))}

GO FUNC flag.__ptrTo_FlagSet_Float64Var from flag/flag.go:
// func __ptrTo_FlagSet_Float64Var(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOffloat64(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_Init from flag/flag.go:
// func __ptrTo_FlagSet_Init(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC flag.__ptrTo_FlagSet_Int from flag/flag.go:
func __ptrTo_FlagSet_Int(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Int()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)Int()", "name", _argList, 0)
	value := ExtractGoInt("(*_flag.FlagSet)Int()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)Int()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).Int(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Int64 from flag/flag.go:
func __ptrTo_FlagSet_Int64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Int64()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)Int64()", "name", _argList, 0)
	value := ExtractGoInt64("(*_flag.FlagSet)Int64()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)Int64()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).Int64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Int64Var from flag/flag.go:
// func __ptrTo_FlagSet_Int64Var(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint64(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_IntVar from flag/flag.go:
// func __ptrTo_FlagSet_IntVar(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfint(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_Lookup from flag/flag.go:
func __ptrTo_FlagSet_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Lookup()", args, 1, 1)
	name := ExtractGoString("(*_flag.FlagSet)Lookup()", "name", _argList, 0)
	_res := o.O.(*_flag.FlagSet).Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_NArg from flag/flag.go:
func __ptrTo_FlagSet_NArg(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)NArg()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).NArg()
	return MakeInt(_res)
}

GO FUNC flag.__ptrTo_FlagSet_NFlag from flag/flag.go:
func __ptrTo_FlagSet_NFlag(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)NFlag()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).NFlag()
	return MakeInt(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Name from flag/flag.go:
func __ptrTo_FlagSet_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)Name()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).Name()
	return MakeString(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Output from flag/flag.go:
func __ptrTo_FlagSet_Output(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)Output()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).Output()
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Parse from flag/flag.go:
// func __ptrTo_FlagSet_Parse(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(arguments)))}

GO FUNC flag.__ptrTo_FlagSet_Parsed from flag/flag.go:
func __ptrTo_FlagSet_Parsed(o GoObject, args Object) Object {
	CheckGoArity("(*_flag.FlagSet)Parsed()", args, 0, 0)
	_res := o.O.(*_flag.FlagSet).Parsed()
	return MakeBoolean(_res)
}

GO FUNC flag.__ptrTo_FlagSet_PrintDefaults from flag/flag.go:
// func __ptrTo_FlagSet_PrintDefaults(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC flag.__ptrTo_FlagSet_Set from flag/flag.go:
func __ptrTo_FlagSet_Set(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Set()", args, 2, 2)
	name := ExtractGoString("(*_flag.FlagSet)Set()", "name", _argList, 0)
	value := ExtractGoString("(*_flag.FlagSet)Set()", "value", _argList, 1)
	_res := o.O.(*_flag.FlagSet).Set(name, value)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC flag.__ptrTo_FlagSet_SetOutput from flag/flag.go:
// func __ptrTo_FlagSet_SetOutput(o GoObject, args Object) Object {
// output ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC flag.__ptrTo_FlagSet_String from flag/flag.go:
func __ptrTo_FlagSet_String(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)String()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)String()", "name", _argList, 0)
	value := ExtractGoString("(*_flag.FlagSet)String()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)String()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).String(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_StringVar from flag/flag.go:
// func __ptrTo_FlagSet_StringVar(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfstring(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_Uint from flag/flag.go:
func __ptrTo_FlagSet_Uint(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Uint()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)Uint()", "name", _argList, 0)
	value := ExtractGoUInt("(*_flag.FlagSet)Uint()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)Uint()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).Uint(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Uint64 from flag/flag.go:
func __ptrTo_FlagSet_Uint64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_flag.FlagSet)Uint64()", args, 3, 3)
	name := ExtractGoString("(*_flag.FlagSet)Uint64()", "name", _argList, 0)
	value := ExtractGoUInt64("(*_flag.FlagSet)Uint64()", "value", _argList, 1)
	usage := ExtractGoString("(*_flag.FlagSet)Uint64()", "usage", _argList, 2)
	_res := o.O.(*_flag.FlagSet).Uint64(name, value, usage)
	return MakeGoObject(_res)
}

GO FUNC flag.__ptrTo_FlagSet_Uint64Var from flag/flag.go:
// func __ptrTo_FlagSet_Uint64Var(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint64(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_UintVar from flag/flag.go:
// func __ptrTo_FlagSet_UintVar(o GoObject, args Object) Object {
// (ABEND903(pre.go: custom-runtime routine not implemented: ConvertToIndirectOfuint(p)), name, value, usage)}

GO FUNC flag.__ptrTo_FlagSet_Var from flag/flag.go:
// func __ptrTo_FlagSet_Var(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC flag.__ptrTo_FlagSet_Visit from flag/flag.go:
// func __ptrTo_FlagSet_Visit(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC flag.__ptrTo_FlagSet_VisitAll from flag/flag.go:
// func __ptrTo_FlagSet_VisitAll(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package flag

import (
	_flag "flag"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_PtrTo_FlagSet = GoTypeInfo{Members: GoMembers{
	"Arg": __ptrTo_FlagSet_Arg,
	"Args": __ptrTo_FlagSet_Args,
	"Bool": __ptrTo_FlagSet_Bool,
	"ErrorHandling": __ptrTo_FlagSet_ErrorHandling,
	"Int": __ptrTo_FlagSet_Int,
	"Int64": __ptrTo_FlagSet_Int64,
	"Lookup": __ptrTo_FlagSet_Lookup,
	"NArg": __ptrTo_FlagSet_NArg,
	"NFlag": __ptrTo_FlagSet_NFlag,
	"Name": __ptrTo_FlagSet_Name,
	"Output": __ptrTo_FlagSet_Output,
	"Parsed": __ptrTo_FlagSet_Parsed,
	"Set": __ptrTo_FlagSet_Set,
	"String": __ptrTo_FlagSet_String,
	"Uint": __ptrTo_FlagSet_Uint,
	"Uint64": __ptrTo_FlagSet_Uint64,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_flag.FlagSet)(nil))] = &members_PtrTo_FlagSet
}

GO FUNC fmt.Errorf from fmt/print.go:
// func __errorf(format string, a ...interface {})  {
// 	_res := _fmt.Errorf(format, a)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC fmt.Fprint from fmt/print.go:
// func __fprint(w ABEND987(genutils.go: imports not yet supported: io.Writer), a ...interface {}) Object {
// 	n, err := _fmt.Fprint(w, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintf from fmt/print.go:
// func __fprintf(w ABEND987(genutils.go: imports not yet supported: io.Writer), format string, a ...interface {}) Object {
// 	n, err := _fmt.Fprintf(w, format, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintln from fmt/print.go:
// func __fprintln(w ABEND987(genutils.go: imports not yet supported: io.Writer), a ...interface {}) Object {
// 	n, err := _fmt.Fprintln(w, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscan from fmt/scan.go:
// func __fscan(r ABEND987(genutils.go: imports not yet supported: io.Reader), a ...interface {}) Object {
// 	n, err := _fmt.Fscan(r, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanf from fmt/scan.go:
// func __fscanf(r ABEND987(genutils.go: imports not yet supported: io.Reader), format string, a ...interface {}) Object {
// 	n, err := _fmt.Fscanf(r, format, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanln from fmt/scan.go:
// func __fscanln(r ABEND987(genutils.go: imports not yet supported: io.Reader), a ...interface {}) Object {
// 	n, err := _fmt.Fscanln(r, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Print from fmt/print.go:
// func __print(a ...interface {}) Object {
// 	n, err := _fmt.Print(a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Printf from fmt/print.go:
// func __printf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Printf(format, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Println from fmt/print.go:
// func __println(a ...interface {}) Object {
// 	n, err := _fmt.Println(a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scan from fmt/scan.go:
// func __scan(a ...interface {}) Object {
// 	n, err := _fmt.Scan(a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanf from fmt/scan.go:
// func __scanf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Scanf(format, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanln from fmt/scan.go:
// func __scanln(a ...interface {}) Object {
// 	n, err := _fmt.Scanln(a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sprint from fmt/print.go:
// func __sprint(a ...interface {})  {
// 	_res := _fmt.Sprint(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintf from fmt/print.go:
// func __sprintf(format string, a ...interface {})  {
// 	_res := _fmt.Sprintf(format, a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sprintln from fmt/print.go:
// func __sprintln(a ...interface {})  {
// 	_res := _fmt.Sprintln(a)
// 	return MakeString(_res)
// }

GO FUNC fmt.Sscan from fmt/scan.go:
// func __sscan(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscan(str, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanf from fmt/scan.go:
// func __sscanf(str string, format string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanf(str, format, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanln from fmt/scan.go:
// func __sscanln(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanln(str, a)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO TYPE go/ast.ArrayType from go/ast/ast.go:
func ExtractGoObjectArrayType(args []Object, index int) *_ast.ArrayType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ArrayType:
			return &r
		case *_ast.ArrayType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ArrayType]"))
}

// func _mapToArrayType(o Map) *_ast.ArrayType {
// 	return &_ast.ArrayType{}
// }

// func _vectorToArrayType(o *Vector) *_ast.ArrayType {
// 	return &_ast.ArrayType{
// 		Lbrack: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Len: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Elt: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructArrayType(_v Object) *_ast.ArrayType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ArrayType:
// 			return &_g
// 		case *_ast.ArrayType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToArrayType(_o.(Map))
// 	case *Vector:
// 		return _vectorToArrayType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ArrayType] or: Map or Vector"))
// }

GO TYPE go/ast.AssignStmt from go/ast/ast.go:
func ExtractGoObjectAssignStmt(args []Object, index int) *_ast.AssignStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.AssignStmt:
			return &r
		case *_ast.AssignStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.AssignStmt]"))
}

// func _mapToAssignStmt(o Map) *_ast.AssignStmt {
// 	return &_ast.AssignStmt{}
// }

// func _vectorToAssignStmt(o *Vector) *_ast.AssignStmt {
// 	return &_ast.AssignStmt{
// 		Lhs: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 		TokPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Tok: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Rhs: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 	}
// }

// func _ConstructAssignStmt(_v Object) *_ast.AssignStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.AssignStmt:
// 			return &_g
// 		case *_ast.AssignStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAssignStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToAssignStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.AssignStmt] or: Map or Vector"))
// }

GO TYPE go/ast.BadDecl from go/ast/ast.go:
func ExtractGoObjectBadDecl(args []Object, index int) *_ast.BadDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadDecl:
			return &r
		case *_ast.BadDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadDecl]"))
}

// func _mapToBadDecl(o Map) *_ast.BadDecl {
// 	return &_ast.BadDecl{}
// }

// func _vectorToBadDecl(o *Vector) *_ast.BadDecl {
// 	return &_ast.BadDecl{
// 		From: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		To: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructBadDecl(_v Object) *_ast.BadDecl {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BadDecl:
// 			return &_g
// 		case *_ast.BadDecl:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBadDecl(_o.(Map))
// 	case *Vector:
// 		return _vectorToBadDecl(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadDecl] or: Map or Vector"))
// }

GO TYPE go/ast.BadExpr from go/ast/ast.go:
func ExtractGoObjectBadExpr(args []Object, index int) *_ast.BadExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadExpr:
			return &r
		case *_ast.BadExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadExpr]"))
}

// func _mapToBadExpr(o Map) *_ast.BadExpr {
// 	return &_ast.BadExpr{}
// }

// func _vectorToBadExpr(o *Vector) *_ast.BadExpr {
// 	return &_ast.BadExpr{
// 		From: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		To: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructBadExpr(_v Object) *_ast.BadExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BadExpr:
// 			return &_g
// 		case *_ast.BadExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBadExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToBadExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadExpr] or: Map or Vector"))
// }

GO TYPE go/ast.BadStmt from go/ast/ast.go:
func ExtractGoObjectBadStmt(args []Object, index int) *_ast.BadStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BadStmt:
			return &r
		case *_ast.BadStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BadStmt]"))
}

// func _mapToBadStmt(o Map) *_ast.BadStmt {
// 	return &_ast.BadStmt{}
// }

// func _vectorToBadStmt(o *Vector) *_ast.BadStmt {
// 	return &_ast.BadStmt{
// 		From: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		To: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructBadStmt(_v Object) *_ast.BadStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BadStmt:
// 			return &_g
// 		case *_ast.BadStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBadStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToBadStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BadStmt] or: Map or Vector"))
// }

GO TYPE go/ast.BasicLit from go/ast/ast.go:
func ExtractGoObjectBasicLit(args []Object, index int) *_ast.BasicLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BasicLit:
			return &r
		case *_ast.BasicLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BasicLit]"))
}

// func _mapToBasicLit(o Map) *_ast.BasicLit {
// 	return &_ast.BasicLit{}
// }

// func _vectorToBasicLit(o *Vector) *_ast.BasicLit {
// 	return &_ast.BasicLit{
// 		ValuePos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Kind: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Value: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructBasicLit(_v Object) *_ast.BasicLit {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BasicLit:
// 			return &_g
// 		case *_ast.BasicLit:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBasicLit(_o.(Map))
// 	case *Vector:
// 		return _vectorToBasicLit(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BasicLit] or: Map or Vector"))
// }

GO TYPE go/ast.BinaryExpr from go/ast/ast.go:
func ExtractGoObjectBinaryExpr(args []Object, index int) *_ast.BinaryExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BinaryExpr:
			return &r
		case *_ast.BinaryExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BinaryExpr]"))
}

// func _mapToBinaryExpr(o Map) *_ast.BinaryExpr {
// 	return &_ast.BinaryExpr{}
// }

// func _vectorToBinaryExpr(o *Vector) *_ast.BinaryExpr {
// 	return &_ast.BinaryExpr{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		OpPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Op: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Y: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructBinaryExpr(_v Object) *_ast.BinaryExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BinaryExpr:
// 			return &_g
// 		case *_ast.BinaryExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBinaryExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToBinaryExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BinaryExpr] or: Map or Vector"))
// }

GO TYPE go/ast.BlockStmt from go/ast/ast.go:
func ExtractGoObjectBlockStmt(args []Object, index int) *_ast.BlockStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BlockStmt:
			return &r
		case *_ast.BlockStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BlockStmt]"))
}

// func _mapToBlockStmt(o Map) *_ast.BlockStmt {
// 	return &_ast.BlockStmt{}
// }

// func _vectorToBlockStmt(o *Vector) *_ast.BlockStmt {
// 	return &_ast.BlockStmt{
// 		Lbrace: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		List: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Stmt (go/ast.Stmt)),
// 		Rbrace: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructBlockStmt(_v Object) *_ast.BlockStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BlockStmt:
// 			return &_g
// 		case *_ast.BlockStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBlockStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToBlockStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BlockStmt] or: Map or Vector"))
// }

GO TYPE go/ast.BranchStmt from go/ast/ast.go:
func ExtractGoObjectBranchStmt(args []Object, index int) *_ast.BranchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.BranchStmt:
			return &r
		case *_ast.BranchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.BranchStmt]"))
}

// func _mapToBranchStmt(o Map) *_ast.BranchStmt {
// 	return &_ast.BranchStmt{}
// }

// func _vectorToBranchStmt(o *Vector) *_ast.BranchStmt {
// 	return &_ast.BranchStmt{
// 		TokPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Tok: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Label: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 	}
// }

// func _ConstructBranchStmt(_v Object) *_ast.BranchStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.BranchStmt:
// 			return &_g
// 		case *_ast.BranchStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBranchStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToBranchStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.BranchStmt] or: Map or Vector"))
// }

GO TYPE go/ast.CallExpr from go/ast/ast.go:
func ExtractGoObjectCallExpr(args []Object, index int) *_ast.CallExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CallExpr:
			return &r
		case *_ast.CallExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CallExpr]"))
}

// func _mapToCallExpr(o Map) *_ast.CallExpr {
// 	return &_ast.CallExpr{}
// }

// func _vectorToCallExpr(o *Vector) *_ast.CallExpr {
// 	return &_ast.CallExpr{
// 		Fun: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Lparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 		Ellipsis: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Rparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCallExpr(_v Object) *_ast.CallExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CallExpr:
// 			return &_g
// 		case *_ast.CallExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCallExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToCallExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CallExpr] or: Map or Vector"))
// }

GO TYPE go/ast.CaseClause from go/ast/ast.go:
func ExtractGoObjectCaseClause(args []Object, index int) *_ast.CaseClause {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CaseClause:
			return &r
		case *_ast.CaseClause:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CaseClause]"))
}

// func _mapToCaseClause(o Map) *_ast.CaseClause {
// 	return &_ast.CaseClause{}
// }

// func _vectorToCaseClause(o *Vector) *_ast.CaseClause {
// 	return &_ast.CaseClause{
// 		Case: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		List: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 		Colon: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Stmt (go/ast.Stmt)),
// 	}
// }

// func _ConstructCaseClause(_v Object) *_ast.CaseClause {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CaseClause:
// 			return &_g
// 		case *_ast.CaseClause:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCaseClause(_o.(Map))
// 	case *Vector:
// 		return _vectorToCaseClause(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CaseClause] or: Map or Vector"))
// }

GO TYPE go/ast.ChanDir from go/ast/ast.go:
func ExtractGoObjectChanDir(args []Object, index int) *_ast.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ChanDir:
			return &r
		case *_ast.ChanDir:
			return r
		}
	case Int:
		v := _ast.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ChanDir]"))
}

func _ConstructChanDir(_v Object) _ast.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ChanDir:
			return _g
		case *_ast.ChanDir:
			return *_g
		}
	case Number:
		return _ast.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ChanDir] or: Number"))
}

GO TYPE go/ast.ChanType from go/ast/ast.go:
func ExtractGoObjectChanType(args []Object, index int) *_ast.ChanType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ChanType:
			return &r
		case *_ast.ChanType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ChanType]"))
}

// func _mapToChanType(o Map) *_ast.ChanType {
// 	return &_ast.ChanType{}
// }

// func _vectorToChanType(o *Vector) *_ast.ChanType {
// 	return &_ast.ChanType{
// 		Begin: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Arrow: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Dir: _ast.ChanDir(AssertInt(o.Nth(2), "").I),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructChanType(_v Object) *_ast.ChanType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ChanType:
// 			return &_g
// 		case *_ast.ChanType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToChanType(_o.(Map))
// 	case *Vector:
// 		return _vectorToChanType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ChanType] or: Map or Vector"))
// }

GO TYPE go/ast.CommClause from go/ast/ast.go:
func ExtractGoObjectCommClause(args []Object, index int) *_ast.CommClause {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommClause:
			return &r
		case *_ast.CommClause:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommClause]"))
}

// func _mapToCommClause(o Map) *_ast.CommClause {
// 	return &_ast.CommClause{}
// }

// func _vectorToCommClause(o *Vector) *_ast.CommClause {
// 	return &_ast.CommClause{
// 		Case: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Comm: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Colon: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Stmt (go/ast.Stmt)),
// 	}
// }

// func _ConstructCommClause(_v Object) *_ast.CommClause {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CommClause:
// 			return &_g
// 		case *_ast.CommClause:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCommClause(_o.(Map))
// 	case *Vector:
// 		return _vectorToCommClause(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommClause] or: Map or Vector"))
// }

GO TYPE go/ast.Comment from go/ast/ast.go:
func ExtractGoObjectComment(args []Object, index int) *_ast.Comment {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Comment:
			return &r
		case *_ast.Comment:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Comment]"))
}

// func _mapToComment(o Map) *_ast.Comment {
// 	return &_ast.Comment{}
// }

// func _vectorToComment(o *Vector) *_ast.Comment {
// 	return &_ast.Comment{
// 		Slash: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Text: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructComment(_v Object) *_ast.Comment {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Comment:
// 			return &_g
// 		case *_ast.Comment:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToComment(_o.(Map))
// 	case *Vector:
// 		return _vectorToComment(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Comment] or: Map or Vector"))
// }

GO TYPE go/ast.CommentGroup from go/ast/ast.go:
func ExtractGoObjectCommentGroup(args []Object, index int) *_ast.CommentGroup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommentGroup:
			return &r
		case *_ast.CommentGroup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommentGroup]"))
}

// func _mapToCommentGroup(o Map) *_ast.CommentGroup {
// 	return &_ast.CommentGroup{}
// }

// func _vectorToCommentGroup(o *Vector) *_ast.CommentGroup {
// 	return &_ast.CommentGroup{
// 		List: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.Comment (*go/ast.Comment)),
// 	}
// }

// func _ConstructCommentGroup(_v Object) *_ast.CommentGroup {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CommentGroup:
// 			return &_g
// 		case *_ast.CommentGroup:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCommentGroup(_o.(Map))
// 	case *Vector:
// 		return _vectorToCommentGroup(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommentGroup] or: Map or Vector"))
// }

GO TYPE go/ast.CommentMap from go/ast/commentmap.go:
func ExtractGoObjectCommentMap(args []Object, index int) *_ast.CommentMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CommentMap:
			return &r
		case *_ast.CommentMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CommentMap]"))
}

// func _ConstructCommentMap(_v Object) _ast.CommentMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CommentMap:
// 			return _g
// 		case *_ast.CommentMap:
// 			return *_g
// 		}
// 	default:
// 		return _ast.CommentMap(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for CommentMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CommentMap] or: whatever"))
// }

GO TYPE go/ast.CompositeLit from go/ast/ast.go:
func ExtractGoObjectCompositeLit(args []Object, index int) *_ast.CompositeLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.CompositeLit:
			return &r
		case *_ast.CompositeLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.CompositeLit]"))
}

// func _mapToCompositeLit(o Map) *_ast.CompositeLit {
// 	return &_ast.CompositeLit{}
// }

// func _vectorToCompositeLit(o *Vector) *_ast.CompositeLit {
// 	return &_ast.CompositeLit{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Lbrace: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Elts: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 		Rbrace: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Incomplete: ToBool(o.Nth(4)),
// 	}
// }

// func _ConstructCompositeLit(_v Object) *_ast.CompositeLit {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.CompositeLit:
// 			return &_g
// 		case *_ast.CompositeLit:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCompositeLit(_o.(Map))
// 	case *Vector:
// 		return _vectorToCompositeLit(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.CompositeLit] or: Map or Vector"))
// }

GO TYPE go/ast.Decl from go/ast/ast.go:
func ExtractGoObjectDecl(args []Object, index int) *_ast.Decl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Decl:
			return &r
		case *_ast.Decl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Decl]"))
}

// func _ConstructDecl(_v Object) _ast.Decl {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Decl:
// 			return _g
// 		case *_ast.Decl:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Decl(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Decl))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Decl] or: whatever"))
// }

GO TYPE go/ast.DeclStmt from go/ast/ast.go:
func ExtractGoObjectDeclStmt(args []Object, index int) *_ast.DeclStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.DeclStmt:
			return &r
		case *_ast.DeclStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.DeclStmt]"))
}

// func _mapToDeclStmt(o Map) *_ast.DeclStmt {
// 	return &_ast.DeclStmt{}
// }

// func _vectorToDeclStmt(o *Vector) *_ast.DeclStmt {
// 	return &_ast.DeclStmt{
// 		Decl: ABEND048(codegen.go: no conversion from Clojure for go/ast.Decl (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructDeclStmt(_v Object) *_ast.DeclStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.DeclStmt:
// 			return &_g
// 		case *_ast.DeclStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDeclStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToDeclStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.DeclStmt] or: Map or Vector"))
// }

GO TYPE go/ast.DeferStmt from go/ast/ast.go:
func ExtractGoObjectDeferStmt(args []Object, index int) *_ast.DeferStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.DeferStmt:
			return &r
		case *_ast.DeferStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.DeferStmt]"))
}

// func _mapToDeferStmt(o Map) *_ast.DeferStmt {
// 	return &_ast.DeferStmt{}
// }

// func _vectorToDeferStmt(o *Vector) *_ast.DeferStmt {
// 	return &_ast.DeferStmt{
// 		Defer: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Call: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CallExpr (go/ast.CallExpr)),
// 	}
// }

// func _ConstructDeferStmt(_v Object) *_ast.DeferStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.DeferStmt:
// 			return &_g
// 		case *_ast.DeferStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDeferStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToDeferStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.DeferStmt] or: Map or Vector"))
// }

GO TYPE go/ast.Ellipsis from go/ast/ast.go:
func ExtractGoObjectEllipsis(args []Object, index int) *_ast.Ellipsis {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Ellipsis:
			return &r
		case *_ast.Ellipsis:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Ellipsis]"))
}

// func _mapToEllipsis(o Map) *_ast.Ellipsis {
// 	return &_ast.Ellipsis{}
// }

// func _vectorToEllipsis(o *Vector) *_ast.Ellipsis {
// 	return &_ast.Ellipsis{
// 		Ellipsis: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Elt: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructEllipsis(_v Object) *_ast.Ellipsis {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Ellipsis:
// 			return &_g
// 		case *_ast.Ellipsis:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEllipsis(_o.(Map))
// 	case *Vector:
// 		return _vectorToEllipsis(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Ellipsis] or: Map or Vector"))
// }

GO TYPE go/ast.EmptyStmt from go/ast/ast.go:
func ExtractGoObjectEmptyStmt(args []Object, index int) *_ast.EmptyStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.EmptyStmt:
			return &r
		case *_ast.EmptyStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.EmptyStmt]"))
}

// func _mapToEmptyStmt(o Map) *_ast.EmptyStmt {
// 	return &_ast.EmptyStmt{}
// }

// func _vectorToEmptyStmt(o *Vector) *_ast.EmptyStmt {
// 	return &_ast.EmptyStmt{
// 		Semicolon: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Implicit: ToBool(o.Nth(1)),
// 	}
// }

// func _ConstructEmptyStmt(_v Object) *_ast.EmptyStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.EmptyStmt:
// 			return &_g
// 		case *_ast.EmptyStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEmptyStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToEmptyStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.EmptyStmt] or: Map or Vector"))
// }

GO TYPE go/ast.Expr from go/ast/ast.go:
func ExtractGoObjectExpr(args []Object, index int) *_ast.Expr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Expr:
			return &r
		case *_ast.Expr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Expr]"))
}

// func _ConstructExpr(_v Object) _ast.Expr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Expr:
// 			return _g
// 		case *_ast.Expr:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Expr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Expr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Expr] or: whatever"))
// }

GO TYPE go/ast.ExprStmt from go/ast/ast.go:
func ExtractGoObjectExprStmt(args []Object, index int) *_ast.ExprStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ExprStmt:
			return &r
		case *_ast.ExprStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ExprStmt]"))
}

// func _mapToExprStmt(o Map) *_ast.ExprStmt {
// 	return &_ast.ExprStmt{}
// }

// func _vectorToExprStmt(o *Vector) *_ast.ExprStmt {
// 	return &_ast.ExprStmt{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructExprStmt(_v Object) *_ast.ExprStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ExprStmt:
// 			return &_g
// 		case *_ast.ExprStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToExprStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToExprStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ExprStmt] or: Map or Vector"))
// }

GO TYPE go/ast.Field from go/ast/ast.go:
func ExtractGoObjectField(args []Object, index int) *_ast.Field {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Field:
			return &r
		case *_ast.Field:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Field]"))
}

// func _mapToField(o Map) *_ast.Field {
// 	return &_ast.Field{}
// }

// func _vectorToField(o *Vector) *_ast.Field {
// 	return &_ast.Field{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Names: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.Ident (*go/ast.Ident)),
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Tag: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BasicLit (go/ast.BasicLit)),
// 		Comment: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 	}
// }

// func _ConstructField(_v Object) *_ast.Field {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Field:
// 			return &_g
// 		case *_ast.Field:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToField(_o.(Map))
// 	case *Vector:
// 		return _vectorToField(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Field] or: Map or Vector"))
// }

GO TYPE go/ast.FieldFilter from go/ast/print.go:
func ExtractGoObjectFieldFilter(args []Object, index int) *_ast.FieldFilter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FieldFilter:
			return &r
		case *_ast.FieldFilter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FieldFilter]"))
}

// func _ConstructFieldFilter(_v Object) _ast.FieldFilter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FieldFilter:
// 			return _g
// 		case *_ast.FieldFilter:
// 			return *_g
// 		}
// 	default:
// 		return _ast.FieldFilter(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for FieldFilter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FieldFilter] or: whatever"))
// }

GO TYPE go/ast.FieldList from go/ast/ast.go:
func ExtractGoObjectFieldList(args []Object, index int) *_ast.FieldList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FieldList:
			return &r
		case *_ast.FieldList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FieldList]"))
}

// func _mapToFieldList(o Map) *_ast.FieldList {
// 	return &_ast.FieldList{}
// }

// func _vectorToFieldList(o *Vector) *_ast.FieldList {
// 	return &_ast.FieldList{
// 		Opening: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		List: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.Field (*go/ast.Field)),
// 		Closing: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructFieldList(_v Object) *_ast.FieldList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FieldList:
// 			return &_g
// 		case *_ast.FieldList:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFieldList(_o.(Map))
// 	case *Vector:
// 		return _vectorToFieldList(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FieldList] or: Map or Vector"))
// }

GO TYPE go/ast.File from go/ast/ast.go:
func ExtractGoObjectFile(args []Object, index int) *_ast.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.File:
			return &r
		case *_ast.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.File]"))
}

// func _mapToFile(o Map) *_ast.File {
// 	return &_ast.File{}
// }

// func _vectorToFile(o *Vector) *_ast.File {
// 	return &_ast.File{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Package: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 		Decls: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Decl (go/ast.Decl)),
// 		Scope: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Scope (go/ast.Scope)),
// 		Imports: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.ImportSpec (*go/ast.ImportSpec)),
// 		Unresolved: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.Ident (*go/ast.Ident)),
// 		Comments: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.CommentGroup (*go/ast.CommentGroup)),
// 	}
// }

// func _ConstructFile(_v Object) *_ast.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.File:
// 			return &_g
// 		case *_ast.File:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFile(_o.(Map))
// 	case *Vector:
// 		return _vectorToFile(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.File] or: Map or Vector"))
// }

GO TYPE go/ast.Filter from go/ast/filter.go:
func ExtractGoObjectFilter(args []Object, index int) *_ast.Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Filter:
			return &r
		case *_ast.Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Filter]"))
}

// func _ConstructFilter(_v Object) _ast.Filter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Filter:
// 			return _g
// 		case *_ast.Filter:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Filter(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Filter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Filter] or: whatever"))
// }

GO TYPE go/ast.ForStmt from go/ast/ast.go:
func ExtractGoObjectForStmt(args []Object, index int) *_ast.ForStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ForStmt:
			return &r
		case *_ast.ForStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ForStmt]"))
}

// func _mapToForStmt(o Map) *_ast.ForStmt {
// 	return &_ast.ForStmt{}
// }

// func _vectorToForStmt(o *Vector) *_ast.ForStmt {
// 	return &_ast.ForStmt{
// 		For: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Init: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Cond: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Post: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructForStmt(_v Object) *_ast.ForStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ForStmt:
// 			return &_g
// 		case *_ast.ForStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToForStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToForStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ForStmt] or: Map or Vector"))
// }

GO TYPE go/ast.FuncDecl from go/ast/ast.go:
func ExtractGoObjectFuncDecl(args []Object, index int) *_ast.FuncDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncDecl:
			return &r
		case *_ast.FuncDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncDecl]"))
}

// func _mapToFuncDecl(o Map) *_ast.FuncDecl {
// 	return &_ast.FuncDecl{}
// }

// func _vectorToFuncDecl(o *Vector) *_ast.FuncDecl {
// 	return &_ast.FuncDecl{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Recv: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FieldList (go/ast.FieldList)),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 		Type: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FuncType (go/ast.FuncType)),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructFuncDecl(_v Object) *_ast.FuncDecl {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FuncDecl:
// 			return &_g
// 		case *_ast.FuncDecl:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFuncDecl(_o.(Map))
// 	case *Vector:
// 		return _vectorToFuncDecl(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncDecl] or: Map or Vector"))
// }

GO TYPE go/ast.FuncLit from go/ast/ast.go:
func ExtractGoObjectFuncLit(args []Object, index int) *_ast.FuncLit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncLit:
			return &r
		case *_ast.FuncLit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncLit]"))
}

// func _mapToFuncLit(o Map) *_ast.FuncLit {
// 	return &_ast.FuncLit{}
// }

// func _vectorToFuncLit(o *Vector) *_ast.FuncLit {
// 	return &_ast.FuncLit{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FuncType (go/ast.FuncType)),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructFuncLit(_v Object) *_ast.FuncLit {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FuncLit:
// 			return &_g
// 		case *_ast.FuncLit:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFuncLit(_o.(Map))
// 	case *Vector:
// 		return _vectorToFuncLit(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncLit] or: Map or Vector"))
// }

GO TYPE go/ast.FuncType from go/ast/ast.go:
func ExtractGoObjectFuncType(args []Object, index int) *_ast.FuncType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.FuncType:
			return &r
		case *_ast.FuncType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.FuncType]"))
}

// func _mapToFuncType(o Map) *_ast.FuncType {
// 	return &_ast.FuncType{}
// }

// func _vectorToFuncType(o *Vector) *_ast.FuncType {
// 	return &_ast.FuncType{
// 		Func: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Params: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FieldList (go/ast.FieldList)),
// 		Results: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FieldList (go/ast.FieldList)),
// 	}
// }

// func _ConstructFuncType(_v Object) *_ast.FuncType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.FuncType:
// 			return &_g
// 		case *_ast.FuncType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFuncType(_o.(Map))
// 	case *Vector:
// 		return _vectorToFuncType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.FuncType] or: Map or Vector"))
// }

GO TYPE go/ast.GenDecl from go/ast/ast.go:
func ExtractGoObjectGenDecl(args []Object, index int) *_ast.GenDecl {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.GenDecl:
			return &r
		case *_ast.GenDecl:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.GenDecl]"))
}

// func _mapToGenDecl(o Map) *_ast.GenDecl {
// 	return &_ast.GenDecl{}
// }

// func _vectorToGenDecl(o *Vector) *_ast.GenDecl {
// 	return &_ast.GenDecl{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		TokPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Tok: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Lparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Specs: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Spec (go/ast.Spec)),
// 		Rparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructGenDecl(_v Object) *_ast.GenDecl {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.GenDecl:
// 			return &_g
// 		case *_ast.GenDecl:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGenDecl(_o.(Map))
// 	case *Vector:
// 		return _vectorToGenDecl(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.GenDecl] or: Map or Vector"))
// }

GO TYPE go/ast.GoStmt from go/ast/ast.go:
func ExtractGoObjectGoStmt(args []Object, index int) *_ast.GoStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.GoStmt:
			return &r
		case *_ast.GoStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.GoStmt]"))
}

// func _mapToGoStmt(o Map) *_ast.GoStmt {
// 	return &_ast.GoStmt{}
// }

// func _vectorToGoStmt(o *Vector) *_ast.GoStmt {
// 	return &_ast.GoStmt{
// 		Go: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Call: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CallExpr (go/ast.CallExpr)),
// 	}
// }

// func _ConstructGoStmt(_v Object) *_ast.GoStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.GoStmt:
// 			return &_g
// 		case *_ast.GoStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGoStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToGoStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.GoStmt] or: Map or Vector"))
// }

GO TYPE go/ast.Ident from go/ast/ast.go:
func ExtractGoObjectIdent(args []Object, index int) *_ast.Ident {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Ident:
			return &r
		case *_ast.Ident:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Ident]"))
}

// func _mapToIdent(o Map) *_ast.Ident {
// 	return &_ast.Ident{}
// }

// func _vectorToIdent(o *Vector) *_ast.Ident {
// 	return &_ast.Ident{
// 		NamePos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Name: AssertString(o.Nth(1), "").S,
// 		Obj: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Object (go/ast.Object)),
// 	}
// }

// func _ConstructIdent(_v Object) *_ast.Ident {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Ident:
// 			return &_g
// 		case *_ast.Ident:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIdent(_o.(Map))
// 	case *Vector:
// 		return _vectorToIdent(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Ident] or: Map or Vector"))
// }

GO TYPE go/ast.IfStmt from go/ast/ast.go:
func ExtractGoObjectIfStmt(args []Object, index int) *_ast.IfStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IfStmt:
			return &r
		case *_ast.IfStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IfStmt]"))
}

// func _mapToIfStmt(o Map) *_ast.IfStmt {
// 	return &_ast.IfStmt{}
// }

// func _vectorToIfStmt(o *Vector) *_ast.IfStmt {
// 	return &_ast.IfStmt{
// 		If: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Init: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Cond: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 		Else: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructIfStmt(_v Object) *_ast.IfStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.IfStmt:
// 			return &_g
// 		case *_ast.IfStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IfStmt] or: Map or Vector"))
// }

GO TYPE go/ast.ImportSpec from go/ast/ast.go:
func ExtractGoObjectImportSpec(args []Object, index int) *_ast.ImportSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ImportSpec:
			return &r
		case *_ast.ImportSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ImportSpec]"))
}

// func _mapToImportSpec(o Map) *_ast.ImportSpec {
// 	return &_ast.ImportSpec{}
// }

// func _vectorToImportSpec(o *Vector) *_ast.ImportSpec {
// 	return &_ast.ImportSpec{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 		Path: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BasicLit (go/ast.BasicLit)),
// 		Comment: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		EndPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructImportSpec(_v Object) *_ast.ImportSpec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ImportSpec:
// 			return &_g
// 		case *_ast.ImportSpec:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToImportSpec(_o.(Map))
// 	case *Vector:
// 		return _vectorToImportSpec(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ImportSpec] or: Map or Vector"))
// }

GO TYPE go/ast.Importer from go/ast/resolve.go:
func ExtractGoObjectImporter(args []Object, index int) *_ast.Importer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Importer:
			return &r
		case *_ast.Importer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Importer]"))
}

// func _ConstructImporter(_v Object) _ast.Importer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Importer:
// 			return _g
// 		case *_ast.Importer:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Importer(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Importer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Importer] or: whatever"))
// }

GO TYPE go/ast.IncDecStmt from go/ast/ast.go:
func ExtractGoObjectIncDecStmt(args []Object, index int) *_ast.IncDecStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IncDecStmt:
			return &r
		case *_ast.IncDecStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IncDecStmt]"))
}

// func _mapToIncDecStmt(o Map) *_ast.IncDecStmt {
// 	return &_ast.IncDecStmt{}
// }

// func _vectorToIncDecStmt(o *Vector) *_ast.IncDecStmt {
// 	return &_ast.IncDecStmt{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		TokPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Tok: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructIncDecStmt(_v Object) *_ast.IncDecStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.IncDecStmt:
// 			return &_g
// 		case *_ast.IncDecStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIncDecStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToIncDecStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IncDecStmt] or: Map or Vector"))
// }

GO TYPE go/ast.IndexExpr from go/ast/ast.go:
func ExtractGoObjectIndexExpr(args []Object, index int) *_ast.IndexExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.IndexExpr:
			return &r
		case *_ast.IndexExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.IndexExpr]"))
}

// func _mapToIndexExpr(o Map) *_ast.IndexExpr {
// 	return &_ast.IndexExpr{}
// }

// func _vectorToIndexExpr(o *Vector) *_ast.IndexExpr {
// 	return &_ast.IndexExpr{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Lbrack: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Index: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Rbrack: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructIndexExpr(_v Object) *_ast.IndexExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.IndexExpr:
// 			return &_g
// 		case *_ast.IndexExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIndexExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIndexExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.IndexExpr] or: Map or Vector"))
// }

GO TYPE go/ast.InterfaceType from go/ast/ast.go:
func ExtractGoObjectInterfaceType(args []Object, index int) *_ast.InterfaceType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.InterfaceType:
			return &r
		case *_ast.InterfaceType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.InterfaceType]"))
}

// func _mapToInterfaceType(o Map) *_ast.InterfaceType {
// 	return &_ast.InterfaceType{}
// }

// func _vectorToInterfaceType(o *Vector) *_ast.InterfaceType {
// 	return &_ast.InterfaceType{
// 		Interface: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Methods: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FieldList (go/ast.FieldList)),
// 		Incomplete: ToBool(o.Nth(2)),
// 	}
// }

// func _ConstructInterfaceType(_v Object) *_ast.InterfaceType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.InterfaceType:
// 			return &_g
// 		case *_ast.InterfaceType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterfaceType(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterfaceType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.InterfaceType] or: Map or Vector"))
// }

GO TYPE go/ast.KeyValueExpr from go/ast/ast.go:
func ExtractGoObjectKeyValueExpr(args []Object, index int) *_ast.KeyValueExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.KeyValueExpr:
			return &r
		case *_ast.KeyValueExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.KeyValueExpr]"))
}

// func _mapToKeyValueExpr(o Map) *_ast.KeyValueExpr {
// 	return &_ast.KeyValueExpr{}
// }

// func _vectorToKeyValueExpr(o *Vector) *_ast.KeyValueExpr {
// 	return &_ast.KeyValueExpr{
// 		Key: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Colon: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructKeyValueExpr(_v Object) *_ast.KeyValueExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.KeyValueExpr:
// 			return &_g
// 		case *_ast.KeyValueExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToKeyValueExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToKeyValueExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.KeyValueExpr] or: Map or Vector"))
// }

GO TYPE go/ast.LabeledStmt from go/ast/ast.go:
func ExtractGoObjectLabeledStmt(args []Object, index int) *_ast.LabeledStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.LabeledStmt:
			return &r
		case *_ast.LabeledStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.LabeledStmt]"))
}

// func _mapToLabeledStmt(o Map) *_ast.LabeledStmt {
// 	return &_ast.LabeledStmt{}
// }

// func _vectorToLabeledStmt(o *Vector) *_ast.LabeledStmt {
// 	return &_ast.LabeledStmt{
// 		Label: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 		Colon: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Stmt: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructLabeledStmt(_v Object) *_ast.LabeledStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.LabeledStmt:
// 			return &_g
// 		case *_ast.LabeledStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToLabeledStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToLabeledStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.LabeledStmt] or: Map or Vector"))
// }

GO TYPE go/ast.MapType from go/ast/ast.go:
func ExtractGoObjectMapType(args []Object, index int) *_ast.MapType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.MapType:
			return &r
		case *_ast.MapType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.MapType]"))
}

// func _mapToMapType(o Map) *_ast.MapType {
// 	return &_ast.MapType{}
// }

// func _vectorToMapType(o *Vector) *_ast.MapType {
// 	return &_ast.MapType{
// 		Map: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Key: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructMapType(_v Object) *_ast.MapType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.MapType:
// 			return &_g
// 		case *_ast.MapType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMapType(_o.(Map))
// 	case *Vector:
// 		return _vectorToMapType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.MapType] or: Map or Vector"))
// }

GO TYPE go/ast.MergeMode from go/ast/filter.go:
func ExtractGoObjectMergeMode(args []Object, index int) *_ast.MergeMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.MergeMode:
			return &r
		case *_ast.MergeMode:
			return r
		}
	case Number:
		v := _ast.MergeMode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.MergeMode]"))
}

func _ConstructMergeMode(_v Object) _ast.MergeMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.MergeMode:
			return _g
		case *_ast.MergeMode:
			return *_g
		}
	case Number:
		return _ast.MergeMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.MergeMode] or: Number"))
}

GO TYPE go/ast.Node from go/ast/ast.go:
func ExtractGoObjectNode(args []Object, index int) *_ast.Node {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Node:
			return &r
		case *_ast.Node:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Node]"))
}

// func _ConstructNode(_v Object) _ast.Node {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Node:
// 			return _g
// 		case *_ast.Node:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Node(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Node))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Node] or: whatever"))
// }

GO TYPE go/ast.ObjKind from go/ast/scope.go:
func ExtractGoObjectObjKind(args []Object, index int) *_ast.ObjKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ObjKind:
			return &r
		case *_ast.ObjKind:
			return r
		}
	case Int:
		v := _ast.ObjKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ObjKind]"))
}

func _ConstructObjKind(_v Object) _ast.ObjKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _ast.ObjKind:
			return _g
		case *_ast.ObjKind:
			return *_g
		}
	case Number:
		return _ast.ObjKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ObjKind] or: Number"))
}

GO TYPE go/ast.Object from go/ast/scope.go:
func ExtractGoObjectObject(args []Object, index int) *_ast.Object {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Object:
			return &r
		case *_ast.Object:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Object]"))
}

// func _mapToObject(o Map) *_ast.Object {
// 	return &_ast.Object{}
// }

// func _vectorToObject(o *Vector) *_ast.Object {
// 	return &_ast.Object{
// 		Kind: _ast.ObjKind(AssertInt(o.Nth(0), "").I),
// 		Name: AssertString(o.Nth(1), "").S,
// 		Decl: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Data: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Type: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructObject(_v Object) *_ast.Object {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Object:
// 			return &_g
// 		case *_ast.Object:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToObject(_o.(Map))
// 	case *Vector:
// 		return _vectorToObject(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Object] or: Map or Vector"))
// }

GO TYPE go/ast.Package from go/ast/ast.go:
func ExtractGoObjectPackage(args []Object, index int) *_ast.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Package:
			return &r
		case *_ast.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Package]"))
}

// func _mapToPackage(o Map) *_ast.Package {
// 	return &_ast.Package{}
// }

// func _vectorToPackage(o *Vector) *_ast.Package {
// 	return &_ast.Package{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Scope: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Scope (go/ast.Scope)),
// 		Imports: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Files: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 	}
// }

// func _ConstructPackage(_v Object) *_ast.Package {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Package:
// 			return &_g
// 		case *_ast.Package:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPackage(_o.(Map))
// 	case *Vector:
// 		return _vectorToPackage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Package] or: Map or Vector"))
// }

GO TYPE go/ast.ParenExpr from go/ast/ast.go:
func ExtractGoObjectParenExpr(args []Object, index int) *_ast.ParenExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ParenExpr:
			return &r
		case *_ast.ParenExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ParenExpr]"))
}

// func _mapToParenExpr(o Map) *_ast.ParenExpr {
// 	return &_ast.ParenExpr{}
// }

// func _vectorToParenExpr(o *Vector) *_ast.ParenExpr {
// 	return &_ast.ParenExpr{
// 		Lparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Rparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructParenExpr(_v Object) *_ast.ParenExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ParenExpr:
// 			return &_g
// 		case *_ast.ParenExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToParenExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToParenExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ParenExpr] or: Map or Vector"))
// }

GO TYPE go/ast.RangeStmt from go/ast/ast.go:
func ExtractGoObjectRangeStmt(args []Object, index int) *_ast.RangeStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.RangeStmt:
			return &r
		case *_ast.RangeStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.RangeStmt]"))
}

// func _mapToRangeStmt(o Map) *_ast.RangeStmt {
// 	return &_ast.RangeStmt{}
// }

// func _vectorToRangeStmt(o *Vector) *_ast.RangeStmt {
// 	return &_ast.RangeStmt{
// 		For: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Key: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		TokPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Tok: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructRangeStmt(_v Object) *_ast.RangeStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.RangeStmt:
// 			return &_g
// 		case *_ast.RangeStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRangeStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToRangeStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.RangeStmt] or: Map or Vector"))
// }

GO TYPE go/ast.ReturnStmt from go/ast/ast.go:
func ExtractGoObjectReturnStmt(args []Object, index int) *_ast.ReturnStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ReturnStmt:
			return &r
		case *_ast.ReturnStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ReturnStmt]"))
}

// func _mapToReturnStmt(o Map) *_ast.ReturnStmt {
// 	return &_ast.ReturnStmt{}
// }

// func _vectorToReturnStmt(o *Vector) *_ast.ReturnStmt {
// 	return &_ast.ReturnStmt{
// 		Return: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Results: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 	}
// }

// func _ConstructReturnStmt(_v Object) *_ast.ReturnStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ReturnStmt:
// 			return &_g
// 		case *_ast.ReturnStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReturnStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToReturnStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ReturnStmt] or: Map or Vector"))
// }

GO TYPE go/ast.Scope from go/ast/scope.go:
func ExtractGoObjectScope(args []Object, index int) *_ast.Scope {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Scope:
			return &r
		case *_ast.Scope:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Scope]"))
}

// func _mapToScope(o Map) *_ast.Scope {
// 	return &_ast.Scope{}
// }

// func _vectorToScope(o *Vector) *_ast.Scope {
// 	return &_ast.Scope{
// 		Outer: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Scope (go/ast.Scope)),
// 		Objects: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 	}
// }

// func _ConstructScope(_v Object) *_ast.Scope {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Scope:
// 			return &_g
// 		case *_ast.Scope:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToScope(_o.(Map))
// 	case *Vector:
// 		return _vectorToScope(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Scope] or: Map or Vector"))
// }

GO TYPE go/ast.SelectStmt from go/ast/ast.go:
func ExtractGoObjectSelectStmt(args []Object, index int) *_ast.SelectStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SelectStmt:
			return &r
		case *_ast.SelectStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SelectStmt]"))
}

// func _mapToSelectStmt(o Map) *_ast.SelectStmt {
// 	return &_ast.SelectStmt{}
// }

// func _vectorToSelectStmt(o *Vector) *_ast.SelectStmt {
// 	return &_ast.SelectStmt{
// 		Select: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructSelectStmt(_v Object) *_ast.SelectStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.SelectStmt:
// 			return &_g
// 		case *_ast.SelectStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSelectStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToSelectStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SelectStmt] or: Map or Vector"))
// }

GO TYPE go/ast.SelectorExpr from go/ast/ast.go:
func ExtractGoObjectSelectorExpr(args []Object, index int) *_ast.SelectorExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SelectorExpr:
			return &r
		case *_ast.SelectorExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SelectorExpr]"))
}

// func _mapToSelectorExpr(o Map) *_ast.SelectorExpr {
// 	return &_ast.SelectorExpr{}
// }

// func _vectorToSelectorExpr(o *Vector) *_ast.SelectorExpr {
// 	return &_ast.SelectorExpr{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Sel: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 	}
// }

// func _ConstructSelectorExpr(_v Object) *_ast.SelectorExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.SelectorExpr:
// 			return &_g
// 		case *_ast.SelectorExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSelectorExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToSelectorExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SelectorExpr] or: Map or Vector"))
// }

GO TYPE go/ast.SendStmt from go/ast/ast.go:
func ExtractGoObjectSendStmt(args []Object, index int) *_ast.SendStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SendStmt:
			return &r
		case *_ast.SendStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SendStmt]"))
}

// func _mapToSendStmt(o Map) *_ast.SendStmt {
// 	return &_ast.SendStmt{}
// }

// func _vectorToSendStmt(o *Vector) *_ast.SendStmt {
// 	return &_ast.SendStmt{
// 		Chan: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Arrow: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Value: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructSendStmt(_v Object) *_ast.SendStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.SendStmt:
// 			return &_g
// 		case *_ast.SendStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSendStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToSendStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SendStmt] or: Map or Vector"))
// }

GO TYPE go/ast.SliceExpr from go/ast/ast.go:
func ExtractGoObjectSliceExpr(args []Object, index int) *_ast.SliceExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SliceExpr:
			return &r
		case *_ast.SliceExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SliceExpr]"))
}

// func _mapToSliceExpr(o Map) *_ast.SliceExpr {
// 	return &_ast.SliceExpr{}
// }

// func _vectorToSliceExpr(o *Vector) *_ast.SliceExpr {
// 	return &_ast.SliceExpr{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Lbrack: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Low: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		High: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Max: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Slice3: ToBool(o.Nth(5)),
// 		Rbrack: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructSliceExpr(_v Object) *_ast.SliceExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.SliceExpr:
// 			return &_g
// 		case *_ast.SliceExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSliceExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToSliceExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SliceExpr] or: Map or Vector"))
// }

GO TYPE go/ast.Spec from go/ast/ast.go:
func ExtractGoObjectSpec(args []Object, index int) *_ast.Spec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Spec:
			return &r
		case *_ast.Spec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Spec]"))
}

// func _ConstructSpec(_v Object) _ast.Spec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Spec:
// 			return _g
// 		case *_ast.Spec:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Spec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Spec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Spec] or: whatever"))
// }

GO TYPE go/ast.StarExpr from go/ast/ast.go:
func ExtractGoObjectStarExpr(args []Object, index int) *_ast.StarExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.StarExpr:
			return &r
		case *_ast.StarExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.StarExpr]"))
}

// func _mapToStarExpr(o Map) *_ast.StarExpr {
// 	return &_ast.StarExpr{}
// }

// func _vectorToStarExpr(o *Vector) *_ast.StarExpr {
// 	return &_ast.StarExpr{
// 		Star: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructStarExpr(_v Object) *_ast.StarExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.StarExpr:
// 			return &_g
// 		case *_ast.StarExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStarExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToStarExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.StarExpr] or: Map or Vector"))
// }

GO TYPE go/ast.Stmt from go/ast/ast.go:
func ExtractGoObjectStmt(args []Object, index int) *_ast.Stmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Stmt:
			return &r
		case *_ast.Stmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Stmt]"))
}

// func _ConstructStmt(_v Object) _ast.Stmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Stmt:
// 			return _g
// 		case *_ast.Stmt:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Stmt(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Stmt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Stmt] or: whatever"))
// }

GO TYPE go/ast.StructType from go/ast/ast.go:
func ExtractGoObjectStructType(args []Object, index int) *_ast.StructType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.StructType:
			return &r
		case *_ast.StructType:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.StructType]"))
}

// func _mapToStructType(o Map) *_ast.StructType {
// 	return &_ast.StructType{}
// }

// func _vectorToStructType(o *Vector) *_ast.StructType {
// 	return &_ast.StructType{
// 		Struct: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Fields: ABEND048(codegen.go: no conversion from Clojure for *go/ast.FieldList (go/ast.FieldList)),
// 		Incomplete: ToBool(o.Nth(2)),
// 	}
// }

// func _ConstructStructType(_v Object) *_ast.StructType {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.StructType:
// 			return &_g
// 		case *_ast.StructType:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStructType(_o.(Map))
// 	case *Vector:
// 		return _vectorToStructType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.StructType] or: Map or Vector"))
// }

GO TYPE go/ast.SwitchStmt from go/ast/ast.go:
func ExtractGoObjectSwitchStmt(args []Object, index int) *_ast.SwitchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.SwitchStmt:
			return &r
		case *_ast.SwitchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.SwitchStmt]"))
}

// func _mapToSwitchStmt(o Map) *_ast.SwitchStmt {
// 	return &_ast.SwitchStmt{}
// }

// func _vectorToSwitchStmt(o *Vector) *_ast.SwitchStmt {
// 	return &_ast.SwitchStmt{
// 		Switch: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Init: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Tag: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructSwitchStmt(_v Object) *_ast.SwitchStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.SwitchStmt:
// 			return &_g
// 		case *_ast.SwitchStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSwitchStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToSwitchStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.SwitchStmt] or: Map or Vector"))
// }

GO TYPE go/ast.TypeAssertExpr from go/ast/ast.go:
func ExtractGoObjectTypeAssertExpr(args []Object, index int) *_ast.TypeAssertExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeAssertExpr:
			return &r
		case *_ast.TypeAssertExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeAssertExpr]"))
}

// func _mapToTypeAssertExpr(o Map) *_ast.TypeAssertExpr {
// 	return &_ast.TypeAssertExpr{}
// }

// func _vectorToTypeAssertExpr(o *Vector) *_ast.TypeAssertExpr {
// 	return &_ast.TypeAssertExpr{
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Lparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Rparen: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructTypeAssertExpr(_v Object) *_ast.TypeAssertExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.TypeAssertExpr:
// 			return &_g
// 		case *_ast.TypeAssertExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTypeAssertExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToTypeAssertExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeAssertExpr] or: Map or Vector"))
// }

GO TYPE go/ast.TypeSpec from go/ast/ast.go:
func ExtractGoObjectTypeSpec(args []Object, index int) *_ast.TypeSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeSpec:
			return &r
		case *_ast.TypeSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeSpec]"))
}

// func _mapToTypeSpec(o Map) *_ast.TypeSpec {
// 	return &_ast.TypeSpec{}
// }

// func _vectorToTypeSpec(o *Vector) *_ast.TypeSpec {
// 	return &_ast.TypeSpec{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for *go/ast.Ident (go/ast.Ident)),
// 		Assign: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Comment: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 	}
// }

// func _ConstructTypeSpec(_v Object) *_ast.TypeSpec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.TypeSpec:
// 			return &_g
// 		case *_ast.TypeSpec:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTypeSpec(_o.(Map))
// 	case *Vector:
// 		return _vectorToTypeSpec(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeSpec] or: Map or Vector"))
// }

GO TYPE go/ast.TypeSwitchStmt from go/ast/ast.go:
func ExtractGoObjectTypeSwitchStmt(args []Object, index int) *_ast.TypeSwitchStmt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.TypeSwitchStmt:
			return &r
		case *_ast.TypeSwitchStmt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.TypeSwitchStmt]"))
}

// func _mapToTypeSwitchStmt(o Map) *_ast.TypeSwitchStmt {
// 	return &_ast.TypeSwitchStmt{}
// }

// func _vectorToTypeSwitchStmt(o *Vector) *_ast.TypeSwitchStmt {
// 	return &_ast.TypeSwitchStmt{
// 		Switch: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Init: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Assign: ABEND048(codegen.go: no conversion from Clojure for go/ast.Stmt (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Body: ABEND048(codegen.go: no conversion from Clojure for *go/ast.BlockStmt (go/ast.BlockStmt)),
// 	}
// }

// func _ConstructTypeSwitchStmt(_v Object) *_ast.TypeSwitchStmt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.TypeSwitchStmt:
// 			return &_g
// 		case *_ast.TypeSwitchStmt:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTypeSwitchStmt(_o.(Map))
// 	case *Vector:
// 		return _vectorToTypeSwitchStmt(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.TypeSwitchStmt] or: Map or Vector"))
// }

GO TYPE go/ast.UnaryExpr from go/ast/ast.go:
func ExtractGoObjectUnaryExpr(args []Object, index int) *_ast.UnaryExpr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.UnaryExpr:
			return &r
		case *_ast.UnaryExpr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.UnaryExpr]"))
}

// func _mapToUnaryExpr(o Map) *_ast.UnaryExpr {
// 	return &_ast.UnaryExpr{}
// }

// func _vectorToUnaryExpr(o *Vector) *_ast.UnaryExpr {
// 	return &_ast.UnaryExpr{
// 		OpPos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Op: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		X: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructUnaryExpr(_v Object) *_ast.UnaryExpr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.UnaryExpr:
// 			return &_g
// 		case *_ast.UnaryExpr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUnaryExpr(_o.(Map))
// 	case *Vector:
// 		return _vectorToUnaryExpr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.UnaryExpr] or: Map or Vector"))
// }

GO TYPE go/ast.ValueSpec from go/ast/ast.go:
func ExtractGoObjectValueSpec(args []Object, index int) *_ast.ValueSpec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.ValueSpec:
			return &r
		case *_ast.ValueSpec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.ValueSpec]"))
}

// func _mapToValueSpec(o Map) *_ast.ValueSpec {
// 	return &_ast.ValueSpec{}
// }

// func _vectorToValueSpec(o *Vector) *_ast.ValueSpec {
// 	return &_ast.ValueSpec{
// 		Doc: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 		Names: ABEND048(codegen.go: no conversion from Clojure for []*go/ast.Ident (*go/ast.Ident)),
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/ast.Expr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Values: ABEND048(codegen.go: no conversion from Clojure for []go/ast.Expr (go/ast.Expr)),
// 		Comment: ABEND048(codegen.go: no conversion from Clojure for *go/ast.CommentGroup (go/ast.CommentGroup)),
// 	}
// }

// func _ConstructValueSpec(_v Object) *_ast.ValueSpec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.ValueSpec:
// 			return &_g
// 		case *_ast.ValueSpec:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToValueSpec(_o.(Map))
// 	case *Vector:
// 		return _vectorToValueSpec(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.ValueSpec] or: Map or Vector"))
// }

GO TYPE go/ast.Visitor from go/ast/walk.go:
func ExtractGoObjectVisitor(args []Object, index int) *_ast.Visitor {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _ast.Visitor:
			return &r
		case *_ast.Visitor:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/ast.Visitor]"))
}

// func _ConstructVisitor(_v Object) _ast.Visitor {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _ast.Visitor:
// 			return _g
// 		case *_ast.Visitor:
// 			return *_g
// 		}
// 	default:
// 		return _ast.Visitor(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Visitor))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[ast.Visitor] or: whatever"))
// }

GO FUNC go/ast.Fprint from go/ast/print.go:
// func __fprint(w ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), x interface {}, f _ast.FieldFilter)  {
// 	_res := _ast.Fprint(w, fset, x, f)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.Inspect from go/ast/walk.go:
// func __inspect(node _ast.Node, f func) Object {
// 	_ast.Inspect(node, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.MergePackageFiles from go/ast/filter.go:
func __mergePackageFiles(pkg *_ast.Package, mode _ast.MergeMode) Object {
	_res := _ast.MergePackageFiles(pkg, mode)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewCommentMap from go/ast/commentmap.go:
// func __newCommentMap(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node _ast.Node, comments []*_ast.CommentGroup) Object {
// 	_res := _ast.NewCommentMap(fset, node, comments)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.NewIdent from go/ast/ast.go:
func __newIdent(name string) Object {
	_res := _ast.NewIdent(name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewObj from go/ast/scope.go:
func __newObj(kind _ast.ObjKind, name string) Object {
	_res := _ast.NewObj(kind, name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NewPackage from go/ast/resolve.go:
// func __newPackage(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), files map[], importer _ast.Importer, universe *_ast.Scope) Object {
// 	_res1, _res2 := _ast.NewPackage(fset, files, importer, universe)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/ast.NewScope from go/ast/scope.go:
func __newScope(outer *_ast.Scope) Object {
	_res := _ast.NewScope(outer)
	return MakeGoObject(_res)
}

GO FUNC go/ast.NotNilFilter from go/ast/print.go:
// func __notNilFilter(_ string, v ABEND987(genutils.go: imports not yet supported: reflect.Value))  {
// 	_res := _ast.NotNilFilter(_, v)
// 	return MakeBoolean(_res)
// }

GO FUNC go/ast.Print from go/ast/print.go:
// func __print(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), x interface {})  {
// 	_res := _ast.Print(fset, x)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/ast.SortImports from go/ast/import.go:
// func __sortImports(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), f *_ast.File) Object {
// 	_ast.SortImports(fset, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.Walk from go/ast/walk.go:
// func __walk(v _ast.Visitor, node _ast.Node) Object {
// 	_ast.Walk(v, node)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.__commentMap_Comments from go/ast/commentmap.go:
func __commentMap_Comments(o GoObject, args Object) Object {
	CheckGoArity("(_go/ast.CommentMap)Comments()", args, 0, 0)
	_res := o.O.(_ast.CommentMap).Comments()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC go/ast.__commentMap_Filter from go/ast/commentmap.go:
func __commentMap_Filter(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_go/ast.CommentMap)Filter()", args, 1, 1)
	node := ExtractGo_go_std_go_ast__Node("(_go/ast.CommentMap)Filter()", "node", _argList, 0)
	_res := o.O.(_ast.CommentMap).Filter(node)
	return MakeGoObject(_res)
}

GO FUNC go/ast.__commentMap_String from go/ast/commentmap.go:
func __commentMap_String(o GoObject, args Object) Object {
	CheckGoArity("(_go/ast.CommentMap)String()", args, 0, 0)
	_res := o.O.(_ast.CommentMap).String()
	return MakeString(_res)
}

GO FUNC go/ast.__commentMap_Update from go/ast/commentmap.go:
func __commentMap_Update(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_go/ast.CommentMap)Update()", args, 2, 2)
	old := ExtractGo_go_std_go_ast__Node("(_go/ast.CommentMap)Update()", "old", _argList, 0)
	new := ExtractGo_go_std_go_ast__Node("(_go/ast.CommentMap)Update()", "new", _argList, 1)
	_res := o.O.(_ast.CommentMap).Update(old, new)
	return MakeGoObject(_res)
}

GO FUNC go/ast.__objKind_String from go/ast/scope.go:
func __objKind_String(o GoObject, args Object) Object {
	CheckGoArity("(_go/ast.ObjKind)String()", args, 0, 0)
	_res := o.O.(_ast.ObjKind).String()
	return MakeString(_res)
}

GO FUNC go/ast.__ptrTo_ArrayType_End from go/ast/ast.go:
func __ptrTo_ArrayType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ArrayType)End()", args, 0, 0)
	_res := o.O.(*_ast.ArrayType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ArrayType_Pos from go/ast/ast.go:
func __ptrTo_ArrayType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ArrayType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ArrayType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_AssignStmt_End from go/ast/ast.go:
func __ptrTo_AssignStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.AssignStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.AssignStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_AssignStmt_Pos from go/ast/ast.go:
func __ptrTo_AssignStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.AssignStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.AssignStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadDecl_End from go/ast/ast.go:
func __ptrTo_BadDecl_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadDecl)End()", args, 0, 0)
	_res := o.O.(*_ast.BadDecl).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadDecl_Pos from go/ast/ast.go:
func __ptrTo_BadDecl_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadDecl)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BadDecl).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadExpr_End from go/ast/ast.go:
func __ptrTo_BadExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.BadExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadExpr_Pos from go/ast/ast.go:
func __ptrTo_BadExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BadExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadStmt_End from go/ast/ast.go:
func __ptrTo_BadStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.BadStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BadStmt_Pos from go/ast/ast.go:
func __ptrTo_BadStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BadStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BadStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BasicLit_End from go/ast/ast.go:
func __ptrTo_BasicLit_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BasicLit)End()", args, 0, 0)
	_res := o.O.(*_ast.BasicLit).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BasicLit_Pos from go/ast/ast.go:
func __ptrTo_BasicLit_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BasicLit)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BasicLit).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BinaryExpr_End from go/ast/ast.go:
func __ptrTo_BinaryExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BinaryExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.BinaryExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BinaryExpr_Pos from go/ast/ast.go:
func __ptrTo_BinaryExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BinaryExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BinaryExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BlockStmt_End from go/ast/ast.go:
func __ptrTo_BlockStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BlockStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.BlockStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BlockStmt_Pos from go/ast/ast.go:
func __ptrTo_BlockStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BlockStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BlockStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BranchStmt_End from go/ast/ast.go:
func __ptrTo_BranchStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BranchStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.BranchStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_BranchStmt_Pos from go/ast/ast.go:
func __ptrTo_BranchStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.BranchStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.BranchStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CallExpr_End from go/ast/ast.go:
func __ptrTo_CallExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CallExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.CallExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CallExpr_Pos from go/ast/ast.go:
func __ptrTo_CallExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CallExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.CallExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CaseClause_End from go/ast/ast.go:
func __ptrTo_CaseClause_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CaseClause)End()", args, 0, 0)
	_res := o.O.(*_ast.CaseClause).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CaseClause_Pos from go/ast/ast.go:
func __ptrTo_CaseClause_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CaseClause)Pos()", args, 0, 0)
	_res := o.O.(*_ast.CaseClause).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ChanType_End from go/ast/ast.go:
func __ptrTo_ChanType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ChanType)End()", args, 0, 0)
	_res := o.O.(*_ast.ChanType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ChanType_Pos from go/ast/ast.go:
func __ptrTo_ChanType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ChanType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ChanType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CommClause_End from go/ast/ast.go:
func __ptrTo_CommClause_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CommClause)End()", args, 0, 0)
	_res := o.O.(*_ast.CommClause).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CommClause_Pos from go/ast/ast.go:
func __ptrTo_CommClause_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CommClause)Pos()", args, 0, 0)
	_res := o.O.(*_ast.CommClause).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CommentGroup_End from go/ast/ast.go:
func __ptrTo_CommentGroup_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CommentGroup)End()", args, 0, 0)
	_res := o.O.(*_ast.CommentGroup).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CommentGroup_Pos from go/ast/ast.go:
func __ptrTo_CommentGroup_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CommentGroup)Pos()", args, 0, 0)
	_res := o.O.(*_ast.CommentGroup).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CommentGroup_Text from go/ast/ast.go:
func __ptrTo_CommentGroup_Text(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CommentGroup)Text()", args, 0, 0)
	_res := o.O.(*_ast.CommentGroup).Text()
	return MakeString(_res)
}

GO FUNC go/ast.__ptrTo_Comment_End from go/ast/ast.go:
func __ptrTo_Comment_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Comment)End()", args, 0, 0)
	_res := o.O.(*_ast.Comment).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Comment_Pos from go/ast/ast.go:
func __ptrTo_Comment_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Comment)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Comment).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CompositeLit_End from go/ast/ast.go:
func __ptrTo_CompositeLit_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CompositeLit)End()", args, 0, 0)
	_res := o.O.(*_ast.CompositeLit).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_CompositeLit_Pos from go/ast/ast.go:
func __ptrTo_CompositeLit_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.CompositeLit)Pos()", args, 0, 0)
	_res := o.O.(*_ast.CompositeLit).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_DeclStmt_End from go/ast/ast.go:
func __ptrTo_DeclStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.DeclStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.DeclStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_DeclStmt_Pos from go/ast/ast.go:
func __ptrTo_DeclStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.DeclStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.DeclStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_DeferStmt_End from go/ast/ast.go:
func __ptrTo_DeferStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.DeferStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.DeferStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_DeferStmt_Pos from go/ast/ast.go:
func __ptrTo_DeferStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.DeferStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.DeferStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Ellipsis_End from go/ast/ast.go:
func __ptrTo_Ellipsis_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ellipsis)End()", args, 0, 0)
	_res := o.O.(*_ast.Ellipsis).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Ellipsis_Pos from go/ast/ast.go:
func __ptrTo_Ellipsis_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ellipsis)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Ellipsis).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_EmptyStmt_End from go/ast/ast.go:
func __ptrTo_EmptyStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.EmptyStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.EmptyStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_EmptyStmt_Pos from go/ast/ast.go:
func __ptrTo_EmptyStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.EmptyStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.EmptyStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ExprStmt_End from go/ast/ast.go:
func __ptrTo_ExprStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ExprStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.ExprStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ExprStmt_Pos from go/ast/ast.go:
func __ptrTo_ExprStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ExprStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ExprStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FieldList_End from go/ast/ast.go:
func __ptrTo_FieldList_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FieldList)End()", args, 0, 0)
	_res := o.O.(*_ast.FieldList).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FieldList_NumFields from go/ast/ast.go:
func __ptrTo_FieldList_NumFields(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FieldList)NumFields()", args, 0, 0)
	_res := o.O.(*_ast.FieldList).NumFields()
	return MakeInt(_res)
}

GO FUNC go/ast.__ptrTo_FieldList_Pos from go/ast/ast.go:
func __ptrTo_FieldList_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FieldList)Pos()", args, 0, 0)
	_res := o.O.(*_ast.FieldList).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Field_End from go/ast/ast.go:
func __ptrTo_Field_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Field)End()", args, 0, 0)
	_res := o.O.(*_ast.Field).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Field_Pos from go/ast/ast.go:
func __ptrTo_Field_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Field)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Field).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_File_End from go/ast/ast.go:
func __ptrTo_File_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.File)End()", args, 0, 0)
	_res := o.O.(*_ast.File).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_File_Pos from go/ast/ast.go:
func __ptrTo_File_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.File)Pos()", args, 0, 0)
	_res := o.O.(*_ast.File).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ForStmt_End from go/ast/ast.go:
func __ptrTo_ForStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ForStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.ForStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ForStmt_Pos from go/ast/ast.go:
func __ptrTo_ForStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ForStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ForStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncDecl_End from go/ast/ast.go:
func __ptrTo_FuncDecl_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncDecl)End()", args, 0, 0)
	_res := o.O.(*_ast.FuncDecl).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncDecl_Pos from go/ast/ast.go:
func __ptrTo_FuncDecl_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncDecl)Pos()", args, 0, 0)
	_res := o.O.(*_ast.FuncDecl).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncLit_End from go/ast/ast.go:
func __ptrTo_FuncLit_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncLit)End()", args, 0, 0)
	_res := o.O.(*_ast.FuncLit).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncLit_Pos from go/ast/ast.go:
func __ptrTo_FuncLit_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncLit)Pos()", args, 0, 0)
	_res := o.O.(*_ast.FuncLit).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncType_End from go/ast/ast.go:
func __ptrTo_FuncType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncType)End()", args, 0, 0)
	_res := o.O.(*_ast.FuncType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_FuncType_Pos from go/ast/ast.go:
func __ptrTo_FuncType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.FuncType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.FuncType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_GenDecl_End from go/ast/ast.go:
func __ptrTo_GenDecl_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.GenDecl)End()", args, 0, 0)
	_res := o.O.(*_ast.GenDecl).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_GenDecl_Pos from go/ast/ast.go:
func __ptrTo_GenDecl_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.GenDecl)Pos()", args, 0, 0)
	_res := o.O.(*_ast.GenDecl).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_GoStmt_End from go/ast/ast.go:
func __ptrTo_GoStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.GoStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.GoStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_GoStmt_Pos from go/ast/ast.go:
func __ptrTo_GoStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.GoStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.GoStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Ident_End from go/ast/ast.go:
func __ptrTo_Ident_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ident)End()", args, 0, 0)
	_res := o.O.(*_ast.Ident).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Ident_IsExported from go/ast/ast.go:
func __ptrTo_Ident_IsExported(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ident)IsExported()", args, 0, 0)
	_res := o.O.(*_ast.Ident).IsExported()
	return MakeBoolean(_res)
}

GO FUNC go/ast.__ptrTo_Ident_Pos from go/ast/ast.go:
func __ptrTo_Ident_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ident)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Ident).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Ident_String from go/ast/ast.go:
func __ptrTo_Ident_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Ident)String()", args, 0, 0)
	_res := o.O.(*_ast.Ident).String()
	return MakeString(_res)
}

GO FUNC go/ast.__ptrTo_IfStmt_End from go/ast/ast.go:
func __ptrTo_IfStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IfStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.IfStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_IfStmt_Pos from go/ast/ast.go:
func __ptrTo_IfStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IfStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.IfStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ImportSpec_End from go/ast/ast.go:
func __ptrTo_ImportSpec_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ImportSpec)End()", args, 0, 0)
	_res := o.O.(*_ast.ImportSpec).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ImportSpec_Pos from go/ast/ast.go:
func __ptrTo_ImportSpec_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ImportSpec)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ImportSpec).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_IncDecStmt_End from go/ast/ast.go:
func __ptrTo_IncDecStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IncDecStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.IncDecStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_IncDecStmt_Pos from go/ast/ast.go:
func __ptrTo_IncDecStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IncDecStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.IncDecStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_IndexExpr_End from go/ast/ast.go:
func __ptrTo_IndexExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IndexExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.IndexExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_IndexExpr_Pos from go/ast/ast.go:
func __ptrTo_IndexExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.IndexExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.IndexExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_InterfaceType_End from go/ast/ast.go:
func __ptrTo_InterfaceType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.InterfaceType)End()", args, 0, 0)
	_res := o.O.(*_ast.InterfaceType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_InterfaceType_Pos from go/ast/ast.go:
func __ptrTo_InterfaceType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.InterfaceType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.InterfaceType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_KeyValueExpr_End from go/ast/ast.go:
func __ptrTo_KeyValueExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.KeyValueExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.KeyValueExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_KeyValueExpr_Pos from go/ast/ast.go:
func __ptrTo_KeyValueExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.KeyValueExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.KeyValueExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_LabeledStmt_End from go/ast/ast.go:
func __ptrTo_LabeledStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.LabeledStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.LabeledStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_LabeledStmt_Pos from go/ast/ast.go:
func __ptrTo_LabeledStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.LabeledStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.LabeledStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_MapType_End from go/ast/ast.go:
func __ptrTo_MapType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.MapType)End()", args, 0, 0)
	_res := o.O.(*_ast.MapType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_MapType_Pos from go/ast/ast.go:
func __ptrTo_MapType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.MapType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.MapType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Object_Pos from go/ast/scope.go:
func __ptrTo_Object_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Object)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Object).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Package_End from go/ast/ast.go:
func __ptrTo_Package_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Package)End()", args, 0, 0)
	_res := o.O.(*_ast.Package).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Package_Pos from go/ast/ast.go:
func __ptrTo_Package_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Package)Pos()", args, 0, 0)
	_res := o.O.(*_ast.Package).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ParenExpr_End from go/ast/ast.go:
func __ptrTo_ParenExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ParenExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.ParenExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ParenExpr_Pos from go/ast/ast.go:
func __ptrTo_ParenExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ParenExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ParenExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_RangeStmt_End from go/ast/ast.go:
func __ptrTo_RangeStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.RangeStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.RangeStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_RangeStmt_Pos from go/ast/ast.go:
func __ptrTo_RangeStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.RangeStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.RangeStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ReturnStmt_End from go/ast/ast.go:
func __ptrTo_ReturnStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ReturnStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.ReturnStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ReturnStmt_Pos from go/ast/ast.go:
func __ptrTo_ReturnStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ReturnStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ReturnStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Scope_Insert from go/ast/scope.go:
// func __ptrTo_Scope_Insert(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_go/ast.Scope)Insert()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for obj at: /usr/local/go/src/go/ast/scope.go:43:28)
// 	_res := o.O.(*_ast.Scope).Insert(obj)
// 	return MakeGoObject(_res)
// }

GO FUNC go/ast.__ptrTo_Scope_Lookup from go/ast/scope.go:
func __ptrTo_Scope_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/ast.Scope)Lookup()", args, 1, 1)
	name := ExtractGoString("(*_go/ast.Scope)Lookup()", "name", _argList, 0)
	_res := o.O.(*_ast.Scope).Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_Scope_String from go/ast/scope.go:
func __ptrTo_Scope_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.Scope)String()", args, 0, 0)
	_res := o.O.(*_ast.Scope).String()
	return MakeString(_res)
}

GO FUNC go/ast.__ptrTo_SelectStmt_End from go/ast/ast.go:
func __ptrTo_SelectStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SelectStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.SelectStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SelectStmt_Pos from go/ast/ast.go:
func __ptrTo_SelectStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SelectStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.SelectStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SelectorExpr_End from go/ast/ast.go:
func __ptrTo_SelectorExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SelectorExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.SelectorExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SelectorExpr_Pos from go/ast/ast.go:
func __ptrTo_SelectorExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SelectorExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.SelectorExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SendStmt_End from go/ast/ast.go:
func __ptrTo_SendStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SendStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.SendStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SendStmt_Pos from go/ast/ast.go:
func __ptrTo_SendStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SendStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.SendStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SliceExpr_End from go/ast/ast.go:
func __ptrTo_SliceExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SliceExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.SliceExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SliceExpr_Pos from go/ast/ast.go:
func __ptrTo_SliceExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SliceExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.SliceExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_StarExpr_End from go/ast/ast.go:
func __ptrTo_StarExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.StarExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.StarExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_StarExpr_Pos from go/ast/ast.go:
func __ptrTo_StarExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.StarExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.StarExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_StructType_End from go/ast/ast.go:
func __ptrTo_StructType_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.StructType)End()", args, 0, 0)
	_res := o.O.(*_ast.StructType).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_StructType_Pos from go/ast/ast.go:
func __ptrTo_StructType_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.StructType)Pos()", args, 0, 0)
	_res := o.O.(*_ast.StructType).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SwitchStmt_End from go/ast/ast.go:
func __ptrTo_SwitchStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SwitchStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.SwitchStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_SwitchStmt_Pos from go/ast/ast.go:
func __ptrTo_SwitchStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.SwitchStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.SwitchStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeAssertExpr_End from go/ast/ast.go:
func __ptrTo_TypeAssertExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeAssertExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.TypeAssertExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeAssertExpr_Pos from go/ast/ast.go:
func __ptrTo_TypeAssertExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeAssertExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.TypeAssertExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeSpec_End from go/ast/ast.go:
func __ptrTo_TypeSpec_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeSpec)End()", args, 0, 0)
	_res := o.O.(*_ast.TypeSpec).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeSpec_Pos from go/ast/ast.go:
func __ptrTo_TypeSpec_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeSpec)Pos()", args, 0, 0)
	_res := o.O.(*_ast.TypeSpec).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeSwitchStmt_End from go/ast/ast.go:
func __ptrTo_TypeSwitchStmt_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeSwitchStmt)End()", args, 0, 0)
	_res := o.O.(*_ast.TypeSwitchStmt).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_TypeSwitchStmt_Pos from go/ast/ast.go:
func __ptrTo_TypeSwitchStmt_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.TypeSwitchStmt)Pos()", args, 0, 0)
	_res := o.O.(*_ast.TypeSwitchStmt).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_UnaryExpr_End from go/ast/ast.go:
func __ptrTo_UnaryExpr_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.UnaryExpr)End()", args, 0, 0)
	_res := o.O.(*_ast.UnaryExpr).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_UnaryExpr_Pos from go/ast/ast.go:
func __ptrTo_UnaryExpr_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.UnaryExpr)Pos()", args, 0, 0)
	_res := o.O.(*_ast.UnaryExpr).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ValueSpec_End from go/ast/ast.go:
func __ptrTo_ValueSpec_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ValueSpec)End()", args, 0, 0)
	_res := o.O.(*_ast.ValueSpec).End()
	return MakeGoObject(_res)
}

GO FUNC go/ast.__ptrTo_ValueSpec_Pos from go/ast/ast.go:
func __ptrTo_ValueSpec_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/ast.ValueSpec)Pos()", args, 0, 0)
	_res := o.O.(*_ast.ValueSpec).Pos()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ast

import (
	. "github.com/candid82/joker/core"
	_ast "go/ast"
	_reflect "reflect"
)
var members_PtrTo_ArrayType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ArrayType_End,
	"Pos": __ptrTo_ArrayType_Pos,
}}

var members_PtrTo_AssignStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_AssignStmt_End,
	"Pos": __ptrTo_AssignStmt_Pos,
}}

var members_PtrTo_BadDecl = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BadDecl_End,
	"Pos": __ptrTo_BadDecl_Pos,
}}

var members_PtrTo_BadExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BadExpr_End,
	"Pos": __ptrTo_BadExpr_Pos,
}}

var members_PtrTo_BadStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BadStmt_End,
	"Pos": __ptrTo_BadStmt_Pos,
}}

var members_PtrTo_BasicLit = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BasicLit_End,
	"Pos": __ptrTo_BasicLit_Pos,
}}

var members_PtrTo_BinaryExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BinaryExpr_End,
	"Pos": __ptrTo_BinaryExpr_Pos,
}}

var members_PtrTo_BlockStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BlockStmt_End,
	"Pos": __ptrTo_BlockStmt_Pos,
}}

var members_PtrTo_BranchStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_BranchStmt_End,
	"Pos": __ptrTo_BranchStmt_Pos,
}}

var members_PtrTo_CallExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_CallExpr_End,
	"Pos": __ptrTo_CallExpr_Pos,
}}

var members_PtrTo_CaseClause = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_CaseClause_End,
	"Pos": __ptrTo_CaseClause_Pos,
}}

var members_PtrTo_ChanType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ChanType_End,
	"Pos": __ptrTo_ChanType_Pos,
}}

var members_PtrTo_CommClause = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_CommClause_End,
	"Pos": __ptrTo_CommClause_Pos,
}}

var members_PtrTo_Comment = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_Comment_End,
	"Pos": __ptrTo_Comment_Pos,
}}

var members_PtrTo_CommentGroup = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_CommentGroup_End,
	"Pos": __ptrTo_CommentGroup_Pos,
	"Text": __ptrTo_CommentGroup_Text,
}}

var members_CommentMap = GoTypeInfo{Members: GoMembers{
	"Comments": __commentMap_Comments,
	"Filter": __commentMap_Filter,
	"String": __commentMap_String,
	"Update": __commentMap_Update,
}}

var members_PtrTo_CompositeLit = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_CompositeLit_End,
	"Pos": __ptrTo_CompositeLit_Pos,
}}

var members_PtrTo_DeclStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_DeclStmt_End,
	"Pos": __ptrTo_DeclStmt_Pos,
}}

var members_PtrTo_DeferStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_DeferStmt_End,
	"Pos": __ptrTo_DeferStmt_Pos,
}}

var members_PtrTo_Ellipsis = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_Ellipsis_End,
	"Pos": __ptrTo_Ellipsis_Pos,
}}

var members_PtrTo_EmptyStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_EmptyStmt_End,
	"Pos": __ptrTo_EmptyStmt_Pos,
}}

var members_PtrTo_ExprStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ExprStmt_End,
	"Pos": __ptrTo_ExprStmt_Pos,
}}

var members_PtrTo_Field = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_Field_End,
	"Pos": __ptrTo_Field_Pos,
}}

var members_PtrTo_FieldList = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_FieldList_End,
	"NumFields": __ptrTo_FieldList_NumFields,
	"Pos": __ptrTo_FieldList_Pos,
}}

var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_File_End,
	"Pos": __ptrTo_File_Pos,
}}

var members_PtrTo_ForStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ForStmt_End,
	"Pos": __ptrTo_ForStmt_Pos,
}}

var members_PtrTo_FuncDecl = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_FuncDecl_End,
	"Pos": __ptrTo_FuncDecl_Pos,
}}

var members_PtrTo_FuncLit = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_FuncLit_End,
	"Pos": __ptrTo_FuncLit_Pos,
}}

var members_PtrTo_FuncType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_FuncType_End,
	"Pos": __ptrTo_FuncType_Pos,
}}

var members_PtrTo_GenDecl = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_GenDecl_End,
	"Pos": __ptrTo_GenDecl_Pos,
}}

var members_PtrTo_GoStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_GoStmt_End,
	"Pos": __ptrTo_GoStmt_Pos,
}}

var members_PtrTo_Ident = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_Ident_End,
	"IsExported": __ptrTo_Ident_IsExported,
	"Pos": __ptrTo_Ident_Pos,
	"String": __ptrTo_Ident_String,
}}

var members_PtrTo_IfStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_IfStmt_End,
	"Pos": __ptrTo_IfStmt_Pos,
}}

var members_PtrTo_ImportSpec = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ImportSpec_End,
	"Pos": __ptrTo_ImportSpec_Pos,
}}

var members_PtrTo_IncDecStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_IncDecStmt_End,
	"Pos": __ptrTo_IncDecStmt_Pos,
}}

var members_PtrTo_IndexExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_IndexExpr_End,
	"Pos": __ptrTo_IndexExpr_Pos,
}}

var members_PtrTo_InterfaceType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_InterfaceType_End,
	"Pos": __ptrTo_InterfaceType_Pos,
}}

var members_PtrTo_KeyValueExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_KeyValueExpr_End,
	"Pos": __ptrTo_KeyValueExpr_Pos,
}}

var members_PtrTo_LabeledStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_LabeledStmt_End,
	"Pos": __ptrTo_LabeledStmt_Pos,
}}

var members_PtrTo_MapType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_MapType_End,
	"Pos": __ptrTo_MapType_Pos,
}}

var members_ObjKind = GoTypeInfo{Members: GoMembers{
	"String": __objKind_String,
}}

var members_PtrTo_Object = GoTypeInfo{Members: GoMembers{
	"Pos": __ptrTo_Object_Pos,
}}

var members_PtrTo_Package = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_Package_End,
	"Pos": __ptrTo_Package_Pos,
}}

var members_PtrTo_ParenExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ParenExpr_End,
	"Pos": __ptrTo_ParenExpr_Pos,
}}

var members_PtrTo_RangeStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_RangeStmt_End,
	"Pos": __ptrTo_RangeStmt_Pos,
}}

var members_PtrTo_ReturnStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ReturnStmt_End,
	"Pos": __ptrTo_ReturnStmt_Pos,
}}

var members_PtrTo_Scope = GoTypeInfo{Members: GoMembers{
	"Lookup": __ptrTo_Scope_Lookup,
	"String": __ptrTo_Scope_String,
}}

var members_PtrTo_SelectStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_SelectStmt_End,
	"Pos": __ptrTo_SelectStmt_Pos,
}}

var members_PtrTo_SelectorExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_SelectorExpr_End,
	"Pos": __ptrTo_SelectorExpr_Pos,
}}

var members_PtrTo_SendStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_SendStmt_End,
	"Pos": __ptrTo_SendStmt_Pos,
}}

var members_PtrTo_SliceExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_SliceExpr_End,
	"Pos": __ptrTo_SliceExpr_Pos,
}}

var members_PtrTo_StarExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_StarExpr_End,
	"Pos": __ptrTo_StarExpr_Pos,
}}

var members_PtrTo_StructType = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_StructType_End,
	"Pos": __ptrTo_StructType_Pos,
}}

var members_PtrTo_SwitchStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_SwitchStmt_End,
	"Pos": __ptrTo_SwitchStmt_Pos,
}}

var members_PtrTo_TypeAssertExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_TypeAssertExpr_End,
	"Pos": __ptrTo_TypeAssertExpr_Pos,
}}

var members_PtrTo_TypeSpec = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_TypeSpec_End,
	"Pos": __ptrTo_TypeSpec_Pos,
}}

var members_PtrTo_TypeSwitchStmt = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_TypeSwitchStmt_End,
	"Pos": __ptrTo_TypeSwitchStmt_Pos,
}}

var members_PtrTo_UnaryExpr = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_UnaryExpr_End,
	"Pos": __ptrTo_UnaryExpr_Pos,
}}

var members_PtrTo_ValueSpec = GoTypeInfo{Members: GoMembers{
	"End": __ptrTo_ValueSpec_End,
	"Pos": __ptrTo_ValueSpec_Pos,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_ast.ArrayType)(nil))] = &members_PtrTo_ArrayType
	GoTypes[_reflect.TypeOf((*_ast.AssignStmt)(nil))] = &members_PtrTo_AssignStmt
	GoTypes[_reflect.TypeOf((*_ast.BadDecl)(nil))] = &members_PtrTo_BadDecl
	GoTypes[_reflect.TypeOf((*_ast.BadExpr)(nil))] = &members_PtrTo_BadExpr
	GoTypes[_reflect.TypeOf((*_ast.BadStmt)(nil))] = &members_PtrTo_BadStmt
	GoTypes[_reflect.TypeOf((*_ast.BasicLit)(nil))] = &members_PtrTo_BasicLit
	GoTypes[_reflect.TypeOf((*_ast.BinaryExpr)(nil))] = &members_PtrTo_BinaryExpr
	GoTypes[_reflect.TypeOf((*_ast.BlockStmt)(nil))] = &members_PtrTo_BlockStmt
	GoTypes[_reflect.TypeOf((*_ast.BranchStmt)(nil))] = &members_PtrTo_BranchStmt
	GoTypes[_reflect.TypeOf((*_ast.CallExpr)(nil))] = &members_PtrTo_CallExpr
	GoTypes[_reflect.TypeOf((*_ast.CaseClause)(nil))] = &members_PtrTo_CaseClause
	GoTypes[_reflect.TypeOf((*_ast.ChanType)(nil))] = &members_PtrTo_ChanType
	GoTypes[_reflect.TypeOf((*_ast.CommClause)(nil))] = &members_PtrTo_CommClause
	GoTypes[_reflect.TypeOf((*_ast.Comment)(nil))] = &members_PtrTo_Comment
	GoTypes[_reflect.TypeOf((*_ast.CommentGroup)(nil))] = &members_PtrTo_CommentGroup
	GoTypes[_reflect.TypeOf((*_ast.CommentMap)(nil)).Elem()] = &members_CommentMap
	GoTypes[_reflect.TypeOf((*_ast.CompositeLit)(nil))] = &members_PtrTo_CompositeLit
	GoTypes[_reflect.TypeOf((*_ast.DeclStmt)(nil))] = &members_PtrTo_DeclStmt
	GoTypes[_reflect.TypeOf((*_ast.DeferStmt)(nil))] = &members_PtrTo_DeferStmt
	GoTypes[_reflect.TypeOf((*_ast.Ellipsis)(nil))] = &members_PtrTo_Ellipsis
	GoTypes[_reflect.TypeOf((*_ast.EmptyStmt)(nil))] = &members_PtrTo_EmptyStmt
	GoTypes[_reflect.TypeOf((*_ast.ExprStmt)(nil))] = &members_PtrTo_ExprStmt
	GoTypes[_reflect.TypeOf((*_ast.Field)(nil))] = &members_PtrTo_Field
	GoTypes[_reflect.TypeOf((*_ast.FieldList)(nil))] = &members_PtrTo_FieldList
	GoTypes[_reflect.TypeOf((*_ast.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_ast.ForStmt)(nil))] = &members_PtrTo_ForStmt
	GoTypes[_reflect.TypeOf((*_ast.FuncDecl)(nil))] = &members_PtrTo_FuncDecl
	GoTypes[_reflect.TypeOf((*_ast.FuncLit)(nil))] = &members_PtrTo_FuncLit
	GoTypes[_reflect.TypeOf((*_ast.FuncType)(nil))] = &members_PtrTo_FuncType
	GoTypes[_reflect.TypeOf((*_ast.GenDecl)(nil))] = &members_PtrTo_GenDecl
	GoTypes[_reflect.TypeOf((*_ast.GoStmt)(nil))] = &members_PtrTo_GoStmt
	GoTypes[_reflect.TypeOf((*_ast.Ident)(nil))] = &members_PtrTo_Ident
	GoTypes[_reflect.TypeOf((*_ast.IfStmt)(nil))] = &members_PtrTo_IfStmt
	GoTypes[_reflect.TypeOf((*_ast.ImportSpec)(nil))] = &members_PtrTo_ImportSpec
	GoTypes[_reflect.TypeOf((*_ast.IncDecStmt)(nil))] = &members_PtrTo_IncDecStmt
	GoTypes[_reflect.TypeOf((*_ast.IndexExpr)(nil))] = &members_PtrTo_IndexExpr
	GoTypes[_reflect.TypeOf((*_ast.InterfaceType)(nil))] = &members_PtrTo_InterfaceType
	GoTypes[_reflect.TypeOf((*_ast.KeyValueExpr)(nil))] = &members_PtrTo_KeyValueExpr
	GoTypes[_reflect.TypeOf((*_ast.LabeledStmt)(nil))] = &members_PtrTo_LabeledStmt
	GoTypes[_reflect.TypeOf((*_ast.MapType)(nil))] = &members_PtrTo_MapType
	GoTypes[_reflect.TypeOf((*_ast.ObjKind)(nil)).Elem()] = &members_ObjKind
	GoTypes[_reflect.TypeOf((*_ast.Object)(nil))] = &members_PtrTo_Object
	GoTypes[_reflect.TypeOf((*_ast.Package)(nil))] = &members_PtrTo_Package
	GoTypes[_reflect.TypeOf((*_ast.ParenExpr)(nil))] = &members_PtrTo_ParenExpr
	GoTypes[_reflect.TypeOf((*_ast.RangeStmt)(nil))] = &members_PtrTo_RangeStmt
	GoTypes[_reflect.TypeOf((*_ast.ReturnStmt)(nil))] = &members_PtrTo_ReturnStmt
	GoTypes[_reflect.TypeOf((*_ast.Scope)(nil))] = &members_PtrTo_Scope
	GoTypes[_reflect.TypeOf((*_ast.SelectStmt)(nil))] = &members_PtrTo_SelectStmt
	GoTypes[_reflect.TypeOf((*_ast.SelectorExpr)(nil))] = &members_PtrTo_SelectorExpr
	GoTypes[_reflect.TypeOf((*_ast.SendStmt)(nil))] = &members_PtrTo_SendStmt
	GoTypes[_reflect.TypeOf((*_ast.SliceExpr)(nil))] = &members_PtrTo_SliceExpr
	GoTypes[_reflect.TypeOf((*_ast.StarExpr)(nil))] = &members_PtrTo_StarExpr
	GoTypes[_reflect.TypeOf((*_ast.StructType)(nil))] = &members_PtrTo_StructType
	GoTypes[_reflect.TypeOf((*_ast.SwitchStmt)(nil))] = &members_PtrTo_SwitchStmt
	GoTypes[_reflect.TypeOf((*_ast.TypeAssertExpr)(nil))] = &members_PtrTo_TypeAssertExpr
	GoTypes[_reflect.TypeOf((*_ast.TypeSpec)(nil))] = &members_PtrTo_TypeSpec
	GoTypes[_reflect.TypeOf((*_ast.TypeSwitchStmt)(nil))] = &members_PtrTo_TypeSwitchStmt
	GoTypes[_reflect.TypeOf((*_ast.UnaryExpr)(nil))] = &members_PtrTo_UnaryExpr
	GoTypes[_reflect.TypeOf((*_ast.ValueSpec)(nil))] = &members_PtrTo_ValueSpec
}

GO TYPE go/build.Context from go/build/build.go:
func ExtractGoObjectContext(args []Object, index int) *_build.Context {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.Context:
			return &r
		case *_build.Context:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.Context]"))
}

// func _mapToContext(o Map) *_build.Context {
// 	return &_build.Context{}
// }

// func _vectorToContext(o *Vector) *_build.Context {
// 	return &_build.Context{
// 		GOARCH: AssertString(o.Nth(0), "").S,
// 		GOOS: AssertString(o.Nth(1), "").S,
// 		GOROOT: AssertString(o.Nth(2), "").S,
// 		GOPATH: AssertString(o.Nth(3), "").S,
// 		CgoEnabled: ToBool(o.Nth(4)),
// 		UseAllFiles: ToBool(o.Nth(5)),
// 		Compiler: AssertString(o.Nth(6), "").S,
// 		BuildTags: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ReleaseTags: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		InstallSuffix: AssertString(o.Nth(9), "").S,
// 		JoinPath: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		SplitPathList: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		IsAbsPath: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		IsDir: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		HasSubdir: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ReadDir: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		OpenFile: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructContext(_v Object) *_build.Context {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _build.Context:
// 			return &_g
// 		case *_build.Context:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToContext(_o.(Map))
// 	case *Vector:
// 		return _vectorToContext(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[build.Context] or: Map or Vector"))
// }

GO TYPE go/build.ImportMode from go/build/build.go:
func ExtractGoObjectImportMode(args []Object, index int) *_build.ImportMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.ImportMode:
			return &r
		case *_build.ImportMode:
			return r
		}
	case Number:
		v := _build.ImportMode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.ImportMode]"))
}

func _ConstructImportMode(_v Object) _build.ImportMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.ImportMode:
			return _g
		case *_build.ImportMode:
			return *_g
		}
	case Number:
		return _build.ImportMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.ImportMode] or: Number"))
}

GO TYPE go/build.MultiplePackageError from go/build/build.go:
func ExtractGoObjectMultiplePackageError(args []Object, index int) *_build.MultiplePackageError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.MultiplePackageError:
			return &r
		case *_build.MultiplePackageError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.MultiplePackageError]"))
}

// func _mapToMultiplePackageError(o Map) *_build.MultiplePackageError {
// 	return &_build.MultiplePackageError{}
// }

// func _vectorToMultiplePackageError(o *Vector) *_build.MultiplePackageError {
// 	return &_build.MultiplePackageError{
// 		Dir: AssertString(o.Nth(0), "").S,
// 		Packages: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Files: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructMultiplePackageError(_v Object) *_build.MultiplePackageError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _build.MultiplePackageError:
// 			return &_g
// 		case *_build.MultiplePackageError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMultiplePackageError(_o.(Map))
// 	case *Vector:
// 		return _vectorToMultiplePackageError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[build.MultiplePackageError] or: Map or Vector"))
// }

GO TYPE go/build.NoGoError from go/build/build.go:
func ExtractGoObjectNoGoError(args []Object, index int) *_build.NoGoError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.NoGoError:
			return &r
		case *_build.NoGoError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.NoGoError]"))
}

func _mapToNoGoError(o Map) *_build.NoGoError {
	return &_build.NoGoError{}
}

func _vectorToNoGoError(o *Vector) *_build.NoGoError {
	return &_build.NoGoError{
		Dir: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructNoGoError(_v Object) *_build.NoGoError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _build.NoGoError:
			return &_g
		case *_build.NoGoError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNoGoError(_o.(Map))
	case *Vector:
		return _vectorToNoGoError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[build.NoGoError] or: Map or Vector"))
}

GO TYPE go/build.Package from go/build/build.go:
func ExtractGoObjectPackage(args []Object, index int) *_build.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _build.Package:
			return &r
		case *_build.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/build.Package]"))
}

// func _mapToPackage(o Map) *_build.Package {
// 	return &_build.Package{}
// }

// func _vectorToPackage(o *Vector) *_build.Package {
// 	return &_build.Package{
// 		Dir: AssertString(o.Nth(0), "").S,
// 		Name: AssertString(o.Nth(1), "").S,
// 		ImportComment: AssertString(o.Nth(2), "").S,
// 		Doc: AssertString(o.Nth(3), "").S,
// 		ImportPath: AssertString(o.Nth(4), "").S,
// 		Root: AssertString(o.Nth(5), "").S,
// 		SrcRoot: AssertString(o.Nth(6), "").S,
// 		PkgRoot: AssertString(o.Nth(7), "").S,
// 		PkgTargetRoot: AssertString(o.Nth(8), "").S,
// 		BinDir: AssertString(o.Nth(9), "").S,
// 		Goroot: ToBool(o.Nth(10)),
// 		PkgObj: AssertString(o.Nth(11), "").S,
// 		AllTags: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ConflictDir: AssertString(o.Nth(13), "").S,
// 		BinaryOnly: ToBool(o.Nth(14)),
// 		GoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		IgnoredGoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		InvalidGoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CXXFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		MFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		HFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		FFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SwigFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SwigCXXFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		SysoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoCFLAGS: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoCPPFLAGS: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoCXXFLAGS: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoFFLAGS: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoLDFLAGS: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		CgoPkgConfig: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Imports: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		ImportPos: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		TestGoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		TestImports: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		TestImportPos: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		XTestGoFiles: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		XTestImports: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		XTestImportPos: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 	}
// }

// func _ConstructPackage(_v Object) *_build.Package {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _build.Package:
// 			return &_g
// 		case *_build.Package:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPackage(_o.(Map))
// 	case *Vector:
// 		return _vectorToPackage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[build.Package] or: Map or Vector"))
// }

GO FUNC go/build.ArchChar from go/build/build.go:
func __archChar(goarch string) Object {
	_res1, _res2 := _build.ArchChar(goarch)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.Import from go/build/build.go:
func __import(path string, srcDir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.Import(path, srcDir, mode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.ImportDir from go/build/build.go:
func __importDir(dir string, mode _build.ImportMode) Object {
	_res1, _res2 := _build.ImportDir(dir, mode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.__ptrTo_Context_Import from go/build/build.go:
func __ptrTo_Context_Import(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/build.Context)Import()", args, 3, 3)
	path := ExtractGoString("(*_go/build.Context)Import()", "path", _argList, 0)
	srcDir := ExtractGoString("(*_go/build.Context)Import()", "srcDir", _argList, 1)
	mode := ExtractGo_go_std_go_build__ImportMode("(*_go/build.Context)Import()", "mode", _argList, 2)
	_res1, _res2 := o.O.(*_build.Context).Import(path, srcDir, mode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.__ptrTo_Context_ImportDir from go/build/build.go:
func __ptrTo_Context_ImportDir(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/build.Context)ImportDir()", args, 2, 2)
	dir := ExtractGoString("(*_go/build.Context)ImportDir()", "dir", _argList, 0)
	mode := ExtractGo_go_std_go_build__ImportMode("(*_go/build.Context)ImportDir()", "mode", _argList, 1)
	_res1, _res2 := o.O.(*_build.Context).ImportDir(dir, mode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.__ptrTo_Context_MatchFile from go/build/build.go:
func __ptrTo_Context_MatchFile(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/build.Context)MatchFile()", args, 2, 2)
	dir := ExtractGoString("(*_go/build.Context)MatchFile()", "dir", _argList, 0)
	name := ExtractGoString("(*_go/build.Context)MatchFile()", "name", _argList, 1)
	match, err := o.O.(*_build.Context).MatchFile(dir, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(match))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC go/build.__ptrTo_Context_SrcDirs from go/build/build.go:
func __ptrTo_Context_SrcDirs(o GoObject, args Object) Object {
	CheckGoArity("(*_go/build.Context)SrcDirs()", args, 0, 0)
	_res := o.O.(*_build.Context).SrcDirs()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC go/build.__ptrTo_MultiplePackageError_Error from go/build/build.go:
func __ptrTo_MultiplePackageError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_go/build.MultiplePackageError)Error()", args, 0, 0)
	_res := o.O.(*_build.MultiplePackageError).Error()
	return MakeString(_res)
}

GO FUNC go/build.__ptrTo_NoGoError_Error from go/build/build.go:
func __ptrTo_NoGoError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_go/build.NoGoError)Error()", args, 0, 0)
	_res := o.O.(*_build.NoGoError).Error()
	return MakeString(_res)
}

GO FUNC go/build.__ptrTo_Package_IsCommand from go/build/build.go:
func __ptrTo_Package_IsCommand(o GoObject, args Object) Object {
	CheckGoArity("(*_go/build.Package)IsCommand()", args, 0, 0)
	_res := o.O.(*_build.Package).IsCommand()
	return MakeBoolean(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package build

import (
	. "github.com/candid82/joker/core"
	_build "go/build"
	_reflect "reflect"
)
var members_PtrTo_Context = GoTypeInfo{Members: GoMembers{
	"Import": __ptrTo_Context_Import,
	"ImportDir": __ptrTo_Context_ImportDir,
	"MatchFile": __ptrTo_Context_MatchFile,
	"SrcDirs": __ptrTo_Context_SrcDirs,
}}

var members_PtrTo_MultiplePackageError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_MultiplePackageError_Error,
}}

var members_PtrTo_NoGoError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_NoGoError_Error,
}}

var members_PtrTo_Package = GoTypeInfo{Members: GoMembers{
	"IsCommand": __ptrTo_Package_IsCommand,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_build.Context)(nil))] = &members_PtrTo_Context
	GoTypes[_reflect.TypeOf((*_build.MultiplePackageError)(nil))] = &members_PtrTo_MultiplePackageError
	GoTypes[_reflect.TypeOf((*_build.NoGoError)(nil))] = &members_PtrTo_NoGoError
	GoTypes[_reflect.TypeOf((*_build.Package)(nil))] = &members_PtrTo_Package
}

GO TYPE go/constant.Kind from go/constant/value.go:
func ExtractGoObjectKind(args []Object, index int) *_constant.Kind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _constant.Kind:
			return &r
		case *_constant.Kind:
			return r
		}
	case Int:
		v := _constant.Kind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/constant.Kind]"))
}

func _ConstructKind(_v Object) _constant.Kind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _constant.Kind:
			return _g
		case *_constant.Kind:
			return *_g
		}
	case Number:
		return _constant.Kind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[constant.Kind] or: Number"))
}

GO TYPE go/constant.Value from go/constant/value.go:
func ExtractGoObjectValue(args []Object, index int) *_constant.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _constant.Value:
			return &r
		case *_constant.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/constant.Value]"))
}

// func _ConstructValue(_v Object) _constant.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _constant.Value:
// 			return _g
// 		case *_constant.Value:
// 			return *_g
// 		}
// 	default:
// 		return _constant.Value(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Value))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[constant.Value] or: whatever"))
// }

GO FUNC go/constant.BinaryOp from go/constant/value.go:
// func __binaryOp(x_ _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), y_ _constant.Value) Object {
// 	_res := _constant.BinaryOp(x_, op, y_)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.Bytes from go/constant/value.go:
func __bytes(x _constant.Value) Object {
	_res := _constant.Bytes(x)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC go/constant.Compare from go/constant/value.go:
// func __compare(x_ _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), y_ _constant.Value)  {
// 	_res := _constant.Compare(x_, op, y_)
// 	return MakeBoolean(_res)
// }

GO FUNC go/constant.Denom from go/constant/value.go:
func __denom(x _constant.Value) Object {
	_res := _constant.Denom(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Float32Val from go/constant/value.go:
// func __float32Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float32Val(x)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float32))
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC go/constant.Float64Val from go/constant/value.go:
// func __float64Val(x _constant.Value) Object {
// 	_res1, _res2 := _constant.Float64Val(x)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC go/constant.Imag from go/constant/value.go:
func __imag(x _constant.Value) Object {
	_res := _constant.Imag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Int64Val from go/constant/value.go:
func __int64Val(x _constant.Value) Object {
	_res1, _res2 := _constant.Int64Val(x)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC go/constant.MakeBool from go/constant/value.go:
func __makeBool(b bool) Object {
	_res := _constant.MakeBool(b)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeFloat64 from go/constant/value.go:
func __makeFloat64(x float64) Object {
	_res := _constant.MakeFloat64(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeFromBytes from go/constant/value.go:
// func __makeFromBytes(bytes []byte) Object {
// 	_res := _constant.MakeFromBytes(bytes)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeFromLiteral from go/constant/value.go:
// func __makeFromLiteral(lit string, tok ABEND987(genutils.go: imports not yet supported: token.Token), zero uint) Object {
// 	_res := _constant.MakeFromLiteral(lit, tok, zero)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.MakeImag from go/constant/value.go:
func __makeImag(x _constant.Value) Object {
	_res := _constant.MakeImag(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeInt64 from go/constant/value.go:
func __makeInt64(x int64) Object {
	_res := _constant.MakeInt64(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeString from go/constant/value.go:
func __makeString(s string) Object {
	_res := _constant.MakeString(s)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeUint64 from go/constant/value.go:
func __makeUint64(x uint64) Object {
	_res := _constant.MakeUint64(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.MakeUnknown from go/constant/value.go:
func __makeUnknown() Object {
	_res := _constant.MakeUnknown()
	return MakeGoObject(_res)
}

GO FUNC go/constant.Num from go/constant/value.go:
func __num(x _constant.Value) Object {
	_res := _constant.Num(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Real from go/constant/value.go:
func __real(x _constant.Value) Object {
	_res := _constant.Real(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Shift from go/constant/value.go:
// func __shift(x _constant.Value, op ABEND987(genutils.go: imports not yet supported: token.Token), s uint) Object {
// 	_res := _constant.Shift(x, op, s)
// 	return MakeGoObject(_res)
// }

GO FUNC go/constant.ToComplex from go/constant/value.go:
func __toComplex(x _constant.Value) Object {
	_res := _constant.ToComplex(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToFloat from go/constant/value.go:
func __toFloat(x _constant.Value) Object {
	_res := _constant.ToFloat(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.ToInt from go/constant/value.go:
func __toInt(x _constant.Value) Object {
	_res := _constant.ToInt(x)
	return MakeGoObject(_res)
}

GO FUNC go/constant.Uint64Val from go/constant/value.go:
func __uint64Val(x _constant.Value) Object {
	_res1, _res2 := _constant.Uint64Val(x)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC go/constant.UnaryOp from go/constant/value.go:
// func __unaryOp(op ABEND987(genutils.go: imports not yet supported: token.Token), y _constant.Value, prec uint) Object {
// 	_res := _constant.UnaryOp(op, y, prec)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package constant

import (
	. "github.com/candid82/joker/core"
	_constant "go/constant"
)

func init() {
}

GO TYPE go/doc.Example from go/doc/example.go:
func ExtractGoObjectExample(args []Object, index int) *_doc.Example {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Example:
			return &r
		case *_doc.Example:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Example]"))
}

// func _mapToExample(o Map) *_doc.Example {
// 	return &_doc.Example{}
// }

// func _vectorToExample(o *Vector) *_doc.Example {
// 	return &_doc.Example{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Doc: AssertString(o.Nth(1), "").S,
// 		Code: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Play: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Comments: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Output: AssertString(o.Nth(5), "").S,
// 		Unordered: ToBool(o.Nth(6)),
// 		EmptyOutput: ToBool(o.Nth(7)),
// 		Order: AssertInt(o.Nth(8), "").I,
// 	}
// }

// func _ConstructExample(_v Object) *_doc.Example {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Example:
// 			return &_g
// 		case *_doc.Example:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToExample(_o.(Map))
// 	case *Vector:
// 		return _vectorToExample(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Example] or: Map or Vector"))
// }

GO TYPE go/doc.Filter from go/doc/filter.go:
func ExtractGoObjectFilter(args []Object, index int) *_doc.Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Filter:
			return &r
		case *_doc.Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Filter]"))
}

// func _ConstructFilter(_v Object) _doc.Filter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Filter:
// 			return _g
// 		case *_doc.Filter:
// 			return *_g
// 		}
// 	default:
// 		return _doc.Filter(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Filter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Filter] or: whatever"))
// }

GO TYPE go/doc.Func from go/doc/doc.go:
func ExtractGoObjectFunc(args []Object, index int) *_doc.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Func:
			return &r
		case *_doc.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Func]"))
}

// func _mapToFunc(o Map) *_doc.Func {
// 	return &_doc.Func{}
// }

// func _vectorToFunc(o *Vector) *_doc.Func {
// 	return &_doc.Func{
// 		Doc: AssertString(o.Nth(0), "").S,
// 		Name: AssertString(o.Nth(1), "").S,
// 		Decl: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Recv: AssertString(o.Nth(3), "").S,
// 		Orig: AssertString(o.Nth(4), "").S,
// 		Level: AssertInt(o.Nth(5), "").I,
// 	}
// }

// func _ConstructFunc(_v Object) *_doc.Func {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Func:
// 			return &_g
// 		case *_doc.Func:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFunc(_o.(Map))
// 	case *Vector:
// 		return _vectorToFunc(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Func] or: Map or Vector"))
// }

GO TYPE go/doc.Mode from go/doc/doc.go:
func ExtractGoObjectMode(args []Object, index int) *_doc.Mode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Mode:
			return &r
		case *_doc.Mode:
			return r
		}
	case Int:
		v := _doc.Mode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Mode]"))
}

func _ConstructMode(_v Object) _doc.Mode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _doc.Mode:
			return _g
		case *_doc.Mode:
			return *_g
		}
	case Number:
		return _doc.Mode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Mode] or: Number"))
}

GO TYPE go/doc.Note from go/doc/doc.go:
func ExtractGoObjectNote(args []Object, index int) *_doc.Note {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Note:
			return &r
		case *_doc.Note:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Note]"))
}

// func _mapToNote(o Map) *_doc.Note {
// 	return &_doc.Note{}
// }

// func _vectorToNote(o *Vector) *_doc.Note {
// 	return &_doc.Note{
// 		Pos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		End: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		UID: AssertString(o.Nth(2), "").S,
// 		Body: AssertString(o.Nth(3), "").S,
// 	}
// }

// func _ConstructNote(_v Object) *_doc.Note {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Note:
// 			return &_g
// 		case *_doc.Note:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNote(_o.(Map))
// 	case *Vector:
// 		return _vectorToNote(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Note] or: Map or Vector"))
// }

GO TYPE go/doc.Package from go/doc/doc.go:
func ExtractGoObjectPackage(args []Object, index int) *_doc.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Package:
			return &r
		case *_doc.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Package]"))
}

// func _mapToPackage(o Map) *_doc.Package {
// 	return &_doc.Package{}
// }

// func _vectorToPackage(o *Vector) *_doc.Package {
// 	return &_doc.Package{
// 		Doc: AssertString(o.Nth(0), "").S,
// 		Name: AssertString(o.Nth(1), "").S,
// 		ImportPath: AssertString(o.Nth(2), "").S,
// 		Imports: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Filenames: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Notes: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Bugs: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Consts: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Value (*go/doc.Value)),
// 		Types: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Type (*go/doc.Type)),
// 		Vars: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Value (*go/doc.Value)),
// 		Funcs: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Func (*go/doc.Func)),
// 	}
// }

// func _ConstructPackage(_v Object) *_doc.Package {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Package:
// 			return &_g
// 		case *_doc.Package:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPackage(_o.(Map))
// 	case *Vector:
// 		return _vectorToPackage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Package] or: Map or Vector"))
// }

GO TYPE go/doc.Type from go/doc/doc.go:
func ExtractGoObjectType(args []Object, index int) *_doc.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Type:
			return &r
		case *_doc.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Type]"))
}

// func _mapToType(o Map) *_doc.Type {
// 	return &_doc.Type{}
// }

// func _vectorToType(o *Vector) *_doc.Type {
// 	return &_doc.Type{
// 		Doc: AssertString(o.Nth(0), "").S,
// 		Name: AssertString(o.Nth(1), "").S,
// 		Decl: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Consts: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Value (*go/doc.Value)),
// 		Vars: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Value (*go/doc.Value)),
// 		Funcs: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Func (*go/doc.Func)),
// 		Methods: ABEND048(codegen.go: no conversion from Clojure for []*go/doc.Func (*go/doc.Func)),
// 	}
// }

// func _ConstructType(_v Object) *_doc.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Type:
// 			return &_g
// 		case *_doc.Type:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToType(_o.(Map))
// 	case *Vector:
// 		return _vectorToType(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Type] or: Map or Vector"))
// }

GO TYPE go/doc.Value from go/doc/doc.go:
func ExtractGoObjectValue(args []Object, index int) *_doc.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _doc.Value:
			return &r
		case *_doc.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/doc.Value]"))
}

// func _mapToValue(o Map) *_doc.Value {
// 	return &_doc.Value{}
// }

// func _vectorToValue(o *Vector) *_doc.Value {
// 	return &_doc.Value{
// 		Doc: AssertString(o.Nth(0), "").S,
// 		Names: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Decl: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructValue(_v Object) *_doc.Value {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _doc.Value:
// 			return &_g
// 		case *_doc.Value:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[doc.Value] or: Map or Vector"))
// }

GO FUNC go/doc.Examples from go/doc/example.go:
// func __examples(files ...*ABEND987(genutils.go: imports not yet supported: ast.File)) Object {
// 	_res := _doc.Examples(files)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC go/doc.New from go/doc/doc.go:
// func __new(pkg *ABEND987(genutils.go: imports not yet supported: ast.Package), importPath string, mode _doc.Mode) Object {
// 	_res := _doc.New(pkg, importPath, mode)
// 	return MakeGoObject(_res)
// }

GO FUNC go/doc.ToHTML from go/doc/comment.go:
// func __toHTML(w ABEND987(genutils.go: imports not yet supported: io.Writer), text string, words map[]) Object {
// 	_doc.ToHTML(w, text, words)
// 	...ABEND675: TODO...
// }

GO FUNC go/doc.ToText from go/doc/comment.go:
// func __toText(w ABEND987(genutils.go: imports not yet supported: io.Writer), text string, indent string, preIndent string, width int) Object {
// 	_doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND675: TODO...
// }

GO FUNC go/doc.__ptrTo_Package_Filter from go/doc/filter.go:
// func __ptrTo_Package_Filter(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package doc

import (
	. "github.com/candid82/joker/core"
	_doc "go/doc"
)

func init() {
}

GO FUNC go/format.Node from go/format/format.go:
// func __node(dst ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node interface {})  {
// 	_res := _format.Node(dst, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/format.Source from go/format/format.go:
// func __source(src []byte) Object {
// 	_res1, _res2 := _format.Source(src)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO TYPE go/importer.Lookup from go/importer/importer.go:
func ExtractGoObjectLookup(args []Object, index int) *_importer.Lookup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _importer.Lookup:
			return &r
		case *_importer.Lookup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/importer.Lookup]"))
}

// func _ConstructLookup(_v Object) _importer.Lookup {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _importer.Lookup:
// 			return _g
// 		case *_importer.Lookup:
// 			return *_g
// 		}
// 	default:
// 		return _importer.Lookup(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Lookup))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[importer.Lookup] or: whatever"))
// }

GO FUNC go/importer.Default from go/importer/importer.go:
func __default() Object {
	_res := _importer.Default()
	return MakeGoObject(_res)
}

GO FUNC go/importer.For from go/importer/importer.go:
func __for(compiler string, lookup _importer.Lookup) Object {
	_res := _importer.For(compiler, lookup)
	return MakeGoObject(_res)
}

GO FUNC go/importer.ForCompiler from go/importer/importer.go:
// func __forCompiler(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), compiler string, lookup _importer.Lookup) Object {
// 	_res := _importer.ForCompiler(fset, compiler, lookup)
// 	return MakeGoObject(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package importer

import (
	. "github.com/candid82/joker/core"
	_importer "go/importer"
)

func init() {
}

GO TYPE go/parser.Mode from go/parser/interface.go:
func ExtractGoObjectMode(args []Object, index int) *_parser.Mode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parser.Mode:
			return &r
		case *_parser.Mode:
			return r
		}
	case Number:
		v := _parser.Mode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/parser.Mode]"))
}

func _ConstructMode(_v Object) _parser.Mode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parser.Mode:
			return _g
		case *_parser.Mode:
			return *_g
		}
	case Number:
		return _parser.Mode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parser.Mode] or: Number"))
}

GO FUNC go/parser.ParseDir from go/parser/interface.go:
// func __parseDir(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), path string, filter func, mode _parser.Mode) Object {
// 	pkgs, first := _parser.ParseDir(fset, path, filter, mode)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(pkgs)
// 	_res = _res.Conjoin(func () Object { if (first) == nil { return NIL } else { return MakeError(first) } }())
// 	return _res
// }

GO FUNC go/parser.ParseExpr from go/parser/interface.go:
func __parseExpr(x string) Object {
	_res1, _res2 := _parser.ParseExpr(x)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/parser.ParseExprFrom from go/parser/interface.go:
// func __parseExprFrom(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), filename string, src interface {}, mode _parser.Mode) Object {
// 	_res1, _res2 := _parser.ParseExprFrom(fset, filename, src, mode)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/parser.ParseFile from go/parser/interface.go:
// func __parseFile(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), filename string, src interface {}, mode _parser.Mode) Object {
// 	f, err := _parser.ParseFile(fset, filename, src, mode)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(f))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parser

import (
	. "github.com/candid82/joker/core"
	_parser "go/parser"
)

func init() {
}

GO FUNC go/printer.Fprint from go/printer/printer.go:
// func __fprint(output ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node interface {})  {
// 	_res := _printer.Fprint(output, fset, node)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC go/printer.__ptrTo_Config_Fprint from go/printer/printer.go:
// func __ptrTo_Config_Fprint(o GoObject, args Object) Object {
// output ABEND987(genutils.go: imports not yet supported: io.Writer), fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), node interface {}}

GO TYPE go/scanner.Error from go/scanner/errors.go:
func ExtractGoObjectError(args []Object, index int) *_scanner.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.Error:
			return &r
		case *_scanner.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/scanner.Error]"))
}

// func _mapToError(o Map) *_scanner.Error {
// 	return &_scanner.Error{}
// }

// func _vectorToError(o *Vector) *_scanner.Error {
// 	return &_scanner.Error{
// 		Pos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Msg: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructError(_v Object) *_scanner.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _scanner.Error:
// 			return &_g
// 		case *_scanner.Error:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToError(_o.(Map))
// 	case *Vector:
// 		return _vectorToError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.Error] or: Map or Vector"))
// }

GO TYPE go/scanner.ErrorHandler from go/scanner/scanner.go:
func ExtractGoObjectErrorHandler(args []Object, index int) *_scanner.ErrorHandler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.ErrorHandler:
			return &r
		case *_scanner.ErrorHandler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/scanner.ErrorHandler]"))
}

// func _ConstructErrorHandler(_v Object) _scanner.ErrorHandler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _scanner.ErrorHandler:
// 			return _g
// 		case *_scanner.ErrorHandler:
// 			return *_g
// 		}
// 	default:
// 		return _scanner.ErrorHandler(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for ErrorHandler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.ErrorHandler] or: whatever"))
// }

GO TYPE go/scanner.ErrorList from go/scanner/errors.go:
func ExtractGoObjectErrorList(args []Object, index int) *_scanner.ErrorList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.ErrorList:
			return &r
		case *_scanner.ErrorList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/scanner.ErrorList]"))
}

// func _ConstructErrorList(_v Object) _scanner.ErrorList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _scanner.ErrorList:
// 			return _g
// 		case *_scanner.ErrorList:
// 			return *_g
// 		}
// 	default:
// 		return _scanner.ErrorList(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for ErrorList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.ErrorList] or: whatever"))
// }

GO TYPE go/scanner.Mode from go/scanner/scanner.go:
func ExtractGoObjectMode(args []Object, index int) *_scanner.Mode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.Mode:
			return &r
		case *_scanner.Mode:
			return r
		}
	case Number:
		v := _scanner.Mode(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/scanner.Mode]"))
}

func _ConstructMode(_v Object) _scanner.Mode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _scanner.Mode:
			return _g
		case *_scanner.Mode:
			return *_g
		}
	case Number:
		return _scanner.Mode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.Mode] or: Number"))
}

GO TYPE go/scanner.Scanner from go/scanner/scanner.go:
func ExtractGoObjectScanner(args []Object, index int) *_scanner.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.Scanner:
			return &r
		case *_scanner.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/scanner.Scanner]"))
}

func _mapToScanner(o Map) *_scanner.Scanner {
	return &_scanner.Scanner{}
}

func _vectorToScanner(o *Vector) *_scanner.Scanner {
	return &_scanner.Scanner{
		ErrorCount: AssertInt(o.Nth(0), "").I,
	}
}

func _ConstructScanner(_v Object) *_scanner.Scanner {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _scanner.Scanner:
			return &_g
		case *_scanner.Scanner:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScanner(_o.(Map))
	case *Vector:
		return _vectorToScanner(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.Scanner] or: Map or Vector"))
}

GO FUNC go/scanner.PrintError from go/scanner/errors.go:
// func __printError(w ABEND987(genutils.go: imports not yet supported: io.Writer), err error) Object {
// 	_scanner.PrintError(w, err)
// 	...ABEND675: TODO...
// }

GO FUNC go/scanner.__errorList_Err from go/scanner/errors.go:
func __errorList_Err(o GoObject, args Object) Object {
	CheckGoArity("(_go/scanner.ErrorList)Err()", args, 0, 0)
	_res := o.O.(_scanner.ErrorList).Err()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC go/scanner.__errorList_Error from go/scanner/errors.go:
func __errorList_Error(o GoObject, args Object) Object {
	CheckGoArity("(_go/scanner.ErrorList)Error()", args, 0, 0)
	_res := o.O.(_scanner.ErrorList).Error()
	return MakeString(_res)
}

GO FUNC go/scanner.__errorList_Len from go/scanner/errors.go:
func __errorList_Len(o GoObject, args Object) Object {
	CheckGoArity("(_go/scanner.ErrorList)Len()", args, 0, 0)
	_res := o.O.(_scanner.ErrorList).Len()
	return MakeInt(_res)
}

GO FUNC go/scanner.__errorList_Less from go/scanner/errors.go:
func __errorList_Less(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_go/scanner.ErrorList)Less()", args, 2, 2)
	i := ExtractGoInt("(_go/scanner.ErrorList)Less()", "i", _argList, 0)
	j := ExtractGoInt("(_go/scanner.ErrorList)Less()", "j", _argList, 1)
	_res := o.O.(_scanner.ErrorList).Less(i, j)
	return MakeBoolean(_res)
}

GO FUNC go/scanner.__errorList_Sort from go/scanner/errors.go:
// func __errorList_Sort(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/scanner.__errorList_Swap from go/scanner/errors.go:
// func __errorList_Swap(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/scanner.__error_Error from go/scanner/errors.go:
func __error_Error(o GoObject, args Object) Object {
	CheckGoArity("(_go/scanner.Error)Error()", args, 0, 0)
	_res := o.O.(_scanner.Error).Error()
	return MakeString(_res)
}

GO FUNC go/scanner.__ptrTo_ErrorList_Add from go/scanner/errors.go:
// func __ptrTo_ErrorList_Add(o GoObject, args Object) Object {
// pos ABEND987(genutils.go: imports not yet supported: token.Position), msg string}

GO FUNC go/scanner.__ptrTo_ErrorList_RemoveMultiples from go/scanner/errors.go:
// func __ptrTo_ErrorList_RemoveMultiples(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/scanner.__ptrTo_ErrorList_Reset from go/scanner/errors.go:
// func __ptrTo_ErrorList_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/scanner.__ptrTo_Scanner_Init from go/scanner/scanner.go:
// func __ptrTo_Scanner_Init(o GoObject, args Object) Object {
// file *ABEND987(genutils.go: imports not yet supported: token.File), src []byte, err _scanner.ErrorHandler, mode _scanner.Mode}

GO FUNC go/scanner.__ptrTo_Scanner_Scan from go/scanner/scanner.go:
func __ptrTo_Scanner_Scan(o GoObject, args Object) Object {
	CheckGoArity("(*_go/scanner.Scanner)Scan()", args, 0, 0)
	pos, tok, lit := o.O.(*_scanner.Scanner).Scan()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(pos))
	_res = _res.Conjoin(MakeGoObject(tok))
	_res = _res.Conjoin(MakeString(lit))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package scanner

import (
	. "github.com/candid82/joker/core"
	_scanner "go/scanner"
	_reflect "reflect"
)
var members_Error = GoTypeInfo{Members: GoMembers{
	"Error": __error_Error,
}}

var members_ErrorList = GoTypeInfo{Members: GoMembers{
	"Err": __errorList_Err,
	"Error": __errorList_Error,
	"Len": __errorList_Len,
	"Less": __errorList_Less,
}}

var members_PtrTo_Scanner = GoTypeInfo{Members: GoMembers{
	"Scan": __ptrTo_Scanner_Scan,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_scanner.Error)(nil)).Elem()] = &members_Error
	GoTypes[_reflect.TypeOf((*_scanner.ErrorList)(nil)).Elem()] = &members_ErrorList
	GoTypes[_reflect.TypeOf((*_scanner.Scanner)(nil))] = &members_PtrTo_Scanner
}

GO TYPE go/token.File from go/token/position.go:
func ExtractGoObjectFile(args []Object, index int) *_token.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.File:
			return &r
		case *_token.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.File]"))
}

func _mapToFile(o Map) *_token.File {
	return &_token.File{}
}

func _vectorToFile(o *Vector) *_token.File {
	return &_token.File{}
}

func _ConstructFile(_v Object) *_token.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.File:
			return &_g
		case *_token.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.File] or: Map or Vector"))
}

GO TYPE go/token.FileSet from go/token/position.go:
func ExtractGoObjectFileSet(args []Object, index int) *_token.FileSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.FileSet:
			return &r
		case *_token.FileSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.FileSet]"))
}

func _mapToFileSet(o Map) *_token.FileSet {
	return &_token.FileSet{}
}

func _vectorToFileSet(o *Vector) *_token.FileSet {
	return &_token.FileSet{}
}

func _ConstructFileSet(_v Object) *_token.FileSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.FileSet:
			return &_g
		case *_token.FileSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFileSet(_o.(Map))
	case *Vector:
		return _vectorToFileSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.FileSet] or: Map or Vector"))
}

GO TYPE go/token.Pos from go/token/position.go:
func ExtractGoObjectPos(args []Object, index int) *_token.Pos {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Pos:
			return &r
		case *_token.Pos:
			return r
		}
	case Int:
		v := _token.Pos(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Pos]"))
}

func _ConstructPos(_v Object) _token.Pos {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Pos:
			return _g
		case *_token.Pos:
			return *_g
		}
	case Number:
		return _token.Pos(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Pos] or: Number"))
}

GO TYPE go/token.Position from go/token/position.go:
func ExtractGoObjectPosition(args []Object, index int) *_token.Position {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Position:
			return &r
		case *_token.Position:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Position]"))
}

func _mapToPosition(o Map) *_token.Position {
	return &_token.Position{}
}

func _vectorToPosition(o *Vector) *_token.Position {
	return &_token.Position{
		Filename: AssertString(o.Nth(0), "").S,
		Offset: AssertInt(o.Nth(1), "").I,
		Line: AssertInt(o.Nth(2), "").I,
		Column: AssertInt(o.Nth(3), "").I,
	}
}

func _ConstructPosition(_v Object) *_token.Position {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Position:
			return &_g
		case *_token.Position:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPosition(_o.(Map))
	case *Vector:
		return _vectorToPosition(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Position] or: Map or Vector"))
}

GO TYPE go/token.Token from go/token/token.go:
func ExtractGoObjectToken(args []Object, index int) *_token.Token {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _token.Token:
			return &r
		case *_token.Token:
			return r
		}
	case Int:
		v := _token.Token(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/token.Token]"))
}

func _ConstructToken(_v Object) _token.Token {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _token.Token:
			return _g
		case *_token.Token:
			return *_g
		}
	case Number:
		return _token.Token(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[token.Token] or: Number"))
}

GO FUNC go/token.Lookup from go/token/token.go:
func __lookup(ident string) Object {
	_res := _token.Lookup(ident)
	return MakeGoObject(_res)
}

GO FUNC go/token.NewFileSet from go/token/position.go:
func __newFileSet() Object {
	_res := _token.NewFileSet()
	return MakeGoObject(_res)
}

GO FUNC go/token.__pos_IsValid from go/token/position.go:
func __pos_IsValid(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Pos)IsValid()", args, 0, 0)
	_res := o.O.(_token.Pos).IsValid()
	return MakeBoolean(_res)
}

GO FUNC go/token.__position_String from go/token/position.go:
func __position_String(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Position)String()", args, 0, 0)
	_res := o.O.(_token.Position).String()
	return MakeString(_res)
}

GO FUNC go/token.__ptrTo_FileSet_AddFile from go/token/position.go:
func __ptrTo_FileSet_AddFile(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.FileSet)AddFile()", args, 3, 3)
	filename := ExtractGoString("(*_go/token.FileSet)AddFile()", "filename", _argList, 0)
	base := ExtractGoInt("(*_go/token.FileSet)AddFile()", "base", _argList, 1)
	size := ExtractGoInt("(*_go/token.FileSet)AddFile()", "size", _argList, 2)
	_res := o.O.(*_token.FileSet).AddFile(filename, base, size)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_FileSet_Base from go/token/position.go:
func __ptrTo_FileSet_Base(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.FileSet)Base()", args, 0, 0)
	_res := o.O.(*_token.FileSet).Base()
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_FileSet_File from go/token/position.go:
func __ptrTo_FileSet_File(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.FileSet)File()", args, 1, 1)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.FileSet)File()", "p", _argList, 0)
	_res := o.O.(*_token.FileSet).File(p)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_FileSet_Iterate from go/token/position.go:
// func __ptrTo_FileSet_Iterate(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC go/token.__ptrTo_FileSet_Position from go/token/position.go:
func __ptrTo_FileSet_Position(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.FileSet)Position()", args, 1, 1)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.FileSet)Position()", "p", _argList, 0)
	_res := o.O.(*_token.FileSet).Position(p)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_FileSet_PositionFor from go/token/position.go:
func __ptrTo_FileSet_PositionFor(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.FileSet)PositionFor()", args, 2, 2)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.FileSet)PositionFor()", "p", _argList, 0)
	adjusted := ExtractGoBoolean("(*_go/token.FileSet)PositionFor()", "adjusted", _argList, 1)
	_res := o.O.(*_token.FileSet).PositionFor(p, adjusted)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_FileSet_Read from go/token/serialize.go:
// func __ptrTo_FileSet_Read(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC go/token.__ptrTo_FileSet_Write from go/token/serialize.go:
// func __ptrTo_FileSet_Write(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC go/token.__ptrTo_File_AddLine from go/token/position.go:
// func __ptrTo_File_AddLine(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/token.__ptrTo_File_AddLineColumnInfo from go/token/position.go:
// func __ptrTo_File_AddLineColumnInfo(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/token.__ptrTo_File_AddLineInfo from go/token/position.go:
// func __ptrTo_File_AddLineInfo(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/token.__ptrTo_File_Base from go/token/position.go:
func __ptrTo_File_Base(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.File)Base()", args, 0, 0)
	_res := o.O.(*_token.File).Base()
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_File_Line from go/token/position.go:
func __ptrTo_File_Line(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)Line()", args, 1, 1)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.File)Line()", "p", _argList, 0)
	_res := o.O.(*_token.File).Line(p)
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_File_LineCount from go/token/position.go:
func __ptrTo_File_LineCount(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.File)LineCount()", args, 0, 0)
	_res := o.O.(*_token.File).LineCount()
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_File_LineStart from go/token/position.go:
func __ptrTo_File_LineStart(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)LineStart()", args, 1, 1)
	line := ExtractGoInt("(*_go/token.File)LineStart()", "line", _argList, 0)
	_res := o.O.(*_token.File).LineStart(line)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_File_MergeLine from go/token/position.go:
// func __ptrTo_File_MergeLine(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/token.__ptrTo_File_Name from go/token/position.go:
func __ptrTo_File_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.File)Name()", args, 0, 0)
	_res := o.O.(*_token.File).Name()
	return MakeString(_res)
}

GO FUNC go/token.__ptrTo_File_Offset from go/token/position.go:
func __ptrTo_File_Offset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)Offset()", args, 1, 1)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.File)Offset()", "p", _argList, 0)
	_res := o.O.(*_token.File).Offset(p)
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_File_Pos from go/token/position.go:
func __ptrTo_File_Pos(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)Pos()", args, 1, 1)
	offset := ExtractGoInt("(*_go/token.File)Pos()", "offset", _argList, 0)
	_res := o.O.(*_token.File).Pos(offset)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_File_Position from go/token/position.go:
func __ptrTo_File_Position(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)Position()", args, 1, 1)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.File)Position()", "p", _argList, 0)
	_res := o.O.(*_token.File).Position(p)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_File_PositionFor from go/token/position.go:
func __ptrTo_File_PositionFor(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/token.File)PositionFor()", args, 2, 2)
	p := ExtractGo_go_std_go_token__Pos("(*_go/token.File)PositionFor()", "p", _argList, 0)
	adjusted := ExtractGoBoolean("(*_go/token.File)PositionFor()", "adjusted", _argList, 1)
	_res := o.O.(*_token.File).PositionFor(p, adjusted)
	return MakeGoObject(_res)
}

GO FUNC go/token.__ptrTo_File_SetLines from go/token/position.go:
// func __ptrTo_File_SetLines(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(lines)))}

GO FUNC go/token.__ptrTo_File_SetLinesForContent from go/token/position.go:
// func __ptrTo_File_SetLinesForContent(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(content)))}

GO FUNC go/token.__ptrTo_File_Size from go/token/position.go:
func __ptrTo_File_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.File)Size()", args, 0, 0)
	_res := o.O.(*_token.File).Size()
	return MakeInt(_res)
}

GO FUNC go/token.__ptrTo_Position_IsValid from go/token/position.go:
func __ptrTo_Position_IsValid(o GoObject, args Object) Object {
	CheckGoArity("(*_go/token.Position)IsValid()", args, 0, 0)
	_res := o.O.(*_token.Position).IsValid()
	return MakeBoolean(_res)
}

GO FUNC go/token.__token_IsKeyword from go/token/token.go:
func __token_IsKeyword(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Token)IsKeyword()", args, 0, 0)
	_res := o.O.(_token.Token).IsKeyword()
	return MakeBoolean(_res)
}

GO FUNC go/token.__token_IsLiteral from go/token/token.go:
func __token_IsLiteral(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Token)IsLiteral()", args, 0, 0)
	_res := o.O.(_token.Token).IsLiteral()
	return MakeBoolean(_res)
}

GO FUNC go/token.__token_IsOperator from go/token/token.go:
func __token_IsOperator(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Token)IsOperator()", args, 0, 0)
	_res := o.O.(_token.Token).IsOperator()
	return MakeBoolean(_res)
}

GO FUNC go/token.__token_Precedence from go/token/token.go:
func __token_Precedence(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Token)Precedence()", args, 0, 0)
	_res := o.O.(_token.Token).Precedence()
	return MakeInt(_res)
}

GO FUNC go/token.__token_String from go/token/token.go:
func __token_String(o GoObject, args Object) Object {
	CheckGoArity("(_go/token.Token)String()", args, 0, 0)
	_res := o.O.(_token.Token).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package token

import (
	. "github.com/candid82/joker/core"
	_token "go/token"
	_reflect "reflect"
)
var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Base": __ptrTo_File_Base,
	"Line": __ptrTo_File_Line,
	"LineCount": __ptrTo_File_LineCount,
	"LineStart": __ptrTo_File_LineStart,
	"Name": __ptrTo_File_Name,
	"Offset": __ptrTo_File_Offset,
	"Pos": __ptrTo_File_Pos,
	"Position": __ptrTo_File_Position,
	"PositionFor": __ptrTo_File_PositionFor,
	"Size": __ptrTo_File_Size,
}}

var members_PtrTo_FileSet = GoTypeInfo{Members: GoMembers{
	"AddFile": __ptrTo_FileSet_AddFile,
	"Base": __ptrTo_FileSet_Base,
	"File": __ptrTo_FileSet_File,
	"Position": __ptrTo_FileSet_Position,
	"PositionFor": __ptrTo_FileSet_PositionFor,
}}

var members_Pos = GoTypeInfo{Members: GoMembers{
	"IsValid": __pos_IsValid,
}}

var members_PtrTo_Position = GoTypeInfo{Members: GoMembers{
	"IsValid": __ptrTo_Position_IsValid,
}}

var members_Position = GoTypeInfo{Members: GoMembers{
	"String": __position_String,
}}

var members_Token = GoTypeInfo{Members: GoMembers{
	"IsKeyword": __token_IsKeyword,
	"IsLiteral": __token_IsLiteral,
	"IsOperator": __token_IsOperator,
	"Precedence": __token_Precedence,
	"String": __token_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_token.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_token.FileSet)(nil))] = &members_PtrTo_FileSet
	GoTypes[_reflect.TypeOf((*_token.Pos)(nil)).Elem()] = &members_Pos
	GoTypes[_reflect.TypeOf((*_token.Position)(nil))] = &members_PtrTo_Position
	GoTypes[_reflect.TypeOf((*_token.Position)(nil)).Elem()] = &members_Position
	GoTypes[_reflect.TypeOf((*_token.Token)(nil)).Elem()] = &members_Token
}

GO TYPE go/types.Array from go/types/type.go:
func ExtractGoObjectArray(args []Object, index int) *_types.Array {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Array:
			return &r
		case *_types.Array:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Array]"))
}

func _mapToArray(o Map) *_types.Array {
	return &_types.Array{}
}

func _vectorToArray(o *Vector) *_types.Array {
	return &_types.Array{}
}

func _ConstructArray(_v Object) *_types.Array {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Array:
			return &_g
		case *_types.Array:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToArray(_o.(Map))
	case *Vector:
		return _vectorToArray(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Array] or: Map or Vector"))
}

GO TYPE go/types.Basic from go/types/type.go:
func ExtractGoObjectBasic(args []Object, index int) *_types.Basic {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Basic:
			return &r
		case *_types.Basic:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Basic]"))
}

func _mapToBasic(o Map) *_types.Basic {
	return &_types.Basic{}
}

func _vectorToBasic(o *Vector) *_types.Basic {
	return &_types.Basic{}
}

func _ConstructBasic(_v Object) *_types.Basic {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Basic:
			return &_g
		case *_types.Basic:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBasic(_o.(Map))
	case *Vector:
		return _vectorToBasic(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Basic] or: Map or Vector"))
}

GO TYPE go/types.BasicInfo from go/types/type.go:
func ExtractGoObjectBasicInfo(args []Object, index int) *_types.BasicInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.BasicInfo:
			return &r
		case *_types.BasicInfo:
			return r
		}
	case Int:
		v := _types.BasicInfo(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.BasicInfo]"))
}

func _ConstructBasicInfo(_v Object) _types.BasicInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.BasicInfo:
			return _g
		case *_types.BasicInfo:
			return *_g
		}
	case Number:
		return _types.BasicInfo(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.BasicInfo] or: Number"))
}

GO TYPE go/types.BasicKind from go/types/type.go:
func ExtractGoObjectBasicKind(args []Object, index int) *_types.BasicKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.BasicKind:
			return &r
		case *_types.BasicKind:
			return r
		}
	case Int:
		v := _types.BasicKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.BasicKind]"))
}

func _ConstructBasicKind(_v Object) _types.BasicKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.BasicKind:
			return _g
		case *_types.BasicKind:
			return *_g
		}
	case Number:
		return _types.BasicKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.BasicKind] or: Number"))
}

GO TYPE go/types.Builtin from go/types/object.go:
func ExtractGoObjectBuiltin(args []Object, index int) *_types.Builtin {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Builtin:
			return &r
		case *_types.Builtin:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Builtin]"))
}

func _mapToBuiltin(o Map) *_types.Builtin {
	return &_types.Builtin{}
}

func _vectorToBuiltin(o *Vector) *_types.Builtin {
	return &_types.Builtin{}
}

func _ConstructBuiltin(_v Object) *_types.Builtin {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Builtin:
			return &_g
		case *_types.Builtin:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuiltin(_o.(Map))
	case *Vector:
		return _vectorToBuiltin(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Builtin] or: Map or Vector"))
}

GO TYPE go/types.Chan from go/types/type.go:
func ExtractGoObjectChan(args []Object, index int) *_types.Chan {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Chan:
			return &r
		case *_types.Chan:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Chan]"))
}

func _mapToChan(o Map) *_types.Chan {
	return &_types.Chan{}
}

func _vectorToChan(o *Vector) *_types.Chan {
	return &_types.Chan{}
}

func _ConstructChan(_v Object) *_types.Chan {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Chan:
			return &_g
		case *_types.Chan:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChan(_o.(Map))
	case *Vector:
		return _vectorToChan(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Chan] or: Map or Vector"))
}

GO TYPE go/types.ChanDir from go/types/type.go:
func ExtractGoObjectChanDir(args []Object, index int) *_types.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ChanDir:
			return &r
		case *_types.ChanDir:
			return r
		}
	case Int:
		v := _types.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ChanDir]"))
}

func _ConstructChanDir(_v Object) _types.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.ChanDir:
			return _g
		case *_types.ChanDir:
			return *_g
		}
	case Number:
		return _types.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ChanDir] or: Number"))
}

GO TYPE go/types.Checker from go/types/check.go:
func ExtractGoObjectChecker(args []Object, index int) *_types.Checker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Checker:
			return &r
		case *_types.Checker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Checker]"))
}

func _mapToChecker(o Map) *_types.Checker {
	return &_types.Checker{}
}

func _vectorToChecker(o *Vector) *_types.Checker {
	return &_types.Checker{}
}

func _ConstructChecker(_v Object) *_types.Checker {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Checker:
			return &_g
		case *_types.Checker:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToChecker(_o.(Map))
	case *Vector:
		return _vectorToChecker(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Checker] or: Map or Vector"))
}

GO TYPE go/types.Config from go/types/api.go:
func ExtractGoObjectConfig(args []Object, index int) *_types.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Config:
			return &r
		case *_types.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Config]"))
}

// func _mapToConfig(o Map) *_types.Config {
// 	return &_types.Config{}
// }

// func _vectorToConfig(o *Vector) *_types.Config {
// 	return &_types.Config{
// 		IgnoreFuncBodies: ToBool(o.Nth(0)),
// 		FakeImportC: ToBool(o.Nth(1)),
// 		Error: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Importer: ABEND048(codegen.go: no conversion from Clojure for go/types.Importer (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Sizes: ABEND048(codegen.go: no conversion from Clojure for go/types.Sizes (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		DisableUnusedImportCheck: ToBool(o.Nth(5)),
// 	}
// }

// func _ConstructConfig(_v Object) *_types.Config {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Config:
// 			return &_g
// 		case *_types.Config:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Config] or: Map or Vector"))
// }

GO TYPE go/types.Const from go/types/object.go:
func ExtractGoObjectConst(args []Object, index int) *_types.Const {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Const:
			return &r
		case *_types.Const:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Const]"))
}

func _mapToConst(o Map) *_types.Const {
	return &_types.Const{}
}

func _vectorToConst(o *Vector) *_types.Const {
	return &_types.Const{}
}

func _ConstructConst(_v Object) *_types.Const {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Const:
			return &_g
		case *_types.Const:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConst(_o.(Map))
	case *Vector:
		return _vectorToConst(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Const] or: Map or Vector"))
}

GO TYPE go/types.Error from go/types/api.go:
func ExtractGoObjectError(args []Object, index int) *_types.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Error:
			return &r
		case *_types.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Error]"))
}

// func _mapToError(o Map) *_types.Error {
// 	return &_types.Error{}
// }

// func _vectorToError(o *Vector) *_types.Error {
// 	return &_types.Error{
// 		Fset: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Pos: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Msg: AssertString(o.Nth(2), "").S,
// 		Soft: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructError(_v Object) *_types.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Error:
// 			return &_g
// 		case *_types.Error:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToError(_o.(Map))
// 	case *Vector:
// 		return _vectorToError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Error] or: Map or Vector"))
// }

GO TYPE go/types.Func from go/types/object.go:
func ExtractGoObjectFunc(args []Object, index int) *_types.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Func:
			return &r
		case *_types.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Func]"))
}

func _mapToFunc(o Map) *_types.Func {
	return &_types.Func{}
}

func _vectorToFunc(o *Vector) *_types.Func {
	return &_types.Func{}
}

func _ConstructFunc(_v Object) *_types.Func {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Func:
			return &_g
		case *_types.Func:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFunc(_o.(Map))
	case *Vector:
		return _vectorToFunc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Func] or: Map or Vector"))
}

GO TYPE go/types.ImportMode from go/types/api.go:
func ExtractGoObjectImportMode(args []Object, index int) *_types.ImportMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ImportMode:
			return &r
		case *_types.ImportMode:
			return r
		}
	case Int:
		v := _types.ImportMode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ImportMode]"))
}

func _ConstructImportMode(_v Object) _types.ImportMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.ImportMode:
			return _g
		case *_types.ImportMode:
			return *_g
		}
	case Number:
		return _types.ImportMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ImportMode] or: Number"))
}

GO TYPE go/types.Importer from go/types/api.go:
func ExtractGoObjectImporter(args []Object, index int) *_types.Importer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Importer:
			return &r
		case *_types.Importer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Importer]"))
}

// func _ConstructImporter(_v Object) _types.Importer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Importer:
// 			return _g
// 		case *_types.Importer:
// 			return *_g
// 		}
// 	default:
// 		return _types.Importer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Importer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Importer] or: whatever"))
// }

GO TYPE go/types.ImporterFrom from go/types/api.go:
func ExtractGoObjectImporterFrom(args []Object, index int) *_types.ImporterFrom {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.ImporterFrom:
			return &r
		case *_types.ImporterFrom:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.ImporterFrom]"))
}

// func _ConstructImporterFrom(_v Object) _types.ImporterFrom {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.ImporterFrom:
// 			return _g
// 		case *_types.ImporterFrom:
// 			return *_g
// 		}
// 	default:
// 		return _types.ImporterFrom(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ImporterFrom))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.ImporterFrom] or: whatever"))
// }

GO TYPE go/types.Info from go/types/api.go:
func ExtractGoObjectInfo(args []Object, index int) *_types.Info {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Info:
			return &r
		case *_types.Info:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Info]"))
}

// func _mapToInfo(o Map) *_types.Info {
// 	return &_types.Info{}
// }

// func _vectorToInfo(o *Vector) *_types.Info {
// 	return &_types.Info{
// 		Types: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Defs: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Uses: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Implicits: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Selections: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Scopes: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		InitOrder: ABEND048(codegen.go: no conversion from Clojure for []*go/types.Initializer (*go/types.Initializer)),
// 	}
// }

// func _ConstructInfo(_v Object) *_types.Info {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Info:
// 			return &_g
// 		case *_types.Info:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Info] or: Map or Vector"))
// }

GO TYPE go/types.Initializer from go/types/api.go:
func ExtractGoObjectInitializer(args []Object, index int) *_types.Initializer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Initializer:
			return &r
		case *_types.Initializer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Initializer]"))
}

// func _mapToInitializer(o Map) *_types.Initializer {
// 	return &_types.Initializer{}
// }

// func _vectorToInitializer(o *Vector) *_types.Initializer {
// 	return &_types.Initializer{
// 		Lhs: ABEND048(codegen.go: no conversion from Clojure for []*go/types.Var (*go/types.Var)),
// 		Rhs: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructInitializer(_v Object) *_types.Initializer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Initializer:
// 			return &_g
// 		case *_types.Initializer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInitializer(_o.(Map))
// 	case *Vector:
// 		return _vectorToInitializer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Initializer] or: Map or Vector"))
// }

GO TYPE go/types.Interface from go/types/type.go:
func ExtractGoObjectInterface(args []Object, index int) *_types.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Interface:
			return &r
		case *_types.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Interface]"))
}

func _mapToInterface(o Map) *_types.Interface {
	return &_types.Interface{}
}

func _vectorToInterface(o *Vector) *_types.Interface {
	return &_types.Interface{}
}

func _ConstructInterface(_v Object) *_types.Interface {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Interface:
			return &_g
		case *_types.Interface:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInterface(_o.(Map))
	case *Vector:
		return _vectorToInterface(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Interface] or: Map or Vector"))
}

GO TYPE go/types.Label from go/types/object.go:
func ExtractGoObjectLabel(args []Object, index int) *_types.Label {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Label:
			return &r
		case *_types.Label:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Label]"))
}

func _mapToLabel(o Map) *_types.Label {
	return &_types.Label{}
}

func _vectorToLabel(o *Vector) *_types.Label {
	return &_types.Label{}
}

func _ConstructLabel(_v Object) *_types.Label {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Label:
			return &_g
		case *_types.Label:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLabel(_o.(Map))
	case *Vector:
		return _vectorToLabel(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Label] or: Map or Vector"))
}

GO TYPE go/types.Map from go/types/type.go:
func ExtractGoObjectMap(args []Object, index int) *_types.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Map:
			return &r
		case *_types.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Map]"))
}

func _mapToMap(o Map) *_types.Map {
	return &_types.Map{}
}

func _vectorToMap(o *Vector) *_types.Map {
	return &_types.Map{}
}

func _ConstructMap(_v Object) *_types.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Map:
			return &_g
		case *_types.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Map] or: Map or Vector"))
}

GO TYPE go/types.MethodSet from go/types/methodset.go:
func ExtractGoObjectMethodSet(args []Object, index int) *_types.MethodSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.MethodSet:
			return &r
		case *_types.MethodSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.MethodSet]"))
}

func _mapToMethodSet(o Map) *_types.MethodSet {
	return &_types.MethodSet{}
}

func _vectorToMethodSet(o *Vector) *_types.MethodSet {
	return &_types.MethodSet{}
}

func _ConstructMethodSet(_v Object) *_types.MethodSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.MethodSet:
			return &_g
		case *_types.MethodSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMethodSet(_o.(Map))
	case *Vector:
		return _vectorToMethodSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.MethodSet] or: Map or Vector"))
}

GO TYPE go/types.Named from go/types/type.go:
func ExtractGoObjectNamed(args []Object, index int) *_types.Named {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Named:
			return &r
		case *_types.Named:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Named]"))
}

func _mapToNamed(o Map) *_types.Named {
	return &_types.Named{}
}

func _vectorToNamed(o *Vector) *_types.Named {
	return &_types.Named{}
}

func _ConstructNamed(_v Object) *_types.Named {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Named:
			return &_g
		case *_types.Named:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNamed(_o.(Map))
	case *Vector:
		return _vectorToNamed(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Named] or: Map or Vector"))
}

GO TYPE go/types.Nil from go/types/object.go:
func ExtractGoObjectNil(args []Object, index int) *_types.Nil {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Nil:
			return &r
		case *_types.Nil:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Nil]"))
}

func _mapToNil(o Map) *_types.Nil {
	return &_types.Nil{}
}

func _vectorToNil(o *Vector) *_types.Nil {
	return &_types.Nil{}
}

func _ConstructNil(_v Object) *_types.Nil {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Nil:
			return &_g
		case *_types.Nil:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNil(_o.(Map))
	case *Vector:
		return _vectorToNil(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Nil] or: Map or Vector"))
}

GO TYPE go/types.Object from go/types/object.go:
func ExtractGoObjectObject(args []Object, index int) *_types.Object {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Object:
			return &r
		case *_types.Object:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Object]"))
}

// func _ConstructObject(_v Object) _types.Object {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Object:
// 			return _g
// 		case *_types.Object:
// 			return *_g
// 		}
// 	default:
// 		return _types.Object(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Object))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Object] or: whatever"))
// }

GO TYPE go/types.Package from go/types/package.go:
func ExtractGoObjectPackage(args []Object, index int) *_types.Package {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Package:
			return &r
		case *_types.Package:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Package]"))
}

func _mapToPackage(o Map) *_types.Package {
	return &_types.Package{}
}

func _vectorToPackage(o *Vector) *_types.Package {
	return &_types.Package{}
}

func _ConstructPackage(_v Object) *_types.Package {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Package:
			return &_g
		case *_types.Package:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPackage(_o.(Map))
	case *Vector:
		return _vectorToPackage(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Package] or: Map or Vector"))
}

GO TYPE go/types.PkgName from go/types/object.go:
func ExtractGoObjectPkgName(args []Object, index int) *_types.PkgName {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.PkgName:
			return &r
		case *_types.PkgName:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.PkgName]"))
}

func _mapToPkgName(o Map) *_types.PkgName {
	return &_types.PkgName{}
}

func _vectorToPkgName(o *Vector) *_types.PkgName {
	return &_types.PkgName{}
}

func _ConstructPkgName(_v Object) *_types.PkgName {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.PkgName:
			return &_g
		case *_types.PkgName:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPkgName(_o.(Map))
	case *Vector:
		return _vectorToPkgName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.PkgName] or: Map or Vector"))
}

GO TYPE go/types.Pointer from go/types/type.go:
func ExtractGoObjectPointer(args []Object, index int) *_types.Pointer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Pointer:
			return &r
		case *_types.Pointer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Pointer]"))
}

func _mapToPointer(o Map) *_types.Pointer {
	return &_types.Pointer{}
}

func _vectorToPointer(o *Vector) *_types.Pointer {
	return &_types.Pointer{}
}

func _ConstructPointer(_v Object) *_types.Pointer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Pointer:
			return &_g
		case *_types.Pointer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPointer(_o.(Map))
	case *Vector:
		return _vectorToPointer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Pointer] or: Map or Vector"))
}

GO TYPE go/types.Qualifier from go/types/typestring.go:
func ExtractGoObjectQualifier(args []Object, index int) *_types.Qualifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Qualifier:
			return &r
		case *_types.Qualifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Qualifier]"))
}

// func _ConstructQualifier(_v Object) _types.Qualifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Qualifier:
// 			return _g
// 		case *_types.Qualifier:
// 			return *_g
// 		}
// 	default:
// 		return _types.Qualifier(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for Qualifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Qualifier] or: whatever"))
// }

GO TYPE go/types.Scope from go/types/scope.go:
func ExtractGoObjectScope(args []Object, index int) *_types.Scope {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Scope:
			return &r
		case *_types.Scope:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Scope]"))
}

func _mapToScope(o Map) *_types.Scope {
	return &_types.Scope{}
}

func _vectorToScope(o *Vector) *_types.Scope {
	return &_types.Scope{}
}

func _ConstructScope(_v Object) *_types.Scope {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Scope:
			return &_g
		case *_types.Scope:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToScope(_o.(Map))
	case *Vector:
		return _vectorToScope(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Scope] or: Map or Vector"))
}

GO TYPE go/types.Selection from go/types/selection.go:
func ExtractGoObjectSelection(args []Object, index int) *_types.Selection {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Selection:
			return &r
		case *_types.Selection:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Selection]"))
}

func _mapToSelection(o Map) *_types.Selection {
	return &_types.Selection{}
}

func _vectorToSelection(o *Vector) *_types.Selection {
	return &_types.Selection{}
}

func _ConstructSelection(_v Object) *_types.Selection {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Selection:
			return &_g
		case *_types.Selection:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSelection(_o.(Map))
	case *Vector:
		return _vectorToSelection(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Selection] or: Map or Vector"))
}

GO TYPE go/types.SelectionKind from go/types/selection.go:
func ExtractGoObjectSelectionKind(args []Object, index int) *_types.SelectionKind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.SelectionKind:
			return &r
		case *_types.SelectionKind:
			return r
		}
	case Int:
		v := _types.SelectionKind(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.SelectionKind]"))
}

func _ConstructSelectionKind(_v Object) _types.SelectionKind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.SelectionKind:
			return _g
		case *_types.SelectionKind:
			return *_g
		}
	case Number:
		return _types.SelectionKind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.SelectionKind] or: Number"))
}

GO TYPE go/types.Signature from go/types/type.go:
func ExtractGoObjectSignature(args []Object, index int) *_types.Signature {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Signature:
			return &r
		case *_types.Signature:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Signature]"))
}

func _mapToSignature(o Map) *_types.Signature {
	return &_types.Signature{}
}

func _vectorToSignature(o *Vector) *_types.Signature {
	return &_types.Signature{}
}

func _ConstructSignature(_v Object) *_types.Signature {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Signature:
			return &_g
		case *_types.Signature:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSignature(_o.(Map))
	case *Vector:
		return _vectorToSignature(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Signature] or: Map or Vector"))
}

GO TYPE go/types.Sizes from go/types/sizes.go:
func ExtractGoObjectSizes(args []Object, index int) *_types.Sizes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Sizes:
			return &r
		case *_types.Sizes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Sizes]"))
}

// func _ConstructSizes(_v Object) _types.Sizes {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Sizes:
// 			return _g
// 		case *_types.Sizes:
// 			return *_g
// 		}
// 	default:
// 		return _types.Sizes(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Sizes))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Sizes] or: whatever"))
// }

GO TYPE go/types.Slice from go/types/type.go:
func ExtractGoObjectSlice(args []Object, index int) *_types.Slice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Slice:
			return &r
		case *_types.Slice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Slice]"))
}

func _mapToSlice(o Map) *_types.Slice {
	return &_types.Slice{}
}

func _vectorToSlice(o *Vector) *_types.Slice {
	return &_types.Slice{}
}

func _ConstructSlice(_v Object) *_types.Slice {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Slice:
			return &_g
		case *_types.Slice:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSlice(_o.(Map))
	case *Vector:
		return _vectorToSlice(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Slice] or: Map or Vector"))
}

GO TYPE go/types.StdSizes from go/types/sizes.go:
func ExtractGoObjectStdSizes(args []Object, index int) *_types.StdSizes {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.StdSizes:
			return &r
		case *_types.StdSizes:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.StdSizes]"))
}

func _mapToStdSizes(o Map) *_types.StdSizes {
	return &_types.StdSizes{}
}

func _vectorToStdSizes(o *Vector) *_types.StdSizes {
	return &_types.StdSizes{
		WordSize: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		MaxAlign: AssertNumber(o.Nth(1), "").BigInt().Int64(),
	}
}

func _ConstructStdSizes(_v Object) *_types.StdSizes {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.StdSizes:
			return &_g
		case *_types.StdSizes:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStdSizes(_o.(Map))
	case *Vector:
		return _vectorToStdSizes(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.StdSizes] or: Map or Vector"))
}

GO TYPE go/types.Struct from go/types/type.go:
func ExtractGoObjectStruct(args []Object, index int) *_types.Struct {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Struct:
			return &r
		case *_types.Struct:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Struct]"))
}

func _mapToStruct(o Map) *_types.Struct {
	return &_types.Struct{}
}

func _vectorToStruct(o *Vector) *_types.Struct {
	return &_types.Struct{}
}

func _ConstructStruct(_v Object) *_types.Struct {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Struct:
			return &_g
		case *_types.Struct:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStruct(_o.(Map))
	case *Vector:
		return _vectorToStruct(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Struct] or: Map or Vector"))
}

GO TYPE go/types.Tuple from go/types/type.go:
func ExtractGoObjectTuple(args []Object, index int) *_types.Tuple {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Tuple:
			return &r
		case *_types.Tuple:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Tuple]"))
}

func _mapToTuple(o Map) *_types.Tuple {
	return &_types.Tuple{}
}

func _vectorToTuple(o *Vector) *_types.Tuple {
	return &_types.Tuple{}
}

func _ConstructTuple(_v Object) *_types.Tuple {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Tuple:
			return &_g
		case *_types.Tuple:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTuple(_o.(Map))
	case *Vector:
		return _vectorToTuple(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Tuple] or: Map or Vector"))
}

GO TYPE go/types.Type from go/types/type.go:
func ExtractGoObjectType(args []Object, index int) *_types.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Type:
			return &r
		case *_types.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Type]"))
}

// func _ConstructType(_v Object) _types.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.Type:
// 			return _g
// 		case *_types.Type:
// 			return *_g
// 		}
// 	default:
// 		return _types.Type(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Type] or: whatever"))
// }

GO TYPE go/types.TypeAndValue from go/types/api.go:
func ExtractGoObjectTypeAndValue(args []Object, index int) *_types.TypeAndValue {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.TypeAndValue:
			return &r
		case *_types.TypeAndValue:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.TypeAndValue]"))
}

// func _mapToTypeAndValue(o Map) *_types.TypeAndValue {
// 	return &_types.TypeAndValue{}
// }

// func _vectorToTypeAndValue(o *Vector) *_types.TypeAndValue {
// 	return &_types.TypeAndValue{
// 		Type: ABEND048(codegen.go: no conversion from Clojure for go/types.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Value: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructTypeAndValue(_v Object) *_types.TypeAndValue {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _types.TypeAndValue:
// 			return &_g
// 		case *_types.TypeAndValue:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTypeAndValue(_o.(Map))
// 	case *Vector:
// 		return _vectorToTypeAndValue(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[types.TypeAndValue] or: Map or Vector"))
// }

GO TYPE go/types.TypeName from go/types/object.go:
func ExtractGoObjectTypeName(args []Object, index int) *_types.TypeName {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.TypeName:
			return &r
		case *_types.TypeName:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.TypeName]"))
}

func _mapToTypeName(o Map) *_types.TypeName {
	return &_types.TypeName{}
}

func _vectorToTypeName(o *Vector) *_types.TypeName {
	return &_types.TypeName{}
}

func _ConstructTypeName(_v Object) *_types.TypeName {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.TypeName:
			return &_g
		case *_types.TypeName:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeName(_o.(Map))
	case *Vector:
		return _vectorToTypeName(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.TypeName] or: Map or Vector"))
}

GO TYPE go/types.Var from go/types/object.go:
func ExtractGoObjectVar(args []Object, index int) *_types.Var {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _types.Var:
			return &r
		case *_types.Var:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[go/types.Var]"))
}

func _mapToVar(o Map) *_types.Var {
	return &_types.Var{}
}

func _vectorToVar(o *Vector) *_types.Var {
	return &_types.Var{}
}

func _ConstructVar(_v Object) *_types.Var {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _types.Var:
			return &_g
		case *_types.Var:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToVar(_o.(Map))
	case *Vector:
		return _vectorToVar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[types.Var] or: Map or Vector"))
}

GO FUNC go/types.DefPredeclaredTestFuncs from go/types/universe.go:
// func __defPredeclaredTestFuncs() Object {
// 	_types.DefPredeclaredTestFuncs()
// 	...ABEND675: TODO...
// }

GO FUNC go/types.Default from go/types/predicates.go:
func __default(typ _types.Type) Object {
	_res := _types.Default(typ)
	return MakeGoObject(_res)
}

GO FUNC go/types.Eval from go/types/eval.go:
// func __eval(fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), pkg *_types.Package, pos ABEND987(genutils.go: imports not yet supported: token.Pos), expr string) Object {
// 	_, err := _types.Eval(fset, pkg, pos, expr)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/types.ExprString from go/types/exprstring.go:
// func __exprString(x ABEND987(genutils.go: imports not yet supported: ast.Expr))  {
// 	_res := _types.ExprString(x)
// 	return MakeString(_res)
// }

GO FUNC go/types.LookupFieldOrMethod from go/types/lookup.go:
func __lookupFieldOrMethod(T _types.Type, addressable bool, pkg *_types.Package, name string) Object {
	obj, index, indirect := _types.LookupFieldOrMethod(T, addressable, pkg, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(obj))
	_vec1 := EmptyVector()
	for _, _elem1 := range index {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(MakeBoolean(indirect))
	return _res
}

GO FUNC go/types.MissingMethod from go/types/lookup.go:
func __missingMethod(V _types.Type, T *_types.Interface, static bool) Object {
	method, wrongType := _types.MissingMethod(V, T, static)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(method))
	_res = _res.Conjoin(MakeBoolean(wrongType))
	return _res
}

GO FUNC go/types.NewArray from go/types/type.go:
func __newArray(elem _types.Type, len int64) Object {
	_res := _types.NewArray(elem, len)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChan from go/types/type.go:
func __newChan(dir _types.ChanDir, elem _types.Type) Object {
	_res := _types.NewChan(dir, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewChecker from go/types/check.go:
// func __newChecker(conf *_types.Config, fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), pkg *_types.Package, info *_types.Info) Object {
// 	_res := _types.NewChecker(conf, fset, pkg, info)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewConst from go/types/object.go:
// func __newConst(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type, val ABEND987(genutils.go: imports not yet supported: constant.Value)) Object {
// 	_res := _types.NewConst(pos, pkg, name, typ, val)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewField from go/types/object.go:
// func __newField(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type, embedded bool) Object {
// 	_res := _types.NewField(pos, pkg, name, typ, embedded)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewFunc from go/types/object.go:
// func __newFunc(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, sig *_types.Signature) Object {
// 	_res := _types.NewFunc(pos, pkg, name, sig)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterface from go/types/type.go:
// func __newInterface(methods []*_types.Func, embeddeds []*_types.Named) Object {
// 	_res := _types.NewInterface(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewInterfaceType from go/types/type.go:
// func __newInterfaceType(methods []*_types.Func, embeddeds []_types.Type) Object {
// 	_res := _types.NewInterfaceType(methods, embeddeds)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewLabel from go/types/object.go:
// func __newLabel(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string) Object {
// 	_res := _types.NewLabel(pos, pkg, name)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewMap from go/types/type.go:
func __newMap(key _types.Type, elem _types.Type) Object {
	_res := _types.NewMap(key, elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewMethodSet from go/types/methodset.go:
func __newMethodSet(T _types.Type) Object {
	_res := _types.NewMethodSet(T)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewNamed from go/types/type.go:
// func __newNamed(obj *_types.TypeName, underlying _types.Type, methods []*_types.Func) Object {
// 	_res := _types.NewNamed(obj, underlying, methods)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPackage from go/types/package.go:
func __newPackage(path string, name string) Object {
	_res := _types.NewPackage(path, name)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewParam from go/types/object.go:
// func __newParam(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewParam(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPkgName from go/types/object.go:
// func __newPkgName(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, imported *_types.Package) Object {
// 	_res := _types.NewPkgName(pos, pkg, name, imported)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewPointer from go/types/type.go:
func __newPointer(elem _types.Type) Object {
	_res := _types.NewPointer(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewScope from go/types/scope.go:
// func __newScope(parent *_types.Scope, pos ABEND987(genutils.go: imports not yet supported: token.Pos), end ABEND987(genutils.go: imports not yet supported: token.Pos), comment string) Object {
// 	_res := _types.NewScope(parent, pos, end, comment)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewSignature from go/types/type.go:
func __newSignature(recv *_types.Var, params *_types.Tuple, results *_types.Tuple, variadic bool) Object {
	_res := _types.NewSignature(recv, params, results, variadic)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewSlice from go/types/type.go:
func __newSlice(elem _types.Type) Object {
	_res := _types.NewSlice(elem)
	return MakeGoObject(_res)
}

GO FUNC go/types.NewStruct from go/types/type.go:
// func __newStruct(fields []*_types.Var, tags []string) Object {
// 	_res := _types.NewStruct(fields, tags)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTuple from go/types/type.go:
// func __newTuple(x ...*_types.Var) Object {
// 	_res := _types.NewTuple(x)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewTypeName from go/types/object.go:
// func __newTypeName(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewTypeName(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.NewVar from go/types/object.go:
// func __newVar(pos ABEND987(genutils.go: imports not yet supported: token.Pos), pkg *_types.Package, name string, typ _types.Type) Object {
// 	_res := _types.NewVar(pos, pkg, name, typ)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.RelativeTo from go/types/typestring.go:
func __relativeTo(pkg *_types.Package) Object {
	_res := _types.RelativeTo(pkg)
	return MakeGoObject(_res)
}

GO FUNC go/types.SizesFor from go/types/sizes.go:
func __sizesFor(compiler string, arch string) Object {
	_res := _types.SizesFor(compiler, arch)
	return MakeGoObject(_res)
}

GO FUNC go/types.WriteExpr from go/types/exprstring.go:
// func __writeExpr(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), x ABEND987(genutils.go: imports not yet supported: ast.Expr)) Object {
// 	_types.WriteExpr(buf, x)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteSignature from go/types/typestring.go:
// func __writeSignature(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), sig *_types.Signature, qf _types.Qualifier) Object {
// 	_types.WriteSignature(buf, sig, qf)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteType from go/types/typestring.go:
// func __writeType(buf *ABEND987(genutils.go: imports not yet supported: bytes.Buffer), typ _types.Type, qf _types.Qualifier) Object {
// 	_types.WriteType(buf, typ, qf)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.__error_Error from go/types/api.go:
func __error_Error(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.Error)Error()", args, 0, 0)
	_res := o.O.(_types.Error).Error()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Array_Elem from go/types/type.go:
func __ptrTo_Array_Elem(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Array)Elem()", args, 0, 0)
	_res := o.O.(*_types.Array).Elem()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Array_Len from go/types/type.go:
func __ptrTo_Array_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Array)Len()", args, 0, 0)
	_res := o.O.(*_types.Array).Len()
	return MakeBigInt(_res)
}

GO FUNC go/types.__ptrTo_Array_String from go/types/type.go:
func __ptrTo_Array_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Array)String()", args, 0, 0)
	_res := o.O.(*_types.Array).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Array_Underlying from go/types/type.go:
func __ptrTo_Array_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Array)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Array).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Basic_Info from go/types/type.go:
func __ptrTo_Basic_Info(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Basic)Info()", args, 0, 0)
	_res := o.O.(*_types.Basic).Info()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Basic_Kind from go/types/type.go:
func __ptrTo_Basic_Kind(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Basic)Kind()", args, 0, 0)
	_res := o.O.(*_types.Basic).Kind()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Basic_Name from go/types/type.go:
func __ptrTo_Basic_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Basic)Name()", args, 0, 0)
	_res := o.O.(*_types.Basic).Name()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Basic_String from go/types/type.go:
func __ptrTo_Basic_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Basic)String()", args, 0, 0)
	_res := o.O.(*_types.Basic).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Basic_Underlying from go/types/type.go:
func __ptrTo_Basic_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Basic)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Basic).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Builtin_String from go/types/object.go:
func __ptrTo_Builtin_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Builtin)String()", args, 0, 0)
	_res := o.O.(*_types.Builtin).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Chan_Dir from go/types/type.go:
func __ptrTo_Chan_Dir(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Chan)Dir()", args, 0, 0)
	_res := o.O.(*_types.Chan).Dir()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Chan_Elem from go/types/type.go:
func __ptrTo_Chan_Elem(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Chan)Elem()", args, 0, 0)
	_res := o.O.(*_types.Chan).Elem()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Chan_String from go/types/type.go:
func __ptrTo_Chan_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Chan)String()", args, 0, 0)
	_res := o.O.(*_types.Chan).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Chan_Underlying from go/types/type.go:
func __ptrTo_Chan_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Chan)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Chan).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Checker_Files from go/types/check.go:
// func __ptrTo_Checker_Files(o GoObject, args Object) Object {
// files []*ABEND987(genutils.go: imports not yet supported: ast.File)}

GO FUNC go/types.__ptrTo_Config_Check from go/types/api.go:
// func __ptrTo_Config_Check(o GoObject, args Object) Object {
// path string, fset *ABEND987(genutils.go: imports not yet supported: token.FileSet), files []*ABEND987(genutils.go: imports not yet supported: ast.File), info *_types.Info}

GO FUNC go/types.__ptrTo_Const_String from go/types/object.go:
func __ptrTo_Const_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Const)String()", args, 0, 0)
	_res := o.O.(*_types.Const).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Const_Val from go/types/object.go:
func __ptrTo_Const_Val(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Const)Val()", args, 0, 0)
	_res := o.O.(*_types.Const).Val()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Func_FullName from go/types/object.go:
func __ptrTo_Func_FullName(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Func)FullName()", args, 0, 0)
	_res := o.O.(*_types.Func).FullName()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Func_Scope from go/types/object.go:
func __ptrTo_Func_Scope(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Func)Scope()", args, 0, 0)
	_res := o.O.(*_types.Func).Scope()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Func_String from go/types/object.go:
func __ptrTo_Func_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Func)String()", args, 0, 0)
	_res := o.O.(*_types.Func).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Info_ObjectOf from go/types/api.go:
// func __ptrTo_Info_ObjectOf(o GoObject, args Object) Object {
// id *ABEND987(genutils.go: imports not yet supported: ast.Ident)}

GO FUNC go/types.__ptrTo_Info_TypeOf from go/types/api.go:
// func __ptrTo_Info_TypeOf(o GoObject, args Object) Object {
// e ABEND987(genutils.go: imports not yet supported: ast.Expr)}

GO FUNC go/types.__ptrTo_Initializer_String from go/types/api.go:
func __ptrTo_Initializer_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Initializer)String()", args, 0, 0)
	_res := o.O.(*_types.Initializer).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Interface_Complete from go/types/type.go:
func __ptrTo_Interface_Complete(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)Complete()", args, 0, 0)
	_res := o.O.(*_types.Interface).Complete()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Interface_Embedded from go/types/type.go:
func __ptrTo_Interface_Embedded(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Interface)Embedded()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Interface)Embedded()", "i", _argList, 0)
	_res := o.O.(*_types.Interface).Embedded(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Interface_EmbeddedType from go/types/type.go:
func __ptrTo_Interface_EmbeddedType(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Interface)EmbeddedType()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Interface)EmbeddedType()", "i", _argList, 0)
	_res := o.O.(*_types.Interface).EmbeddedType(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Interface_Empty from go/types/type.go:
func __ptrTo_Interface_Empty(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)Empty()", args, 0, 0)
	_res := o.O.(*_types.Interface).Empty()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Interface_ExplicitMethod from go/types/type.go:
func __ptrTo_Interface_ExplicitMethod(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Interface)ExplicitMethod()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Interface)ExplicitMethod()", "i", _argList, 0)
	_res := o.O.(*_types.Interface).ExplicitMethod(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Interface_Method from go/types/type.go:
func __ptrTo_Interface_Method(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Interface)Method()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Interface)Method()", "i", _argList, 0)
	_res := o.O.(*_types.Interface).Method(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Interface_NumEmbeddeds from go/types/type.go:
func __ptrTo_Interface_NumEmbeddeds(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)NumEmbeddeds()", args, 0, 0)
	_res := o.O.(*_types.Interface).NumEmbeddeds()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Interface_NumExplicitMethods from go/types/type.go:
func __ptrTo_Interface_NumExplicitMethods(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)NumExplicitMethods()", args, 0, 0)
	_res := o.O.(*_types.Interface).NumExplicitMethods()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Interface_NumMethods from go/types/type.go:
func __ptrTo_Interface_NumMethods(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)NumMethods()", args, 0, 0)
	_res := o.O.(*_types.Interface).NumMethods()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Interface_String from go/types/type.go:
func __ptrTo_Interface_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)String()", args, 0, 0)
	_res := o.O.(*_types.Interface).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Interface_Underlying from go/types/type.go:
func __ptrTo_Interface_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Interface)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Interface).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Label_String from go/types/object.go:
func __ptrTo_Label_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Label)String()", args, 0, 0)
	_res := o.O.(*_types.Label).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Map_Elem from go/types/type.go:
func __ptrTo_Map_Elem(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Map)Elem()", args, 0, 0)
	_res := o.O.(*_types.Map).Elem()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Map_Key from go/types/type.go:
func __ptrTo_Map_Key(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Map)Key()", args, 0, 0)
	_res := o.O.(*_types.Map).Key()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Map_String from go/types/type.go:
func __ptrTo_Map_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Map)String()", args, 0, 0)
	_res := o.O.(*_types.Map).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Map_Underlying from go/types/type.go:
func __ptrTo_Map_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Map)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Map).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_MethodSet_At from go/types/methodset.go:
func __ptrTo_MethodSet_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.MethodSet)At()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.MethodSet)At()", "i", _argList, 0)
	_res := o.O.(*_types.MethodSet).At(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_MethodSet_Len from go/types/methodset.go:
func __ptrTo_MethodSet_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.MethodSet)Len()", args, 0, 0)
	_res := o.O.(*_types.MethodSet).Len()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_MethodSet_Lookup from go/types/methodset.go:
// func __ptrTo_MethodSet_Lookup(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_go/types.MethodSet)Lookup()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for pkg at: /usr/local/go/src/go/types/methodset.go:43:32)
// 	name := ExtractGoString("(*_go/types.MethodSet)Lookup()", "name", _argList, 1)
// 	_res := o.O.(*_types.MethodSet).Lookup(pkg, name)
// 	return MakeGoObject(_res)
// }

GO FUNC go/types.__ptrTo_MethodSet_String from go/types/methodset.go:
func __ptrTo_MethodSet_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.MethodSet)String()", args, 0, 0)
	_res := o.O.(*_types.MethodSet).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Named_AddMethod from go/types/type.go:
// func __ptrTo_Named_AddMethod(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/types.__ptrTo_Named_Method from go/types/type.go:
func __ptrTo_Named_Method(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Named)Method()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Named)Method()", "i", _argList, 0)
	_res := o.O.(*_types.Named).Method(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Named_NumMethods from go/types/type.go:
func __ptrTo_Named_NumMethods(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Named)NumMethods()", args, 0, 0)
	_res := o.O.(*_types.Named).NumMethods()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Named_Obj from go/types/type.go:
func __ptrTo_Named_Obj(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Named)Obj()", args, 0, 0)
	_res := o.O.(*_types.Named).Obj()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Named_SetUnderlying from go/types/type.go:
// func __ptrTo_Named_SetUnderlying(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/types.__ptrTo_Named_String from go/types/type.go:
func __ptrTo_Named_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Named)String()", args, 0, 0)
	_res := o.O.(*_types.Named).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Named_Underlying from go/types/type.go:
func __ptrTo_Named_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Named)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Named).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Nil_String from go/types/object.go:
func __ptrTo_Nil_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Nil)String()", args, 0, 0)
	_res := o.O.(*_types.Nil).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Package_Complete from go/types/package.go:
func __ptrTo_Package_Complete(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)Complete()", args, 0, 0)
	_res := o.O.(*_types.Package).Complete()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Package_Imports from go/types/package.go:
func __ptrTo_Package_Imports(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)Imports()", args, 0, 0)
	_res := o.O.(*_types.Package).Imports()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC go/types.__ptrTo_Package_MarkComplete from go/types/package.go:
// func __ptrTo_Package_MarkComplete(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/types.__ptrTo_Package_Name from go/types/package.go:
func __ptrTo_Package_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)Name()", args, 0, 0)
	_res := o.O.(*_types.Package).Name()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Package_Path from go/types/package.go:
func __ptrTo_Package_Path(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)Path()", args, 0, 0)
	_res := o.O.(*_types.Package).Path()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Package_Scope from go/types/package.go:
func __ptrTo_Package_Scope(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)Scope()", args, 0, 0)
	_res := o.O.(*_types.Package).Scope()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Package_SetImports from go/types/package.go:
// func __ptrTo_Package_SetImports(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Package(list)))}

GO FUNC go/types.__ptrTo_Package_SetName from go/types/package.go:
// func __ptrTo_Package_SetName(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC go/types.__ptrTo_Package_String from go/types/package.go:
func __ptrTo_Package_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Package)String()", args, 0, 0)
	_res := o.O.(*_types.Package).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_PkgName_Imported from go/types/object.go:
func __ptrTo_PkgName_Imported(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.PkgName)Imported()", args, 0, 0)
	_res := o.O.(*_types.PkgName).Imported()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_PkgName_String from go/types/object.go:
func __ptrTo_PkgName_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.PkgName)String()", args, 0, 0)
	_res := o.O.(*_types.PkgName).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Pointer_Elem from go/types/type.go:
func __ptrTo_Pointer_Elem(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Pointer)Elem()", args, 0, 0)
	_res := o.O.(*_types.Pointer).Elem()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Pointer_String from go/types/type.go:
func __ptrTo_Pointer_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Pointer)String()", args, 0, 0)
	_res := o.O.(*_types.Pointer).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Pointer_Underlying from go/types/type.go:
func __ptrTo_Pointer_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Pointer)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Pointer).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_Child from go/types/scope.go:
func __ptrTo_Scope_Child(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Scope)Child()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Scope)Child()", "i", _argList, 0)
	_res := o.O.(*_types.Scope).Child(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_Contains from go/types/scope.go:
// func __ptrTo_Scope_Contains(o GoObject, args Object) Object {
// pos ABEND987(genutils.go: imports not yet supported: token.Pos)}

GO FUNC go/types.__ptrTo_Scope_End from go/types/scope.go:
func __ptrTo_Scope_End(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)End()", args, 0, 0)
	_res := o.O.(*_types.Scope).End()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_Innermost from go/types/scope.go:
// func __ptrTo_Scope_Innermost(o GoObject, args Object) Object {
// pos ABEND987(genutils.go: imports not yet supported: token.Pos)}

GO FUNC go/types.__ptrTo_Scope_Insert from go/types/scope.go:
func __ptrTo_Scope_Insert(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Scope)Insert()", args, 1, 1)
	obj := ExtractGo_go_std_go_types__Object("(*_go/types.Scope)Insert()", "obj", _argList, 0)
	_res := o.O.(*_types.Scope).Insert(obj)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_Len from go/types/scope.go:
func __ptrTo_Scope_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)Len()", args, 0, 0)
	_res := o.O.(*_types.Scope).Len()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Scope_Lookup from go/types/scope.go:
func __ptrTo_Scope_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Scope)Lookup()", args, 1, 1)
	name := ExtractGoString("(*_go/types.Scope)Lookup()", "name", _argList, 0)
	_res := o.O.(*_types.Scope).Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_LookupParent from go/types/scope.go:
// func __ptrTo_Scope_LookupParent(o GoObject, args Object) Object {
// name string, pos ABEND987(genutils.go: imports not yet supported: token.Pos)}

GO FUNC go/types.__ptrTo_Scope_Names from go/types/scope.go:
func __ptrTo_Scope_Names(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)Names()", args, 0, 0)
	_res := o.O.(*_types.Scope).Names()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC go/types.__ptrTo_Scope_NumChildren from go/types/scope.go:
func __ptrTo_Scope_NumChildren(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)NumChildren()", args, 0, 0)
	_res := o.O.(*_types.Scope).NumChildren()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Scope_Parent from go/types/scope.go:
func __ptrTo_Scope_Parent(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)Parent()", args, 0, 0)
	_res := o.O.(*_types.Scope).Parent()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_Pos from go/types/scope.go:
func __ptrTo_Scope_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)Pos()", args, 0, 0)
	_res := o.O.(*_types.Scope).Pos()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Scope_String from go/types/scope.go:
func __ptrTo_Scope_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Scope)String()", args, 0, 0)
	_res := o.O.(*_types.Scope).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Scope_WriteTo from go/types/scope.go:
// func __ptrTo_Scope_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer), n int, recurse bool}

GO FUNC go/types.__ptrTo_Selection_Index from go/types/selection.go:
func __ptrTo_Selection_Index(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Index()", args, 0, 0)
	_res := o.O.(*_types.Selection).Index()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC go/types.__ptrTo_Selection_Indirect from go/types/selection.go:
func __ptrTo_Selection_Indirect(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Indirect()", args, 0, 0)
	_res := o.O.(*_types.Selection).Indirect()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Selection_Kind from go/types/selection.go:
func __ptrTo_Selection_Kind(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Kind()", args, 0, 0)
	_res := o.O.(*_types.Selection).Kind()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Selection_Obj from go/types/selection.go:
func __ptrTo_Selection_Obj(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Obj()", args, 0, 0)
	_res := o.O.(*_types.Selection).Obj()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Selection_Recv from go/types/selection.go:
func __ptrTo_Selection_Recv(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Recv()", args, 0, 0)
	_res := o.O.(*_types.Selection).Recv()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Selection_String from go/types/selection.go:
func __ptrTo_Selection_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)String()", args, 0, 0)
	_res := o.O.(*_types.Selection).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Selection_Type from go/types/selection.go:
func __ptrTo_Selection_Type(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Selection)Type()", args, 0, 0)
	_res := o.O.(*_types.Selection).Type()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Signature_Params from go/types/type.go:
func __ptrTo_Signature_Params(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)Params()", args, 0, 0)
	_res := o.O.(*_types.Signature).Params()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Signature_Recv from go/types/type.go:
func __ptrTo_Signature_Recv(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)Recv()", args, 0, 0)
	_res := o.O.(*_types.Signature).Recv()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Signature_Results from go/types/type.go:
func __ptrTo_Signature_Results(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)Results()", args, 0, 0)
	_res := o.O.(*_types.Signature).Results()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Signature_String from go/types/type.go:
func __ptrTo_Signature_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)String()", args, 0, 0)
	_res := o.O.(*_types.Signature).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Signature_Underlying from go/types/type.go:
func __ptrTo_Signature_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Signature).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Signature_Variadic from go/types/type.go:
func __ptrTo_Signature_Variadic(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Signature)Variadic()", args, 0, 0)
	_res := o.O.(*_types.Signature).Variadic()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Slice_Elem from go/types/type.go:
func __ptrTo_Slice_Elem(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Slice)Elem()", args, 0, 0)
	_res := o.O.(*_types.Slice).Elem()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Slice_String from go/types/type.go:
func __ptrTo_Slice_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Slice)String()", args, 0, 0)
	_res := o.O.(*_types.Slice).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Slice_Underlying from go/types/type.go:
func __ptrTo_Slice_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Slice)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Slice).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_StdSizes_Alignof from go/types/sizes.go:
func __ptrTo_StdSizes_Alignof(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.StdSizes)Alignof()", args, 1, 1)
	T := ExtractGo_go_std_go_types__Type("(*_go/types.StdSizes)Alignof()", "T", _argList, 0)
	_res := o.O.(*_types.StdSizes).Alignof(T)
	return MakeBigInt(_res)
}

GO FUNC go/types.__ptrTo_StdSizes_Offsetsof from go/types/sizes.go:
// func __ptrTo_StdSizes_Offsetsof(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf*_types.Var(fields)))}

GO FUNC go/types.__ptrTo_StdSizes_Sizeof from go/types/sizes.go:
func __ptrTo_StdSizes_Sizeof(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.StdSizes)Sizeof()", args, 1, 1)
	T := ExtractGo_go_std_go_types__Type("(*_go/types.StdSizes)Sizeof()", "T", _argList, 0)
	_res := o.O.(*_types.StdSizes).Sizeof(T)
	return MakeBigInt(_res)
}

GO FUNC go/types.__ptrTo_Struct_Field from go/types/type.go:
func __ptrTo_Struct_Field(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Struct)Field()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Struct)Field()", "i", _argList, 0)
	_res := o.O.(*_types.Struct).Field(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Struct_NumFields from go/types/type.go:
func __ptrTo_Struct_NumFields(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Struct)NumFields()", args, 0, 0)
	_res := o.O.(*_types.Struct).NumFields()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Struct_String from go/types/type.go:
func __ptrTo_Struct_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Struct)String()", args, 0, 0)
	_res := o.O.(*_types.Struct).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Struct_Tag from go/types/type.go:
func __ptrTo_Struct_Tag(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Struct)Tag()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Struct)Tag()", "i", _argList, 0)
	_res := o.O.(*_types.Struct).Tag(i)
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Struct_Underlying from go/types/type.go:
func __ptrTo_Struct_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Struct)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Struct).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Tuple_At from go/types/type.go:
func __ptrTo_Tuple_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_go/types.Tuple)At()", args, 1, 1)
	i := ExtractGoInt("(*_go/types.Tuple)At()", "i", _argList, 0)
	_res := o.O.(*_types.Tuple).At(i)
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_Tuple_Len from go/types/type.go:
func __ptrTo_Tuple_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Tuple)Len()", args, 0, 0)
	_res := o.O.(*_types.Tuple).Len()
	return MakeInt(_res)
}

GO FUNC go/types.__ptrTo_Tuple_String from go/types/type.go:
func __ptrTo_Tuple_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Tuple)String()", args, 0, 0)
	_res := o.O.(*_types.Tuple).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Tuple_Underlying from go/types/type.go:
func __ptrTo_Tuple_Underlying(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Tuple)Underlying()", args, 0, 0)
	_res := o.O.(*_types.Tuple).Underlying()
	return MakeGoObject(_res)
}

GO FUNC go/types.__ptrTo_TypeName_IsAlias from go/types/object.go:
func __ptrTo_TypeName_IsAlias(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.TypeName)IsAlias()", args, 0, 0)
	_res := o.O.(*_types.TypeName).IsAlias()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_TypeName_String from go/types/object.go:
func __ptrTo_TypeName_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.TypeName)String()", args, 0, 0)
	_res := o.O.(*_types.TypeName).String()
	return MakeString(_res)
}

GO FUNC go/types.__ptrTo_Var_Anonymous from go/types/object.go:
func __ptrTo_Var_Anonymous(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Var)Anonymous()", args, 0, 0)
	_res := o.O.(*_types.Var).Anonymous()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Var_Embedded from go/types/object.go:
func __ptrTo_Var_Embedded(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Var)Embedded()", args, 0, 0)
	_res := o.O.(*_types.Var).Embedded()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Var_IsField from go/types/object.go:
func __ptrTo_Var_IsField(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Var)IsField()", args, 0, 0)
	_res := o.O.(*_types.Var).IsField()
	return MakeBoolean(_res)
}

GO FUNC go/types.__ptrTo_Var_String from go/types/object.go:
func __ptrTo_Var_String(o GoObject, args Object) Object {
	CheckGoArity("(*_go/types.Var)String()", args, 0, 0)
	_res := o.O.(*_types.Var).String()
	return MakeString(_res)
}

GO FUNC go/types.__typeAndValue_Addressable from go/types/api.go:
func __typeAndValue_Addressable(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)Addressable()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).Addressable()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_Assignable from go/types/api.go:
func __typeAndValue_Assignable(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)Assignable()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).Assignable()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_HasOk from go/types/api.go:
func __typeAndValue_HasOk(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)HasOk()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).HasOk()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_IsBuiltin from go/types/api.go:
func __typeAndValue_IsBuiltin(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)IsBuiltin()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).IsBuiltin()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_IsNil from go/types/api.go:
func __typeAndValue_IsNil(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)IsNil()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).IsNil()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_IsType from go/types/api.go:
func __typeAndValue_IsType(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)IsType()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).IsType()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_IsValue from go/types/api.go:
func __typeAndValue_IsValue(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)IsValue()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).IsValue()
	return MakeBoolean(_res)
}

GO FUNC go/types.__typeAndValue_IsVoid from go/types/api.go:
func __typeAndValue_IsVoid(o GoObject, args Object) Object {
	CheckGoArity("(_go/types.TypeAndValue)IsVoid()", args, 0, 0)
	_res := o.O.(_types.TypeAndValue).IsVoid()
	return MakeBoolean(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package types

import (
	. "github.com/candid82/joker/core"
	_types "go/types"
	_reflect "reflect"
)
var members_PtrTo_Array = GoTypeInfo{Members: GoMembers{
	"Elem": __ptrTo_Array_Elem,
	"Len": __ptrTo_Array_Len,
	"String": __ptrTo_Array_String,
	"Underlying": __ptrTo_Array_Underlying,
}}

var members_PtrTo_Basic = GoTypeInfo{Members: GoMembers{
	"Info": __ptrTo_Basic_Info,
	"Kind": __ptrTo_Basic_Kind,
	"Name": __ptrTo_Basic_Name,
	"String": __ptrTo_Basic_String,
	"Underlying": __ptrTo_Basic_Underlying,
}}

var members_PtrTo_Builtin = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Builtin_String,
}}

var members_PtrTo_Chan = GoTypeInfo{Members: GoMembers{
	"Dir": __ptrTo_Chan_Dir,
	"Elem": __ptrTo_Chan_Elem,
	"String": __ptrTo_Chan_String,
	"Underlying": __ptrTo_Chan_Underlying,
}}

var members_PtrTo_Const = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Const_String,
	"Val": __ptrTo_Const_Val,
}}

var members_Error = GoTypeInfo{Members: GoMembers{
	"Error": __error_Error,
}}

var members_PtrTo_Func = GoTypeInfo{Members: GoMembers{
	"FullName": __ptrTo_Func_FullName,
	"Scope": __ptrTo_Func_Scope,
	"String": __ptrTo_Func_String,
}}

var members_PtrTo_Initializer = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Initializer_String,
}}

var members_PtrTo_Interface = GoTypeInfo{Members: GoMembers{
	"Complete": __ptrTo_Interface_Complete,
	"Embedded": __ptrTo_Interface_Embedded,
	"EmbeddedType": __ptrTo_Interface_EmbeddedType,
	"Empty": __ptrTo_Interface_Empty,
	"ExplicitMethod": __ptrTo_Interface_ExplicitMethod,
	"Method": __ptrTo_Interface_Method,
	"NumEmbeddeds": __ptrTo_Interface_NumEmbeddeds,
	"NumExplicitMethods": __ptrTo_Interface_NumExplicitMethods,
	"NumMethods": __ptrTo_Interface_NumMethods,
	"String": __ptrTo_Interface_String,
	"Underlying": __ptrTo_Interface_Underlying,
}}

var members_PtrTo_Label = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Label_String,
}}

var members_PtrTo_Map = GoTypeInfo{Members: GoMembers{
	"Elem": __ptrTo_Map_Elem,
	"Key": __ptrTo_Map_Key,
	"String": __ptrTo_Map_String,
	"Underlying": __ptrTo_Map_Underlying,
}}

var members_PtrTo_MethodSet = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_MethodSet_At,
	"Len": __ptrTo_MethodSet_Len,
	"String": __ptrTo_MethodSet_String,
}}

var members_PtrTo_Named = GoTypeInfo{Members: GoMembers{
	"Method": __ptrTo_Named_Method,
	"NumMethods": __ptrTo_Named_NumMethods,
	"Obj": __ptrTo_Named_Obj,
	"String": __ptrTo_Named_String,
	"Underlying": __ptrTo_Named_Underlying,
}}

var members_PtrTo_Nil = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Nil_String,
}}

var members_PtrTo_Package = GoTypeInfo{Members: GoMembers{
	"Complete": __ptrTo_Package_Complete,
	"Imports": __ptrTo_Package_Imports,
	"Name": __ptrTo_Package_Name,
	"Path": __ptrTo_Package_Path,
	"Scope": __ptrTo_Package_Scope,
	"String": __ptrTo_Package_String,
}}

var members_PtrTo_PkgName = GoTypeInfo{Members: GoMembers{
	"Imported": __ptrTo_PkgName_Imported,
	"String": __ptrTo_PkgName_String,
}}

var members_PtrTo_Pointer = GoTypeInfo{Members: GoMembers{
	"Elem": __ptrTo_Pointer_Elem,
	"String": __ptrTo_Pointer_String,
	"Underlying": __ptrTo_Pointer_Underlying,
}}

var members_PtrTo_Scope = GoTypeInfo{Members: GoMembers{
	"Child": __ptrTo_Scope_Child,
	"End": __ptrTo_Scope_End,
	"Insert": __ptrTo_Scope_Insert,
	"Len": __ptrTo_Scope_Len,
	"Lookup": __ptrTo_Scope_Lookup,
	"Names": __ptrTo_Scope_Names,
	"NumChildren": __ptrTo_Scope_NumChildren,
	"Parent": __ptrTo_Scope_Parent,
	"Pos": __ptrTo_Scope_Pos,
	"String": __ptrTo_Scope_String,
}}

var members_PtrTo_Selection = GoTypeInfo{Members: GoMembers{
	"Index": __ptrTo_Selection_Index,
	"Indirect": __ptrTo_Selection_Indirect,
	"Kind": __ptrTo_Selection_Kind,
	"Obj": __ptrTo_Selection_Obj,
	"Recv": __ptrTo_Selection_Recv,
	"String": __ptrTo_Selection_String,
	"Type": __ptrTo_Selection_Type,
}}

var members_PtrTo_Signature = GoTypeInfo{Members: GoMembers{
	"Params": __ptrTo_Signature_Params,
	"Recv": __ptrTo_Signature_Recv,
	"Results": __ptrTo_Signature_Results,
	"String": __ptrTo_Signature_String,
	"Underlying": __ptrTo_Signature_Underlying,
	"Variadic": __ptrTo_Signature_Variadic,
}}

var members_PtrTo_Slice = GoTypeInfo{Members: GoMembers{
	"Elem": __ptrTo_Slice_Elem,
	"String": __ptrTo_Slice_String,
	"Underlying": __ptrTo_Slice_Underlying,
}}

var members_PtrTo_StdSizes = GoTypeInfo{Members: GoMembers{
	"Alignof": __ptrTo_StdSizes_Alignof,
	"Sizeof": __ptrTo_StdSizes_Sizeof,
}}

var members_PtrTo_Struct = GoTypeInfo{Members: GoMembers{
	"Field": __ptrTo_Struct_Field,
	"NumFields": __ptrTo_Struct_NumFields,
	"String": __ptrTo_Struct_String,
	"Tag": __ptrTo_Struct_Tag,
	"Underlying": __ptrTo_Struct_Underlying,
}}

var members_PtrTo_Tuple = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_Tuple_At,
	"Len": __ptrTo_Tuple_Len,
	"String": __ptrTo_Tuple_String,
	"Underlying": __ptrTo_Tuple_Underlying,
}}

var members_TypeAndValue = GoTypeInfo{Members: GoMembers{
	"Addressable": __typeAndValue_Addressable,
	"Assignable": __typeAndValue_Assignable,
	"HasOk": __typeAndValue_HasOk,
	"IsBuiltin": __typeAndValue_IsBuiltin,
	"IsNil": __typeAndValue_IsNil,
	"IsType": __typeAndValue_IsType,
	"IsValue": __typeAndValue_IsValue,
	"IsVoid": __typeAndValue_IsVoid,
}}

var members_PtrTo_TypeName = GoTypeInfo{Members: GoMembers{
	"IsAlias": __ptrTo_TypeName_IsAlias,
	"String": __ptrTo_TypeName_String,
}}

var members_PtrTo_Var = GoTypeInfo{Members: GoMembers{
	"Anonymous": __ptrTo_Var_Anonymous,
	"Embedded": __ptrTo_Var_Embedded,
	"IsField": __ptrTo_Var_IsField,
	"String": __ptrTo_Var_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_types.Array)(nil))] = &members_PtrTo_Array
	GoTypes[_reflect.TypeOf((*_types.Basic)(nil))] = &members_PtrTo_Basic
	GoTypes[_reflect.TypeOf((*_types.Builtin)(nil))] = &members_PtrTo_Builtin
	GoTypes[_reflect.TypeOf((*_types.Chan)(nil))] = &members_PtrTo_Chan
	GoTypes[_reflect.TypeOf((*_types.Const)(nil))] = &members_PtrTo_Const
	GoTypes[_reflect.TypeOf((*_types.Error)(nil)).Elem()] = &members_Error
	GoTypes[_reflect.TypeOf((*_types.Func)(nil))] = &members_PtrTo_Func
	GoTypes[_reflect.TypeOf((*_types.Initializer)(nil))] = &members_PtrTo_Initializer
	GoTypes[_reflect.TypeOf((*_types.Interface)(nil))] = &members_PtrTo_Interface
	GoTypes[_reflect.TypeOf((*_types.Label)(nil))] = &members_PtrTo_Label
	GoTypes[_reflect.TypeOf((*_types.Map)(nil))] = &members_PtrTo_Map
	GoTypes[_reflect.TypeOf((*_types.MethodSet)(nil))] = &members_PtrTo_MethodSet
	GoTypes[_reflect.TypeOf((*_types.Named)(nil))] = &members_PtrTo_Named
	GoTypes[_reflect.TypeOf((*_types.Nil)(nil))] = &members_PtrTo_Nil
	GoTypes[_reflect.TypeOf((*_types.Package)(nil))] = &members_PtrTo_Package
	GoTypes[_reflect.TypeOf((*_types.PkgName)(nil))] = &members_PtrTo_PkgName
	GoTypes[_reflect.TypeOf((*_types.Pointer)(nil))] = &members_PtrTo_Pointer
	GoTypes[_reflect.TypeOf((*_types.Scope)(nil))] = &members_PtrTo_Scope
	GoTypes[_reflect.TypeOf((*_types.Selection)(nil))] = &members_PtrTo_Selection
	GoTypes[_reflect.TypeOf((*_types.Signature)(nil))] = &members_PtrTo_Signature
	GoTypes[_reflect.TypeOf((*_types.Slice)(nil))] = &members_PtrTo_Slice
	GoTypes[_reflect.TypeOf((*_types.StdSizes)(nil))] = &members_PtrTo_StdSizes
	GoTypes[_reflect.TypeOf((*_types.Struct)(nil))] = &members_PtrTo_Struct
	GoTypes[_reflect.TypeOf((*_types.Tuple)(nil))] = &members_PtrTo_Tuple
	GoTypes[_reflect.TypeOf((*_types.TypeAndValue)(nil)).Elem()] = &members_TypeAndValue
	GoTypes[_reflect.TypeOf((*_types.TypeName)(nil))] = &members_PtrTo_TypeName
	GoTypes[_reflect.TypeOf((*_types.Var)(nil))] = &members_PtrTo_Var
}

GO FUNC hash/adler32.Checksum from hash/adler32/adler32.go:
// func __checksum(data []byte) Object {
// 	_res := _adler32.Checksum(data)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC hash/adler32.New from hash/adler32/adler32.go:
func __new() Object {
	_res := _adler32.New()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package adler32

import (
	. "github.com/candid82/joker/core"
	_adler32 "hash/adler32"
)

func init() {
}

GO TYPE hash/crc32.Table from hash/crc32/crc32.go:
func ExtractGoObjectTable(args []Object, index int) *_crc32.Table {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crc32.Table:
			return &r
		case *_crc32.Table:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[hash/crc32.Table]"))
}

// func _ConstructTable(_v Object) _crc32.Table {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crc32.Table:
// 			return _g
// 		case *_crc32.Table:
// 			return *_g
// 		}
// 	default:
// 		return _crc32.Table(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Table))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crc32.Table] or: whatever"))
// }

GO FUNC hash/crc32.Checksum from hash/crc32/crc32.go:
// func __checksum(data []byte, tab *_crc32.Table) Object {
// 	_res := _crc32.Checksum(data, tab)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC hash/crc32.ChecksumIEEE from hash/crc32/crc32.go:
// func __checksumIEEE(data []byte) Object {
// 	_res := _crc32.ChecksumIEEE(data)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC hash/crc32.MakeTable from hash/crc32/crc32.go:
func __makeTable(poly uint32) Object {
	_res := _crc32.MakeTable(poly)
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.New from hash/crc32/crc32.go:
func __new(tab *_crc32.Table) Object {
	_res := _crc32.New(tab)
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.NewIEEE from hash/crc32/crc32.go:
func __newIEEE() Object {
	_res := _crc32.NewIEEE()
	return MakeGoObject(_res)
}

GO FUNC hash/crc32.Update from hash/crc32/crc32.go:
// func __update(crc uint32, tab *_crc32.Table, p []byte) Object {
// 	_res := _crc32.Update(crc, tab, p)
// 	return MakeBigIntU(uint64(_res))
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crc32

import (
	. "github.com/candid82/joker/core"
	_crc32 "hash/crc32"
)

func init() {
}

GO TYPE hash/crc64.Table from hash/crc64/crc64.go:
func ExtractGoObjectTable(args []Object, index int) *_crc64.Table {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _crc64.Table:
			return &r
		case *_crc64.Table:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[hash/crc64.Table]"))
}

// func _ConstructTable(_v Object) _crc64.Table {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _crc64.Table:
// 			return _g
// 		case *_crc64.Table:
// 			return *_g
// 		}
// 	default:
// 		return _crc64.Table(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Table))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[crc64.Table] or: whatever"))
// }

GO FUNC hash/crc64.Checksum from hash/crc64/crc64.go:
// func __checksum(data []byte, tab *_crc64.Table) Object {
// 	_res := _crc64.Checksum(data, tab)
// 	return MakeBigIntU(_res)
// }

GO FUNC hash/crc64.MakeTable from hash/crc64/crc64.go:
func __makeTable(poly uint64) Object {
	_res := _crc64.MakeTable(poly)
	return MakeGoObject(_res)
}

GO FUNC hash/crc64.New from hash/crc64/crc64.go:
func __new(tab *_crc64.Table) Object {
	_res := _crc64.New(tab)
	return MakeGoObject(_res)
}

GO FUNC hash/crc64.Update from hash/crc64/crc64.go:
// func __update(crc uint64, tab *_crc64.Table, p []byte) Object {
// 	_res := _crc64.Update(crc, tab, p)
// 	return MakeBigIntU(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package crc64

import (
	. "github.com/candid82/joker/core"
	_crc64 "hash/crc64"
)

func init() {
}

GO FUNC hash/fnv.New128 from hash/fnv/fnv.go:
func __new128() Object {
	_res := _fnv.New128()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New128a from hash/fnv/fnv.go:
func __new128a() Object {
	_res := _fnv.New128a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32 from hash/fnv/fnv.go:
func __new32() Object {
	_res := _fnv.New32()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New32a from hash/fnv/fnv.go:
func __new32a() Object {
	_res := _fnv.New32a()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64 from hash/fnv/fnv.go:
func __new64() Object {
	_res := _fnv.New64()
	return MakeGoObject(_res)
}

GO FUNC hash/fnv.New64a from hash/fnv/fnv.go:
func __new64a() Object {
	_res := _fnv.New64a()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package fnv

import (
	. "github.com/candid82/joker/core"
	_fnv "hash/fnv"
)

func init() {
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package html

import (
)

func init() {
}

GO TYPE html/template.CSS from html/template/content.go:
func ExtractGoObjectCSS(args []Object, index int) *_template.CSS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.CSS:
			return &r
		case *_template.CSS:
			return r
		}
	case String:
		v := _template.CSS(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.CSS]"))
}

func _ConstructCSS(_v Object) _template.CSS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.CSS:
			return _g
		case *_template.CSS:
			return *_g
		}
	case String:
		return _template.CSS(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.CSS] or: String"))
}

GO TYPE html/template.Error from html/template/error.go:
func ExtractGoObjectError(args []Object, index int) *_template.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Error:
			return &r
		case *_template.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Error]"))
}

// func _mapToError(o Map) *_template.Error {
// 	return &_template.Error{}
// }

// func _vectorToError(o *Vector) *_template.Error {
// 	return &_template.Error{
// 		ErrorCode: _template.ErrorCode(AssertInt(o.Nth(0), "").I),
// 		Node: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Name: AssertString(o.Nth(2), "").S,
// 		Line: AssertInt(o.Nth(3), "").I,
// 		Description: AssertString(o.Nth(4), "").S,
// 	}
// }

// func _ConstructError(_v Object) *_template.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.Error:
// 			return &_g
// 		case *_template.Error:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToError(_o.(Map))
// 	case *Vector:
// 		return _vectorToError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Error] or: Map or Vector"))
// }

GO TYPE html/template.ErrorCode from html/template/error.go:
func ExtractGoObjectErrorCode(args []Object, index int) *_template.ErrorCode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.ErrorCode:
			return &r
		case *_template.ErrorCode:
			return r
		}
	case Int:
		v := _template.ErrorCode(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.ErrorCode]"))
}

func _ConstructErrorCode(_v Object) _template.ErrorCode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.ErrorCode:
			return _g
		case *_template.ErrorCode:
			return *_g
		}
	case Number:
		return _template.ErrorCode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.ErrorCode] or: Number"))
}

GO TYPE html/template.FuncMap from html/template/template.go:
func ExtractGoObjectFuncMap(args []Object, index int) *_template.FuncMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.FuncMap:
			return &r
		case *_template.FuncMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.FuncMap]"))
}

// func _ConstructFuncMap(_v Object) _template.FuncMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.FuncMap:
// 			return _g
// 		case *_template.FuncMap:
// 			return *_g
// 		}
// 	default:
// 		return _template.FuncMap(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for FuncMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.FuncMap] or: whatever"))
// }

GO TYPE html/template.HTML from html/template/content.go:
func ExtractGoObjectHTML(args []Object, index int) *_template.HTML {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.HTML:
			return &r
		case *_template.HTML:
			return r
		}
	case String:
		v := _template.HTML(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.HTML]"))
}

func _ConstructHTML(_v Object) _template.HTML {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.HTML:
			return _g
		case *_template.HTML:
			return *_g
		}
	case String:
		return _template.HTML(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.HTML] or: String"))
}

GO TYPE html/template.HTMLAttr from html/template/content.go:
func ExtractGoObjectHTMLAttr(args []Object, index int) *_template.HTMLAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.HTMLAttr:
			return &r
		case *_template.HTMLAttr:
			return r
		}
	case String:
		v := _template.HTMLAttr(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.HTMLAttr]"))
}

func _ConstructHTMLAttr(_v Object) _template.HTMLAttr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.HTMLAttr:
			return _g
		case *_template.HTMLAttr:
			return *_g
		}
	case String:
		return _template.HTMLAttr(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.HTMLAttr] or: String"))
}

GO TYPE html/template.JS from html/template/content.go:
func ExtractGoObjectJS(args []Object, index int) *_template.JS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.JS:
			return &r
		case *_template.JS:
			return r
		}
	case String:
		v := _template.JS(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.JS]"))
}

func _ConstructJS(_v Object) _template.JS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.JS:
			return _g
		case *_template.JS:
			return *_g
		}
	case String:
		return _template.JS(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.JS] or: String"))
}

GO TYPE html/template.JSStr from html/template/content.go:
func ExtractGoObjectJSStr(args []Object, index int) *_template.JSStr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.JSStr:
			return &r
		case *_template.JSStr:
			return r
		}
	case String:
		v := _template.JSStr(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.JSStr]"))
}

func _ConstructJSStr(_v Object) _template.JSStr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.JSStr:
			return _g
		case *_template.JSStr:
			return *_g
		}
	case String:
		return _template.JSStr(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.JSStr] or: String"))
}

GO TYPE html/template.Srcset from html/template/content.go:
func ExtractGoObjectSrcset(args []Object, index int) *_template.Srcset {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Srcset:
			return &r
		case *_template.Srcset:
			return r
		}
	case String:
		v := _template.Srcset(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Srcset]"))
}

func _ConstructSrcset(_v Object) _template.Srcset {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Srcset:
			return _g
		case *_template.Srcset:
			return *_g
		}
	case String:
		return _template.Srcset(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Srcset] or: String"))
}

GO TYPE html/template.Template from html/template/template.go:
func ExtractGoObjectTemplate(args []Object, index int) *_template.Template {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Template:
			return &r
		case *_template.Template:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.Template]"))
}

// func _mapToTemplate(o Map) *_template.Template {
// 	return &_template.Template{}
// }

// func _vectorToTemplate(o *Vector) *_template.Template {
// 	return &_template.Template{
// 		Tree: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructTemplate(_v Object) *_template.Template {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.Template:
// 			return &_g
// 		case *_template.Template:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTemplate(_o.(Map))
// 	case *Vector:
// 		return _vectorToTemplate(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Template] or: Map or Vector"))
// }

GO TYPE html/template.URL from html/template/content.go:
func ExtractGoObjectURL(args []Object, index int) *_template.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.URL:
			return &r
		case *_template.URL:
			return r
		}
	case String:
		v := _template.URL(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[html/template.URL]"))
}

func _ConstructURL(_v Object) _template.URL {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.URL:
			return _g
		case *_template.URL:
			return *_g
		}
	case String:
		return _template.URL(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.URL] or: String"))
}

GO FUNC html/template.HTMLEscape from html/template/escape.go:
// func __hTMLEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.HTMLEscaper from html/template/escape.go:
// func __hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.IsTrue from html/template/template.go:
// func __isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBoolean(truth))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC html/template.JSEscape from html/template/escape.go:
// func __jSEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.JSEscaper from html/template/escape.go:
// func __jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.Must from html/template/template.go:
func __must(t *_template.Template, err error) Object {
	_res := _template.Must(t, err)
	return MakeGoObject(_res)
}

GO FUNC html/template.New from html/template/template.go:
func __new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC html/template.ParseFiles from html/template/template.go:
// func __parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC html/template.ParseGlob from html/template/template.go:
func __parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.URLQueryEscaper from html/template/escape.go:
// func __uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC html/template.__ptrTo_Error_Error from html/template/error.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_html/template.Error)Error()", args, 0, 0)
	_res := o.O.(*_template.Error).Error()
	return MakeString(_res)
}

GO FUNC html/template.__ptrTo_Template_AddParseTree from html/template/template.go:
// func __ptrTo_Template_AddParseTree(o GoObject, args Object) Object {
// name string, tree *ABEND987(genutils.go: imports not yet supported: parse.Tree)}

GO FUNC html/template.__ptrTo_Template_Clone from html/template/template.go:
func __ptrTo_Template_Clone(o GoObject, args Object) Object {
	CheckGoArity("(*_html/template.Template)Clone()", args, 0, 0)
	_res1, _res2 := o.O.(*_template.Template).Clone()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.__ptrTo_Template_DefinedTemplates from html/template/template.go:
func __ptrTo_Template_DefinedTemplates(o GoObject, args Object) Object {
	CheckGoArity("(*_html/template.Template)DefinedTemplates()", args, 0, 0)
	_res := o.O.(*_template.Template).DefinedTemplates()
	return MakeString(_res)
}

GO FUNC html/template.__ptrTo_Template_Delims from html/template/template.go:
func __ptrTo_Template_Delims(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)Delims()", args, 2, 2)
	left := ExtractGoString("(*_html/template.Template)Delims()", "left", _argList, 0)
	right := ExtractGoString("(*_html/template.Template)Delims()", "right", _argList, 1)
	_res := o.O.(*_template.Template).Delims(left, right)
	return MakeGoObject(_res)
}

GO FUNC html/template.__ptrTo_Template_Execute from html/template/template.go:
// func __ptrTo_Template_Execute(o GoObject, args Object) Object {
// wr ABEND987(genutils.go: imports not yet supported: io.Writer), data interface {}}

GO FUNC html/template.__ptrTo_Template_ExecuteTemplate from html/template/template.go:
// func __ptrTo_Template_ExecuteTemplate(o GoObject, args Object) Object {
// wr ABEND987(genutils.go: imports not yet supported: io.Writer), name string, data interface {}}

GO FUNC html/template.__ptrTo_Template_Funcs from html/template/template.go:
func __ptrTo_Template_Funcs(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)Funcs()", args, 1, 1)
	funcMap := ExtractGo_go_std_html_template__FuncMap("(*_html/template.Template)Funcs()", "funcMap", _argList, 0)
	_res := o.O.(*_template.Template).Funcs(funcMap)
	return MakeGoObject(_res)
}

GO FUNC html/template.__ptrTo_Template_Lookup from html/template/template.go:
func __ptrTo_Template_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)Lookup()", args, 1, 1)
	name := ExtractGoString("(*_html/template.Template)Lookup()", "name", _argList, 0)
	_res := o.O.(*_template.Template).Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC html/template.__ptrTo_Template_Name from html/template/template.go:
func __ptrTo_Template_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_html/template.Template)Name()", args, 0, 0)
	_res := o.O.(*_template.Template).Name()
	return MakeString(_res)
}

GO FUNC html/template.__ptrTo_Template_New from html/template/template.go:
func __ptrTo_Template_New(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)New()", args, 1, 1)
	name := ExtractGoString("(*_html/template.Template)New()", "name", _argList, 0)
	_res := o.O.(*_template.Template).New(name)
	return MakeGoObject(_res)
}

GO FUNC html/template.__ptrTo_Template_Option from html/template/template.go:
// func __ptrTo_Template_Option(o GoObject, args Object) Object {
// (ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(opt)))}

GO FUNC html/template.__ptrTo_Template_Parse from html/template/template.go:
func __ptrTo_Template_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)Parse()", args, 1, 1)
	text := ExtractGoString("(*_html/template.Template)Parse()", "text", _argList, 0)
	_res1, _res2 := o.O.(*_template.Template).Parse(text)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.__ptrTo_Template_ParseFiles from html/template/template.go:
// func __ptrTo_Template_ParseFiles(o GoObject, args Object) Object {
// (ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(filenames)))}

GO FUNC html/template.__ptrTo_Template_ParseGlob from html/template/template.go:
func __ptrTo_Template_ParseGlob(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_html/template.Template)ParseGlob()", args, 1, 1)
	pattern := ExtractGoString("(*_html/template.Template)ParseGlob()", "pattern", _argList, 0)
	_res1, _res2 := o.O.(*_template.Template).ParseGlob(pattern)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC html/template.__ptrTo_Template_Templates from html/template/template.go:
func __ptrTo_Template_Templates(o GoObject, args Object) Object {
	CheckGoArity("(*_html/template.Template)Templates()", args, 0, 0)
	_res := o.O.(*_template.Template).Templates()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	. "github.com/candid82/joker/core"
	_template "html/template"
	_reflect "reflect"
)
var members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Error_Error,
}}

var members_PtrTo_Template = GoTypeInfo{Members: GoMembers{
	"Clone": __ptrTo_Template_Clone,
	"DefinedTemplates": __ptrTo_Template_DefinedTemplates,
	"Delims": __ptrTo_Template_Delims,
	"Funcs": __ptrTo_Template_Funcs,
	"Lookup": __ptrTo_Template_Lookup,
	"Name": __ptrTo_Template_Name,
	"New": __ptrTo_Template_New,
	"Parse": __ptrTo_Template_Parse,
	"ParseGlob": __ptrTo_Template_ParseGlob,
	"Templates": __ptrTo_Template_Templates,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_template.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_template.Template)(nil))] = &members_PtrTo_Template
}

GO TYPE image.Alpha from image/image.go:
func ExtractGoObjectAlpha(args []Object, index int) *_image.Alpha {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Alpha:
			return &r
		case *_image.Alpha:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Alpha]"))
}

// func _mapToAlpha(o Map) *_image.Alpha {
// 	return &_image.Alpha{}
// }

// func _vectorToAlpha(o *Vector) *_image.Alpha {
// 	return &_image.Alpha{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructAlpha(_v Object) *_image.Alpha {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Alpha:
// 			return &_g
// 		case *_image.Alpha:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAlpha(_o.(Map))
// 	case *Vector:
// 		return _vectorToAlpha(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Alpha] or: Map or Vector"))
// }

GO TYPE image.Alpha16 from image/image.go:
func ExtractGoObjectAlpha16(args []Object, index int) *_image.Alpha16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Alpha16:
			return &r
		case *_image.Alpha16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Alpha16]"))
}

// func _mapToAlpha16(o Map) *_image.Alpha16 {
// 	return &_image.Alpha16{}
// }

// func _vectorToAlpha16(o *Vector) *_image.Alpha16 {
// 	return &_image.Alpha16{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructAlpha16(_v Object) *_image.Alpha16 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Alpha16:
// 			return &_g
// 		case *_image.Alpha16:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAlpha16(_o.(Map))
// 	case *Vector:
// 		return _vectorToAlpha16(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Alpha16] or: Map or Vector"))
// }

GO TYPE image.CMYK from image/image.go:
func ExtractGoObjectCMYK(args []Object, index int) *_image.CMYK {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.CMYK:
			return &r
		case *_image.CMYK:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.CMYK]"))
}

// func _mapToCMYK(o Map) *_image.CMYK {
// 	return &_image.CMYK{}
// }

// func _vectorToCMYK(o *Vector) *_image.CMYK {
// 	return &_image.CMYK{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructCMYK(_v Object) *_image.CMYK {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.CMYK:
// 			return &_g
// 		case *_image.CMYK:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCMYK(_o.(Map))
// 	case *Vector:
// 		return _vectorToCMYK(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.CMYK] or: Map or Vector"))
// }

GO TYPE image.Config from image/image.go:
func ExtractGoObjectConfig(args []Object, index int) *_image.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Config:
			return &r
		case *_image.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Config]"))
}

// func _mapToConfig(o Map) *_image.Config {
// 	return &_image.Config{}
// }

// func _vectorToConfig(o *Vector) *_image.Config {
// 	return &_image.Config{
// 		ColorModel: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Width: AssertInt(o.Nth(1), "").I,
// 		Height: AssertInt(o.Nth(2), "").I,
// 	}
// }

// func _ConstructConfig(_v Object) *_image.Config {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Config:
// 			return &_g
// 		case *_image.Config:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Config] or: Map or Vector"))
// }

GO TYPE image.Gray from image/image.go:
func ExtractGoObjectGray(args []Object, index int) *_image.Gray {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Gray:
			return &r
		case *_image.Gray:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Gray]"))
}

// func _mapToGray(o Map) *_image.Gray {
// 	return &_image.Gray{}
// }

// func _vectorToGray(o *Vector) *_image.Gray {
// 	return &_image.Gray{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructGray(_v Object) *_image.Gray {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Gray:
// 			return &_g
// 		case *_image.Gray:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGray(_o.(Map))
// 	case *Vector:
// 		return _vectorToGray(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Gray] or: Map or Vector"))
// }

GO TYPE image.Gray16 from image/image.go:
func ExtractGoObjectGray16(args []Object, index int) *_image.Gray16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Gray16:
			return &r
		case *_image.Gray16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Gray16]"))
}

// func _mapToGray16(o Map) *_image.Gray16 {
// 	return &_image.Gray16{}
// }

// func _vectorToGray16(o *Vector) *_image.Gray16 {
// 	return &_image.Gray16{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructGray16(_v Object) *_image.Gray16 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Gray16:
// 			return &_g
// 		case *_image.Gray16:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGray16(_o.(Map))
// 	case *Vector:
// 		return _vectorToGray16(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Gray16] or: Map or Vector"))
// }

GO TYPE image.Image from image/image.go:
func ExtractGoObjectImage(args []Object, index int) *_image.Image {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Image:
			return &r
		case *_image.Image:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Image]"))
}

// func _ConstructImage(_v Object) _image.Image {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Image:
// 			return _g
// 		case *_image.Image:
// 			return *_g
// 		}
// 	default:
// 		return _image.Image(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Image))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Image] or: whatever"))
// }

GO TYPE image.NRGBA from image/image.go:
func ExtractGoObjectNRGBA(args []Object, index int) *_image.NRGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NRGBA:
			return &r
		case *_image.NRGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NRGBA]"))
}

// func _mapToNRGBA(o Map) *_image.NRGBA {
// 	return &_image.NRGBA{}
// }

// func _vectorToNRGBA(o *Vector) *_image.NRGBA {
// 	return &_image.NRGBA{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructNRGBA(_v Object) *_image.NRGBA {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.NRGBA:
// 			return &_g
// 		case *_image.NRGBA:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNRGBA(_o.(Map))
// 	case *Vector:
// 		return _vectorToNRGBA(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NRGBA] or: Map or Vector"))
// }

GO TYPE image.NRGBA64 from image/image.go:
func ExtractGoObjectNRGBA64(args []Object, index int) *_image.NRGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NRGBA64:
			return &r
		case *_image.NRGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NRGBA64]"))
}

// func _mapToNRGBA64(o Map) *_image.NRGBA64 {
// 	return &_image.NRGBA64{}
// }

// func _vectorToNRGBA64(o *Vector) *_image.NRGBA64 {
// 	return &_image.NRGBA64{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructNRGBA64(_v Object) *_image.NRGBA64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.NRGBA64:
// 			return &_g
// 		case *_image.NRGBA64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNRGBA64(_o.(Map))
// 	case *Vector:
// 		return _vectorToNRGBA64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NRGBA64] or: Map or Vector"))
// }

GO TYPE image.NYCbCrA from image/ycbcr.go:
func ExtractGoObjectNYCbCrA(args []Object, index int) *_image.NYCbCrA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.NYCbCrA:
			return &r
		case *_image.NYCbCrA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.NYCbCrA]"))
}

// func _mapToNYCbCrA(o Map) *_image.NYCbCrA {
// 	return &_image.NYCbCrA{}
// }

// func _vectorToNYCbCrA(o *Vector) *_image.NYCbCrA {
// 	return &_image.NYCbCrA{
// 		A: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		AStride: AssertInt(o.Nth(1), "").I,
// 	}
// }

// func _ConstructNYCbCrA(_v Object) *_image.NYCbCrA {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.NYCbCrA:
// 			return &_g
// 		case *_image.NYCbCrA:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNYCbCrA(_o.(Map))
// 	case *Vector:
// 		return _vectorToNYCbCrA(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.NYCbCrA] or: Map or Vector"))
// }

GO TYPE image.Paletted from image/image.go:
func ExtractGoObjectPaletted(args []Object, index int) *_image.Paletted {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Paletted:
			return &r
		case *_image.Paletted:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Paletted]"))
}

// func _mapToPaletted(o Map) *_image.Paletted {
// 	return &_image.Paletted{}
// }

// func _vectorToPaletted(o *Vector) *_image.Paletted {
// 	return &_image.Paletted{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Palette: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructPaletted(_v Object) *_image.Paletted {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Paletted:
// 			return &_g
// 		case *_image.Paletted:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPaletted(_o.(Map))
// 	case *Vector:
// 		return _vectorToPaletted(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Paletted] or: Map or Vector"))
// }

GO TYPE image.PalettedImage from image/image.go:
func ExtractGoObjectPalettedImage(args []Object, index int) *_image.PalettedImage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.PalettedImage:
			return &r
		case *_image.PalettedImage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.PalettedImage]"))
}

// func _ConstructPalettedImage(_v Object) _image.PalettedImage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.PalettedImage:
// 			return _g
// 		case *_image.PalettedImage:
// 			return *_g
// 		}
// 	default:
// 		return _image.PalettedImage(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PalettedImage))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.PalettedImage] or: whatever"))
// }

GO TYPE image.Point from image/geom.go:
func ExtractGoObjectPoint(args []Object, index int) *_image.Point {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Point:
			return &r
		case *_image.Point:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Point]"))
}

func _mapToPoint(o Map) *_image.Point {
	return &_image.Point{}
}

func _vectorToPoint(o *Vector) *_image.Point {
	return &_image.Point{
		X: AssertInt(o.Nth(0), "").I,
		Y: AssertInt(o.Nth(1), "").I,
	}
}

func _ConstructPoint(_v Object) *_image.Point {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.Point:
			return &_g
		case *_image.Point:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPoint(_o.(Map))
	case *Vector:
		return _vectorToPoint(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Point] or: Map or Vector"))
}

GO TYPE image.RGBA from image/image.go:
func ExtractGoObjectRGBA(args []Object, index int) *_image.RGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.RGBA:
			return &r
		case *_image.RGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.RGBA]"))
}

// func _mapToRGBA(o Map) *_image.RGBA {
// 	return &_image.RGBA{}
// }

// func _vectorToRGBA(o *Vector) *_image.RGBA {
// 	return &_image.RGBA{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructRGBA(_v Object) *_image.RGBA {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.RGBA:
// 			return &_g
// 		case *_image.RGBA:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRGBA(_o.(Map))
// 	case *Vector:
// 		return _vectorToRGBA(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.RGBA] or: Map or Vector"))
// }

GO TYPE image.RGBA64 from image/image.go:
func ExtractGoObjectRGBA64(args []Object, index int) *_image.RGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.RGBA64:
			return &r
		case *_image.RGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.RGBA64]"))
}

// func _mapToRGBA64(o Map) *_image.RGBA64 {
// 	return &_image.RGBA64{}
// }

// func _vectorToRGBA64(o *Vector) *_image.RGBA64 {
// 	return &_image.RGBA64{
// 		Pix: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Stride: AssertInt(o.Nth(1), "").I,
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructRGBA64(_v Object) *_image.RGBA64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.RGBA64:
// 			return &_g
// 		case *_image.RGBA64:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRGBA64(_o.(Map))
// 	case *Vector:
// 		return _vectorToRGBA64(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.RGBA64] or: Map or Vector"))
// }

GO TYPE image.Rectangle from image/geom.go:
func ExtractGoObjectRectangle(args []Object, index int) *_image.Rectangle {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Rectangle:
			return &r
		case *_image.Rectangle:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Rectangle]"))
}

// func _mapToRectangle(o Map) *_image.Rectangle {
// 	return &_image.Rectangle{}
// }

// func _vectorToRectangle(o *Vector) *_image.Rectangle {
// 	return &_image.Rectangle{
// 		Min: ABEND048(codegen.go: no conversion from Clojure for image.Point (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Max: ABEND048(codegen.go: no conversion from Clojure for image.Point (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructRectangle(_v Object) *_image.Rectangle {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Rectangle:
// 			return &_g
// 		case *_image.Rectangle:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRectangle(_o.(Map))
// 	case *Vector:
// 		return _vectorToRectangle(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Rectangle] or: Map or Vector"))
// }

GO TYPE image.Uniform from image/names.go:
func ExtractGoObjectUniform(args []Object, index int) *_image.Uniform {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.Uniform:
			return &r
		case *_image.Uniform:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.Uniform]"))
}

// func _mapToUniform(o Map) *_image.Uniform {
// 	return &_image.Uniform{}
// }

// func _vectorToUniform(o *Vector) *_image.Uniform {
// 	return &_image.Uniform{
// 		C: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructUniform(_v Object) *_image.Uniform {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.Uniform:
// 			return &_g
// 		case *_image.Uniform:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUniform(_o.(Map))
// 	case *Vector:
// 		return _vectorToUniform(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.Uniform] or: Map or Vector"))
// }

GO TYPE image.YCbCr from image/ycbcr.go:
func ExtractGoObjectYCbCr(args []Object, index int) *_image.YCbCr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.YCbCr:
			return &r
		case *_image.YCbCr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.YCbCr]"))
}

// func _mapToYCbCr(o Map) *_image.YCbCr {
// 	return &_image.YCbCr{}
// }

// func _vectorToYCbCr(o *Vector) *_image.YCbCr {
// 	return &_image.YCbCr{
// 		Y: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Cb: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		Cr: ABEND048(codegen.go: no conversion from Clojure for []uint8 (uint8)),
// 		YStride: AssertInt(o.Nth(3), "").I,
// 		CStride: AssertInt(o.Nth(4), "").I,
// 		SubsampleRatio: _image.YCbCrSubsampleRatio(AssertInt(o.Nth(5), "").I),
// 		Rect: ABEND048(codegen.go: no conversion from Clojure for image.Rectangle (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructYCbCr(_v Object) *_image.YCbCr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _image.YCbCr:
// 			return &_g
// 		case *_image.YCbCr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToYCbCr(_o.(Map))
// 	case *Vector:
// 		return _vectorToYCbCr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[image.YCbCr] or: Map or Vector"))
// }

GO TYPE image.YCbCrSubsampleRatio from image/ycbcr.go:
func ExtractGoObjectYCbCrSubsampleRatio(args []Object, index int) *_image.YCbCrSubsampleRatio {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _image.YCbCrSubsampleRatio:
			return &r
		case *_image.YCbCrSubsampleRatio:
			return r
		}
	case Int:
		v := _image.YCbCrSubsampleRatio(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image.YCbCrSubsampleRatio]"))
}

func _ConstructYCbCrSubsampleRatio(_v Object) _image.YCbCrSubsampleRatio {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _image.YCbCrSubsampleRatio:
			return _g
		case *_image.YCbCrSubsampleRatio:
			return *_g
		}
	case Number:
		return _image.YCbCrSubsampleRatio(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[image.YCbCrSubsampleRatio] or: Number"))
}

GO FUNC image.Decode from image/format.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2, _res3 := _image.Decode(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.DecodeConfig from image/format.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2, _res3 := _image.DecodeConfig(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.NewAlpha from image/image.go:
func __newAlpha(r _image.Rectangle) Object {
	_res := _image.NewAlpha(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewAlpha16 from image/image.go:
func __newAlpha16(r _image.Rectangle) Object {
	_res := _image.NewAlpha16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewCMYK from image/image.go:
func __newCMYK(r _image.Rectangle) Object {
	_res := _image.NewCMYK(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray from image/image.go:
func __newGray(r _image.Rectangle) Object {
	_res := _image.NewGray(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewGray16 from image/image.go:
func __newGray16(r _image.Rectangle) Object {
	_res := _image.NewGray16(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA from image/image.go:
func __newNRGBA(r _image.Rectangle) Object {
	_res := _image.NewNRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNRGBA64 from image/image.go:
func __newNRGBA64(r _image.Rectangle) Object {
	_res := _image.NewNRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewNYCbCrA from image/ycbcr.go:
func __newNYCbCrA(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewNYCbCrA(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.NewPaletted from image/image.go:
// func __newPaletted(r _image.Rectangle, p ABEND987(genutils.go: imports not yet supported: color.Palette)) Object {
// 	_res := _image.NewPaletted(r, p)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewRGBA from image/image.go:
func __newRGBA(r _image.Rectangle) Object {
	_res := _image.NewRGBA(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewRGBA64 from image/image.go:
func __newRGBA64(r _image.Rectangle) Object {
	_res := _image.NewRGBA64(r)
	return MakeGoObject(_res)
}

GO FUNC image.NewUniform from image/names.go:
// func __newUniform(c ABEND987(genutils.go: imports not yet supported: color.Color)) Object {
// 	_res := _image.NewUniform(c)
// 	return MakeGoObject(_res)
// }

GO FUNC image.NewYCbCr from image/ycbcr.go:
func __newYCbCr(r _image.Rectangle, subsampleRatio _image.YCbCrSubsampleRatio) Object {
	_res := _image.NewYCbCr(r, subsampleRatio)
	return MakeGoObject(_res)
}

GO FUNC image.Pt from image/geom.go:
func __pt(X int, Y int) Object {
	_res := _image.Pt(X, Y)
	return MakeGoObject(_res)
}

GO FUNC image.Rect from image/geom.go:
func __rect(x0 int, y0 int, x1 int, y1 int) Object {
	_res := _image.Rect(x0, y0, x1, y1)
	return MakeGoObject(_res)
}

GO FUNC image.RegisterFormat from image/format.go:
// func __registerFormat(name string, magic string, decode func, decodeConfig func) Object {
// 	_image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND675: TODO...
// }

GO FUNC image.__point_Add from image/geom.go:
func __point_Add(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Add()", args, 1, 1)
	q := ExtractGo_go_std_image__Point("(_image.Point)Add()", "q", _argList, 0)
	_res := o.O.(_image.Point).Add(q)
	return MakeGoObject(_res)
}

GO FUNC image.__point_Div from image/geom.go:
func __point_Div(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Div()", args, 1, 1)
	k := ExtractGoInt("(_image.Point)Div()", "k", _argList, 0)
	_res := o.O.(_image.Point).Div(k)
	return MakeGoObject(_res)
}

GO FUNC image.__point_Eq from image/geom.go:
func __point_Eq(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Eq()", args, 1, 1)
	q := ExtractGo_go_std_image__Point("(_image.Point)Eq()", "q", _argList, 0)
	_res := o.O.(_image.Point).Eq(q)
	return MakeBoolean(_res)
}

GO FUNC image.__point_In from image/geom.go:
func __point_In(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)In()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(_image.Point)In()", "r", _argList, 0)
	_res := o.O.(_image.Point).In(r)
	return MakeBoolean(_res)
}

GO FUNC image.__point_Mod from image/geom.go:
func __point_Mod(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Mod()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(_image.Point)Mod()", "r", _argList, 0)
	_res := o.O.(_image.Point).Mod(r)
	return MakeGoObject(_res)
}

GO FUNC image.__point_Mul from image/geom.go:
func __point_Mul(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Mul()", args, 1, 1)
	k := ExtractGoInt("(_image.Point)Mul()", "k", _argList, 0)
	_res := o.O.(_image.Point).Mul(k)
	return MakeGoObject(_res)
}

GO FUNC image.__point_String from image/geom.go:
func __point_String(o GoObject, args Object) Object {
	CheckGoArity("(_image.Point)String()", args, 0, 0)
	_res := o.O.(_image.Point).String()
	return MakeString(_res)
}

GO FUNC image.__point_Sub from image/geom.go:
func __point_Sub(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Point)Sub()", args, 1, 1)
	q := ExtractGo_go_std_image__Point("(_image.Point)Sub()", "q", _argList, 0)
	_res := o.O.(_image.Point).Sub(q)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha16_Alpha16At from image/image.go:
func __ptrTo_Alpha16_Alpha16At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha16)Alpha16At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha16)Alpha16At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha16)Alpha16At()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha16).Alpha16At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha16_At from image/image.go:
func __ptrTo_Alpha16_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha16)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha16)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha16)At()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha16).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha16_Bounds from image/image.go:
func __ptrTo_Alpha16_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha16)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Alpha16).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha16_ColorModel from image/image.go:
func __ptrTo_Alpha16_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha16)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Alpha16).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha16_Opaque from image/image.go:
func __ptrTo_Alpha16_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha16)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Alpha16).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Alpha16_PixOffset from image/image.go:
func __ptrTo_Alpha16_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha16)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha16)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha16)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha16).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_Alpha16_Set from image/image.go:
// func __ptrTo_Alpha16_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Alpha16_SetAlpha16 from image/image.go:
// func __ptrTo_Alpha16_SetAlpha16(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Alpha16)}

GO FUNC image.__ptrTo_Alpha16_SubImage from image/image.go:
func __ptrTo_Alpha16_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha16)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.Alpha16)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.Alpha16).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha_AlphaAt from image/image.go:
func __ptrTo_Alpha_AlphaAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha)AlphaAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha)AlphaAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha)AlphaAt()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha).AlphaAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha_At from image/image.go:
func __ptrTo_Alpha_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha)At()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha_Bounds from image/image.go:
func __ptrTo_Alpha_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Alpha).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha_ColorModel from image/image.go:
func __ptrTo_Alpha_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Alpha).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Alpha_Opaque from image/image.go:
func __ptrTo_Alpha_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Alpha)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Alpha).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Alpha_PixOffset from image/image.go:
func __ptrTo_Alpha_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.Alpha)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Alpha)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.Alpha).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_Alpha_Set from image/image.go:
// func __ptrTo_Alpha_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Alpha_SetAlpha from image/image.go:
// func __ptrTo_Alpha_SetAlpha(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Alpha)}

GO FUNC image.__ptrTo_Alpha_SubImage from image/image.go:
func __ptrTo_Alpha_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Alpha)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.Alpha)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.Alpha).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_CMYK_At from image/image.go:
func __ptrTo_CMYK_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.CMYK)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.CMYK)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.CMYK)At()", "y", _argList, 1)
	_res := o.O.(*_image.CMYK).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_CMYK_Bounds from image/image.go:
func __ptrTo_CMYK_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.CMYK)Bounds()", args, 0, 0)
	_res := o.O.(*_image.CMYK).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_CMYK_CMYKAt from image/image.go:
func __ptrTo_CMYK_CMYKAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.CMYK)CMYKAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.CMYK)CMYKAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.CMYK)CMYKAt()", "y", _argList, 1)
	_res := o.O.(*_image.CMYK).CMYKAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_CMYK_ColorModel from image/image.go:
func __ptrTo_CMYK_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.CMYK)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.CMYK).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_CMYK_Opaque from image/image.go:
func __ptrTo_CMYK_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.CMYK)Opaque()", args, 0, 0)
	_res := o.O.(*_image.CMYK).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_CMYK_PixOffset from image/image.go:
func __ptrTo_CMYK_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.CMYK)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.CMYK)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.CMYK)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.CMYK).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_CMYK_Set from image/image.go:
// func __ptrTo_CMYK_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_CMYK_SetCMYK from image/image.go:
// func __ptrTo_CMYK_SetCMYK(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.CMYK)}

GO FUNC image.__ptrTo_CMYK_SubImage from image/image.go:
func __ptrTo_CMYK_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.CMYK)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.CMYK)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.CMYK).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray16_At from image/image.go:
func __ptrTo_Gray16_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray16)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray16)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray16)At()", "y", _argList, 1)
	_res := o.O.(*_image.Gray16).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray16_Bounds from image/image.go:
func __ptrTo_Gray16_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray16)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Gray16).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray16_ColorModel from image/image.go:
func __ptrTo_Gray16_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray16)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Gray16).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray16_Gray16At from image/image.go:
func __ptrTo_Gray16_Gray16At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray16)Gray16At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray16)Gray16At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray16)Gray16At()", "y", _argList, 1)
	_res := o.O.(*_image.Gray16).Gray16At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray16_Opaque from image/image.go:
func __ptrTo_Gray16_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray16)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Gray16).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Gray16_PixOffset from image/image.go:
func __ptrTo_Gray16_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray16)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray16)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray16)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.Gray16).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_Gray16_Set from image/image.go:
// func __ptrTo_Gray16_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Gray16_SetGray16 from image/image.go:
// func __ptrTo_Gray16_SetGray16(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Gray16)}

GO FUNC image.__ptrTo_Gray16_SubImage from image/image.go:
func __ptrTo_Gray16_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray16)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.Gray16)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.Gray16).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray_At from image/image.go:
func __ptrTo_Gray_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray)At()", "y", _argList, 1)
	_res := o.O.(*_image.Gray).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray_Bounds from image/image.go:
func __ptrTo_Gray_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Gray).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray_ColorModel from image/image.go:
func __ptrTo_Gray_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Gray).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray_GrayAt from image/image.go:
func __ptrTo_Gray_GrayAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray)GrayAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray)GrayAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray)GrayAt()", "y", _argList, 1)
	_res := o.O.(*_image.Gray).GrayAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Gray_Opaque from image/image.go:
func __ptrTo_Gray_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Gray)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Gray).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Gray_PixOffset from image/image.go:
func __ptrTo_Gray_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.Gray)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Gray)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.Gray).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_Gray_Set from image/image.go:
// func __ptrTo_Gray_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Gray_SetGray from image/image.go:
// func __ptrTo_Gray_SetGray(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Gray)}

GO FUNC image.__ptrTo_Gray_SubImage from image/image.go:
func __ptrTo_Gray_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Gray)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.Gray)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.Gray).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA64_At from image/image.go:
func __ptrTo_NRGBA64_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA64)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA64)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA64)At()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA64).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA64_Bounds from image/image.go:
func __ptrTo_NRGBA64_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA64)Bounds()", args, 0, 0)
	_res := o.O.(*_image.NRGBA64).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA64_ColorModel from image/image.go:
func __ptrTo_NRGBA64_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA64)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.NRGBA64).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA64_NRGBA64At from image/image.go:
func __ptrTo_NRGBA64_NRGBA64At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA64)NRGBA64At()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA64)NRGBA64At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA64)NRGBA64At()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA64).NRGBA64At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA64_Opaque from image/image.go:
func __ptrTo_NRGBA64_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA64)Opaque()", args, 0, 0)
	_res := o.O.(*_image.NRGBA64).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_NRGBA64_PixOffset from image/image.go:
func __ptrTo_NRGBA64_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA64)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA64)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA64)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA64).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_NRGBA64_Set from image/image.go:
// func __ptrTo_NRGBA64_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_NRGBA64_SetNRGBA64 from image/image.go:
// func __ptrTo_NRGBA64_SetNRGBA64(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.NRGBA64)}

GO FUNC image.__ptrTo_NRGBA64_SubImage from image/image.go:
func __ptrTo_NRGBA64_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA64)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.NRGBA64)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.NRGBA64).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA_At from image/image.go:
func __ptrTo_NRGBA_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA)At()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA_Bounds from image/image.go:
func __ptrTo_NRGBA_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA)Bounds()", args, 0, 0)
	_res := o.O.(*_image.NRGBA).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA_ColorModel from image/image.go:
func __ptrTo_NRGBA_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.NRGBA).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA_NRGBAAt from image/image.go:
func __ptrTo_NRGBA_NRGBAAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA)NRGBAAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA)NRGBAAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA)NRGBAAt()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA).NRGBAAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NRGBA_Opaque from image/image.go:
func __ptrTo_NRGBA_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NRGBA)Opaque()", args, 0, 0)
	_res := o.O.(*_image.NRGBA).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_NRGBA_PixOffset from image/image.go:
func __ptrTo_NRGBA_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.NRGBA)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NRGBA)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.NRGBA).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_NRGBA_Set from image/image.go:
// func __ptrTo_NRGBA_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_NRGBA_SetNRGBA from image/image.go:
// func __ptrTo_NRGBA_SetNRGBA(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.NRGBA)}

GO FUNC image.__ptrTo_NRGBA_SubImage from image/image.go:
func __ptrTo_NRGBA_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NRGBA)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.NRGBA)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.NRGBA).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_AOffset from image/ycbcr.go:
func __ptrTo_NYCbCrA_AOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NYCbCrA)AOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.NYCbCrA)AOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NYCbCrA)AOffset()", "y", _argList, 1)
	_res := o.O.(*_image.NYCbCrA).AOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_At from image/ycbcr.go:
func __ptrTo_NYCbCrA_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NYCbCrA)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.NYCbCrA)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NYCbCrA)At()", "y", _argList, 1)
	_res := o.O.(*_image.NYCbCrA).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_ColorModel from image/ycbcr.go:
func __ptrTo_NYCbCrA_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NYCbCrA)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.NYCbCrA).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_NYCbCrAAt from image/ycbcr.go:
func __ptrTo_NYCbCrA_NYCbCrAAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NYCbCrA)NYCbCrAAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.NYCbCrA)NYCbCrAAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.NYCbCrA)NYCbCrAAt()", "y", _argList, 1)
	_res := o.O.(*_image.NYCbCrA).NYCbCrAAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_Opaque from image/ycbcr.go:
func __ptrTo_NYCbCrA_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.NYCbCrA)Opaque()", args, 0, 0)
	_res := o.O.(*_image.NYCbCrA).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_NYCbCrA_SubImage from image/ycbcr.go:
func __ptrTo_NYCbCrA_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.NYCbCrA)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.NYCbCrA)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.NYCbCrA).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Paletted_At from image/image.go:
func __ptrTo_Paletted_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Paletted)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Paletted)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Paletted)At()", "y", _argList, 1)
	_res := o.O.(*_image.Paletted).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Paletted_Bounds from image/image.go:
func __ptrTo_Paletted_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Paletted)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Paletted).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Paletted_ColorIndexAt from image/image.go:
func __ptrTo_Paletted_ColorIndexAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Paletted)ColorIndexAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.Paletted)ColorIndexAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Paletted)ColorIndexAt()", "y", _argList, 1)
	_res := o.O.(*_image.Paletted).ColorIndexAt(x, y)
	return MakeInt(int(_res))
}

GO FUNC image.__ptrTo_Paletted_ColorModel from image/image.go:
func __ptrTo_Paletted_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Paletted)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Paletted).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Paletted_Opaque from image/image.go:
func __ptrTo_Paletted_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Paletted)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Paletted).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Paletted_PixOffset from image/image.go:
func __ptrTo_Paletted_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Paletted)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.Paletted)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Paletted)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.Paletted).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_Paletted_Set from image/image.go:
// func __ptrTo_Paletted_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Paletted_SetColorIndex from image/image.go:
// func __ptrTo_Paletted_SetColorIndex(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC image.__ptrTo_Paletted_SubImage from image/image.go:
func __ptrTo_Paletted_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Paletted)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.Paletted)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.Paletted).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA64_At from image/image.go:
func __ptrTo_RGBA64_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA64)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA64)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA64)At()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA64).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA64_Bounds from image/image.go:
func __ptrTo_RGBA64_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA64)Bounds()", args, 0, 0)
	_res := o.O.(*_image.RGBA64).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA64_ColorModel from image/image.go:
func __ptrTo_RGBA64_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA64)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.RGBA64).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA64_Opaque from image/image.go:
func __ptrTo_RGBA64_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA64)Opaque()", args, 0, 0)
	_res := o.O.(*_image.RGBA64).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_RGBA64_PixOffset from image/image.go:
func __ptrTo_RGBA64_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA64)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA64)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA64)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA64).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_RGBA64_RGBA64At from image/image.go:
func __ptrTo_RGBA64_RGBA64At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA64)RGBA64At()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA64)RGBA64At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA64)RGBA64At()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA64).RGBA64At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA64_Set from image/image.go:
// func __ptrTo_RGBA64_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_RGBA64_SetRGBA64 from image/image.go:
// func __ptrTo_RGBA64_SetRGBA64(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.RGBA64)}

GO FUNC image.__ptrTo_RGBA64_SubImage from image/image.go:
func __ptrTo_RGBA64_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA64)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.RGBA64)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.RGBA64).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA_At from image/image.go:
func __ptrTo_RGBA_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA)At()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA_Bounds from image/image.go:
func __ptrTo_RGBA_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA)Bounds()", args, 0, 0)
	_res := o.O.(*_image.RGBA).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA_ColorModel from image/image.go:
func __ptrTo_RGBA_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.RGBA).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA_Opaque from image/image.go:
func __ptrTo_RGBA_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.RGBA)Opaque()", args, 0, 0)
	_res := o.O.(*_image.RGBA).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_RGBA_PixOffset from image/image.go:
func __ptrTo_RGBA_PixOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA)PixOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA)PixOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA)PixOffset()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA).PixOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_RGBA_RGBAAt from image/image.go:
func __ptrTo_RGBA_RGBAAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA)RGBAAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.RGBA)RGBAAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.RGBA)RGBAAt()", "y", _argList, 1)
	_res := o.O.(*_image.RGBA).RGBAAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_RGBA_Set from image/image.go:
// func __ptrTo_RGBA_Set(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_RGBA_SetRGBA from image/image.go:
// func __ptrTo_RGBA_SetRGBA(o GoObject, args Object) Object {
// x int, y int, c ABEND987(genutils.go: imports not yet supported: color.RGBA)}

GO FUNC image.__ptrTo_RGBA_SubImage from image/image.go:
func __ptrTo_RGBA_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.RGBA)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.RGBA)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.RGBA).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Uniform_At from image/names.go:
func __ptrTo_Uniform_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.Uniform)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.Uniform)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.Uniform)At()", "y", _argList, 1)
	_res := o.O.(*_image.Uniform).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Uniform_Bounds from image/names.go:
func __ptrTo_Uniform_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Uniform)Bounds()", args, 0, 0)
	_res := o.O.(*_image.Uniform).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Uniform_ColorModel from image/names.go:
func __ptrTo_Uniform_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Uniform)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.Uniform).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_Uniform_Convert from image/names.go:
// func __ptrTo_Uniform_Convert(o GoObject, args Object) Object {
// 1 ABEND987(genutils.go: imports not yet supported: color.Color)}

GO FUNC image.__ptrTo_Uniform_Opaque from image/names.go:
func __ptrTo_Uniform_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Uniform)Opaque()", args, 0, 0)
	_res := o.O.(*_image.Uniform).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_Uniform_RGBA from image/names.go:
func __ptrTo_Uniform_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(*_image.Uniform)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(*_image.Uniform).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image.__ptrTo_YCbCr_At from image/ycbcr.go:
func __ptrTo_YCbCr_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.YCbCr)At()", args, 2, 2)
	x := ExtractGoInt("(*_image.YCbCr)At()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.YCbCr)At()", "y", _argList, 1)
	_res := o.O.(*_image.YCbCr).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_YCbCr_Bounds from image/ycbcr.go:
func __ptrTo_YCbCr_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(*_image.YCbCr)Bounds()", args, 0, 0)
	_res := o.O.(*_image.YCbCr).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_YCbCr_COffset from image/ycbcr.go:
func __ptrTo_YCbCr_COffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.YCbCr)COffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.YCbCr)COffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.YCbCr)COffset()", "y", _argList, 1)
	_res := o.O.(*_image.YCbCr).COffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__ptrTo_YCbCr_ColorModel from image/ycbcr.go:
func __ptrTo_YCbCr_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(*_image.YCbCr)ColorModel()", args, 0, 0)
	_res := o.O.(*_image.YCbCr).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_YCbCr_Opaque from image/ycbcr.go:
func __ptrTo_YCbCr_Opaque(o GoObject, args Object) Object {
	CheckGoArity("(*_image.YCbCr)Opaque()", args, 0, 0)
	_res := o.O.(*_image.YCbCr).Opaque()
	return MakeBoolean(_res)
}

GO FUNC image.__ptrTo_YCbCr_SubImage from image/ycbcr.go:
func __ptrTo_YCbCr_SubImage(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.YCbCr)SubImage()", args, 1, 1)
	r := ExtractGo_go_std_image__Rectangle("(*_image.YCbCr)SubImage()", "r", _argList, 0)
	_res := o.O.(*_image.YCbCr).SubImage(r)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_YCbCr_YCbCrAt from image/ycbcr.go:
func __ptrTo_YCbCr_YCbCrAt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.YCbCr)YCbCrAt()", args, 2, 2)
	x := ExtractGoInt("(*_image.YCbCr)YCbCrAt()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.YCbCr)YCbCrAt()", "y", _argList, 1)
	_res := o.O.(*_image.YCbCr).YCbCrAt(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__ptrTo_YCbCr_YOffset from image/ycbcr.go:
func __ptrTo_YCbCr_YOffset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_image.YCbCr)YOffset()", args, 2, 2)
	x := ExtractGoInt("(*_image.YCbCr)YOffset()", "x", _argList, 0)
	y := ExtractGoInt("(*_image.YCbCr)YOffset()", "y", _argList, 1)
	_res := o.O.(*_image.YCbCr).YOffset(x, y)
	return MakeInt(_res)
}

GO FUNC image.__rectangle_Add from image/geom.go:
func __rectangle_Add(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Add()", args, 1, 1)
	p := ExtractGo_go_std_image__Point("(_image.Rectangle)Add()", "p", _argList, 0)
	_res := o.O.(_image.Rectangle).Add(p)
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_At from image/geom.go:
func __rectangle_At(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)At()", args, 2, 2)
	x := ExtractGoInt("(_image.Rectangle)At()", "x", _argList, 0)
	y := ExtractGoInt("(_image.Rectangle)At()", "y", _argList, 1)
	_res := o.O.(_image.Rectangle).At(x, y)
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Bounds from image/geom.go:
func __rectangle_Bounds(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Bounds()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Bounds()
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Canon from image/geom.go:
func __rectangle_Canon(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Canon()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Canon()
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_ColorModel from image/geom.go:
func __rectangle_ColorModel(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)ColorModel()", args, 0, 0)
	_res := o.O.(_image.Rectangle).ColorModel()
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Dx from image/geom.go:
func __rectangle_Dx(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Dx()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Dx()
	return MakeInt(_res)
}

GO FUNC image.__rectangle_Dy from image/geom.go:
func __rectangle_Dy(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Dy()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Dy()
	return MakeInt(_res)
}

GO FUNC image.__rectangle_Empty from image/geom.go:
func __rectangle_Empty(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Empty()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Empty()
	return MakeBoolean(_res)
}

GO FUNC image.__rectangle_Eq from image/geom.go:
func __rectangle_Eq(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Eq()", args, 1, 1)
	s := ExtractGo_go_std_image__Rectangle("(_image.Rectangle)Eq()", "s", _argList, 0)
	_res := o.O.(_image.Rectangle).Eq(s)
	return MakeBoolean(_res)
}

GO FUNC image.__rectangle_In from image/geom.go:
func __rectangle_In(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)In()", args, 1, 1)
	s := ExtractGo_go_std_image__Rectangle("(_image.Rectangle)In()", "s", _argList, 0)
	_res := o.O.(_image.Rectangle).In(s)
	return MakeBoolean(_res)
}

GO FUNC image.__rectangle_Inset from image/geom.go:
func __rectangle_Inset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Inset()", args, 1, 1)
	n := ExtractGoInt("(_image.Rectangle)Inset()", "n", _argList, 0)
	_res := o.O.(_image.Rectangle).Inset(n)
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Intersect from image/geom.go:
func __rectangle_Intersect(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Intersect()", args, 1, 1)
	s := ExtractGo_go_std_image__Rectangle("(_image.Rectangle)Intersect()", "s", _argList, 0)
	_res := o.O.(_image.Rectangle).Intersect(s)
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Overlaps from image/geom.go:
func __rectangle_Overlaps(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Overlaps()", args, 1, 1)
	s := ExtractGo_go_std_image__Rectangle("(_image.Rectangle)Overlaps()", "s", _argList, 0)
	_res := o.O.(_image.Rectangle).Overlaps(s)
	return MakeBoolean(_res)
}

GO FUNC image.__rectangle_Size from image/geom.go:
func __rectangle_Size(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)Size()", args, 0, 0)
	_res := o.O.(_image.Rectangle).Size()
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_String from image/geom.go:
func __rectangle_String(o GoObject, args Object) Object {
	CheckGoArity("(_image.Rectangle)String()", args, 0, 0)
	_res := o.O.(_image.Rectangle).String()
	return MakeString(_res)
}

GO FUNC image.__rectangle_Sub from image/geom.go:
func __rectangle_Sub(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Sub()", args, 1, 1)
	p := ExtractGo_go_std_image__Point("(_image.Rectangle)Sub()", "p", _argList, 0)
	_res := o.O.(_image.Rectangle).Sub(p)
	return MakeGoObject(_res)
}

GO FUNC image.__rectangle_Union from image/geom.go:
func __rectangle_Union(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image.Rectangle)Union()", args, 1, 1)
	s := ExtractGo_go_std_image__Rectangle("(_image.Rectangle)Union()", "s", _argList, 0)
	_res := o.O.(_image.Rectangle).Union(s)
	return MakeGoObject(_res)
}

GO FUNC image.__yCbCrSubsampleRatio_String from image/ycbcr.go:
func __yCbCrSubsampleRatio_String(o GoObject, args Object) Object {
	CheckGoArity("(_image.YCbCrSubsampleRatio)String()", args, 0, 0)
	_res := o.O.(_image.YCbCrSubsampleRatio).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package image

import (
	. "github.com/candid82/joker/core"
	_image "image"
	_reflect "reflect"
)
var members_PtrTo_Alpha = GoTypeInfo{Members: GoMembers{
	"AlphaAt": __ptrTo_Alpha_AlphaAt,
	"At": __ptrTo_Alpha_At,
	"Bounds": __ptrTo_Alpha_Bounds,
	"ColorModel": __ptrTo_Alpha_ColorModel,
	"Opaque": __ptrTo_Alpha_Opaque,
	"PixOffset": __ptrTo_Alpha_PixOffset,
	"SubImage": __ptrTo_Alpha_SubImage,
}}

var members_PtrTo_Alpha16 = GoTypeInfo{Members: GoMembers{
	"Alpha16At": __ptrTo_Alpha16_Alpha16At,
	"At": __ptrTo_Alpha16_At,
	"Bounds": __ptrTo_Alpha16_Bounds,
	"ColorModel": __ptrTo_Alpha16_ColorModel,
	"Opaque": __ptrTo_Alpha16_Opaque,
	"PixOffset": __ptrTo_Alpha16_PixOffset,
	"SubImage": __ptrTo_Alpha16_SubImage,
}}

var members_PtrTo_CMYK = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_CMYK_At,
	"Bounds": __ptrTo_CMYK_Bounds,
	"CMYKAt": __ptrTo_CMYK_CMYKAt,
	"ColorModel": __ptrTo_CMYK_ColorModel,
	"Opaque": __ptrTo_CMYK_Opaque,
	"PixOffset": __ptrTo_CMYK_PixOffset,
	"SubImage": __ptrTo_CMYK_SubImage,
}}

var members_PtrTo_Gray = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_Gray_At,
	"Bounds": __ptrTo_Gray_Bounds,
	"ColorModel": __ptrTo_Gray_ColorModel,
	"GrayAt": __ptrTo_Gray_GrayAt,
	"Opaque": __ptrTo_Gray_Opaque,
	"PixOffset": __ptrTo_Gray_PixOffset,
	"SubImage": __ptrTo_Gray_SubImage,
}}

var members_PtrTo_Gray16 = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_Gray16_At,
	"Bounds": __ptrTo_Gray16_Bounds,
	"ColorModel": __ptrTo_Gray16_ColorModel,
	"Gray16At": __ptrTo_Gray16_Gray16At,
	"Opaque": __ptrTo_Gray16_Opaque,
	"PixOffset": __ptrTo_Gray16_PixOffset,
	"SubImage": __ptrTo_Gray16_SubImage,
}}

var members_PtrTo_NRGBA = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_NRGBA_At,
	"Bounds": __ptrTo_NRGBA_Bounds,
	"ColorModel": __ptrTo_NRGBA_ColorModel,
	"NRGBAAt": __ptrTo_NRGBA_NRGBAAt,
	"Opaque": __ptrTo_NRGBA_Opaque,
	"PixOffset": __ptrTo_NRGBA_PixOffset,
	"SubImage": __ptrTo_NRGBA_SubImage,
}}

var members_PtrTo_NRGBA64 = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_NRGBA64_At,
	"Bounds": __ptrTo_NRGBA64_Bounds,
	"ColorModel": __ptrTo_NRGBA64_ColorModel,
	"NRGBA64At": __ptrTo_NRGBA64_NRGBA64At,
	"Opaque": __ptrTo_NRGBA64_Opaque,
	"PixOffset": __ptrTo_NRGBA64_PixOffset,
	"SubImage": __ptrTo_NRGBA64_SubImage,
}}

var members_PtrTo_NYCbCrA = GoTypeInfo{Members: GoMembers{
	"AOffset": __ptrTo_NYCbCrA_AOffset,
	"At": __ptrTo_NYCbCrA_At,
	"ColorModel": __ptrTo_NYCbCrA_ColorModel,
	"NYCbCrAAt": __ptrTo_NYCbCrA_NYCbCrAAt,
	"Opaque": __ptrTo_NYCbCrA_Opaque,
	"SubImage": __ptrTo_NYCbCrA_SubImage,
}}

var members_PtrTo_Paletted = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_Paletted_At,
	"Bounds": __ptrTo_Paletted_Bounds,
	"ColorIndexAt": __ptrTo_Paletted_ColorIndexAt,
	"ColorModel": __ptrTo_Paletted_ColorModel,
	"Opaque": __ptrTo_Paletted_Opaque,
	"PixOffset": __ptrTo_Paletted_PixOffset,
	"SubImage": __ptrTo_Paletted_SubImage,
}}

var members_Point = GoTypeInfo{Members: GoMembers{
	"Add": __point_Add,
	"Div": __point_Div,
	"Eq": __point_Eq,
	"In": __point_In,
	"Mod": __point_Mod,
	"Mul": __point_Mul,
	"String": __point_String,
	"Sub": __point_Sub,
}}

var members_PtrTo_RGBA = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_RGBA_At,
	"Bounds": __ptrTo_RGBA_Bounds,
	"ColorModel": __ptrTo_RGBA_ColorModel,
	"Opaque": __ptrTo_RGBA_Opaque,
	"PixOffset": __ptrTo_RGBA_PixOffset,
	"RGBAAt": __ptrTo_RGBA_RGBAAt,
	"SubImage": __ptrTo_RGBA_SubImage,
}}

var members_PtrTo_RGBA64 = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_RGBA64_At,
	"Bounds": __ptrTo_RGBA64_Bounds,
	"ColorModel": __ptrTo_RGBA64_ColorModel,
	"Opaque": __ptrTo_RGBA64_Opaque,
	"PixOffset": __ptrTo_RGBA64_PixOffset,
	"RGBA64At": __ptrTo_RGBA64_RGBA64At,
	"SubImage": __ptrTo_RGBA64_SubImage,
}}

var members_Rectangle = GoTypeInfo{Members: GoMembers{
	"Add": __rectangle_Add,
	"At": __rectangle_At,
	"Bounds": __rectangle_Bounds,
	"Canon": __rectangle_Canon,
	"ColorModel": __rectangle_ColorModel,
	"Dx": __rectangle_Dx,
	"Dy": __rectangle_Dy,
	"Empty": __rectangle_Empty,
	"Eq": __rectangle_Eq,
	"In": __rectangle_In,
	"Inset": __rectangle_Inset,
	"Intersect": __rectangle_Intersect,
	"Overlaps": __rectangle_Overlaps,
	"Size": __rectangle_Size,
	"String": __rectangle_String,
	"Sub": __rectangle_Sub,
	"Union": __rectangle_Union,
}}

var members_PtrTo_Uniform = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_Uniform_At,
	"Bounds": __ptrTo_Uniform_Bounds,
	"ColorModel": __ptrTo_Uniform_ColorModel,
	"Opaque": __ptrTo_Uniform_Opaque,
	"RGBA": __ptrTo_Uniform_RGBA,
}}

var members_PtrTo_YCbCr = GoTypeInfo{Members: GoMembers{
	"At": __ptrTo_YCbCr_At,
	"Bounds": __ptrTo_YCbCr_Bounds,
	"COffset": __ptrTo_YCbCr_COffset,
	"ColorModel": __ptrTo_YCbCr_ColorModel,
	"Opaque": __ptrTo_YCbCr_Opaque,
	"SubImage": __ptrTo_YCbCr_SubImage,
	"YCbCrAt": __ptrTo_YCbCr_YCbCrAt,
	"YOffset": __ptrTo_YCbCr_YOffset,
}}

var members_YCbCrSubsampleRatio = GoTypeInfo{Members: GoMembers{
	"String": __yCbCrSubsampleRatio_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_image.Alpha)(nil))] = &members_PtrTo_Alpha
	GoTypes[_reflect.TypeOf((*_image.Alpha16)(nil))] = &members_PtrTo_Alpha16
	GoTypes[_reflect.TypeOf((*_image.CMYK)(nil))] = &members_PtrTo_CMYK
	GoTypes[_reflect.TypeOf((*_image.Gray)(nil))] = &members_PtrTo_Gray
	GoTypes[_reflect.TypeOf((*_image.Gray16)(nil))] = &members_PtrTo_Gray16
	GoTypes[_reflect.TypeOf((*_image.NRGBA)(nil))] = &members_PtrTo_NRGBA
	GoTypes[_reflect.TypeOf((*_image.NRGBA64)(nil))] = &members_PtrTo_NRGBA64
	GoTypes[_reflect.TypeOf((*_image.NYCbCrA)(nil))] = &members_PtrTo_NYCbCrA
	GoTypes[_reflect.TypeOf((*_image.Paletted)(nil))] = &members_PtrTo_Paletted
	GoTypes[_reflect.TypeOf((*_image.Point)(nil)).Elem()] = &members_Point
	GoTypes[_reflect.TypeOf((*_image.RGBA)(nil))] = &members_PtrTo_RGBA
	GoTypes[_reflect.TypeOf((*_image.RGBA64)(nil))] = &members_PtrTo_RGBA64
	GoTypes[_reflect.TypeOf((*_image.Rectangle)(nil)).Elem()] = &members_Rectangle
	GoTypes[_reflect.TypeOf((*_image.Uniform)(nil))] = &members_PtrTo_Uniform
	GoTypes[_reflect.TypeOf((*_image.YCbCr)(nil))] = &members_PtrTo_YCbCr
	GoTypes[_reflect.TypeOf((*_image.YCbCrSubsampleRatio)(nil)).Elem()] = &members_YCbCrSubsampleRatio
}

GO TYPE image/color.Alpha from image/color/color.go:
func ExtractGoObjectAlpha(args []Object, index int) *_color.Alpha {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Alpha:
			return &r
		case *_color.Alpha:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Alpha]"))
}

func _mapToAlpha(o Map) *_color.Alpha {
	return &_color.Alpha{}
}

func _vectorToAlpha(o *Vector) *_color.Alpha {
	return &_color.Alpha{
		A: uint8(AssertInt(o.Nth(0), "").I),
	}
}

func _ConstructAlpha(_v Object) *_color.Alpha {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.Alpha:
			return &_g
		case *_color.Alpha:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAlpha(_o.(Map))
	case *Vector:
		return _vectorToAlpha(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Alpha] or: Map or Vector"))
}

GO TYPE image/color.Alpha16 from image/color/color.go:
func ExtractGoObjectAlpha16(args []Object, index int) *_color.Alpha16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Alpha16:
			return &r
		case *_color.Alpha16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Alpha16]"))
}

func _mapToAlpha16(o Map) *_color.Alpha16 {
	return &_color.Alpha16{}
}

func _vectorToAlpha16(o *Vector) *_color.Alpha16 {
	return &_color.Alpha16{
		A: uint16(AssertInt(o.Nth(0), "").I),
	}
}

func _ConstructAlpha16(_v Object) *_color.Alpha16 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.Alpha16:
			return &_g
		case *_color.Alpha16:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAlpha16(_o.(Map))
	case *Vector:
		return _vectorToAlpha16(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Alpha16] or: Map or Vector"))
}

GO TYPE image/color.CMYK from image/color/ycbcr.go:
func ExtractGoObjectCMYK(args []Object, index int) *_color.CMYK {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.CMYK:
			return &r
		case *_color.CMYK:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.CMYK]"))
}

func _mapToCMYK(o Map) *_color.CMYK {
	return &_color.CMYK{}
}

func _vectorToCMYK(o *Vector) *_color.CMYK {
	return &_color.CMYK{
		C: uint8(AssertInt(o.Nth(0), "").I),
		M: uint8(AssertInt(o.Nth(1), "").I),
		Y: uint8(AssertInt(o.Nth(2), "").I),
		K: uint8(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructCMYK(_v Object) *_color.CMYK {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.CMYK:
			return &_g
		case *_color.CMYK:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCMYK(_o.(Map))
	case *Vector:
		return _vectorToCMYK(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.CMYK] or: Map or Vector"))
}

GO TYPE image/color.Color from image/color/color.go:
func ExtractGoObjectColor(args []Object, index int) *_color.Color {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Color:
			return &r
		case *_color.Color:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Color]"))
}

// func _ConstructColor(_v Object) _color.Color {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _color.Color:
// 			return _g
// 		case *_color.Color:
// 			return *_g
// 		}
// 	default:
// 		return _color.Color(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Color))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Color] or: whatever"))
// }

GO TYPE image/color.Gray from image/color/color.go:
func ExtractGoObjectGray(args []Object, index int) *_color.Gray {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Gray:
			return &r
		case *_color.Gray:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Gray]"))
}

func _mapToGray(o Map) *_color.Gray {
	return &_color.Gray{}
}

func _vectorToGray(o *Vector) *_color.Gray {
	return &_color.Gray{
		Y: uint8(AssertInt(o.Nth(0), "").I),
	}
}

func _ConstructGray(_v Object) *_color.Gray {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.Gray:
			return &_g
		case *_color.Gray:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGray(_o.(Map))
	case *Vector:
		return _vectorToGray(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Gray] or: Map or Vector"))
}

GO TYPE image/color.Gray16 from image/color/color.go:
func ExtractGoObjectGray16(args []Object, index int) *_color.Gray16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Gray16:
			return &r
		case *_color.Gray16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Gray16]"))
}

func _mapToGray16(o Map) *_color.Gray16 {
	return &_color.Gray16{}
}

func _vectorToGray16(o *Vector) *_color.Gray16 {
	return &_color.Gray16{
		Y: uint16(AssertInt(o.Nth(0), "").I),
	}
}

func _ConstructGray16(_v Object) *_color.Gray16 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.Gray16:
			return &_g
		case *_color.Gray16:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGray16(_o.(Map))
	case *Vector:
		return _vectorToGray16(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Gray16] or: Map or Vector"))
}

GO TYPE image/color.Model from image/color/color.go:
func ExtractGoObjectModel(args []Object, index int) *_color.Model {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Model:
			return &r
		case *_color.Model:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Model]"))
}

// func _ConstructModel(_v Object) _color.Model {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _color.Model:
// 			return _g
// 		case *_color.Model:
// 			return *_g
// 		}
// 	default:
// 		return _color.Model(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Model))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Model] or: whatever"))
// }

GO TYPE image/color.NRGBA from image/color/color.go:
func ExtractGoObjectNRGBA(args []Object, index int) *_color.NRGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.NRGBA:
			return &r
		case *_color.NRGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.NRGBA]"))
}

func _mapToNRGBA(o Map) *_color.NRGBA {
	return &_color.NRGBA{}
}

func _vectorToNRGBA(o *Vector) *_color.NRGBA {
	return &_color.NRGBA{
		R: uint8(AssertInt(o.Nth(0), "").I),
		G: uint8(AssertInt(o.Nth(1), "").I),
		B: uint8(AssertInt(o.Nth(2), "").I),
		A: uint8(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructNRGBA(_v Object) *_color.NRGBA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.NRGBA:
			return &_g
		case *_color.NRGBA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNRGBA(_o.(Map))
	case *Vector:
		return _vectorToNRGBA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.NRGBA] or: Map or Vector"))
}

GO TYPE image/color.NRGBA64 from image/color/color.go:
func ExtractGoObjectNRGBA64(args []Object, index int) *_color.NRGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.NRGBA64:
			return &r
		case *_color.NRGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.NRGBA64]"))
}

func _mapToNRGBA64(o Map) *_color.NRGBA64 {
	return &_color.NRGBA64{}
}

func _vectorToNRGBA64(o *Vector) *_color.NRGBA64 {
	return &_color.NRGBA64{
		R: uint16(AssertInt(o.Nth(0), "").I),
		G: uint16(AssertInt(o.Nth(1), "").I),
		B: uint16(AssertInt(o.Nth(2), "").I),
		A: uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructNRGBA64(_v Object) *_color.NRGBA64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.NRGBA64:
			return &_g
		case *_color.NRGBA64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNRGBA64(_o.(Map))
	case *Vector:
		return _vectorToNRGBA64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.NRGBA64] or: Map or Vector"))
}

GO TYPE image/color.NYCbCrA from image/color/ycbcr.go:
func ExtractGoObjectNYCbCrA(args []Object, index int) *_color.NYCbCrA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.NYCbCrA:
			return &r
		case *_color.NYCbCrA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.NYCbCrA]"))
}

func _mapToNYCbCrA(o Map) *_color.NYCbCrA {
	return &_color.NYCbCrA{}
}

func _vectorToNYCbCrA(o *Vector) *_color.NYCbCrA {
	return &_color.NYCbCrA{
		A: uint8(AssertInt(o.Nth(0), "").I),
	}
}

func _ConstructNYCbCrA(_v Object) *_color.NYCbCrA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.NYCbCrA:
			return &_g
		case *_color.NYCbCrA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNYCbCrA(_o.(Map))
	case *Vector:
		return _vectorToNYCbCrA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.NYCbCrA] or: Map or Vector"))
}

GO TYPE image/color.Palette from image/color/color.go:
func ExtractGoObjectPalette(args []Object, index int) *_color.Palette {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.Palette:
			return &r
		case *_color.Palette:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.Palette]"))
}

// func _ConstructPalette(_v Object) _color.Palette {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _color.Palette:
// 			return _g
// 		case *_color.Palette:
// 			return *_g
// 		}
// 	default:
// 		return _color.Palette(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Palette))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[color.Palette] or: whatever"))
// }

GO TYPE image/color.RGBA from image/color/color.go:
func ExtractGoObjectRGBA(args []Object, index int) *_color.RGBA {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.RGBA:
			return &r
		case *_color.RGBA:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.RGBA]"))
}

func _mapToRGBA(o Map) *_color.RGBA {
	return &_color.RGBA{}
}

func _vectorToRGBA(o *Vector) *_color.RGBA {
	return &_color.RGBA{
		R: uint8(AssertInt(o.Nth(0), "").I),
		G: uint8(AssertInt(o.Nth(1), "").I),
		B: uint8(AssertInt(o.Nth(2), "").I),
		A: uint8(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructRGBA(_v Object) *_color.RGBA {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.RGBA:
			return &_g
		case *_color.RGBA:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRGBA(_o.(Map))
	case *Vector:
		return _vectorToRGBA(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.RGBA] or: Map or Vector"))
}

GO TYPE image/color.RGBA64 from image/color/color.go:
func ExtractGoObjectRGBA64(args []Object, index int) *_color.RGBA64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.RGBA64:
			return &r
		case *_color.RGBA64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.RGBA64]"))
}

func _mapToRGBA64(o Map) *_color.RGBA64 {
	return &_color.RGBA64{}
}

func _vectorToRGBA64(o *Vector) *_color.RGBA64 {
	return &_color.RGBA64{
		R: uint16(AssertInt(o.Nth(0), "").I),
		G: uint16(AssertInt(o.Nth(1), "").I),
		B: uint16(AssertInt(o.Nth(2), "").I),
		A: uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructRGBA64(_v Object) *_color.RGBA64 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.RGBA64:
			return &_g
		case *_color.RGBA64:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRGBA64(_o.(Map))
	case *Vector:
		return _vectorToRGBA64(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.RGBA64] or: Map or Vector"))
}

GO TYPE image/color.YCbCr from image/color/ycbcr.go:
func ExtractGoObjectYCbCr(args []Object, index int) *_color.YCbCr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _color.YCbCr:
			return &r
		case *_color.YCbCr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/color.YCbCr]"))
}

func _mapToYCbCr(o Map) *_color.YCbCr {
	return &_color.YCbCr{}
}

func _vectorToYCbCr(o *Vector) *_color.YCbCr {
	return &_color.YCbCr{
		Y: uint8(AssertInt(o.Nth(0), "").I),
		Cb: uint8(AssertInt(o.Nth(1), "").I),
		Cr: uint8(AssertInt(o.Nth(2), "").I),
	}
}

func _ConstructYCbCr(_v Object) *_color.YCbCr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _color.YCbCr:
			return &_g
		case *_color.YCbCr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToYCbCr(_o.(Map))
	case *Vector:
		return _vectorToYCbCr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[color.YCbCr] or: Map or Vector"))
}

GO FUNC image/color.CMYKToRGB from image/color/ycbcr.go:
func __cMYKToRGB(c uint8, m uint8, y uint8, k uint8) Object {
	_res1, _res2, _res3 := _color.CMYKToRGB(c, m, y, k)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeInt(int(_res2)))
	_res = _res.Conjoin(MakeInt(int(_res3)))
	return _res
}

GO FUNC image/color.ModelFunc from image/color/color.go:
// func __modelFunc(f func) Object {
// 	_res := _color.ModelFunc(f)
// 	return MakeGoObject(_res)
// }

GO FUNC image/color.RGBToCMYK from image/color/ycbcr.go:
func __rGBToCMYK(r uint8, g uint8, b uint8) Object {
	_res1, _res2, _res3, _res4 := _color.RGBToCMYK(r, g, b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeInt(int(_res2)))
	_res = _res.Conjoin(MakeInt(int(_res3)))
	_res = _res.Conjoin(MakeInt(int(_res4)))
	return _res
}

GO FUNC image/color.RGBToYCbCr from image/color/ycbcr.go:
func __rGBToYCbCr(r uint8, g uint8, b uint8) Object {
	_res1, _res2, _res3 := _color.RGBToYCbCr(r, g, b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeInt(int(_res2)))
	_res = _res.Conjoin(MakeInt(int(_res3)))
	return _res
}

GO FUNC image/color.YCbCrToRGB from image/color/ycbcr.go:
func __yCbCrToRGB(y uint8, cb uint8, cr uint8) Object {
	_res1, _res2, _res3 := _color.YCbCrToRGB(y, cb, cr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeInt(int(_res2)))
	_res = _res.Conjoin(MakeInt(int(_res3)))
	return _res
}

GO FUNC image/color.__alpha16_RGBA from image/color/color.go:
func __alpha16_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.Alpha16)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.Alpha16).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__alpha_RGBA from image/color/color.go:
func __alpha_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.Alpha)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.Alpha).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__cMYK_RGBA from image/color/ycbcr.go:
func __cMYK_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.CMYK)RGBA()", args, 0, 0)
	_res1, _res2, _res3, _res4 := o.O.(_color.CMYK).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(_res1)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res2)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res3)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res4)))
	return _res
}

GO FUNC image/color.__gray16_RGBA from image/color/color.go:
func __gray16_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.Gray16)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.Gray16).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__gray_RGBA from image/color/color.go:
func __gray_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.Gray)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.Gray).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__nRGBA64_RGBA from image/color/color.go:
func __nRGBA64_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.NRGBA64)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.NRGBA64).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__nRGBA_RGBA from image/color/color.go:
func __nRGBA_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.NRGBA)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.NRGBA).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__nYCbCrA_RGBA from image/color/ycbcr.go:
func __nYCbCrA_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.NYCbCrA)RGBA()", args, 0, 0)
	_res1, _res2, _res3, _res4 := o.O.(_color.NYCbCrA).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(_res1)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res2)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res3)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res4)))
	return _res
}

GO FUNC image/color.__palette_Convert from image/color/color.go:
func __palette_Convert(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image/color.Palette)Convert()", args, 1, 1)
	c := ExtractGo_go_std_image_color__Color("(_image/color.Palette)Convert()", "c", _argList, 0)
	_res := o.O.(_color.Palette).Convert(c)
	return MakeGoObject(_res)
}

GO FUNC image/color.__palette_Index from image/color/color.go:
func __palette_Index(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_image/color.Palette)Index()", args, 1, 1)
	c := ExtractGo_go_std_image_color__Color("(_image/color.Palette)Index()", "c", _argList, 0)
	_res := o.O.(_color.Palette).Index(c)
	return MakeInt(_res)
}

GO FUNC image/color.__rGBA64_RGBA from image/color/color.go:
func __rGBA64_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.RGBA64)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.RGBA64).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__rGBA_RGBA from image/color/color.go:
func __rGBA_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.RGBA)RGBA()", args, 0, 0)
	r, g, b, a := o.O.(_color.RGBA).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(r)))
	_res = _res.Conjoin(MakeBigIntU(uint64(g)))
	_res = _res.Conjoin(MakeBigIntU(uint64(b)))
	_res = _res.Conjoin(MakeBigIntU(uint64(a)))
	return _res
}

GO FUNC image/color.__yCbCr_RGBA from image/color/ycbcr.go:
func __yCbCr_RGBA(o GoObject, args Object) Object {
	CheckGoArity("(_image/color.YCbCr)RGBA()", args, 0, 0)
	_res1, _res2, _res3, _res4 := o.O.(_color.YCbCr).RGBA()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(_res1)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res2)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res3)))
	_res = _res.Conjoin(MakeBigIntU(uint64(_res4)))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package color

import (
	. "github.com/candid82/joker/core"
	_color "image/color"
	_reflect "reflect"
)
var members_Alpha = GoTypeInfo{Members: GoMembers{
	"RGBA": __alpha_RGBA,
}}

var members_Alpha16 = GoTypeInfo{Members: GoMembers{
	"RGBA": __alpha16_RGBA,
}}

var members_CMYK = GoTypeInfo{Members: GoMembers{
	"RGBA": __cMYK_RGBA,
}}

var members_Gray = GoTypeInfo{Members: GoMembers{
	"RGBA": __gray_RGBA,
}}

var members_Gray16 = GoTypeInfo{Members: GoMembers{
	"RGBA": __gray16_RGBA,
}}

var members_NRGBA = GoTypeInfo{Members: GoMembers{
	"RGBA": __nRGBA_RGBA,
}}

var members_NRGBA64 = GoTypeInfo{Members: GoMembers{
	"RGBA": __nRGBA64_RGBA,
}}

var members_NYCbCrA = GoTypeInfo{Members: GoMembers{
	"RGBA": __nYCbCrA_RGBA,
}}

var members_Palette = GoTypeInfo{Members: GoMembers{
	"Convert": __palette_Convert,
	"Index": __palette_Index,
}}

var members_RGBA = GoTypeInfo{Members: GoMembers{
	"RGBA": __rGBA_RGBA,
}}

var members_RGBA64 = GoTypeInfo{Members: GoMembers{
	"RGBA": __rGBA64_RGBA,
}}

var members_YCbCr = GoTypeInfo{Members: GoMembers{
	"RGBA": __yCbCr_RGBA,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_color.Alpha)(nil)).Elem()] = &members_Alpha
	GoTypes[_reflect.TypeOf((*_color.Alpha16)(nil)).Elem()] = &members_Alpha16
	GoTypes[_reflect.TypeOf((*_color.CMYK)(nil)).Elem()] = &members_CMYK
	GoTypes[_reflect.TypeOf((*_color.Gray)(nil)).Elem()] = &members_Gray
	GoTypes[_reflect.TypeOf((*_color.Gray16)(nil)).Elem()] = &members_Gray16
	GoTypes[_reflect.TypeOf((*_color.NRGBA)(nil)).Elem()] = &members_NRGBA
	GoTypes[_reflect.TypeOf((*_color.NRGBA64)(nil)).Elem()] = &members_NRGBA64
	GoTypes[_reflect.TypeOf((*_color.NYCbCrA)(nil)).Elem()] = &members_NYCbCrA
	GoTypes[_reflect.TypeOf((*_color.Palette)(nil)).Elem()] = &members_Palette
	GoTypes[_reflect.TypeOf((*_color.RGBA)(nil)).Elem()] = &members_RGBA
	GoTypes[_reflect.TypeOf((*_color.RGBA64)(nil)).Elem()] = &members_RGBA64
	GoTypes[_reflect.TypeOf((*_color.YCbCr)(nil)).Elem()] = &members_YCbCr
}

GO FUNC image/draw.Draw from image/draw/draw.go:
// func __draw(dst _draw.Image, r ABEND987(genutils.go: imports not yet supported: image.Rectangle), src ABEND987(genutils.go: imports not yet supported: image.Image), sp ABEND987(genutils.go: imports not yet supported: image.Point), op _draw.Op) Object {
// 	_draw.Draw(dst, r, src, sp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/draw.DrawMask from image/draw/draw.go:
// func __drawMask(dst _draw.Image, r ABEND987(genutils.go: imports not yet supported: image.Rectangle), src ABEND987(genutils.go: imports not yet supported: image.Image), sp ABEND987(genutils.go: imports not yet supported: image.Point), mask ABEND987(genutils.go: imports not yet supported: image.Image), mp ABEND987(genutils.go: imports not yet supported: image.Point), op _draw.Op) Object {
// 	_draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/draw.__op_Draw from image/draw/draw.go:
// func __op_Draw(o GoObject, args Object) Object {
// dst _draw.Image, r ABEND987(genutils.go: imports not yet supported: image.Rectangle), src ABEND987(genutils.go: imports not yet supported: image.Image), sp ABEND987(genutils.go: imports not yet supported: image.Point)}

GO FUNC image/gif.Decode from image/gif/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.Decode(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeAll from image/gif/reader.go:
// func __decodeAll(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.DecodeAll(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeConfig from image/gif/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _gif.DecodeConfig(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.Encode from image/gif/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image), o *_gif.Options)  {
// 	_res := _gif.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/gif.EncodeAll from image/gif/writer.go:
// func __encodeAll(w ABEND987(genutils.go: imports not yet supported: io.Writer), g *_gif.GIF)  {
// 	_res := _gif.EncodeAll(w, g)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE image/jpeg.FormatError from image/jpeg/reader.go:
func ExtractGoObjectFormatError(args []Object, index int) *_jpeg.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _jpeg.FormatError:
			return &r
		case *_jpeg.FormatError:
			return r
		}
	case String:
		v := _jpeg.FormatError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/jpeg.FormatError]"))
}

func _ConstructFormatError(_v Object) _jpeg.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _jpeg.FormatError:
			return _g
		case *_jpeg.FormatError:
			return *_g
		}
	case String:
		return _jpeg.FormatError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[jpeg.FormatError] or: String"))
}

GO TYPE image/jpeg.Options from image/jpeg/writer.go:
func ExtractGoObjectOptions(args []Object, index int) *_jpeg.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _jpeg.Options:
			return &r
		case *_jpeg.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/jpeg.Options]"))
}

func _mapToOptions(o Map) *_jpeg.Options {
	return &_jpeg.Options{}
}

func _vectorToOptions(o *Vector) *_jpeg.Options {
	return &_jpeg.Options{
		Quality: AssertInt(o.Nth(0), "").I,
	}
}

func _ConstructOptions(_v Object) *_jpeg.Options {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _jpeg.Options:
			return &_g
		case *_jpeg.Options:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOptions(_o.(Map))
	case *Vector:
		return _vectorToOptions(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[jpeg.Options] or: Map or Vector"))
}

GO TYPE image/jpeg.Reader from image/jpeg/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_jpeg.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _jpeg.Reader:
			return &r
		case *_jpeg.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/jpeg.Reader]"))
}

// func _ConstructReader(_v Object) _jpeg.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _jpeg.Reader:
// 			return _g
// 		case *_jpeg.Reader:
// 			return *_g
// 		}
// 	default:
// 		return _jpeg.Reader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Reader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[jpeg.Reader] or: whatever"))
// }

GO TYPE image/jpeg.UnsupportedError from image/jpeg/reader.go:
func ExtractGoObjectUnsupportedError(args []Object, index int) *_jpeg.UnsupportedError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _jpeg.UnsupportedError:
			return &r
		case *_jpeg.UnsupportedError:
			return r
		}
	case String:
		v := _jpeg.UnsupportedError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/jpeg.UnsupportedError]"))
}

func _ConstructUnsupportedError(_v Object) _jpeg.UnsupportedError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _jpeg.UnsupportedError:
			return _g
		case *_jpeg.UnsupportedError:
			return *_g
		}
	case String:
		return _jpeg.UnsupportedError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[jpeg.UnsupportedError] or: String"))
}

GO FUNC image/jpeg.Decode from image/jpeg/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _jpeg.Decode(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.DecodeConfig from image/jpeg/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _jpeg.DecodeConfig(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.Encode from image/jpeg/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image), o *_jpeg.Options)  {
// 	_res := _jpeg.Encode(w, m, o)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/jpeg.__formatError_Error from image/jpeg/reader.go:
func __formatError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_image/jpeg.FormatError)Error()", args, 0, 0)
	_res := o.O.(_jpeg.FormatError).Error()
	return MakeString(_res)
}

GO FUNC image/jpeg.__unsupportedError_Error from image/jpeg/reader.go:
func __unsupportedError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_image/jpeg.UnsupportedError)Error()", args, 0, 0)
	_res := o.O.(_jpeg.UnsupportedError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package jpeg

import (
	. "github.com/candid82/joker/core"
	_jpeg "image/jpeg"
	_reflect "reflect"
)
var members_FormatError = GoTypeInfo{Members: GoMembers{
	"Error": __formatError_Error,
}}

var members_UnsupportedError = GoTypeInfo{Members: GoMembers{
	"Error": __unsupportedError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_jpeg.FormatError)(nil)).Elem()] = &members_FormatError
	GoTypes[_reflect.TypeOf((*_jpeg.UnsupportedError)(nil)).Elem()] = &members_UnsupportedError
}

GO TYPE image/png.CompressionLevel from image/png/writer.go:
func ExtractGoObjectCompressionLevel(args []Object, index int) *_png.CompressionLevel {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.CompressionLevel:
			return &r
		case *_png.CompressionLevel:
			return r
		}
	case Int:
		v := _png.CompressionLevel(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.CompressionLevel]"))
}

func _ConstructCompressionLevel(_v Object) _png.CompressionLevel {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _png.CompressionLevel:
			return _g
		case *_png.CompressionLevel:
			return *_g
		}
	case Number:
		return _png.CompressionLevel(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[png.CompressionLevel] or: Number"))
}

GO TYPE image/png.Encoder from image/png/writer.go:
func ExtractGoObjectEncoder(args []Object, index int) *_png.Encoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.Encoder:
			return &r
		case *_png.Encoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.Encoder]"))
}

// func _mapToEncoder(o Map) *_png.Encoder {
// 	return &_png.Encoder{}
// }

// func _vectorToEncoder(o *Vector) *_png.Encoder {
// 	return &_png.Encoder{
// 		CompressionLevel: _png.CompressionLevel(AssertInt(o.Nth(0), "").I),
// 		BufferPool: ABEND048(codegen.go: no conversion from Clojure for image/png.EncoderBufferPool (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructEncoder(_v Object) *_png.Encoder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _png.Encoder:
// 			return &_g
// 		case *_png.Encoder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToEncoder(_o.(Map))
// 	case *Vector:
// 		return _vectorToEncoder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[png.Encoder] or: Map or Vector"))
// }

GO TYPE image/png.EncoderBuffer from image/png/writer.go:
func ExtractGoObjectEncoderBuffer(args []Object, index int) *_png.EncoderBuffer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.EncoderBuffer:
			return &r
		case *_png.EncoderBuffer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.EncoderBuffer]"))
}

// func _ConstructEncoderBuffer(_v Object) _png.EncoderBuffer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _png.EncoderBuffer:
// 			return _g
// 		case *_png.EncoderBuffer:
// 			return *_g
// 		}
// 	case  /* ABEND171(missing go object type or clojure-object extraction for image/png.encoder) */:
// 		return _png.EncoderBuffer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[png.EncoderBuffer] or: "))
// }

GO TYPE image/png.EncoderBufferPool from image/png/writer.go:
func ExtractGoObjectEncoderBufferPool(args []Object, index int) *_png.EncoderBufferPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.EncoderBufferPool:
			return &r
		case *_png.EncoderBufferPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.EncoderBufferPool]"))
}

// func _ConstructEncoderBufferPool(_v Object) _png.EncoderBufferPool {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _png.EncoderBufferPool:
// 			return _g
// 		case *_png.EncoderBufferPool:
// 			return *_g
// 		}
// 	default:
// 		return _png.EncoderBufferPool(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for EncoderBufferPool))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[png.EncoderBufferPool] or: whatever"))
// }

GO TYPE image/png.FormatError from image/png/reader.go:
func ExtractGoObjectFormatError(args []Object, index int) *_png.FormatError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.FormatError:
			return &r
		case *_png.FormatError:
			return r
		}
	case String:
		v := _png.FormatError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.FormatError]"))
}

func _ConstructFormatError(_v Object) _png.FormatError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _png.FormatError:
			return _g
		case *_png.FormatError:
			return *_g
		}
	case String:
		return _png.FormatError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[png.FormatError] or: String"))
}

GO TYPE image/png.UnsupportedError from image/png/reader.go:
func ExtractGoObjectUnsupportedError(args []Object, index int) *_png.UnsupportedError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _png.UnsupportedError:
			return &r
		case *_png.UnsupportedError:
			return r
		}
	case String:
		v := _png.UnsupportedError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[image/png.UnsupportedError]"))
}

func _ConstructUnsupportedError(_v Object) _png.UnsupportedError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _png.UnsupportedError:
			return _g
		case *_png.UnsupportedError:
			return *_g
		}
	case String:
		return _png.UnsupportedError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[png.UnsupportedError] or: String"))
}

GO FUNC image/png.Decode from image/png/reader.go:
// func __decode(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _png.Decode(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.DecodeConfig from image/png/reader.go:
// func __decodeConfig(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _png.DecodeConfig(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.Encode from image/png/writer.go:
// func __encode(w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image))  {
// 	_res := _png.Encode(w, m)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC image/png.__formatError_Error from image/png/reader.go:
func __formatError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_image/png.FormatError)Error()", args, 0, 0)
	_res := o.O.(_png.FormatError).Error()
	return MakeString(_res)
}

GO FUNC image/png.__ptrTo_Encoder_Encode from image/png/writer.go:
// func __ptrTo_Encoder_Encode(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer), m ABEND987(genutils.go: imports not yet supported: image.Image)}

GO FUNC image/png.__unsupportedError_Error from image/png/reader.go:
func __unsupportedError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_image/png.UnsupportedError)Error()", args, 0, 0)
	_res := o.O.(_png.UnsupportedError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package png

import (
	. "github.com/candid82/joker/core"
	_png "image/png"
	_reflect "reflect"
)
var members_FormatError = GoTypeInfo{Members: GoMembers{
	"Error": __formatError_Error,
}}

var members_UnsupportedError = GoTypeInfo{Members: GoMembers{
	"Error": __unsupportedError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_png.FormatError)(nil)).Elem()] = &members_FormatError
	GoTypes[_reflect.TypeOf((*_png.UnsupportedError)(nil)).Elem()] = &members_UnsupportedError
}

GO TYPE index/suffixarray.Index from index/suffixarray/suffixarray.go:
func ExtractGoObjectIndex(args []Object, index int) *_suffixarray.Index {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _suffixarray.Index:
			return &r
		case *_suffixarray.Index:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[index/suffixarray.Index]"))
}

func _mapToIndex(o Map) *_suffixarray.Index {
	return &_suffixarray.Index{}
}

func _vectorToIndex(o *Vector) *_suffixarray.Index {
	return &_suffixarray.Index{}
}

func _ConstructIndex(_v Object) *_suffixarray.Index {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _suffixarray.Index:
			return &_g
		case *_suffixarray.Index:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIndex(_o.(Map))
	case *Vector:
		return _vectorToIndex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[suffixarray.Index] or: Map or Vector"))
}

GO FUNC index/suffixarray.New from index/suffixarray/suffixarray.go:
// func __new(data []byte) Object {
// 	_res := _suffixarray.New(data)
// 	return MakeGoObject(_res)
// }

GO FUNC index/suffixarray.__ptrTo_Index_Bytes from index/suffixarray/suffixarray.go:
func __ptrTo_Index_Bytes(o GoObject, args Object) Object {
	CheckGoArity("(*_index/suffixarray.Index)Bytes()", args, 0, 0)
	_res := o.O.(*_suffixarray.Index).Bytes()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC index/suffixarray.__ptrTo_Index_FindAllIndex from index/suffixarray/suffixarray.go:
// func __ptrTo_Index_FindAllIndex(o GoObject, args Object) Object {
// r *ABEND987(genutils.go: imports not yet supported: regexp.Regexp), n int}

GO FUNC index/suffixarray.__ptrTo_Index_Lookup from index/suffixarray/suffixarray.go:
// func __ptrTo_Index_Lookup(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(s)), n)}

GO FUNC index/suffixarray.__ptrTo_Index_Read from index/suffixarray/suffixarray.go:
// func __ptrTo_Index_Read(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC index/suffixarray.__ptrTo_Index_Write from index/suffixarray/suffixarray.go:
// func __ptrTo_Index_Write(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package suffixarray

import (
	. "github.com/candid82/joker/core"
	_suffixarray "index/suffixarray"
	_reflect "reflect"
)
var members_PtrTo_Index = GoTypeInfo{Members: GoMembers{
	"Bytes": __ptrTo_Index_Bytes,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_suffixarray.Index)(nil))] = &members_PtrTo_Index
}

GO TYPE io.ByteReader from io/io.go:
func ExtractGoObjectByteReader(args []Object, index int) *_io.ByteReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteReader:
			return &r
		case *_io.ByteReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteReader]"))
}

// func _ConstructByteReader(_v Object) _io.ByteReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteReader:
// 			return _g
// 		case *_io.ByteReader:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteReader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ByteReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteReader] or: whatever"))
// }

GO TYPE io.ByteScanner from io/io.go:
func ExtractGoObjectByteScanner(args []Object, index int) *_io.ByteScanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteScanner:
			return &r
		case *_io.ByteScanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteScanner]"))
}

// func _ConstructByteScanner(_v Object) _io.ByteScanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteScanner:
// 			return _g
// 		case *_io.ByteScanner:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteScanner(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ByteScanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteScanner] or: whatever"))
// }

GO TYPE io.ByteWriter from io/io.go:
func ExtractGoObjectByteWriter(args []Object, index int) *_io.ByteWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ByteWriter:
			return &r
		case *_io.ByteWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ByteWriter]"))
}

// func _ConstructByteWriter(_v Object) _io.ByteWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ByteWriter:
// 			return _g
// 		case *_io.ByteWriter:
// 			return *_g
// 		}
// 	default:
// 		return _io.ByteWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ByteWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ByteWriter] or: whatever"))
// }

GO TYPE io.Closer from io/io.go:
func ExtractGoObjectCloser(args []Object, index int) *_io.Closer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Closer:
			return &r
		case *_io.Closer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Closer]"))
}

// func _ConstructCloser(_v Object) _io.Closer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Closer:
// 			return _g
// 		case *_io.Closer:
// 			return *_g
// 		}
// 	default:
// 		return _io.Closer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Closer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Closer] or: whatever"))
// }

GO TYPE io.LimitedReader from io/io.go:
func ExtractGoObjectLimitedReader(args []Object, index int) *_io.LimitedReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.LimitedReader:
			return &r
		case *_io.LimitedReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.LimitedReader]"))
}

// func _mapToLimitedReader(o Map) *_io.LimitedReader {
// 	return &_io.LimitedReader{}
// }

// func _vectorToLimitedReader(o *Vector) *_io.LimitedReader {
// 	return &_io.LimitedReader{
// 		R: ABEND048(codegen.go: no conversion from Clojure for io.Reader (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		N: AssertNumber(o.Nth(1), "").BigInt().Int64(),
// 	}
// }

// func _ConstructLimitedReader(_v Object) *_io.LimitedReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.LimitedReader:
// 			return &_g
// 		case *_io.LimitedReader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToLimitedReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToLimitedReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.LimitedReader] or: Map or Vector"))
// }

GO TYPE io.PipeReader from io/pipe.go:
func ExtractGoObjectPipeReader(args []Object, index int) *_io.PipeReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.PipeReader:
			return &r
		case *_io.PipeReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.PipeReader]"))
}

func _mapToPipeReader(o Map) *_io.PipeReader {
	return &_io.PipeReader{}
}

func _vectorToPipeReader(o *Vector) *_io.PipeReader {
	return &_io.PipeReader{}
}

func _ConstructPipeReader(_v Object) *_io.PipeReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.PipeReader:
			return &_g
		case *_io.PipeReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeReader(_o.(Map))
	case *Vector:
		return _vectorToPipeReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.PipeReader] or: Map or Vector"))
}

GO TYPE io.PipeWriter from io/pipe.go:
func ExtractGoObjectPipeWriter(args []Object, index int) *_io.PipeWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.PipeWriter:
			return &r
		case *_io.PipeWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.PipeWriter]"))
}

func _mapToPipeWriter(o Map) *_io.PipeWriter {
	return &_io.PipeWriter{}
}

func _vectorToPipeWriter(o *Vector) *_io.PipeWriter {
	return &_io.PipeWriter{}
}

func _ConstructPipeWriter(_v Object) *_io.PipeWriter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.PipeWriter:
			return &_g
		case *_io.PipeWriter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeWriter(_o.(Map))
	case *Vector:
		return _vectorToPipeWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.PipeWriter] or: Map or Vector"))
}

GO TYPE io.ReadCloser from io/io.go:
func ExtractGoObjectReadCloser(args []Object, index int) *_io.ReadCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadCloser:
			return &r
		case *_io.ReadCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadCloser]"))
}

// func _ConstructReadCloser(_v Object) _io.ReadCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadCloser:
// 			return _g
// 		case *_io.ReadCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadCloser(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReadCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadCloser] or: whatever"))
// }

GO TYPE io.ReadSeeker from io/io.go:
func ExtractGoObjectReadSeeker(args []Object, index int) *_io.ReadSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadSeeker:
			return &r
		case *_io.ReadSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadSeeker]"))
}

// func _ConstructReadSeeker(_v Object) _io.ReadSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadSeeker:
// 			return _g
// 		case *_io.ReadSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadSeeker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReadSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadSeeker] or: whatever"))
// }

GO TYPE io.ReadWriteCloser from io/io.go:
func ExtractGoObjectReadWriteCloser(args []Object, index int) *_io.ReadWriteCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriteCloser:
			return &r
		case *_io.ReadWriteCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriteCloser]"))
}

// func _ConstructReadWriteCloser(_v Object) _io.ReadWriteCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriteCloser:
// 			return _g
// 		case *_io.ReadWriteCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriteCloser(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReadWriteCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriteCloser] or: whatever"))
// }

GO TYPE io.ReadWriteSeeker from io/io.go:
func ExtractGoObjectReadWriteSeeker(args []Object, index int) *_io.ReadWriteSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriteSeeker:
			return &r
		case *_io.ReadWriteSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriteSeeker]"))
}

// func _ConstructReadWriteSeeker(_v Object) _io.ReadWriteSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriteSeeker:
// 			return _g
// 		case *_io.ReadWriteSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriteSeeker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReadWriteSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriteSeeker] or: whatever"))
// }

GO TYPE io.ReadWriter from io/io.go:
func ExtractGoObjectReadWriter(args []Object, index int) *_io.ReadWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReadWriter:
			return &r
		case *_io.ReadWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReadWriter]"))
}

// func _ConstructReadWriter(_v Object) _io.ReadWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReadWriter:
// 			return _g
// 		case *_io.ReadWriter:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReadWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReadWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReadWriter] or: whatever"))
// }

GO TYPE io.Reader from io/io.go:
func ExtractGoObjectReader(args []Object, index int) *_io.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Reader:
			return &r
		case *_io.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Reader]"))
}

// func _ConstructReader(_v Object) _io.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Reader:
// 			return _g
// 		case *_io.Reader:
// 			return *_g
// 		}
// 	default:
// 		return _io.Reader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Reader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Reader] or: whatever"))
// }

GO TYPE io.ReaderAt from io/io.go:
func ExtractGoObjectReaderAt(args []Object, index int) *_io.ReaderAt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReaderAt:
			return &r
		case *_io.ReaderAt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReaderAt]"))
}

// func _ConstructReaderAt(_v Object) _io.ReaderAt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReaderAt:
// 			return _g
// 		case *_io.ReaderAt:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReaderAt(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReaderAt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReaderAt] or: whatever"))
// }

GO TYPE io.ReaderFrom from io/io.go:
func ExtractGoObjectReaderFrom(args []Object, index int) *_io.ReaderFrom {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.ReaderFrom:
			return &r
		case *_io.ReaderFrom:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.ReaderFrom]"))
}

// func _ConstructReaderFrom(_v Object) _io.ReaderFrom {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.ReaderFrom:
// 			return _g
// 		case *_io.ReaderFrom:
// 			return *_g
// 		}
// 	default:
// 		return _io.ReaderFrom(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ReaderFrom))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.ReaderFrom] or: whatever"))
// }

GO TYPE io.RuneReader from io/io.go:
func ExtractGoObjectRuneReader(args []Object, index int) *_io.RuneReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.RuneReader:
			return &r
		case *_io.RuneReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.RuneReader]"))
}

// func _ConstructRuneReader(_v Object) _io.RuneReader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.RuneReader:
// 			return _g
// 		case *_io.RuneReader:
// 			return *_g
// 		}
// 	default:
// 		return _io.RuneReader(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RuneReader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.RuneReader] or: whatever"))
// }

GO TYPE io.RuneScanner from io/io.go:
func ExtractGoObjectRuneScanner(args []Object, index int) *_io.RuneScanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.RuneScanner:
			return &r
		case *_io.RuneScanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.RuneScanner]"))
}

// func _ConstructRuneScanner(_v Object) _io.RuneScanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.RuneScanner:
// 			return _g
// 		case *_io.RuneScanner:
// 			return *_g
// 		}
// 	default:
// 		return _io.RuneScanner(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RuneScanner))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.RuneScanner] or: whatever"))
// }

GO TYPE io.SectionReader from io/io.go:
func ExtractGoObjectSectionReader(args []Object, index int) *_io.SectionReader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.SectionReader:
			return &r
		case *_io.SectionReader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.SectionReader]"))
}

func _mapToSectionReader(o Map) *_io.SectionReader {
	return &_io.SectionReader{}
}

func _vectorToSectionReader(o *Vector) *_io.SectionReader {
	return &_io.SectionReader{}
}

func _ConstructSectionReader(_v Object) *_io.SectionReader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _io.SectionReader:
			return &_g
		case *_io.SectionReader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSectionReader(_o.(Map))
	case *Vector:
		return _vectorToSectionReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[io.SectionReader] or: Map or Vector"))
}

GO TYPE io.Seeker from io/io.go:
func ExtractGoObjectSeeker(args []Object, index int) *_io.Seeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Seeker:
			return &r
		case *_io.Seeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Seeker]"))
}

// func _ConstructSeeker(_v Object) _io.Seeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Seeker:
// 			return _g
// 		case *_io.Seeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.Seeker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Seeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Seeker] or: whatever"))
// }

GO TYPE io.StringWriter from io/io.go:
func ExtractGoObjectStringWriter(args []Object, index int) *_io.StringWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.StringWriter:
			return &r
		case *_io.StringWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.StringWriter]"))
}

// func _ConstructStringWriter(_v Object) _io.StringWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.StringWriter:
// 			return _g
// 		case *_io.StringWriter:
// 			return *_g
// 		}
// 	default:
// 		return _io.StringWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for StringWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.StringWriter] or: whatever"))
// }

GO TYPE io.WriteCloser from io/io.go:
func ExtractGoObjectWriteCloser(args []Object, index int) *_io.WriteCloser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriteCloser:
			return &r
		case *_io.WriteCloser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriteCloser]"))
}

// func _ConstructWriteCloser(_v Object) _io.WriteCloser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriteCloser:
// 			return _g
// 		case *_io.WriteCloser:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriteCloser(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for WriteCloser))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriteCloser] or: whatever"))
// }

GO TYPE io.WriteSeeker from io/io.go:
func ExtractGoObjectWriteSeeker(args []Object, index int) *_io.WriteSeeker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriteSeeker:
			return &r
		case *_io.WriteSeeker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriteSeeker]"))
}

// func _ConstructWriteSeeker(_v Object) _io.WriteSeeker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriteSeeker:
// 			return _g
// 		case *_io.WriteSeeker:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriteSeeker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for WriteSeeker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriteSeeker] or: whatever"))
// }

GO TYPE io.Writer from io/io.go:
func ExtractGoObjectWriter(args []Object, index int) *_io.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.Writer:
			return &r
		case *_io.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.Writer]"))
}

// func _ConstructWriter(_v Object) _io.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.Writer:
// 			return _g
// 		case *_io.Writer:
// 			return *_g
// 		}
// 	default:
// 		return _io.Writer(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Writer))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.Writer] or: whatever"))
// }

GO TYPE io.WriterAt from io/io.go:
func ExtractGoObjectWriterAt(args []Object, index int) *_io.WriterAt {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriterAt:
			return &r
		case *_io.WriterAt:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriterAt]"))
}

// func _ConstructWriterAt(_v Object) _io.WriterAt {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriterAt:
// 			return _g
// 		case *_io.WriterAt:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriterAt(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for WriterAt))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriterAt] or: whatever"))
// }

GO TYPE io.WriterTo from io/io.go:
func ExtractGoObjectWriterTo(args []Object, index int) *_io.WriterTo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _io.WriterTo:
			return &r
		case *_io.WriterTo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[io.WriterTo]"))
}

// func _ConstructWriterTo(_v Object) _io.WriterTo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _io.WriterTo:
// 			return _g
// 		case *_io.WriterTo:
// 			return *_g
// 		}
// 	default:
// 		return _io.WriterTo(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for WriterTo))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[io.WriterTo] or: whatever"))
// }

GO FUNC io.Copy from io/io.go:
func __copy(dst _io.Writer, src _io.Reader) Object {
	written, err := _io.Copy(dst, src)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(written))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.CopyBuffer from io/io.go:
// func __copyBuffer(dst _io.Writer, src _io.Reader, buf []byte) Object {
// 	written, err := _io.CopyBuffer(dst, src, buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBigInt(written))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.CopyN from io/io.go:
func __copyN(dst _io.Writer, src _io.Reader, n int64) Object {
	written, err := _io.CopyN(dst, src, n)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(written))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.LimitReader from io/io.go:
func __limitReader(r _io.Reader, n int64) Object {
	_res := _io.LimitReader(r, n)
	return MakeGoObject(_res)
}

GO FUNC io.MultiReader from io/multi.go:
// func __multiReader(readers ..._io.Reader) Object {
// 	_res := _io.MultiReader(readers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.MultiWriter from io/multi.go:
// func __multiWriter(writers ..._io.Writer) Object {
// 	_res := _io.MultiWriter(writers)
// 	return MakeGoObject(_res)
// }

GO FUNC io.NewSectionReader from io/io.go:
func __newSectionReader(r _io.ReaderAt, off int64, n int64) Object {
	_res := _io.NewSectionReader(r, off, n)
	return MakeGoObject(_res)
}

GO FUNC io.Pipe from io/pipe.go:
func __pipe() Object {
	_res1, _res2 := _io.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC io.ReadAtLeast from io/io.go:
// func __readAtLeast(r _io.Reader, buf []byte, min int) Object {
// 	n, err := _io.ReadAtLeast(r, buf, min)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.ReadFull from io/io.go:
// func __readFull(r _io.Reader, buf []byte) Object {
// 	n, err := _io.ReadFull(r, buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.TeeReader from io/io.go:
func __teeReader(r _io.Reader, w _io.Writer) Object {
	_res := _io.TeeReader(r, w)
	return MakeGoObject(_res)
}

GO FUNC io.WriteString from io/io.go:
func __writeString(w _io.Writer, s string) Object {
	n, err := _io.WriteString(w, s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io.__ptrTo_LimitedReader_Read from io/io.go:
// func __ptrTo_LimitedReader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC io.__ptrTo_PipeReader_Close from io/pipe.go:
func __ptrTo_PipeReader_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_io.PipeReader)Close()", args, 0, 0)
	_res := o.O.(*_io.PipeReader).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC io.__ptrTo_PipeReader_CloseWithError from io/pipe.go:
func __ptrTo_PipeReader_CloseWithError(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_io.PipeReader)CloseWithError()", args, 1, 1)
	err := ExtractGoError("(*_io.PipeReader)CloseWithError()", "err", _argList, 0)
	_res := o.O.(*_io.PipeReader).CloseWithError(err)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC io.__ptrTo_PipeReader_Read from io/pipe.go:
// func __ptrTo_PipeReader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC io.__ptrTo_PipeWriter_Close from io/pipe.go:
func __ptrTo_PipeWriter_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_io.PipeWriter)Close()", args, 0, 0)
	_res := o.O.(*_io.PipeWriter).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC io.__ptrTo_PipeWriter_CloseWithError from io/pipe.go:
func __ptrTo_PipeWriter_CloseWithError(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_io.PipeWriter)CloseWithError()", args, 1, 1)
	err := ExtractGoError("(*_io.PipeWriter)CloseWithError()", "err", _argList, 0)
	_res := o.O.(*_io.PipeWriter).CloseWithError(err)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC io.__ptrTo_PipeWriter_Write from io/pipe.go:
// func __ptrTo_PipeWriter_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC io.__ptrTo_SectionReader_Read from io/io.go:
// func __ptrTo_SectionReader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC io.__ptrTo_SectionReader_ReadAt from io/io.go:
// func __ptrTo_SectionReader_ReadAt(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)), off)}

GO FUNC io.__ptrTo_SectionReader_Seek from io/io.go:
func __ptrTo_SectionReader_Seek(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_io.SectionReader)Seek()", args, 2, 2)
	offset := ExtractGoInt64("(*_io.SectionReader)Seek()", "offset", _argList, 0)
	whence := ExtractGoInt("(*_io.SectionReader)Seek()", "whence", _argList, 1)
	_res1, _res2 := o.O.(*_io.SectionReader).Seek(offset, whence)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io.__ptrTo_SectionReader_Size from io/io.go:
func __ptrTo_SectionReader_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_io.SectionReader)Size()", args, 0, 0)
	_res := o.O.(*_io.SectionReader).Size()
	return MakeBigInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package io

import (
	. "github.com/candid82/joker/core"
	_io "io"
	_reflect "reflect"
)
var members_PtrTo_PipeReader = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_PipeReader_Close,
	"CloseWithError": __ptrTo_PipeReader_CloseWithError,
}}

var members_PtrTo_PipeWriter = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_PipeWriter_Close,
	"CloseWithError": __ptrTo_PipeWriter_CloseWithError,
}}

var members_PtrTo_SectionReader = GoTypeInfo{Members: GoMembers{
	"Seek": __ptrTo_SectionReader_Seek,
	"Size": __ptrTo_SectionReader_Size,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_io.PipeReader)(nil))] = &members_PtrTo_PipeReader
	GoTypes[_reflect.TypeOf((*_io.PipeWriter)(nil))] = &members_PtrTo_PipeWriter
	GoTypes[_reflect.TypeOf((*_io.SectionReader)(nil))] = &members_PtrTo_SectionReader
}

GO FUNC io/ioutil.NopCloser from io/ioutil/ioutil.go:
// func __nopCloser(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _ioutil.NopCloser(r)
// 	return MakeGoObject(_res)
// }

GO FUNC io/ioutil.ReadAll from io/ioutil/ioutil.go:
// func __readAll(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _ioutil.ReadAll(r)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC io/ioutil.ReadDir from io/ioutil/ioutil.go:
func __readDir(dirname string) Object {
	_res1, _res2 := _ioutil.ReadDir(dirname)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.ReadFile from io/ioutil/ioutil.go:
func __readFile(filename string) Object {
	_res1, _res2 := _ioutil.ReadFile(filename)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.TempDir from io/ioutil/tempfile.go:
func __tempDir(dir string, prefix string) Object {
	name, err := _ioutil.TempDir(dir, prefix)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.TempFile from io/ioutil/tempfile.go:
func __tempFile(dir string, pattern string) Object {
	f, err := _ioutil.TempFile(dir, pattern)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.WriteFile from io/ioutil/ioutil.go:
// func __writeFile(filename string, data []byte, perm ABEND987(genutils.go: imports not yet supported: os.FileMode))  {
// 	_res := _ioutil.WriteFile(filename, data, perm)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package ioutil

import (
	. "github.com/candid82/joker/core"
	_ioutil "io/ioutil"
)

func init() {
}

GO TYPE log.Logger from log/log.go:
func ExtractGoObjectLogger(args []Object, index int) *_log.Logger {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _log.Logger:
			return &r
		case *_log.Logger:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log.Logger]"))
}

func _mapToLogger(o Map) *_log.Logger {
	return &_log.Logger{}
}

func _vectorToLogger(o *Vector) *_log.Logger {
	return &_log.Logger{}
}

func _ConstructLogger(_v Object) *_log.Logger {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _log.Logger:
			return &_g
		case *_log.Logger:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLogger(_o.(Map))
	case *Vector:
		return _vectorToLogger(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[log.Logger] or: Map or Vector"))
}

GO FUNC log.Fatal from log/log.go:
// func __fatal(v ...interface {}) Object {
// 	_log.Fatal(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalf from log/log.go:
// func __fatalf(format string, v ...interface {}) Object {
// 	_log.Fatalf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalln from log/log.go:
// func __fatalln(v ...interface {}) Object {
// 	_log.Fatalln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.New from log/log.go:
// func __new(out ABEND987(genutils.go: imports not yet supported: io.Writer), prefix string, flag int) Object {
// 	_res := _log.New(out, prefix, flag)
// 	return MakeGoObject(_res)
// }

GO FUNC log.Panic from log/log.go:
// func __panic(v ...interface {}) Object {
// 	_log.Panic(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicf from log/log.go:
// func __panicf(format string, v ...interface {}) Object {
// 	_log.Panicf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicln from log/log.go:
// func __panicln(v ...interface {}) Object {
// 	_log.Panicln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Print from log/log.go:
// func __print(v ...interface {}) Object {
// 	_log.Print(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Printf from log/log.go:
// func __printf(format string, v ...interface {}) Object {
// 	_log.Printf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Println from log/log.go:
// func __println(v ...interface {}) Object {
// 	_log.Println(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetFlags from log/log.go:
// func __setFlags(flag int) Object {
// 	_log.SetFlags(flag)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetOutput from log/log.go:
// func __setOutput(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_log.SetOutput(w)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetPrefix from log/log.go:
// func __setPrefix(prefix string) Object {
// 	_log.SetPrefix(prefix)
// 	...ABEND675: TODO...
// }

GO FUNC log.__ptrTo_Logger_Fatal from log/log.go:
// func __ptrTo_Logger_Fatal(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Fatalf from log/log.go:
// func __ptrTo_Logger_Fatalf(o GoObject, args Object) Object {
// (format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Fatalln from log/log.go:
// func __ptrTo_Logger_Fatalln(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Flags from log/log.go:
func __ptrTo_Logger_Flags(o GoObject, args Object) Object {
	CheckGoArity("(*_log.Logger)Flags()", args, 0, 0)
	_res := o.O.(*_log.Logger).Flags()
	return MakeInt(_res)
}

GO FUNC log.__ptrTo_Logger_Output from log/log.go:
func __ptrTo_Logger_Output(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log.Logger)Output()", args, 2, 2)
	calldepth := ExtractGoInt("(*_log.Logger)Output()", "calldepth", _argList, 0)
	s := ExtractGoString("(*_log.Logger)Output()", "s", _argList, 1)
	_res := o.O.(*_log.Logger).Output(calldepth, s)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log.__ptrTo_Logger_Panic from log/log.go:
// func __ptrTo_Logger_Panic(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Panicf from log/log.go:
// func __ptrTo_Logger_Panicf(o GoObject, args Object) Object {
// (format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Panicln from log/log.go:
// func __ptrTo_Logger_Panicln(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Prefix from log/log.go:
func __ptrTo_Logger_Prefix(o GoObject, args Object) Object {
	CheckGoArity("(*_log.Logger)Prefix()", args, 0, 0)
	_res := o.O.(*_log.Logger).Prefix()
	return MakeString(_res)
}

GO FUNC log.__ptrTo_Logger_Print from log/log.go:
// func __ptrTo_Logger_Print(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Printf from log/log.go:
// func __ptrTo_Logger_Printf(o GoObject, args Object) Object {
// (format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_Println from log/log.go:
// func __ptrTo_Logger_Println(o GoObject, args Object) Object {
// (ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC log.__ptrTo_Logger_SetFlags from log/log.go:
// func __ptrTo_Logger_SetFlags(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC log.__ptrTo_Logger_SetOutput from log/log.go:
// func __ptrTo_Logger_SetOutput(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC log.__ptrTo_Logger_SetPrefix from log/log.go:
// func __ptrTo_Logger_SetPrefix(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC log.__ptrTo_Logger_Writer from log/log.go:
func __ptrTo_Logger_Writer(o GoObject, args Object) Object {
	CheckGoArity("(*_log.Logger)Writer()", args, 0, 0)
	_res := o.O.(*_log.Logger).Writer()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package log

import (
	. "github.com/candid82/joker/core"
	_log "log"
	_reflect "reflect"
)
var members_PtrTo_Logger = GoTypeInfo{Members: GoMembers{
	"Flags": __ptrTo_Logger_Flags,
	"Output": __ptrTo_Logger_Output,
	"Prefix": __ptrTo_Logger_Prefix,
	"Writer": __ptrTo_Logger_Writer,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_log.Logger)(nil))] = &members_PtrTo_Logger
}

GO TYPE log/syslog.Priority from log/syslog/syslog.go:
func ExtractGoObjectPriority(args []Object, index int) *_syslog.Priority {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syslog.Priority:
			return &r
		case *_syslog.Priority:
			return r
		}
	case Int:
		v := _syslog.Priority(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log/syslog.Priority]"))
}

func _ConstructPriority(_v Object) _syslog.Priority {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syslog.Priority:
			return _g
		case *_syslog.Priority:
			return *_g
		}
	case Number:
		return _syslog.Priority(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syslog.Priority] or: Number"))
}

GO TYPE log/syslog.Writer from log/syslog/syslog.go:
func ExtractGoObjectWriter(args []Object, index int) *_syslog.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syslog.Writer:
			return &r
		case *_syslog.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[log/syslog.Writer]"))
}

func _mapToWriter(o Map) *_syslog.Writer {
	return &_syslog.Writer{}
}

func _vectorToWriter(o *Vector) *_syslog.Writer {
	return &_syslog.Writer{}
}

func _ConstructWriter(_v Object) *_syslog.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syslog.Writer:
			return &_g
		case *_syslog.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syslog.Writer] or: Map or Vector"))
}

GO FUNC log/syslog.Dial from log/syslog/syslog.go:
func __dial(network string, raddr string, priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.Dial(network, raddr, priority, tag)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.New from log/syslog/syslog.go:
func __new(priority _syslog.Priority, tag string) Object {
	_res1, _res2 := _syslog.New(priority, tag)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.NewLogger from log/syslog/syslog.go:
func __newLogger(p _syslog.Priority, logFlag int) Object {
	_res1, _res2 := _syslog.NewLogger(p, logFlag)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC log/syslog.__ptrTo_Writer_Alert from log/syslog/syslog.go:
func __ptrTo_Writer_Alert(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Alert()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Alert()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Alert(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Close from log/syslog/syslog.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_log/syslog.Writer)Close()", args, 0, 0)
	_res := o.O.(*_syslog.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Crit from log/syslog/syslog.go:
func __ptrTo_Writer_Crit(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Crit()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Crit()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Crit(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Debug from log/syslog/syslog.go:
func __ptrTo_Writer_Debug(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Debug()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Debug()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Debug(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Emerg from log/syslog/syslog.go:
func __ptrTo_Writer_Emerg(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Emerg()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Emerg()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Emerg(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Err from log/syslog/syslog.go:
func __ptrTo_Writer_Err(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Err()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Err()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Err(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Info from log/syslog/syslog.go:
func __ptrTo_Writer_Info(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Info()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Info()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Info(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Notice from log/syslog/syslog.go:
func __ptrTo_Writer_Notice(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Notice()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Notice()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Notice(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Warning from log/syslog/syslog.go:
func __ptrTo_Writer_Warning(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_log/syslog.Writer)Warning()", args, 1, 1)
	m := ExtractGoString("(*_log/syslog.Writer)Warning()", "m", _argList, 0)
	_res := o.O.(*_syslog.Writer).Warning(m)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC log/syslog.__ptrTo_Writer_Write from log/syslog/syslog.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syslog

import (
	. "github.com/candid82/joker/core"
	_syslog "log/syslog"
	_reflect "reflect"
)
var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Alert": __ptrTo_Writer_Alert,
	"Close": __ptrTo_Writer_Close,
	"Crit": __ptrTo_Writer_Crit,
	"Debug": __ptrTo_Writer_Debug,
	"Emerg": __ptrTo_Writer_Emerg,
	"Err": __ptrTo_Writer_Err,
	"Info": __ptrTo_Writer_Info,
	"Notice": __ptrTo_Writer_Notice,
	"Warning": __ptrTo_Writer_Warning,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_syslog.Writer)(nil))] = &members_PtrTo_Writer
}

GO FUNC math.Abs from math/abs.go:
// func __abs(x float64) Object {
// 	_res := _math.Abs(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Acos from math/asin.go:
// func __acos(x float64) Object {
// 	_res := _math.Acos(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Acosh from math/acosh.go:
// func __acosh(x float64) Object {
// 	_res := _math.Acosh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Asin from math/asin.go:
// func __asin(x float64) Object {
// 	_res := _math.Asin(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Asinh from math/asinh.go:
// func __asinh(x float64) Object {
// 	_res := _math.Asinh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Atan from math/atan.go:
// func __atan(x float64) Object {
// 	_res := _math.Atan(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Atan2 from math/atan2.go:
// func __atan2(y float64, x float64) Object {
// 	_res := _math.Atan2(y, x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Atanh from math/atanh.go:
// func __atanh(x float64) Object {
// 	_res := _math.Atanh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Cbrt from math/cbrt.go:
// func __cbrt(x float64) Object {
// 	_res := _math.Cbrt(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Ceil from math/floor.go:
// func __ceil(x float64) Object {
// 	_res := _math.Ceil(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Copysign from math/copysign.go:
// func __copysign(x float64, y float64) Object {
// 	_res := _math.Copysign(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Cos from math/sin.go:
// func __cos(x float64) Object {
// 	_res := _math.Cos(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Cosh from math/sinh.go:
// func __cosh(x float64) Object {
// 	_res := _math.Cosh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Dim from math/dim.go:
// func __dim(x float64, y float64) Object {
// 	_res := _math.Dim(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Erf from math/erf.go:
// func __erf(x float64) Object {
// 	_res := _math.Erf(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Erfc from math/erf.go:
// func __erfc(x float64) Object {
// 	_res := _math.Erfc(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Erfcinv from math/erfinv.go:
// func __erfcinv(x float64) Object {
// 	_res := _math.Erfcinv(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Erfinv from math/erfinv.go:
// func __erfinv(x float64) Object {
// 	_res := _math.Erfinv(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Exp from math/exp.go:
// func __exp(x float64) Object {
// 	_res := _math.Exp(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Exp2 from math/exp.go:
// func __exp2(x float64) Object {
// 	_res := _math.Exp2(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Expm1 from math/expm1.go:
// func __expm1(x float64) Object {
// 	_res := _math.Expm1(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Float32bits from math/unsafe.go:
func __float32bits(f float32) Object {
	_res := _math.Float32bits(f)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math.Float32frombits from math/unsafe.go:
// func __float32frombits(b uint32) Object {
// 	_res := _math.Float32frombits(b)
// 	return ABEND043(post.go: unsupported built-in type float32)
// }

GO FUNC math.Float64bits from math/unsafe.go:
func __float64bits(f float64) Object {
	_res := _math.Float64bits(f)
	return MakeBigIntU(_res)
}

GO FUNC math.Float64frombits from math/unsafe.go:
// func __float64frombits(b uint64) Object {
// 	_res := _math.Float64frombits(b)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Floor from math/floor.go:
// func __floor(x float64) Object {
// 	_res := _math.Floor(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Frexp from math/frexp.go:
// func __frexp(f float64) Object {
// 	frac, exp := _math.Frexp(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(MakeInt(exp))
// 	return _res
// }

GO FUNC math.Gamma from math/gamma.go:
// func __gamma(x float64) Object {
// 	_res := _math.Gamma(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Hypot from math/hypot.go:
// func __hypot(p float64, q float64) Object {
// 	_res := _math.Hypot(p, q)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Inf from math/bits.go:
// func __inf(sign int) Object {
// 	_res := _math.Inf(sign)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.J0 from math/j0.go:
// func __j0(x float64) Object {
// 	_res := _math.J0(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.J1 from math/j1.go:
// func __j1(x float64) Object {
// 	_res := _math.J1(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Jn from math/jn.go:
// func __jn(n int, x float64) Object {
// 	_res := _math.Jn(n, x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Ldexp from math/ldexp.go:
// func __ldexp(frac float64, exp int) Object {
// 	_res := _math.Ldexp(frac, exp)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Lgamma from math/lgamma.go:
// func __lgamma(x float64) Object {
// 	lgamma, sign := _math.Lgamma(x)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(MakeInt(sign))
// 	return _res
// }

GO FUNC math.Log from math/log.go:
// func __log(x float64) Object {
// 	_res := _math.Log(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Log10 from math/log10.go:
// func __log10(x float64) Object {
// 	_res := _math.Log10(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Log1p from math/log1p.go:
// func __log1p(x float64) Object {
// 	_res := _math.Log1p(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Log2 from math/log10.go:
// func __log2(x float64) Object {
// 	_res := _math.Log2(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Logb from math/logb.go:
// func __logb(x float64) Object {
// 	_res := _math.Logb(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Max from math/dim.go:
// func __max(x float64, y float64) Object {
// 	_res := _math.Max(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Min from math/dim.go:
// func __min(x float64, y float64) Object {
// 	_res := _math.Min(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Mod from math/mod.go:
// func __mod(x float64, y float64) Object {
// 	_res := _math.Mod(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Modf from math/modf.go:
// func __modf(f float64) Object {
// 	int, frac := _math.Modf(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	return _res
// }

GO FUNC math.NaN from math/bits.go:
// func __naN() Object {
// 	_res := _math.NaN()
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Nextafter from math/nextafter.go:
// func __nextafter(x float64, y float64) Object {
// 	_res := _math.Nextafter(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Nextafter32 from math/nextafter.go:
// func __nextafter32(x float32, y float32) Object {
// 	_res := _math.Nextafter32(x, y)
// 	return ABEND043(post.go: unsupported built-in type float32)
// }

GO FUNC math.Pow from math/pow.go:
// func __pow(x float64, y float64) Object {
// 	_res := _math.Pow(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Pow10 from math/pow10.go:
// func __pow10(n int) Object {
// 	_res := _math.Pow10(n)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Remainder from math/remainder.go:
// func __remainder(x float64, y float64) Object {
// 	_res := _math.Remainder(x, y)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Round from math/floor.go:
// func __round(x float64) Object {
// 	_res := _math.Round(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.RoundToEven from math/floor.go:
// func __roundToEven(x float64) Object {
// 	_res := _math.RoundToEven(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Sin from math/sin.go:
// func __sin(x float64) Object {
// 	_res := _math.Sin(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Sincos from math/sincos.go:
// func __sincos(x float64) Object {
// 	sin, cos := _math.Sincos(x)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	return _res
// }

GO FUNC math.Sinh from math/sinh.go:
// func __sinh(x float64) Object {
// 	_res := _math.Sinh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Sqrt from math/sqrt.go:
// func __sqrt(x float64) Object {
// 	_res := _math.Sqrt(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Tan from math/tan.go:
// func __tan(x float64) Object {
// 	_res := _math.Tan(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Tanh from math/tanh.go:
// func __tanh(x float64) Object {
// 	_res := _math.Tanh(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Trunc from math/floor.go:
// func __trunc(x float64) Object {
// 	_res := _math.Trunc(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Y0 from math/j0.go:
// func __y0(x float64) Object {
// 	_res := _math.Y0(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Y1 from math/j1.go:
// func __y1(x float64) Object {
// 	_res := _math.Y1(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math.Yn from math/jn.go:
// func __yn(n int, x float64) Object {
// 	_res := _math.Yn(n, x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package math

import (
	. "github.com/candid82/joker/core"
	_math "math"
)

func init() {
}

GO TYPE math/big.Accuracy from math/big/float.go:
func ExtractGoObjectAccuracy(args []Object, index int) *_big.Accuracy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Accuracy:
			return &r
		case *_big.Accuracy:
			return r
		}
	case Int:
		v := _big.Accuracy(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Accuracy]"))
}

func _ConstructAccuracy(_v Object) _big.Accuracy {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Accuracy:
			return _g
		case *_big.Accuracy:
			return *_g
		}
	case Number:
		return _big.Accuracy(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Accuracy] or: Number"))
}

GO TYPE math/big.ErrNaN from math/big/float.go:
func ExtractGoObjectErrNaN(args []Object, index int) *_big.ErrNaN {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.ErrNaN:
			return &r
		case *_big.ErrNaN:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.ErrNaN]"))
}

func _mapToErrNaN(o Map) *_big.ErrNaN {
	return &_big.ErrNaN{}
}

func _vectorToErrNaN(o *Vector) *_big.ErrNaN {
	return &_big.ErrNaN{}
}

func _ConstructErrNaN(_v Object) *_big.ErrNaN {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.ErrNaN:
			return &_g
		case *_big.ErrNaN:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToErrNaN(_o.(Map))
	case *Vector:
		return _vectorToErrNaN(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.ErrNaN] or: Map or Vector"))
}

GO TYPE math/big.Float from math/big/float.go:
func ExtractGoObjectFloat(args []Object, index int) *_big.Float {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Float:
			return &r
		case *_big.Float:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Float]"))
}

func _mapToFloat(o Map) *_big.Float {
	return &_big.Float{}
}

func _vectorToFloat(o *Vector) *_big.Float {
	return &_big.Float{}
}

func _ConstructFloat(_v Object) *_big.Float {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Float:
			return &_g
		case *_big.Float:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFloat(_o.(Map))
	case *Vector:
		return _vectorToFloat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Float] or: Map or Vector"))
}

GO TYPE math/big.Int from math/big/int.go:
func ExtractGoObjectInt(args []Object, index int) *_big.Int {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Int:
			return &r
		case *_big.Int:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Int]"))
}

func _mapToInt(o Map) *_big.Int {
	return &_big.Int{}
}

func _vectorToInt(o *Vector) *_big.Int {
	return &_big.Int{}
}

func _ConstructInt(_v Object) *_big.Int {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Int:
			return &_g
		case *_big.Int:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToInt(_o.(Map))
	case *Vector:
		return _vectorToInt(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Int] or: Map or Vector"))
}

GO TYPE math/big.Rat from math/big/rat.go:
func ExtractGoObjectRat(args []Object, index int) *_big.Rat {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Rat:
			return &r
		case *_big.Rat:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Rat]"))
}

func _mapToRat(o Map) *_big.Rat {
	return &_big.Rat{}
}

func _vectorToRat(o *Vector) *_big.Rat {
	return &_big.Rat{}
}

func _ConstructRat(_v Object) *_big.Rat {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Rat:
			return &_g
		case *_big.Rat:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRat(_o.(Map))
	case *Vector:
		return _vectorToRat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Rat] or: Map or Vector"))
}

GO TYPE math/big.RoundingMode from math/big/float.go:
func ExtractGoObjectRoundingMode(args []Object, index int) *_big.RoundingMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.RoundingMode:
			return &r
		case *_big.RoundingMode:
			return r
		}
	case Int:
		v := _big.RoundingMode(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.RoundingMode]"))
}

func _ConstructRoundingMode(_v Object) _big.RoundingMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.RoundingMode:
			return _g
		case *_big.RoundingMode:
			return *_g
		}
	case Number:
		return _big.RoundingMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.RoundingMode] or: Number"))
}

GO TYPE math/big.Word from math/big/arith.go:
func ExtractGoObjectWord(args []Object, index int) *_big.Word {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _big.Word:
			return &r
		case *_big.Word:
			return r
		}
	case Number:
		v := _big.Word(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/big.Word]"))
}

func _ConstructWord(_v Object) _big.Word {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _big.Word:
			return _g
		case *_big.Word:
			return *_g
		}
	case Number:
		return _big.Word(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[big.Word] or: Number"))
}

GO FUNC math/big.NewFloat from math/big/float.go:
func __newFloat(x float64) Object {
	_res := _big.NewFloat(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.NewInt from math/big/int.go:
func __newInt(x int64) Object {
	_res := _big.NewInt(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.NewRat from math/big/rat.go:
func __newRat(a int64, b int64) Object {
	_res := _big.NewRat(a, b)
	return MakeGoObject(_res)
}

GO FUNC math/big.ParseFloat from math/big/floatconv.go:
func __parseFloat(s string, base int, prec uint, mode _big.RoundingMode) Object {
	f, b, err := _big.ParseFloat(s, base, prec, mode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(MakeInt(b))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/big.__accuracy_String from math/big/accuracy_string.go:
func __accuracy_String(o GoObject, args Object) Object {
	CheckGoArity("(_math/big.Accuracy)String()", args, 0, 0)
	_res := o.O.(_big.Accuracy).String()
	return MakeString(_res)
}

GO FUNC math/big.__errNaN_Error from math/big/float.go:
func __errNaN_Error(o GoObject, args Object) Object {
	CheckGoArity("(_math/big.ErrNaN)Error()", args, 0, 0)
	_res := o.O.(_big.ErrNaN).Error()
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Float_Abs from math/big/float.go:
// func __ptrTo_Float_Abs(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Abs()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1171:23)
// 	_res := o.O.(*_big.Float).Abs(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Acc from math/big/float.go:
func __ptrTo_Float_Acc(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Acc()", args, 0, 0)
	_res := o.O.(*_big.Float).Acc()
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_Add from math/big/float.go:
// func __ptrTo_Float_Add(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Add()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1438:26)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/float.go:1438:26)
// 	_res := o.O.(*_big.Float).Add(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Append from math/big/ftoa.go:
// func __ptrTo_Float_Append(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), fmt, prec)}

GO FUNC math/big.__ptrTo_Float_Cmp from math/big/float.go:
// func __ptrTo_Float_Cmp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Cmp()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/float.go:1671:23)
// 	_res := o.O.(*_big.Float).Cmp(y)
// 	return MakeInt(_res)
// }

GO FUNC math/big.__ptrTo_Float_Copy from math/big/float.go:
// func __ptrTo_Float_Copy(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Copy()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:667:24)
// 	_res := o.O.(*_big.Float).Copy(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Float32 from math/big/float.go:
// func __ptrTo_Float_Float32(o GoObject, args Object) Object {
// [ABEND007(find these) Object]}

GO FUNC math/big.__ptrTo_Float_Float64 from math/big/float.go:
// func __ptrTo_Float_Float64(o GoObject, args Object) Object {
// [ABEND007(find these) Object]}

GO FUNC math/big.__ptrTo_Float_Format from math/big/ftoa.go:
// func __ptrTo_Float_Format(o GoObject, args Object) Object {
// s ABEND987(genutils.go: imports not yet supported: fmt.State), format rune}

GO FUNC math/big.__ptrTo_Float_GobDecode from math/big/floatmarsh.go:
// func __ptrTo_Float_GobDecode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

GO FUNC math/big.__ptrTo_Float_GobEncode from math/big/floatmarsh.go:
func __ptrTo_Float_GobEncode(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)GobEncode()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Float).GobEncode()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Float_Int from math/big/float.go:
// func __ptrTo_Float_Int(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Int()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for z at: /usr/local/go/src/math/big/float.go:1071:23)
// 	_res1, _res2 := o.O.(*_big.Float).Int(z)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC math/big.__ptrTo_Float_Int64 from math/big/float.go:
func __ptrTo_Float_Int64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Int64()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Float).Int64()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC math/big.__ptrTo_Float_IsInf from math/big/float.go:
func __ptrTo_Float_IsInf(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)IsInf()", args, 0, 0)
	_res := o.O.(*_big.Float).IsInf()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Float_IsInt from math/big/float.go:
func __ptrTo_Float_IsInt(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)IsInt()", args, 0, 0)
	_res := o.O.(*_big.Float).IsInt()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Float_MantExp from math/big/float.go:
// func __ptrTo_Float_MantExp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)MantExp()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for mant at: /usr/local/go/src/math/big/float.go:266:30)
// 	_res := o.O.(*_big.Float).MantExp(mant)
// 	return MakeInt(_res)
// }

GO FUNC math/big.__ptrTo_Float_MarshalText from math/big/floatmarsh.go:
func __ptrTo_Float_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)MarshalText()", args, 0, 0)
	text, err := o.O.(*_big.Float).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Float_MinPrec from math/big/float.go:
func __ptrTo_Float_MinPrec(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)MinPrec()", args, 0, 0)
	_res := o.O.(*_big.Float).MinPrec()
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/big.__ptrTo_Float_Mode from math/big/float.go:
func __ptrTo_Float_Mode(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Mode()", args, 0, 0)
	_res := o.O.(*_big.Float).Mode()
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_Mul from math/big/float.go:
// func __ptrTo_Float_Mul(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Mul()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1579:26)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/float.go:1579:26)
// 	_res := o.O.(*_big.Float).Mul(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Neg from math/big/float.go:
// func __ptrTo_Float_Neg(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Neg()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1179:23)
// 	_res := o.O.(*_big.Float).Neg(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Parse from math/big/floatconv.go:
func __ptrTo_Float_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)Parse()", args, 2, 2)
	s := ExtractGoString("(*_math/big.Float)Parse()", "s", _argList, 0)
	base := ExtractGoInt("(*_math/big.Float)Parse()", "base", _argList, 1)
	f, b, err := o.O.(*_big.Float).Parse(s, base)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(MakeInt(b))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Float_Prec from math/big/float.go:
func __ptrTo_Float_Prec(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Prec()", args, 0, 0)
	_res := o.O.(*_big.Float).Prec()
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/big.__ptrTo_Float_Quo from math/big/float.go:
// func __ptrTo_Float_Quo(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Quo()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1624:26)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/float.go:1624:26)
// 	_res := o.O.(*_big.Float).Quo(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Rat from math/big/float.go:
// func __ptrTo_Float_Rat(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Rat()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for z at: /usr/local/go/src/math/big/float.go:1127:23)
// 	_res1, _res2 := o.O.(*_big.Float).Rat(z)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC math/big.__ptrTo_Float_Scan from math/big/floatconv.go:
// func __ptrTo_Float_Scan(o GoObject, args Object) Object {
// s ABEND987(genutils.go: imports not yet supported: fmt.ScanState), ch rune}

GO FUNC math/big.__ptrTo_Float_Set from math/big/float.go:
// func __ptrTo_Float_Set(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Set()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:643:23)
// 	_res := o.O.(*_big.Float).Set(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_SetFloat64 from math/big/float.go:
// func __ptrTo_Float_SetFloat64(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)SetFloat64()", args, 1, 1)
// 	x := ExtractGoABEND007(find these)("(*_math/big.Float)SetFloat64()", "x", _argList, 0)
// 	_res := o.O.(*_big.Float).SetFloat64(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_SetInf from math/big/float.go:
func __ptrTo_Float_SetInf(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetInf()", args, 1, 1)
	signbit := ExtractGoBoolean("(*_math/big.Float)SetInf()", "signbit", _argList, 0)
	_res := o.O.(*_big.Float).SetInf(signbit)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_SetInt from math/big/float.go:
// func __ptrTo_Float_SetInt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)SetInt()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:589:26)
// 	_res := o.O.(*_big.Float).SetInt(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_SetInt64 from math/big/float.go:
func __ptrTo_Float_SetInt64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetInt64()", args, 1, 1)
	x := ExtractGoInt64("(*_math/big.Float)SetInt64()", "x", _argList, 0)
	_res := o.O.(*_big.Float).SetInt64(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_SetMantExp from math/big/float.go:
// func __ptrTo_Float_SetMantExp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)SetMantExp()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for mant at: /usr/local/go/src/math/big/float.go:317:33)
// 	exp := ExtractGoInt("(*_math/big.Float)SetMantExp()", "exp", _argList, 1)
// 	_res := o.O.(*_big.Float).SetMantExp(mant, exp)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_SetMode from math/big/float.go:
func __ptrTo_Float_SetMode(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetMode()", args, 1, 1)
	mode := ExtractGo_go_std_math_big__RoundingMode("(*_math/big.Float)SetMode()", "mode", _argList, 0)
	_res := o.O.(*_big.Float).SetMode(mode)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_SetPrec from math/big/float.go:
func __ptrTo_Float_SetPrec(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetPrec()", args, 1, 1)
	prec := ExtractGoUInt("(*_math/big.Float)SetPrec()", "prec", _argList, 0)
	_res := o.O.(*_big.Float).SetPrec(prec)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_SetRat from math/big/float.go:
// func __ptrTo_Float_SetRat(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)SetRat()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:613:26)
// 	_res := o.O.(*_big.Float).SetRat(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_SetString from math/big/floatconv.go:
func __ptrTo_Float_SetString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetString()", args, 1, 1)
	s := ExtractGoString("(*_math/big.Float)SetString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_big.Float).SetString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC math/big.__ptrTo_Float_SetUint64 from math/big/float.go:
func __ptrTo_Float_SetUint64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)SetUint64()", args, 1, 1)
	x := ExtractGoUInt64("(*_math/big.Float)SetUint64()", "x", _argList, 0)
	_res := o.O.(*_big.Float).SetUint64(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Float_Sign from math/big/float.go:
func __ptrTo_Float_Sign(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Sign()", args, 0, 0)
	_res := o.O.(*_big.Float).Sign()
	return MakeInt(_res)
}

GO FUNC math/big.__ptrTo_Float_Signbit from math/big/float.go:
func __ptrTo_Float_Signbit(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Signbit()", args, 0, 0)
	_res := o.O.(*_big.Float).Signbit()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Float_Sqrt from math/big/sqrt.go:
// func __ptrTo_Float_Sqrt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Sqrt()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/sqrt.go:21:24)
// 	_res := o.O.(*_big.Float).Sqrt(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_String from math/big/ftoa.go:
func __ptrTo_Float_String(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)String()", args, 0, 0)
	_res := o.O.(*_big.Float).String()
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Float_Sub from math/big/float.go:
// func __ptrTo_Float_Sub(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Float)Sub()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/float.go:1512:26)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/float.go:1512:26)
// 	_res := o.O.(*_big.Float).Sub(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Float_Text from math/big/ftoa.go:
func __ptrTo_Float_Text(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Float)Text()", args, 2, 2)
	format := ExtractGoByte("(*_math/big.Float)Text()", "format", _argList, 0)
	prec := ExtractGoInt("(*_math/big.Float)Text()", "prec", _argList, 1)
	_res := o.O.(*_big.Float).Text(format, prec)
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Float_Uint64 from math/big/float.go:
func __ptrTo_Float_Uint64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Float)Uint64()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Float).Uint64()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC math/big.__ptrTo_Float_UnmarshalText from math/big/floatmarsh.go:
// func __ptrTo_Float_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC math/big.__ptrTo_Int_Abs from math/big/int.go:
// func __ptrTo_Int_Abs(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Abs()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:102:21)
// 	_res := o.O.(*_big.Int).Abs(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Add from math/big/int.go:
// func __ptrTo_Int_Add(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Add()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:116:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:116:24)
// 	_res := o.O.(*_big.Int).Add(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_And from math/big/int.go:
// func __ptrTo_Int_And(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)And()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1001:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:1001:24)
// 	_res := o.O.(*_big.Int).And(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_AndNot from math/big/int.go:
// func __ptrTo_Int_AndNot(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)AndNot()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1031:27)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:1031:27)
// 	_res := o.O.(*_big.Int).AndNot(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Append from math/big/intconv.go:
// func __ptrTo_Int_Append(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)), base)}

GO FUNC math/big.__ptrTo_Int_Binomial from math/big/int.go:
func __ptrTo_Int_Binomial(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)Binomial()", args, 2, 2)
	n := ExtractGoInt64("(*_math/big.Int)Binomial()", "n", _argList, 0)
	k := ExtractGoInt64("(*_math/big.Int)Binomial()", "k", _argList, 1)
	_res := o.O.(*_big.Int).Binomial(n, k)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Int_Bit from math/big/int.go:
func __ptrTo_Int_Bit(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)Bit()", args, 1, 1)
	i := ExtractGoInt("(*_math/big.Int)Bit()", "i", _argList, 0)
	_res := o.O.(*_big.Int).Bit(i)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/big.__ptrTo_Int_BitLen from math/big/int.go:
func __ptrTo_Int_BitLen(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)BitLen()", args, 0, 0)
	_res := o.O.(*_big.Int).BitLen()
	return MakeInt(_res)
}

GO FUNC math/big.__ptrTo_Int_Bits from math/big/int.go:
func __ptrTo_Int_Bits(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)Bits()", args, 0, 0)
	_res := o.O.(*_big.Int).Bits()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC math/big.__ptrTo_Int_Bytes from math/big/int.go:
func __ptrTo_Int_Bytes(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)Bytes()", args, 0, 0)
	_res := o.O.(*_big.Int).Bytes()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC math/big.__ptrTo_Int_Cmp from math/big/int.go:
// func __ptrTo_Int_Cmp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Cmp()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:320:21)
// 	_res := o.O.(*_big.Int).Cmp(y)
// 	return MakeInt(_res)
// }

GO FUNC math/big.__ptrTo_Int_CmpAbs from math/big/int.go:
// func __ptrTo_Int_CmpAbs(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)CmpAbs()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:345:24)
// 	_res := o.O.(*_big.Int).CmpAbs(y)
// 	return MakeInt(_res)
// }

GO FUNC math/big.__ptrTo_Int_Div from math/big/int.go:
// func __ptrTo_Int_Div(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Div()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:247:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:247:24)
// 	_res := o.O.(*_big.Int).Div(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_DivMod from math/big/int.go:
// func __ptrTo_Int_DivMod(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)DivMod()", args, 3, 3)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:296:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:296:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for m at: /usr/local/go/src/math/big/int.go:296:30)
// 	_res1, _res2 := o.O.(*_big.Int).DivMod(x, y, m)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC math/big.__ptrTo_Int_Exp from math/big/int.go:
// func __ptrTo_Int_Exp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Exp()", args, 3, 3)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:456:27)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:456:27)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for m at: /usr/local/go/src/math/big/int.go:456:27)
// 	_res := o.O.(*_big.Int).Exp(x, y, m)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Format from math/big/intconv.go:
// func __ptrTo_Int_Format(o GoObject, args Object) Object {
// s ABEND987(genutils.go: imports not yet supported: fmt.State), ch rune}

GO FUNC math/big.__ptrTo_Int_GCD from math/big/int.go:
// func __ptrTo_Int_GCD(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)GCD()", args, 4, 4)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:488:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:488:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for a at: /usr/local/go/src/math/big/int.go:488:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for b at: /usr/local/go/src/math/big/int.go:488:30)
// 	_res := o.O.(*_big.Int).GCD(x, y, a, b)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_GobDecode from math/big/intmarsh.go:
// func __ptrTo_Int_GobDecode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

GO FUNC math/big.__ptrTo_Int_GobEncode from math/big/intmarsh.go:
func __ptrTo_Int_GobEncode(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)GobEncode()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Int).GobEncode()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Int_Int64 from math/big/int.go:
func __ptrTo_Int_Int64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)Int64()", args, 0, 0)
	_res := o.O.(*_big.Int).Int64()
	return MakeBigInt(_res)
}

GO FUNC math/big.__ptrTo_Int_IsInt64 from math/big/int.go:
func __ptrTo_Int_IsInt64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)IsInt64()", args, 0, 0)
	_res := o.O.(*_big.Int).IsInt64()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Int_IsUint64 from math/big/int.go:
func __ptrTo_Int_IsUint64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)IsUint64()", args, 0, 0)
	_res := o.O.(*_big.Int).IsUint64()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Int_Lsh from math/big/int.go:
// func __ptrTo_Int_Lsh(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Lsh()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:937:21)
// 	n := ExtractGoUInt("(*_math/big.Int)Lsh()", "n", _argList, 1)
// 	_res := o.O.(*_big.Int).Lsh(x, n)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_MarshalJSON from math/big/intmarsh.go:
func __ptrTo_Int_MarshalJSON(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)MarshalJSON()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Int).MarshalJSON()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Int_MarshalText from math/big/intmarsh.go:
func __ptrTo_Int_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)MarshalText()", args, 0, 0)
	text, err := o.O.(*_big.Int).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Int_Mod from math/big/int.go:
// func __ptrTo_Int_Mod(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Mod()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:264:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:264:24)
// 	_res := o.O.(*_big.Int).Mod(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_ModInverse from math/big/int.go:
// func __ptrTo_Int_ModInverse(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)ModInverse()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for g at: /usr/local/go/src/math/big/int.go:737:31)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for n at: /usr/local/go/src/math/big/int.go:737:31)
// 	_res := o.O.(*_big.Int).ModInverse(g, n)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_ModSqrt from math/big/int.go:
// func __ptrTo_Int_ModSqrt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)ModSqrt()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:910:28)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for p at: /usr/local/go/src/math/big/int.go:910:28)
// 	_res := o.O.(*_big.Int).ModSqrt(x, p)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Mul from math/big/int.go:
// func __ptrTo_Int_Mul(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Mul()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:158:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:158:24)
// 	_res := o.O.(*_big.Int).Mul(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_MulRange from math/big/int.go:
func __ptrTo_Int_MulRange(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)MulRange()", args, 2, 2)
	a := ExtractGoInt64("(*_math/big.Int)MulRange()", "a", _argList, 0)
	b := ExtractGoInt64("(*_math/big.Int)MulRange()", "b", _argList, 1)
	_res := o.O.(*_big.Int).MulRange(a, b)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Int_Neg from math/big/int.go:
// func __ptrTo_Int_Neg(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Neg()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:109:21)
// 	_res := o.O.(*_big.Int).Neg(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Not from math/big/int.go:
// func __ptrTo_Int_Not(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Not()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1124:21)
// 	_res := o.O.(*_big.Int).Not(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Or from math/big/int.go:
// func __ptrTo_Int_Or(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Or()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1064:23)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:1064:23)
// 	_res := o.O.(*_big.Int).Or(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_ProbablyPrime from math/big/prime.go:
func __ptrTo_Int_ProbablyPrime(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)ProbablyPrime()", args, 1, 1)
	n := ExtractGoInt("(*_math/big.Int)ProbablyPrime()", "n", _argList, 0)
	_res := o.O.(*_big.Int).ProbablyPrime(n)
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Int_Quo from math/big/int.go:
// func __ptrTo_Int_Quo(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Quo()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:211:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:211:24)
// 	_res := o.O.(*_big.Int).Quo(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_QuoRem from math/big/int.go:
// func __ptrTo_Int_QuoRem(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)QuoRem()", args, 3, 3)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:238:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:238:30)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for r at: /usr/local/go/src/math/big/int.go:238:30)
// 	_res1, _res2 := o.O.(*_big.Int).QuoRem(x, y, r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(MakeGoObject(_res2))
// 	return _res
// }

GO FUNC math/big.__ptrTo_Int_Rand from math/big/int.go:
// func __ptrTo_Int_Rand(o GoObject, args Object) Object {
// rnd *ABEND987(genutils.go: imports not yet supported: rand.Rand), n *_big.Int}

GO FUNC math/big.__ptrTo_Int_Rem from math/big/int.go:
// func __ptrTo_Int_Rem(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Rem()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:220:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:220:24)
// 	_res := o.O.(*_big.Int).Rem(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Rsh from math/big/int.go:
// func __ptrTo_Int_Rsh(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Rsh()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:944:21)
// 	n := ExtractGoUInt("(*_math/big.Int)Rsh()", "n", _argList, 1)
// 	_res := o.O.(*_big.Int).Rsh(x, n)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Scan from math/big/intconv.go:
// func __ptrTo_Int_Scan(o GoObject, args Object) Object {
// s ABEND987(genutils.go: imports not yet supported: fmt.ScanState), ch rune}

GO FUNC math/big.__ptrTo_Int_Set from math/big/int.go:
// func __ptrTo_Int_Set(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Set()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:73:21)
// 	_res := o.O.(*_big.Int).Set(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_SetBit from math/big/int.go:
// func __ptrTo_Int_SetBit(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)SetBit()", args, 3, 3)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:984:24)
// 	i := ExtractGoInt("(*_math/big.Int)SetBit()", "i", _argList, 1)
// 	b := ExtractGoUInt("(*_math/big.Int)SetBit()", "b", _argList, 2)
// 	_res := o.O.(*_big.Int).SetBit(x, i, b)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_SetBits from math/big/int.go:
// func __ptrTo_Int_SetBits(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_big.Word(*abs)))}

GO FUNC math/big.__ptrTo_Int_SetBytes from math/big/int.go:
// func __ptrTo_Int_SetBytes(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

GO FUNC math/big.__ptrTo_Int_SetInt64 from math/big/int.go:
func __ptrTo_Int_SetInt64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)SetInt64()", args, 1, 1)
	x := ExtractGoInt64("(*_math/big.Int)SetInt64()", "x", _argList, 0)
	_res := o.O.(*_big.Int).SetInt64(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Int_SetString from math/big/int.go:
func __ptrTo_Int_SetString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)SetString()", args, 2, 2)
	s := ExtractGoString("(*_math/big.Int)SetString()", "s", _argList, 0)
	base := ExtractGoInt("(*_math/big.Int)SetString()", "base", _argList, 1)
	_res1, _res2 := o.O.(*_big.Int).SetString(s, base)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC math/big.__ptrTo_Int_SetUint64 from math/big/int.go:
func __ptrTo_Int_SetUint64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)SetUint64()", args, 1, 1)
	x := ExtractGoUInt64("(*_math/big.Int)SetUint64()", "x", _argList, 0)
	_res := o.O.(*_big.Int).SetUint64(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Int_Sign from math/big/int.go:
func __ptrTo_Int_Sign(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)Sign()", args, 0, 0)
	_res := o.O.(*_big.Int).Sign()
	return MakeInt(_res)
}

GO FUNC math/big.__ptrTo_Int_Sqrt from math/big/int.go:
// func __ptrTo_Int_Sqrt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Sqrt()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1140:22)
// 	_res := o.O.(*_big.Int).Sqrt(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_String from math/big/intconv.go:
func __ptrTo_Int_String(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)String()", args, 0, 0)
	_res := o.O.(*_big.Int).String()
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Int_Sub from math/big/int.go:
// func __ptrTo_Int_Sub(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Sub()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:137:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:137:24)
// 	_res := o.O.(*_big.Int).Sub(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Int_Text from math/big/intconv.go:
func __ptrTo_Int_Text(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Int)Text()", args, 1, 1)
	base := ExtractGoInt("(*_math/big.Int)Text()", "base", _argList, 0)
	_res := o.O.(*_big.Int).Text(base)
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Int_Uint64 from math/big/int.go:
func __ptrTo_Int_Uint64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Int)Uint64()", args, 0, 0)
	_res := o.O.(*_big.Int).Uint64()
	return MakeBigIntU(_res)
}

GO FUNC math/big.__ptrTo_Int_UnmarshalJSON from math/big/intmarsh.go:
// func __ptrTo_Int_UnmarshalJSON(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC math/big.__ptrTo_Int_UnmarshalText from math/big/intmarsh.go:
// func __ptrTo_Int_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC math/big.__ptrTo_Int_Xor from math/big/int.go:
// func __ptrTo_Int_Xor(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Int)Xor()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/int.go:1094:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/int.go:1094:24)
// 	_res := o.O.(*_big.Int).Xor(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Abs from math/big/rat.go:
// func __ptrTo_Rat_Abs(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Abs()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:352:21)
// 	_res := o.O.(*_big.Rat).Abs(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Add from math/big/rat.go:
// func __ptrTo_Rat_Add(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Add()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:481:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/rat.go:481:24)
// 	_res := o.O.(*_big.Rat).Add(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Cmp from math/big/rat.go:
// func __ptrTo_Rat_Cmp(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Cmp()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/rat.go:476:21)
// 	_res := o.O.(*_big.Rat).Cmp(y)
// 	return MakeInt(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Denom from math/big/rat.go:
func __ptrTo_Rat_Denom(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)Denom()", args, 0, 0)
	_res := o.O.(*_big.Rat).Denom()
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Rat_Float32 from math/big/rat.go:
// func __ptrTo_Rat_Float32(o GoObject, args Object) Object {
// [ABEND007(find these) Boolean]}

GO FUNC math/big.__ptrTo_Rat_Float64 from math/big/rat.go:
// func __ptrTo_Rat_Float64(o GoObject, args Object) Object {
// [ABEND007(find these) Boolean]}

GO FUNC math/big.__ptrTo_Rat_FloatString from math/big/ratconv.go:
func __ptrTo_Rat_FloatString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Rat)FloatString()", args, 1, 1)
	prec := ExtractGoInt("(*_math/big.Rat)FloatString()", "prec", _argList, 0)
	_res := o.O.(*_big.Rat).FloatString(prec)
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Rat_GobDecode from math/big/ratmarsh.go:
// func __ptrTo_Rat_GobDecode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

GO FUNC math/big.__ptrTo_Rat_GobEncode from math/big/ratmarsh.go:
func __ptrTo_Rat_GobEncode(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)GobEncode()", args, 0, 0)
	_res1, _res2 := o.O.(*_big.Rat).GobEncode()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Rat_Inv from math/big/rat.go:
// func __ptrTo_Rat_Inv(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Inv()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:366:21)
// 	_res := o.O.(*_big.Rat).Inv(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_IsInt from math/big/rat.go:
func __ptrTo_Rat_IsInt(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)IsInt()", args, 0, 0)
	_res := o.O.(*_big.Rat).IsInt()
	return MakeBoolean(_res)
}

GO FUNC math/big.__ptrTo_Rat_MarshalText from math/big/ratmarsh.go:
func __ptrTo_Rat_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)MarshalText()", args, 0, 0)
	text, err := o.O.(*_big.Rat).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/big.__ptrTo_Rat_Mul from math/big/rat.go:
// func __ptrTo_Rat_Mul(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Mul()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:499:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/rat.go:499:24)
// 	_res := o.O.(*_big.Rat).Mul(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Neg from math/big/rat.go:
// func __ptrTo_Rat_Neg(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Neg()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:359:21)
// 	_res := o.O.(*_big.Rat).Neg(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_Num from math/big/rat.go:
func __ptrTo_Rat_Num(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)Num()", args, 0, 0)
	_res := o.O.(*_big.Rat).Num()
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Rat_Quo from math/big/rat.go:
// func __ptrTo_Rat_Quo(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Quo()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:514:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/rat.go:514:24)
// 	_res := o.O.(*_big.Rat).Quo(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_RatString from math/big/ratconv.go:
func __ptrTo_Rat_RatString(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)RatString()", args, 0, 0)
	_res := o.O.(*_big.Rat).RatString()
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Rat_Scan from math/big/ratconv.go:
// func __ptrTo_Rat_Scan(o GoObject, args Object) Object {
// s ABEND987(genutils.go: imports not yet supported: fmt.ScanState), ch rune}

GO FUNC math/big.__ptrTo_Rat_Set from math/big/rat.go:
// func __ptrTo_Rat_Set(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Set()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:343:21)
// 	_res := o.O.(*_big.Rat).Set(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_SetFloat64 from math/big/rat.go:
// func __ptrTo_Rat_SetFloat64(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)SetFloat64()", args, 1, 1)
// 	f := ExtractGoABEND007(find these)("(*_math/big.Rat)SetFloat64()", "f", _argList, 0)
// 	_res := o.O.(*_big.Rat).SetFloat64(f)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_SetFrac from math/big/rat.go:
// func __ptrTo_Rat_SetFrac(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)SetFrac()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for a at: /usr/local/go/src/math/big/rat.go:300:28)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for b at: /usr/local/go/src/math/big/rat.go:300:28)
// 	_res := o.O.(*_big.Rat).SetFrac(a, b)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_SetFrac64 from math/big/rat.go:
func __ptrTo_Rat_SetFrac64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Rat)SetFrac64()", args, 2, 2)
	a := ExtractGoInt64("(*_math/big.Rat)SetFrac64()", "a", _argList, 0)
	b := ExtractGoInt64("(*_math/big.Rat)SetFrac64()", "b", _argList, 1)
	_res := o.O.(*_big.Rat).SetFrac64(a, b)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Rat_SetInt from math/big/rat.go:
// func __ptrTo_Rat_SetInt(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)SetInt()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:329:24)
// 	_res := o.O.(*_big.Rat).SetInt(x)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_SetInt64 from math/big/rat.go:
func __ptrTo_Rat_SetInt64(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Rat)SetInt64()", args, 1, 1)
	x := ExtractGoInt64("(*_math/big.Rat)SetInt64()", "x", _argList, 0)
	_res := o.O.(*_big.Rat).SetInt64(x)
	return MakeGoObject(_res)
}

GO FUNC math/big.__ptrTo_Rat_SetString from math/big/ratconv.go:
func __ptrTo_Rat_SetString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/big.Rat)SetString()", args, 1, 1)
	s := ExtractGoString("(*_math/big.Rat)SetString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_big.Rat).SetString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC math/big.__ptrTo_Rat_Sign from math/big/rat.go:
func __ptrTo_Rat_Sign(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)Sign()", args, 0, 0)
	_res := o.O.(*_big.Rat).Sign()
	return MakeInt(_res)
}

GO FUNC math/big.__ptrTo_Rat_String from math/big/ratconv.go:
func __ptrTo_Rat_String(o GoObject, args Object) Object {
	CheckGoArity("(*_math/big.Rat)String()", args, 0, 0)
	_res := o.O.(*_big.Rat).String()
	return MakeString(_res)
}

GO FUNC math/big.__ptrTo_Rat_Sub from math/big/rat.go:
// func __ptrTo_Rat_Sub(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_math/big.Rat)Sub()", args, 2, 2)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for x at: /usr/local/go/src/math/big/rat.go:490:24)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/math/big/rat.go:490:24)
// 	_res := o.O.(*_big.Rat).Sub(x, y)
// 	return MakeGoObject(_res)
// }

GO FUNC math/big.__ptrTo_Rat_UnmarshalText from math/big/ratmarsh.go:
// func __ptrTo_Rat_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC math/big.__roundingMode_String from math/big/roundingmode_string.go:
func __roundingMode_String(o GoObject, args Object) Object {
	CheckGoArity("(_math/big.RoundingMode)String()", args, 0, 0)
	_res := o.O.(_big.RoundingMode).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package big

import (
	. "github.com/candid82/joker/core"
	_big "math/big"
	_reflect "reflect"
)
var members_Accuracy = GoTypeInfo{Members: GoMembers{
	"String": __accuracy_String,
}}

var members_ErrNaN = GoTypeInfo{Members: GoMembers{
	"Error": __errNaN_Error,
}}

var members_PtrTo_Float = GoTypeInfo{Members: GoMembers{
	"Acc": __ptrTo_Float_Acc,
	"GobEncode": __ptrTo_Float_GobEncode,
	"Int64": __ptrTo_Float_Int64,
	"IsInf": __ptrTo_Float_IsInf,
	"IsInt": __ptrTo_Float_IsInt,
	"MarshalText": __ptrTo_Float_MarshalText,
	"MinPrec": __ptrTo_Float_MinPrec,
	"Mode": __ptrTo_Float_Mode,
	"Parse": __ptrTo_Float_Parse,
	"Prec": __ptrTo_Float_Prec,
	"SetInf": __ptrTo_Float_SetInf,
	"SetInt64": __ptrTo_Float_SetInt64,
	"SetMode": __ptrTo_Float_SetMode,
	"SetPrec": __ptrTo_Float_SetPrec,
	"SetString": __ptrTo_Float_SetString,
	"SetUint64": __ptrTo_Float_SetUint64,
	"Sign": __ptrTo_Float_Sign,
	"Signbit": __ptrTo_Float_Signbit,
	"String": __ptrTo_Float_String,
	"Text": __ptrTo_Float_Text,
	"Uint64": __ptrTo_Float_Uint64,
}}

var members_PtrTo_Int = GoTypeInfo{Members: GoMembers{
	"Binomial": __ptrTo_Int_Binomial,
	"Bit": __ptrTo_Int_Bit,
	"BitLen": __ptrTo_Int_BitLen,
	"Bits": __ptrTo_Int_Bits,
	"Bytes": __ptrTo_Int_Bytes,
	"GobEncode": __ptrTo_Int_GobEncode,
	"Int64": __ptrTo_Int_Int64,
	"IsInt64": __ptrTo_Int_IsInt64,
	"IsUint64": __ptrTo_Int_IsUint64,
	"MarshalJSON": __ptrTo_Int_MarshalJSON,
	"MarshalText": __ptrTo_Int_MarshalText,
	"MulRange": __ptrTo_Int_MulRange,
	"ProbablyPrime": __ptrTo_Int_ProbablyPrime,
	"SetInt64": __ptrTo_Int_SetInt64,
	"SetString": __ptrTo_Int_SetString,
	"SetUint64": __ptrTo_Int_SetUint64,
	"Sign": __ptrTo_Int_Sign,
	"String": __ptrTo_Int_String,
	"Text": __ptrTo_Int_Text,
	"Uint64": __ptrTo_Int_Uint64,
}}

var members_PtrTo_Rat = GoTypeInfo{Members: GoMembers{
	"Denom": __ptrTo_Rat_Denom,
	"FloatString": __ptrTo_Rat_FloatString,
	"GobEncode": __ptrTo_Rat_GobEncode,
	"IsInt": __ptrTo_Rat_IsInt,
	"MarshalText": __ptrTo_Rat_MarshalText,
	"Num": __ptrTo_Rat_Num,
	"RatString": __ptrTo_Rat_RatString,
	"SetFrac64": __ptrTo_Rat_SetFrac64,
	"SetInt64": __ptrTo_Rat_SetInt64,
	"SetString": __ptrTo_Rat_SetString,
	"Sign": __ptrTo_Rat_Sign,
	"String": __ptrTo_Rat_String,
}}

var members_RoundingMode = GoTypeInfo{Members: GoMembers{
	"String": __roundingMode_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_big.Accuracy)(nil)).Elem()] = &members_Accuracy
	GoTypes[_reflect.TypeOf((*_big.ErrNaN)(nil)).Elem()] = &members_ErrNaN
	GoTypes[_reflect.TypeOf((*_big.Float)(nil))] = &members_PtrTo_Float
	GoTypes[_reflect.TypeOf((*_big.Int)(nil))] = &members_PtrTo_Int
	GoTypes[_reflect.TypeOf((*_big.Rat)(nil))] = &members_PtrTo_Rat
	GoTypes[_reflect.TypeOf((*_big.RoundingMode)(nil)).Elem()] = &members_RoundingMode
}

GO FUNC math/bits.Add from math/bits/bits.go:
func __add(x uint, y uint, carry uint) Object {
	sum, carryOut := _bits.Add(x, y, carry)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(sum)))
	_res = _res.Conjoin(MakeBigIntU(uint64(carryOut)))
	return _res
}

GO FUNC math/bits.Add32 from math/bits/bits.go:
func __add32(x uint32, y uint32, carry uint32) Object {
	sum, carryOut := _bits.Add32(x, y, carry)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(sum)))
	_res = _res.Conjoin(MakeBigIntU(uint64(carryOut)))
	return _res
}

GO FUNC math/bits.Add64 from math/bits/bits.go:
func __add64(x uint64, y uint64, carry uint64) Object {
	sum, carryOut := _bits.Add64(x, y, carry)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(sum))
	_res = _res.Conjoin(MakeBigIntU(carryOut))
	return _res
}

GO FUNC math/bits.Div from math/bits/bits.go:
func __div(hi uint, lo uint, y uint) Object {
	quo, rem := _bits.Div(hi, lo, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(quo)))
	_res = _res.Conjoin(MakeBigIntU(uint64(rem)))
	return _res
}

GO FUNC math/bits.Div32 from math/bits/bits.go:
func __div32(hi uint32, lo uint32, y uint32) Object {
	quo, rem := _bits.Div32(hi, lo, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(quo)))
	_res = _res.Conjoin(MakeBigIntU(uint64(rem)))
	return _res
}

GO FUNC math/bits.Div64 from math/bits/bits.go:
func __div64(hi uint64, lo uint64, y uint64) Object {
	quo, rem := _bits.Div64(hi, lo, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(quo))
	_res = _res.Conjoin(MakeBigIntU(rem))
	return _res
}

GO FUNC math/bits.Mul from math/bits/bits.go:
func __mul(x uint, y uint) Object {
	hi, lo := _bits.Mul(x, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(hi)))
	_res = _res.Conjoin(MakeBigIntU(uint64(lo)))
	return _res
}

GO FUNC math/bits.Mul32 from math/bits/bits.go:
func __mul32(x uint32, y uint32) Object {
	hi, lo := _bits.Mul32(x, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(hi)))
	_res = _res.Conjoin(MakeBigIntU(uint64(lo)))
	return _res
}

GO FUNC math/bits.Mul64 from math/bits/bits.go:
func __mul64(x uint64, y uint64) Object {
	hi, lo := _bits.Mul64(x, y)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(hi))
	_res = _res.Conjoin(MakeBigIntU(lo))
	return _res
}

GO FUNC math/bits.Reverse from math/bits/bits.go:
func __reverse(x uint) Object {
	_res := _bits.Reverse(x)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.Reverse16 from math/bits/bits.go:
func __reverse16(x uint16) Object {
	_res := _bits.Reverse16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Reverse32 from math/bits/bits.go:
func __reverse32(x uint32) Object {
	_res := _bits.Reverse32(x)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.Reverse64 from math/bits/bits.go:
func __reverse64(x uint64) Object {
	_res := _bits.Reverse64(x)
	return MakeBigIntU(_res)
}

GO FUNC math/bits.Reverse8 from math/bits/bits.go:
func __reverse8(x uint8) Object {
	_res := _bits.Reverse8(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes from math/bits/bits.go:
func __reverseBytes(x uint) Object {
	_res := _bits.ReverseBytes(x)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.ReverseBytes16 from math/bits/bits.go:
func __reverseBytes16(x uint16) Object {
	_res := _bits.ReverseBytes16(x)
	return MakeInt(int(_res))
}

GO FUNC math/bits.ReverseBytes32 from math/bits/bits.go:
func __reverseBytes32(x uint32) Object {
	_res := _bits.ReverseBytes32(x)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.ReverseBytes64 from math/bits/bits.go:
func __reverseBytes64(x uint64) Object {
	_res := _bits.ReverseBytes64(x)
	return MakeBigIntU(_res)
}

GO FUNC math/bits.RotateLeft from math/bits/bits.go:
func __rotateLeft(x uint, k int) Object {
	_res := _bits.RotateLeft(x, k)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.RotateLeft16 from math/bits/bits.go:
func __rotateLeft16(x uint16, k int) Object {
	_res := _bits.RotateLeft16(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.RotateLeft32 from math/bits/bits.go:
func __rotateLeft32(x uint32, k int) Object {
	_res := _bits.RotateLeft32(x, k)
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/bits.RotateLeft64 from math/bits/bits.go:
func __rotateLeft64(x uint64, k int) Object {
	_res := _bits.RotateLeft64(x, k)
	return MakeBigIntU(_res)
}

GO FUNC math/bits.RotateLeft8 from math/bits/bits.go:
func __rotateLeft8(x uint8, k int) Object {
	_res := _bits.RotateLeft8(x, k)
	return MakeInt(int(_res))
}

GO FUNC math/bits.Sub from math/bits/bits.go:
func __sub(x uint, y uint, borrow uint) Object {
	diff, borrowOut := _bits.Sub(x, y, borrow)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(diff)))
	_res = _res.Conjoin(MakeBigIntU(uint64(borrowOut)))
	return _res
}

GO FUNC math/bits.Sub32 from math/bits/bits.go:
func __sub32(x uint32, y uint32, borrow uint32) Object {
	diff, borrowOut := _bits.Sub32(x, y, borrow)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(diff)))
	_res = _res.Conjoin(MakeBigIntU(uint64(borrowOut)))
	return _res
}

GO FUNC math/bits.Sub64 from math/bits/bits.go:
func __sub64(x uint64, y uint64, borrow uint64) Object {
	diff, borrowOut := _bits.Sub64(x, y, borrow)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(diff))
	_res = _res.Conjoin(MakeBigIntU(borrowOut))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package bits

import (
	. "github.com/candid82/joker/core"
	_bits "math/bits"
)

func init() {
}

GO FUNC math/cmplx.Abs from math/cmplx/abs.go:
// func __abs(x complex128) Object {
// 	_res := _cmplx.Abs(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math/cmplx.Acos from math/cmplx/asin.go:
// func __acos(x complex128) Object {
// 	_res := _cmplx.Acos(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Acosh from math/cmplx/asin.go:
// func __acosh(x complex128) Object {
// 	_res := _cmplx.Acosh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Asin from math/cmplx/asin.go:
// func __asin(x complex128) Object {
// 	_res := _cmplx.Asin(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Asinh from math/cmplx/asin.go:
// func __asinh(x complex128) Object {
// 	_res := _cmplx.Asinh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Atan from math/cmplx/asin.go:
// func __atan(x complex128) Object {
// 	_res := _cmplx.Atan(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Atanh from math/cmplx/asin.go:
// func __atanh(x complex128) Object {
// 	_res := _cmplx.Atanh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Conj from math/cmplx/conj.go:
// func __conj(x complex128) Object {
// 	_res := _cmplx.Conj(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Cos from math/cmplx/sin.go:
// func __cos(x complex128) Object {
// 	_res := _cmplx.Cos(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Cosh from math/cmplx/sin.go:
// func __cosh(x complex128) Object {
// 	_res := _cmplx.Cosh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Cot from math/cmplx/tan.go:
// func __cot(x complex128) Object {
// 	_res := _cmplx.Cot(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Exp from math/cmplx/exp.go:
// func __exp(x complex128) Object {
// 	_res := _cmplx.Exp(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Inf from math/cmplx/isinf.go:
// func __inf() Object {
// 	_res := _cmplx.Inf()
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Log from math/cmplx/log.go:
// func __log(x complex128) Object {
// 	_res := _cmplx.Log(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Log10 from math/cmplx/log.go:
// func __log10(x complex128) Object {
// 	_res := _cmplx.Log10(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.NaN from math/cmplx/isnan.go:
// func __naN() Object {
// 	_res := _cmplx.NaN()
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Phase from math/cmplx/phase.go:
// func __phase(x complex128) Object {
// 	_res := _cmplx.Phase(x)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math/cmplx.Polar from math/cmplx/polar.go:
// func __polar(x complex128) Object {
// 	r,  := _cmplx.Polar(x)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	return _res
// }

GO FUNC math/cmplx.Pow from math/cmplx/pow.go:
// func __pow(x complex128, y complex128) Object {
// 	_res := _cmplx.Pow(x, y)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Rect from math/cmplx/rect.go:
// func __rect(r float64,  float64) Object {
// 	_res := _cmplx.Rect(r, )
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Sin from math/cmplx/sin.go:
// func __sin(x complex128) Object {
// 	_res := _cmplx.Sin(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Sinh from math/cmplx/sin.go:
// func __sinh(x complex128) Object {
// 	_res := _cmplx.Sinh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Sqrt from math/cmplx/sqrt.go:
// func __sqrt(x complex128) Object {
// 	_res := _cmplx.Sqrt(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Tan from math/cmplx/tan.go:
// func __tan(x complex128) Object {
// 	_res := _cmplx.Tan(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

GO FUNC math/cmplx.Tanh from math/cmplx/tan.go:
// func __tanh(x complex128) Object {
// 	_res := _cmplx.Tanh(x)
// 	return ABEND043(post.go: unsupported built-in type complex128)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cmplx

import (
)

func init() {
}

GO TYPE math/rand.Rand from math/rand/rand.go:
func ExtractGoObjectRand(args []Object, index int) *_rand.Rand {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Rand:
			return &r
		case *_rand.Rand:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Rand]"))
}

func _mapToRand(o Map) *_rand.Rand {
	return &_rand.Rand{}
}

func _vectorToRand(o *Vector) *_rand.Rand {
	return &_rand.Rand{}
}

func _ConstructRand(_v Object) *_rand.Rand {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rand.Rand:
			return &_g
		case *_rand.Rand:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRand(_o.(Map))
	case *Vector:
		return _vectorToRand(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Rand] or: Map or Vector"))
}

GO TYPE math/rand.Source from math/rand/rand.go:
func ExtractGoObjectSource(args []Object, index int) *_rand.Source {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Source:
			return &r
		case *_rand.Source:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Source]"))
}

// func _ConstructSource(_v Object) _rand.Source {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rand.Source:
// 			return _g
// 		case *_rand.Source:
// 			return *_g
// 		}
// 	default:
// 		return _rand.Source(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Source))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Source] or: whatever"))
// }

GO TYPE math/rand.Source64 from math/rand/rand.go:
func ExtractGoObjectSource64(args []Object, index int) *_rand.Source64 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Source64:
			return &r
		case *_rand.Source64:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Source64]"))
}

// func _ConstructSource64(_v Object) _rand.Source64 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rand.Source64:
// 			return _g
// 		case *_rand.Source64:
// 			return *_g
// 		}
// 	default:
// 		return _rand.Source64(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Source64))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Source64] or: whatever"))
// }

GO TYPE math/rand.Zipf from math/rand/zipf.go:
func ExtractGoObjectZipf(args []Object, index int) *_rand.Zipf {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rand.Zipf:
			return &r
		case *_rand.Zipf:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[math/rand.Zipf]"))
}

func _mapToZipf(o Map) *_rand.Zipf {
	return &_rand.Zipf{}
}

func _vectorToZipf(o *Vector) *_rand.Zipf {
	return &_rand.Zipf{}
}

func _ConstructZipf(_v Object) *_rand.Zipf {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rand.Zipf:
			return &_g
		case *_rand.Zipf:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToZipf(_o.(Map))
	case *Vector:
		return _vectorToZipf(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rand.Zipf] or: Map or Vector"))
}

GO FUNC math/rand.ExpFloat64 from math/rand/rand.go:
// func __expFloat64() Object {
// 	_res := _rand.ExpFloat64()
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math/rand.Float32 from math/rand/rand.go:
// func __float32() Object {
// 	_res := _rand.Float32()
// 	return ABEND043(post.go: unsupported built-in type float32)
// }

GO FUNC math/rand.Float64 from math/rand/rand.go:
// func __float64() Object {
// 	_res := _rand.Float64()
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math/rand.Int31 from math/rand/rand.go:
func __int31() Object {
	_res := _rand.Int31()
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int31n from math/rand/rand.go:
func __int31n(n int32) Object {
	_res := _rand.Int31n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.Int63 from math/rand/rand.go:
func __int63() Object {
	_res := _rand.Int63()
	return MakeBigInt(_res)
}

GO FUNC math/rand.Int63n from math/rand/rand.go:
func __int63n(n int64) Object {
	_res := _rand.Int63n(n)
	return MakeBigInt(_res)
}

GO FUNC math/rand.New from math/rand/rand.go:
func __new(src _rand.Source) Object {
	_res := _rand.New(src)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewSource from math/rand/rand.go:
func __newSource(seed int64) Object {
	_res := _rand.NewSource(seed)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NewZipf from math/rand/zipf.go:
func __newZipf(r *_rand.Rand, s float64, v float64, imax uint64) Object {
	_res := _rand.NewZipf(r, s, v, imax)
	return MakeGoObject(_res)
}

GO FUNC math/rand.NormFloat64 from math/rand/rand.go:
// func __normFloat64() Object {
// 	_res := _rand.NormFloat64()
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC math/rand.Perm from math/rand/rand.go:
func __perm(n int) Object {
	_res := _rand.Perm(n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC math/rand.Read from math/rand/rand.go:
// func __read(p []byte) Object {
// 	n, err := _rand.Read(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC math/rand.Seed from math/rand/rand.go:
// func __seed(seed int64) Object {
// 	_rand.Seed(seed)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Shuffle from math/rand/rand.go:
// func __shuffle(n int, swap func) Object {
// 	_rand.Shuffle(n, swap)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Uint32 from math/rand/rand.go:
func __uint32() Object {
	_res := _rand.Uint32()
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/rand.Uint64 from math/rand/rand.go:
func __uint64() Object {
	_res := _rand.Uint64()
	return MakeBigIntU(_res)
}

GO FUNC math/rand.__ptrTo_Rand_ExpFloat64 from math/rand/exp.go:
// func __ptrTo_Rand_ExpFloat64(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC math/rand.__ptrTo_Rand_Float32 from math/rand/rand.go:
// func __ptrTo_Rand_Float32(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC math/rand.__ptrTo_Rand_Float64 from math/rand/rand.go:
// func __ptrTo_Rand_Float64(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC math/rand.__ptrTo_Rand_Int from math/rand/rand.go:
func __ptrTo_Rand_Int(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Rand)Int()", args, 0, 0)
	_res := o.O.(*_rand.Rand).Int()
	return MakeInt(_res)
}

GO FUNC math/rand.__ptrTo_Rand_Int31 from math/rand/rand.go:
func __ptrTo_Rand_Int31(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Rand)Int31()", args, 0, 0)
	_res := o.O.(*_rand.Rand).Int31()
	return MakeInt(int(_res))
}

GO FUNC math/rand.__ptrTo_Rand_Int31n from math/rand/rand.go:
func __ptrTo_Rand_Int31n(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/rand.Rand)Int31n()", args, 1, 1)
	n := ExtractGoInt32("(*_math/rand.Rand)Int31n()", "n", _argList, 0)
	_res := o.O.(*_rand.Rand).Int31n(n)
	return MakeInt(int(_res))
}

GO FUNC math/rand.__ptrTo_Rand_Int63 from math/rand/rand.go:
func __ptrTo_Rand_Int63(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Rand)Int63()", args, 0, 0)
	_res := o.O.(*_rand.Rand).Int63()
	return MakeBigInt(_res)
}

GO FUNC math/rand.__ptrTo_Rand_Int63n from math/rand/rand.go:
func __ptrTo_Rand_Int63n(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/rand.Rand)Int63n()", args, 1, 1)
	n := ExtractGoInt64("(*_math/rand.Rand)Int63n()", "n", _argList, 0)
	_res := o.O.(*_rand.Rand).Int63n(n)
	return MakeBigInt(_res)
}

GO FUNC math/rand.__ptrTo_Rand_Intn from math/rand/rand.go:
func __ptrTo_Rand_Intn(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/rand.Rand)Intn()", args, 1, 1)
	n := ExtractGoInt("(*_math/rand.Rand)Intn()", "n", _argList, 0)
	_res := o.O.(*_rand.Rand).Intn(n)
	return MakeInt(_res)
}

GO FUNC math/rand.__ptrTo_Rand_NormFloat64 from math/rand/normal.go:
// func __ptrTo_Rand_NormFloat64(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC math/rand.__ptrTo_Rand_Perm from math/rand/rand.go:
func __ptrTo_Rand_Perm(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_math/rand.Rand)Perm()", args, 1, 1)
	n := ExtractGoInt("(*_math/rand.Rand)Perm()", "n", _argList, 0)
	_res := o.O.(*_rand.Rand).Perm(n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC math/rand.__ptrTo_Rand_Read from math/rand/rand.go:
// func __ptrTo_Rand_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC math/rand.__ptrTo_Rand_Seed from math/rand/rand.go:
// func __ptrTo_Rand_Seed(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC math/rand.__ptrTo_Rand_Shuffle from math/rand/rand.go:
// func __ptrTo_Rand_Shuffle(o GoObject, args Object) Object {
// (n, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC math/rand.__ptrTo_Rand_Uint32 from math/rand/rand.go:
func __ptrTo_Rand_Uint32(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Rand)Uint32()", args, 0, 0)
	_res := o.O.(*_rand.Rand).Uint32()
	return MakeBigIntU(uint64(_res))
}

GO FUNC math/rand.__ptrTo_Rand_Uint64 from math/rand/rand.go:
func __ptrTo_Rand_Uint64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Rand)Uint64()", args, 0, 0)
	_res := o.O.(*_rand.Rand).Uint64()
	return MakeBigIntU(_res)
}

GO FUNC math/rand.__ptrTo_Zipf_Uint64 from math/rand/zipf.go:
func __ptrTo_Zipf_Uint64(o GoObject, args Object) Object {
	CheckGoArity("(*_math/rand.Zipf)Uint64()", args, 0, 0)
	_res := o.O.(*_rand.Zipf).Uint64()
	return MakeBigIntU(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rand

import (
	. "github.com/candid82/joker/core"
	_rand "math/rand"
	_reflect "reflect"
)
var members_PtrTo_Rand = GoTypeInfo{Members: GoMembers{
	"Int": __ptrTo_Rand_Int,
	"Int31": __ptrTo_Rand_Int31,
	"Int31n": __ptrTo_Rand_Int31n,
	"Int63": __ptrTo_Rand_Int63,
	"Int63n": __ptrTo_Rand_Int63n,
	"Intn": __ptrTo_Rand_Intn,
	"Perm": __ptrTo_Rand_Perm,
	"Uint32": __ptrTo_Rand_Uint32,
	"Uint64": __ptrTo_Rand_Uint64,
}}

var members_PtrTo_Zipf = GoTypeInfo{Members: GoMembers{
	"Uint64": __ptrTo_Zipf_Uint64,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_rand.Rand)(nil))] = &members_PtrTo_Rand
	GoTypes[_reflect.TypeOf((*_rand.Zipf)(nil))] = &members_PtrTo_Zipf
}

GO TYPE mime.WordDecoder from mime/encodedword.go:
func ExtractGoObjectWordDecoder(args []Object, index int) *_mime.WordDecoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mime.WordDecoder:
			return &r
		case *_mime.WordDecoder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime.WordDecoder]"))
}

// func _mapToWordDecoder(o Map) *_mime.WordDecoder {
// 	return &_mime.WordDecoder{}
// }

// func _vectorToWordDecoder(o *Vector) *_mime.WordDecoder {
// 	return &_mime.WordDecoder{
// 		CharsetReader: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructWordDecoder(_v Object) *_mime.WordDecoder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mime.WordDecoder:
// 			return &_g
// 		case *_mime.WordDecoder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToWordDecoder(_o.(Map))
// 	case *Vector:
// 		return _vectorToWordDecoder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mime.WordDecoder] or: Map or Vector"))
// }

GO TYPE mime.WordEncoder from mime/encodedword.go:
func ExtractGoObjectWordEncoder(args []Object, index int) *_mime.WordEncoder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mime.WordEncoder:
			return &r
		case *_mime.WordEncoder:
			return r
		}
	case Int:
		v := _mime.WordEncoder(ExtractByte(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime.WordEncoder]"))
}

func _ConstructWordEncoder(_v Object) _mime.WordEncoder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mime.WordEncoder:
			return _g
		case *_mime.WordEncoder:
			return *_g
		}
	case Number:
		return _mime.WordEncoder(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mime.WordEncoder] or: Number"))
}

GO FUNC mime.ExtensionsByType from mime/type.go:
func __extensionsByType(typ string) Object {
	_res1, _res2 := _mime.ExtensionsByType(typ)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.FormatMediaType from mime/mediatype.go:
// func __formatMediaType(t string, param map[])  {
// 	_res := _mime.FormatMediaType(t, param)
// 	return MakeString(_res)
// }

GO FUNC mime.ParseMediaType from mime/mediatype.go:
// func __parseMediaType(v string) Object {
// 	mediatype, params, err := _mime.ParseMediaType(v)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeString(mediatype))
// 	_res = _res.Conjoin(params)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC mime.__ptrTo_WordDecoder_Decode from mime/encodedword.go:
func __ptrTo_WordDecoder_Decode(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime.WordDecoder)Decode()", args, 1, 1)
	word := ExtractGoString("(*_mime.WordDecoder)Decode()", "word", _argList, 0)
	_res1, _res2 := o.O.(*_mime.WordDecoder).Decode(word)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.__ptrTo_WordDecoder_DecodeHeader from mime/encodedword.go:
func __ptrTo_WordDecoder_DecodeHeader(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime.WordDecoder)DecodeHeader()", args, 1, 1)
	header := ExtractGoString("(*_mime.WordDecoder)DecodeHeader()", "header", _argList, 0)
	_res1, _res2 := o.O.(*_mime.WordDecoder).DecodeHeader(header)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.__wordEncoder_Encode from mime/encodedword.go:
func __wordEncoder_Encode(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_mime.WordEncoder)Encode()", args, 2, 2)
	charset := ExtractGoString("(_mime.WordEncoder)Encode()", "charset", _argList, 0)
	s := ExtractGoString("(_mime.WordEncoder)Encode()", "s", _argList, 1)
	_res := o.O.(_mime.WordEncoder).Encode(charset, s)
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mime

import (
	. "github.com/candid82/joker/core"
	_mime "mime"
	_reflect "reflect"
)
var members_PtrTo_WordDecoder = GoTypeInfo{Members: GoMembers{
	"Decode": __ptrTo_WordDecoder_Decode,
	"DecodeHeader": __ptrTo_WordDecoder_DecodeHeader,
}}

var members_WordEncoder = GoTypeInfo{Members: GoMembers{
	"Encode": __wordEncoder_Encode,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_mime.WordDecoder)(nil))] = &members_PtrTo_WordDecoder
	GoTypes[_reflect.TypeOf((*_mime.WordEncoder)(nil)).Elem()] = &members_WordEncoder
}

GO TYPE mime/multipart.File from mime/multipart/formdata.go:
func ExtractGoObjectFile(args []Object, index int) *_multipart.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.File:
			return &r
		case *_multipart.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.File]"))
}

// func _ConstructFile(_v Object) _multipart.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _multipart.File:
// 			return _g
// 		case *_multipart.File:
// 			return *_g
// 		}
// 	default:
// 		return _multipart.File(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.File] or: whatever"))
// }

GO TYPE mime/multipart.FileHeader from mime/multipart/formdata.go:
func ExtractGoObjectFileHeader(args []Object, index int) *_multipart.FileHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.FileHeader:
			return &r
		case *_multipart.FileHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.FileHeader]"))
}

// func _mapToFileHeader(o Map) *_multipart.FileHeader {
// 	return &_multipart.FileHeader{}
// }

// func _vectorToFileHeader(o *Vector) *_multipart.FileHeader {
// 	return &_multipart.FileHeader{
// 		Filename: AssertString(o.Nth(0), "").S,
// 		Header: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Size: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 	}
// }

// func _ConstructFileHeader(_v Object) *_multipart.FileHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _multipart.FileHeader:
// 			return &_g
// 		case *_multipart.FileHeader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFileHeader(_o.(Map))
// 	case *Vector:
// 		return _vectorToFileHeader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.FileHeader] or: Map or Vector"))
// }

GO TYPE mime/multipart.Form from mime/multipart/formdata.go:
func ExtractGoObjectForm(args []Object, index int) *_multipart.Form {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.Form:
			return &r
		case *_multipart.Form:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.Form]"))
}

// func _mapToForm(o Map) *_multipart.Form {
// 	return &_multipart.Form{}
// }

// func _vectorToForm(o *Vector) *_multipart.Form {
// 	return &_multipart.Form{
// 		Value: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		File: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 	}
// }

// func _ConstructForm(_v Object) *_multipart.Form {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _multipart.Form:
// 			return &_g
// 		case *_multipart.Form:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToForm(_o.(Map))
// 	case *Vector:
// 		return _vectorToForm(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.Form] or: Map or Vector"))
// }

GO TYPE mime/multipart.Part from mime/multipart/multipart.go:
func ExtractGoObjectPart(args []Object, index int) *_multipart.Part {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.Part:
			return &r
		case *_multipart.Part:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.Part]"))
}

// func _mapToPart(o Map) *_multipart.Part {
// 	return &_multipart.Part{}
// }

// func _vectorToPart(o *Vector) *_multipart.Part {
// 	return &_multipart.Part{
// 		Header: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructPart(_v Object) *_multipart.Part {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _multipart.Part:
// 			return &_g
// 		case *_multipart.Part:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPart(_o.(Map))
// 	case *Vector:
// 		return _vectorToPart(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.Part] or: Map or Vector"))
// }

GO TYPE mime/multipart.Reader from mime/multipart/multipart.go:
func ExtractGoObjectReader(args []Object, index int) *_multipart.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.Reader:
			return &r
		case *_multipart.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.Reader]"))
}

func _mapToReader(o Map) *_multipart.Reader {
	return &_multipart.Reader{}
}

func _vectorToReader(o *Vector) *_multipart.Reader {
	return &_multipart.Reader{}
}

func _ConstructReader(_v Object) *_multipart.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _multipart.Reader:
			return &_g
		case *_multipart.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.Reader] or: Map or Vector"))
}

GO TYPE mime/multipart.Writer from mime/multipart/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_multipart.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _multipart.Writer:
			return &r
		case *_multipart.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/multipart.Writer]"))
}

func _mapToWriter(o Map) *_multipart.Writer {
	return &_multipart.Writer{}
}

func _vectorToWriter(o *Vector) *_multipart.Writer {
	return &_multipart.Writer{}
}

func _ConstructWriter(_v Object) *_multipart.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _multipart.Writer:
			return &_g
		case *_multipart.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[multipart.Writer] or: Map or Vector"))
}

GO FUNC mime/multipart.NewReader from mime/multipart/multipart.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader), boundary string) Object {
// 	_res := _multipart.NewReader(r, boundary)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/multipart.NewWriter from mime/multipart/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _multipart.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/multipart.__ptrTo_FileHeader_Open from mime/multipart/formdata.go:
func __ptrTo_FileHeader_Open(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.FileHeader)Open()", args, 0, 0)
	_res1, _res2 := o.O.(*_multipart.FileHeader).Open()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime/multipart.__ptrTo_Form_RemoveAll from mime/multipart/formdata.go:
func __ptrTo_Form_RemoveAll(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Form)RemoveAll()", args, 0, 0)
	_res := o.O.(*_multipart.Form).RemoveAll()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC mime/multipart.__ptrTo_Part_Close from mime/multipart/multipart.go:
func __ptrTo_Part_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Part)Close()", args, 0, 0)
	_res := o.O.(*_multipart.Part).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC mime/multipart.__ptrTo_Part_FileName from mime/multipart/multipart.go:
func __ptrTo_Part_FileName(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Part)FileName()", args, 0, 0)
	_res := o.O.(*_multipart.Part).FileName()
	return MakeString(_res)
}

GO FUNC mime/multipart.__ptrTo_Part_FormName from mime/multipart/multipart.go:
func __ptrTo_Part_FormName(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Part)FormName()", args, 0, 0)
	_res := o.O.(*_multipart.Part).FormName()
	return MakeString(_res)
}

GO FUNC mime/multipart.__ptrTo_Part_Read from mime/multipart/multipart.go:
// func __ptrTo_Part_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(d)))}

GO FUNC mime/multipart.__ptrTo_Reader_NextPart from mime/multipart/multipart.go:
func __ptrTo_Reader_NextPart(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Reader)NextPart()", args, 0, 0)
	_res1, _res2 := o.O.(*_multipart.Reader).NextPart()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime/multipart.__ptrTo_Reader_ReadForm from mime/multipart/formdata.go:
func __ptrTo_Reader_ReadForm(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime/multipart.Reader)ReadForm()", args, 1, 1)
	maxMemory := ExtractGoInt64("(*_mime/multipart.Reader)ReadForm()", "maxMemory", _argList, 0)
	_res1, _res2 := o.O.(*_multipart.Reader).ReadForm(maxMemory)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime/multipart.__ptrTo_Writer_Boundary from mime/multipart/writer.go:
func __ptrTo_Writer_Boundary(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Writer)Boundary()", args, 0, 0)
	_res := o.O.(*_multipart.Writer).Boundary()
	return MakeString(_res)
}

GO FUNC mime/multipart.__ptrTo_Writer_Close from mime/multipart/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Writer)Close()", args, 0, 0)
	_res := o.O.(*_multipart.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC mime/multipart.__ptrTo_Writer_CreateFormField from mime/multipart/writer.go:
func __ptrTo_Writer_CreateFormField(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime/multipart.Writer)CreateFormField()", args, 1, 1)
	fieldname := ExtractGoString("(*_mime/multipart.Writer)CreateFormField()", "fieldname", _argList, 0)
	_res1, _res2 := o.O.(*_multipart.Writer).CreateFormField(fieldname)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime/multipart.__ptrTo_Writer_CreateFormFile from mime/multipart/writer.go:
func __ptrTo_Writer_CreateFormFile(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime/multipart.Writer)CreateFormFile()", args, 2, 2)
	fieldname := ExtractGoString("(*_mime/multipart.Writer)CreateFormFile()", "fieldname", _argList, 0)
	filename := ExtractGoString("(*_mime/multipart.Writer)CreateFormFile()", "filename", _argList, 1)
	_res1, _res2 := o.O.(*_multipart.Writer).CreateFormFile(fieldname, filename)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime/multipart.__ptrTo_Writer_CreatePart from mime/multipart/writer.go:
// func __ptrTo_Writer_CreatePart(o GoObject, args Object) Object {
// header ABEND987(genutils.go: imports not yet supported: textproto.MIMEHeader)}

GO FUNC mime/multipart.__ptrTo_Writer_FormDataContentType from mime/multipart/writer.go:
func __ptrTo_Writer_FormDataContentType(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/multipart.Writer)FormDataContentType()", args, 0, 0)
	_res := o.O.(*_multipart.Writer).FormDataContentType()
	return MakeString(_res)
}

GO FUNC mime/multipart.__ptrTo_Writer_SetBoundary from mime/multipart/writer.go:
func __ptrTo_Writer_SetBoundary(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime/multipart.Writer)SetBoundary()", args, 1, 1)
	boundary := ExtractGoString("(*_mime/multipart.Writer)SetBoundary()", "boundary", _argList, 0)
	_res := o.O.(*_multipart.Writer).SetBoundary(boundary)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC mime/multipart.__ptrTo_Writer_WriteField from mime/multipart/writer.go:
func __ptrTo_Writer_WriteField(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_mime/multipart.Writer)WriteField()", args, 2, 2)
	fieldname := ExtractGoString("(*_mime/multipart.Writer)WriteField()", "fieldname", _argList, 0)
	value := ExtractGoString("(*_mime/multipart.Writer)WriteField()", "value", _argList, 1)
	_res := o.O.(*_multipart.Writer).WriteField(fieldname, value)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package multipart

import (
	. "github.com/candid82/joker/core"
	_multipart "mime/multipart"
	_reflect "reflect"
)
var members_PtrTo_FileHeader = GoTypeInfo{Members: GoMembers{
	"Open": __ptrTo_FileHeader_Open,
}}

var members_PtrTo_Form = GoTypeInfo{Members: GoMembers{
	"RemoveAll": __ptrTo_Form_RemoveAll,
}}

var members_PtrTo_Part = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Part_Close,
	"FileName": __ptrTo_Part_FileName,
	"FormName": __ptrTo_Part_FormName,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"NextPart": __ptrTo_Reader_NextPart,
	"ReadForm": __ptrTo_Reader_ReadForm,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Boundary": __ptrTo_Writer_Boundary,
	"Close": __ptrTo_Writer_Close,
	"CreateFormField": __ptrTo_Writer_CreateFormField,
	"CreateFormFile": __ptrTo_Writer_CreateFormFile,
	"FormDataContentType": __ptrTo_Writer_FormDataContentType,
	"SetBoundary": __ptrTo_Writer_SetBoundary,
	"WriteField": __ptrTo_Writer_WriteField,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_multipart.FileHeader)(nil))] = &members_PtrTo_FileHeader
	GoTypes[_reflect.TypeOf((*_multipart.Form)(nil))] = &members_PtrTo_Form
	GoTypes[_reflect.TypeOf((*_multipart.Part)(nil))] = &members_PtrTo_Part
	GoTypes[_reflect.TypeOf((*_multipart.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_multipart.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE mime/quotedprintable.Reader from mime/quotedprintable/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_quotedprintable.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quotedprintable.Reader:
			return &r
		case *_quotedprintable.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/quotedprintable.Reader]"))
}

func _mapToReader(o Map) *_quotedprintable.Reader {
	return &_quotedprintable.Reader{}
}

func _vectorToReader(o *Vector) *_quotedprintable.Reader {
	return &_quotedprintable.Reader{}
}

func _ConstructReader(_v Object) *_quotedprintable.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _quotedprintable.Reader:
			return &_g
		case *_quotedprintable.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[quotedprintable.Reader] or: Map or Vector"))
}

GO TYPE mime/quotedprintable.Writer from mime/quotedprintable/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_quotedprintable.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quotedprintable.Writer:
			return &r
		case *_quotedprintable.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[mime/quotedprintable.Writer]"))
}

func _mapToWriter(o Map) *_quotedprintable.Writer {
	return &_quotedprintable.Writer{}
}

func _vectorToWriter(o *Vector) *_quotedprintable.Writer {
	return &_quotedprintable.Writer{
		Binary: ToBool(o.Nth(0)),
	}
}

func _ConstructWriter(_v Object) *_quotedprintable.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _quotedprintable.Writer:
			return &_g
		case *_quotedprintable.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[quotedprintable.Writer] or: Map or Vector"))
}

GO FUNC mime/quotedprintable.NewReader from mime/quotedprintable/reader.go:
// func __newReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _quotedprintable.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.NewWriter from mime/quotedprintable/writer.go:
// func __newWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _quotedprintable.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC mime/quotedprintable.__ptrTo_Reader_Read from mime/quotedprintable/reader.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC mime/quotedprintable.__ptrTo_Writer_Close from mime/quotedprintable/writer.go:
func __ptrTo_Writer_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_mime/quotedprintable.Writer)Close()", args, 0, 0)
	_res := o.O.(*_quotedprintable.Writer).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC mime/quotedprintable.__ptrTo_Writer_Write from mime/quotedprintable/writer.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package quotedprintable

import (
	. "github.com/candid82/joker/core"
	_quotedprintable "mime/quotedprintable"
	_reflect "reflect"
)
var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Writer_Close,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_quotedprintable.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE net.Addr from net/net.go:
func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

// func _ConstructAddr(_v Object) _net.Addr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Addr:
// 			return _g
// 		case *_net.Addr:
// 			return *_g
// 		}
// 	default:
// 		return _net.Addr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Addr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Addr] or: whatever"))
// }

GO TYPE net.AddrError from net/net.go:
func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{}
}

func _vectorToAddrError(o *Vector) *_net.AddrError {
	return &_net.AddrError{
		Err: AssertString(o.Nth(0), "").S,
		Addr: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.AddrError:
			return &_g
		case *_net.AddrError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	case *Vector:
		return _vectorToAddrError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map or Vector"))
}

GO TYPE net.Buffers from net/net.go:
func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _ConstructBuffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Buffers:
// 			return _g
// 		case *_net.Buffers:
// 			return *_g
// 		}
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

GO TYPE net.Conn from net/net.go:
func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

// func _ConstructConn(_v Object) _net.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Conn:
// 			return _g
// 		case *_net.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _net.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Conn] or: whatever"))
// }

GO TYPE net.DNSConfigError from net/net.go:
func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{}
}

func _vectorToDNSConfigError(o *Vector) *_net.DNSConfigError {
	return &_net.DNSConfigError{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructDNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSConfigError:
			return &_g
		case *_net.DNSConfigError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	case *Vector:
		return _vectorToDNSConfigError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map or Vector"))
}

GO TYPE net.DNSError from net/net.go:
func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{}
}

func _vectorToDNSError(o *Vector) *_net.DNSError {
	return &_net.DNSError{
		Err: AssertString(o.Nth(0), "").S,
		Name: AssertString(o.Nth(1), "").S,
		Server: AssertString(o.Nth(2), "").S,
		IsTimeout: ToBool(o.Nth(3)),
		IsTemporary: ToBool(o.Nth(4)),
	}
}

func _ConstructDNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSError:
			return &_g
		case *_net.DNSError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	case *Vector:
		return _vectorToDNSError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map or Vector"))
}

GO TYPE net.Dialer from net/dial.go:
func ExtractGoObjectDialer(args []Object, index int) *_net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Dialer:
			return &r
		case *_net.Dialer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

// func _mapToDialer(o Map) *_net.Dialer {
// 	return &_net.Dialer{}
// }

// func _vectorToDialer(o *Vector) *_net.Dialer {
// 	return &_net.Dialer{
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Deadline: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		LocalAddr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		DualStack: ToBool(o.Nth(3)),
// 		FallbackDelay: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeepAlive: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Resolver: ABEND048(codegen.go: no conversion from Clojure for *net.Resolver (net.Resolver)),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructDialer(_v Object) *_net.Dialer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Dialer:
// 			return &_g
// 		case *_net.Dialer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDialer(_o.(Map))
// 	case *Vector:
// 		return _vectorToDialer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or: Map or Vector"))
// }

GO TYPE net.Error from net/net.go:
func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

// func _ConstructError(_v Object) _net.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Error:
// 			return _g
// 		case *_net.Error:
// 			return *_g
// 		}
// 	default:
// 		return _net.Error(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Error] or: whatever"))
// }

GO TYPE net.Flags from net/interface.go:
func ExtractGoObjectFlags(args []Object, index int) *_net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Flags:
			return &r
		case *_net.Flags:
			return r
		}
	case Number:
		v := _net.Flags(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _ConstructFlags(_v Object) _net.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Flags:
			return _g
		case *_net.Flags:
			return *_g
		}
	case Number:
		return _net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or: Number"))
}

GO TYPE net.HardwareAddr from net/mac.go:
func ExtractGoObjectHardwareAddr(args []Object, index int) *_net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.HardwareAddr:
			return &r
		case *_net.HardwareAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _ConstructHardwareAddr(_v Object) _net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.HardwareAddr:
// 			return _g
// 		case *_net.HardwareAddr:
// 			return *_g
// 		}
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or: whatever"))
// }

GO TYPE net.IP from net/ip.go:
func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _ConstructIP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IP:
// 			return _g
// 		case *_net.IP:
// 			return *_g
// 		}
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

GO TYPE net.IPAddr from net/iprawsock.go:
func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *_net.IPAddr {
// 	return &_net.IPAddr{}
// }

// func _vectorToIPAddr(o *Vector) *_net.IPAddr {
// 	return &_net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructIPAddr(_v Object) *_net.IPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPAddr:
// 			return &_g
// 		case *_net.IPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map or Vector"))
// }

GO TYPE net.IPConn from net/iprawsock.go:
func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{}
}

func _vectorToIPConn(o *Vector) *_net.IPConn {
	return &_net.IPConn{}
}

func _ConstructIPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPConn:
			return &_g
		case *_net.IPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	case *Vector:
		return _vectorToIPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map or Vector"))
}

GO TYPE net.IPMask from net/ip.go:
func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _ConstructIPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPMask:
// 			return _g
// 		case *_net.IPMask:
// 			return *_g
// 		}
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

GO TYPE net.IPNet from net/ip.go:
func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *_net.IPNet {
// 	return &_net.IPNet{}
// }

// func _vectorToIPNet(o *Vector) *_net.IPNet {
// 	return &_net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _ConstructIPNet(_v Object) *_net.IPNet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPNet:
// 			return &_g
// 		case *_net.IPNet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPNet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map or Vector"))
// }

GO TYPE net.Interface from net/interface.go:
func ExtractGoObjectInterface(args []Object, index int) *_net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Interface:
			return &r
		case *_net.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

// func _mapToInterface(o Map) *_net.Interface {
// 	return &_net.Interface{}
// }

// func _vectorToInterface(o *Vector) *_net.Interface {
// 	return &_net.Interface{
// 		Index: AssertInt(o.Nth(0), "").I,
// 		MTU: AssertInt(o.Nth(1), "").I,
// 		Name: AssertString(o.Nth(2), "").S,
// 		HardwareAddr: ABEND048(codegen.go: no conversion from Clojure for net.HardwareAddr ([]byte)),
// 		Flags: _net.Flags(uint(AssertInt(o.Nth(4), "").I)),
// 	}
// }

// func _ConstructInterface(_v Object) *_net.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Interface:
// 			return &_g
// 		case *_net.Interface:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterface(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterface(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or: Map or Vector"))
// }

GO TYPE net.InvalidAddrError from net/net.go:
func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _ConstructInvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.InvalidAddrError:
			return _g
		case *_net.InvalidAddrError:
			return *_g
		}
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

GO TYPE net.ListenConfig from net/dial.go:
func ExtractGoObjectListenConfig(args []Object, index int) *_net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ListenConfig:
			return &r
		case *_net.ListenConfig:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

// func _mapToListenConfig(o Map) *_net.ListenConfig {
// 	return &_net.ListenConfig{}
// }

// func _vectorToListenConfig(o *Vector) *_net.ListenConfig {
// 	return &_net.ListenConfig{
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructListenConfig(_v Object) *_net.ListenConfig {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.ListenConfig:
// 			return &_g
// 		case *_net.ListenConfig:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToListenConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToListenConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or: Map or Vector"))
// }

GO TYPE net.Listener from net/net.go:
func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

// func _ConstructListener(_v Object) _net.Listener {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Listener:
// 			return _g
// 		case *_net.Listener:
// 			return *_g
// 		}
// 	default:
// 		return _net.Listener(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Listener))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Listener] or: whatever"))
// }

GO TYPE net.MX from net/dnsclient.go:
func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{}
}

func _vectorToMX(o *Vector) *_net.MX {
	return &_net.MX{
		Host: AssertString(o.Nth(0), "").S,
		Pref: uint16(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructMX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.MX:
			return &_g
		case *_net.MX:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	case *Vector:
		return _vectorToMX(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map or Vector"))
}

GO TYPE net.NS from net/dnsclient.go:
func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{}
}

func _vectorToNS(o *Vector) *_net.NS {
	return &_net.NS{
		Host: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructNS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.NS:
			return &_g
		case *_net.NS:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	case *Vector:
		return _vectorToNS(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map or Vector"))
}

GO TYPE net.OpError from net/net.go:
func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *_net.OpError {
// 	return &_net.OpError{}
// }

// func _vectorToOpError(o *Vector) *_net.OpError {
// 	return &_net.OpError{
// 		Op: AssertString(o.Nth(0), "").S,
// 		Net: AssertString(o.Nth(1), "").S,
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Err: _errors.New(AssertString(o.Nth(4), "").S),
// 	}
// }

// func _ConstructOpError(_v Object) *_net.OpError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.OpError:
// 			return &_g
// 		case *_net.OpError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	case *Vector:
// 		return _vectorToOpError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map or Vector"))
// }

GO TYPE net.PacketConn from net/net.go:
func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

// func _ConstructPacketConn(_v Object) _net.PacketConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.PacketConn:
// 			return _g
// 		case *_net.PacketConn:
// 			return *_g
// 		}
// 	default:
// 		return _net.PacketConn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PacketConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.PacketConn] or: whatever"))
// }

GO TYPE net.ParseError from net/net.go:
func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{}
}

func _vectorToParseError(o *Vector) *_net.ParseError {
	return &_net.ParseError{
		Type: AssertString(o.Nth(0), "").S,
		Text: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ParseError:
			return &_g
		case *_net.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map or Vector"))
}

GO TYPE net.Resolver from net/lookup.go:
func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *_net.Resolver {
// 	return &_net.Resolver{}
// }

// func _vectorToResolver(o *Vector) *_net.Resolver {
// 	return &_net.Resolver{
// 		PreferGo: ToBool(o.Nth(0)),
// 		StrictErrors: ToBool(o.Nth(1)),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructResolver(_v Object) *_net.Resolver {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Resolver:
// 			return &_g
// 		case *_net.Resolver:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	case *Vector:
// 		return _vectorToResolver(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map or Vector"))
// }

GO TYPE net.SRV from net/dnsclient.go:
func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{}
}

func _vectorToSRV(o *Vector) *_net.SRV {
	return &_net.SRV{
		Target: AssertString(o.Nth(0), "").S,
		Port: uint16(AssertInt(o.Nth(1), "").I),
		Priority: uint16(AssertInt(o.Nth(2), "").I),
		Weight: uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructSRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.SRV:
			return &_g
		case *_net.SRV:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	case *Vector:
		return _vectorToSRV(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map or Vector"))
}

GO TYPE net.TCPAddr from net/tcpsock.go:
func ExtractGoObjectTCPAddr(args []Object, index int) *_net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPAddr:
			return &r
		case *_net.TCPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

// func _mapToTCPAddr(o Map) *_net.TCPAddr {
// 	return &_net.TCPAddr{}
// }

// func _vectorToTCPAddr(o *Vector) *_net.TCPAddr {
// 	return &_net.TCPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructTCPAddr(_v Object) *_net.TCPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.TCPAddr:
// 			return &_g
// 		case *_net.TCPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTCPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToTCPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or: Map or Vector"))
// }

GO TYPE net.TCPConn from net/tcpsock.go:
func ExtractGoObjectTCPConn(args []Object, index int) *_net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPConn:
			return &r
		case *_net.TCPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _vectorToTCPConn(o *Vector) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _ConstructTCPConn(_v Object) *_net.TCPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPConn:
			return &_g
		case *_net.TCPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	case *Vector:
		return _vectorToTCPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or: Map or Vector"))
}

GO TYPE net.TCPListener from net/tcpsock.go:
func ExtractGoObjectTCPListener(args []Object, index int) *_net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPListener:
			return &r
		case *_net.TCPListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _vectorToTCPListener(o *Vector) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _ConstructTCPListener(_v Object) *_net.TCPListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPListener:
			return &_g
		case *_net.TCPListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	case *Vector:
		return _vectorToTCPListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or: Map or Vector"))
}

GO TYPE net.UDPAddr from net/udpsock.go:
func ExtractGoObjectUDPAddr(args []Object, index int) *_net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPAddr:
			return &r
		case *_net.UDPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

// func _mapToUDPAddr(o Map) *_net.UDPAddr {
// 	return &_net.UDPAddr{}
// }

// func _vectorToUDPAddr(o *Vector) *_net.UDPAddr {
// 	return &_net.UDPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructUDPAddr(_v Object) *_net.UDPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.UDPAddr:
// 			return &_g
// 		case *_net.UDPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUDPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToUDPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or: Map or Vector"))
// }

GO TYPE net.UDPConn from net/udpsock.go:
func ExtractGoObjectUDPConn(args []Object, index int) *_net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPConn:
			return &r
		case *_net.UDPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _vectorToUDPConn(o *Vector) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _ConstructUDPConn(_v Object) *_net.UDPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPConn:
			return &_g
		case *_net.UDPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	case *Vector:
		return _vectorToUDPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or: Map or Vector"))
}

GO TYPE net.UnixAddr from net/unixsock.go:
func ExtractGoObjectUnixAddr(args []Object, index int) *_net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixAddr:
			return &r
		case *_net.UnixAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *_net.UnixAddr {
	return &_net.UnixAddr{}
}

func _vectorToUnixAddr(o *Vector) *_net.UnixAddr {
	return &_net.UnixAddr{
		Name: AssertString(o.Nth(0), "").S,
		Net: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructUnixAddr(_v Object) *_net.UnixAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixAddr:
			return &_g
		case *_net.UnixAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	case *Vector:
		return _vectorToUnixAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or: Map or Vector"))
}

GO TYPE net.UnixConn from net/unixsock.go:
func ExtractGoObjectUnixConn(args []Object, index int) *_net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixConn:
			return &r
		case *_net.UnixConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _vectorToUnixConn(o *Vector) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _ConstructUnixConn(_v Object) *_net.UnixConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixConn:
			return &_g
		case *_net.UnixConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	case *Vector:
		return _vectorToUnixConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or: Map or Vector"))
}

GO TYPE net.UnixListener from net/unixsock.go:
func ExtractGoObjectUnixListener(args []Object, index int) *_net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixListener:
			return &r
		case *_net.UnixListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _vectorToUnixListener(o *Vector) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _ConstructUnixListener(_v Object) *_net.UnixListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixListener:
			return &_g
		case *_net.UnixListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	case *Vector:
		return _vectorToUnixListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or: Map or Vector"))
}

GO TYPE net.UnknownNetworkError from net/net.go:
func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _ConstructUnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnknownNetworkError:
			return _g
		case *_net.UnknownNetworkError:
			return *_g
		}
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

GO FUNC net.CIDRMask from net/ip.go:
func __cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _net.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
func __dialIP(network string, laddr *_net.IPAddr, raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTCP from net/tcpsock.go:
func __dialTCP(network string, laddr *_net.TCPAddr, raddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.DialTCP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTimeout from net/dial.go:
// func __dialTimeout(network string, address string, timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
func __dialUDP(network string, laddr *_net.UDPAddr, raddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.DialUDP(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialUnix from net/unixsock.go:
func __dialUnix(network string, laddr *_net.UnixAddr, raddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.DialUnix(network, laddr, raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.FileConn from net/file.go:
// func __fileConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func __fileListener(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func __filePacketConn(f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func __iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func __iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func __interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func __interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func __interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func __interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func __listen(network string, address string) Object {
	_res1, _res2 := _net.Listen(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
func __listenIP(network string, laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
func __listenMulticastUDP(network string, ifi *_net.Interface, gaddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenPacket from net/dial.go:
func __listenPacket(network string, address string) Object {
	_res1, _res2 := _net.ListenPacket(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
func __listenTCP(network string, laddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.ListenTCP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUDP from net/udpsock.go:
func __listenUDP(network string, laddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenUDP(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnix from net/unixsock.go:
func __listenUnix(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnix(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnixgram from net/unixsock.go:
func __listenUnixgram(network string, laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnixgram(network, laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func __lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func __lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func __lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func __lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func __lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func __lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func __lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func __lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func __lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func __parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func __parseIP(s string) Object {
	_res := _net.ParseIP(s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func __parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func __pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func __resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func __resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func __resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func __resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func __splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.__flags_String from net/interface.go:
func __flags_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.Flags)String()", args, 0, 0)
	_res := o.O.(_net.Flags).String()
	return MakeString(_res)
}

GO FUNC net.__hardwareAddr_String from net/mac.go:
func __hardwareAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.HardwareAddr)String()", args, 0, 0)
	_res := o.O.(_net.HardwareAddr).String()
	return MakeString(_res)
}

GO FUNC net.__iPMask_Size from net/ip.go:
func __iPMask_Size(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(_net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

GO FUNC net.__iPMask_String from net/ip.go:
func __iPMask_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)String()", args, 0, 0)
	_res := o.O.(_net.IPMask).String()
	return MakeString(_res)
}

GO FUNC net.__iP_DefaultMask from net/ip.go:
func __iP_DefaultMask(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(_net.IP).DefaultMask()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_Equal from net/ip.go:
func __iP_Equal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Equal()", args, 1, 1)
	x := ExtractGo_go_std_net__IP("(_net.IP)Equal()", "x", _argList, 0)
	_res := o.O.(_net.IP).Equal(x)
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsGlobalUnicast from net/ip.go:
func __iP_IsGlobalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsInterfaceLocalMulticast from net/ip.go:
func __iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalMulticast from net/ip.go:
func __iP_IsLinkLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalUnicast from net/ip.go:
func __iP_IsLinkLocalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLoopback from net/ip.go:
func __iP_IsLoopback(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(_net.IP).IsLoopback()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsMulticast from net/ip.go:
func __iP_IsMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsUnspecified from net/ip.go:
func __iP_IsUnspecified(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(_net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_MarshalText from net/ip.go:
func __iP_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(_net.IP).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__iP_Mask from net/ip.go:
func __iP_Mask(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Mask()", args, 1, 1)
	mask := ExtractGo_go_std_net__IPMask("(_net.IP)Mask()", "mask", _argList, 0)
	_res := o.O.(_net.IP).Mask(mask)
	return MakeGoObject(_res)
}

GO FUNC net.__iP_String from net/ip.go:
func __iP_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)String()", args, 0, 0)
	_res := o.O.(_net.IP).String()
	return MakeString(_res)
}

GO FUNC net.__iP_To16 from net/ip.go:
func __iP_To16(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To16()", args, 0, 0)
	_res := o.O.(_net.IP).To16()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_To4 from net/ip.go:
func __iP_To4(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To4()", args, 0, 0)
	_res := o.O.(_net.IP).To4()
	return MakeGoObject(_res)
}

GO FUNC net.__invalidAddrError_Error from net/net.go:
func __invalidAddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__invalidAddrError_Temporary from net/net.go:
func __invalidAddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__invalidAddrError_Timeout from net/net.go:
func __invalidAddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_AddrError_Error from net/net.go:
func __ptrTo_AddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_AddrError_Temporary from net/net.go:
func __ptrTo_AddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_AddrError_Timeout from net/net.go:
func __ptrTo_AddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_Buffers_Read from net/net.go:
// func __ptrTo_Buffers_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC net.__ptrTo_Buffers_WriteTo from net/net.go:
// func __ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net.__ptrTo_DNSConfigError_Error from net/net.go:
func __ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Temporary from net/net.go:
func __ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Timeout from net/net.go:
func __ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Error from net/net.go:
func __ptrTo_DNSError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSError_Temporary from net/net.go:
func __ptrTo_DNSError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Timeout from net/net.go:
func __ptrTo_DNSError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_Dialer_Dial from net/dial.go:
func __ptrTo_Dialer_Dial(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.Dialer)Dial()", args, 2, 2)
	network := ExtractGoString("(*_net.Dialer)Dial()", "network", _argList, 0)
	address := ExtractGoString("(*_net.Dialer)Dial()", "address", _argList, 1)
	_res1, _res2 := o.O.(*_net.Dialer).Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_Dialer_DialContext from net/dial.go:
// func __ptrTo_Dialer_DialContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), network string, address string}

GO FUNC net.__ptrTo_IPAddr_Network from net/iprawsock.go:
func __ptrTo_IPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPAddr_String from net/iprawsock.go:
func __ptrTo_IPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPConn_ReadFrom from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_IPConn_ReadFromIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_IPConn_ReadMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)))}

GO FUNC net.__ptrTo_IPConn_SyscallConn from net/iprawsock.go:
func __ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.IPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_IPConn_WriteMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), addr)}

GO FUNC net.__ptrTo_IPConn_WriteTo from net/iprawsock.go:
// func __ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), *addr)}

GO FUNC net.__ptrTo_IPConn_WriteToIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), addr)}

GO FUNC net.__ptrTo_IPNet_Contains from net/ip.go:
func __ptrTo_IPNet_Contains(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.IPNet)Contains()", args, 1, 1)
	ip := ExtractGo_go_std_net__IP("(*_net.IPNet)Contains()", "ip", _argList, 0)
	_res := o.O.(*_net.IPNet).Contains(ip)
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_IPNet_Network from net/ip.go:
func __ptrTo_IPNet_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*_net.IPNet).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPNet_String from net/ip.go:
func __ptrTo_IPNet_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)String()", args, 0, 0)
	_res := o.O.(*_net.IPNet).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IP_UnmarshalText from net/ip.go:
// func __ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC net.__ptrTo_Interface_Addrs from net/interface.go:
func __ptrTo_Interface_Addrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)Addrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).Addrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_Interface_MulticastAddrs from net/interface.go:
func __ptrTo_Interface_MulticastAddrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)MulticastAddrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).MulticastAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_ListenConfig_Listen from net/dial.go:
// func __ptrTo_ListenConfig_Listen(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), network string, address string}

GO FUNC net.__ptrTo_ListenConfig_ListenPacket from net/dial.go:
// func __ptrTo_ListenConfig_ListenPacket(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), network string, address string}

GO FUNC net.__ptrTo_OpError_Error from net/net.go:
func __ptrTo_OpError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Error()", args, 0, 0)
	_res := o.O.(*_net.OpError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_OpError_Temporary from net/net.go:
func __ptrTo_OpError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.OpError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_OpError_Timeout from net/net.go:
func __ptrTo_OpError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.OpError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_ParseError_Error from net/net.go:
func __ptrTo_ParseError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_net.ParseError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_Resolver_LookupAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), addr string}

GO FUNC net.__ptrTo_Resolver_LookupCNAME from net/lookup.go:
// func __ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), host string}

GO FUNC net.__ptrTo_Resolver_LookupHost from net/lookup.go:
// func __ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), host string}

GO FUNC net.__ptrTo_Resolver_LookupIPAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), host string}

GO FUNC net.__ptrTo_Resolver_LookupMX from net/lookup.go:
// func __ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), name string}

GO FUNC net.__ptrTo_Resolver_LookupNS from net/lookup.go:
// func __ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), name string}

GO FUNC net.__ptrTo_Resolver_LookupPort from net/lookup.go:
// func __ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), network string, service string}

GO FUNC net.__ptrTo_Resolver_LookupSRV from net/lookup.go:
// func __ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), service string, proto string, name string}

GO FUNC net.__ptrTo_Resolver_LookupTXT from net/lookup.go:
// func __ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context), name string}

GO FUNC net.__ptrTo_TCPAddr_Network from net/tcpsock.go:
func __ptrTo_TCPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_TCPAddr_String from net/tcpsock.go:
func __ptrTo_TCPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_TCPConn_CloseRead from net/tcpsock.go:
func __ptrTo_TCPConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_CloseWrite from net/tcpsock.go:
func __ptrTo_TCPConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_ReadFrom from net/tcpsock.go:
// func __ptrTo_TCPConn_ReadFrom(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC net.__ptrTo_TCPConn_SetKeepAlive from net/tcpsock.go:
func __ptrTo_TCPConn_SetKeepAlive(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetKeepAlive()", args, 1, 1)
	keepalive := ExtractGoBoolean("(*_net.TCPConn)SetKeepAlive()", "keepalive", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetKeepAlive(keepalive)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SetKeepAlivePeriod from net/tcpsock.go:
// func __ptrTo_TCPConn_SetKeepAlivePeriod(o GoObject, args Object) Object {
// d ABEND987(genutils.go: imports not yet supported: time.Duration)}

GO FUNC net.__ptrTo_TCPConn_SetLinger from net/tcpsock.go:
func __ptrTo_TCPConn_SetLinger(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetLinger()", args, 1, 1)
	sec := ExtractGoInt("(*_net.TCPConn)SetLinger()", "sec", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetLinger(sec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SetNoDelay from net/tcpsock.go:
func __ptrTo_TCPConn_SetNoDelay(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetNoDelay()", args, 1, 1)
	noDelay := ExtractGoBoolean("(*_net.TCPConn)SetNoDelay()", "noDelay", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetNoDelay(noDelay)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SyscallConn from net/tcpsock.go:
func __ptrTo_TCPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_Accept from net/tcpsock.go:
func __ptrTo_TCPListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_AcceptTCP from net/tcpsock.go:
func __ptrTo_TCPListener_AcceptTCP(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)AcceptTCP()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).AcceptTCP()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_Addr from net/tcpsock.go:
func __ptrTo_TCPListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__ptrTo_TCPListener_Close from net/tcpsock.go:
func __ptrTo_TCPListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Close()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPListener_File from net/tcpsock.go:
func __ptrTo_TCPListener_File(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)File()", args, 0, 0)
	f, err := o.O.(*_net.TCPListener).File()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_SetDeadline from net/tcpsock.go:
// func __ptrTo_TCPListener_SetDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__ptrTo_TCPListener_SyscallConn from net/tcpsock.go:
func __ptrTo_TCPListener_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UDPAddr_Network from net/udpsock.go:
func __ptrTo_UDPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UDPAddr_String from net/udpsock.go:
func __ptrTo_UDPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UDPConn_ReadFrom from net/udpsock.go:
// func __ptrTo_UDPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_UDPConn_ReadFromUDP from net/udpsock.go:
// func __ptrTo_UDPConn_ReadFromUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_UDPConn_ReadMsgUDP from net/udpsock.go:
// func __ptrTo_UDPConn_ReadMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)))}

GO FUNC net.__ptrTo_UDPConn_SyscallConn from net/udpsock.go:
func __ptrTo_UDPConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UDPConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UDPConn_WriteMsgUDP from net/udpsock.go:
// func __ptrTo_UDPConn_WriteMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), addr)}

GO FUNC net.__ptrTo_UDPConn_WriteTo from net/udpsock.go:
// func __ptrTo_UDPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), *addr)}

GO FUNC net.__ptrTo_UDPConn_WriteToUDP from net/udpsock.go:
// func __ptrTo_UDPConn_WriteToUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), addr)}

GO FUNC net.__ptrTo_UnixAddr_Network from net/unixsock.go:
func __ptrTo_UnixAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UnixAddr_String from net/unixsock.go:
func __ptrTo_UnixAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UnixConn_CloseRead from net/unixsock.go:
func __ptrTo_UnixConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixConn_CloseWrite from net/unixsock.go:
func __ptrTo_UnixConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixConn_ReadFrom from net/unixsock.go:
// func __ptrTo_UnixConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_UnixConn_ReadFromUnix from net/unixsock.go:
// func __ptrTo_UnixConn_ReadFromUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC net.__ptrTo_UnixConn_ReadMsgUnix from net/unixsock.go:
// func __ptrTo_UnixConn_ReadMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)))}

GO FUNC net.__ptrTo_UnixConn_SyscallConn from net/unixsock.go:
func __ptrTo_UnixConn_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixConn).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixConn_WriteMsgUnix from net/unixsock.go:
// func __ptrTo_UnixConn_WriteMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(oob)), addr)}

GO FUNC net.__ptrTo_UnixConn_WriteTo from net/unixsock.go:
// func __ptrTo_UnixConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), *addr)}

GO FUNC net.__ptrTo_UnixConn_WriteToUnix from net/unixsock.go:
// func __ptrTo_UnixConn_WriteToUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), addr)}

GO FUNC net.__ptrTo_UnixListener_Accept from net/unixsock.go:
func __ptrTo_UnixListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixListener_AcceptUnix from net/unixsock.go:
func __ptrTo_UnixListener_AcceptUnix(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)AcceptUnix()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).AcceptUnix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixListener_Addr from net/unixsock.go:
func __ptrTo_UnixListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__ptrTo_UnixListener_Close from net/unixsock.go:
func __ptrTo_UnixListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Close()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixListener_File from net/unixsock.go:
func __ptrTo_UnixListener_File(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)File()", args, 0, 0)
	f, err := o.O.(*_net.UnixListener).File()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(f))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixListener_SetDeadline from net/unixsock.go:
// func __ptrTo_UnixListener_SetDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__ptrTo_UnixListener_SetUnlinkOnClose from net/unixsock_posix.go:
// func __ptrTo_UnixListener_SetUnlinkOnClose(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net.__ptrTo_UnixListener_SyscallConn from net/unixsock.go:
func __ptrTo_UnixListener_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__unknownNetworkError_Error from net/net.go:
func __unknownNetworkError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Error()
	return MakeString(_res)
}

GO FUNC net.__unknownNetworkError_Temporary from net/net.go:
func __unknownNetworkError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__unknownNetworkError_Timeout from net/net.go:
func __unknownNetworkError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package net

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_net "net"
	_reflect "reflect"
)
var members_PtrTo_AddrError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_AddrError_Error,
	"Temporary": __ptrTo_AddrError_Temporary,
	"Timeout": __ptrTo_AddrError_Timeout,
}}

var members_PtrTo_DNSConfigError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_DNSConfigError_Error,
	"Temporary": __ptrTo_DNSConfigError_Temporary,
	"Timeout": __ptrTo_DNSConfigError_Timeout,
}}

var members_PtrTo_DNSError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_DNSError_Error,
	"Temporary": __ptrTo_DNSError_Temporary,
	"Timeout": __ptrTo_DNSError_Timeout,
}}

var members_PtrTo_Dialer = GoTypeInfo{Members: GoMembers{
	"Dial": __ptrTo_Dialer_Dial,
}}

var members_Flags = GoTypeInfo{Members: GoMembers{
	"String": __flags_String,
}}

var members_HardwareAddr = GoTypeInfo{Members: GoMembers{
	"String": __hardwareAddr_String,
}}

var members_IP = GoTypeInfo{Members: GoMembers{
	"DefaultMask": __iP_DefaultMask,
	"Equal": __iP_Equal,
	"IsGlobalUnicast": __iP_IsGlobalUnicast,
	"IsInterfaceLocalMulticast": __iP_IsInterfaceLocalMulticast,
	"IsLinkLocalMulticast": __iP_IsLinkLocalMulticast,
	"IsLinkLocalUnicast": __iP_IsLinkLocalUnicast,
	"IsLoopback": __iP_IsLoopback,
	"IsMulticast": __iP_IsMulticast,
	"IsUnspecified": __iP_IsUnspecified,
	"MarshalText": __iP_MarshalText,
	"Mask": __iP_Mask,
	"String": __iP_String,
	"To16": __iP_To16,
	"To4": __iP_To4,
}}

var members_PtrTo_IPAddr = GoTypeInfo{Members: GoMembers{
	"Network": __ptrTo_IPAddr_Network,
	"String": __ptrTo_IPAddr_String,
}}

var members_PtrTo_IPConn = GoTypeInfo{Members: GoMembers{
	"SyscallConn": __ptrTo_IPConn_SyscallConn,
}}

var members_IPMask = GoTypeInfo{Members: GoMembers{
	"Size": __iPMask_Size,
	"String": __iPMask_String,
}}

var members_PtrTo_IPNet = GoTypeInfo{Members: GoMembers{
	"Contains": __ptrTo_IPNet_Contains,
	"Network": __ptrTo_IPNet_Network,
	"String": __ptrTo_IPNet_String,
}}

var members_PtrTo_Interface = GoTypeInfo{Members: GoMembers{
	"Addrs": __ptrTo_Interface_Addrs,
	"MulticastAddrs": __ptrTo_Interface_MulticastAddrs,
}}

var members_InvalidAddrError = GoTypeInfo{Members: GoMembers{
	"Error": __invalidAddrError_Error,
	"Temporary": __invalidAddrError_Temporary,
	"Timeout": __invalidAddrError_Timeout,
}}

var members_PtrTo_OpError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_OpError_Error,
	"Temporary": __ptrTo_OpError_Temporary,
	"Timeout": __ptrTo_OpError_Timeout,
}}

var members_PtrTo_ParseError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ParseError_Error,
}}

var members_PtrTo_TCPAddr = GoTypeInfo{Members: GoMembers{
	"Network": __ptrTo_TCPAddr_Network,
	"String": __ptrTo_TCPAddr_String,
}}

var members_PtrTo_TCPConn = GoTypeInfo{Members: GoMembers{
	"CloseRead": __ptrTo_TCPConn_CloseRead,
	"CloseWrite": __ptrTo_TCPConn_CloseWrite,
	"SetKeepAlive": __ptrTo_TCPConn_SetKeepAlive,
	"SetLinger": __ptrTo_TCPConn_SetLinger,
	"SetNoDelay": __ptrTo_TCPConn_SetNoDelay,
	"SyscallConn": __ptrTo_TCPConn_SyscallConn,
}}

var members_PtrTo_TCPListener = GoTypeInfo{Members: GoMembers{
	"Accept": __ptrTo_TCPListener_Accept,
	"AcceptTCP": __ptrTo_TCPListener_AcceptTCP,
	"Addr": __ptrTo_TCPListener_Addr,
	"Close": __ptrTo_TCPListener_Close,
	"File": __ptrTo_TCPListener_File,
	"SyscallConn": __ptrTo_TCPListener_SyscallConn,
}}

var members_PtrTo_UDPAddr = GoTypeInfo{Members: GoMembers{
	"Network": __ptrTo_UDPAddr_Network,
	"String": __ptrTo_UDPAddr_String,
}}

var members_PtrTo_UDPConn = GoTypeInfo{Members: GoMembers{
	"SyscallConn": __ptrTo_UDPConn_SyscallConn,
}}

var members_PtrTo_UnixAddr = GoTypeInfo{Members: GoMembers{
	"Network": __ptrTo_UnixAddr_Network,
	"String": __ptrTo_UnixAddr_String,
}}

var members_PtrTo_UnixConn = GoTypeInfo{Members: GoMembers{
	"CloseRead": __ptrTo_UnixConn_CloseRead,
	"CloseWrite": __ptrTo_UnixConn_CloseWrite,
	"SyscallConn": __ptrTo_UnixConn_SyscallConn,
}}

var members_PtrTo_UnixListener = GoTypeInfo{Members: GoMembers{
	"Accept": __ptrTo_UnixListener_Accept,
	"AcceptUnix": __ptrTo_UnixListener_AcceptUnix,
	"Addr": __ptrTo_UnixListener_Addr,
	"Close": __ptrTo_UnixListener_Close,
	"File": __ptrTo_UnixListener_File,
	"SyscallConn": __ptrTo_UnixListener_SyscallConn,
}}

var members_UnknownNetworkError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownNetworkError_Error,
	"Temporary": __unknownNetworkError_Temporary,
	"Timeout": __unknownNetworkError_Timeout,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_net.AddrError)(nil))] = &members_PtrTo_AddrError
	GoTypes[_reflect.TypeOf((*_net.DNSConfigError)(nil))] = &members_PtrTo_DNSConfigError
	GoTypes[_reflect.TypeOf((*_net.DNSError)(nil))] = &members_PtrTo_DNSError
	GoTypes[_reflect.TypeOf((*_net.Dialer)(nil))] = &members_PtrTo_Dialer
	GoTypes[_reflect.TypeOf((*_net.Flags)(nil)).Elem()] = &members_Flags
	GoTypes[_reflect.TypeOf((*_net.HardwareAddr)(nil)).Elem()] = &members_HardwareAddr
	GoTypes[_reflect.TypeOf((*_net.IP)(nil)).Elem()] = &members_IP
	GoTypes[_reflect.TypeOf((*_net.IPAddr)(nil))] = &members_PtrTo_IPAddr
	GoTypes[_reflect.TypeOf((*_net.IPConn)(nil))] = &members_PtrTo_IPConn
	GoTypes[_reflect.TypeOf((*_net.IPMask)(nil)).Elem()] = &members_IPMask
	GoTypes[_reflect.TypeOf((*_net.IPNet)(nil))] = &members_PtrTo_IPNet
	GoTypes[_reflect.TypeOf((*_net.Interface)(nil))] = &members_PtrTo_Interface
	GoTypes[_reflect.TypeOf((*_net.InvalidAddrError)(nil)).Elem()] = &members_InvalidAddrError
	GoTypes[_reflect.TypeOf((*_net.OpError)(nil))] = &members_PtrTo_OpError
	GoTypes[_reflect.TypeOf((*_net.ParseError)(nil))] = &members_PtrTo_ParseError
	GoTypes[_reflect.TypeOf((*_net.TCPAddr)(nil))] = &members_PtrTo_TCPAddr
	GoTypes[_reflect.TypeOf((*_net.TCPConn)(nil))] = &members_PtrTo_TCPConn
	GoTypes[_reflect.TypeOf((*_net.TCPListener)(nil))] = &members_PtrTo_TCPListener
	GoTypes[_reflect.TypeOf((*_net.UDPAddr)(nil))] = &members_PtrTo_UDPAddr
	GoTypes[_reflect.TypeOf((*_net.UDPConn)(nil))] = &members_PtrTo_UDPConn
	GoTypes[_reflect.TypeOf((*_net.UnixAddr)(nil))] = &members_PtrTo_UnixAddr
	GoTypes[_reflect.TypeOf((*_net.UnixConn)(nil))] = &members_PtrTo_UnixConn
	GoTypes[_reflect.TypeOf((*_net.UnixListener)(nil))] = &members_PtrTo_UnixListener
	GoTypes[_reflect.TypeOf((*_net.UnknownNetworkError)(nil)).Elem()] = &members_UnknownNetworkError
}

GO TYPE net/http.Client from net/http/client.go:
func ExtractGoObjectClient(args []Object, index int) *_http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Client:
			return &r
		case *_http.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

// func _mapToClient(o Map) *_http.Client {
// 	return &_http.Client{}
// }

// func _vectorToClient(o *Vector) *_http.Client {
// 	return &_http.Client{
// 		Transport: ABEND048(codegen.go: no conversion from Clojure for net/http.RoundTripper (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		CheckRedirect: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Jar: ABEND048(codegen.go: no conversion from Clojure for net/http.CookieJar (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_http.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Client:
// 			return &_g
// 		case *_http.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or: Map or Vector"))
// }

GO TYPE net/http.CloseNotifier from net/http/server.go:
func ExtractGoObjectCloseNotifier(args []Object, index int) *_http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CloseNotifier:
			return &r
		case *_http.CloseNotifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

// func _ConstructCloseNotifier(_v Object) _http.CloseNotifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CloseNotifier:
// 			return _g
// 		case *_http.CloseNotifier:
// 			return *_g
// 		}
// 	default:
// 		return _http.CloseNotifier(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CloseNotifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CloseNotifier] or: whatever"))
// }

GO TYPE net/http.ConnState from net/http/server.go:
func ExtractGoObjectConnState(args []Object, index int) *_http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ConnState:
			return &r
		case *_http.ConnState:
			return r
		}
	case Int:
		v := _http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _ConstructConnState(_v Object) _http.ConnState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ConnState:
			return _g
		case *_http.ConnState:
			return *_g
		}
	case Number:
		return _http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or: Number"))
}

GO TYPE net/http.Cookie from net/http/cookie.go:
func ExtractGoObjectCookie(args []Object, index int) *_http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Cookie:
			return &r
		case *_http.Cookie:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

// func _mapToCookie(o Map) *_http.Cookie {
// 	return &_http.Cookie{}
// }

// func _vectorToCookie(o *Vector) *_http.Cookie {
// 	return &_http.Cookie{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Value: AssertString(o.Nth(1), "").S,
// 		Path: AssertString(o.Nth(2), "").S,
// 		Domain: AssertString(o.Nth(3), "").S,
// 		Expires: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RawExpires: AssertString(o.Nth(5), "").S,
// 		MaxAge: AssertInt(o.Nth(6), "").I,
// 		Secure: ToBool(o.Nth(7)),
// 		HttpOnly: ToBool(o.Nth(8)),
// 		SameSite: _http.SameSite(AssertInt(o.Nth(9), "").I),
// 		Raw: AssertString(o.Nth(10), "").S,
// 		Unparsed: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructCookie(_v Object) *_http.Cookie {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Cookie:
// 			return &_g
// 		case *_http.Cookie:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCookie(_o.(Map))
// 	case *Vector:
// 		return _vectorToCookie(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or: Map or Vector"))
// }

GO TYPE net/http.CookieJar from net/http/jar.go:
func ExtractGoObjectCookieJar(args []Object, index int) *_http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CookieJar:
			return &r
		case *_http.CookieJar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

// func _ConstructCookieJar(_v Object) _http.CookieJar {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CookieJar:
// 			return _g
// 		case *_http.CookieJar:
// 			return *_g
// 		}
// 	default:
// 		return _http.CookieJar(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CookieJar))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CookieJar] or: whatever"))
// }

GO TYPE net/http.Dir from net/http/fs.go:
func ExtractGoObjectDir(args []Object, index int) *_http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Dir:
			return &r
		case *_http.Dir:
			return r
		}
	case String:
		v := _http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _ConstructDir(_v Object) _http.Dir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Dir:
			return _g
		case *_http.Dir:
			return *_g
		}
	case String:
		return _http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or: String"))
}

GO TYPE net/http.File from net/http/fs.go:
func ExtractGoObjectFile(args []Object, index int) *_http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.File:
			return &r
		case *_http.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

// func _ConstructFile(_v Object) _http.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.File:
// 			return _g
// 		case *_http.File:
// 			return *_g
// 		}
// 	default:
// 		return _http.File(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.File] or: whatever"))
// }

GO TYPE net/http.FileSystem from net/http/fs.go:
func ExtractGoObjectFileSystem(args []Object, index int) *_http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.FileSystem:
			return &r
		case *_http.FileSystem:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

// func _ConstructFileSystem(_v Object) _http.FileSystem {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.FileSystem:
// 			return _g
// 		case *_http.FileSystem:
// 			return *_g
// 		}
// 	default:
// 		return _http.FileSystem(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for FileSystem))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.FileSystem] or: whatever"))
// }

GO TYPE net/http.Flusher from net/http/server.go:
func ExtractGoObjectFlusher(args []Object, index int) *_http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Flusher:
			return &r
		case *_http.Flusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

// func _ConstructFlusher(_v Object) _http.Flusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Flusher:
// 			return _g
// 		case *_http.Flusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Flusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Flusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Flusher] or: whatever"))
// }

GO TYPE net/http.Handler from net/http/server.go:
func ExtractGoObjectHandler(args []Object, index int) *_http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Handler:
			return &r
		case *_http.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

// func _ConstructHandler(_v Object) _http.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Handler:
// 			return _g
// 		case *_http.Handler:
// 			return *_g
// 		}
// 	default:
// 		return _http.Handler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Handler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Handler] or: whatever"))
// }

GO TYPE net/http.HandlerFunc from net/http/server.go:
func ExtractGoObjectHandlerFunc(args []Object, index int) *_http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.HandlerFunc:
			return &r
		case *_http.HandlerFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _ConstructHandlerFunc(_v Object) _http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.HandlerFunc:
// 			return _g
// 		case *_http.HandlerFunc:
// 			return *_g
// 		}
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or: whatever"))
// }

GO TYPE net/http.Header from net/http/header.go:
func ExtractGoObjectHeader(args []Object, index int) *_http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Header:
			return &r
		case *_http.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _ConstructHeader(_v Object) _http.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Header:
// 			return _g
// 		case *_http.Header:
// 			return *_g
// 		}
// 	default:
// 		return _http.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or: whatever"))
// }

GO TYPE net/http.Hijacker from net/http/server.go:
func ExtractGoObjectHijacker(args []Object, index int) *_http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Hijacker:
			return &r
		case *_http.Hijacker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

// func _ConstructHijacker(_v Object) _http.Hijacker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Hijacker:
// 			return _g
// 		case *_http.Hijacker:
// 			return *_g
// 		}
// 	default:
// 		return _http.Hijacker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Hijacker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Hijacker] or: whatever"))
// }

GO TYPE net/http.ProtocolError from net/http/request.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ProtocolError:
			return &r
		case *_http.ProtocolError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *_http.ProtocolError {
	return &_http.ProtocolError{}
}

func _vectorToProtocolError(o *Vector) *_http.ProtocolError {
	return &_http.ProtocolError{
		ErrorString: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructProtocolError(_v Object) *_http.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ProtocolError:
			return &_g
		case *_http.ProtocolError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	case *Vector:
		return _vectorToProtocolError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or: Map or Vector"))
}

GO TYPE net/http.PushOptions from net/http/http.go:
func ExtractGoObjectPushOptions(args []Object, index int) *_http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.PushOptions:
			return &r
		case *_http.PushOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

// func _mapToPushOptions(o Map) *_http.PushOptions {
// 	return &_http.PushOptions{}
// }

// func _vectorToPushOptions(o *Vector) *_http.PushOptions {
// 	return &_http.PushOptions{
// 		Method: AssertString(o.Nth(0), "").S,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 	}
// }

// func _ConstructPushOptions(_v Object) *_http.PushOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.PushOptions:
// 			return &_g
// 		case *_http.PushOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPushOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToPushOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or: Map or Vector"))
// }

GO TYPE net/http.Pusher from net/http/http.go:
func ExtractGoObjectPusher(args []Object, index int) *_http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Pusher:
			return &r
		case *_http.Pusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

// func _ConstructPusher(_v Object) _http.Pusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Pusher:
// 			return _g
// 		case *_http.Pusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Pusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Pusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Pusher] or: whatever"))
// }

GO TYPE net/http.Request from net/http/request.go:
func ExtractGoObjectRequest(args []Object, index int) *_http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Request:
			return &r
		case *_http.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

// func _mapToRequest(o Map) *_http.Request {
// 	return &_http.Request{}
// }

// func _vectorToRequest(o *Vector) *_http.Request {
// 	return &_http.Request{
// 		Method: AssertString(o.Nth(0), "").S,
// 		URL: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		GetBody: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ContentLength: AssertNumber(o.Nth(8), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(10)),
// 		Host: AssertString(o.Nth(11), "").S,
// 		Form: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PostForm: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MultipartForm: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		RemoteAddr: AssertString(o.Nth(16), "").S,
// 		RequestURI: AssertString(o.Nth(17), "").S,
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Response: ABEND048(codegen.go: no conversion from Clojure for *net/http.Response (net/http.Response)),
// 	}
// }

// func _ConstructRequest(_v Object) *_http.Request {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Request:
// 			return &_g
// 		case *_http.Request:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRequest(_o.(Map))
// 	case *Vector:
// 		return _vectorToRequest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or: Map or Vector"))
// }

GO TYPE net/http.Response from net/http/response.go:
func ExtractGoObjectResponse(args []Object, index int) *_http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Response:
			return &r
		case *_http.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

// func _mapToResponse(o Map) *_http.Response {
// 	return &_http.Response{}
// }

// func _vectorToResponse(o *Vector) *_http.Response {
// 	return &_http.Response{
// 		Status: AssertString(o.Nth(0), "").S,
// 		StatusCode: AssertInt(o.Nth(1), "").I,
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ContentLength: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(9)),
// 		Uncompressed: ToBool(o.Nth(10)),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Request: ABEND048(codegen.go: no conversion from Clojure for *net/http.Request (net/http.Request)),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructResponse(_v Object) *_http.Response {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Response:
// 			return &_g
// 		case *_http.Response:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponse(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponse(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or: Map or Vector"))
// }

GO TYPE net/http.ResponseWriter from net/http/server.go:
func ExtractGoObjectResponseWriter(args []Object, index int) *_http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ResponseWriter:
			return &r
		case *_http.ResponseWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

// func _ConstructResponseWriter(_v Object) _http.ResponseWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.ResponseWriter:
// 			return _g
// 		case *_http.ResponseWriter:
// 			return *_g
// 		}
// 	default:
// 		return _http.ResponseWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ResponseWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ResponseWriter] or: whatever"))
// }

GO TYPE net/http.RoundTripper from net/http/client.go:
func ExtractGoObjectRoundTripper(args []Object, index int) *_http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.RoundTripper:
			return &r
		case *_http.RoundTripper:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

// func _ConstructRoundTripper(_v Object) _http.RoundTripper {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.RoundTripper:
// 			return _g
// 		case *_http.RoundTripper:
// 			return *_g
// 		}
// 	default:
// 		return _http.RoundTripper(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RoundTripper))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.RoundTripper] or: whatever"))
// }

GO TYPE net/http.SameSite from net/http/cookie.go:
func ExtractGoObjectSameSite(args []Object, index int) *_http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.SameSite:
			return &r
		case *_http.SameSite:
			return r
		}
	case Int:
		v := _http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _ConstructSameSite(_v Object) _http.SameSite {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.SameSite:
			return _g
		case *_http.SameSite:
			return *_g
		}
	case Number:
		return _http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or: Number"))
}

GO TYPE net/http.ServeMux from net/http/server.go:
func ExtractGoObjectServeMux(args []Object, index int) *_http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ServeMux:
			return &r
		case *_http.ServeMux:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _vectorToServeMux(o *Vector) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _ConstructServeMux(_v Object) *_http.ServeMux {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ServeMux:
			return &_g
		case *_http.ServeMux:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	case *Vector:
		return _vectorToServeMux(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or: Map or Vector"))
}

GO TYPE net/http.Server from net/http/server.go:
func ExtractGoObjectServer(args []Object, index int) *_http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Server:
			return &r
		case *_http.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

// func _mapToServer(o Map) *_http.Server {
// 	return &_http.Server{}
// }

// func _vectorToServer(o *Vector) *_http.Server {
// 	return &_http.Server{
// 		Addr: AssertString(o.Nth(0), "").S,
// 		Handler: ABEND048(codegen.go: no conversion from Clojure for net/http.Handler (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		TLSConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		WriteTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		IdleTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MaxHeaderBytes: AssertInt(o.Nth(7), "").I,
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ConnState: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_http.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Server:
// 			return &_g
// 		case *_http.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or: Map or Vector"))
// }

GO TYPE net/http.Transport from net/http/transport.go:
func ExtractGoObjectTransport(args []Object, index int) *_http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Transport:
			return &r
		case *_http.Transport:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

// func _mapToTransport(o Map) *_http.Transport {
// 	return &_http.Transport{}
// }

// func _vectorToTransport(o *Vector) *_http.Transport {
// 	return &_http.Transport{
// 		Proxy: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialContext: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialTLS: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSClientConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSHandshakeTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		DisableKeepAlives: ToBool(o.Nth(6)),
// 		DisableCompression: ToBool(o.Nth(7)),
// 		MaxIdleConns: AssertInt(o.Nth(8), "").I,
// 		MaxIdleConnsPerHost: AssertInt(o.Nth(9), "").I,
// 		MaxConnsPerHost: AssertInt(o.Nth(10), "").I,
// 		IdleConnTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ResponseHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExpectContinueTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ProxyConnectHeader: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		MaxResponseHeaderBytes: AssertNumber(o.Nth(16), "").BigInt().Int64(),
// 	}
// }

// func _ConstructTransport(_v Object) *_http.Transport {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Transport:
// 			return &_g
// 		case *_http.Transport:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTransport(_o.(Map))
// 	case *Vector:
// 		return _vectorToTransport(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or: Map or Vector"))
// }

GO FUNC net/http.DetectContentType from net/http/sniff.go:
// func __detectContentType(data []byte)  {
// 	_res := _http.DetectContentType(data)
// 	return MakeString(_res)
// }

GO FUNC net/http.Error from net/http/server.go:
// func __error(w _http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
func __fileServer(root _http.FileSystem) Object {
	_res := _http.FileServer(root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func __get(url string) Object {
	resp, err := _http.Get(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
// func __handle(pattern string, handler _http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func __handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
func __head(url string) Object {
	resp, err := _http.Head(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func __maxBytesReader(w _http.ResponseWriter, r ABEND987(genutils.go: imports not yet supported: io.ReadCloser), n int64) Object {
// 	_res := _http.MaxBytesReader(w, r, n)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func __newFileTransport(fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func __newRequest(method string, url string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func __newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
// func __notFound(w _http.ResponseWriter, r *_http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func __notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func __parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
func __parseTime(text string) Object {
	t, err := _http.ParseTime(text)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(t))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Post from net/http/client.go:
// func __post(url string, contentType string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func __postForm(url string, data ABEND987(genutils.go: imports not yet supported: url.Values)) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
func __proxyFromEnvironment(req *_http.Request) Object {
	_res1, _res2 := _http.ProxyFromEnvironment(req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func __proxyURL(fixedURL *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func __readRequest(b *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func __readResponse(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader), req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func __redirect(w _http.ResponseWriter, r *_http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
func __redirectHandler(url string, code int) Object {
	_res := _http.RedirectHandler(url, code)
	return MakeGoObject(_res)
}

GO FUNC net/http.Serve from net/http/server.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler)  {
// 	_res := _http.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func __serveContent(w _http.ResponseWriter, req *_http.Request, name string, modtime ABEND987(genutils.go: imports not yet supported: time.Time), content ABEND987(genutils.go: imports not yet supported: io.ReadSeeker)) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func __serveFile(w _http.ResponseWriter, r *_http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeTLS from net/http/server.go:
// func __serveTLS(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler _http.Handler, certFile string, keyFile string)  {
// 	_res := _http.ServeTLS(l, handler, certFile, keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func __setCookie(w _http.ResponseWriter, cookie *_http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
func __stripPrefix(prefix string, h _http.Handler) Object {
	_res := _http.StripPrefix(prefix, h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func __timeoutHandler(h _http.Handler, dt ABEND987(genutils.go: imports not yet supported: time.Duration), msg string) Object {
// 	_res := _http.TimeoutHandler(h, dt, msg)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.__connState_String from net/http/server.go:
func __connState_String(o GoObject, args Object) Object {
	CheckGoArity("(_net/http.ConnState)String()", args, 0, 0)
	_res := o.O.(_http.ConnState).String()
	return MakeString(_res)
}

GO FUNC net/http.__dir_Open from net/http/fs.go:
func __dir_Open(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Dir)Open()", args, 1, 1)
	name := ExtractGoString("(_net/http.Dir)Open()", "name", _argList, 0)
	_res1, _res2 := o.O.(_http.Dir).Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__handlerFunc_ServeHTTP from net/http/server.go:
// func __handlerFunc_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Add from net/http/header.go:
// func __header_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Del from net/http/header.go:
// func __header_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Get from net/http/header.go:
func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Header)Get()", args, 1, 1)
	key := ExtractGoString("(_net/http.Header)Get()", "key", _argList, 0)
	_res := o.O.(_http.Header).Get(key)
	return MakeString(_res)
}

GO FUNC net/http.__header_Set from net/http/header.go:
// func __header_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Write from net/http/header.go:
// func __header_Write(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__header_WriteSubset from net/http/header.go:
// func __header_WriteSubset(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer), exclude map[]}

GO FUNC net/http.__ptrTo_Client_CloseIdleConnections from net/http/client.go:
// func __ptrTo_Client_CloseIdleConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Client_Do from net/http/client.go:
// func __ptrTo_Client_Do(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Client)Do()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for req at: /usr/local/go/src/net/http/client.go:508:25)
// 	_res1, _res2 := o.O.(*_http.Client).Do(req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.__ptrTo_Client_Get from net/http/client.go:
func __ptrTo_Client_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Get()", args, 1, 1)
	url := ExtractGoString("(*_net/http.Client)Get()", "url", _argList, 0)
	resp, err := o.O.(*_http.Client).Get(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Client_Head from net/http/client.go:
func __ptrTo_Client_Head(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Head()", args, 1, 1)
	url := ExtractGoString("(*_net/http.Client)Head()", "url", _argList, 0)
	resp, err := o.O.(*_http.Client).Head(url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Client_Post from net/http/client.go:
// func __ptrTo_Client_Post(o GoObject, args Object) Object {
// url string, contentType string, body ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC net/http.__ptrTo_Client_PostForm from net/http/client.go:
// func __ptrTo_Client_PostForm(o GoObject, args Object) Object {
// url string, data ABEND987(genutils.go: imports not yet supported: url.Values)}

GO FUNC net/http.__ptrTo_Cookie_String from net/http/cookie.go:
func __ptrTo_Cookie_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Cookie)String()", args, 0, 0)
	_res := o.O.(*_http.Cookie).String()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_ProtocolError_Error from net/http/request.go:
func __ptrTo_ProtocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(*_http.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_AddCookie from net/http/request.go:
// func __ptrTo_Request_AddCookie(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Request_BasicAuth from net/http/request.go:
func __ptrTo_Request_BasicAuth(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)BasicAuth()", args, 0, 0)
	username, password, ok := o.O.(*_http.Request).BasicAuth()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(username))
	_res = _res.Conjoin(MakeString(password))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.__ptrTo_Request_Context from net/http/request.go:
func __ptrTo_Request_Context(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Context()", args, 0, 0)
	_res := o.O.(*_http.Request).Context()
	return MakeGoObject(_res)
}

GO FUNC net/http.__ptrTo_Request_Cookie from net/http/request.go:
func __ptrTo_Request_Cookie(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)Cookie()", args, 1, 1)
	name := ExtractGoString("(*_net/http.Request)Cookie()", "name", _argList, 0)
	_res1, _res2 := o.O.(*_http.Request).Cookie(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Request_Cookies from net/http/request.go:
func __ptrTo_Request_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Request).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC net/http.__ptrTo_Request_FormFile from net/http/request.go:
func __ptrTo_Request_FormFile(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)FormFile()", args, 1, 1)
	key := ExtractGoString("(*_net/http.Request)FormFile()", "key", _argList, 0)
	_res1, _res2, _res3 := o.O.(*_http.Request).FormFile(key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Request_FormValue from net/http/request.go:
func __ptrTo_Request_FormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)FormValue()", args, 1, 1)
	key := ExtractGoString("(*_net/http.Request)FormValue()", "key", _argList, 0)
	_res := o.O.(*_http.Request).FormValue(key)
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_MultipartReader from net/http/request.go:
func __ptrTo_Request_MultipartReader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)MultipartReader()", args, 0, 0)
	_res1, _res2 := o.O.(*_http.Request).MultipartReader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Request_ParseForm from net/http/request.go:
func __ptrTo_Request_ParseForm(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)ParseForm()", args, 0, 0)
	_res := o.O.(*_http.Request).ParseForm()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Request_ParseMultipartForm from net/http/request.go:
func __ptrTo_Request_ParseMultipartForm(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ParseMultipartForm()", args, 1, 1)
	maxMemory := ExtractGoInt64("(*_net/http.Request)ParseMultipartForm()", "maxMemory", _argList, 0)
	_res := o.O.(*_http.Request).ParseMultipartForm(maxMemory)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Request_PostFormValue from net/http/request.go:
func __ptrTo_Request_PostFormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)PostFormValue()", args, 1, 1)
	key := ExtractGoString("(*_net/http.Request)PostFormValue()", "key", _argList, 0)
	_res := o.O.(*_http.Request).PostFormValue(key)
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_ProtoAtLeast from net/http/request.go:
func __ptrTo_Request_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ProtoAtLeast()", args, 2, 2)
	major := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "major", _argList, 0)
	minor := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "minor", _argList, 1)
	_res := o.O.(*_http.Request).ProtoAtLeast(major, minor)
	return MakeBoolean(_res)
}

GO FUNC net/http.__ptrTo_Request_Referer from net/http/request.go:
func __ptrTo_Request_Referer(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Referer()", args, 0, 0)
	_res := o.O.(*_http.Request).Referer()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_SetBasicAuth from net/http/request.go:
// func __ptrTo_Request_SetBasicAuth(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Request_UserAgent from net/http/request.go:
func __ptrTo_Request_UserAgent(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)UserAgent()", args, 0, 0)
	_res := o.O.(*_http.Request).UserAgent()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_WithContext from net/http/request.go:
// func __ptrTo_Request_WithContext(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC net/http.__ptrTo_Request_Write from net/http/request.go:
// func __ptrTo_Request_Write(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_Request_WriteProxy from net/http/request.go:
// func __ptrTo_Request_WriteProxy(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_Response_Cookies from net/http/response.go:
func __ptrTo_Response_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Response).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC net/http.__ptrTo_Response_Location from net/http/response.go:
func __ptrTo_Response_Location(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Location()", args, 0, 0)
	_res1, _res2 := o.O.(*_http.Response).Location()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Response_ProtoAtLeast from net/http/response.go:
func __ptrTo_Response_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Response)ProtoAtLeast()", args, 2, 2)
	major := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "major", _argList, 0)
	minor := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "minor", _argList, 1)
	_res := o.O.(*_http.Response).ProtoAtLeast(major, minor)
	return MakeBoolean(_res)
}

GO FUNC net/http.__ptrTo_Response_Write from net/http/response.go:
// func __ptrTo_Response_Write(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_ServeMux_Handle from net/http/server.go:
// func __ptrTo_ServeMux_Handle(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_ServeMux_HandleFunc from net/http/server.go:
// func __ptrTo_ServeMux_HandleFunc(o GoObject, args Object) Object {
// (pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC net/http.__ptrTo_ServeMux_Handler from net/http/server.go:
// func __ptrTo_ServeMux_Handler(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.ServeMux)Handler()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for r at: /usr/local/go/src/net/http/server.go:2310:32)
// 	h, pattern := o.O.(*_http.ServeMux).Handler(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(h))
// 	_res = _res.Conjoin(MakeString(pattern))
// 	return _res
// }

GO FUNC net/http.__ptrTo_ServeMux_ServeHTTP from net/http/server.go:
// func __ptrTo_ServeMux_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Server_Close from net/http/server.go:
func __ptrTo_Server_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)Close()", args, 0, 0)
	_res := o.O.(*_http.Server).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_ListenAndServe from net/http/server.go:
func __ptrTo_Server_ListenAndServe(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)ListenAndServe()", args, 0, 0)
	_res := o.O.(*_http.Server).ListenAndServe()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_ListenAndServeTLS from net/http/server.go:
func __ptrTo_Server_ListenAndServeTLS(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Server)ListenAndServeTLS()", args, 2, 2)
	certFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "certFile", _argList, 0)
	keyFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "keyFile", _argList, 1)
	_res := o.O.(*_http.Server).ListenAndServeTLS(certFile, keyFile)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_RegisterOnShutdown from net/http/server.go:
// func __ptrTo_Server_RegisterOnShutdown(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC net/http.__ptrTo_Server_Serve from net/http/server.go:
// func __ptrTo_Server_Serve(o GoObject, args Object) Object {
// l ABEND987(genutils.go: imports not yet supported: net.Listener)}

GO FUNC net/http.__ptrTo_Server_ServeTLS from net/http/server.go:
// func __ptrTo_Server_ServeTLS(o GoObject, args Object) Object {
// l ABEND987(genutils.go: imports not yet supported: net.Listener), certFile string, keyFile string}

GO FUNC net/http.__ptrTo_Server_SetKeepAlivesEnabled from net/http/server.go:
// func __ptrTo_Server_SetKeepAlivesEnabled(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Server_Shutdown from net/http/server.go:
// func __ptrTo_Server_Shutdown(o GoObject, args Object) Object {
// ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC net/http.__ptrTo_Transport_CancelRequest from net/http/transport.go:
// func __ptrTo_Transport_CancelRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_CloseIdleConnections from net/http/transport.go:
// func __ptrTo_Transport_CloseIdleConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_RegisterProtocol from net/http/transport.go:
// func __ptrTo_Transport_RegisterProtocol(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_RoundTrip from net/http/roundtrip.go:
// func __ptrTo_Transport_RoundTrip(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Transport)RoundTrip()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for req at: /usr/local/go/src/net/http/roundtrip.go:16:35)
// 	_res1, _res2 := o.O.(*_http.Transport).RoundTrip(req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package http

import (
	. "github.com/candid82/joker/core"
	_http "net/http"
	_reflect "reflect"
)
var members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
	"Get": __ptrTo_Client_Get,
	"Head": __ptrTo_Client_Head,
}}

var members_ConnState = GoTypeInfo{Members: GoMembers{
	"String": __connState_String,
}}

var members_PtrTo_Cookie = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Cookie_String,
}}

var members_Dir = GoTypeInfo{Members: GoMembers{
	"Open": __dir_Open,
}}

var members_Header = GoTypeInfo{Members: GoMembers{
	"Get": __header_Get,
}}

var members_PtrTo_ProtocolError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ProtocolError_Error,
}}

var members_PtrTo_Request = GoTypeInfo{Members: GoMembers{
	"BasicAuth": __ptrTo_Request_BasicAuth,
	"Context": __ptrTo_Request_Context,
	"Cookie": __ptrTo_Request_Cookie,
	"Cookies": __ptrTo_Request_Cookies,
	"FormFile": __ptrTo_Request_FormFile,
	"FormValue": __ptrTo_Request_FormValue,
	"MultipartReader": __ptrTo_Request_MultipartReader,
	"ParseForm": __ptrTo_Request_ParseForm,
	"ParseMultipartForm": __ptrTo_Request_ParseMultipartForm,
	"PostFormValue": __ptrTo_Request_PostFormValue,
	"ProtoAtLeast": __ptrTo_Request_ProtoAtLeast,
	"Referer": __ptrTo_Request_Referer,
	"UserAgent": __ptrTo_Request_UserAgent,
}}

var members_PtrTo_Response = GoTypeInfo{Members: GoMembers{
	"Cookies": __ptrTo_Response_Cookies,
	"Location": __ptrTo_Response_Location,
	"ProtoAtLeast": __ptrTo_Response_ProtoAtLeast,
}}

var members_PtrTo_Server = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Server_Close,
	"ListenAndServe": __ptrTo_Server_ListenAndServe,
	"ListenAndServeTLS": __ptrTo_Server_ListenAndServeTLS,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_http.Client)(nil))] = &members_PtrTo_Client
	GoTypes[_reflect.TypeOf((*_http.ConnState)(nil)).Elem()] = &members_ConnState
	GoTypes[_reflect.TypeOf((*_http.Cookie)(nil))] = &members_PtrTo_Cookie
	GoTypes[_reflect.TypeOf((*_http.Dir)(nil)).Elem()] = &members_Dir
	GoTypes[_reflect.TypeOf((*_http.Header)(nil)).Elem()] = &members_Header
	GoTypes[_reflect.TypeOf((*_http.ProtocolError)(nil))] = &members_PtrTo_ProtocolError
	GoTypes[_reflect.TypeOf((*_http.Request)(nil))] = &members_PtrTo_Request
	GoTypes[_reflect.TypeOf((*_http.Response)(nil))] = &members_PtrTo_Response
	GoTypes[_reflect.TypeOf((*_http.Server)(nil))] = &members_PtrTo_Server
}

GO TYPE net/http/cgi.Handler from net/http/cgi/host.go:
func ExtractGoObjectHandler(args []Object, index int) *_cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cgi.Handler:
			return &r
		case *_cgi.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cgi.Handler]"))
}

// func _mapToHandler(o Map) *_cgi.Handler {
// 	return &_cgi.Handler{}
// }

// func _vectorToHandler(o *Vector) *_cgi.Handler {
// 	return &_cgi.Handler{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Root: AssertString(o.Nth(1), "").S,
// 		Dir: AssertString(o.Nth(2), "").S,
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		InheritEnv: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Logger: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Stderr: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PathLocationHandler: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructHandler(_v Object) *_cgi.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cgi.Handler:
// 			return &_g
// 		case *_cgi.Handler:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHandler(_o.(Map))
// 	case *Vector:
// 		return _vectorToHandler(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cgi.Handler] or: Map or Vector"))
// }

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func __request() Object {
	_res1, _res2 := _cgi.Request()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func __requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.Serve from net/http/cgi/child.go:
// func __serve(handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _cgi.Serve(handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http/cgi.__ptrTo_Handler_ServeHTTP from net/http/cgi/host.go:
// func __ptrTo_Handler_ServeHTTP(o GoObject, args Object) Object {
// rw ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), req *ABEND987(genutils.go: imports not yet supported: http.Request)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cgi

import (
	. "github.com/candid82/joker/core"
	_cgi "net/http/cgi"
)

func init() {
}

GO TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func ExtractGoObjectJar(args []Object, index int) *_cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Jar:
			return &r
		case *_cookiejar.Jar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _vectorToJar(o *Vector) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _ConstructJar(_v Object) *_cookiejar.Jar {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Jar:
			return &_g
		case *_cookiejar.Jar:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	case *Vector:
		return _vectorToJar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or: Map or Vector"))
}

GO TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func ExtractGoObjectOptions(args []Object, index int) *_cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Options:
			return &r
		case *_cookiejar.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

// func _mapToOptions(o Map) *_cookiejar.Options {
// 	return &_cookiejar.Options{}
// }

// func _vectorToOptions(o *Vector) *_cookiejar.Options {
// 	return &_cookiejar.Options{
// 		PublicSuffixList: ABEND048(codegen.go: no conversion from Clojure for net/http/cookiejar.PublicSuffixList (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructOptions(_v Object) *_cookiejar.Options {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.Options:
// 			return &_g
// 		case *_cookiejar.Options:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or: Map or Vector"))
// }

GO TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
func ExtractGoObjectPublicSuffixList(args []Object, index int) *_cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.PublicSuffixList:
			return &r
		case *_cookiejar.PublicSuffixList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

// func _ConstructPublicSuffixList(_v Object) _cookiejar.PublicSuffixList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.PublicSuffixList:
// 			return _g
// 		case *_cookiejar.PublicSuffixList:
// 			return *_g
// 		}
// 	default:
// 		return _cookiejar.PublicSuffixList(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PublicSuffixList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.PublicSuffixList] or: whatever"))
// }

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
func __new(o *_cookiejar.Options) Object {
	_res1, _res2 := _cookiejar.New(o)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cookiejar.__ptrTo_Jar_Cookies from net/http/cookiejar/jar.go:
// func __ptrTo_Jar_Cookies(o GoObject, args Object) Object {
// u *ABEND987(genutils.go: imports not yet supported: url.URL)}

GO FUNC net/http/cookiejar.__ptrTo_Jar_SetCookies from net/http/cookiejar/jar.go:
// func __ptrTo_Jar_SetCookies(o GoObject, args Object) Object {
// u *ABEND987(genutils.go: imports not yet supported: url.URL), cookies []*ABEND987(genutils.go: imports not yet supported: http.Cookie)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package cookiejar

import (
	. "github.com/candid82/joker/core"
	_cookiejar "net/http/cookiejar"
)

func init() {
}

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func __processEnv(r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
// func __serve(l ABEND987(genutils.go: imports not yet supported: net.Listener), handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _fcgi.Serve(l, handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func ExtractGoObjectResponseRecorder(args []Object, index int) *_httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.ResponseRecorder:
			return &r
		case *_httptest.ResponseRecorder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.ResponseRecorder]"))
}

// func _mapToResponseRecorder(o Map) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{}
// }

// func _vectorToResponseRecorder(o *Vector) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{
// 		Code: AssertInt(o.Nth(0), "").I,
// 		HeaderMap: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Flushed: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructResponseRecorder(_v Object) *_httptest.ResponseRecorder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.ResponseRecorder:
// 			return &_g
// 		case *_httptest.ResponseRecorder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponseRecorder(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponseRecorder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.ResponseRecorder] or: Map or Vector"))
// }

GO TYPE net/http/httptest.Server from net/http/httptest/server.go:
func ExtractGoObjectServer(args []Object, index int) *_httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.Server:
			return &r
		case *_httptest.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.Server]"))
}

// func _mapToServer(o Map) *_httptest.Server {
// 	return &_httptest.Server{}
// }

// func _vectorToServer(o *Vector) *_httptest.Server {
// 	return &_httptest.Server{
// 		URL: AssertString(o.Nth(0), "").S,
// 		Listener: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Config: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_httptest.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.Server:
// 			return &_g
// 		case *_httptest.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.Server] or: Map or Vector"))
// }

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func __newRecorder() Object {
	_res := _httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func __newRequest(method string, target string, body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func __newServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func __newTLSServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func __newUnstartedServer(handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Flush from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_Flush(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Header from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_Header(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.ResponseRecorder)Header()", args, 0, 0)
	_res := o.O.(*_httptest.ResponseRecorder).Header()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Result from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_Result(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.ResponseRecorder)Result()", args, 0, 0)
	_res := o.O.(*_httptest.ResponseRecorder).Result()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Write from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_WriteHeader from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_WriteHeader(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_WriteString from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http/httptest.ResponseRecorder)WriteString()", args, 1, 1)
	str := ExtractGoString("(*_net/http/httptest.ResponseRecorder)WriteString()", "str", _argList, 0)
	_res1, _res2 := o.O.(*_httptest.ResponseRecorder).WriteString(str)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httptest.__ptrTo_Server_Certificate from net/http/httptest/server.go:
func __ptrTo_Server_Certificate(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.Server)Certificate()", args, 0, 0)
	_res := o.O.(*_httptest.Server).Certificate()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_Server_Client from net/http/httptest/server.go:
func __ptrTo_Server_Client(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.Server)Client()", args, 0, 0)
	_res := o.O.(*_httptest.Server).Client()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_Server_Close from net/http/httptest/server.go:
// func __ptrTo_Server_Close(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_CloseClientConnections from net/http/httptest/server.go:
// func __ptrTo_Server_CloseClientConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_Start from net/http/httptest/server.go:
// func __ptrTo_Server_Start(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_StartTLS from net/http/httptest/server.go:
// func __ptrTo_Server_StartTLS(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package httptest

import (
	. "github.com/candid82/joker/core"
	_httptest "net/http/httptest"
	_reflect "reflect"
)
var members_PtrTo_ResponseRecorder = GoTypeInfo{Members: GoMembers{
	"Header": __ptrTo_ResponseRecorder_Header,
	"Result": __ptrTo_ResponseRecorder_Result,
	"WriteString": __ptrTo_ResponseRecorder_WriteString,
}}

var members_PtrTo_Server = GoTypeInfo{Members: GoMembers{
	"Certificate": __ptrTo_Server_Certificate,
	"Client": __ptrTo_Server_Client,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_httptest.ResponseRecorder)(nil))] = &members_PtrTo_ResponseRecorder
	GoTypes[_reflect.TypeOf((*_httptest.Server)(nil))] = &members_PtrTo_Server
}

GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func __contextClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func __withClientTrace(ctx ABEND987(genutils.go: imports not yet supported: context.Context), trace *_httptrace.ClientTrace) Object {
// 	_res := _httptrace.WithClientTrace(ctx, trace)
// 	return MakeGoObject(_res)
// }

GO TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
func ExtractGoObjectBufferPool(args []Object, index int) *_httputil.BufferPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.BufferPool:
			return &r
		case *_httputil.BufferPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.BufferPool]"))
}

// func _ConstructBufferPool(_v Object) _httputil.BufferPool {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.BufferPool:
// 			return _g
// 		case *_httputil.BufferPool:
// 			return *_g
// 		}
// 	default:
// 		return _httputil.BufferPool(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for BufferPool))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.BufferPool] or: whatever"))
// }

GO TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
func ExtractGoObjectClientConn(args []Object, index int) *_httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ClientConn:
			return &r
		case *_httputil.ClientConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ClientConn]"))
}

func _mapToClientConn(o Map) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _vectorToClientConn(o *Vector) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _ConstructClientConn(_v Object) *_httputil.ClientConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ClientConn:
			return &_g
		case *_httputil.ClientConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientConn(_o.(Map))
	case *Vector:
		return _vectorToClientConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ClientConn] or: Map or Vector"))
}

GO TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
func ExtractGoObjectReverseProxy(args []Object, index int) *_httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ReverseProxy:
			return &r
		case *_httputil.ReverseProxy:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ReverseProxy]"))
}

// func _mapToReverseProxy(o Map) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{}
// }

// func _vectorToReverseProxy(o *Vector) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{
// 		Director: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Transport: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		FlushInterval: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		BufferPool: ABEND048(codegen.go: no conversion from Clojure for net/http/httputil.BufferPool (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		ModifyResponse: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorHandler: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructReverseProxy(_v Object) *_httputil.ReverseProxy {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.ReverseProxy:
// 			return &_g
// 		case *_httputil.ReverseProxy:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReverseProxy(_o.(Map))
// 	case *Vector:
// 		return _vectorToReverseProxy(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ReverseProxy] or: Map or Vector"))
// }

GO TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
func ExtractGoObjectServerConn(args []Object, index int) *_httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ServerConn:
			return &r
		case *_httputil.ServerConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ServerConn]"))
}

func _mapToServerConn(o Map) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _vectorToServerConn(o *Vector) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _ConstructServerConn(_v Object) *_httputil.ServerConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ServerConn:
			return &_g
		case *_httputil.ServerConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServerConn(_o.(Map))
	case *Vector:
		return _vectorToServerConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ServerConn] or: Map or Vector"))
}

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func __dumpRequest(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func __dumpRequestOut(req *ABEND987(genutils.go: imports not yet supported: http.Request), body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func __dumpResponse(resp *ABEND987(genutils.go: imports not yet supported: http.Response), body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func __newChunkedReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httputil.NewChunkedReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func __newChunkedWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _httputil.NewChunkedWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func __newClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func __newProxyClientConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewProxyClientConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func __newServerConn(c ABEND987(genutils.go: imports not yet supported: net.Conn), r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewServerConn(c, r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func __newSingleHostReverseProxy(target *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.__ptrTo_ClientConn_Close from net/http/httputil/persist.go:
func __ptrTo_ClientConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Do from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Do(o GoObject, args Object) Object {
// req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Hijack from net/http/httputil/persist.go:
func __ptrTo_ClientConn_Hijack(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Hijack()", args, 0, 0)
	c, r := o.O.(*_httputil.ClientConn).Hijack()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(c))
	_res = _res.Conjoin(MakeGoObject(r))
	return _res
}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Pending from net/http/httputil/persist.go:
func __ptrTo_ClientConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Read from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Read(o GoObject, args Object) Object {
// req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Write from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Write(o GoObject, args Object) Object {
// req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ReverseProxy_ServeHTTP from net/http/httputil/reverseproxy.go:
// func __ptrTo_ReverseProxy_ServeHTTP(o GoObject, args Object) Object {
// rw ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Close from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Hijack from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Hijack(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Hijack()", args, 0, 0)
	_res1, _res2 := o.O.(*_httputil.ServerConn).Hijack()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Pending from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Read from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Read(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Read()", args, 0, 0)
	_res1, _res2 := o.O.(*_httputil.ServerConn).Read()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Write from net/http/httputil/persist.go:
// func __ptrTo_ServerConn_Write(o GoObject, args Object) Object {
// req *ABEND987(genutils.go: imports not yet supported: http.Request), resp *ABEND987(genutils.go: imports not yet supported: http.Response)}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package httputil

import (
	. "github.com/candid82/joker/core"
	_httputil "net/http/httputil"
	_reflect "reflect"
)
var members_PtrTo_ClientConn = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_ClientConn_Close,
	"Hijack": __ptrTo_ClientConn_Hijack,
	"Pending": __ptrTo_ClientConn_Pending,
}}

var members_PtrTo_ServerConn = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_ServerConn_Close,
	"Hijack": __ptrTo_ServerConn_Hijack,
	"Pending": __ptrTo_ServerConn_Pending,
	"Read": __ptrTo_ServerConn_Read,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_httputil.ClientConn)(nil))] = &members_PtrTo_ClientConn
	GoTypes[_reflect.TypeOf((*_httputil.ServerConn)(nil))] = &members_PtrTo_ServerConn
}

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func __cmdline(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func __handler(name string) Object {
	_res := _pprof.Handler(name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func __index(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func __profile(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func __symbol(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func __trace(w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	. "github.com/candid82/joker/core"
	_pprof "net/http/pprof"
)

func init() {
}

GO TYPE net/mail.Address from net/mail/message.go:
func ExtractGoObjectAddress(args []Object, index int) *_mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Address:
			return &r
		case *_mail.Address:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *_mail.Address {
	return &_mail.Address{}
}

func _vectorToAddress(o *Vector) *_mail.Address {
	return &_mail.Address{
		Name: AssertString(o.Nth(0), "").S,
		Address: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddress(_v Object) *_mail.Address {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Address:
			return &_g
		case *_mail.Address:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	case *Vector:
		return _vectorToAddress(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or: Map or Vector"))
}

GO TYPE net/mail.AddressParser from net/mail/message.go:
func ExtractGoObjectAddressParser(args []Object, index int) *_mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.AddressParser:
			return &r
		case *_mail.AddressParser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

// func _mapToAddressParser(o Map) *_mail.AddressParser {
// 	return &_mail.AddressParser{}
// }

// func _vectorToAddressParser(o *Vector) *_mail.AddressParser {
// 	return &_mail.AddressParser{
// 		WordDecoder: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructAddressParser(_v Object) *_mail.AddressParser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.AddressParser:
// 			return &_g
// 		case *_mail.AddressParser:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAddressParser(_o.(Map))
// 	case *Vector:
// 		return _vectorToAddressParser(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or: Map or Vector"))
// }

GO TYPE net/mail.Header from net/mail/message.go:
func ExtractGoObjectHeader(args []Object, index int) *_mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Header:
			return &r
		case *_mail.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _ConstructHeader(_v Object) _mail.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Header:
// 			return _g
// 		case *_mail.Header:
// 			return *_g
// 		}
// 	default:
// 		return _mail.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or: whatever"))
// }

GO TYPE net/mail.Message from net/mail/message.go:
func ExtractGoObjectMessage(args []Object, index int) *_mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Message:
			return &r
		case *_mail.Message:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

// func _mapToMessage(o Map) *_mail.Message {
// 	return &_mail.Message{}
// }

// func _vectorToMessage(o *Vector) *_mail.Message {
// 	return &_mail.Message{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/mail.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructMessage(_v Object) *_mail.Message {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Message:
// 			return &_g
// 		case *_mail.Message:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or: Map or Vector"))
// }

GO FUNC net/mail.ParseAddress from net/mail/message.go:
func __parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func __parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
func __parseDate(date string) Object {
	_res1, _res2 := _mail.ParseDate(date)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func __readMessage(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/mail.__header_AddressList from net/mail/message.go:
func __header_AddressList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)AddressList()", args, 1, 1)
	key := ExtractGoString("(_net/mail.Header)AddressList()", "key", _argList, 0)
	_res1, _res2 := o.O.(_mail.Header).AddressList(key)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__header_Date from net/mail/message.go:
func __header_Date(o GoObject, args Object) Object {
	CheckGoArity("(_net/mail.Header)Date()", args, 0, 0)
	_res1, _res2 := o.O.(_mail.Header).Date()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__header_Get from net/mail/message.go:
func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)Get()", args, 1, 1)
	key := ExtractGoString("(_net/mail.Header)Get()", "key", _argList, 0)
	_res := o.O.(_mail.Header).Get(key)
	return MakeString(_res)
}

GO FUNC net/mail.__ptrTo_AddressParser_Parse from net/mail/message.go:
func __ptrTo_AddressParser_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)Parse()", args, 1, 1)
	address := ExtractGoString("(*_net/mail.AddressParser)Parse()", "address", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).Parse(address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__ptrTo_AddressParser_ParseList from net/mail/message.go:
func __ptrTo_AddressParser_ParseList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)ParseList()", args, 1, 1)
	list := ExtractGoString("(*_net/mail.AddressParser)ParseList()", "list", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).ParseList(list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__ptrTo_Address_String from net/mail/message.go:
func __ptrTo_Address_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/mail.Address)String()", args, 0, 0)
	_res := o.O.(*_mail.Address).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package mail

import (
	. "github.com/candid82/joker/core"
	_mail "net/mail"
	_reflect "reflect"
)
var members_PtrTo_Address = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Address_String,
}}

var members_PtrTo_AddressParser = GoTypeInfo{Members: GoMembers{
	"Parse": __ptrTo_AddressParser_Parse,
	"ParseList": __ptrTo_AddressParser_ParseList,
}}

var members_Header = GoTypeInfo{Members: GoMembers{
	"AddressList": __header_AddressList,
	"Date": __header_Date,
	"Get": __header_Get,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_mail.Address)(nil))] = &members_PtrTo_Address
	GoTypes[_reflect.TypeOf((*_mail.AddressParser)(nil))] = &members_PtrTo_AddressParser
	GoTypes[_reflect.TypeOf((*_mail.Header)(nil)).Elem()] = &members_Header
}

GO TYPE net/rpc.Call from net/rpc/client.go:
func ExtractGoObjectCall(args []Object, index int) *_rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Call:
			return &r
		case *_rpc.Call:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

// func _mapToCall(o Map) *_rpc.Call {
// 	return &_rpc.Call{}
// }

// func _vectorToCall(o *Vector) *_rpc.Call {
// 	return &_rpc.Call{
// 		ServiceMethod: AssertString(o.Nth(0), "").S,
// 		Args: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Reply: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Error: _errors.New(AssertString(o.Nth(3), "").S),
// 		Done: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructCall(_v Object) *_rpc.Call {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.Call:
// 			return &_g
// 		case *_rpc.Call:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCall(_o.(Map))
// 	case *Vector:
// 		return _vectorToCall(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or: Map or Vector"))
// }

GO TYPE net/rpc.Client from net/rpc/client.go:
func ExtractGoObjectClient(args []Object, index int) *_rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Client:
			return &r
		case *_rpc.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *_rpc.Client {
	return &_rpc.Client{}
}

func _vectorToClient(o *Vector) *_rpc.Client {
	return &_rpc.Client{}
}

func _ConstructClient(_v Object) *_rpc.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Client:
			return &_g
		case *_rpc.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or: Map or Vector"))
}

GO TYPE net/rpc.ClientCodec from net/rpc/client.go:
func ExtractGoObjectClientCodec(args []Object, index int) *_rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ClientCodec:
			return &r
		case *_rpc.ClientCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

// func _ConstructClientCodec(_v Object) _rpc.ClientCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ClientCodec:
// 			return _g
// 		case *_rpc.ClientCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ClientCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ClientCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ClientCodec] or: whatever"))
// }

GO TYPE net/rpc.Request from net/rpc/server.go:
func ExtractGoObjectRequest(args []Object, index int) *_rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Request:
			return &r
		case *_rpc.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *_rpc.Request {
	return &_rpc.Request{}
}

func _vectorToRequest(o *Vector) *_rpc.Request {
	return &_rpc.Request{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRequest(_v Object) *_rpc.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Request:
			return &_g
		case *_rpc.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or: Map or Vector"))
}

GO TYPE net/rpc.Response from net/rpc/server.go:
func ExtractGoObjectResponse(args []Object, index int) *_rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Response:
			return &r
		case *_rpc.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *_rpc.Response {
	return &_rpc.Response{}
}

func _vectorToResponse(o *Vector) *_rpc.Response {
	return &_rpc.Response{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Error: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructResponse(_v Object) *_rpc.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Response:
			return &_g
		case *_rpc.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or: Map or Vector"))
}

GO TYPE net/rpc.Server from net/rpc/server.go:
func ExtractGoObjectServer(args []Object, index int) *_rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Server:
			return &r
		case *_rpc.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *_rpc.Server {
	return &_rpc.Server{}
}

func _vectorToServer(o *Vector) *_rpc.Server {
	return &_rpc.Server{}
}

func _ConstructServer(_v Object) *_rpc.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Server:
			return &_g
		case *_rpc.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or: Map or Vector"))
}

GO TYPE net/rpc.ServerCodec from net/rpc/server.go:
func ExtractGoObjectServerCodec(args []Object, index int) *_rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerCodec:
			return &r
		case *_rpc.ServerCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

// func _ConstructServerCodec(_v Object) _rpc.ServerCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ServerCodec:
// 			return _g
// 		case *_rpc.ServerCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ServerCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ServerCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerCodec] or: whatever"))
// }

GO TYPE net/rpc.ServerError from net/rpc/client.go:
func ExtractGoObjectServerError(args []Object, index int) *_rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerError:
			return &r
		case *_rpc.ServerError:
			return r
		}
	case String:
		v := _rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _ConstructServerError(_v Object) _rpc.ServerError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.ServerError:
			return _g
		case *_rpc.ServerError:
			return *_g
		}
	case String:
		return _rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or: String"))
}

GO FUNC net/rpc.Accept from net/rpc/server.go:
// func __accept(lis ABEND987(genutils.go: imports not yet supported: net.Listener)) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func __dialHTTP(network string, address string) Object {
	_res1, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func __dialHTTPPath(network string, address string, path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func __handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _rpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func __newClientWithCodec(codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func __newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.Register from net/rpc/server.go:
// func __register(rcvr interface {})  {
// 	_res := _rpc.Register(rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.RegisterName from net/rpc/server.go:
// func __registerName(name string, rcvr interface {})  {
// 	_res := _rpc.RegisterName(name, rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func __serveCodec(codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.__ptrTo_Client_Call from net/rpc/client.go:
// func __ptrTo_Client_Call(o GoObject, args Object) Object {
// (serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Client_Close from net/rpc/client.go:
func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/rpc.Client)Close()", args, 0, 0)
	_res := o.O.(*_rpc.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__ptrTo_Client_Go from net/rpc/client.go:
// func __ptrTo_Client_Go(o GoObject, args Object) Object {
// (serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_Accept from net/rpc/server.go:
// func __ptrTo_Server_Accept(o GoObject, args Object) Object {
// lis ABEND987(genutils.go: imports not yet supported: net.Listener)}

GO FUNC net/rpc.__ptrTo_Server_HandleHTTP from net/rpc/server.go:
// func __ptrTo_Server_HandleHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc.__ptrTo_Server_Register from net/rpc/server.go:
// func __ptrTo_Server_Register(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_RegisterName from net/rpc/server.go:
// func __ptrTo_Server_RegisterName(o GoObject, args Object) Object {
// (name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_ServeCodec from net/rpc/server.go:
// func __ptrTo_Server_ServeCodec(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc.__ptrTo_Server_ServeConn from net/rpc/server.go:
// func __ptrTo_Server_ServeConn(o GoObject, args Object) Object {
// conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)}

GO FUNC net/rpc.__ptrTo_Server_ServeHTTP from net/rpc/server.go:
// func __ptrTo_Server_ServeHTTP(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/rpc.__ptrTo_Server_ServeRequest from net/rpc/server.go:
func __ptrTo_Server_ServeRequest(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/rpc.Server)ServeRequest()", args, 1, 1)
	codec := ExtractGo_go_std_net_rpc__ServerCodec("(*_net/rpc.Server)ServeRequest()", "codec", _argList, 0)
	_res := o.O.(*_rpc.Server).ServeRequest(codec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__serverError_Error from net/rpc/client.go:
func __serverError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/rpc.ServerError)Error()", args, 0, 0)
	_res := o.O.(_rpc.ServerError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package rpc

import (
	. "github.com/candid82/joker/core"
	_rpc "net/rpc"
	_reflect "reflect"
)
var members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Client_Close,
}}

var members_PtrTo_Server = GoTypeInfo{Members: GoMembers{
	"ServeRequest": __ptrTo_Server_ServeRequest,
}}

var members_ServerError = GoTypeInfo{Members: GoMembers{
	"Error": __serverError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_rpc.Client)(nil))] = &members_PtrTo_Client
	GoTypes[_reflect.TypeOf((*_rpc.Server)(nil))] = &members_PtrTo_Server
	GoTypes[_reflect.TypeOf((*_rpc.ServerError)(nil)).Elem()] = &members_ServerError
}

GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func __dial(network string, address string) Object {
	_res1, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClient(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func __newClientCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClientCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func __newServerCodec(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewServerCodec(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func __serveConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package jsonrpc

import (
	. "github.com/candid82/joker/core"
	_jsonrpc "net/rpc/jsonrpc"
)

func init() {
}

GO TYPE net/smtp.Auth from net/smtp/auth.go:
func ExtractGoObjectAuth(args []Object, index int) *_smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Auth:
			return &r
		case *_smtp.Auth:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

// func _ConstructAuth(_v Object) _smtp.Auth {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Auth:
// 			return _g
// 		case *_smtp.Auth:
// 			return *_g
// 		}
// 	default:
// 		return _smtp.Auth(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Auth))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Auth] or: whatever"))
// }

GO TYPE net/smtp.Client from net/smtp/smtp.go:
func ExtractGoObjectClient(args []Object, index int) *_smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Client:
			return &r
		case *_smtp.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

// func _mapToClient(o Map) *_smtp.Client {
// 	return &_smtp.Client{}
// }

// func _vectorToClient(o *Vector) *_smtp.Client {
// 	return &_smtp.Client{
// 		Text: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_smtp.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Client:
// 			return &_g
// 		case *_smtp.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or: Map or Vector"))
// }

GO TYPE net/smtp.ServerInfo from net/smtp/auth.go:
func ExtractGoObjectServerInfo(args []Object, index int) *_smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.ServerInfo:
			return &r
		case *_smtp.ServerInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

// func _mapToServerInfo(o Map) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{}
// }

// func _vectorToServerInfo(o *Vector) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{
// 		Name: AssertString(o.Nth(0), "").S,
// 		TLS: ToBool(o.Nth(1)),
// 		Auth: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructServerInfo(_v Object) *_smtp.ServerInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.ServerInfo:
// 			return &_g
// 		case *_smtp.ServerInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServerInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToServerInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or: Map or Vector"))
// }

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func __cRAMMD5Auth(username string, secret string) Object {
	_res := _smtp.CRAMMD5Auth(username, secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func __dial(addr string) Object {
	_res1, _res2 := _smtp.Dial(addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func __newClient(conn ABEND987(genutils.go: imports not yet supported: net.Conn), host string) Object {
// 	_res1, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func __plainAuth(identity string, username string, password string, host string) Object {
	_res := _smtp.PlainAuth(identity, username, password, host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.SendMail from net/smtp/smtp.go:
// func __sendMail(addr string, a _smtp.Auth, from string, to []string, msg []byte)  {
// 	_res := _smtp.SendMail(addr, a, from, to, msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/smtp.__ptrTo_Client_Auth from net/smtp/smtp.go:
func __ptrTo_Client_Auth(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Auth()", args, 1, 1)
	a := ExtractGo_go_std_net_smtp__Auth("(*_net/smtp.Client)Auth()", "a", _argList, 0)
	_res := o.O.(*_smtp.Client).Auth(a)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Close from net/smtp/smtp.go:
func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Close()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Data from net/smtp/smtp.go:
func __ptrTo_Client_Data(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Data()", args, 0, 0)
	_res1, _res2 := o.O.(*_smtp.Client).Data()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.__ptrTo_Client_Extension from net/smtp/smtp.go:
func __ptrTo_Client_Extension(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Extension()", args, 1, 1)
	ext := ExtractGoString("(*_net/smtp.Client)Extension()", "ext", _argList, 0)
	_res1, _res2 := o.O.(*_smtp.Client).Extension(ext)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(MakeString(_res2))
	return _res
}

GO FUNC net/smtp.__ptrTo_Client_Hello from net/smtp/smtp.go:
func __ptrTo_Client_Hello(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Hello()", args, 1, 1)
	localName := ExtractGoString("(*_net/smtp.Client)Hello()", "localName", _argList, 0)
	_res := o.O.(*_smtp.Client).Hello(localName)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Mail from net/smtp/smtp.go:
func __ptrTo_Client_Mail(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Mail()", args, 1, 1)
	from := ExtractGoString("(*_net/smtp.Client)Mail()", "from", _argList, 0)
	_res := o.O.(*_smtp.Client).Mail(from)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Noop from net/smtp/smtp.go:
func __ptrTo_Client_Noop(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Noop()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Noop()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Quit from net/smtp/smtp.go:
func __ptrTo_Client_Quit(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Quit()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Quit()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Rcpt from net/smtp/smtp.go:
func __ptrTo_Client_Rcpt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Rcpt()", args, 1, 1)
	to := ExtractGoString("(*_net/smtp.Client)Rcpt()", "to", _argList, 0)
	_res := o.O.(*_smtp.Client).Rcpt(to)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Reset from net/smtp/smtp.go:
func __ptrTo_Client_Reset(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Reset()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Reset()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_StartTLS from net/smtp/smtp.go:
// func __ptrTo_Client_StartTLS(o GoObject, args Object) Object {
// config *ABEND987(genutils.go: imports not yet supported: tls.Config)}

GO FUNC net/smtp.__ptrTo_Client_TLSConnectionState from net/smtp/smtp.go:
func __ptrTo_Client_TLSConnectionState(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)TLSConnectionState()", args, 0, 0)
	state, ok := o.O.(*_smtp.Client).TLSConnectionState()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(state))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/smtp.__ptrTo_Client_Verify from net/smtp/smtp.go:
func __ptrTo_Client_Verify(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Verify()", args, 1, 1)
	addr := ExtractGoString("(*_net/smtp.Client)Verify()", "addr", _argList, 0)
	_res := o.O.(*_smtp.Client).Verify(addr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package smtp

import (
	. "github.com/candid82/joker/core"
	_smtp "net/smtp"
	_reflect "reflect"
)
var members_PtrTo_Client = GoTypeInfo{Members: GoMembers{
	"Auth": __ptrTo_Client_Auth,
	"Close": __ptrTo_Client_Close,
	"Data": __ptrTo_Client_Data,
	"Extension": __ptrTo_Client_Extension,
	"Hello": __ptrTo_Client_Hello,
	"Mail": __ptrTo_Client_Mail,
	"Noop": __ptrTo_Client_Noop,
	"Quit": __ptrTo_Client_Quit,
	"Rcpt": __ptrTo_Client_Rcpt,
	"Reset": __ptrTo_Client_Reset,
	"TLSConnectionState": __ptrTo_Client_TLSConnectionState,
	"Verify": __ptrTo_Client_Verify,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_smtp.Client)(nil))] = &members_PtrTo_Client
}

GO TYPE net/textproto.Conn from net/textproto/textproto.go:
func ExtractGoObjectConn(args []Object, index int) *_textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Conn:
			return &r
		case *_textproto.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _vectorToConn(o *Vector) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _ConstructConn(_v Object) *_textproto.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Conn:
			return &_g
		case *_textproto.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or: Map or Vector"))
}

GO TYPE net/textproto.Error from net/textproto/textproto.go:
func ExtractGoObjectError(args []Object, index int) *_textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Error:
			return &r
		case *_textproto.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *_textproto.Error {
	return &_textproto.Error{}
}

func _vectorToError(o *Vector) *_textproto.Error {
	return &_textproto.Error{
		Code: AssertInt(o.Nth(0), "").I,
		Msg: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructError(_v Object) *_textproto.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Error:
			return &_g
		case *_textproto.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or: Map or Vector"))
}

GO TYPE net/textproto.MIMEHeader from net/textproto/header.go:
func ExtractGoObjectMIMEHeader(args []Object, index int) *_textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.MIMEHeader:
			return &r
		case *_textproto.MIMEHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _ConstructMIMEHeader(_v Object) _textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.MIMEHeader:
// 			return _g
// 		case *_textproto.MIMEHeader:
// 			return *_g
// 		}
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or: whatever"))
// }

GO TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
func ExtractGoObjectPipeline(args []Object, index int) *_textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Pipeline:
			return &r
		case *_textproto.Pipeline:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _vectorToPipeline(o *Vector) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _ConstructPipeline(_v Object) *_textproto.Pipeline {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Pipeline:
			return &_g
		case *_textproto.Pipeline:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	case *Vector:
		return _vectorToPipeline(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or: Map or Vector"))
}

GO TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.ProtocolError:
			return &r
		case *_textproto.ProtocolError:
			return r
		}
	case String:
		v := _textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _ConstructProtocolError(_v Object) _textproto.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.ProtocolError:
			return _g
		case *_textproto.ProtocolError:
			return *_g
		}
	case String:
		return _textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or: String"))
}

GO TYPE net/textproto.Reader from net/textproto/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Reader:
			return &r
		case *_textproto.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

// func _mapToReader(o Map) *_textproto.Reader {
// 	return &_textproto.Reader{}
// }

// func _vectorToReader(o *Vector) *_textproto.Reader {
// 	return &_textproto.Reader{
// 		R: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructReader(_v Object) *_textproto.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Reader:
// 			return &_g
// 		case *_textproto.Reader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or: Map or Vector"))
// }

GO TYPE net/textproto.Writer from net/textproto/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Writer:
			return &r
		case *_textproto.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

// func _mapToWriter(o Map) *_textproto.Writer {
// 	return &_textproto.Writer{}
// }

// func _vectorToWriter(o *Vector) *_textproto.Writer {
// 	return &_textproto.Writer{
// 		W: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructWriter(_v Object) *_textproto.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Writer:
// 			return &_g
// 		case *_textproto.Writer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToWriter(_o.(Map))
// 	case *Vector:
// 		return _vectorToWriter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or: Map or Vector"))
// }

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func __dial(network string, addr string) Object {
	_res1, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func __newConn(conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _textproto.NewConn(conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func __newReader(r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _textproto.NewReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func __newWriter(w *ABEND987(genutils.go: imports not yet supported: bufio.Writer)) Object {
// 	_res := _textproto.NewWriter(w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func __trimBytes(b []byte) Object {
// 	_res := _textproto.TrimBytes(b)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC net/textproto.__mIMEHeader_Add from net/textproto/header.go:
// func __mIMEHeader_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__mIMEHeader_Del from net/textproto/header.go:
// func __mIMEHeader_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__mIMEHeader_Get from net/textproto/header.go:
func __mIMEHeader_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/textproto.MIMEHeader)Get()", args, 1, 1)
	key := ExtractGoString("(_net/textproto.MIMEHeader)Get()", "key", _argList, 0)
	_res := o.O.(_textproto.MIMEHeader).Get(key)
	return MakeString(_res)
}

GO FUNC net/textproto.__mIMEHeader_Set from net/textproto/header.go:
// func __mIMEHeader_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__protocolError_Error from net/textproto/textproto.go:
func __protocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/textproto.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(_textproto.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/textproto.__ptrTo_Conn_Close from net/textproto/textproto.go:
func __ptrTo_Conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Conn)Close()", args, 0, 0)
	_res := o.O.(*_textproto.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/textproto.__ptrTo_Conn_Cmd from net/textproto/textproto.go:
// func __ptrTo_Conn_Cmd(o GoObject, args Object) Object {
// (format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC net/textproto.__ptrTo_Error_Error from net/textproto/textproto.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Error)Error()", args, 0, 0)
	_res := o.O.(*_textproto.Error).Error()
	return MakeString(_res)
}

GO FUNC net/textproto.__ptrTo_Pipeline_EndRequest from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_EndRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_EndResponse from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_EndResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_Next from net/textproto/pipeline.go:
func __ptrTo_Pipeline_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Pipeline)Next()", args, 0, 0)
	_res := o.O.(*_textproto.Pipeline).Next()
	return MakeBigIntU(uint64(_res))
}

GO FUNC net/textproto.__ptrTo_Pipeline_StartRequest from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_StartRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_StartResponse from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_StartResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Reader_DotReader from net/textproto/reader.go:
func __ptrTo_Reader_DotReader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)DotReader()", args, 0, 0)
	_res := o.O.(*_textproto.Reader).DotReader()
	return MakeGoObject(_res)
}

GO FUNC net/textproto.__ptrTo_Reader_ReadCodeLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadCodeLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadCodeLine()", args, 1, 1)
	expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadCodeLine()", "expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadCodeLine(expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadContinuedLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadContinuedLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadContinuedLineBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadContinuedLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadDotBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadDotBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadDotLines from net/textproto/reader.go:
func __ptrTo_Reader_ReadDotLines(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotLines()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotLines()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadLineBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadMIMEHeader from net/textproto/reader.go:
func __ptrTo_Reader_ReadMIMEHeader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadMIMEHeader()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadMIMEHeader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadResponse from net/textproto/reader.go:
func __ptrTo_Reader_ReadResponse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadResponse()", args, 1, 1)
	expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadResponse()", "expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadResponse(expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Writer_DotWriter from net/textproto/writer.go:
func __ptrTo_Writer_DotWriter(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Writer)DotWriter()", args, 0, 0)
	_res := o.O.(*_textproto.Writer).DotWriter()
	return MakeGoObject(_res)
}

GO FUNC net/textproto.__ptrTo_Writer_PrintfLine from net/textproto/writer.go:
// func __ptrTo_Writer_PrintfLine(o GoObject, args Object) Object {
// (format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package textproto

import (
	. "github.com/candid82/joker/core"
	_textproto "net/textproto"
	_reflect "reflect"
)
var members_PtrTo_Conn = GoTypeInfo{Members: GoMembers{
	"Close": __ptrTo_Conn_Close,
}}

var members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Error_Error,
}}

var members_MIMEHeader = GoTypeInfo{Members: GoMembers{
	"Get": __mIMEHeader_Get,
}}

var members_PtrTo_Pipeline = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_Pipeline_Next,
}}

var members_ProtocolError = GoTypeInfo{Members: GoMembers{
	"Error": __protocolError_Error,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"DotReader": __ptrTo_Reader_DotReader,
	"ReadCodeLine": __ptrTo_Reader_ReadCodeLine,
	"ReadContinuedLine": __ptrTo_Reader_ReadContinuedLine,
	"ReadContinuedLineBytes": __ptrTo_Reader_ReadContinuedLineBytes,
	"ReadDotBytes": __ptrTo_Reader_ReadDotBytes,
	"ReadDotLines": __ptrTo_Reader_ReadDotLines,
	"ReadLine": __ptrTo_Reader_ReadLine,
	"ReadLineBytes": __ptrTo_Reader_ReadLineBytes,
	"ReadMIMEHeader": __ptrTo_Reader_ReadMIMEHeader,
	"ReadResponse": __ptrTo_Reader_ReadResponse,
}}

var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"DotWriter": __ptrTo_Writer_DotWriter,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_textproto.Conn)(nil))] = &members_PtrTo_Conn
	GoTypes[_reflect.TypeOf((*_textproto.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_textproto.MIMEHeader)(nil)).Elem()] = &members_MIMEHeader
	GoTypes[_reflect.TypeOf((*_textproto.Pipeline)(nil))] = &members_PtrTo_Pipeline
	GoTypes[_reflect.TypeOf((*_textproto.ProtocolError)(nil)).Elem()] = &members_ProtocolError
	GoTypes[_reflect.TypeOf((*_textproto.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_textproto.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE net/url.Error from net/url/url.go:
func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{}
}

func _vectorToError(o *Vector) *_url.Error {
	return &_url.Error{
		Op: AssertString(o.Nth(0), "").S,
		URL: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructError(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Error:
			return &_g
		case *_url.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map or Vector"))
}

GO TYPE net/url.EscapeError from net/url/url.go:
func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _ConstructEscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.EscapeError:
			return _g
		case *_url.EscapeError:
			return *_g
		}
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _ConstructInvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.InvalidHostError:
			return _g
		case *_url.InvalidHostError:
			return *_g
		}
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

GO TYPE net/url.URL from net/url/url.go:
func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *_url.URL {
// 	return &_url.URL{}
// }

// func _vectorToURL(o *Vector) *_url.URL {
// 	return &_url.URL{
// 		Scheme: AssertString(o.Nth(0), "").S,
// 		Opaque: AssertString(o.Nth(1), "").S,
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: AssertString(o.Nth(3), "").S,
// 		Path: AssertString(o.Nth(4), "").S,
// 		RawPath: AssertString(o.Nth(5), "").S,
// 		ForceQuery: ToBool(o.Nth(6)),
// 		RawQuery: AssertString(o.Nth(7), "").S,
// 		Fragment: AssertString(o.Nth(8), "").S,
// 	}
// }

// func _ConstructURL(_v Object) *_url.URL {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.URL:
// 			return &_g
// 		case *_url.URL:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	case *Vector:
// 		return _vectorToURL(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map or Vector"))
// }

GO TYPE net/url.Userinfo from net/url/url.go:
func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _vectorToUserinfo(o *Vector) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _ConstructUserinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Userinfo:
			return &_g
		case *_url.Userinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	case *Vector:
		return _vectorToUserinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map or Vector"))
}

GO TYPE net/url.Values from net/url/url.go:
func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _ConstructValues(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.Values:
// 			return _g
// 		case *_url.Values:
// 			return *_g
// 		}
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

GO FUNC net/url.Parse from net/url/url.go:
func __parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func __parseQuery(query string) Object {
	_res1, _res2 := _url.ParseQuery(query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func __parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func __pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func __queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func __user(username string) Object {
	_res := _url.User(username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func __userPassword(username string, password string) Object {
	_res := _url.UserPassword(username, password)
	return MakeGoObject(_res)
}

GO FUNC net/url.__escapeError_Error from net/url/url.go:
func __escapeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(_url.EscapeError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__invalidHostError_Error from net/url/url.go:
func __invalidHostError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(_url.InvalidHostError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Error from net/url/url.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Error()", args, 0, 0)
	_res := o.O.(*_url.Error).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Temporary from net/url/url.go:
func __ptrTo_Error_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*_url.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_Error_Timeout from net/url/url.go:
func __ptrTo_Error_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*_url.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_EscapedPath from net/url/url.go:
func __ptrTo_URL_EscapedPath(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*_url.URL).EscapedPath()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Hostname from net/url/url.go:
func __ptrTo_URL_Hostname(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*_url.URL).Hostname()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_IsAbs from net/url/url.go:
func __ptrTo_URL_IsAbs(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*_url.URL).IsAbs()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_MarshalBinary from net/url/url.go:
func __ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*_url.URL).MarshalBinary()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Parse from net/url/url.go:
func __ptrTo_URL_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/url.URL)Parse()", args, 1, 1)
	ref := ExtractGoString("(*_net/url.URL)Parse()", "ref", _argList, 0)
	_res1, _res2 := o.O.(*_url.URL).Parse(ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Port from net/url/url.go:
func __ptrTo_URL_Port(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Port()", args, 0, 0)
	_res := o.O.(*_url.URL).Port()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Query from net/url/url.go:
func __ptrTo_URL_Query(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Query()", args, 0, 0)
	_res := o.O.(*_url.URL).Query()
	return MakeGoObject(_res)
}

GO FUNC net/url.__ptrTo_URL_RequestURI from net/url/url.go:
func __ptrTo_URL_RequestURI(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*_url.URL).RequestURI()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_ResolveReference from net/url/url.go:
// func __ptrTo_URL_ResolveReference(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/url.URL)ResolveReference()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for ref at: /usr/local/go/src/net/url/url.go:1002:36)
// 	_res := o.O.(*_url.URL).ResolveReference(ref)
// 	return MakeGoObject(_res)
// }

GO FUNC net/url.__ptrTo_URL_String from net/url/url.go:
func __ptrTo_URL_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)String()", args, 0, 0)
	_res := o.O.(*_url.URL).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_UnmarshalBinary from net/url/url.go:
// func __ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(text)))}

GO FUNC net/url.__ptrTo_Userinfo_Password from net/url/url.go:
func __ptrTo_Userinfo_Password(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*_url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC net/url.__ptrTo_Userinfo_String from net/url/url.go:
func __ptrTo_Userinfo_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Userinfo_Username from net/url/url.go:
func __ptrTo_Userinfo_Username(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).Username()
	return MakeString(_res)
}

GO FUNC net/url.__values_Add from net/url/url.go:
// func __values_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Del from net/url/url.go:
// func __values_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Encode from net/url/url.go:
func __values_Encode(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.Values)Encode()", args, 0, 0)
	_res := o.O.(_url.Values).Encode()
	return MakeString(_res)
}

GO FUNC net/url.__values_Get from net/url/url.go:
func __values_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/url.Values)Get()", args, 1, 1)
	key := ExtractGoString("(_net/url.Values)Get()", "key", _argList, 0)
	_res := o.O.(_url.Values).Get(key)
	return MakeString(_res)
}

GO FUNC net/url.__values_Set from net/url/url.go:
// func __values_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package url

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_url "net/url"
	_reflect "reflect"
)
var members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Error_Error,
	"Temporary": __ptrTo_Error_Temporary,
	"Timeout": __ptrTo_Error_Timeout,
}}

var members_EscapeError = GoTypeInfo{Members: GoMembers{
	"Error": __escapeError_Error,
}}

var members_InvalidHostError = GoTypeInfo{Members: GoMembers{
	"Error": __invalidHostError_Error,
}}

var members_PtrTo_URL = GoTypeInfo{Members: GoMembers{
	"EscapedPath": __ptrTo_URL_EscapedPath,
	"Hostname": __ptrTo_URL_Hostname,
	"IsAbs": __ptrTo_URL_IsAbs,
	"MarshalBinary": __ptrTo_URL_MarshalBinary,
	"Parse": __ptrTo_URL_Parse,
	"Port": __ptrTo_URL_Port,
	"Query": __ptrTo_URL_Query,
	"RequestURI": __ptrTo_URL_RequestURI,
	"String": __ptrTo_URL_String,
}}

var members_PtrTo_Userinfo = GoTypeInfo{Members: GoMembers{
	"Password": __ptrTo_Userinfo_Password,
	"String": __ptrTo_Userinfo_String,
	"Username": __ptrTo_Userinfo_Username,
}}

var members_Values = GoTypeInfo{Members: GoMembers{
	"Encode": __values_Encode,
	"Get": __values_Get,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_url.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_url.EscapeError)(nil)).Elem()] = &members_EscapeError
	GoTypes[_reflect.TypeOf((*_url.InvalidHostError)(nil)).Elem()] = &members_InvalidHostError
	GoTypes[_reflect.TypeOf((*_url.URL)(nil))] = &members_PtrTo_URL
	GoTypes[_reflect.TypeOf((*_url.Userinfo)(nil))] = &members_PtrTo_Userinfo
	GoTypes[_reflect.TypeOf((*_url.Values)(nil)).Elem()] = &members_Values
}

GO TYPE os.File from os/types.go:
func ExtractGoObjectFile(args []Object, index int) *_os.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.File:
			return &r
		case *_os.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.File]"))
}

func _mapToFile(o Map) *_os.File {
	return &_os.File{}
}

func _vectorToFile(o *Vector) *_os.File {
	return &_os.File{}
}

func _ConstructFile(_v Object) *_os.File {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.File:
			return &_g
		case *_os.File:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFile(_o.(Map))
	case *Vector:
		return _vectorToFile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.File] or: Map or Vector"))
}

GO TYPE os.FileInfo from os/types.go:
func ExtractGoObjectFileInfo(args []Object, index int) *_os.FileInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.FileInfo:
			return &r
		case *_os.FileInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.FileInfo]"))
}

// func _ConstructFileInfo(_v Object) _os.FileInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _os.FileInfo:
// 			return _g
// 		case *_os.FileInfo:
// 			return *_g
// 		}
// 	default:
// 		return _os.FileInfo(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for FileInfo))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[os.FileInfo] or: whatever"))
// }

GO TYPE os.FileMode from os/types.go:
func ExtractGoObjectFileMode(args []Object, index int) *_os.FileMode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.FileMode:
			return &r
		case *_os.FileMode:
			return r
		}
	case Number:
		v := _os.FileMode(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.FileMode]"))
}

func _ConstructFileMode(_v Object) _os.FileMode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.FileMode:
			return _g
		case *_os.FileMode:
			return *_g
		}
	case Number:
		return _os.FileMode(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.FileMode] or: Number"))
}

GO TYPE os.LinkError from os/file.go:
func ExtractGoObjectLinkError(args []Object, index int) *_os.LinkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.LinkError:
			return &r
		case *_os.LinkError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.LinkError]"))
}

func _mapToLinkError(o Map) *_os.LinkError {
	return &_os.LinkError{}
}

func _vectorToLinkError(o *Vector) *_os.LinkError {
	return &_os.LinkError{
		Op: AssertString(o.Nth(0), "").S,
		Old: AssertString(o.Nth(1), "").S,
		New: AssertString(o.Nth(2), "").S,
		Err: _errors.New(AssertString(o.Nth(3), "").S),
	}
}

func _ConstructLinkError(_v Object) *_os.LinkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.LinkError:
			return &_g
		case *_os.LinkError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLinkError(_o.(Map))
	case *Vector:
		return _vectorToLinkError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.LinkError] or: Map or Vector"))
}

GO TYPE os.PathError from os/error.go:
func ExtractGoObjectPathError(args []Object, index int) *_os.PathError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.PathError:
			return &r
		case *_os.PathError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.PathError]"))
}

func _mapToPathError(o Map) *_os.PathError {
	return &_os.PathError{}
}

func _vectorToPathError(o *Vector) *_os.PathError {
	return &_os.PathError{
		Op: AssertString(o.Nth(0), "").S,
		Path: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructPathError(_v Object) *_os.PathError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.PathError:
			return &_g
		case *_os.PathError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPathError(_o.(Map))
	case *Vector:
		return _vectorToPathError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.PathError] or: Map or Vector"))
}

GO TYPE os.ProcAttr from os/exec.go:
func ExtractGoObjectProcAttr(args []Object, index int) *_os.ProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.ProcAttr:
			return &r
		case *_os.ProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.ProcAttr]"))
}

// func _mapToProcAttr(o Map) *_os.ProcAttr {
// 	return &_os.ProcAttr{}
// }

// func _vectorToProcAttr(o *Vector) *_os.ProcAttr {
// 	return &_os.ProcAttr{
// 		Dir: AssertString(o.Nth(0), "").S,
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Files: ABEND048(codegen.go: no conversion from Clojure for []*os.File (*os.File)),
// 		Sys: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructProcAttr(_v Object) *_os.ProcAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _os.ProcAttr:
// 			return &_g
// 		case *_os.ProcAttr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToProcAttr(_o.(Map))
// 	case *Vector:
// 		return _vectorToProcAttr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[os.ProcAttr] or: Map or Vector"))
// }

GO TYPE os.Process from os/exec.go:
func ExtractGoObjectProcess(args []Object, index int) *_os.Process {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.Process:
			return &r
		case *_os.Process:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.Process]"))
}

func _mapToProcess(o Map) *_os.Process {
	return &_os.Process{}
}

func _vectorToProcess(o *Vector) *_os.Process {
	return &_os.Process{
		Pid: AssertInt(o.Nth(0), "").I,
	}
}

func _ConstructProcess(_v Object) *_os.Process {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.Process:
			return &_g
		case *_os.Process:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcess(_o.(Map))
	case *Vector:
		return _vectorToProcess(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.Process] or: Map or Vector"))
}

GO TYPE os.ProcessState from os/exec_posix.go:
func ExtractGoObjectProcessState(args []Object, index int) *_os.ProcessState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.ProcessState:
			return &r
		case *_os.ProcessState:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.ProcessState]"))
}

func _mapToProcessState(o Map) *_os.ProcessState {
	return &_os.ProcessState{}
}

func _vectorToProcessState(o *Vector) *_os.ProcessState {
	return &_os.ProcessState{}
}

func _ConstructProcessState(_v Object) *_os.ProcessState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.ProcessState:
			return &_g
		case *_os.ProcessState:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProcessState(_o.(Map))
	case *Vector:
		return _vectorToProcessState(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.ProcessState] or: Map or Vector"))
}

GO TYPE os.Signal from os/exec.go:
func ExtractGoObjectSignal(args []Object, index int) *_os.Signal {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.Signal:
			return &r
		case *_os.Signal:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.Signal]"))
}

// func _ConstructSignal(_v Object) _os.Signal {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _os.Signal:
// 			return _g
// 		case *_os.Signal:
// 			return *_g
// 		}
// 	default:
// 		return _os.Signal(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Signal))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[os.Signal] or: whatever"))
// }

GO TYPE os.SyscallError from os/error.go:
func ExtractGoObjectSyscallError(args []Object, index int) *_os.SyscallError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _os.SyscallError:
			return &r
		case *_os.SyscallError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os.SyscallError]"))
}

func _mapToSyscallError(o Map) *_os.SyscallError {
	return &_os.SyscallError{}
}

func _vectorToSyscallError(o *Vector) *_os.SyscallError {
	return &_os.SyscallError{
		Syscall: AssertString(o.Nth(0), "").S,
		Err: _errors.New(AssertString(o.Nth(1), "").S),
	}
}

func _ConstructSyscallError(_v Object) *_os.SyscallError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _os.SyscallError:
			return &_g
		case *_os.SyscallError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSyscallError(_o.(Map))
	case *Vector:
		return _vectorToSyscallError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[os.SyscallError] or: Map or Vector"))
}

GO FUNC os.Chtimes from os/file_posix.go:
// func __chtimes(name string, atime ABEND987(genutils.go: imports not yet supported: time.Time), mtime ABEND987(genutils.go: imports not yet supported: time.Time))  {
// 	_res := _os.Chtimes(name, atime, mtime)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC os.Clearenv from os/env.go:
// func __clearenv() Object {
// 	_os.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC os.Create from os/file.go:
func __create(name string) Object {
	_res1, _res2 := _os.Create(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Environ from os/env.go:
func __environ() Object {
	_res := _os.Environ()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC os.Executable from os/executable.go:
func __executable() Object {
	_res1, _res2 := _os.Executable()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Exit from os/proc.go:
// func __exit(code int) Object {
// 	_os.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC os.Expand from os/env.go:
// func __expand(s string, mapping func)  {
// 	_res := _os.Expand(s, mapping)
// 	return MakeString(_res)
// }

GO FUNC os.FindProcess from os/exec.go:
func __findProcess(pid int) Object {
	_res1, _res2 := _os.FindProcess(pid)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getgroups from os/proc.go:
func __getgroups() Object {
	_res1, _res2 := _os.Getgroups()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getwd from os/getwd.go:
func __getwd() Object {
	dir, err := _os.Getwd()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Hostname from os/sys.go:
func __hostname() Object {
	name, err := _os.Hostname()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.LookupEnv from os/env.go:
func __lookupEnv(key string) Object {
	_res1, _res2 := _os.LookupEnv(key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC os.Lstat from os/stat.go:
func __lstat(name string) Object {
	_res1, _res2 := _os.Lstat(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.NewFile from os/file_unix.go:
func __newFile(fd uintptr, name string) Object {
	_res := _os.NewFile(fd, name)
	return MakeGoObject(_res)
}

GO FUNC os.Open from os/file.go:
func __open(name string) Object {
	_res1, _res2 := _os.Open(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.OpenFile from os/file.go:
func __openFile(name string, flag int, perm _os.FileMode) Object {
	_res1, _res2 := _os.OpenFile(name, flag, perm)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Pipe from os/pipe_bsd.go:
func __pipe() Object {
	r, w, err := _os.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(r))
	_res = _res.Conjoin(MakeGoObject(w))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Readlink from os/file_posix.go:
func __readlink(name string) Object {
	_res1, _res2 := _os.Readlink(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.StartProcess from os/exec.go:
// func __startProcess(name string, argv []string, attr *_os.ProcAttr) Object {
// 	_res1, _res2 := _os.StartProcess(name, argv, attr)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.Stat from os/stat.go:
func __stat(name string) Object {
	_res1, _res2 := _os.Stat(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.UserCacheDir from os/file.go:
func __userCacheDir() Object {
	_res1, _res2 := _os.UserCacheDir()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.UserHomeDir from os/file.go:
func __userHomeDir() Object {
	_res1, _res2 := _os.UserHomeDir()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.__fileMode_IsDir from os/types.go:
func __fileMode_IsDir(o GoObject, args Object) Object {
	CheckGoArity("(_os.FileMode)IsDir()", args, 0, 0)
	_res := o.O.(_os.FileMode).IsDir()
	return MakeBoolean(_res)
}

GO FUNC os.__fileMode_IsRegular from os/types.go:
func __fileMode_IsRegular(o GoObject, args Object) Object {
	CheckGoArity("(_os.FileMode)IsRegular()", args, 0, 0)
	_res := o.O.(_os.FileMode).IsRegular()
	return MakeBoolean(_res)
}

GO FUNC os.__fileMode_Perm from os/types.go:
func __fileMode_Perm(o GoObject, args Object) Object {
	CheckGoArity("(_os.FileMode)Perm()", args, 0, 0)
	_res := o.O.(_os.FileMode).Perm()
	return MakeGoObject(_res)
}

GO FUNC os.__fileMode_String from os/types.go:
func __fileMode_String(o GoObject, args Object) Object {
	CheckGoArity("(_os.FileMode)String()", args, 0, 0)
	_res := o.O.(_os.FileMode).String()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_File_Chdir from os/file_posix.go:
func __ptrTo_File_Chdir(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)Chdir()", args, 0, 0)
	_res := o.O.(*_os.File).Chdir()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_Chmod from os/file.go:
func __ptrTo_File_Chmod(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Chmod()", args, 1, 1)
	mode := ExtractGo_go_std_os__FileMode("(*_os.File)Chmod()", "mode", _argList, 0)
	_res := o.O.(*_os.File).Chmod(mode)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_Chown from os/file_posix.go:
func __ptrTo_File_Chown(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Chown()", args, 2, 2)
	uid := ExtractGoInt("(*_os.File)Chown()", "uid", _argList, 0)
	gid := ExtractGoInt("(*_os.File)Chown()", "gid", _argList, 1)
	_res := o.O.(*_os.File).Chown(uid, gid)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_Close from os/file_unix.go:
func __ptrTo_File_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)Close()", args, 0, 0)
	_res := o.O.(*_os.File).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_Fd from os/file_unix.go:
// func __ptrTo_File_Fd(o GoObject, args Object) Object {
// 	CheckGoArity("(*_os.File)Fd()", args, 0, 0)
// 	_res := o.O.(*_os.File).Fd()
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC os.__ptrTo_File_Name from os/file.go:
func __ptrTo_File_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)Name()", args, 0, 0)
	_res := o.O.(*_os.File).Name()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_File_Read from os/file.go:
// func __ptrTo_File_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC os.__ptrTo_File_ReadAt from os/file.go:
// func __ptrTo_File_ReadAt(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), off)}

GO FUNC os.__ptrTo_File_Readdir from os/dir.go:
func __ptrTo_File_Readdir(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Readdir()", args, 1, 1)
	n := ExtractGoInt("(*_os.File)Readdir()", "n", _argList, 0)
	_res1, _res2 := o.O.(*_os.File).Readdir(n)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.__ptrTo_File_Readdirnames from os/dir.go:
func __ptrTo_File_Readdirnames(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Readdirnames()", args, 1, 1)
	n := ExtractGoInt("(*_os.File)Readdirnames()", "n", _argList, 0)
	names, err := o.O.(*_os.File).Readdirnames(n)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.__ptrTo_File_Seek from os/file.go:
func __ptrTo_File_Seek(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Seek()", args, 2, 2)
	offset := ExtractGoInt64("(*_os.File)Seek()", "offset", _argList, 0)
	whence := ExtractGoInt("(*_os.File)Seek()", "whence", _argList, 1)
	ret, err := o.O.(*_os.File).Seek(offset, whence)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(ret))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.__ptrTo_File_SetDeadline from os/file.go:
// func __ptrTo_File_SetDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC os.__ptrTo_File_SetReadDeadline from os/file.go:
// func __ptrTo_File_SetReadDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC os.__ptrTo_File_SetWriteDeadline from os/file.go:
// func __ptrTo_File_SetWriteDeadline(o GoObject, args Object) Object {
// t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC os.__ptrTo_File_Stat from os/stat_unix.go:
func __ptrTo_File_Stat(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)Stat()", args, 0, 0)
	_res1, _res2 := o.O.(*_os.File).Stat()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.__ptrTo_File_Sync from os/file_posix.go:
func __ptrTo_File_Sync(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)Sync()", args, 0, 0)
	_res := o.O.(*_os.File).Sync()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_SyscallConn from os/file.go:
func __ptrTo_File_SyscallConn(o GoObject, args Object) Object {
	CheckGoArity("(*_os.File)SyscallConn()", args, 0, 0)
	_res1, _res2 := o.O.(*_os.File).SyscallConn()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.__ptrTo_File_Truncate from os/file_posix.go:
func __ptrTo_File_Truncate(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)Truncate()", args, 1, 1)
	size := ExtractGoInt64("(*_os.File)Truncate()", "size", _argList, 0)
	_res := o.O.(*_os.File).Truncate(size)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_File_Write from os/file.go:
// func __ptrTo_File_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC os.__ptrTo_File_WriteAt from os/file.go:
// func __ptrTo_File_WriteAt(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), off)}

GO FUNC os.__ptrTo_File_WriteString from os/file.go:
func __ptrTo_File_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.File)WriteString()", args, 1, 1)
	s := ExtractGoString("(*_os.File)WriteString()", "s", _argList, 0)
	n, err := o.O.(*_os.File).WriteString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.__ptrTo_LinkError_Error from os/file.go:
func __ptrTo_LinkError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_os.LinkError)Error()", args, 0, 0)
	_res := o.O.(*_os.LinkError).Error()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_PathError_Error from os/error.go:
func __ptrTo_PathError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_os.PathError)Error()", args, 0, 0)
	_res := o.O.(*_os.PathError).Error()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_PathError_Timeout from os/error.go:
func __ptrTo_PathError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_os.PathError)Timeout()", args, 0, 0)
	_res := o.O.(*_os.PathError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC os.__ptrTo_ProcessState_ExitCode from os/exec_posix.go:
func __ptrTo_ProcessState_ExitCode(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)ExitCode()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).ExitCode()
	return MakeInt(_res)
}

GO FUNC os.__ptrTo_ProcessState_Exited from os/exec.go:
func __ptrTo_ProcessState_Exited(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)Exited()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).Exited()
	return MakeBoolean(_res)
}

GO FUNC os.__ptrTo_ProcessState_Pid from os/exec_posix.go:
func __ptrTo_ProcessState_Pid(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)Pid()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).Pid()
	return MakeInt(_res)
}

GO FUNC os.__ptrTo_ProcessState_String from os/exec_posix.go:
func __ptrTo_ProcessState_String(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)String()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).String()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_ProcessState_Success from os/exec.go:
func __ptrTo_ProcessState_Success(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)Success()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).Success()
	return MakeBoolean(_res)
}

GO FUNC os.__ptrTo_ProcessState_Sys from os/exec.go:
// func __ptrTo_ProcessState_Sys(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/os/exec.go:158:30)}

GO FUNC os.__ptrTo_ProcessState_SysUsage from os/exec.go:
// func __ptrTo_ProcessState_SysUsage(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/os/exec.go:167:35)}

GO FUNC os.__ptrTo_ProcessState_SystemTime from os/exec.go:
func __ptrTo_ProcessState_SystemTime(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)SystemTime()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).SystemTime()
	return MakeGoObject(_res)
}

GO FUNC os.__ptrTo_ProcessState_UserTime from os/exec.go:
func __ptrTo_ProcessState_UserTime(o GoObject, args Object) Object {
	CheckGoArity("(*_os.ProcessState)UserTime()", args, 0, 0)
	_res := o.O.(*_os.ProcessState).UserTime()
	return MakeGoObject(_res)
}

GO FUNC os.__ptrTo_Process_Kill from os/exec.go:
func __ptrTo_Process_Kill(o GoObject, args Object) Object {
	CheckGoArity("(*_os.Process)Kill()", args, 0, 0)
	_res := o.O.(*_os.Process).Kill()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_Process_Release from os/exec.go:
func __ptrTo_Process_Release(o GoObject, args Object) Object {
	CheckGoArity("(*_os.Process)Release()", args, 0, 0)
	_res := o.O.(*_os.Process).Release()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_Process_Signal from os/exec.go:
func __ptrTo_Process_Signal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_os.Process)Signal()", args, 1, 1)
	sig := ExtractGo_go_std_os__Signal("(*_os.Process)Signal()", "sig", _argList, 0)
	_res := o.O.(*_os.Process).Signal(sig)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os.__ptrTo_Process_Wait from os/exec.go:
func __ptrTo_Process_Wait(o GoObject, args Object) Object {
	CheckGoArity("(*_os.Process)Wait()", args, 0, 0)
	_res1, _res2 := o.O.(*_os.Process).Wait()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.__ptrTo_SyscallError_Error from os/error.go:
func __ptrTo_SyscallError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_os.SyscallError)Error()", args, 0, 0)
	_res := o.O.(*_os.SyscallError).Error()
	return MakeString(_res)
}

GO FUNC os.__ptrTo_SyscallError_Timeout from os/error.go:
func __ptrTo_SyscallError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_os.SyscallError)Timeout()", args, 0, 0)
	_res := o.O.(*_os.SyscallError).Timeout()
	return MakeBoolean(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package os

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_os "os"
	_reflect "reflect"
)
var members_PtrTo_File = GoTypeInfo{Members: GoMembers{
	"Chdir": __ptrTo_File_Chdir,
	"Chmod": __ptrTo_File_Chmod,
	"Chown": __ptrTo_File_Chown,
	"Close": __ptrTo_File_Close,
	"Name": __ptrTo_File_Name,
	"Readdir": __ptrTo_File_Readdir,
	"Readdirnames": __ptrTo_File_Readdirnames,
	"Seek": __ptrTo_File_Seek,
	"Stat": __ptrTo_File_Stat,
	"Sync": __ptrTo_File_Sync,
	"SyscallConn": __ptrTo_File_SyscallConn,
	"Truncate": __ptrTo_File_Truncate,
	"WriteString": __ptrTo_File_WriteString,
}}

var members_FileMode = GoTypeInfo{Members: GoMembers{
	"IsDir": __fileMode_IsDir,
	"IsRegular": __fileMode_IsRegular,
	"Perm": __fileMode_Perm,
	"String": __fileMode_String,
}}

var members_PtrTo_LinkError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_LinkError_Error,
}}

var members_PtrTo_PathError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_PathError_Error,
	"Timeout": __ptrTo_PathError_Timeout,
}}

var members_PtrTo_Process = GoTypeInfo{Members: GoMembers{
	"Kill": __ptrTo_Process_Kill,
	"Release": __ptrTo_Process_Release,
	"Signal": __ptrTo_Process_Signal,
	"Wait": __ptrTo_Process_Wait,
}}

var members_PtrTo_ProcessState = GoTypeInfo{Members: GoMembers{
	"ExitCode": __ptrTo_ProcessState_ExitCode,
	"Exited": __ptrTo_ProcessState_Exited,
	"Pid": __ptrTo_ProcessState_Pid,
	"String": __ptrTo_ProcessState_String,
	"Success": __ptrTo_ProcessState_Success,
	"SystemTime": __ptrTo_ProcessState_SystemTime,
	"UserTime": __ptrTo_ProcessState_UserTime,
}}

var members_PtrTo_SyscallError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_SyscallError_Error,
	"Timeout": __ptrTo_SyscallError_Timeout,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_os.File)(nil))] = &members_PtrTo_File
	GoTypes[_reflect.TypeOf((*_os.FileMode)(nil)).Elem()] = &members_FileMode
	GoTypes[_reflect.TypeOf((*_os.LinkError)(nil))] = &members_PtrTo_LinkError
	GoTypes[_reflect.TypeOf((*_os.PathError)(nil))] = &members_PtrTo_PathError
	GoTypes[_reflect.TypeOf((*_os.Process)(nil))] = &members_PtrTo_Process
	GoTypes[_reflect.TypeOf((*_os.ProcessState)(nil))] = &members_PtrTo_ProcessState
	GoTypes[_reflect.TypeOf((*_os.SyscallError)(nil))] = &members_PtrTo_SyscallError
}

GO TYPE os/exec.Cmd from os/exec/exec.go:
func ExtractGoObjectCmd(args []Object, index int) *_exec.Cmd {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.Cmd:
			return &r
		case *_exec.Cmd:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.Cmd]"))
}

// func _mapToCmd(o Map) *_exec.Cmd {
// 	return &_exec.Cmd{}
// }

// func _vectorToCmd(o *Vector) *_exec.Cmd {
// 	return &_exec.Cmd{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Dir: AssertString(o.Nth(3), "").S,
// 		Stdin: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Stdout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Stderr: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExtraFiles: []*ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		SysProcAttr: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Process: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ProcessState: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructCmd(_v Object) *_exec.Cmd {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _exec.Cmd:
// 			return &_g
// 		case *_exec.Cmd:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCmd(_o.(Map))
// 	case *Vector:
// 		return _vectorToCmd(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.Cmd] or: Map or Vector"))
// }

GO TYPE os/exec.Error from os/exec/exec.go:
func ExtractGoObjectError(args []Object, index int) *_exec.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.Error:
			return &r
		case *_exec.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.Error]"))
}

func _mapToError(o Map) *_exec.Error {
	return &_exec.Error{}
}

func _vectorToError(o *Vector) *_exec.Error {
	return &_exec.Error{
		Name: AssertString(o.Nth(0), "").S,
		Err: _errors.New(AssertString(o.Nth(1), "").S),
	}
}

func _ConstructError(_v Object) *_exec.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _exec.Error:
			return &_g
		case *_exec.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.Error] or: Map or Vector"))
}

GO TYPE os/exec.ExitError from os/exec/exec.go:
func ExtractGoObjectExitError(args []Object, index int) *_exec.ExitError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _exec.ExitError:
			return &r
		case *_exec.ExitError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/exec.ExitError]"))
}

// func _mapToExitError(o Map) *_exec.ExitError {
// 	return &_exec.ExitError{}
// }

// func _vectorToExitError(o *Vector) *_exec.ExitError {
// 	return &_exec.ExitError{
// 		Stderr: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructExitError(_v Object) *_exec.ExitError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _exec.ExitError:
// 			return &_g
// 		case *_exec.ExitError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToExitError(_o.(Map))
// 	case *Vector:
// 		return _vectorToExitError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[exec.ExitError] or: Map or Vector"))
// }

GO FUNC os/exec.Command from os/exec/exec.go:
// func __command(name string, arg ...string) Object {
// 	_res := _exec.Command(name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.CommandContext from os/exec/exec.go:
// func __commandContext(ctx ABEND987(genutils.go: imports not yet supported: context.Context), name string, arg ...string) Object {
// 	_res := _exec.CommandContext(ctx, name, arg)
// 	return MakeGoObject(_res)
// }

GO FUNC os/exec.LookPath from os/exec/lp_unix.go:
func __lookPath(file string) Object {
	_res1, _res2 := _exec.LookPath(file)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_CombinedOutput from os/exec/exec.go:
func __ptrTo_Cmd_CombinedOutput(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)CombinedOutput()", args, 0, 0)
	_res1, _res2 := o.O.(*_exec.Cmd).CombinedOutput()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_Output from os/exec/exec.go:
func __ptrTo_Cmd_Output(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)Output()", args, 0, 0)
	_res1, _res2 := o.O.(*_exec.Cmd).Output()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_Run from os/exec/exec.go:
func __ptrTo_Cmd_Run(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)Run()", args, 0, 0)
	_res := o.O.(*_exec.Cmd).Run()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os/exec.__ptrTo_Cmd_Start from os/exec/exec.go:
func __ptrTo_Cmd_Start(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)Start()", args, 0, 0)
	_res := o.O.(*_exec.Cmd).Start()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os/exec.__ptrTo_Cmd_StderrPipe from os/exec/exec.go:
func __ptrTo_Cmd_StderrPipe(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)StderrPipe()", args, 0, 0)
	_res1, _res2 := o.O.(*_exec.Cmd).StderrPipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_StdinPipe from os/exec/exec.go:
func __ptrTo_Cmd_StdinPipe(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)StdinPipe()", args, 0, 0)
	_res1, _res2 := o.O.(*_exec.Cmd).StdinPipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_StdoutPipe from os/exec/exec.go:
func __ptrTo_Cmd_StdoutPipe(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)StdoutPipe()", args, 0, 0)
	_res1, _res2 := o.O.(*_exec.Cmd).StdoutPipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.__ptrTo_Cmd_Wait from os/exec/exec.go:
func __ptrTo_Cmd_Wait(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Cmd)Wait()", args, 0, 0)
	_res := o.O.(*_exec.Cmd).Wait()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC os/exec.__ptrTo_Error_Error from os/exec/exec.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.Error)Error()", args, 0, 0)
	_res := o.O.(*_exec.Error).Error()
	return MakeString(_res)
}

GO FUNC os/exec.__ptrTo_ExitError_Error from os/exec/exec.go:
func __ptrTo_ExitError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_os/exec.ExitError)Error()", args, 0, 0)
	_res := o.O.(*_exec.ExitError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package exec

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_exec "os/exec"
	_reflect "reflect"
)
var members_PtrTo_Cmd = GoTypeInfo{Members: GoMembers{
	"CombinedOutput": __ptrTo_Cmd_CombinedOutput,
	"Output": __ptrTo_Cmd_Output,
	"Run": __ptrTo_Cmd_Run,
	"Start": __ptrTo_Cmd_Start,
	"StderrPipe": __ptrTo_Cmd_StderrPipe,
	"StdinPipe": __ptrTo_Cmd_StdinPipe,
	"StdoutPipe": __ptrTo_Cmd_StdoutPipe,
	"Wait": __ptrTo_Cmd_Wait,
}}

var members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Error_Error,
}}

var members_PtrTo_ExitError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ExitError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_exec.Cmd)(nil))] = &members_PtrTo_Cmd
	GoTypes[_reflect.TypeOf((*_exec.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_exec.ExitError)(nil))] = &members_PtrTo_ExitError
}

GO FUNC os/signal.Ignore from os/signal/signal.go:
// func __ignore(sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Ignore(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Ignored from os/signal/signal.go:
// func __ignored(sig ABEND987(genutils.go: imports not yet supported: os.Signal))  {
// 	_res := _signal.Ignored(sig)
// 	return MakeBoolean(_res)
// }

GO FUNC os/signal.Notify from os/signal/signal.go:
// func __notify(c <-chan, sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Notify(c, sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Reset from os/signal/signal.go:
// func __reset(sig ...ABEND987(genutils.go: imports not yet supported: os.Signal)) Object {
// 	_signal.Reset(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Stop from os/signal/signal.go:
// func __stop(c <-chan) Object {
// 	_signal.Stop(c)
// 	...ABEND675: TODO...
// }

GO TYPE os/user.Group from os/user/user.go:
func ExtractGoObjectGroup(args []Object, index int) *_user.Group {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.Group:
			return &r
		case *_user.Group:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.Group]"))
}

func _mapToGroup(o Map) *_user.Group {
	return &_user.Group{}
}

func _vectorToGroup(o *Vector) *_user.Group {
	return &_user.Group{
		Gid: AssertString(o.Nth(0), "").S,
		Name: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructGroup(_v Object) *_user.Group {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.Group:
			return &_g
		case *_user.Group:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToGroup(_o.(Map))
	case *Vector:
		return _vectorToGroup(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.Group] or: Map or Vector"))
}

GO TYPE os/user.UnknownGroupError from os/user/user.go:
func ExtractGoObjectUnknownGroupError(args []Object, index int) *_user.UnknownGroupError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownGroupError:
			return &r
		case *_user.UnknownGroupError:
			return r
		}
	case String:
		v := _user.UnknownGroupError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownGroupError]"))
}

func _ConstructUnknownGroupError(_v Object) _user.UnknownGroupError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownGroupError:
			return _g
		case *_user.UnknownGroupError:
			return *_g
		}
	case String:
		return _user.UnknownGroupError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownGroupError] or: String"))
}

GO TYPE os/user.UnknownGroupIdError from os/user/user.go:
func ExtractGoObjectUnknownGroupIdError(args []Object, index int) *_user.UnknownGroupIdError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownGroupIdError:
			return &r
		case *_user.UnknownGroupIdError:
			return r
		}
	case String:
		v := _user.UnknownGroupIdError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownGroupIdError]"))
}

func _ConstructUnknownGroupIdError(_v Object) _user.UnknownGroupIdError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownGroupIdError:
			return _g
		case *_user.UnknownGroupIdError:
			return *_g
		}
	case String:
		return _user.UnknownGroupIdError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownGroupIdError] or: String"))
}

GO TYPE os/user.UnknownUserError from os/user/user.go:
func ExtractGoObjectUnknownUserError(args []Object, index int) *_user.UnknownUserError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownUserError:
			return &r
		case *_user.UnknownUserError:
			return r
		}
	case String:
		v := _user.UnknownUserError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownUserError]"))
}

func _ConstructUnknownUserError(_v Object) _user.UnknownUserError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownUserError:
			return _g
		case *_user.UnknownUserError:
			return *_g
		}
	case String:
		return _user.UnknownUserError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownUserError] or: String"))
}

GO TYPE os/user.UnknownUserIdError from os/user/user.go:
func ExtractGoObjectUnknownUserIdError(args []Object, index int) *_user.UnknownUserIdError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.UnknownUserIdError:
			return &r
		case *_user.UnknownUserIdError:
			return r
		}
	case Int:
		v := _user.UnknownUserIdError(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.UnknownUserIdError]"))
}

func _ConstructUnknownUserIdError(_v Object) _user.UnknownUserIdError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.UnknownUserIdError:
			return _g
		case *_user.UnknownUserIdError:
			return *_g
		}
	case Number:
		return _user.UnknownUserIdError(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.UnknownUserIdError] or: Number"))
}

GO TYPE os/user.User from os/user/user.go:
func ExtractGoObjectUser(args []Object, index int) *_user.User {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _user.User:
			return &r
		case *_user.User:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[os/user.User]"))
}

func _mapToUser(o Map) *_user.User {
	return &_user.User{}
}

func _vectorToUser(o *Vector) *_user.User {
	return &_user.User{
		Uid: AssertString(o.Nth(0), "").S,
		Gid: AssertString(o.Nth(1), "").S,
		Username: AssertString(o.Nth(2), "").S,
		Name: AssertString(o.Nth(3), "").S,
		HomeDir: AssertString(o.Nth(4), "").S,
	}
}

func _ConstructUser(_v Object) *_user.User {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _user.User:
			return &_g
		case *_user.User:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUser(_o.(Map))
	case *Vector:
		return _vectorToUser(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[user.User] or: Map or Vector"))
}

GO FUNC os/user.Current from os/user/lookup.go:
func __current() Object {
	_res1, _res2 := _user.Current()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.Lookup from os/user/lookup.go:
func __lookup(username string) Object {
	_res1, _res2 := _user.Lookup(username)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroup from os/user/lookup.go:
func __lookupGroup(name string) Object {
	_res1, _res2 := _user.LookupGroup(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroupId from os/user/lookup.go:
func __lookupGroupId(gid string) Object {
	_res1, _res2 := _user.LookupGroupId(gid)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupId from os/user/lookup.go:
func __lookupId(uid string) Object {
	_res1, _res2 := _user.LookupId(uid)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.__ptrTo_User_GroupIds from os/user/lookup.go:
func __ptrTo_User_GroupIds(o GoObject, args Object) Object {
	CheckGoArity("(*_os/user.User)GroupIds()", args, 0, 0)
	_res1, _res2 := o.O.(*_user.User).GroupIds()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.__unknownGroupError_Error from os/user/user.go:
func __unknownGroupError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_os/user.UnknownGroupError)Error()", args, 0, 0)
	_res := o.O.(_user.UnknownGroupError).Error()
	return MakeString(_res)
}

GO FUNC os/user.__unknownGroupIdError_Error from os/user/user.go:
func __unknownGroupIdError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_os/user.UnknownGroupIdError)Error()", args, 0, 0)
	_res := o.O.(_user.UnknownGroupIdError).Error()
	return MakeString(_res)
}

GO FUNC os/user.__unknownUserError_Error from os/user/user.go:
func __unknownUserError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_os/user.UnknownUserError)Error()", args, 0, 0)
	_res := o.O.(_user.UnknownUserError).Error()
	return MakeString(_res)
}

GO FUNC os/user.__unknownUserIdError_Error from os/user/user.go:
func __unknownUserIdError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_os/user.UnknownUserIdError)Error()", args, 0, 0)
	_res := o.O.(_user.UnknownUserIdError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package user

import (
	. "github.com/candid82/joker/core"
	_user "os/user"
	_reflect "reflect"
)
var members_UnknownGroupError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownGroupError_Error,
}}

var members_UnknownGroupIdError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownGroupIdError_Error,
}}

var members_UnknownUserError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownUserError_Error,
}}

var members_UnknownUserIdError = GoTypeInfo{Members: GoMembers{
	"Error": __unknownUserIdError_Error,
}}

var members_PtrTo_User = GoTypeInfo{Members: GoMembers{
	"GroupIds": __ptrTo_User_GroupIds,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_user.UnknownGroupError)(nil)).Elem()] = &members_UnknownGroupError
	GoTypes[_reflect.TypeOf((*_user.UnknownGroupIdError)(nil)).Elem()] = &members_UnknownGroupIdError
	GoTypes[_reflect.TypeOf((*_user.UnknownUserError)(nil)).Elem()] = &members_UnknownUserError
	GoTypes[_reflect.TypeOf((*_user.UnknownUserIdError)(nil)).Elem()] = &members_UnknownUserIdError
	GoTypes[_reflect.TypeOf((*_user.User)(nil))] = &members_PtrTo_User
}

GO FUNC path.Join from path/path.go:
// func __join(elem ...string)  {
// 	_res := _path.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path.Match from path/match.go:
func __match(pattern string, name string) Object {
	matched, err := _path.Match(pattern, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path.Split from path/path.go:
func __split(path string) Object {
	dir, file := _path.Split(path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package path

import (
	. "github.com/candid82/joker/core"
	_path "path"
)

func init() {
}

GO TYPE path/filepath.WalkFunc from path/filepath/path.go:
func ExtractGoObjectWalkFunc(args []Object, index int) *_filepath.WalkFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _filepath.WalkFunc:
			return &r
		case *_filepath.WalkFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[path/filepath.WalkFunc]"))
}

// func _ConstructWalkFunc(_v Object) _filepath.WalkFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _filepath.WalkFunc:
// 			return _g
// 		case *_filepath.WalkFunc:
// 			return *_g
// 		}
// 	default:
// 		return _filepath.WalkFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for WalkFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[filepath.WalkFunc] or: whatever"))
// }

GO FUNC path/filepath.Abs from path/filepath/path.go:
func __abs(path string) Object {
	_res1, _res2 := _filepath.Abs(path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.EvalSymlinks from path/filepath/path.go:
func __evalSymlinks(path string) Object {
	_res1, _res2 := _filepath.EvalSymlinks(path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Glob from path/filepath/match.go:
func __glob(pattern string) Object {
	matches, err := _filepath.Glob(pattern)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range matches {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Join from path/filepath/path.go:
// func __join(elem ...string)  {
// 	_res := _filepath.Join(elem)
// 	return MakeString(_res)
// }

GO FUNC path/filepath.Match from path/filepath/match.go:
func __match(pattern string, name string) Object {
	matched, err := _filepath.Match(pattern, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Rel from path/filepath/path.go:
func __rel(basepath string, targpath string) Object {
	_res1, _res2 := _filepath.Rel(basepath, targpath)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Split from path/filepath/path.go:
func __split(path string) Object {
	dir, file := _filepath.Split(path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

GO FUNC path/filepath.SplitList from path/filepath/path.go:
func __splitList(path string) Object {
	_res := _filepath.SplitList(path)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package filepath

import (
	. "github.com/candid82/joker/core"
	_filepath "path/filepath"
)

func init() {
}

GO TYPE plugin.Plugin from plugin/plugin.go:
func ExtractGoObjectPlugin(args []Object, index int) *_plugin.Plugin {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plugin.Plugin:
			return &r
		case *_plugin.Plugin:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[plugin.Plugin]"))
}

func _mapToPlugin(o Map) *_plugin.Plugin {
	return &_plugin.Plugin{}
}

func _vectorToPlugin(o *Vector) *_plugin.Plugin {
	return &_plugin.Plugin{}
}

func _ConstructPlugin(_v Object) *_plugin.Plugin {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _plugin.Plugin:
			return &_g
		case *_plugin.Plugin:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPlugin(_o.(Map))
	case *Vector:
		return _vectorToPlugin(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[plugin.Plugin] or: Map or Vector"))
}

GO TYPE plugin.Symbol from plugin/plugin.go:
func ExtractGoObjectSymbol(args []Object, index int) *_plugin.Symbol {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _plugin.Symbol:
			return &r
		case *_plugin.Symbol:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[plugin.Symbol]"))
}

// func _ConstructSymbol(_v Object) _plugin.Symbol {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _plugin.Symbol:
// 			return _g
// 		case *_plugin.Symbol:
// 			return *_g
// 		}
// 	default:
// 		return _plugin.Symbol(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Symbol))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[plugin.Symbol] or: whatever"))
// }

GO FUNC plugin.Open from plugin/plugin.go:
func __open(path string) Object {
	_res1, _res2 := _plugin.Open(path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC plugin.__ptrTo_Plugin_Lookup from plugin/plugin.go:
func __ptrTo_Plugin_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_plugin.Plugin)Lookup()", args, 1, 1)
	symName := ExtractGoString("(*_plugin.Plugin)Lookup()", "symName", _argList, 0)
	_res1, _res2 := o.O.(*_plugin.Plugin).Lookup(symName)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package plugin

import (
	. "github.com/candid82/joker/core"
	_plugin "plugin"
	_reflect "reflect"
)
var members_PtrTo_Plugin = GoTypeInfo{Members: GoMembers{
	"Lookup": __ptrTo_Plugin_Lookup,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_plugin.Plugin)(nil))] = &members_PtrTo_Plugin
}

GO TYPE reflect.ChanDir from reflect/type.go:
func ExtractGoObjectChanDir(args []Object, index int) *_reflect.ChanDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.ChanDir:
			return &r
		case *_reflect.ChanDir:
			return r
		}
	case Int:
		v := _reflect.ChanDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.ChanDir]"))
}

func _ConstructChanDir(_v Object) _reflect.ChanDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.ChanDir:
			return _g
		case *_reflect.ChanDir:
			return *_g
		}
	case Number:
		return _reflect.ChanDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.ChanDir] or: Number"))
}

GO TYPE reflect.Kind from reflect/type.go:
func ExtractGoObjectKind(args []Object, index int) *_reflect.Kind {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Kind:
			return &r
		case *_reflect.Kind:
			return r
		}
	case Number:
		v := _reflect.Kind(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Kind]"))
}

func _ConstructKind(_v Object) _reflect.Kind {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.Kind:
			return _g
		case *_reflect.Kind:
			return *_g
		}
	case Number:
		return _reflect.Kind(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Kind] or: Number"))
}

GO TYPE reflect.MapIter from reflect/value.go:
func ExtractGoObjectMapIter(args []Object, index int) *_reflect.MapIter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.MapIter:
			return &r
		case *_reflect.MapIter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.MapIter]"))
}

func _mapToMapIter(o Map) *_reflect.MapIter {
	return &_reflect.MapIter{}
}

func _vectorToMapIter(o *Vector) *_reflect.MapIter {
	return &_reflect.MapIter{}
}

func _ConstructMapIter(_v Object) *_reflect.MapIter {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.MapIter:
			return &_g
		case *_reflect.MapIter:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMapIter(_o.(Map))
	case *Vector:
		return _vectorToMapIter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.MapIter] or: Map or Vector"))
}

GO TYPE reflect.Method from reflect/type.go:
func ExtractGoObjectMethod(args []Object, index int) *_reflect.Method {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Method:
			return &r
		case *_reflect.Method:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Method]"))
}

// func _mapToMethod(o Map) *_reflect.Method {
// 	return &_reflect.Method{}
// }

// func _vectorToMethod(o *Vector) *_reflect.Method {
// 	return &_reflect.Method{
// 		Name: AssertString(o.Nth(0), "").S,
// 		PkgPath: AssertString(o.Nth(1), "").S,
// 		Type: ABEND048(codegen.go: no conversion from Clojure for reflect.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Func: ABEND048(codegen.go: no conversion from Clojure for reflect.Value (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Index: AssertInt(o.Nth(4), "").I,
// 	}
// }

// func _ConstructMethod(_v Object) *_reflect.Method {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _reflect.Method:
// 			return &_g
// 		case *_reflect.Method:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMethod(_o.(Map))
// 	case *Vector:
// 		return _vectorToMethod(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Method] or: Map or Vector"))
// }

GO TYPE reflect.SelectCase from reflect/value.go:
func ExtractGoObjectSelectCase(args []Object, index int) *_reflect.SelectCase {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SelectCase:
			return &r
		case *_reflect.SelectCase:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SelectCase]"))
}

// func _mapToSelectCase(o Map) *_reflect.SelectCase {
// 	return &_reflect.SelectCase{}
// }

// func _vectorToSelectCase(o *Vector) *_reflect.SelectCase {
// 	return &_reflect.SelectCase{
// 		Dir: _reflect.SelectDir(AssertInt(o.Nth(0), "").I),
// 		Chan: ABEND048(codegen.go: no conversion from Clojure for reflect.Value (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Send: ABEND048(codegen.go: no conversion from Clojure for reflect.Value (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructSelectCase(_v Object) *_reflect.SelectCase {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _reflect.SelectCase:
// 			return &_g
// 		case *_reflect.SelectCase:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSelectCase(_o.(Map))
// 	case *Vector:
// 		return _vectorToSelectCase(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SelectCase] or: Map or Vector"))
// }

GO TYPE reflect.SelectDir from reflect/value.go:
func ExtractGoObjectSelectDir(args []Object, index int) *_reflect.SelectDir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SelectDir:
			return &r
		case *_reflect.SelectDir:
			return r
		}
	case Int:
		v := _reflect.SelectDir(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SelectDir]"))
}

func _ConstructSelectDir(_v Object) _reflect.SelectDir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.SelectDir:
			return _g
		case *_reflect.SelectDir:
			return *_g
		}
	case Number:
		return _reflect.SelectDir(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SelectDir] or: Number"))
}

GO TYPE reflect.SliceHeader from reflect/value.go:
func ExtractGoObjectSliceHeader(args []Object, index int) *_reflect.SliceHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.SliceHeader:
			return &r
		case *_reflect.SliceHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.SliceHeader]"))
}

func _mapToSliceHeader(o Map) *_reflect.SliceHeader {
	return &_reflect.SliceHeader{}
}

func _vectorToSliceHeader(o *Vector) *_reflect.SliceHeader {
	return &_reflect.SliceHeader{
		Data: uintptr(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Len: AssertInt(o.Nth(1), "").I,
		Cap: AssertInt(o.Nth(2), "").I,
	}
}

func _ConstructSliceHeader(_v Object) *_reflect.SliceHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.SliceHeader:
			return &_g
		case *_reflect.SliceHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSliceHeader(_o.(Map))
	case *Vector:
		return _vectorToSliceHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.SliceHeader] or: Map or Vector"))
}

GO TYPE reflect.StringHeader from reflect/value.go:
func ExtractGoObjectStringHeader(args []Object, index int) *_reflect.StringHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StringHeader:
			return &r
		case *_reflect.StringHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StringHeader]"))
}

func _mapToStringHeader(o Map) *_reflect.StringHeader {
	return &_reflect.StringHeader{}
}

func _vectorToStringHeader(o *Vector) *_reflect.StringHeader {
	return &_reflect.StringHeader{
		Data: uintptr(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Len: AssertInt(o.Nth(1), "").I,
	}
}

func _ConstructStringHeader(_v Object) *_reflect.StringHeader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.StringHeader:
			return &_g
		case *_reflect.StringHeader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStringHeader(_o.(Map))
	case *Vector:
		return _vectorToStringHeader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StringHeader] or: Map or Vector"))
}

GO TYPE reflect.StructField from reflect/type.go:
func ExtractGoObjectStructField(args []Object, index int) *_reflect.StructField {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StructField:
			return &r
		case *_reflect.StructField:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StructField]"))
}

// func _mapToStructField(o Map) *_reflect.StructField {
// 	return &_reflect.StructField{}
// }

// func _vectorToStructField(o *Vector) *_reflect.StructField {
// 	return &_reflect.StructField{
// 		Name: AssertString(o.Nth(0), "").S,
// 		PkgPath: AssertString(o.Nth(1), "").S,
// 		Type: ABEND048(codegen.go: no conversion from Clojure for reflect.Type (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Tag: _reflect.StructTag(AssertString(o.Nth(3), "").S),
// 		Offset: uintptr(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Index: ABEND048(codegen.go: no conversion from Clojure for []int (int)),
// 		Anonymous: ToBool(o.Nth(6)),
// 	}
// }

// func _ConstructStructField(_v Object) *_reflect.StructField {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _reflect.StructField:
// 			return &_g
// 		case *_reflect.StructField:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStructField(_o.(Map))
// 	case *Vector:
// 		return _vectorToStructField(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StructField] or: Map or Vector"))
// }

GO TYPE reflect.StructTag from reflect/type.go:
func ExtractGoObjectStructTag(args []Object, index int) *_reflect.StructTag {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.StructTag:
			return &r
		case *_reflect.StructTag:
			return r
		}
	case String:
		v := _reflect.StructTag(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.StructTag]"))
}

func _ConstructStructTag(_v Object) _reflect.StructTag {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.StructTag:
			return _g
		case *_reflect.StructTag:
			return *_g
		}
	case String:
		return _reflect.StructTag(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.StructTag] or: String"))
}

GO TYPE reflect.Type from reflect/type.go:
func ExtractGoObjectType(args []Object, index int) *_reflect.Type {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Type:
			return &r
		case *_reflect.Type:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Type]"))
}

// func _ConstructType(_v Object) _reflect.Type {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _reflect.Type:
// 			return _g
// 		case *_reflect.Type:
// 			return *_g
// 		}
// 	default:
// 		return _reflect.Type(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Type))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Type] or: whatever"))
// }

GO TYPE reflect.Value from reflect/value.go:
func ExtractGoObjectValue(args []Object, index int) *_reflect.Value {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.Value:
			return &r
		case *_reflect.Value:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.Value]"))
}

func _mapToValue(o Map) *_reflect.Value {
	return &_reflect.Value{}
}

func _vectorToValue(o *Vector) *_reflect.Value {
	return &_reflect.Value{}
}

func _ConstructValue(_v Object) *_reflect.Value {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.Value:
			return &_g
		case *_reflect.Value:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValue(_o.(Map))
	case *Vector:
		return _vectorToValue(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.Value] or: Map or Vector"))
}

GO TYPE reflect.ValueError from reflect/value.go:
func ExtractGoObjectValueError(args []Object, index int) *_reflect.ValueError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _reflect.ValueError:
			return &r
		case *_reflect.ValueError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[reflect.ValueError]"))
}

func _mapToValueError(o Map) *_reflect.ValueError {
	return &_reflect.ValueError{}
}

func _vectorToValueError(o *Vector) *_reflect.ValueError {
	return &_reflect.ValueError{
		Method: AssertString(o.Nth(0), "").S,
		Kind: _reflect.Kind(uint(AssertInt(o.Nth(1), "").I)),
	}
}

func _ConstructValueError(_v Object) *_reflect.ValueError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _reflect.ValueError:
			return &_g
		case *_reflect.ValueError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToValueError(_o.(Map))
	case *Vector:
		return _vectorToValueError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[reflect.ValueError] or: Map or Vector"))
}

GO FUNC reflect.Append from reflect/value.go:
// func __append(s _reflect.Value, x ..._reflect.Value) Object {
// 	_res := _reflect.Append(s, x)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.AppendSlice from reflect/value.go:
func __appendSlice(s _reflect.Value, t _reflect.Value) Object {
	_res := _reflect.AppendSlice(s, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.ArrayOf from reflect/type.go:
func __arrayOf(count int, elem _reflect.Type) Object {
	_res := _reflect.ArrayOf(count, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.ChanOf from reflect/type.go:
func __chanOf(dir _reflect.ChanDir, t _reflect.Type) Object {
	_res := _reflect.ChanOf(dir, t)
	return MakeGoObject(_res)
}

GO FUNC reflect.DeepEqual from reflect/deepequal.go:
// func __deepEqual(x interface {}, y interface {})  {
// 	_res := _reflect.DeepEqual(x, y)
// 	return MakeBoolean(_res)
// }

GO FUNC reflect.FuncOf from reflect/type.go:
// func __funcOf(in []_reflect.Type, out []_reflect.Type, variadic bool) Object {
// 	_res := _reflect.FuncOf(in, out, variadic)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Indirect from reflect/value.go:
func __indirect(v _reflect.Value) Object {
	_res := _reflect.Indirect(v)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeChan from reflect/value.go:
func __makeChan(typ _reflect.Type, buffer int) Object {
	_res := _reflect.MakeChan(typ, buffer)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeFunc from reflect/makefunc.go:
// func __makeFunc(typ _reflect.Type, fn func) Object {
// 	_res := _reflect.MakeFunc(typ, fn)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.MakeMap from reflect/value.go:
func __makeMap(typ _reflect.Type) Object {
	_res := _reflect.MakeMap(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeMapWithSize from reflect/value.go:
func __makeMapWithSize(typ _reflect.Type, n int) Object {
	_res := _reflect.MakeMapWithSize(typ, n)
	return MakeGoObject(_res)
}

GO FUNC reflect.MakeSlice from reflect/value.go:
func __makeSlice(typ _reflect.Type, len int, cap int) Object {
	_res := _reflect.MakeSlice(typ, len, cap)
	return MakeGoObject(_res)
}

GO FUNC reflect.MapOf from reflect/type.go:
func __mapOf(key _reflect.Type, elem _reflect.Type) Object {
	_res := _reflect.MapOf(key, elem)
	return MakeGoObject(_res)
}

GO FUNC reflect.New from reflect/value.go:
func __new(typ _reflect.Type) Object {
	_res := _reflect.New(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.NewAt from reflect/value.go:
// func __newAt(typ _reflect.Type, p ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_res := _reflect.NewAt(typ, p)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.PtrTo from reflect/type.go:
func __ptrTo(t _reflect.Type) Object {
	_res := _reflect.PtrTo(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.Select from reflect/value.go:
// func __select(cases []_reflect.SelectCase) Object {
// 	chosen, recv, recvOK := _reflect.Select(cases)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(chosen))
// 	_res = _res.Conjoin(MakeGoObject(recv))
// 	_res = _res.Conjoin(MakeBoolean(recvOK))
// 	return _res
// }

GO FUNC reflect.SliceOf from reflect/type.go:
func __sliceOf(t _reflect.Type) Object {
	_res := _reflect.SliceOf(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.StructOf from reflect/type.go:
// func __structOf(fields []_reflect.StructField) Object {
// 	_res := _reflect.StructOf(fields)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Swapper from reflect/swapper.go:
// func __swapper(slice interface {}) Object {
// 	return _reflect.Swapper(slice)
// }

GO FUNC reflect.TypeOf from reflect/type.go:
// func __typeOf(i interface {}) Object {
// 	_res := _reflect.TypeOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.ValueOf from reflect/value.go:
// func __valueOf(i interface {}) Object {
// 	_res := _reflect.ValueOf(i)
// 	return MakeGoObject(_res)
// }

GO FUNC reflect.Zero from reflect/value.go:
func __zero(typ _reflect.Type) Object {
	_res := _reflect.Zero(typ)
	return MakeGoObject(_res)
}

GO FUNC reflect.__chanDir_String from reflect/type.go:
func __chanDir_String(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.ChanDir)String()", args, 0, 0)
	_res := o.O.(_reflect.ChanDir).String()
	return MakeString(_res)
}

GO FUNC reflect.__kind_String from reflect/type.go:
func __kind_String(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Kind)String()", args, 0, 0)
	_res := o.O.(_reflect.Kind).String()
	return MakeString(_res)
}

GO FUNC reflect.__ptrTo_MapIter_Key from reflect/value.go:
func __ptrTo_MapIter_Key(o GoObject, args Object) Object {
	CheckGoArity("(*_reflect.MapIter)Key()", args, 0, 0)
	_res := o.O.(*_reflect.MapIter).Key()
	return MakeGoObject(_res)
}

GO FUNC reflect.__ptrTo_MapIter_Next from reflect/value.go:
func __ptrTo_MapIter_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_reflect.MapIter)Next()", args, 0, 0)
	_res := o.O.(*_reflect.MapIter).Next()
	return MakeBoolean(_res)
}

GO FUNC reflect.__ptrTo_MapIter_Value from reflect/value.go:
func __ptrTo_MapIter_Value(o GoObject, args Object) Object {
	CheckGoArity("(*_reflect.MapIter)Value()", args, 0, 0)
	_res := o.O.(*_reflect.MapIter).Value()
	return MakeGoObject(_res)
}

GO FUNC reflect.__ptrTo_ValueError_Error from reflect/value.go:
func __ptrTo_ValueError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_reflect.ValueError)Error()", args, 0, 0)
	_res := o.O.(*_reflect.ValueError).Error()
	return MakeString(_res)
}

GO FUNC reflect.__structTag_Get from reflect/type.go:
func __structTag_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.StructTag)Get()", args, 1, 1)
	key := ExtractGoString("(_reflect.StructTag)Get()", "key", _argList, 0)
	_res := o.O.(_reflect.StructTag).Get(key)
	return MakeString(_res)
}

GO FUNC reflect.__structTag_Lookup from reflect/type.go:
func __structTag_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.StructTag)Lookup()", args, 1, 1)
	key := ExtractGoString("(_reflect.StructTag)Lookup()", "key", _argList, 0)
	value, ok := o.O.(_reflect.StructTag).Lookup(key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC reflect.__value_Addr from reflect/value.go:
func __value_Addr(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Addr()", args, 0, 0)
	_res := o.O.(_reflect.Value).Addr()
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Bool from reflect/value.go:
func __value_Bool(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Bool()", args, 0, 0)
	_res := o.O.(_reflect.Value).Bool()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_Bytes from reflect/value.go:
func __value_Bytes(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Bytes()", args, 0, 0)
	_res := o.O.(_reflect.Value).Bytes()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC reflect.__value_Call from reflect/value.go:
// func __value_Call(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Value(*in)))}

GO FUNC reflect.__value_CallSlice from reflect/value.go:
// func __value_CallSlice(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOf_reflect.Value(*in)))}

GO FUNC reflect.__value_CanAddr from reflect/value.go:
func __value_CanAddr(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)CanAddr()", args, 0, 0)
	_res := o.O.(_reflect.Value).CanAddr()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_CanInterface from reflect/value.go:
func __value_CanInterface(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)CanInterface()", args, 0, 0)
	_res := o.O.(_reflect.Value).CanInterface()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_CanSet from reflect/value.go:
func __value_CanSet(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)CanSet()", args, 0, 0)
	_res := o.O.(_reflect.Value).CanSet()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_Cap from reflect/value.go:
func __value_Cap(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Cap()", args, 0, 0)
	_res := o.O.(_reflect.Value).Cap()
	return MakeInt(_res)
}

GO FUNC reflect.__value_Close from reflect/value.go:
// func __value_Close(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_Complex from reflect/value.go:
// func __value_Complex(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC reflect.__value_Convert from reflect/value.go:
func __value_Convert(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Convert()", args, 1, 1)
	t := ExtractGo_go_std_reflect__Type("(_reflect.Value)Convert()", "t", _argList, 0)
	_res := o.O.(_reflect.Value).Convert(t)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Elem from reflect/value.go:
func __value_Elem(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Elem()", args, 0, 0)
	_res := o.O.(_reflect.Value).Elem()
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Field from reflect/value.go:
func __value_Field(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Field()", args, 1, 1)
	i := ExtractGoInt("(_reflect.Value)Field()", "i", _argList, 0)
	_res := o.O.(_reflect.Value).Field(i)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_FieldByIndex from reflect/value.go:
// func __value_FieldByIndex(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(index)))}

GO FUNC reflect.__value_FieldByName from reflect/value.go:
func __value_FieldByName(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)FieldByName()", args, 1, 1)
	name := ExtractGoString("(_reflect.Value)FieldByName()", "name", _argList, 0)
	_res := o.O.(_reflect.Value).FieldByName(name)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_FieldByNameFunc from reflect/value.go:
// func __value_FieldByNameFunc(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC reflect.__value_Float from reflect/value.go:
// func __value_Float(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC reflect.__value_Index from reflect/value.go:
func __value_Index(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Index()", args, 1, 1)
	i := ExtractGoInt("(_reflect.Value)Index()", "i", _argList, 0)
	_res := o.O.(_reflect.Value).Index(i)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Int from reflect/value.go:
func __value_Int(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Int()", args, 0, 0)
	_res := o.O.(_reflect.Value).Int()
	return MakeBigInt(_res)
}

GO FUNC reflect.__value_Interface from reflect/value.go:
// func __value_Interface(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/reflect/value.go:978:31)}

GO FUNC reflect.__value_InterfaceData from reflect/value.go:
// func __value_InterfaceData(o GoObject, args Object) Object {
// 	CheckGoArity("(_reflect.Value)InterfaceData()", args, 0, 0)
// 	_res := o.O.(_reflect.Value).InterfaceData()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	}
// 	return _vec1
// }

GO FUNC reflect.__value_IsNil from reflect/value.go:
func __value_IsNil(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)IsNil()", args, 0, 0)
	_res := o.O.(_reflect.Value).IsNil()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_IsValid from reflect/value.go:
func __value_IsValid(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)IsValid()", args, 0, 0)
	_res := o.O.(_reflect.Value).IsValid()
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_Kind from reflect/value.go:
func __value_Kind(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Kind()", args, 0, 0)
	_res := o.O.(_reflect.Value).Kind()
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Len from reflect/value.go:
func __value_Len(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Len()", args, 0, 0)
	_res := o.O.(_reflect.Value).Len()
	return MakeInt(_res)
}

GO FUNC reflect.__value_MapIndex from reflect/value.go:
func __value_MapIndex(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)MapIndex()", args, 1, 1)
	key := ExtractGo_go_std_reflect__Value("(_reflect.Value)MapIndex()", "key", _argList, 0)
	_res := o.O.(_reflect.Value).MapIndex(key)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_MapKeys from reflect/value.go:
func __value_MapKeys(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)MapKeys()", args, 0, 0)
	_res := o.O.(_reflect.Value).MapKeys()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC reflect.__value_MapRange from reflect/value.go:
func __value_MapRange(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)MapRange()", args, 0, 0)
	_res := o.O.(_reflect.Value).MapRange()
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Method from reflect/value.go:
func __value_Method(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Method()", args, 1, 1)
	i := ExtractGoInt("(_reflect.Value)Method()", "i", _argList, 0)
	_res := o.O.(_reflect.Value).Method(i)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_MethodByName from reflect/value.go:
func __value_MethodByName(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)MethodByName()", args, 1, 1)
	name := ExtractGoString("(_reflect.Value)MethodByName()", "name", _argList, 0)
	_res := o.O.(_reflect.Value).MethodByName(name)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_NumField from reflect/value.go:
func __value_NumField(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)NumField()", args, 0, 0)
	_res := o.O.(_reflect.Value).NumField()
	return MakeInt(_res)
}

GO FUNC reflect.__value_NumMethod from reflect/value.go:
func __value_NumMethod(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)NumMethod()", args, 0, 0)
	_res := o.O.(_reflect.Value).NumMethod()
	return MakeInt(_res)
}

GO FUNC reflect.__value_OverflowComplex from reflect/value.go:
// func __value_OverflowComplex(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(_reflect.Value)OverflowComplex()", args, 1, 1)
// 	x := ExtractGoABEND007(find these)("(_reflect.Value)OverflowComplex()", "x", _argList, 0)
// 	_res := o.O.(_reflect.Value).OverflowComplex(x)
// 	return MakeBoolean(_res)
// }

GO FUNC reflect.__value_OverflowFloat from reflect/value.go:
// func __value_OverflowFloat(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(_reflect.Value)OverflowFloat()", args, 1, 1)
// 	x := ExtractGoABEND007(find these)("(_reflect.Value)OverflowFloat()", "x", _argList, 0)
// 	_res := o.O.(_reflect.Value).OverflowFloat(x)
// 	return MakeBoolean(_res)
// }

GO FUNC reflect.__value_OverflowInt from reflect/value.go:
func __value_OverflowInt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)OverflowInt()", args, 1, 1)
	x := ExtractGoInt64("(_reflect.Value)OverflowInt()", "x", _argList, 0)
	_res := o.O.(_reflect.Value).OverflowInt(x)
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_OverflowUint from reflect/value.go:
func __value_OverflowUint(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)OverflowUint()", args, 1, 1)
	x := ExtractGoUInt64("(_reflect.Value)OverflowUint()", "x", _argList, 0)
	_res := o.O.(_reflect.Value).OverflowUint(x)
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_Pointer from reflect/value.go:
// func __value_Pointer(o GoObject, args Object) Object {
// 	CheckGoArity("(_reflect.Value)Pointer()", args, 0, 0)
// 	_res := o.O.(_reflect.Value).Pointer()
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC reflect.__value_Recv from reflect/value.go:
func __value_Recv(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Recv()", args, 0, 0)
	x, ok := o.O.(_reflect.Value).Recv()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(x))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC reflect.__value_Send from reflect/value.go:
// func __value_Send(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_Set from reflect/value.go:
// func __value_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetBool from reflect/value.go:
// func __value_SetBool(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetBytes from reflect/value.go:
// func __value_SetBytes(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(x)))}

GO FUNC reflect.__value_SetCap from reflect/value.go:
// func __value_SetCap(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetComplex from reflect/value.go:
// func __value_SetComplex(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetFloat from reflect/value.go:
// func __value_SetFloat(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetInt from reflect/value.go:
// func __value_SetInt(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetLen from reflect/value.go:
// func __value_SetLen(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetMapIndex from reflect/value.go:
// func __value_SetMapIndex(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetPointer from reflect/value.go:
// func __value_SetPointer(o GoObject, args Object) Object {
// x ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)}

GO FUNC reflect.__value_SetString from reflect/value.go:
// func __value_SetString(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_SetUint from reflect/value.go:
// func __value_SetUint(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC reflect.__value_Slice from reflect/value.go:
func __value_Slice(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Slice()", args, 2, 2)
	i := ExtractGoInt("(_reflect.Value)Slice()", "i", _argList, 0)
	j := ExtractGoInt("(_reflect.Value)Slice()", "j", _argList, 1)
	_res := o.O.(_reflect.Value).Slice(i, j)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Slice3 from reflect/value.go:
func __value_Slice3(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)Slice3()", args, 3, 3)
	i := ExtractGoInt("(_reflect.Value)Slice3()", "i", _argList, 0)
	j := ExtractGoInt("(_reflect.Value)Slice3()", "j", _argList, 1)
	k := ExtractGoInt("(_reflect.Value)Slice3()", "k", _argList, 2)
	_res := o.O.(_reflect.Value).Slice3(i, j, k)
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_String from reflect/value.go:
func __value_String(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)String()", args, 0, 0)
	_res := o.O.(_reflect.Value).String()
	return MakeString(_res)
}

GO FUNC reflect.__value_TryRecv from reflect/value.go:
func __value_TryRecv(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)TryRecv()", args, 0, 0)
	x, ok := o.O.(_reflect.Value).TryRecv()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(x))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC reflect.__value_TrySend from reflect/value.go:
func __value_TrySend(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_reflect.Value)TrySend()", args, 1, 1)
	x := ExtractGo_go_std_reflect__Value("(_reflect.Value)TrySend()", "x", _argList, 0)
	_res := o.O.(_reflect.Value).TrySend(x)
	return MakeBoolean(_res)
}

GO FUNC reflect.__value_Type from reflect/value.go:
func __value_Type(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Type()", args, 0, 0)
	_res := o.O.(_reflect.Value).Type()
	return MakeGoObject(_res)
}

GO FUNC reflect.__value_Uint from reflect/value.go:
func __value_Uint(o GoObject, args Object) Object {
	CheckGoArity("(_reflect.Value)Uint()", args, 0, 0)
	_res := o.O.(_reflect.Value).Uint()
	return MakeBigIntU(_res)
}

GO FUNC reflect.__value_UnsafeAddr from reflect/value.go:
// func __value_UnsafeAddr(o GoObject, args Object) Object {
// 	CheckGoArity("(_reflect.Value)UnsafeAddr()", args, 0, 0)
// 	_res := o.O.(_reflect.Value).UnsafeAddr()
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package reflect

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
)
var members_ChanDir = GoTypeInfo{Members: GoMembers{
	"String": __chanDir_String,
}}

var members_Kind = GoTypeInfo{Members: GoMembers{
	"String": __kind_String,
}}

var members_PtrTo_MapIter = GoTypeInfo{Members: GoMembers{
	"Key": __ptrTo_MapIter_Key,
	"Next": __ptrTo_MapIter_Next,
	"Value": __ptrTo_MapIter_Value,
}}

var members_StructTag = GoTypeInfo{Members: GoMembers{
	"Get": __structTag_Get,
	"Lookup": __structTag_Lookup,
}}

var members_Value = GoTypeInfo{Members: GoMembers{
	"Addr": __value_Addr,
	"Bool": __value_Bool,
	"Bytes": __value_Bytes,
	"CanAddr": __value_CanAddr,
	"CanInterface": __value_CanInterface,
	"CanSet": __value_CanSet,
	"Cap": __value_Cap,
	"Convert": __value_Convert,
	"Elem": __value_Elem,
	"Field": __value_Field,
	"FieldByName": __value_FieldByName,
	"Index": __value_Index,
	"Int": __value_Int,
	"IsNil": __value_IsNil,
	"IsValid": __value_IsValid,
	"Kind": __value_Kind,
	"Len": __value_Len,
	"MapIndex": __value_MapIndex,
	"MapKeys": __value_MapKeys,
	"MapRange": __value_MapRange,
	"Method": __value_Method,
	"MethodByName": __value_MethodByName,
	"NumField": __value_NumField,
	"NumMethod": __value_NumMethod,
	"OverflowInt": __value_OverflowInt,
	"OverflowUint": __value_OverflowUint,
	"Recv": __value_Recv,
	"Slice": __value_Slice,
	"Slice3": __value_Slice3,
	"String": __value_String,
	"TryRecv": __value_TryRecv,
	"TrySend": __value_TrySend,
	"Type": __value_Type,
	"Uint": __value_Uint,
}}

var members_PtrTo_ValueError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ValueError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_reflect.ChanDir)(nil)).Elem()] = &members_ChanDir
	GoTypes[_reflect.TypeOf((*_reflect.Kind)(nil)).Elem()] = &members_Kind
	GoTypes[_reflect.TypeOf((*_reflect.MapIter)(nil))] = &members_PtrTo_MapIter
	GoTypes[_reflect.TypeOf((*_reflect.StructTag)(nil)).Elem()] = &members_StructTag
	GoTypes[_reflect.TypeOf((*_reflect.Value)(nil)).Elem()] = &members_Value
	GoTypes[_reflect.TypeOf((*_reflect.ValueError)(nil))] = &members_PtrTo_ValueError
}

GO TYPE regexp.Regexp from regexp/regexp.go:
func ExtractGoObjectRegexp(args []Object, index int) *_regexp.Regexp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _regexp.Regexp:
			return &r
		case *_regexp.Regexp:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp.Regexp]"))
}

func _mapToRegexp(o Map) *_regexp.Regexp {
	return &_regexp.Regexp{}
}

func _vectorToRegexp(o *Vector) *_regexp.Regexp {
	return &_regexp.Regexp{}
}

func _ConstructRegexp(_v Object) *_regexp.Regexp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _regexp.Regexp:
			return &_g
		case *_regexp.Regexp:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegexp(_o.(Map))
	case *Vector:
		return _vectorToRegexp(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[regexp.Regexp] or: Map or Vector"))
}

GO FUNC regexp.Compile from regexp/regexp.go:
func __compile(expr string) Object {
	_res1, _res2 := _regexp.Compile(expr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.CompilePOSIX from regexp/regexp.go:
func __compilePOSIX(expr string) Object {
	_res1, _res2 := _regexp.CompilePOSIX(expr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.Match from regexp/regexp.go:
// func __match(pattern string, b []byte) Object {
// 	matched, err := _regexp.Match(pattern, b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBoolean(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchReader from regexp/regexp.go:
// func __matchReader(pattern string, r ABEND987(genutils.go: imports not yet supported: io.RuneReader)) Object {
// 	matched, err := _regexp.MatchReader(pattern, r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBoolean(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchString from regexp/regexp.go:
func __matchString(pattern string, s string) Object {
	matched, err := _regexp.MatchString(pattern, s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC regexp.MustCompile from regexp/regexp.go:
func __mustCompile(str string) Object {
	_res := _regexp.MustCompile(str)
	return MakeGoObject(_res)
}

GO FUNC regexp.MustCompilePOSIX from regexp/regexp.go:
func __mustCompilePOSIX(str string) Object {
	_res := _regexp.MustCompilePOSIX(str)
	return MakeGoObject(_res)
}

GO FUNC regexp.__ptrTo_Regexp_Copy from regexp/regexp.go:
func __ptrTo_Regexp_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp.Regexp)Copy()", args, 0, 0)
	_res := o.O.(*_regexp.Regexp).Copy()
	return MakeGoObject(_res)
}

GO FUNC regexp.__ptrTo_Regexp_Expand from regexp/regexp.go:
// func __ptrTo_Regexp_Expand(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(template)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(match)))}

GO FUNC regexp.__ptrTo_Regexp_ExpandString from regexp/regexp.go:
// func __ptrTo_Regexp_ExpandString(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(dst)), template, src, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfint(match)))}

GO FUNC regexp.__ptrTo_Regexp_Find from regexp/regexp.go:
// func __ptrTo_Regexp_Find(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC regexp.__ptrTo_Regexp_FindAll from regexp/regexp.go:
// func __ptrTo_Regexp_FindAll(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), n)}

GO FUNC regexp.__ptrTo_Regexp_FindAllIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindAllIndex(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), n)}

GO FUNC regexp.__ptrTo_Regexp_FindAllString from regexp/regexp.go:
func __ptrTo_Regexp_FindAllString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindAllString()", args, 2, 2)
	s := ExtractGoString("(*_regexp.Regexp)FindAllString()", "s", _argList, 0)
	n := ExtractGoInt("(*_regexp.Regexp)FindAllString()", "n", _argList, 1)
	_res := o.O.(*_regexp.Regexp).FindAllString(s, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindAllStringIndex from regexp/regexp.go:
func __ptrTo_Regexp_FindAllStringIndex(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindAllStringIndex()", args, 2, 2)
	s := ExtractGoString("(*_regexp.Regexp)FindAllStringIndex()", "s", _argList, 0)
	n := ExtractGoInt("(*_regexp.Regexp)FindAllStringIndex()", "n", _argList, 1)
	_res := o.O.(*_regexp.Regexp).FindAllStringIndex(s, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(_elem2))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindAllStringSubmatch from regexp/regexp.go:
func __ptrTo_Regexp_FindAllStringSubmatch(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindAllStringSubmatch()", args, 2, 2)
	s := ExtractGoString("(*_regexp.Regexp)FindAllStringSubmatch()", "s", _argList, 0)
	n := ExtractGoInt("(*_regexp.Regexp)FindAllStringSubmatch()", "n", _argList, 1)
	_res := o.O.(*_regexp.Regexp).FindAllStringSubmatch(s, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeString(_elem2))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindAllStringSubmatchIndex from regexp/regexp.go:
func __ptrTo_Regexp_FindAllStringSubmatchIndex(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindAllStringSubmatchIndex()", args, 2, 2)
	s := ExtractGoString("(*_regexp.Regexp)FindAllStringSubmatchIndex()", "s", _argList, 0)
	n := ExtractGoInt("(*_regexp.Regexp)FindAllStringSubmatchIndex()", "n", _argList, 1)
	_res := o.O.(*_regexp.Regexp).FindAllStringSubmatchIndex(s, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec2 := EmptyVector()
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(_elem2))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindAllSubmatch from regexp/regexp.go:
// func __ptrTo_Regexp_FindAllSubmatch(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), n)}

GO FUNC regexp.__ptrTo_Regexp_FindAllSubmatchIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindAllSubmatchIndex(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), n)}

GO FUNC regexp.__ptrTo_Regexp_FindIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindIndex(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC regexp.__ptrTo_Regexp_FindReaderIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindReaderIndex(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.RuneReader)}

GO FUNC regexp.__ptrTo_Regexp_FindReaderSubmatchIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindReaderSubmatchIndex(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.RuneReader)}

GO FUNC regexp.__ptrTo_Regexp_FindString from regexp/regexp.go:
func __ptrTo_Regexp_FindString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindString()", args, 1, 1)
	s := ExtractGoString("(*_regexp.Regexp)FindString()", "s", _argList, 0)
	_res := o.O.(*_regexp.Regexp).FindString(s)
	return MakeString(_res)
}

GO FUNC regexp.__ptrTo_Regexp_FindStringIndex from regexp/regexp.go:
func __ptrTo_Regexp_FindStringIndex(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindStringIndex()", args, 1, 1)
	s := ExtractGoString("(*_regexp.Regexp)FindStringIndex()", "s", _argList, 0)
	_res := o.O.(*_regexp.Regexp).FindStringIndex(s)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindStringSubmatch from regexp/regexp.go:
func __ptrTo_Regexp_FindStringSubmatch(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindStringSubmatch()", args, 1, 1)
	s := ExtractGoString("(*_regexp.Regexp)FindStringSubmatch()", "s", _argList, 0)
	_res := o.O.(*_regexp.Regexp).FindStringSubmatch(s)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindStringSubmatchIndex from regexp/regexp.go:
func __ptrTo_Regexp_FindStringSubmatchIndex(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)FindStringSubmatchIndex()", args, 1, 1)
	s := ExtractGoString("(*_regexp.Regexp)FindStringSubmatchIndex()", "s", _argList, 0)
	_res := o.O.(*_regexp.Regexp).FindStringSubmatchIndex(s)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_FindSubmatch from regexp/regexp.go:
// func __ptrTo_Regexp_FindSubmatch(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC regexp.__ptrTo_Regexp_FindSubmatchIndex from regexp/regexp.go:
// func __ptrTo_Regexp_FindSubmatchIndex(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC regexp.__ptrTo_Regexp_LiteralPrefix from regexp/regexp.go:
func __ptrTo_Regexp_LiteralPrefix(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp.Regexp)LiteralPrefix()", args, 0, 0)
	prefix, complete := o.O.(*_regexp.Regexp).LiteralPrefix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(prefix))
	_res = _res.Conjoin(MakeBoolean(complete))
	return _res
}

GO FUNC regexp.__ptrTo_Regexp_Longest from regexp/regexp.go:
// func __ptrTo_Regexp_Longest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC regexp.__ptrTo_Regexp_Match from regexp/regexp.go:
// func __ptrTo_Regexp_Match(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC regexp.__ptrTo_Regexp_MatchReader from regexp/regexp.go:
// func __ptrTo_Regexp_MatchReader(o GoObject, args Object) Object {
// r ABEND987(genutils.go: imports not yet supported: io.RuneReader)}

GO FUNC regexp.__ptrTo_Regexp_MatchString from regexp/regexp.go:
func __ptrTo_Regexp_MatchString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)MatchString()", args, 1, 1)
	s := ExtractGoString("(*_regexp.Regexp)MatchString()", "s", _argList, 0)
	_res := o.O.(*_regexp.Regexp).MatchString(s)
	return MakeBoolean(_res)
}

GO FUNC regexp.__ptrTo_Regexp_NumSubexp from regexp/regexp.go:
func __ptrTo_Regexp_NumSubexp(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp.Regexp)NumSubexp()", args, 0, 0)
	_res := o.O.(*_regexp.Regexp).NumSubexp()
	return MakeInt(_res)
}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAll from regexp/regexp.go:
// func __ptrTo_Regexp_ReplaceAll(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(repl)))}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAllFunc from regexp/regexp.go:
// func __ptrTo_Regexp_ReplaceAllFunc(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAllLiteral from regexp/regexp.go:
// func __ptrTo_Regexp_ReplaceAllLiteral(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(src)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(repl)))}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAllLiteralString from regexp/regexp.go:
func __ptrTo_Regexp_ReplaceAllLiteralString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)ReplaceAllLiteralString()", args, 2, 2)
	src := ExtractGoString("(*_regexp.Regexp)ReplaceAllLiteralString()", "src", _argList, 0)
	repl := ExtractGoString("(*_regexp.Regexp)ReplaceAllLiteralString()", "repl", _argList, 1)
	_res := o.O.(*_regexp.Regexp).ReplaceAllLiteralString(src, repl)
	return MakeString(_res)
}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAllString from regexp/regexp.go:
func __ptrTo_Regexp_ReplaceAllString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)ReplaceAllString()", args, 2, 2)
	src := ExtractGoString("(*_regexp.Regexp)ReplaceAllString()", "src", _argList, 0)
	repl := ExtractGoString("(*_regexp.Regexp)ReplaceAllString()", "repl", _argList, 1)
	_res := o.O.(*_regexp.Regexp).ReplaceAllString(src, repl)
	return MakeString(_res)
}

GO FUNC regexp.__ptrTo_Regexp_ReplaceAllStringFunc from regexp/regexp.go:
// func __ptrTo_Regexp_ReplaceAllStringFunc(o GoObject, args Object) Object {
// (src, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC regexp.__ptrTo_Regexp_Split from regexp/regexp.go:
func __ptrTo_Regexp_Split(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp.Regexp)Split()", args, 2, 2)
	s := ExtractGoString("(*_regexp.Regexp)Split()", "s", _argList, 0)
	n := ExtractGoInt("(*_regexp.Regexp)Split()", "n", _argList, 1)
	_res := o.O.(*_regexp.Regexp).Split(s, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC regexp.__ptrTo_Regexp_String from regexp/regexp.go:
func __ptrTo_Regexp_String(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp.Regexp)String()", args, 0, 0)
	_res := o.O.(*_regexp.Regexp).String()
	return MakeString(_res)
}

GO FUNC regexp.__ptrTo_Regexp_SubexpNames from regexp/regexp.go:
func __ptrTo_Regexp_SubexpNames(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp.Regexp)SubexpNames()", args, 0, 0)
	_res := o.O.(*_regexp.Regexp).SubexpNames()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package regexp

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_regexp "regexp"
)
var members_PtrTo_Regexp = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_Regexp_Copy,
	"FindAllString": __ptrTo_Regexp_FindAllString,
	"FindAllStringIndex": __ptrTo_Regexp_FindAllStringIndex,
	"FindAllStringSubmatch": __ptrTo_Regexp_FindAllStringSubmatch,
	"FindAllStringSubmatchIndex": __ptrTo_Regexp_FindAllStringSubmatchIndex,
	"FindString": __ptrTo_Regexp_FindString,
	"FindStringIndex": __ptrTo_Regexp_FindStringIndex,
	"FindStringSubmatch": __ptrTo_Regexp_FindStringSubmatch,
	"FindStringSubmatchIndex": __ptrTo_Regexp_FindStringSubmatchIndex,
	"LiteralPrefix": __ptrTo_Regexp_LiteralPrefix,
	"MatchString": __ptrTo_Regexp_MatchString,
	"NumSubexp": __ptrTo_Regexp_NumSubexp,
	"ReplaceAllLiteralString": __ptrTo_Regexp_ReplaceAllLiteralString,
	"ReplaceAllString": __ptrTo_Regexp_ReplaceAllString,
	"Split": __ptrTo_Regexp_Split,
	"String": __ptrTo_Regexp_String,
	"SubexpNames": __ptrTo_Regexp_SubexpNames,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_regexp.Regexp)(nil))] = &members_PtrTo_Regexp
}

GO TYPE regexp/syntax.EmptyOp from regexp/syntax/prog.go:
func ExtractGoObjectEmptyOp(args []Object, index int) *_syntax.EmptyOp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.EmptyOp:
			return &r
		case *_syntax.EmptyOp:
			return r
		}
	case Int:
		v := _syntax.EmptyOp(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.EmptyOp]"))
}

func _ConstructEmptyOp(_v Object) _syntax.EmptyOp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.EmptyOp:
			return _g
		case *_syntax.EmptyOp:
			return *_g
		}
	case Number:
		return _syntax.EmptyOp(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.EmptyOp] or: Number"))
}

GO TYPE regexp/syntax.Error from regexp/syntax/parse.go:
func ExtractGoObjectError(args []Object, index int) *_syntax.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Error:
			return &r
		case *_syntax.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Error]"))
}

func _mapToError(o Map) *_syntax.Error {
	return &_syntax.Error{}
}

func _vectorToError(o *Vector) *_syntax.Error {
	return &_syntax.Error{
		Code: _syntax.ErrorCode(AssertString(o.Nth(0), "").S),
		Expr: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructError(_v Object) *_syntax.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Error:
			return &_g
		case *_syntax.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Error] or: Map or Vector"))
}

GO TYPE regexp/syntax.ErrorCode from regexp/syntax/parse.go:
func ExtractGoObjectErrorCode(args []Object, index int) *_syntax.ErrorCode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.ErrorCode:
			return &r
		case *_syntax.ErrorCode:
			return r
		}
	case String:
		v := _syntax.ErrorCode(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.ErrorCode]"))
}

func _ConstructErrorCode(_v Object) _syntax.ErrorCode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.ErrorCode:
			return _g
		case *_syntax.ErrorCode:
			return *_g
		}
	case String:
		return _syntax.ErrorCode(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.ErrorCode] or: String"))
}

GO TYPE regexp/syntax.Flags from regexp/syntax/parse.go:
func ExtractGoObjectFlags(args []Object, index int) *_syntax.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Flags:
			return &r
		case *_syntax.Flags:
			return r
		}
	case Int:
		v := _syntax.Flags(ExtractUInt16(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Flags]"))
}

func _ConstructFlags(_v Object) _syntax.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Flags:
			return _g
		case *_syntax.Flags:
			return *_g
		}
	case Number:
		return _syntax.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Flags] or: Number"))
}

GO TYPE regexp/syntax.Inst from regexp/syntax/prog.go:
func ExtractGoObjectInst(args []Object, index int) *_syntax.Inst {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Inst:
			return &r
		case *_syntax.Inst:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Inst]"))
}

// func _mapToInst(o Map) *_syntax.Inst {
// 	return &_syntax.Inst{}
// }

// func _vectorToInst(o *Vector) *_syntax.Inst {
// 	return &_syntax.Inst{
// 		Op: _syntax.InstOp(uint8(AssertInt(o.Nth(0), "").I)),
// 		Out: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Arg: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		Rune: ABEND048(codegen.go: no conversion from Clojure for []rune (rune)),
// 	}
// }

// func _ConstructInst(_v Object) *_syntax.Inst {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syntax.Inst:
// 			return &_g
// 		case *_syntax.Inst:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInst(_o.(Map))
// 	case *Vector:
// 		return _vectorToInst(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Inst] or: Map or Vector"))
// }

GO TYPE regexp/syntax.InstOp from regexp/syntax/prog.go:
func ExtractGoObjectInstOp(args []Object, index int) *_syntax.InstOp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.InstOp:
			return &r
		case *_syntax.InstOp:
			return r
		}
	case Int:
		v := _syntax.InstOp(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.InstOp]"))
}

func _ConstructInstOp(_v Object) _syntax.InstOp {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.InstOp:
			return _g
		case *_syntax.InstOp:
			return *_g
		}
	case Number:
		return _syntax.InstOp(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.InstOp] or: Number"))
}

GO TYPE regexp/syntax.Op from regexp/syntax/regexp.go:
func ExtractGoObjectOp(args []Object, index int) *_syntax.Op {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Op:
			return &r
		case *_syntax.Op:
			return r
		}
	case Int:
		v := _syntax.Op(ExtractUInt8(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Op]"))
}

func _ConstructOp(_v Object) _syntax.Op {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syntax.Op:
			return _g
		case *_syntax.Op:
			return *_g
		}
	case Number:
		return _syntax.Op(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Op] or: Number"))
}

GO TYPE regexp/syntax.Prog from regexp/syntax/prog.go:
func ExtractGoObjectProg(args []Object, index int) *_syntax.Prog {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Prog:
			return &r
		case *_syntax.Prog:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Prog]"))
}

// func _mapToProg(o Map) *_syntax.Prog {
// 	return &_syntax.Prog{}
// }

// func _vectorToProg(o *Vector) *_syntax.Prog {
// 	return &_syntax.Prog{
// 		Inst: ABEND048(codegen.go: no conversion from Clojure for []regexp/syntax.Inst (regexp/syntax.Inst)),
// 		Start: AssertInt(o.Nth(1), "").I,
// 		NumCap: AssertInt(o.Nth(2), "").I,
// 	}
// }

// func _ConstructProg(_v Object) *_syntax.Prog {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syntax.Prog:
// 			return &_g
// 		case *_syntax.Prog:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToProg(_o.(Map))
// 	case *Vector:
// 		return _vectorToProg(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Prog] or: Map or Vector"))
// }

GO TYPE regexp/syntax.Regexp from regexp/syntax/regexp.go:
func ExtractGoObjectRegexp(args []Object, index int) *_syntax.Regexp {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syntax.Regexp:
			return &r
		case *_syntax.Regexp:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[regexp/syntax.Regexp]"))
}

// func _mapToRegexp(o Map) *_syntax.Regexp {
// 	return &_syntax.Regexp{}
// }

// func _vectorToRegexp(o *Vector) *_syntax.Regexp {
// 	return &_syntax.Regexp{
// 		Op: _syntax.Op(uint8(AssertInt(o.Nth(0), "").I)),
// 		Flags: _syntax.Flags(uint16(AssertInt(o.Nth(1), "").I)),
// 		Sub: ABEND048(codegen.go: no conversion from Clojure for []*regexp/syntax.Regexp (*regexp/syntax.Regexp)),
// 		Sub0: ABEND048(codegen.go: no conversion from Clojure for [1]*regexp/syntax.Regexp (*regexp/syntax.Regexp)),
// 		Rune: ABEND048(codegen.go: no conversion from Clojure for []rune (rune)),
// 		Rune0: ABEND048(codegen.go: no conversion from Clojure for [2]rune (rune)),
// 		Min: AssertInt(o.Nth(6), "").I,
// 		Max: AssertInt(o.Nth(7), "").I,
// 		Cap: AssertInt(o.Nth(8), "").I,
// 		Name: AssertString(o.Nth(9), "").S,
// 	}
// }

// func _ConstructRegexp(_v Object) *_syntax.Regexp {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syntax.Regexp:
// 			return &_g
// 		case *_syntax.Regexp:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRegexp(_o.(Map))
// 	case *Vector:
// 		return _vectorToRegexp(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syntax.Regexp] or: Map or Vector"))
// }

GO FUNC regexp/syntax.Compile from regexp/syntax/compile.go:
func __compile(re *_syntax.Regexp) Object {
	_res1, _res2 := _syntax.Compile(re)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp/syntax.EmptyOpContext from regexp/syntax/prog.go:
func __emptyOpContext(r1 rune, r2 rune) Object {
	_res := _syntax.EmptyOpContext(r1, r2)
	return MakeGoObject(_res)
}

GO FUNC regexp/syntax.Parse from regexp/syntax/parse.go:
func __parse(s string, flags _syntax.Flags) Object {
	_res1, _res2 := _syntax.Parse(s, flags)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp/syntax.__errorCode_String from regexp/syntax/parse.go:
func __errorCode_String(o GoObject, args Object) Object {
	CheckGoArity("(_regexp/syntax.ErrorCode)String()", args, 0, 0)
	_res := o.O.(_syntax.ErrorCode).String()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__instOp_String from regexp/syntax/prog.go:
func __instOp_String(o GoObject, args Object) Object {
	CheckGoArity("(_regexp/syntax.InstOp)String()", args, 0, 0)
	_res := o.O.(_syntax.InstOp).String()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__op_String from regexp/syntax/op_string.go:
func __op_String(o GoObject, args Object) Object {
	CheckGoArity("(_regexp/syntax.Op)String()", args, 0, 0)
	_res := o.O.(_syntax.Op).String()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__ptrTo_Error_Error from regexp/syntax/parse.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Error)Error()", args, 0, 0)
	_res := o.O.(*_syntax.Error).Error()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__ptrTo_Inst_MatchEmptyWidth from regexp/syntax/prog.go:
func __ptrTo_Inst_MatchEmptyWidth(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp/syntax.Inst)MatchEmptyWidth()", args, 2, 2)
	before := ExtractGoChar("(*_regexp/syntax.Inst)MatchEmptyWidth()", "before", _argList, 0)
	after := ExtractGoChar("(*_regexp/syntax.Inst)MatchEmptyWidth()", "after", _argList, 1)
	_res := o.O.(*_syntax.Inst).MatchEmptyWidth(before, after)
	return MakeBoolean(_res)
}

GO FUNC regexp/syntax.__ptrTo_Inst_MatchRune from regexp/syntax/prog.go:
func __ptrTo_Inst_MatchRune(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp/syntax.Inst)MatchRune()", args, 1, 1)
	r := ExtractGoChar("(*_regexp/syntax.Inst)MatchRune()", "r", _argList, 0)
	_res := o.O.(*_syntax.Inst).MatchRune(r)
	return MakeBoolean(_res)
}

GO FUNC regexp/syntax.__ptrTo_Inst_MatchRunePos from regexp/syntax/prog.go:
func __ptrTo_Inst_MatchRunePos(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_regexp/syntax.Inst)MatchRunePos()", args, 1, 1)
	r := ExtractGoChar("(*_regexp/syntax.Inst)MatchRunePos()", "r", _argList, 0)
	_res := o.O.(*_syntax.Inst).MatchRunePos(r)
	return MakeInt(_res)
}

GO FUNC regexp/syntax.__ptrTo_Inst_String from regexp/syntax/prog.go:
func __ptrTo_Inst_String(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Inst)String()", args, 0, 0)
	_res := o.O.(*_syntax.Inst).String()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__ptrTo_Prog_Prefix from regexp/syntax/prog.go:
func __ptrTo_Prog_Prefix(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Prog)Prefix()", args, 0, 0)
	prefix, complete := o.O.(*_syntax.Prog).Prefix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(prefix))
	_res = _res.Conjoin(MakeBoolean(complete))
	return _res
}

GO FUNC regexp/syntax.__ptrTo_Prog_StartCond from regexp/syntax/prog.go:
func __ptrTo_Prog_StartCond(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Prog)StartCond()", args, 0, 0)
	_res := o.O.(*_syntax.Prog).StartCond()
	return MakeGoObject(_res)
}

GO FUNC regexp/syntax.__ptrTo_Prog_String from regexp/syntax/prog.go:
func __ptrTo_Prog_String(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Prog)String()", args, 0, 0)
	_res := o.O.(*_syntax.Prog).String()
	return MakeString(_res)
}

GO FUNC regexp/syntax.__ptrTo_Regexp_CapNames from regexp/syntax/regexp.go:
func __ptrTo_Regexp_CapNames(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Regexp)CapNames()", args, 0, 0)
	_res := o.O.(*_syntax.Regexp).CapNames()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC regexp/syntax.__ptrTo_Regexp_Equal from regexp/syntax/regexp.go:
// func __ptrTo_Regexp_Equal(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_regexp/syntax.Regexp)Equal()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for y at: /usr/local/go/src/regexp/syntax/regexp.go:63:26)
// 	_res := o.O.(*_syntax.Regexp).Equal(y)
// 	return MakeBoolean(_res)
// }

GO FUNC regexp/syntax.__ptrTo_Regexp_MaxCap from regexp/syntax/regexp.go:
func __ptrTo_Regexp_MaxCap(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Regexp)MaxCap()", args, 0, 0)
	_res := o.O.(*_syntax.Regexp).MaxCap()
	return MakeInt(_res)
}

GO FUNC regexp/syntax.__ptrTo_Regexp_Simplify from regexp/syntax/simplify.go:
func __ptrTo_Regexp_Simplify(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Regexp)Simplify()", args, 0, 0)
	_res := o.O.(*_syntax.Regexp).Simplify()
	return MakeGoObject(_res)
}

GO FUNC regexp/syntax.__ptrTo_Regexp_String from regexp/syntax/regexp.go:
func __ptrTo_Regexp_String(o GoObject, args Object) Object {
	CheckGoArity("(*_regexp/syntax.Regexp)String()", args, 0, 0)
	_res := o.O.(*_syntax.Regexp).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syntax

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_syntax "regexp/syntax"
)
var members_PtrTo_Error = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_Error_Error,
}}

var members_ErrorCode = GoTypeInfo{Members: GoMembers{
	"String": __errorCode_String,
}}

var members_PtrTo_Inst = GoTypeInfo{Members: GoMembers{
	"MatchEmptyWidth": __ptrTo_Inst_MatchEmptyWidth,
	"MatchRune": __ptrTo_Inst_MatchRune,
	"MatchRunePos": __ptrTo_Inst_MatchRunePos,
	"String": __ptrTo_Inst_String,
}}

var members_InstOp = GoTypeInfo{Members: GoMembers{
	"String": __instOp_String,
}}

var members_Op = GoTypeInfo{Members: GoMembers{
	"String": __op_String,
}}

var members_PtrTo_Prog = GoTypeInfo{Members: GoMembers{
	"Prefix": __ptrTo_Prog_Prefix,
	"StartCond": __ptrTo_Prog_StartCond,
	"String": __ptrTo_Prog_String,
}}

var members_PtrTo_Regexp = GoTypeInfo{Members: GoMembers{
	"CapNames": __ptrTo_Regexp_CapNames,
	"MaxCap": __ptrTo_Regexp_MaxCap,
	"Simplify": __ptrTo_Regexp_Simplify,
	"String": __ptrTo_Regexp_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_syntax.Error)(nil))] = &members_PtrTo_Error
	GoTypes[_reflect.TypeOf((*_syntax.ErrorCode)(nil)).Elem()] = &members_ErrorCode
	GoTypes[_reflect.TypeOf((*_syntax.Inst)(nil))] = &members_PtrTo_Inst
	GoTypes[_reflect.TypeOf((*_syntax.InstOp)(nil)).Elem()] = &members_InstOp
	GoTypes[_reflect.TypeOf((*_syntax.Op)(nil)).Elem()] = &members_Op
	GoTypes[_reflect.TypeOf((*_syntax.Prog)(nil))] = &members_PtrTo_Prog
	GoTypes[_reflect.TypeOf((*_syntax.Regexp)(nil))] = &members_PtrTo_Regexp
}

GO TYPE runtime.BlockProfileRecord from runtime/mprof.go:
func ExtractGoObjectBlockProfileRecord(args []Object, index int) *_runtime.BlockProfileRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.BlockProfileRecord:
			return &r
		case *_runtime.BlockProfileRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.BlockProfileRecord]"))
}

func _mapToBlockProfileRecord(o Map) *_runtime.BlockProfileRecord {
	return &_runtime.BlockProfileRecord{}
}

func _vectorToBlockProfileRecord(o *Vector) *_runtime.BlockProfileRecord {
	return &_runtime.BlockProfileRecord{
		Count: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Cycles: AssertNumber(o.Nth(1), "").BigInt().Int64(),
	}
}

func _ConstructBlockProfileRecord(_v Object) *_runtime.BlockProfileRecord {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.BlockProfileRecord:
			return &_g
		case *_runtime.BlockProfileRecord:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBlockProfileRecord(_o.(Map))
	case *Vector:
		return _vectorToBlockProfileRecord(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.BlockProfileRecord] or: Map or Vector"))
}

GO TYPE runtime.Error from runtime/error.go:
func ExtractGoObjectError(args []Object, index int) *_runtime.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Error:
			return &r
		case *_runtime.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Error]"))
}

// func _ConstructError(_v Object) _runtime.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.Error:
// 			return _g
// 		case *_runtime.Error:
// 			return *_g
// 		}
// 	default:
// 		return _runtime.Error(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Error] or: whatever"))
// }

GO TYPE runtime.Frame from runtime/symtab.go:
func ExtractGoObjectFrame(args []Object, index int) *_runtime.Frame {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Frame:
			return &r
		case *_runtime.Frame:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Frame]"))
}

// func _mapToFrame(o Map) *_runtime.Frame {
// 	return &_runtime.Frame{}
// }

// func _vectorToFrame(o *Vector) *_runtime.Frame {
// 	return &_runtime.Frame{
// 		PC: uintptr(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Func: ABEND048(codegen.go: no conversion from Clojure for *runtime.Func (runtime.Func)),
// 		Function: AssertString(o.Nth(2), "").S,
// 		File: AssertString(o.Nth(3), "").S,
// 		Line: AssertInt(o.Nth(4), "").I,
// 		Entry: uintptr(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructFrame(_v Object) *_runtime.Frame {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.Frame:
// 			return &_g
// 		case *_runtime.Frame:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFrame(_o.(Map))
// 	case *Vector:
// 		return _vectorToFrame(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Frame] or: Map or Vector"))
// }

GO TYPE runtime.Frames from runtime/symtab.go:
func ExtractGoObjectFrames(args []Object, index int) *_runtime.Frames {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Frames:
			return &r
		case *_runtime.Frames:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Frames]"))
}

func _mapToFrames(o Map) *_runtime.Frames {
	return &_runtime.Frames{}
}

func _vectorToFrames(o *Vector) *_runtime.Frames {
	return &_runtime.Frames{}
}

func _ConstructFrames(_v Object) *_runtime.Frames {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.Frames:
			return &_g
		case *_runtime.Frames:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFrames(_o.(Map))
	case *Vector:
		return _vectorToFrames(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Frames] or: Map or Vector"))
}

GO TYPE runtime.Func from runtime/symtab.go:
func ExtractGoObjectFunc(args []Object, index int) *_runtime.Func {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.Func:
			return &r
		case *_runtime.Func:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.Func]"))
}

func _mapToFunc(o Map) *_runtime.Func {
	return &_runtime.Func{}
}

func _vectorToFunc(o *Vector) *_runtime.Func {
	return &_runtime.Func{}
}

func _ConstructFunc(_v Object) *_runtime.Func {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.Func:
			return &_g
		case *_runtime.Func:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFunc(_o.(Map))
	case *Vector:
		return _vectorToFunc(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.Func] or: Map or Vector"))
}

GO TYPE runtime.MemProfileRecord from runtime/mprof.go:
func ExtractGoObjectMemProfileRecord(args []Object, index int) *_runtime.MemProfileRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.MemProfileRecord:
			return &r
		case *_runtime.MemProfileRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.MemProfileRecord]"))
}

// func _mapToMemProfileRecord(o Map) *_runtime.MemProfileRecord {
// 	return &_runtime.MemProfileRecord{}
// }

// func _vectorToMemProfileRecord(o *Vector) *_runtime.MemProfileRecord {
// 	return &_runtime.MemProfileRecord{
// 		AllocBytes: AssertNumber(o.Nth(0), "").BigInt().Int64(),
// 		FreeBytes: AssertNumber(o.Nth(1), "").BigInt().Int64(),
// 		AllocObjects: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 		FreeObjects: AssertNumber(o.Nth(3), "").BigInt().Int64(),
// 		Stack0: ABEND048(codegen.go: no conversion from Clojure for [32]uintptr (uintptr)),
// 	}
// }

// func _ConstructMemProfileRecord(_v Object) *_runtime.MemProfileRecord {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.MemProfileRecord:
// 			return &_g
// 		case *_runtime.MemProfileRecord:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMemProfileRecord(_o.(Map))
// 	case *Vector:
// 		return _vectorToMemProfileRecord(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.MemProfileRecord] or: Map or Vector"))
// }

GO TYPE runtime.MemStats from runtime/mstats.go:
func ExtractGoObjectMemStats(args []Object, index int) *_runtime.MemStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.MemStats:
			return &r
		case *_runtime.MemStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.MemStats]"))
}

// func _mapToMemStats(o Map) *_runtime.MemStats {
// 	return &_runtime.MemStats{}
// }

// func _vectorToMemStats(o *Vector) *_runtime.MemStats {
// 	return &_runtime.MemStats{
// 		Alloc: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		TotalAlloc: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Sys: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
// 		Lookups: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Mallocs: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
// 		Frees: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
// 		HeapAlloc: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
// 		HeapSys: AssertNumber(o.Nth(7), "").BigInt().Uint64(),
// 		HeapIdle: AssertNumber(o.Nth(8), "").BigInt().Uint64(),
// 		HeapInuse: AssertNumber(o.Nth(9), "").BigInt().Uint64(),
// 		HeapReleased: AssertNumber(o.Nth(10), "").BigInt().Uint64(),
// 		HeapObjects: AssertNumber(o.Nth(11), "").BigInt().Uint64(),
// 		StackInuse: AssertNumber(o.Nth(12), "").BigInt().Uint64(),
// 		StackSys: AssertNumber(o.Nth(13), "").BigInt().Uint64(),
// 		MSpanInuse: AssertNumber(o.Nth(14), "").BigInt().Uint64(),
// 		MSpanSys: AssertNumber(o.Nth(15), "").BigInt().Uint64(),
// 		MCacheInuse: AssertNumber(o.Nth(16), "").BigInt().Uint64(),
// 		MCacheSys: AssertNumber(o.Nth(17), "").BigInt().Uint64(),
// 		BuckHashSys: AssertNumber(o.Nth(18), "").BigInt().Uint64(),
// 		GCSys: AssertNumber(o.Nth(19), "").BigInt().Uint64(),
// 		OtherSys: AssertNumber(o.Nth(20), "").BigInt().Uint64(),
// 		NextGC: AssertNumber(o.Nth(21), "").BigInt().Uint64(),
// 		LastGC: AssertNumber(o.Nth(22), "").BigInt().Uint64(),
// 		PauseTotalNs: AssertNumber(o.Nth(23), "").BigInt().Uint64(),
// 		PauseNs: ABEND048(codegen.go: no conversion from Clojure for [256]uint64 (uint64)),
// 		PauseEnd: ABEND048(codegen.go: no conversion from Clojure for [256]uint64 (uint64)),
// 		NumGC: uint32(AssertNumber(o.Nth(26), "").BigInt().Uint64()),
// 		NumForcedGC: uint32(AssertNumber(o.Nth(27), "").BigInt().Uint64()),
// 		GCCPUFraction: float64(AssertDouble(o.Nth(28), "").D),
// 		EnableGC: ToBool(o.Nth(29)),
// 		DebugGC: ToBool(o.Nth(30)),
// 		BySize: [61]ABEND047(gotypes.go: unsupported type *ast.StructType),
// 	}
// }

// func _ConstructMemStats(_v Object) *_runtime.MemStats {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.MemStats:
// 			return &_g
// 		case *_runtime.MemStats:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMemStats(_o.(Map))
// 	case *Vector:
// 		return _vectorToMemStats(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.MemStats] or: Map or Vector"))
// }

GO TYPE runtime.StackRecord from runtime/mprof.go:
func ExtractGoObjectStackRecord(args []Object, index int) *_runtime.StackRecord {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.StackRecord:
			return &r
		case *_runtime.StackRecord:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.StackRecord]"))
}

// func _mapToStackRecord(o Map) *_runtime.StackRecord {
// 	return &_runtime.StackRecord{}
// }

// func _vectorToStackRecord(o *Vector) *_runtime.StackRecord {
// 	return &_runtime.StackRecord{
// 		Stack0: ABEND048(codegen.go: no conversion from Clojure for [32]uintptr (uintptr)),
// 	}
// }

// func _ConstructStackRecord(_v Object) *_runtime.StackRecord {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _runtime.StackRecord:
// 			return &_g
// 		case *_runtime.StackRecord:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStackRecord(_o.(Map))
// 	case *Vector:
// 		return _vectorToStackRecord(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.StackRecord] or: Map or Vector"))
// }

GO TYPE runtime.TypeAssertionError from runtime/error.go:
func ExtractGoObjectTypeAssertionError(args []Object, index int) *_runtime.TypeAssertionError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _runtime.TypeAssertionError:
			return &r
		case *_runtime.TypeAssertionError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime.TypeAssertionError]"))
}

func _mapToTypeAssertionError(o Map) *_runtime.TypeAssertionError {
	return &_runtime.TypeAssertionError{}
}

func _vectorToTypeAssertionError(o *Vector) *_runtime.TypeAssertionError {
	return &_runtime.TypeAssertionError{}
}

func _ConstructTypeAssertionError(_v Object) *_runtime.TypeAssertionError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _runtime.TypeAssertionError:
			return &_g
		case *_runtime.TypeAssertionError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTypeAssertionError(_o.(Map))
	case *Vector:
		return _vectorToTypeAssertionError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[runtime.TypeAssertionError] or: Map or Vector"))
}

GO FUNC runtime.BlockProfile from runtime/mprof.go:
// func __blockProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.BlockProfile(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.Breakpoint from runtime/proc.go:
// func __breakpoint() Object {
// 	_runtime.Breakpoint()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.CPUProfile from runtime/cpuprof.go:
func __cPUProfile() Object {
	_res := _runtime.CPUProfile()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.Caller from runtime/extern.go:
// func __caller(skip int) Object {
// 	pc, file, line, ok := _runtime.Caller(skip)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeString(file))
// 	_res = _res.Conjoin(MakeInt(line))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.Callers from runtime/extern.go:
// func __callers(skip int, pc []uintptr)  {
// 	_res := _runtime.Callers(skip, pc)
// 	return MakeInt(_res)
// }

GO FUNC runtime.CallersFrames from runtime/symtab.go:
// func __callersFrames(callers []uintptr) Object {
// 	_res := _runtime.CallersFrames(callers)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime.FuncForPC from runtime/symtab.go:
func __funcForPC(pc uintptr) Object {
	_res := _runtime.FuncForPC(pc)
	return MakeGoObject(_res)
}

GO FUNC runtime.GC from runtime/mgc.go:
// func __gC() Object {
// 	_runtime.GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Goexit from runtime/panic.go:
// func __goexit() Object {
// 	_runtime.Goexit()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.GoroutineProfile from runtime/mprof.go:
// func __goroutineProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.GoroutineProfile(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.Gosched from runtime/proc.go:
// func __gosched() Object {
// 	_runtime.Gosched()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.KeepAlive from runtime/mfinal.go:
// func __keepAlive(x interface {}) Object {
// 	_runtime.KeepAlive(x)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.LockOSThread from runtime/proc.go:
// func __lockOSThread() Object {
// 	_runtime.LockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.MemProfile from runtime/mprof.go:
// func __memProfile(p []_runtime.MemProfileRecord, inuseZero bool) Object {
// 	n, ok := _runtime.MemProfile(p, inuseZero)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.MutexProfile from runtime/mprof.go:
// func __mutexProfile(p []_runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.MutexProfile(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.NumCgoCall from runtime/debug.go:
func __numCgoCall() Object {
	_res := _runtime.NumCgoCall()
	return MakeBigInt(_res)
}

GO FUNC runtime.ReadMemStats from runtime/mstats.go:
// func __readMemStats(m *_runtime.MemStats) Object {
// 	_runtime.ReadMemStats(m)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ReadTrace from runtime/trace.go:
func __readTrace() Object {
	_res := _runtime.ReadTrace()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.SetBlockProfileRate from runtime/mprof.go:
// func __setBlockProfileRate(rate int) Object {
// 	_runtime.SetBlockProfileRate(rate)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCPUProfileRate from runtime/cpuprof.go:
// func __setCPUProfileRate(hz int) Object {
// 	_runtime.SetCPUProfileRate(hz)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCgoTraceback from runtime/traceback.go:
// func __setCgoTraceback(version int, traceback ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), context ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), symbolizer ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetFinalizer from runtime/mfinal.go:
// func __setFinalizer(obj interface {}, finalizer interface {}) Object {
// 	_runtime.SetFinalizer(obj, finalizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Stack from runtime/mprof.go:
// func __stack(buf []byte, all bool)  {
// 	_res := _runtime.Stack(buf, all)
// 	return MakeInt(_res)
// }

GO FUNC runtime.StopTrace from runtime/trace.go:
// func __stopTrace() Object {
// 	_runtime.StopTrace()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ThreadCreateProfile from runtime/mprof.go:
// func __threadCreateProfile(p []_runtime.StackRecord) Object {
// 	n, ok := _runtime.ThreadCreateProfile(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC runtime.UnlockOSThread from runtime/proc.go:
// func __unlockOSThread() Object {
// 	_runtime.UnlockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.__ptrTo_Frames_Next from runtime/symtab.go:
func __ptrTo_Frames_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime.Frames)Next()", args, 0, 0)
	frame, more := o.O.(*_runtime.Frames).Next()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(frame))
	_res = _res.Conjoin(MakeBoolean(more))
	return _res
}

GO FUNC runtime.__ptrTo_Func_Entry from runtime/symtab.go:
// func __ptrTo_Func_Entry(o GoObject, args Object) Object {
// 	CheckGoArity("(*_runtime.Func)Entry()", args, 0, 0)
// 	_res := o.O.(*_runtime.Func).Entry()
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC runtime.__ptrTo_Func_FileLine from runtime/symtab.go:
func __ptrTo_Func_FileLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_runtime.Func)FileLine()", args, 1, 1)
	pc := ExtractGoUIntPtr("(*_runtime.Func)FileLine()", "pc", _argList, 0)
	file, line := o.O.(*_runtime.Func).FileLine(pc)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(file))
	_res = _res.Conjoin(MakeInt(line))
	return _res
}

GO FUNC runtime.__ptrTo_Func_Name from runtime/symtab.go:
func __ptrTo_Func_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime.Func)Name()", args, 0, 0)
	_res := o.O.(*_runtime.Func).Name()
	return MakeString(_res)
}

GO FUNC runtime.__ptrTo_MemProfileRecord_InUseBytes from runtime/mprof.go:
func __ptrTo_MemProfileRecord_InUseBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime.MemProfileRecord)InUseBytes()", args, 0, 0)
	_res := o.O.(*_runtime.MemProfileRecord).InUseBytes()
	return MakeBigInt(_res)
}

GO FUNC runtime.__ptrTo_MemProfileRecord_InUseObjects from runtime/mprof.go:
func __ptrTo_MemProfileRecord_InUseObjects(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime.MemProfileRecord)InUseObjects()", args, 0, 0)
	_res := o.O.(*_runtime.MemProfileRecord).InUseObjects()
	return MakeBigInt(_res)
}

GO FUNC runtime.__ptrTo_MemProfileRecord_Stack from runtime/mprof.go:
// func __ptrTo_MemProfileRecord_Stack(o GoObject, args Object) Object {
// 	CheckGoArity("(*_runtime.MemProfileRecord)Stack()", args, 0, 0)
// 	_res := o.O.(*_runtime.MemProfileRecord).Stack()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	}
// 	return _vec1
// }

GO FUNC runtime.__ptrTo_StackRecord_Stack from runtime/mprof.go:
// func __ptrTo_StackRecord_Stack(o GoObject, args Object) Object {
// 	CheckGoArity("(*_runtime.StackRecord)Stack()", args, 0, 0)
// 	_res := o.O.(*_runtime.StackRecord).Stack()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	}
// 	return _vec1
// }

GO FUNC runtime.__ptrTo_TypeAssertionError_Error from runtime/error.go:
func __ptrTo_TypeAssertionError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime.TypeAssertionError)Error()", args, 0, 0)
	_res := o.O.(*_runtime.TypeAssertionError).Error()
	return MakeString(_res)
}

GO FUNC runtime.__ptrTo_TypeAssertionError_RuntimeError from runtime/error.go:
// func __ptrTo_TypeAssertionError_RuntimeError(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package runtime

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_runtime "runtime"
)
var members_PtrTo_Frames = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_Frames_Next,
}}

var members_PtrTo_Func = GoTypeInfo{Members: GoMembers{
	"FileLine": __ptrTo_Func_FileLine,
	"Name": __ptrTo_Func_Name,
}}

var members_PtrTo_MemProfileRecord = GoTypeInfo{Members: GoMembers{
	"InUseBytes": __ptrTo_MemProfileRecord_InUseBytes,
	"InUseObjects": __ptrTo_MemProfileRecord_InUseObjects,
}}

var members_PtrTo_TypeAssertionError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_TypeAssertionError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_runtime.Frames)(nil))] = &members_PtrTo_Frames
	GoTypes[_reflect.TypeOf((*_runtime.Func)(nil))] = &members_PtrTo_Func
	GoTypes[_reflect.TypeOf((*_runtime.MemProfileRecord)(nil))] = &members_PtrTo_MemProfileRecord
	GoTypes[_reflect.TypeOf((*_runtime.TypeAssertionError)(nil))] = &members_PtrTo_TypeAssertionError
}

GO TYPE runtime/debug.BuildInfo from runtime/debug/mod.go:
func ExtractGoObjectBuildInfo(args []Object, index int) *_debug.BuildInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _debug.BuildInfo:
			return &r
		case *_debug.BuildInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/debug.BuildInfo]"))
}

// func _mapToBuildInfo(o Map) *_debug.BuildInfo {
// 	return &_debug.BuildInfo{}
// }

// func _vectorToBuildInfo(o *Vector) *_debug.BuildInfo {
// 	return &_debug.BuildInfo{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Main: ABEND048(codegen.go: no conversion from Clojure for runtime/debug.Module (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Deps: ABEND048(codegen.go: no conversion from Clojure for []*runtime/debug.Module (*runtime/debug.Module)),
// 	}
// }

// func _ConstructBuildInfo(_v Object) *_debug.BuildInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _debug.BuildInfo:
// 			return &_g
// 		case *_debug.BuildInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBuildInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToBuildInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[debug.BuildInfo] or: Map or Vector"))
// }

GO TYPE runtime/debug.GCStats from runtime/debug/garbage.go:
func ExtractGoObjectGCStats(args []Object, index int) *_debug.GCStats {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _debug.GCStats:
			return &r
		case *_debug.GCStats:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/debug.GCStats]"))
}

// func _mapToGCStats(o Map) *_debug.GCStats {
// 	return &_debug.GCStats{}
// }

// func _vectorToGCStats(o *Vector) *_debug.GCStats {
// 	return &_debug.GCStats{
// 		LastGC: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		NumGC: AssertNumber(o.Nth(1), "").BigInt().Int64(),
// 		PauseTotal: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Pause: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PauseEnd: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PauseQuantiles: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructGCStats(_v Object) *_debug.GCStats {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _debug.GCStats:
// 			return &_g
// 		case *_debug.GCStats:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGCStats(_o.(Map))
// 	case *Vector:
// 		return _vectorToGCStats(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[debug.GCStats] or: Map or Vector"))
// }

GO TYPE runtime/debug.Module from runtime/debug/mod.go:
func ExtractGoObjectModule(args []Object, index int) *_debug.Module {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _debug.Module:
			return &r
		case *_debug.Module:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/debug.Module]"))
}

// func _mapToModule(o Map) *_debug.Module {
// 	return &_debug.Module{}
// }

// func _vectorToModule(o *Vector) *_debug.Module {
// 	return &_debug.Module{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Version: AssertString(o.Nth(1), "").S,
// 		Sum: AssertString(o.Nth(2), "").S,
// 		Replace: ABEND048(codegen.go: no conversion from Clojure for *runtime/debug.Module (runtime/debug.Module)),
// 	}
// }

// func _ConstructModule(_v Object) *_debug.Module {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _debug.Module:
// 			return &_g
// 		case *_debug.Module:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToModule(_o.(Map))
// 	case *Vector:
// 		return _vectorToModule(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[debug.Module] or: Map or Vector"))
// }

GO FUNC runtime/debug.FreeOSMemory from runtime/debug/garbage.go:
// func __freeOSMemory() Object {
// 	_debug.FreeOSMemory()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.PrintStack from runtime/debug/stack.go:
// func __printStack() Object {
// 	_debug.PrintStack()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.ReadBuildInfo from runtime/debug/mod.go:
func __readBuildInfo() Object {
	info, ok := _debug.ReadBuildInfo()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(info))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC runtime/debug.ReadGCStats from runtime/debug/garbage.go:
// func __readGCStats(stats *_debug.GCStats) Object {
// 	_debug.ReadGCStats(stats)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.SetTraceback from runtime/debug/garbage.go:
// func __setTraceback(level string) Object {
// 	_debug.SetTraceback(level)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.Stack from runtime/debug/stack.go:
func __stack() Object {
	_res := _debug.Stack()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime/debug.WriteHeapDump from runtime/debug/garbage.go:
// func __writeHeapDump(fd uintptr) Object {
// 	_debug.WriteHeapDump(fd)
// 	...ABEND675: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package debug

import (
	. "github.com/candid82/joker/core"
	_debug "runtime/debug"
)

func init() {
}

GO TYPE runtime/pprof.LabelSet from runtime/pprof/label.go:
func ExtractGoObjectLabelSet(args []Object, index int) *_pprof.LabelSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pprof.LabelSet:
			return &r
		case *_pprof.LabelSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/pprof.LabelSet]"))
}

func _mapToLabelSet(o Map) *_pprof.LabelSet {
	return &_pprof.LabelSet{}
}

func _vectorToLabelSet(o *Vector) *_pprof.LabelSet {
	return &_pprof.LabelSet{}
}

func _ConstructLabelSet(_v Object) *_pprof.LabelSet {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pprof.LabelSet:
			return &_g
		case *_pprof.LabelSet:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLabelSet(_o.(Map))
	case *Vector:
		return _vectorToLabelSet(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pprof.LabelSet] or: Map or Vector"))
}

GO TYPE runtime/pprof.Profile from runtime/pprof/pprof.go:
func ExtractGoObjectProfile(args []Object, index int) *_pprof.Profile {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _pprof.Profile:
			return &r
		case *_pprof.Profile:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/pprof.Profile]"))
}

func _mapToProfile(o Map) *_pprof.Profile {
	return &_pprof.Profile{}
}

func _vectorToProfile(o *Vector) *_pprof.Profile {
	return &_pprof.Profile{}
}

func _ConstructProfile(_v Object) *_pprof.Profile {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _pprof.Profile:
			return &_g
		case *_pprof.Profile:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProfile(_o.(Map))
	case *Vector:
		return _vectorToProfile(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[pprof.Profile] or: Map or Vector"))
}

GO FUNC runtime/pprof.Do from runtime/pprof/runtime.go:
// func __do(ctx ABEND987(genutils.go: imports not yet supported: context.Context), labels _pprof.LabelSet, f func) Object {
// 	_pprof.Do(ctx, labels, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.ForLabels from runtime/pprof/label.go:
// func __forLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context), f func) Object {
// 	_pprof.ForLabels(ctx, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.Label from runtime/pprof/label.go:
// func __label(ctx ABEND987(genutils.go: imports not yet supported: context.Context), key string) Object {
// 	_res1, _res2 := _pprof.Label(ctx, key)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeString(_res1))
// 	_res = _res.Conjoin(MakeBoolean(_res2))
// 	return _res
// }

GO FUNC runtime/pprof.Labels from runtime/pprof/label.go:
// func __labels(args ...string) Object {
// 	_res := _pprof.Labels(args)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.Lookup from runtime/pprof/pprof.go:
func __lookup(name string) Object {
	_res := _pprof.Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.NewProfile from runtime/pprof/pprof.go:
func __newProfile(name string) Object {
	_res := _pprof.NewProfile(name)
	return MakeGoObject(_res)
}

GO FUNC runtime/pprof.Profiles from runtime/pprof/pprof.go:
func __profiles() Object {
	_res := _pprof.Profiles()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC runtime/pprof.SetGoroutineLabels from runtime/pprof/runtime.go:
// func __setGoroutineLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_pprof.SetGoroutineLabels(ctx)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.StartCPUProfile from runtime/pprof/pprof.go:
// func __startCPUProfile(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _pprof.StartCPUProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/pprof.StopCPUProfile from runtime/pprof/pprof.go:
// func __stopCPUProfile() Object {
// 	_pprof.StopCPUProfile()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.WithLabels from runtime/pprof/label.go:
// func __withLabels(ctx ABEND987(genutils.go: imports not yet supported: context.Context), labels _pprof.LabelSet) Object {
// 	_res := _pprof.WithLabels(ctx, labels)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/pprof.WriteHeapProfile from runtime/pprof/pprof.go:
// func __writeHeapProfile(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _pprof.WriteHeapProfile(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/pprof.__ptrTo_Profile_Add from runtime/pprof/pprof.go:
// func __ptrTo_Profile_Add(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), skip)}

GO FUNC runtime/pprof.__ptrTo_Profile_Count from runtime/pprof/pprof.go:
func __ptrTo_Profile_Count(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime/pprof.Profile)Count()", args, 0, 0)
	_res := o.O.(*_pprof.Profile).Count()
	return MakeInt(_res)
}

GO FUNC runtime/pprof.__ptrTo_Profile_Name from runtime/pprof/pprof.go:
func __ptrTo_Profile_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_runtime/pprof.Profile)Name()", args, 0, 0)
	_res := o.O.(*_pprof.Profile).Name()
	return MakeString(_res)
}

GO FUNC runtime/pprof.__ptrTo_Profile_Remove from runtime/pprof/pprof.go:
// func __ptrTo_Profile_Remove(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC runtime/pprof.__ptrTo_Profile_WriteTo from runtime/pprof/pprof.go:
// func __ptrTo_Profile_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer), debug int}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package pprof

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_pprof "runtime/pprof"
)
var members_PtrTo_Profile = GoTypeInfo{Members: GoMembers{
	"Count": __ptrTo_Profile_Count,
	"Name": __ptrTo_Profile_Name,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_pprof.Profile)(nil))] = &members_PtrTo_Profile
}

GO TYPE runtime/trace.Region from runtime/trace/annotation.go:
func ExtractGoObjectRegion(args []Object, index int) *_trace.Region {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _trace.Region:
			return &r
		case *_trace.Region:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/trace.Region]"))
}

func _mapToRegion(o Map) *_trace.Region {
	return &_trace.Region{}
}

func _vectorToRegion(o *Vector) *_trace.Region {
	return &_trace.Region{}
}

func _ConstructRegion(_v Object) *_trace.Region {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _trace.Region:
			return &_g
		case *_trace.Region:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRegion(_o.(Map))
	case *Vector:
		return _vectorToRegion(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[trace.Region] or: Map or Vector"))
}

GO TYPE runtime/trace.Task from runtime/trace/annotation.go:
func ExtractGoObjectTask(args []Object, index int) *_trace.Task {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _trace.Task:
			return &r
		case *_trace.Task:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[runtime/trace.Task]"))
}

func _mapToTask(o Map) *_trace.Task {
	return &_trace.Task{}
}

func _vectorToTask(o *Vector) *_trace.Task {
	return &_trace.Task{}
}

func _ConstructTask(_v Object) *_trace.Task {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _trace.Task:
			return &_g
		case *_trace.Task:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTask(_o.(Map))
	case *Vector:
		return _vectorToTask(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[trace.Task] or: Map or Vector"))
}

GO FUNC runtime/trace.Log from runtime/trace/annotation.go:
// func __log(ctx ABEND987(genutils.go: imports not yet supported: context.Context), category string, message string) Object {
// 	_trace.Log(ctx, category, message)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.Logf from runtime/trace/annotation.go:
// func __logf(ctx ABEND987(genutils.go: imports not yet supported: context.Context), category string, format string, args ...interface {}) Object {
// 	_trace.Logf(ctx, category, format, args)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.NewTask from runtime/trace/annotation.go:
// func __newTask(pctx ABEND987(genutils.go: imports not yet supported: context.Context), taskType string) Object {
// 	ctx, task := _trace.NewTask(pctx, taskType)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ctx))
// 	_res = _res.Conjoin(MakeGoObject(task))
// 	return _res
// }

GO FUNC runtime/trace.Start from runtime/trace/trace.go:
// func __start(w ABEND987(genutils.go: imports not yet supported: io.Writer))  {
// 	_res := _trace.Start(w)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC runtime/trace.StartRegion from runtime/trace/annotation.go:
// func __startRegion(ctx ABEND987(genutils.go: imports not yet supported: context.Context), regionType string) Object {
// 	_res := _trace.StartRegion(ctx, regionType)
// 	return MakeGoObject(_res)
// }

GO FUNC runtime/trace.Stop from runtime/trace/trace.go:
// func __stop() Object {
// 	_trace.Stop()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.WithRegion from runtime/trace/annotation.go:
// func __withRegion(ctx ABEND987(genutils.go: imports not yet supported: context.Context), regionType string, fn func) Object {
// 	_trace.WithRegion(ctx, regionType, fn)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.__ptrTo_Region_End from runtime/trace/annotation.go:
// func __ptrTo_Region_End(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC runtime/trace.__ptrTo_Task_End from runtime/trace/annotation.go:
// func __ptrTo_Task_End(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package trace

import (
	. "github.com/candid82/joker/core"
	_trace "runtime/trace"
)

func init() {
}

GO TYPE sort.Float64Slice from sort/sort.go:
func ExtractGoObjectFloat64Slice(args []Object, index int) *_sort.Float64Slice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.Float64Slice:
			return &r
		case *_sort.Float64Slice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.Float64Slice]"))
}

// func _ConstructFloat64Slice(_v Object) _sort.Float64Slice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.Float64Slice:
// 			return _g
// 		case *_sort.Float64Slice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.Float64Slice(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Float64Slice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.Float64Slice] or: whatever"))
// }

GO TYPE sort.IntSlice from sort/sort.go:
func ExtractGoObjectIntSlice(args []Object, index int) *_sort.IntSlice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.IntSlice:
			return &r
		case *_sort.IntSlice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.IntSlice]"))
}

// func _ConstructIntSlice(_v Object) _sort.IntSlice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.IntSlice:
// 			return _g
// 		case *_sort.IntSlice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.IntSlice(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IntSlice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.IntSlice] or: whatever"))
// }

GO TYPE sort.Interface from sort/sort.go:
func ExtractGoObjectInterface(args []Object, index int) *_sort.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.Interface:
			return &r
		case *_sort.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.Interface]"))
}

// func _ConstructInterface(_v Object) _sort.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.Interface:
// 			return _g
// 		case *_sort.Interface:
// 			return *_g
// 		}
// 	default:
// 		return _sort.Interface(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Interface))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.Interface] or: whatever"))
// }

GO TYPE sort.StringSlice from sort/sort.go:
func ExtractGoObjectStringSlice(args []Object, index int) *_sort.StringSlice {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sort.StringSlice:
			return &r
		case *_sort.StringSlice:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sort.StringSlice]"))
}

// func _ConstructStringSlice(_v Object) _sort.StringSlice {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sort.StringSlice:
// 			return _g
// 		case *_sort.StringSlice:
// 			return *_g
// 		}
// 	default:
// 		return _sort.StringSlice(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for StringSlice))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sort.StringSlice] or: whatever"))
// }

GO FUNC sort.Float64s from sort/sort.go:
// func __float64s(a []float64) Object {
// 	_sort.Float64s(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Float64sAreSorted from sort/sort.go:
// func __float64sAreSorted(a []float64)  {
// 	_res := _sort.Float64sAreSorted(a)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.Ints from sort/sort.go:
// func __ints(a []int) Object {
// 	_sort.Ints(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.IntsAreSorted from sort/sort.go:
// func __intsAreSorted(a []int)  {
// 	_res := _sort.IntsAreSorted(a)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.Reverse from sort/sort.go:
func __reverse(data _sort.Interface) Object {
	_res := _sort.Reverse(data)
	return MakeGoObject(_res)
}

GO FUNC sort.Search from sort/search.go:
// func __search(n int, f func)  {
// 	_res := _sort.Search(n, f)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchFloat64s from sort/search.go:
// func __searchFloat64s(a []float64, x float64)  {
// 	_res := _sort.SearchFloat64s(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchInts from sort/search.go:
// func __searchInts(a []int, x int)  {
// 	_res := _sort.SearchInts(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.SearchStrings from sort/search.go:
// func __searchStrings(a []string, x string)  {
// 	_res := _sort.SearchStrings(a, x)
// 	return MakeInt(_res)
// }

GO FUNC sort.Slice from sort/slice.go:
// func __slice(slice interface {}, less func) Object {
// 	_sort.Slice(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.SliceIsSorted from sort/slice.go:
// func __sliceIsSorted(slice interface {}, less func)  {
// 	_res := _sort.SliceIsSorted(slice, less)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.SliceStable from sort/slice.go:
// func __sliceStable(slice interface {}, less func) Object {
// 	_sort.SliceStable(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Sort from sort/sort.go:
// func __sort(data _sort.Interface) Object {
// 	_sort.Sort(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Stable from sort/sort.go:
// func __stable(data _sort.Interface) Object {
// 	_sort.Stable(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Strings from sort/sort.go:
// func __strings(a []string) Object {
// 	_sort.Strings(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.StringsAreSorted from sort/sort.go:
// func __stringsAreSorted(a []string)  {
// 	_res := _sort.StringsAreSorted(a)
// 	return MakeBoolean(_res)
// }

GO FUNC sort.__float64Slice_Len from sort/sort.go:
func __float64Slice_Len(o GoObject, args Object) Object {
	CheckGoArity("(_sort.Float64Slice)Len()", args, 0, 0)
	_res := o.O.(_sort.Float64Slice).Len()
	return MakeInt(_res)
}

GO FUNC sort.__float64Slice_Less from sort/sort.go:
func __float64Slice_Less(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_sort.Float64Slice)Less()", args, 2, 2)
	i := ExtractGoInt("(_sort.Float64Slice)Less()", "i", _argList, 0)
	j := ExtractGoInt("(_sort.Float64Slice)Less()", "j", _argList, 1)
	_res := o.O.(_sort.Float64Slice).Less(i, j)
	return MakeBoolean(_res)
}

GO FUNC sort.__float64Slice_Search from sort/search.go:
// func __float64Slice_Search(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(_sort.Float64Slice)Search()", args, 1, 1)
// 	x := ExtractGoABEND007(find these)("(_sort.Float64Slice)Search()", "x", _argList, 0)
// 	_res := o.O.(_sort.Float64Slice).Search(x)
// 	return MakeInt(_res)
// }

GO FUNC sort.__float64Slice_Sort from sort/sort.go:
// func __float64Slice_Sort(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sort.__float64Slice_Swap from sort/sort.go:
// func __float64Slice_Swap(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sort.__intSlice_Len from sort/sort.go:
func __intSlice_Len(o GoObject, args Object) Object {
	CheckGoArity("(_sort.IntSlice)Len()", args, 0, 0)
	_res := o.O.(_sort.IntSlice).Len()
	return MakeInt(_res)
}

GO FUNC sort.__intSlice_Less from sort/sort.go:
func __intSlice_Less(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_sort.IntSlice)Less()", args, 2, 2)
	i := ExtractGoInt("(_sort.IntSlice)Less()", "i", _argList, 0)
	j := ExtractGoInt("(_sort.IntSlice)Less()", "j", _argList, 1)
	_res := o.O.(_sort.IntSlice).Less(i, j)
	return MakeBoolean(_res)
}

GO FUNC sort.__intSlice_Search from sort/search.go:
func __intSlice_Search(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_sort.IntSlice)Search()", args, 1, 1)
	x := ExtractGoInt("(_sort.IntSlice)Search()", "x", _argList, 0)
	_res := o.O.(_sort.IntSlice).Search(x)
	return MakeInt(_res)
}

GO FUNC sort.__intSlice_Sort from sort/sort.go:
// func __intSlice_Sort(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sort.__intSlice_Swap from sort/sort.go:
// func __intSlice_Swap(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sort.__stringSlice_Len from sort/sort.go:
func __stringSlice_Len(o GoObject, args Object) Object {
	CheckGoArity("(_sort.StringSlice)Len()", args, 0, 0)
	_res := o.O.(_sort.StringSlice).Len()
	return MakeInt(_res)
}

GO FUNC sort.__stringSlice_Less from sort/sort.go:
func __stringSlice_Less(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_sort.StringSlice)Less()", args, 2, 2)
	i := ExtractGoInt("(_sort.StringSlice)Less()", "i", _argList, 0)
	j := ExtractGoInt("(_sort.StringSlice)Less()", "j", _argList, 1)
	_res := o.O.(_sort.StringSlice).Less(i, j)
	return MakeBoolean(_res)
}

GO FUNC sort.__stringSlice_Search from sort/search.go:
func __stringSlice_Search(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_sort.StringSlice)Search()", args, 1, 1)
	x := ExtractGoString("(_sort.StringSlice)Search()", "x", _argList, 0)
	_res := o.O.(_sort.StringSlice).Search(x)
	return MakeInt(_res)
}

GO FUNC sort.__stringSlice_Sort from sort/sort.go:
// func __stringSlice_Sort(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sort.__stringSlice_Swap from sort/sort.go:
// func __stringSlice_Swap(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sort

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_sort "sort"
)
var members_Float64Slice = GoTypeInfo{Members: GoMembers{
	"Len": __float64Slice_Len,
	"Less": __float64Slice_Less,
}}

var members_IntSlice = GoTypeInfo{Members: GoMembers{
	"Len": __intSlice_Len,
	"Less": __intSlice_Less,
	"Search": __intSlice_Search,
}}

var members_StringSlice = GoTypeInfo{Members: GoMembers{
	"Len": __stringSlice_Len,
	"Less": __stringSlice_Less,
	"Search": __stringSlice_Search,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_sort.Float64Slice)(nil)).Elem()] = &members_Float64Slice
	GoTypes[_reflect.TypeOf((*_sort.IntSlice)(nil)).Elem()] = &members_IntSlice
	GoTypes[_reflect.TypeOf((*_sort.StringSlice)(nil)).Elem()] = &members_StringSlice
}

GO TYPE strconv.NumError from strconv/atoi.go:
func ExtractGoObjectNumError(args []Object, index int) *_strconv.NumError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strconv.NumError:
			return &r
		case *_strconv.NumError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strconv.NumError]"))
}

func _mapToNumError(o Map) *_strconv.NumError {
	return &_strconv.NumError{}
}

func _vectorToNumError(o *Vector) *_strconv.NumError {
	return &_strconv.NumError{
		Func: AssertString(o.Nth(0), "").S,
		Num: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructNumError(_v Object) *_strconv.NumError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strconv.NumError:
			return &_g
		case *_strconv.NumError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNumError(_o.(Map))
	case *Vector:
		return _vectorToNumError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strconv.NumError] or: Map or Vector"))
}

GO FUNC strconv.AppendBool from strconv/atob.go:
// func __appendBool(dst []byte, b bool) Object {
// 	_res := _strconv.AppendBool(dst, b)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendFloat from strconv/ftoa.go:
// func __appendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) Object {
// 	_res := _strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendInt from strconv/itoa.go:
// func __appendInt(dst []byte, i int64, base int) Object {
// 	_res := _strconv.AppendInt(dst, i, base)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuote from strconv/quote.go:
// func __appendQuote(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuote(dst, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRune from strconv/quote.go:
// func __appendQuoteRune(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRune(dst, r)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToASCII from strconv/quote.go:
// func __appendQuoteRuneToASCII(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToASCII(dst, r)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToGraphic from strconv/quote.go:
// func __appendQuoteRuneToGraphic(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToGraphic(dst, r)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToASCII from strconv/quote.go:
// func __appendQuoteToASCII(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToASCII(dst, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToGraphic from strconv/quote.go:
// func __appendQuoteToGraphic(dst []byte, s string) Object {
// 	_res := _strconv.AppendQuoteToGraphic(dst, s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendUint from strconv/itoa.go:
// func __appendUint(dst []byte, i uint64, base int) Object {
// 	_res := _strconv.AppendUint(dst, i, base)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.Atoi from strconv/atoi.go:
func __atoi(s string) Object {
	_res1, _res2 := _strconv.Atoi(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseBool from strconv/atob.go:
func __parseBool(str string) Object {
	_res1, _res2 := _strconv.ParseBool(str)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseFloat from strconv/atof.go:
// func __parseFloat(s string, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseFloat(s, bitSize)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type float64))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.ParseInt from strconv/atoi.go:
func __parseInt(s string, base int, bitSize int) Object {
	i, err := _strconv.ParseInt(s, base, bitSize)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(i))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strconv.ParseUint from strconv/atoi.go:
func __parseUint(s string, base int, bitSize int) Object {
	_res1, _res2 := _strconv.ParseUint(s, base, bitSize)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.Unquote from strconv/quote.go:
func __unquote(s string) Object {
	_res1, _res2 := _strconv.Unquote(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.UnquoteChar from strconv/quote.go:
func __unquoteChar(s string, quote byte) Object {
	value, multibyte, tail, err := _strconv.UnquoteChar(s, quote)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(value))
	_res = _res.Conjoin(MakeBoolean(multibyte))
	_res = _res.Conjoin(MakeString(tail))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strconv.__ptrTo_NumError_Error from strconv/atoi.go:
func __ptrTo_NumError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_strconv.NumError)Error()", args, 0, 0)
	_res := o.O.(*_strconv.NumError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strconv

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_strconv "strconv"
)
var members_PtrTo_NumError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_NumError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_strconv.NumError)(nil))] = &members_PtrTo_NumError
}

GO TYPE strings.Builder from strings/builder.go:
func ExtractGoObjectBuilder(args []Object, index int) *_strings.Builder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Builder:
			return &r
		case *_strings.Builder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Builder]"))
}

func _mapToBuilder(o Map) *_strings.Builder {
	return &_strings.Builder{}
}

func _vectorToBuilder(o *Vector) *_strings.Builder {
	return &_strings.Builder{}
}

func _ConstructBuilder(_v Object) *_strings.Builder {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Builder:
			return &_g
		case *_strings.Builder:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBuilder(_o.(Map))
	case *Vector:
		return _vectorToBuilder(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Builder] or: Map or Vector"))
}

GO TYPE strings.Reader from strings/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_strings.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Reader:
			return &r
		case *_strings.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Reader]"))
}

func _mapToReader(o Map) *_strings.Reader {
	return &_strings.Reader{}
}

func _vectorToReader(o *Vector) *_strings.Reader {
	return &_strings.Reader{}
}

func _ConstructReader(_v Object) *_strings.Reader {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Reader:
			return &_g
		case *_strings.Reader:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReader(_o.(Map))
	case *Vector:
		return _vectorToReader(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Reader] or: Map or Vector"))
}

GO TYPE strings.Replacer from strings/replace.go:
func ExtractGoObjectReplacer(args []Object, index int) *_strings.Replacer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _strings.Replacer:
			return &r
		case *_strings.Replacer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[strings.Replacer]"))
}

func _mapToReplacer(o Map) *_strings.Replacer {
	return &_strings.Replacer{}
}

func _vectorToReplacer(o *Vector) *_strings.Replacer {
	return &_strings.Replacer{}
}

func _ConstructReplacer(_v Object) *_strings.Replacer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _strings.Replacer:
			return &_g
		case *_strings.Replacer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToReplacer(_o.(Map))
	case *Vector:
		return _vectorToReplacer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[strings.Replacer] or: Map or Vector"))
}

GO FUNC strings.Fields from strings/strings.go:
func __fields(s string) Object {
	_res := _strings.Fields(s)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.FieldsFunc from strings/strings.go:
// func __fieldsFunc(s string, f func) Object {
// 	_res := _strings.FieldsFunc(s, f)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC strings.IndexFunc from strings/strings.go:
// func __indexFunc(s string, f func)  {
// 	_res := _strings.IndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.Join from strings/strings.go:
// func __join(a []string, sep string)  {
// 	_res := _strings.Join(a, sep)
// 	return MakeString(_res)
// }

GO FUNC strings.LastIndexFunc from strings/strings.go:
// func __lastIndexFunc(s string, f func)  {
// 	_res := _strings.LastIndexFunc(s, f)
// 	return MakeInt(_res)
// }

GO FUNC strings.Map from strings/strings.go:
// func __map(mapping func, s string)  {
// 	_res := _strings.Map(mapping, s)
// 	return MakeString(_res)
// }

GO FUNC strings.NewReader from strings/reader.go:
func __newReader(s string) Object {
	_res := _strings.NewReader(s)
	return MakeGoObject(_res)
}

GO FUNC strings.NewReplacer from strings/replace.go:
// func __newReplacer(oldnew ...string) Object {
// 	_res := _strings.NewReplacer(oldnew)
// 	return MakeGoObject(_res)
// }

GO FUNC strings.Split from strings/strings.go:
func __split(s string, sep string) Object {
	_res := _strings.Split(s, sep)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfter from strings/strings.go:
func __splitAfter(s string, sep string) Object {
	_res := _strings.SplitAfter(s, sep)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfterN from strings/strings.go:
func __splitAfterN(s string, sep string, n int) Object {
	_res := _strings.SplitAfterN(s, sep, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitN from strings/strings.go:
func __splitN(s string, sep string, n int) Object {
	_res := _strings.SplitN(s, sep, n)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.ToLowerSpecial from strings/strings.go:
// func __toLowerSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToLowerSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToTitleSpecial from strings/strings.go:
// func __toTitleSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToTitleSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.ToUpperSpecial from strings/strings.go:
// func __toUpperSpecial(c ABEND987(genutils.go: imports not yet supported: unicode.SpecialCase), s string)  {
// 	_res := _strings.ToUpperSpecial(c, s)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimFunc from strings/strings.go:
// func __trimFunc(s string, f func)  {
// 	_res := _strings.TrimFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimLeftFunc from strings/strings.go:
// func __trimLeftFunc(s string, f func)  {
// 	_res := _strings.TrimLeftFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.TrimRightFunc from strings/strings.go:
// func __trimRightFunc(s string, f func)  {
// 	_res := _strings.TrimRightFunc(s, f)
// 	return MakeString(_res)
// }

GO FUNC strings.__ptrTo_Builder_Cap from strings/builder.go:
func __ptrTo_Builder_Cap(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Builder)Cap()", args, 0, 0)
	_res := o.O.(*_strings.Builder).Cap()
	return MakeInt(_res)
}

GO FUNC strings.__ptrTo_Builder_Grow from strings/builder.go:
// func __ptrTo_Builder_Grow(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC strings.__ptrTo_Builder_Len from strings/builder.go:
func __ptrTo_Builder_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Builder)Len()", args, 0, 0)
	_res := o.O.(*_strings.Builder).Len()
	return MakeInt(_res)
}

GO FUNC strings.__ptrTo_Builder_Reset from strings/builder.go:
// func __ptrTo_Builder_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC strings.__ptrTo_Builder_String from strings/builder.go:
func __ptrTo_Builder_String(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Builder)String()", args, 0, 0)
	_res := o.O.(*_strings.Builder).String()
	return MakeString(_res)
}

GO FUNC strings.__ptrTo_Builder_Write from strings/builder.go:
// func __ptrTo_Builder_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(p)))}

GO FUNC strings.__ptrTo_Builder_WriteByte from strings/builder.go:
func __ptrTo_Builder_WriteByte(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_strings.Builder)WriteByte()", args, 1, 1)
	c := ExtractGoByte("(*_strings.Builder)WriteByte()", "c", _argList, 0)
	_res := o.O.(*_strings.Builder).WriteByte(c)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC strings.__ptrTo_Builder_WriteRune from strings/builder.go:
func __ptrTo_Builder_WriteRune(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_strings.Builder)WriteRune()", args, 1, 1)
	r := ExtractGoChar("(*_strings.Builder)WriteRune()", "r", _argList, 0)
	_res1, _res2 := o.O.(*_strings.Builder).WriteRune(r)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strings.__ptrTo_Builder_WriteString from strings/builder.go:
func __ptrTo_Builder_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_strings.Builder)WriteString()", args, 1, 1)
	s := ExtractGoString("(*_strings.Builder)WriteString()", "s", _argList, 0)
	_res1, _res2 := o.O.(*_strings.Builder).WriteString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strings.__ptrTo_Reader_Len from strings/reader.go:
func __ptrTo_Reader_Len(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)Len()", args, 0, 0)
	_res := o.O.(*_strings.Reader).Len()
	return MakeInt(_res)
}

GO FUNC strings.__ptrTo_Reader_Read from strings/reader.go:
// func __ptrTo_Reader_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)))}

GO FUNC strings.__ptrTo_Reader_ReadAt from strings/reader.go:
// func __ptrTo_Reader_ReadAt(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), off)}

GO FUNC strings.__ptrTo_Reader_ReadByte from strings/reader.go:
func __ptrTo_Reader_ReadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)ReadByte()", args, 0, 0)
	_res1, _res2 := o.O.(*_strings.Reader).ReadByte()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strings.__ptrTo_Reader_ReadRune from strings/reader.go:
func __ptrTo_Reader_ReadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)ReadRune()", args, 0, 0)
	ch, size, err := o.O.(*_strings.Reader).ReadRune()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(ch))
	_res = _res.Conjoin(MakeInt(size))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strings.__ptrTo_Reader_Reset from strings/reader.go:
// func __ptrTo_Reader_Reset(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC strings.__ptrTo_Reader_Seek from strings/reader.go:
func __ptrTo_Reader_Seek(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_strings.Reader)Seek()", args, 2, 2)
	offset := ExtractGoInt64("(*_strings.Reader)Seek()", "offset", _argList, 0)
	whence := ExtractGoInt("(*_strings.Reader)Seek()", "whence", _argList, 1)
	_res1, _res2 := o.O.(*_strings.Reader).Seek(offset, whence)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strings.__ptrTo_Reader_Size from strings/reader.go:
func __ptrTo_Reader_Size(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)Size()", args, 0, 0)
	_res := o.O.(*_strings.Reader).Size()
	return MakeBigInt(_res)
}

GO FUNC strings.__ptrTo_Reader_UnreadByte from strings/reader.go:
func __ptrTo_Reader_UnreadByte(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)UnreadByte()", args, 0, 0)
	_res := o.O.(*_strings.Reader).UnreadByte()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC strings.__ptrTo_Reader_UnreadRune from strings/reader.go:
func __ptrTo_Reader_UnreadRune(o GoObject, args Object) Object {
	CheckGoArity("(*_strings.Reader)UnreadRune()", args, 0, 0)
	_res := o.O.(*_strings.Reader).UnreadRune()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC strings.__ptrTo_Reader_WriteTo from strings/reader.go:
// func __ptrTo_Reader_WriteTo(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC strings.__ptrTo_Replacer_Replace from strings/replace.go:
func __ptrTo_Replacer_Replace(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_strings.Replacer)Replace()", args, 1, 1)
	s := ExtractGoString("(*_strings.Replacer)Replace()", "s", _argList, 0)
	_res := o.O.(*_strings.Replacer).Replace(s)
	return MakeString(_res)
}

GO FUNC strings.__ptrTo_Replacer_WriteString from strings/replace.go:
// func __ptrTo_Replacer_WriteString(o GoObject, args Object) Object {
// w ABEND987(genutils.go: imports not yet supported: io.Writer), s string}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package strings

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_strings "strings"
)
var members_PtrTo_Builder = GoTypeInfo{Members: GoMembers{
	"Cap": __ptrTo_Builder_Cap,
	"Len": __ptrTo_Builder_Len,
	"String": __ptrTo_Builder_String,
	"WriteByte": __ptrTo_Builder_WriteByte,
	"WriteRune": __ptrTo_Builder_WriteRune,
	"WriteString": __ptrTo_Builder_WriteString,
}}

var members_PtrTo_Reader = GoTypeInfo{Members: GoMembers{
	"Len": __ptrTo_Reader_Len,
	"ReadByte": __ptrTo_Reader_ReadByte,
	"ReadRune": __ptrTo_Reader_ReadRune,
	"Seek": __ptrTo_Reader_Seek,
	"Size": __ptrTo_Reader_Size,
	"UnreadByte": __ptrTo_Reader_UnreadByte,
	"UnreadRune": __ptrTo_Reader_UnreadRune,
}}

var members_PtrTo_Replacer = GoTypeInfo{Members: GoMembers{
	"Replace": __ptrTo_Replacer_Replace,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_strings.Builder)(nil))] = &members_PtrTo_Builder
	GoTypes[_reflect.TypeOf((*_strings.Reader)(nil))] = &members_PtrTo_Reader
	GoTypes[_reflect.TypeOf((*_strings.Replacer)(nil))] = &members_PtrTo_Replacer
}

GO TYPE sync.Cond from sync/cond.go:
func ExtractGoObjectCond(args []Object, index int) *_sync.Cond {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Cond:
			return &r
		case *_sync.Cond:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Cond]"))
}

// func _mapToCond(o Map) *_sync.Cond {
// 	return &_sync.Cond{}
// }

// func _vectorToCond(o *Vector) *_sync.Cond {
// 	return &_sync.Cond{
// 		L: ABEND048(codegen.go: no conversion from Clojure for sync.Locker (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructCond(_v Object) *_sync.Cond {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sync.Cond:
// 			return &_g
// 		case *_sync.Cond:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCond(_o.(Map))
// 	case *Vector:
// 		return _vectorToCond(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Cond] or: Map or Vector"))
// }

GO TYPE sync.Locker from sync/mutex.go:
func ExtractGoObjectLocker(args []Object, index int) *_sync.Locker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Locker:
			return &r
		case *_sync.Locker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Locker]"))
}

// func _ConstructLocker(_v Object) _sync.Locker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sync.Locker:
// 			return _g
// 		case *_sync.Locker:
// 			return *_g
// 		}
// 	default:
// 		return _sync.Locker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Locker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Locker] or: whatever"))
// }

GO TYPE sync.Map from sync/map.go:
func ExtractGoObjectMap(args []Object, index int) *_sync.Map {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Map:
			return &r
		case *_sync.Map:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Map]"))
}

func _mapToMap(o Map) *_sync.Map {
	return &_sync.Map{}
}

func _vectorToMap(o *Vector) *_sync.Map {
	return &_sync.Map{}
}

func _ConstructMap(_v Object) *_sync.Map {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Map:
			return &_g
		case *_sync.Map:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMap(_o.(Map))
	case *Vector:
		return _vectorToMap(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Map] or: Map or Vector"))
}

GO TYPE sync.Mutex from sync/mutex.go:
func ExtractGoObjectMutex(args []Object, index int) *_sync.Mutex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Mutex:
			return &r
		case *_sync.Mutex:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Mutex]"))
}

func _mapToMutex(o Map) *_sync.Mutex {
	return &_sync.Mutex{}
}

func _vectorToMutex(o *Vector) *_sync.Mutex {
	return &_sync.Mutex{}
}

func _ConstructMutex(_v Object) *_sync.Mutex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Mutex:
			return &_g
		case *_sync.Mutex:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMutex(_o.(Map))
	case *Vector:
		return _vectorToMutex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Mutex] or: Map or Vector"))
}

GO TYPE sync.Once from sync/once.go:
func ExtractGoObjectOnce(args []Object, index int) *_sync.Once {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Once:
			return &r
		case *_sync.Once:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Once]"))
}

func _mapToOnce(o Map) *_sync.Once {
	return &_sync.Once{}
}

func _vectorToOnce(o *Vector) *_sync.Once {
	return &_sync.Once{}
}

func _ConstructOnce(_v Object) *_sync.Once {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.Once:
			return &_g
		case *_sync.Once:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToOnce(_o.(Map))
	case *Vector:
		return _vectorToOnce(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Once] or: Map or Vector"))
}

GO TYPE sync.Pool from sync/pool.go:
func ExtractGoObjectPool(args []Object, index int) *_sync.Pool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.Pool:
			return &r
		case *_sync.Pool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.Pool]"))
}

// func _mapToPool(o Map) *_sync.Pool {
// 	return &_sync.Pool{}
// }

// func _vectorToPool(o *Vector) *_sync.Pool {
// 	return &_sync.Pool{
// 		New: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructPool(_v Object) *_sync.Pool {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _sync.Pool:
// 			return &_g
// 		case *_sync.Pool:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPool(_o.(Map))
// 	case *Vector:
// 		return _vectorToPool(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.Pool] or: Map or Vector"))
// }

GO TYPE sync.RWMutex from sync/rwmutex.go:
func ExtractGoObjectRWMutex(args []Object, index int) *_sync.RWMutex {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.RWMutex:
			return &r
		case *_sync.RWMutex:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.RWMutex]"))
}

func _mapToRWMutex(o Map) *_sync.RWMutex {
	return &_sync.RWMutex{}
}

func _vectorToRWMutex(o *Vector) *_sync.RWMutex {
	return &_sync.RWMutex{}
}

func _ConstructRWMutex(_v Object) *_sync.RWMutex {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.RWMutex:
			return &_g
		case *_sync.RWMutex:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRWMutex(_o.(Map))
	case *Vector:
		return _vectorToRWMutex(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.RWMutex] or: Map or Vector"))
}

GO TYPE sync.WaitGroup from sync/waitgroup.go:
func ExtractGoObjectWaitGroup(args []Object, index int) *_sync.WaitGroup {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _sync.WaitGroup:
			return &r
		case *_sync.WaitGroup:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[sync.WaitGroup]"))
}

func _mapToWaitGroup(o Map) *_sync.WaitGroup {
	return &_sync.WaitGroup{}
}

func _vectorToWaitGroup(o *Vector) *_sync.WaitGroup {
	return &_sync.WaitGroup{}
}

func _ConstructWaitGroup(_v Object) *_sync.WaitGroup {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _sync.WaitGroup:
			return &_g
		case *_sync.WaitGroup:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWaitGroup(_o.(Map))
	case *Vector:
		return _vectorToWaitGroup(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[sync.WaitGroup] or: Map or Vector"))
}

GO FUNC sync.NewCond from sync/cond.go:
func __newCond(l _sync.Locker) Object {
	_res := _sync.NewCond(l)
	return MakeGoObject(_res)
}

GO FUNC sync.__ptrTo_Cond_Broadcast from sync/cond.go:
// func __ptrTo_Cond_Broadcast(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_Cond_Signal from sync/cond.go:
// func __ptrTo_Cond_Signal(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_Cond_Wait from sync/cond.go:
// func __ptrTo_Cond_Wait(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_Map_Delete from sync/map.go:
// func __ptrTo_Map_Delete(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC sync.__ptrTo_Map_Load from sync/map.go:
// func __ptrTo_Map_Load(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC sync.__ptrTo_Map_LoadOrStore from sync/map.go:
// func __ptrTo_Map_LoadOrStore(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC sync.__ptrTo_Map_Range from sync/map.go:
// func __ptrTo_Map_Range(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC sync.__ptrTo_Map_Store from sync/map.go:
// func __ptrTo_Map_Store(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC sync.__ptrTo_Mutex_Lock from sync/mutex.go:
// func __ptrTo_Mutex_Lock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_Mutex_Unlock from sync/mutex.go:
// func __ptrTo_Mutex_Unlock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_Once_Do from sync/once.go:
// func __ptrTo_Once_Do(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC sync.__ptrTo_Pool_Get from sync/pool.go:
// func __ptrTo_Pool_Get(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/sync/pool.go:124:22)}

GO FUNC sync.__ptrTo_Pool_Put from sync/pool.go:
// func __ptrTo_Pool_Put(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC sync.__ptrTo_RWMutex_Lock from sync/rwmutex.go:
// func __ptrTo_RWMutex_Lock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_RWMutex_RLock from sync/rwmutex.go:
// func __ptrTo_RWMutex_RLock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_RWMutex_RLocker from sync/rwmutex.go:
func __ptrTo_RWMutex_RLocker(o GoObject, args Object) Object {
	CheckGoArity("(*_sync.RWMutex)RLocker()", args, 0, 0)
	_res := o.O.(*_sync.RWMutex).RLocker()
	return MakeGoObject(_res)
}

GO FUNC sync.__ptrTo_RWMutex_RUnlock from sync/rwmutex.go:
// func __ptrTo_RWMutex_RUnlock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_RWMutex_Unlock from sync/rwmutex.go:
// func __ptrTo_RWMutex_Unlock(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_WaitGroup_Add from sync/waitgroup.go:
// func __ptrTo_WaitGroup_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_WaitGroup_Done from sync/waitgroup.go:
// func __ptrTo_WaitGroup_Done(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC sync.__ptrTo_WaitGroup_Wait from sync/waitgroup.go:
// func __ptrTo_WaitGroup_Wait(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package sync

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_sync "sync"
)
var members_PtrTo_RWMutex = GoTypeInfo{Members: GoMembers{
	"RLocker": __ptrTo_RWMutex_RLocker,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_sync.RWMutex)(nil))] = &members_PtrTo_RWMutex
}

GO FUNC sync/atomic.AddInt32 from sync/atomic/doc.go:
// func __addInt32(addr *int32, delta int32) Object {
// 	_res := _atomic.AddInt32(addr, delta)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.AddInt64 from sync/atomic/doc.go:
// func __addInt64(addr *int64, delta int64) Object {
// 	_res := _atomic.AddInt64(addr, delta)
// 	return MakeBigInt(_res)
// }

GO FUNC sync/atomic.AddUint32 from sync/atomic/doc.go:
// func __addUint32(addr *uint32, delta uint32) Object {
// 	_res := _atomic.AddUint32(addr, delta)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC sync/atomic.AddUint64 from sync/atomic/doc.go:
// func __addUint64(addr *uint64, delta uint64) Object {
// 	_res := _atomic.AddUint64(addr, delta)
// 	return MakeBigIntU(_res)
// }

GO FUNC sync/atomic.AddUintptr from sync/atomic/doc.go:
// func __addUintptr(addr *uintptr, delta uintptr) Object {
// 	_res := _atomic.AddUintptr(addr, delta)
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC sync/atomic.CompareAndSwapInt32 from sync/atomic/doc.go:
// func __compareAndSwapInt32(addr *int32, old int32, new int32)  {
// 	_res := _atomic.CompareAndSwapInt32(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapInt64 from sync/atomic/doc.go:
// func __compareAndSwapInt64(addr *int64, old int64, new int64)  {
// 	_res := _atomic.CompareAndSwapInt64(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapPointer from sync/atomic/doc.go:
// func __compareAndSwapPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), old ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), new ABEND987(genutils.go: imports not yet supported: unsafe.Pointer))  {
// 	_res := _atomic.CompareAndSwapPointer(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint32 from sync/atomic/doc.go:
// func __compareAndSwapUint32(addr *uint32, old uint32, new uint32)  {
// 	_res := _atomic.CompareAndSwapUint32(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUint64 from sync/atomic/doc.go:
// func __compareAndSwapUint64(addr *uint64, old uint64, new uint64)  {
// 	_res := _atomic.CompareAndSwapUint64(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.CompareAndSwapUintptr from sync/atomic/doc.go:
// func __compareAndSwapUintptr(addr *uintptr, old uintptr, new uintptr)  {
// 	_res := _atomic.CompareAndSwapUintptr(addr, old, new)
// 	return MakeBoolean(_res)
// }

GO FUNC sync/atomic.LoadInt32 from sync/atomic/doc.go:
// func __loadInt32(addr *int32) Object {
// 	_res := _atomic.LoadInt32(addr)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.LoadInt64 from sync/atomic/doc.go:
// func __loadInt64(addr *int64) Object {
// 	_res := _atomic.LoadInt64(addr)
// 	return MakeBigInt(_res)
// }

GO FUNC sync/atomic.LoadPointer from sync/atomic/doc.go:
// func __loadPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	return _atomic.LoadPointer(addr)
// }

GO FUNC sync/atomic.LoadUint32 from sync/atomic/doc.go:
// func __loadUint32(addr *uint32) Object {
// 	_res := _atomic.LoadUint32(addr)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC sync/atomic.LoadUint64 from sync/atomic/doc.go:
// func __loadUint64(addr *uint64) Object {
// 	_res := _atomic.LoadUint64(addr)
// 	return MakeBigIntU(_res)
// }

GO FUNC sync/atomic.LoadUintptr from sync/atomic/doc.go:
// func __loadUintptr(addr *uintptr) Object {
// 	_res := _atomic.LoadUintptr(addr)
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC sync/atomic.StoreInt32 from sync/atomic/doc.go:
// func __storeInt32(addr *int32, val int32) Object {
// 	_atomic.StoreInt32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreInt64 from sync/atomic/doc.go:
// func __storeInt64(addr *int64, val int64) Object {
// 	_atomic.StoreInt64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StorePointer from sync/atomic/doc.go:
// func __storePointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), val ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	_atomic.StorePointer(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint32 from sync/atomic/doc.go:
// func __storeUint32(addr *uint32, val uint32) Object {
// 	_atomic.StoreUint32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint64 from sync/atomic/doc.go:
// func __storeUint64(addr *uint64, val uint64) Object {
// 	_atomic.StoreUint64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUintptr from sync/atomic/doc.go:
// func __storeUintptr(addr *uintptr, val uintptr) Object {
// 	_atomic.StoreUintptr(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.SwapInt32 from sync/atomic/doc.go:
// func __swapInt32(addr *int32, new int32) Object {
// 	_res := _atomic.SwapInt32(addr, new)
// 	return MakeInt(int(_res))
// }

GO FUNC sync/atomic.SwapInt64 from sync/atomic/doc.go:
// func __swapInt64(addr *int64, new int64) Object {
// 	_res := _atomic.SwapInt64(addr, new)
// 	return MakeBigInt(_res)
// }

GO FUNC sync/atomic.SwapPointer from sync/atomic/doc.go:
// func __swapPointer(addr *ABEND987(genutils.go: imports not yet supported: unsafe.Pointer), new ABEND987(genutils.go: imports not yet supported: unsafe.Pointer)) Object {
// 	return _atomic.SwapPointer(addr, new)
// }

GO FUNC sync/atomic.SwapUint32 from sync/atomic/doc.go:
// func __swapUint32(addr *uint32, new uint32) Object {
// 	_res := _atomic.SwapUint32(addr, new)
// 	return MakeBigIntU(uint64(_res))
// }

GO FUNC sync/atomic.SwapUint64 from sync/atomic/doc.go:
// func __swapUint64(addr *uint64, new uint64) Object {
// 	_res := _atomic.SwapUint64(addr, new)
// 	return MakeBigIntU(_res)
// }

GO FUNC sync/atomic.SwapUintptr from sync/atomic/doc.go:
// func __swapUintptr(addr *uintptr, new uintptr) Object {
// 	_res := _atomic.SwapUintptr(addr, new)
// 	return ABEND043(post.go: unsupported built-in type uintptr)
// }

GO FUNC sync/atomic.__ptrTo_Value_Load from sync/atomic/value.go:
// func __ptrTo_Value_Load(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.InterfaceType at: /usr/local/go/src/sync/atomic/value.go:28:27)}

GO FUNC sync/atomic.__ptrTo_Value_Store from sync/atomic/value.go:
// func __ptrTo_Value_Store(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO TYPE syscall.BpfHdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectBpfHdr(args []Object, index int) *_syscall.BpfHdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.BpfHdr:
			return &r
		case *_syscall.BpfHdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.BpfHdr]"))
}

// func _mapToBpfHdr(o Map) *_syscall.BpfHdr {
// 	return &_syscall.BpfHdr{}
// }

// func _vectorToBpfHdr(o *Vector) *_syscall.BpfHdr {
// 	return &_syscall.BpfHdr{
// 		Tstamp: ABEND048(codegen.go: no conversion from Clojure for syscall.Timeval32 (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Caplen: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Datalen: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		Hdrlen: uint16(AssertInt(o.Nth(3), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 	}
// }

// func _ConstructBpfHdr(_v Object) *_syscall.BpfHdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.BpfHdr:
// 			return &_g
// 		case *_syscall.BpfHdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBpfHdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToBpfHdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.BpfHdr] or: Map or Vector"))
// }

GO TYPE syscall.BpfInsn from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectBpfInsn(args []Object, index int) *_syscall.BpfInsn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.BpfInsn:
			return &r
		case *_syscall.BpfInsn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.BpfInsn]"))
}

func _mapToBpfInsn(o Map) *_syscall.BpfInsn {
	return &_syscall.BpfInsn{}
}

func _vectorToBpfInsn(o *Vector) *_syscall.BpfInsn {
	return &_syscall.BpfInsn{
		Code: uint16(AssertInt(o.Nth(0), "").I),
		Jt: uint8(AssertInt(o.Nth(1), "").I),
		Jf: uint8(AssertInt(o.Nth(2), "").I),
		K: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
	}
}

func _ConstructBpfInsn(_v Object) *_syscall.BpfInsn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.BpfInsn:
			return &_g
		case *_syscall.BpfInsn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBpfInsn(_o.(Map))
	case *Vector:
		return _vectorToBpfInsn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.BpfInsn] or: Map or Vector"))
}

GO TYPE syscall.BpfProgram from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectBpfProgram(args []Object, index int) *_syscall.BpfProgram {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.BpfProgram:
			return &r
		case *_syscall.BpfProgram:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.BpfProgram]"))
}

// func _mapToBpfProgram(o Map) *_syscall.BpfProgram {
// 	return &_syscall.BpfProgram{}
// }

// func _vectorToBpfProgram(o *Vector) *_syscall.BpfProgram {
// 	return &_syscall.BpfProgram{
// 		Len: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Insns: ABEND048(codegen.go: no conversion from Clojure for *syscall.BpfInsn (syscall.BpfInsn)),
// 	}
// }

// func _ConstructBpfProgram(_v Object) *_syscall.BpfProgram {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.BpfProgram:
// 			return &_g
// 		case *_syscall.BpfProgram:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBpfProgram(_o.(Map))
// 	case *Vector:
// 		return _vectorToBpfProgram(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.BpfProgram] or: Map or Vector"))
// }

GO TYPE syscall.BpfStat from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectBpfStat(args []Object, index int) *_syscall.BpfStat {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.BpfStat:
			return &r
		case *_syscall.BpfStat:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.BpfStat]"))
}

func _mapToBpfStat(o Map) *_syscall.BpfStat {
	return &_syscall.BpfStat{}
}

func _vectorToBpfStat(o *Vector) *_syscall.BpfStat {
	return &_syscall.BpfStat{
		Recv: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Drop: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
	}
}

func _ConstructBpfStat(_v Object) *_syscall.BpfStat {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.BpfStat:
			return &_g
		case *_syscall.BpfStat:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBpfStat(_o.(Map))
	case *Vector:
		return _vectorToBpfStat(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.BpfStat] or: Map or Vector"))
}

GO TYPE syscall.BpfVersion from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectBpfVersion(args []Object, index int) *_syscall.BpfVersion {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.BpfVersion:
			return &r
		case *_syscall.BpfVersion:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.BpfVersion]"))
}

func _mapToBpfVersion(o Map) *_syscall.BpfVersion {
	return &_syscall.BpfVersion{}
}

func _vectorToBpfVersion(o *Vector) *_syscall.BpfVersion {
	return &_syscall.BpfVersion{
		Major: uint16(AssertInt(o.Nth(0), "").I),
		Minor: uint16(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructBpfVersion(_v Object) *_syscall.BpfVersion {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.BpfVersion:
			return &_g
		case *_syscall.BpfVersion:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBpfVersion(_o.(Map))
	case *Vector:
		return _vectorToBpfVersion(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.BpfVersion] or: Map or Vector"))
}

GO TYPE syscall.Cmsghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectCmsghdr(args []Object, index int) *_syscall.Cmsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Cmsghdr:
			return &r
		case *_syscall.Cmsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Cmsghdr]"))
}

func _mapToCmsghdr(o Map) *_syscall.Cmsghdr {
	return &_syscall.Cmsghdr{}
}

func _vectorToCmsghdr(o *Vector) *_syscall.Cmsghdr {
	return &_syscall.Cmsghdr{
		Len: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Level: int32(AssertInt(o.Nth(1), "").I),
		Type: int32(AssertInt(o.Nth(2), "").I),
	}
}

func _ConstructCmsghdr(_v Object) *_syscall.Cmsghdr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Cmsghdr:
			return &_g
		case *_syscall.Cmsghdr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCmsghdr(_o.(Map))
	case *Vector:
		return _vectorToCmsghdr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Cmsghdr] or: Map or Vector"))
}

GO TYPE syscall.Conn from syscall/net.go:
func ExtractGoObjectConn(args []Object, index int) *_syscall.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Conn:
			return &r
		case *_syscall.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Conn]"))
}

// func _ConstructConn(_v Object) _syscall.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Conn:
// 			return _g
// 		case *_syscall.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Conn] or: whatever"))
// }

GO TYPE syscall.Credential from syscall/exec_unix.go:
func ExtractGoObjectCredential(args []Object, index int) *_syscall.Credential {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Credential:
			return &r
		case *_syscall.Credential:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Credential]"))
}

// func _mapToCredential(o Map) *_syscall.Credential {
// 	return &_syscall.Credential{}
// }

// func _vectorToCredential(o *Vector) *_syscall.Credential {
// 	return &_syscall.Credential{
// 		Uid: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Gid: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Groups: ABEND048(codegen.go: no conversion from Clojure for []uint32 (uint32)),
// 		NoSetGroups: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructCredential(_v Object) *_syscall.Credential {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Credential:
// 			return &_g
// 		case *_syscall.Credential:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCredential(_o.(Map))
// 	case *Vector:
// 		return _vectorToCredential(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Credential] or: Map or Vector"))
// }

GO TYPE syscall.Dirent from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectDirent(args []Object, index int) *_syscall.Dirent {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Dirent:
			return &r
		case *_syscall.Dirent:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Dirent]"))
}

// func _mapToDirent(o Map) *_syscall.Dirent {
// 	return &_syscall.Dirent{}
// }

// func _vectorToDirent(o *Vector) *_syscall.Dirent {
// 	return &_syscall.Dirent{
// 		Ino: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		Seekoff: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Reclen: uint16(AssertInt(o.Nth(2), "").I),
// 		Namlen: uint16(AssertInt(o.Nth(3), "").I),
// 		Type: uint8(AssertInt(o.Nth(4), "").I),
// 		Name: ABEND048(codegen.go: no conversion from Clojure for [1024]int8 (int8)),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [3]byte (byte)),
// 	}
// }

// func _ConstructDirent(_v Object) *_syscall.Dirent {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Dirent:
// 			return &_g
// 		case *_syscall.Dirent:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDirent(_o.(Map))
// 	case *Vector:
// 		return _vectorToDirent(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Dirent] or: Map or Vector"))
// }

GO TYPE syscall.Errno from syscall/syscall_unix.go:
func ExtractGoObjectErrno(args []Object, index int) *_syscall.Errno {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Errno:
			return &r
		case *_syscall.Errno:
			return r
		}
	case Number:
		v := _syscall.Errno(ExtractUIntPtr(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Errno]"))
}

func _ConstructErrno(_v Object) _syscall.Errno {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Errno:
			return _g
		case *_syscall.Errno:
			return *_g
		}
	case Number:
		return _syscall.Errno(_o.BigInt().Uint64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Errno] or: Number"))
}

GO TYPE syscall.Fbootstraptransfer_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectFbootstraptransfer_t(args []Object, index int) *_syscall.Fbootstraptransfer_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Fbootstraptransfer_t:
			return &r
		case *_syscall.Fbootstraptransfer_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Fbootstraptransfer_t]"))
}

// func _mapToFbootstraptransfer_t(o Map) *_syscall.Fbootstraptransfer_t {
// 	return &_syscall.Fbootstraptransfer_t{}
// }

// func _vectorToFbootstraptransfer_t(o *Vector) *_syscall.Fbootstraptransfer_t {
// 	return &_syscall.Fbootstraptransfer_t{
// 		Offset: AssertNumber(o.Nth(0), "").BigInt().Int64(),
// 		Length: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Buffer: ABEND048(codegen.go: no conversion from Clojure for *byte (byte)),
// 	}
// }

// func _ConstructFbootstraptransfer_t(_v Object) *_syscall.Fbootstraptransfer_t {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Fbootstraptransfer_t:
// 			return &_g
// 		case *_syscall.Fbootstraptransfer_t:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFbootstraptransfer_t(_o.(Map))
// 	case *Vector:
// 		return _vectorToFbootstraptransfer_t(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Fbootstraptransfer_t] or: Map or Vector"))
// }

GO TYPE syscall.FdSet from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectFdSet(args []Object, index int) *_syscall.FdSet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.FdSet:
			return &r
		case *_syscall.FdSet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.FdSet]"))
}

// func _mapToFdSet(o Map) *_syscall.FdSet {
// 	return &_syscall.FdSet{}
// }

// func _vectorToFdSet(o *Vector) *_syscall.FdSet {
// 	return &_syscall.FdSet{
// 		Bits: ABEND048(codegen.go: no conversion from Clojure for [32]int32 (int32)),
// 	}
// }

// func _ConstructFdSet(_v Object) *_syscall.FdSet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.FdSet:
// 			return &_g
// 		case *_syscall.FdSet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFdSet(_o.(Map))
// 	case *Vector:
// 		return _vectorToFdSet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.FdSet] or: Map or Vector"))
// }

GO TYPE syscall.Flock_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectFlock_t(args []Object, index int) *_syscall.Flock_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Flock_t:
			return &r
		case *_syscall.Flock_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Flock_t]"))
}

func _mapToFlock_t(o Map) *_syscall.Flock_t {
	return &_syscall.Flock_t{}
}

func _vectorToFlock_t(o *Vector) *_syscall.Flock_t {
	return &_syscall.Flock_t{
		Start: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Len: AssertNumber(o.Nth(1), "").BigInt().Int64(),
		Pid: int32(AssertInt(o.Nth(2), "").I),
		Type: int16(AssertInt(o.Nth(3), "").I),
		Whence: int16(AssertInt(o.Nth(4), "").I),
	}
}

func _ConstructFlock_t(_v Object) *_syscall.Flock_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Flock_t:
			return &_g
		case *_syscall.Flock_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFlock_t(_o.(Map))
	case *Vector:
		return _vectorToFlock_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Flock_t] or: Map or Vector"))
}

GO TYPE syscall.Fsid from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectFsid(args []Object, index int) *_syscall.Fsid {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Fsid:
			return &r
		case *_syscall.Fsid:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Fsid]"))
}

// func _mapToFsid(o Map) *_syscall.Fsid {
// 	return &_syscall.Fsid{}
// }

// func _vectorToFsid(o *Vector) *_syscall.Fsid {
// 	return &_syscall.Fsid{
// 		Val: ABEND048(codegen.go: no conversion from Clojure for [2]int32 (int32)),
// 	}
// }

// func _ConstructFsid(_v Object) *_syscall.Fsid {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Fsid:
// 			return &_g
// 		case *_syscall.Fsid:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFsid(_o.(Map))
// 	case *Vector:
// 		return _vectorToFsid(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Fsid] or: Map or Vector"))
// }

GO TYPE syscall.Fstore_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectFstore_t(args []Object, index int) *_syscall.Fstore_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Fstore_t:
			return &r
		case *_syscall.Fstore_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Fstore_t]"))
}

func _mapToFstore_t(o Map) *_syscall.Fstore_t {
	return &_syscall.Fstore_t{}
}

func _vectorToFstore_t(o *Vector) *_syscall.Fstore_t {
	return &_syscall.Fstore_t{
		Flags: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Posmode: int32(AssertInt(o.Nth(1), "").I),
		Offset: AssertNumber(o.Nth(2), "").BigInt().Int64(),
		Length: AssertNumber(o.Nth(3), "").BigInt().Int64(),
		Bytesalloc: AssertNumber(o.Nth(4), "").BigInt().Int64(),
	}
}

func _ConstructFstore_t(_v Object) *_syscall.Fstore_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Fstore_t:
			return &_g
		case *_syscall.Fstore_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToFstore_t(_o.(Map))
	case *Vector:
		return _vectorToFstore_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Fstore_t] or: Map or Vector"))
}

GO TYPE syscall.ICMPv6Filter from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectICMPv6Filter(args []Object, index int) *_syscall.ICMPv6Filter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.ICMPv6Filter:
			return &r
		case *_syscall.ICMPv6Filter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.ICMPv6Filter]"))
}

// func _mapToICMPv6Filter(o Map) *_syscall.ICMPv6Filter {
// 	return &_syscall.ICMPv6Filter{}
// }

// func _vectorToICMPv6Filter(o *Vector) *_syscall.ICMPv6Filter {
// 	return &_syscall.ICMPv6Filter{
// 		Filt: ABEND048(codegen.go: no conversion from Clojure for [8]uint32 (uint32)),
// 	}
// }

// func _ConstructICMPv6Filter(_v Object) *_syscall.ICMPv6Filter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.ICMPv6Filter:
// 			return &_g
// 		case *_syscall.ICMPv6Filter:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToICMPv6Filter(_o.(Map))
// 	case *Vector:
// 		return _vectorToICMPv6Filter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.ICMPv6Filter] or: Map or Vector"))
// }

GO TYPE syscall.IPMreq from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIPMreq(args []Object, index int) *_syscall.IPMreq {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPMreq:
			return &r
		case *_syscall.IPMreq:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPMreq]"))
}

// func _mapToIPMreq(o Map) *_syscall.IPMreq {
// 	return &_syscall.IPMreq{}
// }

// func _vectorToIPMreq(o *Vector) *_syscall.IPMreq {
// 	return &_syscall.IPMreq{
// 		Multiaddr: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Interface: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 	}
// }

// func _ConstructIPMreq(_v Object) *_syscall.IPMreq {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IPMreq:
// 			return &_g
// 		case *_syscall.IPMreq:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPMreq(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPMreq(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPMreq] or: Map or Vector"))
// }

GO TYPE syscall.IPv6MTUInfo from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIPv6MTUInfo(args []Object, index int) *_syscall.IPv6MTUInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPv6MTUInfo:
			return &r
		case *_syscall.IPv6MTUInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPv6MTUInfo]"))
}

// func _mapToIPv6MTUInfo(o Map) *_syscall.IPv6MTUInfo {
// 	return &_syscall.IPv6MTUInfo{}
// }

// func _vectorToIPv6MTUInfo(o *Vector) *_syscall.IPv6MTUInfo {
// 	return &_syscall.IPv6MTUInfo{
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for syscall.RawSockaddrInet6 (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Mtu: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructIPv6MTUInfo(_v Object) *_syscall.IPv6MTUInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IPv6MTUInfo:
// 			return &_g
// 		case *_syscall.IPv6MTUInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPv6MTUInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPv6MTUInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPv6MTUInfo] or: Map or Vector"))
// }

GO TYPE syscall.IPv6Mreq from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIPv6Mreq(args []Object, index int) *_syscall.IPv6Mreq {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IPv6Mreq:
			return &r
		case *_syscall.IPv6Mreq:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IPv6Mreq]"))
}

// func _mapToIPv6Mreq(o Map) *_syscall.IPv6Mreq {
// 	return &_syscall.IPv6Mreq{}
// }

// func _vectorToIPv6Mreq(o *Vector) *_syscall.IPv6Mreq {
// 	return &_syscall.IPv6Mreq{
// 		Multiaddr: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Interface: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructIPv6Mreq(_v Object) *_syscall.IPv6Mreq {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IPv6Mreq:
// 			return &_g
// 		case *_syscall.IPv6Mreq:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPv6Mreq(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPv6Mreq(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IPv6Mreq] or: Map or Vector"))
// }

GO TYPE syscall.IfData from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIfData(args []Object, index int) *_syscall.IfData {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfData:
			return &r
		case *_syscall.IfData:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfData]"))
}

// func _mapToIfData(o Map) *_syscall.IfData {
// 	return &_syscall.IfData{}
// }

// func _vectorToIfData(o *Vector) *_syscall.IfData {
// 	return &_syscall.IfData{
// 		Type: uint8(AssertInt(o.Nth(0), "").I),
// 		Typelen: uint8(AssertInt(o.Nth(1), "").I),
// 		Physical: uint8(AssertInt(o.Nth(2), "").I),
// 		Addrlen: uint8(AssertInt(o.Nth(3), "").I),
// 		Hdrlen: uint8(AssertInt(o.Nth(4), "").I),
// 		Recvquota: uint8(AssertInt(o.Nth(5), "").I),
// 		Xmitquota: uint8(AssertInt(o.Nth(6), "").I),
// 		Unused1: uint8(AssertInt(o.Nth(7), "").I),
// 		Mtu: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Metric: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Baudrate: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		Ipackets: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 		Ierrors: uint32(AssertNumber(o.Nth(12), "").BigInt().Uint64()),
// 		Opackets: uint32(AssertNumber(o.Nth(13), "").BigInt().Uint64()),
// 		Oerrors: uint32(AssertNumber(o.Nth(14), "").BigInt().Uint64()),
// 		Collisions: uint32(AssertNumber(o.Nth(15), "").BigInt().Uint64()),
// 		Ibytes: uint32(AssertNumber(o.Nth(16), "").BigInt().Uint64()),
// 		Obytes: uint32(AssertNumber(o.Nth(17), "").BigInt().Uint64()),
// 		Imcasts: uint32(AssertNumber(o.Nth(18), "").BigInt().Uint64()),
// 		Omcasts: uint32(AssertNumber(o.Nth(19), "").BigInt().Uint64()),
// 		Iqdrops: uint32(AssertNumber(o.Nth(20), "").BigInt().Uint64()),
// 		Noproto: uint32(AssertNumber(o.Nth(21), "").BigInt().Uint64()),
// 		Recvtiming: uint32(AssertNumber(o.Nth(22), "").BigInt().Uint64()),
// 		Xmittiming: uint32(AssertNumber(o.Nth(23), "").BigInt().Uint64()),
// 		Lastchange: ABEND048(codegen.go: no conversion from Clojure for syscall.Timeval32 (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Unused2: uint32(AssertNumber(o.Nth(25), "").BigInt().Uint64()),
// 		Hwassist: uint32(AssertNumber(o.Nth(26), "").BigInt().Uint64()),
// 		Reserved1: uint32(AssertNumber(o.Nth(27), "").BigInt().Uint64()),
// 		Reserved2: uint32(AssertNumber(o.Nth(28), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructIfData(_v Object) *_syscall.IfData {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IfData:
// 			return &_g
// 		case *_syscall.IfData:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfData(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfData(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfData] or: Map or Vector"))
// }

GO TYPE syscall.IfMsghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIfMsghdr(args []Object, index int) *_syscall.IfMsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfMsghdr:
			return &r
		case *_syscall.IfMsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfMsghdr]"))
}

// func _mapToIfMsghdr(o Map) *_syscall.IfMsghdr {
// 	return &_syscall.IfMsghdr{}
// }

// func _vectorToIfMsghdr(o *Vector) *_syscall.IfMsghdr {
// 	return &_syscall.IfMsghdr{
// 		Msglen: uint16(AssertInt(o.Nth(0), "").I),
// 		Version: uint8(AssertInt(o.Nth(1), "").I),
// 		Type: uint8(AssertInt(o.Nth(2), "").I),
// 		Addrs: int32(AssertInt(o.Nth(3), "").I),
// 		Flags: int32(AssertInt(o.Nth(4), "").I),
// 		Index: uint16(AssertInt(o.Nth(5), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for syscall.IfData (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructIfMsghdr(_v Object) *_syscall.IfMsghdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IfMsghdr:
// 			return &_g
// 		case *_syscall.IfMsghdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfMsghdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfMsghdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfMsghdr] or: Map or Vector"))
// }

GO TYPE syscall.IfaMsghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIfaMsghdr(args []Object, index int) *_syscall.IfaMsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfaMsghdr:
			return &r
		case *_syscall.IfaMsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfaMsghdr]"))
}

// func _mapToIfaMsghdr(o Map) *_syscall.IfaMsghdr {
// 	return &_syscall.IfaMsghdr{}
// }

// func _vectorToIfaMsghdr(o *Vector) *_syscall.IfaMsghdr {
// 	return &_syscall.IfaMsghdr{
// 		Msglen: uint16(AssertInt(o.Nth(0), "").I),
// 		Version: uint8(AssertInt(o.Nth(1), "").I),
// 		Type: uint8(AssertInt(o.Nth(2), "").I),
// 		Addrs: int32(AssertInt(o.Nth(3), "").I),
// 		Flags: int32(AssertInt(o.Nth(4), "").I),
// 		Index: uint16(AssertInt(o.Nth(5), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 		Metric: int32(AssertInt(o.Nth(7), "").I),
// 	}
// }

// func _ConstructIfaMsghdr(_v Object) *_syscall.IfaMsghdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IfaMsghdr:
// 			return &_g
// 		case *_syscall.IfaMsghdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfaMsghdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfaMsghdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfaMsghdr] or: Map or Vector"))
// }

GO TYPE syscall.IfmaMsghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIfmaMsghdr(args []Object, index int) *_syscall.IfmaMsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfmaMsghdr:
			return &r
		case *_syscall.IfmaMsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfmaMsghdr]"))
}

// func _mapToIfmaMsghdr(o Map) *_syscall.IfmaMsghdr {
// 	return &_syscall.IfmaMsghdr{}
// }

// func _vectorToIfmaMsghdr(o *Vector) *_syscall.IfmaMsghdr {
// 	return &_syscall.IfmaMsghdr{
// 		Msglen: uint16(AssertInt(o.Nth(0), "").I),
// 		Version: uint8(AssertInt(o.Nth(1), "").I),
// 		Type: uint8(AssertInt(o.Nth(2), "").I),
// 		Addrs: int32(AssertInt(o.Nth(3), "").I),
// 		Flags: int32(AssertInt(o.Nth(4), "").I),
// 		Index: uint16(AssertInt(o.Nth(5), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 	}
// }

// func _ConstructIfmaMsghdr(_v Object) *_syscall.IfmaMsghdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IfmaMsghdr:
// 			return &_g
// 		case *_syscall.IfmaMsghdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfmaMsghdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfmaMsghdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfmaMsghdr] or: Map or Vector"))
// }

GO TYPE syscall.IfmaMsghdr2 from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIfmaMsghdr2(args []Object, index int) *_syscall.IfmaMsghdr2 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.IfmaMsghdr2:
			return &r
		case *_syscall.IfmaMsghdr2:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.IfmaMsghdr2]"))
}

// func _mapToIfmaMsghdr2(o Map) *_syscall.IfmaMsghdr2 {
// 	return &_syscall.IfmaMsghdr2{}
// }

// func _vectorToIfmaMsghdr2(o *Vector) *_syscall.IfmaMsghdr2 {
// 	return &_syscall.IfmaMsghdr2{
// 		Msglen: uint16(AssertInt(o.Nth(0), "").I),
// 		Version: uint8(AssertInt(o.Nth(1), "").I),
// 		Type: uint8(AssertInt(o.Nth(2), "").I),
// 		Addrs: int32(AssertInt(o.Nth(3), "").I),
// 		Flags: int32(AssertInt(o.Nth(4), "").I),
// 		Index: uint16(AssertInt(o.Nth(5), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 		Refcount: int32(AssertInt(o.Nth(7), "").I),
// 	}
// }

// func _ConstructIfmaMsghdr2(_v Object) *_syscall.IfmaMsghdr2 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.IfmaMsghdr2:
// 			return &_g
// 		case *_syscall.IfmaMsghdr2:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIfmaMsghdr2(_o.(Map))
// 	case *Vector:
// 		return _vectorToIfmaMsghdr2(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.IfmaMsghdr2] or: Map or Vector"))
// }

GO TYPE syscall.Inet4Pktinfo from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectInet4Pktinfo(args []Object, index int) *_syscall.Inet4Pktinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Inet4Pktinfo:
			return &r
		case *_syscall.Inet4Pktinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Inet4Pktinfo]"))
}

// func _mapToInet4Pktinfo(o Map) *_syscall.Inet4Pktinfo {
// 	return &_syscall.Inet4Pktinfo{}
// }

// func _vectorToInet4Pktinfo(o *Vector) *_syscall.Inet4Pktinfo {
// 	return &_syscall.Inet4Pktinfo{
// 		Ifindex: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Spec_dst: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 	}
// }

// func _ConstructInet4Pktinfo(_v Object) *_syscall.Inet4Pktinfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Inet4Pktinfo:
// 			return &_g
// 		case *_syscall.Inet4Pktinfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInet4Pktinfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToInet4Pktinfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Inet4Pktinfo] or: Map or Vector"))
// }

GO TYPE syscall.Inet6Pktinfo from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectInet6Pktinfo(args []Object, index int) *_syscall.Inet6Pktinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Inet6Pktinfo:
			return &r
		case *_syscall.Inet6Pktinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Inet6Pktinfo]"))
}

// func _mapToInet6Pktinfo(o Map) *_syscall.Inet6Pktinfo {
// 	return &_syscall.Inet6Pktinfo{}
// }

// func _vectorToInet6Pktinfo(o *Vector) *_syscall.Inet6Pktinfo {
// 	return &_syscall.Inet6Pktinfo{
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Ifindex: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructInet6Pktinfo(_v Object) *_syscall.Inet6Pktinfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Inet6Pktinfo:
// 			return &_g
// 		case *_syscall.Inet6Pktinfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInet6Pktinfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToInet6Pktinfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Inet6Pktinfo] or: Map or Vector"))
// }

GO TYPE syscall.InterfaceAddrMessage from syscall/route_bsd.go:
func ExtractGoObjectInterfaceAddrMessage(args []Object, index int) *_syscall.InterfaceAddrMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.InterfaceAddrMessage:
			return &r
		case *_syscall.InterfaceAddrMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.InterfaceAddrMessage]"))
}

// func _mapToInterfaceAddrMessage(o Map) *_syscall.InterfaceAddrMessage {
// 	return &_syscall.InterfaceAddrMessage{}
// }

// func _vectorToInterfaceAddrMessage(o *Vector) *_syscall.InterfaceAddrMessage {
// 	return &_syscall.InterfaceAddrMessage{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for syscall.IfaMsghdr (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructInterfaceAddrMessage(_v Object) *_syscall.InterfaceAddrMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.InterfaceAddrMessage:
// 			return &_g
// 		case *_syscall.InterfaceAddrMessage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterfaceAddrMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterfaceAddrMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.InterfaceAddrMessage] or: Map or Vector"))
// }

GO TYPE syscall.InterfaceMessage from syscall/route_bsd.go:
func ExtractGoObjectInterfaceMessage(args []Object, index int) *_syscall.InterfaceMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.InterfaceMessage:
			return &r
		case *_syscall.InterfaceMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.InterfaceMessage]"))
}

// func _mapToInterfaceMessage(o Map) *_syscall.InterfaceMessage {
// 	return &_syscall.InterfaceMessage{}
// }

// func _vectorToInterfaceMessage(o *Vector) *_syscall.InterfaceMessage {
// 	return &_syscall.InterfaceMessage{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for syscall.IfMsghdr (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructInterfaceMessage(_v Object) *_syscall.InterfaceMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.InterfaceMessage:
// 			return &_g
// 		case *_syscall.InterfaceMessage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterfaceMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterfaceMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.InterfaceMessage] or: Map or Vector"))
// }

GO TYPE syscall.InterfaceMulticastAddrMessage from syscall/route_darwin.go:
func ExtractGoObjectInterfaceMulticastAddrMessage(args []Object, index int) *_syscall.InterfaceMulticastAddrMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.InterfaceMulticastAddrMessage:
			return &r
		case *_syscall.InterfaceMulticastAddrMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.InterfaceMulticastAddrMessage]"))
}

// func _mapToInterfaceMulticastAddrMessage(o Map) *_syscall.InterfaceMulticastAddrMessage {
// 	return &_syscall.InterfaceMulticastAddrMessage{}
// }

// func _vectorToInterfaceMulticastAddrMessage(o *Vector) *_syscall.InterfaceMulticastAddrMessage {
// 	return &_syscall.InterfaceMulticastAddrMessage{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for syscall.IfmaMsghdr2 (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructInterfaceMulticastAddrMessage(_v Object) *_syscall.InterfaceMulticastAddrMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.InterfaceMulticastAddrMessage:
// 			return &_g
// 		case *_syscall.InterfaceMulticastAddrMessage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterfaceMulticastAddrMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterfaceMulticastAddrMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.InterfaceMulticastAddrMessage] or: Map or Vector"))
// }

GO TYPE syscall.Iovec from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectIovec(args []Object, index int) *_syscall.Iovec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Iovec:
			return &r
		case *_syscall.Iovec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Iovec]"))
}

// func _mapToIovec(o Map) *_syscall.Iovec {
// 	return &_syscall.Iovec{}
// }

// func _vectorToIovec(o *Vector) *_syscall.Iovec {
// 	return &_syscall.Iovec{
// 		Base: ABEND048(codegen.go: no conversion from Clojure for *byte (byte)),
// 		Len: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 	}
// }

// func _ConstructIovec(_v Object) *_syscall.Iovec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Iovec:
// 			return &_g
// 		case *_syscall.Iovec:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIovec(_o.(Map))
// 	case *Vector:
// 		return _vectorToIovec(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Iovec] or: Map or Vector"))
// }

GO TYPE syscall.Kevent_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectKevent_t(args []Object, index int) *_syscall.Kevent_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Kevent_t:
			return &r
		case *_syscall.Kevent_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Kevent_t]"))
}

// func _mapToKevent_t(o Map) *_syscall.Kevent_t {
// 	return &_syscall.Kevent_t{}
// }

// func _vectorToKevent_t(o *Vector) *_syscall.Kevent_t {
// 	return &_syscall.Kevent_t{
// 		Ident: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		Filter: int16(AssertInt(o.Nth(1), "").I),
// 		Flags: uint16(AssertInt(o.Nth(2), "").I),
// 		Fflags: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Data: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		Udata: ABEND048(codegen.go: no conversion from Clojure for *byte (byte)),
// 	}
// }

// func _ConstructKevent_t(_v Object) *_syscall.Kevent_t {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Kevent_t:
// 			return &_g
// 		case *_syscall.Kevent_t:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToKevent_t(_o.(Map))
// 	case *Vector:
// 		return _vectorToKevent_t(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Kevent_t] or: Map or Vector"))
// }

GO TYPE syscall.Linger from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectLinger(args []Object, index int) *_syscall.Linger {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Linger:
			return &r
		case *_syscall.Linger:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Linger]"))
}

func _mapToLinger(o Map) *_syscall.Linger {
	return &_syscall.Linger{}
}

func _vectorToLinger(o *Vector) *_syscall.Linger {
	return &_syscall.Linger{
		Onoff: int32(AssertInt(o.Nth(0), "").I),
		Linger: int32(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructLinger(_v Object) *_syscall.Linger {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Linger:
			return &_g
		case *_syscall.Linger:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLinger(_o.(Map))
	case *Vector:
		return _vectorToLinger(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Linger] or: Map or Vector"))
}

GO TYPE syscall.Log2phys_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectLog2phys_t(args []Object, index int) *_syscall.Log2phys_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Log2phys_t:
			return &r
		case *_syscall.Log2phys_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Log2phys_t]"))
}

func _mapToLog2phys_t(o Map) *_syscall.Log2phys_t {
	return &_syscall.Log2phys_t{}
}

func _vectorToLog2phys_t(o *Vector) *_syscall.Log2phys_t {
	return &_syscall.Log2phys_t{
		Flags: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Contigbytes: AssertNumber(o.Nth(1), "").BigInt().Int64(),
		Devoffset: AssertNumber(o.Nth(2), "").BigInt().Int64(),
	}
}

func _ConstructLog2phys_t(_v Object) *_syscall.Log2phys_t {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Log2phys_t:
			return &_g
		case *_syscall.Log2phys_t:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLog2phys_t(_o.(Map))
	case *Vector:
		return _vectorToLog2phys_t(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Log2phys_t] or: Map or Vector"))
}

GO TYPE syscall.Msghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectMsghdr(args []Object, index int) *_syscall.Msghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Msghdr:
			return &r
		case *_syscall.Msghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Msghdr]"))
}

// func _mapToMsghdr(o Map) *_syscall.Msghdr {
// 	return &_syscall.Msghdr{}
// }

// func _vectorToMsghdr(o *Vector) *_syscall.Msghdr {
// 	return &_syscall.Msghdr{
// 		Name: ABEND048(codegen.go: no conversion from Clojure for *byte (byte)),
// 		Namelen: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Iov: ABEND048(codegen.go: no conversion from Clojure for *syscall.Iovec (syscall.Iovec)),
// 		Iovlen: int32(AssertInt(o.Nth(4), "").I),
// 		Pad_cgo_1: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Control: ABEND048(codegen.go: no conversion from Clojure for *byte (byte)),
// 		Controllen: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Flags: int32(AssertInt(o.Nth(8), "").I),
// 	}
// }

// func _ConstructMsghdr(_v Object) *_syscall.Msghdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Msghdr:
// 			return &_g
// 		case *_syscall.Msghdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMsghdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToMsghdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Msghdr] or: Map or Vector"))
// }

GO TYPE syscall.ProcAttr from syscall/exec_unix.go:
func ExtractGoObjectProcAttr(args []Object, index int) *_syscall.ProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.ProcAttr:
			return &r
		case *_syscall.ProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.ProcAttr]"))
}

// func _mapToProcAttr(o Map) *_syscall.ProcAttr {
// 	return &_syscall.ProcAttr{}
// }

// func _vectorToProcAttr(o *Vector) *_syscall.ProcAttr {
// 	return &_syscall.ProcAttr{
// 		Dir: AssertString(o.Nth(0), "").S,
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Files: ABEND048(codegen.go: no conversion from Clojure for []uintptr (uintptr)),
// 		Sys: ABEND048(codegen.go: no conversion from Clojure for *syscall.SysProcAttr (syscall.SysProcAttr)),
// 	}
// }

// func _ConstructProcAttr(_v Object) *_syscall.ProcAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.ProcAttr:
// 			return &_g
// 		case *_syscall.ProcAttr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToProcAttr(_o.(Map))
// 	case *Vector:
// 		return _vectorToProcAttr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.ProcAttr] or: Map or Vector"))
// }

GO TYPE syscall.Radvisory_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRadvisory_t(args []Object, index int) *_syscall.Radvisory_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Radvisory_t:
			return &r
		case *_syscall.Radvisory_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Radvisory_t]"))
}

// func _mapToRadvisory_t(o Map) *_syscall.Radvisory_t {
// 	return &_syscall.Radvisory_t{}
// }

// func _vectorToRadvisory_t(o *Vector) *_syscall.Radvisory_t {
// 	return &_syscall.Radvisory_t{
// 		Offset: AssertNumber(o.Nth(0), "").BigInt().Int64(),
// 		Count: int32(AssertInt(o.Nth(1), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 	}
// }

// func _ConstructRadvisory_t(_v Object) *_syscall.Radvisory_t {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Radvisory_t:
// 			return &_g
// 		case *_syscall.Radvisory_t:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRadvisory_t(_o.(Map))
// 	case *Vector:
// 		return _vectorToRadvisory_t(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Radvisory_t] or: Map or Vector"))
// }

GO TYPE syscall.RawConn from syscall/net.go:
func ExtractGoObjectRawConn(args []Object, index int) *_syscall.RawConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawConn:
			return &r
		case *_syscall.RawConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawConn]"))
}

// func _ConstructRawConn(_v Object) _syscall.RawConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawConn:
// 			return _g
// 		case *_syscall.RawConn:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.RawConn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RawConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawConn] or: whatever"))
// }

GO TYPE syscall.RawSockaddr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddr(args []Object, index int) *_syscall.RawSockaddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddr:
			return &r
		case *_syscall.RawSockaddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddr]"))
}

// func _mapToRawSockaddr(o Map) *_syscall.RawSockaddr {
// 	return &_syscall.RawSockaddr{}
// }

// func _vectorToRawSockaddr(o *Vector) *_syscall.RawSockaddr {
// 	return &_syscall.RawSockaddr{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for [14]int8 (int8)),
// 	}
// }

// func _ConstructRawSockaddr(_v Object) *_syscall.RawSockaddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddr:
// 			return &_g
// 		case *_syscall.RawSockaddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddr] or: Map or Vector"))
// }

GO TYPE syscall.RawSockaddrAny from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddrAny(args []Object, index int) *_syscall.RawSockaddrAny {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrAny:
			return &r
		case *_syscall.RawSockaddrAny:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrAny]"))
}

// func _mapToRawSockaddrAny(o Map) *_syscall.RawSockaddrAny {
// 	return &_syscall.RawSockaddrAny{}
// }

// func _vectorToRawSockaddrAny(o *Vector) *_syscall.RawSockaddrAny {
// 	return &_syscall.RawSockaddrAny{
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for syscall.RawSockaddr (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Pad: ABEND048(codegen.go: no conversion from Clojure for [92]int8 (int8)),
// 	}
// }

// func _ConstructRawSockaddrAny(_v Object) *_syscall.RawSockaddrAny {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddrAny:
// 			return &_g
// 		case *_syscall.RawSockaddrAny:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddrAny(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddrAny(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrAny] or: Map or Vector"))
// }

GO TYPE syscall.RawSockaddrDatalink from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddrDatalink(args []Object, index int) *_syscall.RawSockaddrDatalink {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrDatalink:
			return &r
		case *_syscall.RawSockaddrDatalink:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrDatalink]"))
}

// func _mapToRawSockaddrDatalink(o Map) *_syscall.RawSockaddrDatalink {
// 	return &_syscall.RawSockaddrDatalink{}
// }

// func _vectorToRawSockaddrDatalink(o *Vector) *_syscall.RawSockaddrDatalink {
// 	return &_syscall.RawSockaddrDatalink{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Index: uint16(AssertInt(o.Nth(2), "").I),
// 		Type: uint8(AssertInt(o.Nth(3), "").I),
// 		Nlen: uint8(AssertInt(o.Nth(4), "").I),
// 		Alen: uint8(AssertInt(o.Nth(5), "").I),
// 		Slen: uint8(AssertInt(o.Nth(6), "").I),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for [12]int8 (int8)),
// 	}
// }

// func _ConstructRawSockaddrDatalink(_v Object) *_syscall.RawSockaddrDatalink {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddrDatalink:
// 			return &_g
// 		case *_syscall.RawSockaddrDatalink:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddrDatalink(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddrDatalink(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrDatalink] or: Map or Vector"))
// }

GO TYPE syscall.RawSockaddrInet4 from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddrInet4(args []Object, index int) *_syscall.RawSockaddrInet4 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrInet4:
			return &r
		case *_syscall.RawSockaddrInet4:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrInet4]"))
}

// func _mapToRawSockaddrInet4(o Map) *_syscall.RawSockaddrInet4 {
// 	return &_syscall.RawSockaddrInet4{}
// }

// func _vectorToRawSockaddrInet4(o *Vector) *_syscall.RawSockaddrInet4 {
// 	return &_syscall.RawSockaddrInet4{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Port: uint16(AssertInt(o.Nth(2), "").I),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Zero: ABEND048(codegen.go: no conversion from Clojure for [8]int8 (int8)),
// 	}
// }

// func _ConstructRawSockaddrInet4(_v Object) *_syscall.RawSockaddrInet4 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddrInet4:
// 			return &_g
// 		case *_syscall.RawSockaddrInet4:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddrInet4(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddrInet4(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrInet4] or: Map or Vector"))
// }

GO TYPE syscall.RawSockaddrInet6 from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddrInet6(args []Object, index int) *_syscall.RawSockaddrInet6 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrInet6:
			return &r
		case *_syscall.RawSockaddrInet6:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrInet6]"))
}

// func _mapToRawSockaddrInet6(o Map) *_syscall.RawSockaddrInet6 {
// 	return &_syscall.RawSockaddrInet6{}
// }

// func _vectorToRawSockaddrInet6(o *Vector) *_syscall.RawSockaddrInet6 {
// 	return &_syscall.RawSockaddrInet6{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Port: uint16(AssertInt(o.Nth(2), "").I),
// 		Flowinfo: uint32(AssertNumber(o.Nth(3), "").BigInt().Uint64()),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 		Scope_id: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 	}
// }

// func _ConstructRawSockaddrInet6(_v Object) *_syscall.RawSockaddrInet6 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddrInet6:
// 			return &_g
// 		case *_syscall.RawSockaddrInet6:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddrInet6(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddrInet6(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrInet6] or: Map or Vector"))
// }

GO TYPE syscall.RawSockaddrUnix from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRawSockaddrUnix(args []Object, index int) *_syscall.RawSockaddrUnix {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RawSockaddrUnix:
			return &r
		case *_syscall.RawSockaddrUnix:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RawSockaddrUnix]"))
}

// func _mapToRawSockaddrUnix(o Map) *_syscall.RawSockaddrUnix {
// 	return &_syscall.RawSockaddrUnix{}
// }

// func _vectorToRawSockaddrUnix(o *Vector) *_syscall.RawSockaddrUnix {
// 	return &_syscall.RawSockaddrUnix{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Path: ABEND048(codegen.go: no conversion from Clojure for [104]int8 (int8)),
// 	}
// }

// func _ConstructRawSockaddrUnix(_v Object) *_syscall.RawSockaddrUnix {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RawSockaddrUnix:
// 			return &_g
// 		case *_syscall.RawSockaddrUnix:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRawSockaddrUnix(_o.(Map))
// 	case *Vector:
// 		return _vectorToRawSockaddrUnix(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RawSockaddrUnix] or: Map or Vector"))
// }

GO TYPE syscall.Rlimit from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRlimit(args []Object, index int) *_syscall.Rlimit {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Rlimit:
			return &r
		case *_syscall.Rlimit:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Rlimit]"))
}

func _mapToRlimit(o Map) *_syscall.Rlimit {
	return &_syscall.Rlimit{}
}

func _vectorToRlimit(o *Vector) *_syscall.Rlimit {
	return &_syscall.Rlimit{
		Cur: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
		Max: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRlimit(_v Object) *_syscall.Rlimit {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Rlimit:
			return &_g
		case *_syscall.Rlimit:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRlimit(_o.(Map))
	case *Vector:
		return _vectorToRlimit(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Rlimit] or: Map or Vector"))
}

GO TYPE syscall.RouteMessage from syscall/route_bsd.go:
func ExtractGoObjectRouteMessage(args []Object, index int) *_syscall.RouteMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RouteMessage:
			return &r
		case *_syscall.RouteMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RouteMessage]"))
}

// func _mapToRouteMessage(o Map) *_syscall.RouteMessage {
// 	return &_syscall.RouteMessage{}
// }

// func _vectorToRouteMessage(o *Vector) *_syscall.RouteMessage {
// 	return &_syscall.RouteMessage{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for syscall.RtMsghdr (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructRouteMessage(_v Object) *_syscall.RouteMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RouteMessage:
// 			return &_g
// 		case *_syscall.RouteMessage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRouteMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToRouteMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RouteMessage] or: Map or Vector"))
// }

GO TYPE syscall.RoutingMessage from syscall/route_bsd.go:
func ExtractGoObjectRoutingMessage(args []Object, index int) *_syscall.RoutingMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RoutingMessage:
			return &r
		case *_syscall.RoutingMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RoutingMessage]"))
}

// func _ConstructRoutingMessage(_v Object) _syscall.RoutingMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RoutingMessage:
// 			return _g
// 		case *_syscall.RoutingMessage:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.RoutingMessage(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RoutingMessage))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RoutingMessage] or: whatever"))
// }

GO TYPE syscall.RtMetrics from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRtMetrics(args []Object, index int) *_syscall.RtMetrics {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtMetrics:
			return &r
		case *_syscall.RtMetrics:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtMetrics]"))
}

// func _mapToRtMetrics(o Map) *_syscall.RtMetrics {
// 	return &_syscall.RtMetrics{}
// }

// func _vectorToRtMetrics(o *Vector) *_syscall.RtMetrics {
// 	return &_syscall.RtMetrics{
// 		Locks: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Mtu: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Hopcount: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
// 		Expire: int32(AssertInt(o.Nth(3), "").I),
// 		Recvpipe: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Sendpipe: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Ssthresh: uint32(AssertNumber(o.Nth(6), "").BigInt().Uint64()),
// 		Rtt: uint32(AssertNumber(o.Nth(7), "").BigInt().Uint64()),
// 		Rttvar: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Pksent: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Filler: ABEND048(codegen.go: no conversion from Clojure for [4]uint32 (uint32)),
// 	}
// }

// func _ConstructRtMetrics(_v Object) *_syscall.RtMetrics {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RtMetrics:
// 			return &_g
// 		case *_syscall.RtMetrics:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRtMetrics(_o.(Map))
// 	case *Vector:
// 		return _vectorToRtMetrics(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtMetrics] or: Map or Vector"))
// }

GO TYPE syscall.RtMsghdr from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRtMsghdr(args []Object, index int) *_syscall.RtMsghdr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.RtMsghdr:
			return &r
		case *_syscall.RtMsghdr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.RtMsghdr]"))
}

// func _mapToRtMsghdr(o Map) *_syscall.RtMsghdr {
// 	return &_syscall.RtMsghdr{}
// }

// func _vectorToRtMsghdr(o *Vector) *_syscall.RtMsghdr {
// 	return &_syscall.RtMsghdr{
// 		Msglen: uint16(AssertInt(o.Nth(0), "").I),
// 		Version: uint8(AssertInt(o.Nth(1), "").I),
// 		Type: uint8(AssertInt(o.Nth(2), "").I),
// 		Index: uint16(AssertInt(o.Nth(3), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [2]byte (byte)),
// 		Flags: int32(AssertInt(o.Nth(5), "").I),
// 		Addrs: int32(AssertInt(o.Nth(6), "").I),
// 		Pid: int32(AssertInt(o.Nth(7), "").I),
// 		Seq: int32(AssertInt(o.Nth(8), "").I),
// 		Errno: int32(AssertInt(o.Nth(9), "").I),
// 		Use: int32(AssertInt(o.Nth(10), "").I),
// 		Inits: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 		Rmx: ABEND048(codegen.go: no conversion from Clojure for syscall.RtMetrics (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 	}
// }

// func _ConstructRtMsghdr(_v Object) *_syscall.RtMsghdr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.RtMsghdr:
// 			return &_g
// 		case *_syscall.RtMsghdr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRtMsghdr(_o.(Map))
// 	case *Vector:
// 		return _vectorToRtMsghdr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.RtMsghdr] or: Map or Vector"))
// }

GO TYPE syscall.Rusage from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectRusage(args []Object, index int) *_syscall.Rusage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Rusage:
			return &r
		case *_syscall.Rusage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Rusage]"))
}

// func _mapToRusage(o Map) *_syscall.Rusage {
// 	return &_syscall.Rusage{}
// }

// func _vectorToRusage(o *Vector) *_syscall.Rusage {
// 	return &_syscall.Rusage{
// 		Utime: ABEND048(codegen.go: no conversion from Clojure for syscall.Timeval (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Stime: ABEND048(codegen.go: no conversion from Clojure for syscall.Timeval (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Maxrss: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 		Ixrss: AssertNumber(o.Nth(3), "").BigInt().Int64(),
// 		Idrss: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		Isrss: AssertNumber(o.Nth(5), "").BigInt().Int64(),
// 		Minflt: AssertNumber(o.Nth(6), "").BigInt().Int64(),
// 		Majflt: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 		Nswap: AssertNumber(o.Nth(8), "").BigInt().Int64(),
// 		Inblock: AssertNumber(o.Nth(9), "").BigInt().Int64(),
// 		Oublock: AssertNumber(o.Nth(10), "").BigInt().Int64(),
// 		Msgsnd: AssertNumber(o.Nth(11), "").BigInt().Int64(),
// 		Msgrcv: AssertNumber(o.Nth(12), "").BigInt().Int64(),
// 		Nsignals: AssertNumber(o.Nth(13), "").BigInt().Int64(),
// 		Nvcsw: AssertNumber(o.Nth(14), "").BigInt().Int64(),
// 		Nivcsw: AssertNumber(o.Nth(15), "").BigInt().Int64(),
// 	}
// }

// func _ConstructRusage(_v Object) *_syscall.Rusage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Rusage:
// 			return &_g
// 		case *_syscall.Rusage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRusage(_o.(Map))
// 	case *Vector:
// 		return _vectorToRusage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Rusage] or: Map or Vector"))
// }

GO TYPE syscall.Signal from syscall/syscall_unix.go:
func ExtractGoObjectSignal(args []Object, index int) *_syscall.Signal {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Signal:
			return &r
		case *_syscall.Signal:
			return r
		}
	case Int:
		v := _syscall.Signal(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Signal]"))
}

func _ConstructSignal(_v Object) _syscall.Signal {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Signal:
			return _g
		case *_syscall.Signal:
			return *_g
		}
	case Number:
		return _syscall.Signal(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Signal] or: Number"))
}

GO TYPE syscall.Sockaddr from syscall/syscall_unix.go:
func ExtractGoObjectSockaddr(args []Object, index int) *_syscall.Sockaddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Sockaddr:
			return &r
		case *_syscall.Sockaddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Sockaddr]"))
}

// func _ConstructSockaddr(_v Object) _syscall.Sockaddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Sockaddr:
// 			return _g
// 		case *_syscall.Sockaddr:
// 			return *_g
// 		}
// 	default:
// 		return _syscall.Sockaddr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Sockaddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Sockaddr] or: whatever"))
// }

GO TYPE syscall.SockaddrDatalink from syscall/syscall_darwin.go:
func ExtractGoObjectSockaddrDatalink(args []Object, index int) *_syscall.SockaddrDatalink {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrDatalink:
			return &r
		case *_syscall.SockaddrDatalink:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrDatalink]"))
}

// func _mapToSockaddrDatalink(o Map) *_syscall.SockaddrDatalink {
// 	return &_syscall.SockaddrDatalink{}
// }

// func _vectorToSockaddrDatalink(o *Vector) *_syscall.SockaddrDatalink {
// 	return &_syscall.SockaddrDatalink{
// 		Len: uint8(AssertInt(o.Nth(0), "").I),
// 		Family: uint8(AssertInt(o.Nth(1), "").I),
// 		Index: uint16(AssertInt(o.Nth(2), "").I),
// 		Type: uint8(AssertInt(o.Nth(3), "").I),
// 		Nlen: uint8(AssertInt(o.Nth(4), "").I),
// 		Alen: uint8(AssertInt(o.Nth(5), "").I),
// 		Slen: uint8(AssertInt(o.Nth(6), "").I),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for [12]int8 (int8)),
// 	}
// }

// func _ConstructSockaddrDatalink(_v Object) *_syscall.SockaddrDatalink {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.SockaddrDatalink:
// 			return &_g
// 		case *_syscall.SockaddrDatalink:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSockaddrDatalink(_o.(Map))
// 	case *Vector:
// 		return _vectorToSockaddrDatalink(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrDatalink] or: Map or Vector"))
// }

GO TYPE syscall.SockaddrInet4 from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrInet4(args []Object, index int) *_syscall.SockaddrInet4 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrInet4:
			return &r
		case *_syscall.SockaddrInet4:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrInet4]"))
}

// func _mapToSockaddrInet4(o Map) *_syscall.SockaddrInet4 {
// 	return &_syscall.SockaddrInet4{}
// }

// func _vectorToSockaddrInet4(o *Vector) *_syscall.SockaddrInet4 {
// 	return &_syscall.SockaddrInet4{
// 		Port: AssertInt(o.Nth(0), "").I,
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 	}
// }

// func _ConstructSockaddrInet4(_v Object) *_syscall.SockaddrInet4 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.SockaddrInet4:
// 			return &_g
// 		case *_syscall.SockaddrInet4:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSockaddrInet4(_o.(Map))
// 	case *Vector:
// 		return _vectorToSockaddrInet4(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrInet4] or: Map or Vector"))
// }

GO TYPE syscall.SockaddrInet6 from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrInet6(args []Object, index int) *_syscall.SockaddrInet6 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrInet6:
			return &r
		case *_syscall.SockaddrInet6:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrInet6]"))
}

// func _mapToSockaddrInet6(o Map) *_syscall.SockaddrInet6 {
// 	return &_syscall.SockaddrInet6{}
// }

// func _vectorToSockaddrInet6(o *Vector) *_syscall.SockaddrInet6 {
// 	return &_syscall.SockaddrInet6{
// 		Port: AssertInt(o.Nth(0), "").I,
// 		ZoneId: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for [16]byte (byte)),
// 	}
// }

// func _ConstructSockaddrInet6(_v Object) *_syscall.SockaddrInet6 {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.SockaddrInet6:
// 			return &_g
// 		case *_syscall.SockaddrInet6:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSockaddrInet6(_o.(Map))
// 	case *Vector:
// 		return _vectorToSockaddrInet6(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrInet6] or: Map or Vector"))
// }

GO TYPE syscall.SockaddrUnix from syscall/syscall_unix.go:
func ExtractGoObjectSockaddrUnix(args []Object, index int) *_syscall.SockaddrUnix {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SockaddrUnix:
			return &r
		case *_syscall.SockaddrUnix:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SockaddrUnix]"))
}

func _mapToSockaddrUnix(o Map) *_syscall.SockaddrUnix {
	return &_syscall.SockaddrUnix{}
}

func _vectorToSockaddrUnix(o *Vector) *_syscall.SockaddrUnix {
	return &_syscall.SockaddrUnix{
		Name: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructSockaddrUnix(_v Object) *_syscall.SockaddrUnix {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.SockaddrUnix:
			return &_g
		case *_syscall.SockaddrUnix:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSockaddrUnix(_o.(Map))
	case *Vector:
		return _vectorToSockaddrUnix(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SockaddrUnix] or: Map or Vector"))
}

GO TYPE syscall.SocketControlMessage from syscall/sockcmsg_unix.go:
func ExtractGoObjectSocketControlMessage(args []Object, index int) *_syscall.SocketControlMessage {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SocketControlMessage:
			return &r
		case *_syscall.SocketControlMessage:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SocketControlMessage]"))
}

// func _mapToSocketControlMessage(o Map) *_syscall.SocketControlMessage {
// 	return &_syscall.SocketControlMessage{}
// }

// func _vectorToSocketControlMessage(o *Vector) *_syscall.SocketControlMessage {
// 	return &_syscall.SocketControlMessage{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for syscall.Cmsghdr (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Data: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructSocketControlMessage(_v Object) *_syscall.SocketControlMessage {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.SocketControlMessage:
// 			return &_g
// 		case *_syscall.SocketControlMessage:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSocketControlMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToSocketControlMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SocketControlMessage] or: Map or Vector"))
// }

GO TYPE syscall.Stat_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectStat_t(args []Object, index int) *_syscall.Stat_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Stat_t:
			return &r
		case *_syscall.Stat_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Stat_t]"))
}

// func _mapToStat_t(o Map) *_syscall.Stat_t {
// 	return &_syscall.Stat_t{}
// }

// func _vectorToStat_t(o *Vector) *_syscall.Stat_t {
// 	return &_syscall.Stat_t{
// 		Dev: int32(AssertInt(o.Nth(0), "").I),
// 		Mode: uint16(AssertInt(o.Nth(1), "").I),
// 		Nlink: uint16(AssertInt(o.Nth(2), "").I),
// 		Ino: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Uid: uint32(AssertNumber(o.Nth(4), "").BigInt().Uint64()),
// 		Gid: uint32(AssertNumber(o.Nth(5), "").BigInt().Uint64()),
// 		Rdev: int32(AssertInt(o.Nth(6), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Atimespec: ABEND048(codegen.go: no conversion from Clojure for syscall.Timespec (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Mtimespec: ABEND048(codegen.go: no conversion from Clojure for syscall.Timespec (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Ctimespec: ABEND048(codegen.go: no conversion from Clojure for syscall.Timespec (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Birthtimespec: ABEND048(codegen.go: no conversion from Clojure for syscall.Timespec (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Size: AssertNumber(o.Nth(12), "").BigInt().Int64(),
// 		Blocks: AssertNumber(o.Nth(13), "").BigInt().Int64(),
// 		Blksize: int32(AssertInt(o.Nth(14), "").I),
// 		Flags: uint32(AssertNumber(o.Nth(15), "").BigInt().Uint64()),
// 		Gen: uint32(AssertNumber(o.Nth(16), "").BigInt().Uint64()),
// 		Lspare: int32(AssertInt(o.Nth(17), "").I),
// 		Qspare: ABEND048(codegen.go: no conversion from Clojure for [2]int64 (int64)),
// 	}
// }

// func _ConstructStat_t(_v Object) *_syscall.Stat_t {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Stat_t:
// 			return &_g
// 		case *_syscall.Stat_t:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStat_t(_o.(Map))
// 	case *Vector:
// 		return _vectorToStat_t(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Stat_t] or: Map or Vector"))
// }

GO TYPE syscall.Statfs_t from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectStatfs_t(args []Object, index int) *_syscall.Statfs_t {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Statfs_t:
			return &r
		case *_syscall.Statfs_t:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Statfs_t]"))
}

// func _mapToStatfs_t(o Map) *_syscall.Statfs_t {
// 	return &_syscall.Statfs_t{}
// }

// func _vectorToStatfs_t(o *Vector) *_syscall.Statfs_t {
// 	return &_syscall.Statfs_t{
// 		Bsize: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Iosize: int32(AssertInt(o.Nth(1), "").I),
// 		Blocks: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
// 		Bfree: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Bavail: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
// 		Files: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
// 		Ffree: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
// 		Fsid: ABEND048(codegen.go: no conversion from Clojure for syscall.Fsid (ABEND047(gotypes.go: unsupported type *ast.StructType))),
// 		Owner: uint32(AssertNumber(o.Nth(8), "").BigInt().Uint64()),
// 		Type: uint32(AssertNumber(o.Nth(9), "").BigInt().Uint64()),
// 		Flags: uint32(AssertNumber(o.Nth(10), "").BigInt().Uint64()),
// 		Fssubtype: uint32(AssertNumber(o.Nth(11), "").BigInt().Uint64()),
// 		Fstypename: ABEND048(codegen.go: no conversion from Clojure for [16]int8 (int8)),
// 		Mntonname: ABEND048(codegen.go: no conversion from Clojure for [1024]int8 (int8)),
// 		Mntfromname: ABEND048(codegen.go: no conversion from Clojure for [1024]int8 (int8)),
// 		Reserved: ABEND048(codegen.go: no conversion from Clojure for [8]uint32 (uint32)),
// 	}
// }

// func _ConstructStatfs_t(_v Object) *_syscall.Statfs_t {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Statfs_t:
// 			return &_g
// 		case *_syscall.Statfs_t:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToStatfs_t(_o.(Map))
// 	case *Vector:
// 		return _vectorToStatfs_t(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Statfs_t] or: Map or Vector"))
// }

GO TYPE syscall.SysProcAttr from syscall/exec_darwin.go:
func ExtractGoObjectSysProcAttr(args []Object, index int) *_syscall.SysProcAttr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.SysProcAttr:
			return &r
		case *_syscall.SysProcAttr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.SysProcAttr]"))
}

// func _mapToSysProcAttr(o Map) *_syscall.SysProcAttr {
// 	return &_syscall.SysProcAttr{}
// }

// func _vectorToSysProcAttr(o *Vector) *_syscall.SysProcAttr {
// 	return &_syscall.SysProcAttr{
// 		Chroot: AssertString(o.Nth(0), "").S,
// 		Credential: ABEND048(codegen.go: no conversion from Clojure for *syscall.Credential (syscall.Credential)),
// 		Ptrace: ToBool(o.Nth(2)),
// 		Setsid: ToBool(o.Nth(3)),
// 		Setpgid: ToBool(o.Nth(4)),
// 		Setctty: ToBool(o.Nth(5)),
// 		Noctty: ToBool(o.Nth(6)),
// 		Ctty: AssertInt(o.Nth(7), "").I,
// 		Foreground: ToBool(o.Nth(8)),
// 		Pgid: AssertInt(o.Nth(9), "").I,
// 	}
// }

// func _ConstructSysProcAttr(_v Object) *_syscall.SysProcAttr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.SysProcAttr:
// 			return &_g
// 		case *_syscall.SysProcAttr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToSysProcAttr(_o.(Map))
// 	case *Vector:
// 		return _vectorToSysProcAttr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.SysProcAttr] or: Map or Vector"))
// }

GO TYPE syscall.Termios from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectTermios(args []Object, index int) *_syscall.Termios {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Termios:
			return &r
		case *_syscall.Termios:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Termios]"))
}

// func _mapToTermios(o Map) *_syscall.Termios {
// 	return &_syscall.Termios{}
// }

// func _vectorToTermios(o *Vector) *_syscall.Termios {
// 	return &_syscall.Termios{
// 		Iflag: AssertNumber(o.Nth(0), "").BigInt().Uint64(),
// 		Oflag: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
// 		Cflag: AssertNumber(o.Nth(2), "").BigInt().Uint64(),
// 		Lflag: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		Cc: ABEND048(codegen.go: no conversion from Clojure for [20]uint8 (uint8)),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 		Ispeed: AssertNumber(o.Nth(6), "").BigInt().Uint64(),
// 		Ospeed: AssertNumber(o.Nth(7), "").BigInt().Uint64(),
// 	}
// }

// func _ConstructTermios(_v Object) *_syscall.Termios {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Termios:
// 			return &_g
// 		case *_syscall.Termios:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTermios(_o.(Map))
// 	case *Vector:
// 		return _vectorToTermios(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Termios] or: Map or Vector"))
// }

GO TYPE syscall.Timespec from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectTimespec(args []Object, index int) *_syscall.Timespec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timespec:
			return &r
		case *_syscall.Timespec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timespec]"))
}

func _mapToTimespec(o Map) *_syscall.Timespec {
	return &_syscall.Timespec{}
}

func _vectorToTimespec(o *Vector) *_syscall.Timespec {
	return &_syscall.Timespec{
		Sec: AssertNumber(o.Nth(0), "").BigInt().Int64(),
		Nsec: AssertNumber(o.Nth(1), "").BigInt().Int64(),
	}
}

func _ConstructTimespec(_v Object) *_syscall.Timespec {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Timespec:
			return &_g
		case *_syscall.Timespec:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimespec(_o.(Map))
	case *Vector:
		return _vectorToTimespec(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timespec] or: Map or Vector"))
}

GO TYPE syscall.Timeval from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectTimeval(args []Object, index int) *_syscall.Timeval {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timeval:
			return &r
		case *_syscall.Timeval:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timeval]"))
}

// func _mapToTimeval(o Map) *_syscall.Timeval {
// 	return &_syscall.Timeval{}
// }

// func _vectorToTimeval(o *Vector) *_syscall.Timeval {
// 	return &_syscall.Timeval{
// 		Sec: AssertNumber(o.Nth(0), "").BigInt().Int64(),
// 		Usec: int32(AssertInt(o.Nth(1), "").I),
// 		Pad_cgo_0: ABEND048(codegen.go: no conversion from Clojure for [4]byte (byte)),
// 	}
// }

// func _ConstructTimeval(_v Object) *_syscall.Timeval {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _syscall.Timeval:
// 			return &_g
// 		case *_syscall.Timeval:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTimeval(_o.(Map))
// 	case *Vector:
// 		return _vectorToTimeval(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timeval] or: Map or Vector"))
// }

GO TYPE syscall.Timeval32 from syscall/ztypes_darwin_amd64.go:
func ExtractGoObjectTimeval32(args []Object, index int) *_syscall.Timeval32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.Timeval32:
			return &r
		case *_syscall.Timeval32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.Timeval32]"))
}

func _mapToTimeval32(o Map) *_syscall.Timeval32 {
	return &_syscall.Timeval32{}
}

func _vectorToTimeval32(o *Vector) *_syscall.Timeval32 {
	return &_syscall.Timeval32{
		Sec: int32(AssertInt(o.Nth(0), "").I),
		Usec: int32(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructTimeval32(_v Object) *_syscall.Timeval32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.Timeval32:
			return &_g
		case *_syscall.Timeval32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTimeval32(_o.(Map))
	case *Vector:
		return _vectorToTimeval32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.Timeval32] or: Map or Vector"))
}

GO TYPE syscall.WaitStatus from syscall/syscall_bsd.go:
func ExtractGoObjectWaitStatus(args []Object, index int) *_syscall.WaitStatus {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _syscall.WaitStatus:
			return &r
		case *_syscall.WaitStatus:
			return r
		}
	case Number:
		v := _syscall.WaitStatus(ExtractUInt32(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[syscall.WaitStatus]"))
}

func _ConstructWaitStatus(_v Object) _syscall.WaitStatus {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _syscall.WaitStatus:
			return _g
		case *_syscall.WaitStatus:
			return *_g
		}
	case Number:
		return _syscall.WaitStatus(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[syscall.WaitStatus] or: Number"))
}

GO FUNC syscall.Accept from syscall/syscall_bsd.go:
func __accept(fd int) Object {
	nfd, sa, err := _syscall.Accept(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.BpfBuflen from syscall/bpf_darwin.go:
func __bpfBuflen(fd int) Object {
	_res1, _res2 := _syscall.BpfBuflen(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfDatalink from syscall/bpf_darwin.go:
func __bpfDatalink(fd int) Object {
	_res1, _res2 := _syscall.BpfDatalink(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfHeadercmpl from syscall/bpf_darwin.go:
func __bpfHeadercmpl(fd int) Object {
	_res1, _res2 := _syscall.BpfHeadercmpl(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfInterface from syscall/bpf_darwin.go:
func __bpfInterface(fd int, name string) Object {
	_res1, _res2 := _syscall.BpfInterface(fd, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfJump from syscall/bpf_darwin.go:
func __bpfJump(code int, k int, jt int, jf int) Object {
	_res := _syscall.BpfJump(code, k, jt, jf)
	return MakeGoObject(_res)
}

GO FUNC syscall.BpfStats from syscall/bpf_darwin.go:
func __bpfStats(fd int) Object {
	_res1, _res2 := _syscall.BpfStats(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BpfStmt from syscall/bpf_darwin.go:
func __bpfStmt(code int, k int) Object {
	_res := _syscall.BpfStmt(code, k)
	return MakeGoObject(_res)
}

GO FUNC syscall.BpfTimeout from syscall/bpf_darwin.go:
func __bpfTimeout(fd int) Object {
	_res1, _res2 := _syscall.BpfTimeout(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.BytePtrFromString from syscall/syscall.go:
func __bytePtrFromString(s string) Object {
	_res1, _res2 := _syscall.BytePtrFromString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ByteSliceFromString from syscall/syscall.go:
func __byteSliceFromString(s string) Object {
	_res1, _res2 := _syscall.ByteSliceFromString(s)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Clearenv from syscall/env_unix.go:
// func __clearenv() Object {
// 	_syscall.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.CloseOnExec from syscall/exec_unix.go:
// func __closeOnExec(fd int) Object {
// 	_syscall.CloseOnExec(fd)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Dup from syscall/zsyscall_darwin_amd64.go:
func __dup(fd int) Object {
	nfd, err := _syscall.Dup(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(nfd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Environ from syscall/env_unix.go:
func __environ() Object {
	_res := _syscall.Environ()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC syscall.Exec from syscall/exec_unix.go:
// func __exec(argv0 string, argv []string, envv []string)  {
// 	_res := _syscall.Exec(argv0, argv, envv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Exit from syscall/syscall.go:
// func __exit(code int) Object {
// 	_syscall.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.ForkExec from syscall/exec_unix.go:
// func __forkExec(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, err := _syscall.ForkExec(argv0, argv, attr)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Fpathconf from syscall/zsyscall_darwin_amd64.go:
func __fpathconf(fd int, name int) Object {
	val, err := _syscall.Fpathconf(fd, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(val))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Futimes from syscall/syscall_bsd.go:
// func __futimes(fd int, tv []_syscall.Timeval)  {
// 	_res := _syscall.Futimes(fd, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Getdirentries from syscall/zsyscall_darwin_amd64.go:
// func __getdirentries(fd int, buf []byte, basep *uintptr) Object {
// 	n, err := _syscall.Getdirentries(fd, buf, basep)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getenv from syscall/env_unix.go:
func __getenv(key string) Object {
	value, found := _syscall.Getenv(key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(MakeBoolean(found))
	return _res
}

GO FUNC syscall.Getfsstat from syscall/syscall_darwin.go:
// func __getfsstat(buf []_syscall.Statfs_t, flags int) Object {
// 	n, err := _syscall.Getfsstat(buf, flags)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getgroups from syscall/syscall_bsd.go:
func __getgroups() Object {
	gids, err := _syscall.Getgroups()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range gids {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpeername from syscall/syscall_unix.go:
func __getpeername(fd int) Object {
	sa, err := _syscall.Getpeername(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpgid from syscall/zsyscall_darwin_amd64.go:
func __getpgid(pid int) Object {
	pgid, err := _syscall.Getpgid(pid)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(pgid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpriority from syscall/zsyscall_darwin_amd64.go:
func __getpriority(which int, who int) Object {
	prio, err := _syscall.Getpriority(which, who)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(prio))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getsid from syscall/zsyscall_darwin_amd64.go:
func __getsid(pid int) Object {
	sid, err := _syscall.Getsid(pid)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(sid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getsockname from syscall/syscall_bsd.go:
func __getsockname(fd int) Object {
	sa, err := _syscall.Getsockname(fd)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(sa))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptByte from syscall/syscall_bsd.go:
func __getsockoptByte(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptByte(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(int(value)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptICMPv6Filter from syscall/syscall_bsd.go:
func __getsockoptICMPv6Filter(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptICMPv6Filter(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreq from syscall/syscall_bsd.go:
func __getsockoptIPMreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreq(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6MTUInfo from syscall/syscall_bsd.go:
func __getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6Mreq from syscall/syscall_bsd.go:
func __getsockoptIPv6Mreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6Mreq(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptInet4Addr from syscall/syscall_bsd.go:
func __getsockoptInet4Addr(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInet4Addr(fd, level, opt)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range value {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptInt from syscall/syscall_unix.go:
func __getsockoptInt(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInt(fd, level, opt)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getwd from syscall/syscall_darwin.go:
func __getwd() Object {
	_res1, _res2 := _syscall.Getwd()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Kevent from syscall/syscall_bsd.go:
// func __kevent(kq int, changes []_syscall.Kevent_t, events []_syscall.Kevent_t, timeout *_syscall.Timespec) Object {
// 	n, err := _syscall.Kevent(kq, changes, events, timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Kqueue from syscall/zsyscall_darwin_amd64.go:
func __kqueue() Object {
	fd, err := _syscall.Kqueue()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Mlock from syscall/zsyscall_darwin_amd64.go:
// func __mlock(b []byte)  {
// 	_res := _syscall.Mlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Mmap from syscall/syscall_bsd.go:
func __mmap(fd int, offset int64, length int, prot int, flags int) Object {
	data, err := _syscall.Mmap(fd, offset, length, prot, flags)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range data {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Mprotect from syscall/zsyscall_darwin_amd64.go:
// func __mprotect(b []byte, prot int)  {
// 	_res := _syscall.Mprotect(b, prot)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munlock from syscall/zsyscall_darwin_amd64.go:
// func __munlock(b []byte)  {
// 	_res := _syscall.Munlock(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Munmap from syscall/syscall_bsd.go:
// func __munmap(b []byte)  {
// 	_res := _syscall.Munmap(b)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.NsecToTimespec from syscall/timestruct.go:
func __nsecToTimespec(nsec int64) Object {
	_res := _syscall.NsecToTimespec(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.NsecToTimeval from syscall/timestruct.go:
func __nsecToTimeval(nsec int64) Object {
	_res := _syscall.NsecToTimeval(nsec)
	return MakeGoObject(_res)
}

GO FUNC syscall.Open from syscall/zsyscall_darwin_amd64.go:
func __open(path string, mode int, perm uint32) Object {
	fd, err := _syscall.Open(path, mode, perm)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.ParseDirent from syscall/dirent.go:
// func __parseDirent(buf []byte, max int, names []string) Object {
// 	consumed, count, newnames := _syscall.ParseDirent(buf, max, names)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(consumed))
// 	_res = _res.Conjoin(MakeInt(count))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range newnames {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	return _res
// }

GO FUNC syscall.ParseRoutingMessage from syscall/route_bsd.go:
// func __parseRoutingMessage(b []byte) Object {
// 	msgs, err := _syscall.ParseRoutingMessage(b)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range msgs {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.ParseRoutingSockaddr from syscall/route_bsd.go:
func __parseRoutingSockaddr(msg _syscall.RoutingMessage) Object {
	_res1, _res2 := _syscall.ParseRoutingSockaddr(msg)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ParseSocketControlMessage from syscall/sockcmsg_unix.go:
// func __parseSocketControlMessage(b []byte) Object {
// 	_res1, _res2 := _syscall.ParseSocketControlMessage(b)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseUnixRights from syscall/sockcmsg_unix.go:
func __parseUnixRights(m *_syscall.SocketControlMessage) Object {
	_res1, _res2 := _syscall.ParseUnixRights(m)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Pathconf from syscall/zsyscall_darwin_amd64.go:
func __pathconf(path string, name int) Object {
	val, err := _syscall.Pathconf(path, name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(val))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Pipe from syscall/syscall_darwin.go:
// func __pipe(p []int)  {
// 	_res := _syscall.Pipe(p)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Pread from syscall/zsyscall_darwin_amd64.go:
// func __pread(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pread(fd, p, offset)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Pwrite from syscall/zsyscall_darwin_amd64.go:
// func __pwrite(fd int, p []byte, offset int64) Object {
// 	n, err := _syscall.Pwrite(fd, p, offset)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.RawSyscall from syscall/syscall_unix.go:
// func __rawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall(trap, a1, a2, a3)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.RawSyscall6 from syscall/syscall_unix.go:
// func __rawSyscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Read from syscall/syscall_unix.go:
// func __read(fd int, p []byte) Object {
// 	n, err := _syscall.Read(fd, p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.ReadDirent from syscall/syscall_bsd.go:
// func __readDirent(fd int, buf []byte) Object {
// 	n, err := _syscall.ReadDirent(fd, buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Readlink from syscall/zsyscall_darwin_amd64.go:
// func __readlink(path string, buf []byte) Object {
// 	n, err := _syscall.Readlink(path, buf)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvfrom from syscall/syscall_unix.go:
// func __recvfrom(fd int, p []byte, flags int) Object {
// 	n, from, err := _syscall.Recvfrom(fd, p, flags)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvmsg from syscall/syscall_bsd.go:
// func __recvmsg(fd int, p []byte, oob []byte, flags int) Object {
// 	n, oobn, recvflags, from, err := _syscall.Recvmsg(fd, p, oob, flags)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeInt(oobn))
// 	_res = _res.Conjoin(MakeInt(recvflags))
// 	_res = _res.Conjoin(MakeGoObject(from))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.RouteRIB from syscall/route_bsd.go:
func __routeRIB(facility int, param int) Object {
	_res1, _res2 := _syscall.RouteRIB(facility, param)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Seek from syscall/zsyscall_darwin_amd64.go:
func __seek(fd int, offset int64, whence int) Object {
	newoffset, err := _syscall.Seek(fd, offset, whence)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(newoffset))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Sendfile from syscall/syscall_unix.go:
// func __sendfile(outfd int, infd int, offset *int64, count int) Object {
// 	written, err := _syscall.Sendfile(outfd, infd, offset, count)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(written))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendmsg from syscall/syscall_bsd.go:
// func __sendmsg(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int)  {
// 	_res := _syscall.Sendmsg(fd, p, oob, to, flags)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SendmsgN from syscall/syscall_bsd.go:
// func __sendmsgN(fd int, p []byte, oob []byte, to _syscall.Sockaddr, flags int) Object {
// 	n, err := _syscall.SendmsgN(fd, p, oob, to, flags)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendto from syscall/syscall_unix.go:
// func __sendto(fd int, p []byte, flags int, to _syscall.Sockaddr)  {
// 	_res := _syscall.Sendto(fd, p, flags, to)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetBpf from syscall/bpf_darwin.go:
// func __setBpf(fd int, i []_syscall.BpfInsn)  {
// 	_res := _syscall.SetBpf(fd, i)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SetBpfBuflen from syscall/bpf_darwin.go:
func __setBpfBuflen(fd int, l int) Object {
	_res1, _res2 := _syscall.SetBpfBuflen(fd, l)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.SetBpfDatalink from syscall/bpf_darwin.go:
func __setBpfDatalink(fd int, t int) Object {
	_res1, _res2 := _syscall.SetBpfDatalink(fd, t)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.SetKevent from syscall/syscall_darwin_amd64.go:
// func __setKevent(k *_syscall.Kevent_t, fd int, mode int, flags int) Object {
// 	_syscall.SetKevent(k, fd, mode, flags)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Setgroups from syscall/syscall_bsd.go:
// func __setgroups(gids []int)  {
// 	_res := _syscall.Setgroups(gids)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Setsid from syscall/zsyscall_darwin_amd64.go:
func __setsid() Object {
	pid, err := _syscall.Setsid()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(pid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SetsockoptInet4Addr from syscall/syscall_unix.go:
// func __setsockoptInet4Addr(fd int, level int, opt int, value []byte)  {
// 	_res := _syscall.SetsockoptInet4Addr(fd, level, opt, value)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.SlicePtrFromStrings from syscall/exec_unix.go:
// func __slicePtrFromStrings(ss []string) Object {
// 	_res1, _res2 := _syscall.SlicePtrFromStrings(ss)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.Socket from syscall/syscall_unix.go:
func __socket(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socket(domain, typ, proto)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Socketpair from syscall/syscall_unix.go:
func __socketpair(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socketpair(domain, typ, proto)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range fd {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.StartProcess from syscall/exec_unix.go:
// func __startProcess(argv0 string, argv []string, attr *_syscall.ProcAttr) Object {
// 	pid, handle, err := _syscall.StartProcess(argv0, argv, attr)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.StringBytePtr from syscall/syscall.go:
func __stringBytePtr(s string) Object {
	_res := _syscall.StringBytePtr(s)
	return MakeGoObject(_res)
}

GO FUNC syscall.StringByteSlice from syscall/syscall.go:
func __stringByteSlice(s string) Object {
	_res := _syscall.StringByteSlice(s)
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC syscall.StringSlicePtr from syscall/exec_unix.go:
// func __stringSlicePtr(ss []string) Object {
// 	_res := _syscall.StringSlicePtr(ss)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Syscall from syscall/syscall_unix.go:
// func __syscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall(trap, a1, a2, a3)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Syscall6 from syscall/syscall_unix.go:
// func __syscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Syscall9 from syscall/syscall_darwin_amd64.go:
// func __syscall9(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr, a7 uintptr, a8 uintptr, a9 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall9(trap, a1, a2, a3, a4, a5, a6, a7, a8, a9)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(ABEND043(post.go: unsupported built-in type uintptr))
// 	_res = _res.Conjoin(MakeGoObject(err))
// 	return _res
// }

GO FUNC syscall.Sysctl from syscall/syscall_bsd.go:
func __sysctl(name string) Object {
	value, err := _syscall.Sysctl(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SysctlUint32 from syscall/syscall_bsd.go:
func __sysctlUint32(name string) Object {
	value, err := _syscall.SysctlUint32(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigIntU(uint64(value)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.TimespecToNsec from syscall/timestruct.go:
func __timespecToNsec(ts _syscall.Timespec) Object {
	_res := _syscall.TimespecToNsec(ts)
	return MakeBigInt(_res)
}

GO FUNC syscall.TimevalToNsec from syscall/timestruct.go:
func __timevalToNsec(tv _syscall.Timeval) Object {
	_res := _syscall.TimevalToNsec(tv)
	return MakeBigInt(_res)
}

GO FUNC syscall.UnixRights from syscall/sockcmsg_unix.go:
// func __unixRights(fds ...int) Object {
// 	_res := _syscall.UnixRights(fds)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Utimes from syscall/syscall_bsd.go:
// func __utimes(path string, tv []_syscall.Timeval)  {
// 	_res := _syscall.Utimes(path, tv)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.UtimesNano from syscall/syscall_bsd.go:
// func __utimesNano(path string, ts []_syscall.Timespec)  {
// 	_res := _syscall.UtimesNano(path, ts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC syscall.Wait4 from syscall/syscall_bsd.go:
func __wait4(pid int, wstatus *_syscall.WaitStatus, options int, rusage *_syscall.Rusage) Object {
	wpid, err := _syscall.Wait4(pid, wstatus, options, rusage)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(wpid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Write from syscall/syscall_unix.go:
// func __write(fd int, p []byte) Object {
// 	n, err := _syscall.Write(fd, p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.__errno_Error from syscall/syscall_unix.go:
func __errno_Error(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.Errno)Error()", args, 0, 0)
	_res := o.O.(_syscall.Errno).Error()
	return MakeString(_res)
}

GO FUNC syscall.__errno_Temporary from syscall/syscall_unix.go:
func __errno_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.Errno)Temporary()", args, 0, 0)
	_res := o.O.(_syscall.Errno).Temporary()
	return MakeBoolean(_res)
}

GO FUNC syscall.__errno_Timeout from syscall/syscall_unix.go:
func __errno_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.Errno)Timeout()", args, 0, 0)
	_res := o.O.(_syscall.Errno).Timeout()
	return MakeBoolean(_res)
}

GO FUNC syscall.__ptrTo_Cmsghdr_SetLen from syscall/syscall_darwin_amd64.go:
// func __ptrTo_Cmsghdr_SetLen(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC syscall.__ptrTo_Iovec_SetLen from syscall/syscall_darwin_amd64.go:
// func __ptrTo_Iovec_SetLen(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC syscall.__ptrTo_Msghdr_SetControllen from syscall/syscall_darwin_amd64.go:
// func __ptrTo_Msghdr_SetControllen(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC syscall.__ptrTo_Timespec_Nano from syscall/syscall.go:
func __ptrTo_Timespec_Nano(o GoObject, args Object) Object {
	CheckGoArity("(*_syscall.Timespec)Nano()", args, 0, 0)
	_res := o.O.(*_syscall.Timespec).Nano()
	return MakeBigInt(_res)
}

GO FUNC syscall.__ptrTo_Timespec_Unix from syscall/syscall.go:
func __ptrTo_Timespec_Unix(o GoObject, args Object) Object {
	CheckGoArity("(*_syscall.Timespec)Unix()", args, 0, 0)
	sec, nsec := o.O.(*_syscall.Timespec).Unix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(sec))
	_res = _res.Conjoin(MakeBigInt(nsec))
	return _res
}

GO FUNC syscall.__ptrTo_Timeval_Nano from syscall/syscall.go:
func __ptrTo_Timeval_Nano(o GoObject, args Object) Object {
	CheckGoArity("(*_syscall.Timeval)Nano()", args, 0, 0)
	_res := o.O.(*_syscall.Timeval).Nano()
	return MakeBigInt(_res)
}

GO FUNC syscall.__ptrTo_Timeval_Unix from syscall/syscall.go:
func __ptrTo_Timeval_Unix(o GoObject, args Object) Object {
	CheckGoArity("(*_syscall.Timeval)Unix()", args, 0, 0)
	sec, nsec := o.O.(*_syscall.Timeval).Unix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBigInt(sec))
	_res = _res.Conjoin(MakeBigInt(nsec))
	return _res
}

GO FUNC syscall.__signal_Signal from syscall/syscall_unix.go:
// func __signal_Signal(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC syscall.__signal_String from syscall/syscall_unix.go:
func __signal_String(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.Signal)String()", args, 0, 0)
	_res := o.O.(_syscall.Signal).String()
	return MakeString(_res)
}

GO FUNC syscall.__waitStatus_Continued from syscall/syscall_bsd.go:
func __waitStatus_Continued(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)Continued()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).Continued()
	return MakeBoolean(_res)
}

GO FUNC syscall.__waitStatus_CoreDump from syscall/syscall_bsd.go:
func __waitStatus_CoreDump(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)CoreDump()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).CoreDump()
	return MakeBoolean(_res)
}

GO FUNC syscall.__waitStatus_ExitStatus from syscall/syscall_bsd.go:
func __waitStatus_ExitStatus(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)ExitStatus()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).ExitStatus()
	return MakeInt(_res)
}

GO FUNC syscall.__waitStatus_Exited from syscall/syscall_bsd.go:
func __waitStatus_Exited(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)Exited()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).Exited()
	return MakeBoolean(_res)
}

GO FUNC syscall.__waitStatus_Signal from syscall/syscall_bsd.go:
func __waitStatus_Signal(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)Signal()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).Signal()
	return MakeGoObject(_res)
}

GO FUNC syscall.__waitStatus_Signaled from syscall/syscall_bsd.go:
func __waitStatus_Signaled(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)Signaled()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).Signaled()
	return MakeBoolean(_res)
}

GO FUNC syscall.__waitStatus_StopSignal from syscall/syscall_bsd.go:
func __waitStatus_StopSignal(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)StopSignal()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).StopSignal()
	return MakeGoObject(_res)
}

GO FUNC syscall.__waitStatus_Stopped from syscall/syscall_bsd.go:
func __waitStatus_Stopped(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)Stopped()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).Stopped()
	return MakeBoolean(_res)
}

GO FUNC syscall.__waitStatus_TrapCause from syscall/syscall_bsd.go:
func __waitStatus_TrapCause(o GoObject, args Object) Object {
	CheckGoArity("(_syscall.WaitStatus)TrapCause()", args, 0, 0)
	_res := o.O.(_syscall.WaitStatus).TrapCause()
	return MakeInt(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package syscall

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_syscall "syscall"
)
var members_Errno = GoTypeInfo{Members: GoMembers{
	"Error": __errno_Error,
	"Temporary": __errno_Temporary,
	"Timeout": __errno_Timeout,
}}

var members_Signal = GoTypeInfo{Members: GoMembers{
	"String": __signal_String,
}}

var members_PtrTo_Timespec = GoTypeInfo{Members: GoMembers{
	"Nano": __ptrTo_Timespec_Nano,
	"Unix": __ptrTo_Timespec_Unix,
}}

var members_PtrTo_Timeval = GoTypeInfo{Members: GoMembers{
	"Nano": __ptrTo_Timeval_Nano,
	"Unix": __ptrTo_Timeval_Unix,
}}

var members_WaitStatus = GoTypeInfo{Members: GoMembers{
	"Continued": __waitStatus_Continued,
	"CoreDump": __waitStatus_CoreDump,
	"ExitStatus": __waitStatus_ExitStatus,
	"Exited": __waitStatus_Exited,
	"Signal": __waitStatus_Signal,
	"Signaled": __waitStatus_Signaled,
	"StopSignal": __waitStatus_StopSignal,
	"Stopped": __waitStatus_Stopped,
	"TrapCause": __waitStatus_TrapCause,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_syscall.Errno)(nil)).Elem()] = &members_Errno
	GoTypes[_reflect.TypeOf((*_syscall.Signal)(nil)).Elem()] = &members_Signal
	GoTypes[_reflect.TypeOf((*_syscall.Timespec)(nil))] = &members_PtrTo_Timespec
	GoTypes[_reflect.TypeOf((*_syscall.Timeval)(nil))] = &members_PtrTo_Timeval
	GoTypes[_reflect.TypeOf((*_syscall.WaitStatus)(nil)).Elem()] = &members_WaitStatus
}

GO TYPE testing.B from testing/benchmark.go:
func ExtractGoObjectB(args []Object, index int) *_testing.B {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.B:
			return &r
		case *_testing.B:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.B]"))
}

func _mapToB(o Map) *_testing.B {
	return &_testing.B{}
}

func _vectorToB(o *Vector) *_testing.B {
	return &_testing.B{
		N: AssertInt(o.Nth(0), "").I,
	}
}

func _ConstructB(_v Object) *_testing.B {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.B:
			return &_g
		case *_testing.B:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToB(_o.(Map))
	case *Vector:
		return _vectorToB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.B] or: Map or Vector"))
}

GO TYPE testing.BenchmarkResult from testing/benchmark.go:
func ExtractGoObjectBenchmarkResult(args []Object, index int) *_testing.BenchmarkResult {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.BenchmarkResult:
			return &r
		case *_testing.BenchmarkResult:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.BenchmarkResult]"))
}

// func _mapToBenchmarkResult(o Map) *_testing.BenchmarkResult {
// 	return &_testing.BenchmarkResult{}
// }

// func _vectorToBenchmarkResult(o *Vector) *_testing.BenchmarkResult {
// 	return &_testing.BenchmarkResult{
// 		N: AssertInt(o.Nth(0), "").I,
// 		T: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Bytes: AssertNumber(o.Nth(2), "").BigInt().Int64(),
// 		MemAllocs: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		MemBytes: AssertNumber(o.Nth(4), "").BigInt().Uint64(),
// 	}
// }

// func _ConstructBenchmarkResult(_v Object) *_testing.BenchmarkResult {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.BenchmarkResult:
// 			return &_g
// 		case *_testing.BenchmarkResult:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBenchmarkResult(_o.(Map))
// 	case *Vector:
// 		return _vectorToBenchmarkResult(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.BenchmarkResult] or: Map or Vector"))
// }

GO TYPE testing.Cover from testing/cover.go:
func ExtractGoObjectCover(args []Object, index int) *_testing.Cover {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.Cover:
			return &r
		case *_testing.Cover:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.Cover]"))
}

// func _mapToCover(o Map) *_testing.Cover {
// 	return &_testing.Cover{}
// }

// func _vectorToCover(o *Vector) *_testing.Cover {
// 	return &_testing.Cover{
// 		Mode: AssertString(o.Nth(0), "").S,
// 		Counters: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		Blocks: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		CoveredPackages: AssertString(o.Nth(3), "").S,
// 	}
// }

// func _ConstructCover(_v Object) *_testing.Cover {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.Cover:
// 			return &_g
// 		case *_testing.Cover:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCover(_o.(Map))
// 	case *Vector:
// 		return _vectorToCover(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.Cover] or: Map or Vector"))
// }

GO TYPE testing.CoverBlock from testing/cover.go:
func ExtractGoObjectCoverBlock(args []Object, index int) *_testing.CoverBlock {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.CoverBlock:
			return &r
		case *_testing.CoverBlock:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.CoverBlock]"))
}

func _mapToCoverBlock(o Map) *_testing.CoverBlock {
	return &_testing.CoverBlock{}
}

func _vectorToCoverBlock(o *Vector) *_testing.CoverBlock {
	return &_testing.CoverBlock{
		Line0: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Col0: uint16(AssertInt(o.Nth(1), "").I),
		Line1: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
		Col1: uint16(AssertInt(o.Nth(3), "").I),
		Stmts: uint16(AssertInt(o.Nth(4), "").I),
	}
}

func _ConstructCoverBlock(_v Object) *_testing.CoverBlock {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.CoverBlock:
			return &_g
		case *_testing.CoverBlock:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToCoverBlock(_o.(Map))
	case *Vector:
		return _vectorToCoverBlock(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.CoverBlock] or: Map or Vector"))
}

GO TYPE testing.InternalBenchmark from testing/benchmark.go:
func ExtractGoObjectInternalBenchmark(args []Object, index int) *_testing.InternalBenchmark {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalBenchmark:
			return &r
		case *_testing.InternalBenchmark:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalBenchmark]"))
}

// func _mapToInternalBenchmark(o Map) *_testing.InternalBenchmark {
// 	return &_testing.InternalBenchmark{}
// }

// func _vectorToInternalBenchmark(o *Vector) *_testing.InternalBenchmark {
// 	return &_testing.InternalBenchmark{
// 		Name: AssertString(o.Nth(0), "").S,
// 		F: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructInternalBenchmark(_v Object) *_testing.InternalBenchmark {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.InternalBenchmark:
// 			return &_g
// 		case *_testing.InternalBenchmark:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInternalBenchmark(_o.(Map))
// 	case *Vector:
// 		return _vectorToInternalBenchmark(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalBenchmark] or: Map or Vector"))
// }

GO TYPE testing.InternalExample from testing/example.go:
func ExtractGoObjectInternalExample(args []Object, index int) *_testing.InternalExample {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalExample:
			return &r
		case *_testing.InternalExample:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalExample]"))
}

// func _mapToInternalExample(o Map) *_testing.InternalExample {
// 	return &_testing.InternalExample{}
// }

// func _vectorToInternalExample(o *Vector) *_testing.InternalExample {
// 	return &_testing.InternalExample{
// 		Name: AssertString(o.Nth(0), "").S,
// 		F: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Output: AssertString(o.Nth(2), "").S,
// 		Unordered: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructInternalExample(_v Object) *_testing.InternalExample {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.InternalExample:
// 			return &_g
// 		case *_testing.InternalExample:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInternalExample(_o.(Map))
// 	case *Vector:
// 		return _vectorToInternalExample(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalExample] or: Map or Vector"))
// }

GO TYPE testing.InternalTest from testing/testing.go:
func ExtractGoObjectInternalTest(args []Object, index int) *_testing.InternalTest {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.InternalTest:
			return &r
		case *_testing.InternalTest:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.InternalTest]"))
}

// func _mapToInternalTest(o Map) *_testing.InternalTest {
// 	return &_testing.InternalTest{}
// }

// func _vectorToInternalTest(o *Vector) *_testing.InternalTest {
// 	return &_testing.InternalTest{
// 		Name: AssertString(o.Nth(0), "").S,
// 		F: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructInternalTest(_v Object) *_testing.InternalTest {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.InternalTest:
// 			return &_g
// 		case *_testing.InternalTest:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInternalTest(_o.(Map))
// 	case *Vector:
// 		return _vectorToInternalTest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.InternalTest] or: Map or Vector"))
// }

GO TYPE testing.M from testing/testing.go:
func ExtractGoObjectM(args []Object, index int) *_testing.M {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.M:
			return &r
		case *_testing.M:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.M]"))
}

func _mapToM(o Map) *_testing.M {
	return &_testing.M{}
}

func _vectorToM(o *Vector) *_testing.M {
	return &_testing.M{}
}

func _ConstructM(_v Object) *_testing.M {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.M:
			return &_g
		case *_testing.M:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToM(_o.(Map))
	case *Vector:
		return _vectorToM(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.M] or: Map or Vector"))
}

GO TYPE testing.PB from testing/benchmark.go:
func ExtractGoObjectPB(args []Object, index int) *_testing.PB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.PB:
			return &r
		case *_testing.PB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.PB]"))
}

func _mapToPB(o Map) *_testing.PB {
	return &_testing.PB{}
}

func _vectorToPB(o *Vector) *_testing.PB {
	return &_testing.PB{}
}

func _ConstructPB(_v Object) *_testing.PB {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.PB:
			return &_g
		case *_testing.PB:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPB(_o.(Map))
	case *Vector:
		return _vectorToPB(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.PB] or: Map or Vector"))
}

GO TYPE testing.T from testing/testing.go:
func ExtractGoObjectT(args []Object, index int) *_testing.T {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.T:
			return &r
		case *_testing.T:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.T]"))
}

func _mapToT(o Map) *_testing.T {
	return &_testing.T{}
}

func _vectorToT(o *Vector) *_testing.T {
	return &_testing.T{}
}

func _ConstructT(_v Object) *_testing.T {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _testing.T:
			return &_g
		case *_testing.T:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToT(_o.(Map))
	case *Vector:
		return _vectorToT(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.T] or: Map or Vector"))
}

GO TYPE testing.TB from testing/testing.go:
func ExtractGoObjectTB(args []Object, index int) *_testing.TB {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _testing.TB:
			return &r
		case *_testing.TB:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing.TB]"))
}

// func _ConstructTB(_v Object) _testing.TB {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _testing.TB:
// 			return _g
// 		case *_testing.TB:
// 			return *_g
// 		}
// 	default:
// 		return _testing.TB(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for TB))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[testing.TB] or: whatever"))
// }

GO FUNC testing.AllocsPerRun from testing/allocs.go:
// func __allocsPerRun(runs int, f func) Object {
// 	_res := _testing.AllocsPerRun(runs, f)
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC testing.Benchmark from testing/benchmark.go:
// func __benchmark(f func) Object {
// 	_res := _testing.Benchmark(f)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.Coverage from testing/cover.go:
// func __coverage() Object {
// 	_res := _testing.Coverage()
// 	return ABEND043(post.go: unsupported built-in type float64)
// }

GO FUNC testing.Main from testing/testing.go:
// func __main(matchString func, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND675: TODO...
// }

GO FUNC testing.MainStart from testing/testing.go:
// func __mainStart(deps testDeps, tests []_testing.InternalTest, benchmarks []_testing.InternalBenchmark, examples []_testing.InternalExample) Object {
// 	_res := _testing.MainStart(deps, tests, benchmarks, examples)
// 	return MakeGoObject(_res)
// }

GO FUNC testing.RegisterCover from testing/cover.go:
// func __registerCover(c _testing.Cover) Object {
// 	_testing.RegisterCover(c)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunBenchmarks from testing/benchmark.go:
// func __runBenchmarks(matchString func, benchmarks []_testing.InternalBenchmark) Object {
// 	_testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunExamples from testing/example.go:
// func __runExamples(matchString func, examples []_testing.InternalExample)  {
// 	_res := _testing.RunExamples(matchString, examples)
// 	return MakeBoolean(_res)
// }

GO FUNC testing.RunTests from testing/testing.go:
// func __runTests(matchString func, tests []_testing.InternalTest)  {
// 	_res := _testing.RunTests(matchString, tests)
// 	return MakeBoolean(_res)
// }

GO FUNC testing.__benchmarkResult_AllocedBytesPerOp from testing/benchmark.go:
func __benchmarkResult_AllocedBytesPerOp(o GoObject, args Object) Object {
	CheckGoArity("(_testing.BenchmarkResult)AllocedBytesPerOp()", args, 0, 0)
	_res := o.O.(_testing.BenchmarkResult).AllocedBytesPerOp()
	return MakeBigInt(_res)
}

GO FUNC testing.__benchmarkResult_AllocsPerOp from testing/benchmark.go:
func __benchmarkResult_AllocsPerOp(o GoObject, args Object) Object {
	CheckGoArity("(_testing.BenchmarkResult)AllocsPerOp()", args, 0, 0)
	_res := o.O.(_testing.BenchmarkResult).AllocsPerOp()
	return MakeBigInt(_res)
}

GO FUNC testing.__benchmarkResult_MemString from testing/benchmark.go:
func __benchmarkResult_MemString(o GoObject, args Object) Object {
	CheckGoArity("(_testing.BenchmarkResult)MemString()", args, 0, 0)
	_res := o.O.(_testing.BenchmarkResult).MemString()
	return MakeString(_res)
}

GO FUNC testing.__benchmarkResult_NsPerOp from testing/benchmark.go:
func __benchmarkResult_NsPerOp(o GoObject, args Object) Object {
	CheckGoArity("(_testing.BenchmarkResult)NsPerOp()", args, 0, 0)
	_res := o.O.(_testing.BenchmarkResult).NsPerOp()
	return MakeBigInt(_res)
}

GO FUNC testing.__benchmarkResult_String from testing/benchmark.go:
func __benchmarkResult_String(o GoObject, args Object) Object {
	CheckGoArity("(_testing.BenchmarkResult)String()", args, 0, 0)
	_res := o.O.(_testing.BenchmarkResult).String()
	return MakeString(_res)
}

GO FUNC testing.__ptrTo_B_ReportAllocs from testing/benchmark.go:
// func __ptrTo_B_ReportAllocs(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_B_ResetTimer from testing/benchmark.go:
// func __ptrTo_B_ResetTimer(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_B_Run from testing/benchmark.go:
// func __ptrTo_B_Run(o GoObject, args Object) Object {
// (name, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC testing.__ptrTo_B_RunParallel from testing/benchmark.go:
// func __ptrTo_B_RunParallel(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC testing.__ptrTo_B_SetBytes from testing/benchmark.go:
// func __ptrTo_B_SetBytes(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_B_SetParallelism from testing/benchmark.go:
// func __ptrTo_B_SetParallelism(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_B_StartTimer from testing/benchmark.go:
// func __ptrTo_B_StartTimer(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_B_StopTimer from testing/benchmark.go:
// func __ptrTo_B_StopTimer(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_M_Run from testing/testing.go:
func __ptrTo_M_Run(o GoObject, args Object) Object {
	CheckGoArity("(*_testing.M)Run()", args, 0, 0)
	_res := o.O.(*_testing.M).Run()
	return MakeInt(_res)
}

GO FUNC testing.__ptrTo_PB_Next from testing/benchmark.go:
func __ptrTo_PB_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_testing.PB)Next()", args, 0, 0)
	_res := o.O.(*_testing.PB).Next()
	return MakeBoolean(_res)
}

GO FUNC testing.__ptrTo_T_Parallel from testing/testing.go:
// func __ptrTo_T_Parallel(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC testing.__ptrTo_T_Run from testing/testing.go:
// func __ptrTo_T_Run(o GoObject, args Object) Object {
// (name, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package testing

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_testing "testing"
)
var members_BenchmarkResult = GoTypeInfo{Members: GoMembers{
	"AllocedBytesPerOp": __benchmarkResult_AllocedBytesPerOp,
	"AllocsPerOp": __benchmarkResult_AllocsPerOp,
	"MemString": __benchmarkResult_MemString,
	"NsPerOp": __benchmarkResult_NsPerOp,
	"String": __benchmarkResult_String,
}}

var members_PtrTo_M = GoTypeInfo{Members: GoMembers{
	"Run": __ptrTo_M_Run,
}}

var members_PtrTo_PB = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_PB_Next,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_testing.BenchmarkResult)(nil)).Elem()] = &members_BenchmarkResult
	GoTypes[_reflect.TypeOf((*_testing.M)(nil))] = &members_PtrTo_M
	GoTypes[_reflect.TypeOf((*_testing.PB)(nil))] = &members_PtrTo_PB
}

GO FUNC testing/iotest.DataErrReader from testing/iotest/reader.go:
// func __dataErrReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.DataErrReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.HalfReader from testing/iotest/reader.go:
// func __halfReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.HalfReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewReadLogger from testing/iotest/logger.go:
// func __newReadLogger(prefix string, r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.NewReadLogger(prefix, r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.NewWriteLogger from testing/iotest/logger.go:
// func __newWriteLogger(prefix string, w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	_res := _iotest.NewWriteLogger(prefix, w)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.OneByteReader from testing/iotest/reader.go:
// func __oneByteReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.OneByteReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TimeoutReader from testing/iotest/reader.go:
// func __timeoutReader(r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _iotest.TimeoutReader(r)
// 	return MakeGoObject(_res)
// }

GO FUNC testing/iotest.TruncateWriter from testing/iotest/writer.go:
// func __truncateWriter(w ABEND987(genutils.go: imports not yet supported: io.Writer), n int64) Object {
// 	_res := _iotest.TruncateWriter(w, n)
// 	return MakeGoObject(_res)
// }

GO TYPE testing/quick.CheckEqualError from testing/quick/quick.go:
func ExtractGoObjectCheckEqualError(args []Object, index int) *_quick.CheckEqualError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quick.CheckEqualError:
			return &r
		case *_quick.CheckEqualError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing/quick.CheckEqualError]"))
}

// func _mapToCheckEqualError(o Map) *_quick.CheckEqualError {
// 	return &_quick.CheckEqualError{}
// }

// func _vectorToCheckEqualError(o *Vector) *_quick.CheckEqualError {
// 	return &_quick.CheckEqualError{
// 		Out1: []ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Out2: []ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructCheckEqualError(_v Object) *_quick.CheckEqualError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _quick.CheckEqualError:
// 			return &_g
// 		case *_quick.CheckEqualError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCheckEqualError(_o.(Map))
// 	case *Vector:
// 		return _vectorToCheckEqualError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[quick.CheckEqualError] or: Map or Vector"))
// }

GO TYPE testing/quick.CheckError from testing/quick/quick.go:
func ExtractGoObjectCheckError(args []Object, index int) *_quick.CheckError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quick.CheckError:
			return &r
		case *_quick.CheckError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing/quick.CheckError]"))
}

// func _mapToCheckError(o Map) *_quick.CheckError {
// 	return &_quick.CheckError{}
// }

// func _vectorToCheckError(o *Vector) *_quick.CheckError {
// 	return &_quick.CheckError{
// 		Count: AssertInt(o.Nth(0), "").I,
// 		In: []ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 	}
// }

// func _ConstructCheckError(_v Object) *_quick.CheckError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _quick.CheckError:
// 			return &_g
// 		case *_quick.CheckError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCheckError(_o.(Map))
// 	case *Vector:
// 		return _vectorToCheckError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[quick.CheckError] or: Map or Vector"))
// }

GO TYPE testing/quick.Config from testing/quick/quick.go:
func ExtractGoObjectConfig(args []Object, index int) *_quick.Config {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quick.Config:
			return &r
		case *_quick.Config:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing/quick.Config]"))
}

// func _mapToConfig(o Map) *_quick.Config {
// 	return &_quick.Config{}
// }

// func _vectorToConfig(o *Vector) *_quick.Config {
// 	return &_quick.Config{
// 		MaxCount: AssertInt(o.Nth(0), "").I,
// 		MaxCountScale: float64(AssertDouble(o.Nth(1), "").D),
// 		Rand: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Values: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructConfig(_v Object) *_quick.Config {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _quick.Config:
// 			return &_g
// 		case *_quick.Config:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[quick.Config] or: Map or Vector"))
// }

GO TYPE testing/quick.Generator from testing/quick/quick.go:
func ExtractGoObjectGenerator(args []Object, index int) *_quick.Generator {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quick.Generator:
			return &r
		case *_quick.Generator:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing/quick.Generator]"))
}

// func _ConstructGenerator(_v Object) _quick.Generator {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _quick.Generator:
// 			return _g
// 		case *_quick.Generator:
// 			return *_g
// 		}
// 	default:
// 		return _quick.Generator(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Generator))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[quick.Generator] or: whatever"))
// }

GO TYPE testing/quick.SetupError from testing/quick/quick.go:
func ExtractGoObjectSetupError(args []Object, index int) *_quick.SetupError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _quick.SetupError:
			return &r
		case *_quick.SetupError:
			return r
		}
	case String:
		v := _quick.SetupError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[testing/quick.SetupError]"))
}

func _ConstructSetupError(_v Object) _quick.SetupError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _quick.SetupError:
			return _g
		case *_quick.SetupError:
			return *_g
		}
	case String:
		return _quick.SetupError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[quick.SetupError] or: String"))
}

GO FUNC testing/quick.Check from testing/quick/quick.go:
// func __check(f interface {}, config *_quick.Config)  {
// 	_res := _quick.Check(f, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.CheckEqual from testing/quick/quick.go:
// func __checkEqual(f interface {}, g interface {}, config *_quick.Config)  {
// 	_res := _quick.CheckEqual(f, g, config)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC testing/quick.Value from testing/quick/quick.go:
// func __value(t ABEND987(genutils.go: imports not yet supported: reflect.Type), rand *ABEND987(genutils.go: imports not yet supported: rand.Rand)) Object {
// 	value, ok := _quick.Value(t, rand)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(value))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC testing/quick.__ptrTo_CheckEqualError_Error from testing/quick/quick.go:
func __ptrTo_CheckEqualError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_testing/quick.CheckEqualError)Error()", args, 0, 0)
	_res := o.O.(*_quick.CheckEqualError).Error()
	return MakeString(_res)
}

GO FUNC testing/quick.__ptrTo_CheckError_Error from testing/quick/quick.go:
func __ptrTo_CheckError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_testing/quick.CheckError)Error()", args, 0, 0)
	_res := o.O.(*_quick.CheckError).Error()
	return MakeString(_res)
}

GO FUNC testing/quick.__setupError_Error from testing/quick/quick.go:
func __setupError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_testing/quick.SetupError)Error()", args, 0, 0)
	_res := o.O.(_quick.SetupError).Error()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package quick

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_quick "testing/quick"
)
var members_PtrTo_CheckEqualError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_CheckEqualError_Error,
}}

var members_PtrTo_CheckError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_CheckError_Error,
}}

var members_SetupError = GoTypeInfo{Members: GoMembers{
	"Error": __setupError_Error,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_quick.CheckEqualError)(nil))] = &members_PtrTo_CheckEqualError
	GoTypes[_reflect.TypeOf((*_quick.CheckError)(nil))] = &members_PtrTo_CheckError
	GoTypes[_reflect.TypeOf((*_quick.SetupError)(nil)).Elem()] = &members_SetupError
}

GO TYPE text/scanner.Position from text/scanner/scanner.go:
func ExtractGoObjectPosition(args []Object, index int) *_scanner.Position {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.Position:
			return &r
		case *_scanner.Position:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/scanner.Position]"))
}

func _mapToPosition(o Map) *_scanner.Position {
	return &_scanner.Position{}
}

func _vectorToPosition(o *Vector) *_scanner.Position {
	return &_scanner.Position{
		Filename: AssertString(o.Nth(0), "").S,
		Offset: AssertInt(o.Nth(1), "").I,
		Line: AssertInt(o.Nth(2), "").I,
		Column: AssertInt(o.Nth(3), "").I,
	}
}

func _ConstructPosition(_v Object) *_scanner.Position {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _scanner.Position:
			return &_g
		case *_scanner.Position:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPosition(_o.(Map))
	case *Vector:
		return _vectorToPosition(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.Position] or: Map or Vector"))
}

GO TYPE text/scanner.Scanner from text/scanner/scanner.go:
func ExtractGoObjectScanner(args []Object, index int) *_scanner.Scanner {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _scanner.Scanner:
			return &r
		case *_scanner.Scanner:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/scanner.Scanner]"))
}

// func _mapToScanner(o Map) *_scanner.Scanner {
// 	return &_scanner.Scanner{}
// }

// func _vectorToScanner(o *Vector) *_scanner.Scanner {
// 	return &_scanner.Scanner{
// 		Error: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorCount: AssertInt(o.Nth(1), "").I,
// 		Mode: uint(AssertInt(o.Nth(2), "").I),
// 		Whitespace: AssertNumber(o.Nth(3), "").BigInt().Uint64(),
// 		IsIdentRune: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructScanner(_v Object) *_scanner.Scanner {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _scanner.Scanner:
// 			return &_g
// 		case *_scanner.Scanner:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToScanner(_o.(Map))
// 	case *Vector:
// 		return _vectorToScanner(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[scanner.Scanner] or: Map or Vector"))
// }

GO FUNC text/scanner.__position_String from text/scanner/scanner.go:
func __position_String(o GoObject, args Object) Object {
	CheckGoArity("(_text/scanner.Position)String()", args, 0, 0)
	_res := o.O.(_scanner.Position).String()
	return MakeString(_res)
}

GO FUNC text/scanner.__ptrTo_Position_IsValid from text/scanner/scanner.go:
func __ptrTo_Position_IsValid(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Position)IsValid()", args, 0, 0)
	_res := o.O.(*_scanner.Position).IsValid()
	return MakeBoolean(_res)
}

GO FUNC text/scanner.__ptrTo_Scanner_Init from text/scanner/scanner.go:
// func __ptrTo_Scanner_Init(o GoObject, args Object) Object {
// src ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC text/scanner.__ptrTo_Scanner_Next from text/scanner/scanner.go:
func __ptrTo_Scanner_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Scanner)Next()", args, 0, 0)
	_res := o.O.(*_scanner.Scanner).Next()
	return MakeChar(_res)
}

GO FUNC text/scanner.__ptrTo_Scanner_Peek from text/scanner/scanner.go:
func __ptrTo_Scanner_Peek(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Scanner)Peek()", args, 0, 0)
	_res := o.O.(*_scanner.Scanner).Peek()
	return MakeChar(_res)
}

GO FUNC text/scanner.__ptrTo_Scanner_Pos from text/scanner/scanner.go:
func __ptrTo_Scanner_Pos(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Scanner)Pos()", args, 0, 0)
	_res := o.O.(*_scanner.Scanner).Pos()
	return MakeGoObject(_res)
}

GO FUNC text/scanner.__ptrTo_Scanner_Scan from text/scanner/scanner.go:
func __ptrTo_Scanner_Scan(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Scanner)Scan()", args, 0, 0)
	_res := o.O.(*_scanner.Scanner).Scan()
	return MakeChar(_res)
}

GO FUNC text/scanner.__ptrTo_Scanner_TokenText from text/scanner/scanner.go:
func __ptrTo_Scanner_TokenText(o GoObject, args Object) Object {
	CheckGoArity("(*_text/scanner.Scanner)TokenText()", args, 0, 0)
	_res := o.O.(*_scanner.Scanner).TokenText()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package scanner

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_scanner "text/scanner"
)
var members_PtrTo_Position = GoTypeInfo{Members: GoMembers{
	"IsValid": __ptrTo_Position_IsValid,
}}

var members_Position = GoTypeInfo{Members: GoMembers{
	"String": __position_String,
}}

var members_PtrTo_Scanner = GoTypeInfo{Members: GoMembers{
	"Next": __ptrTo_Scanner_Next,
	"Peek": __ptrTo_Scanner_Peek,
	"Pos": __ptrTo_Scanner_Pos,
	"Scan": __ptrTo_Scanner_Scan,
	"TokenText": __ptrTo_Scanner_TokenText,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_scanner.Position)(nil))] = &members_PtrTo_Position
	GoTypes[_reflect.TypeOf((*_scanner.Position)(nil)).Elem()] = &members_Position
	GoTypes[_reflect.TypeOf((*_scanner.Scanner)(nil))] = &members_PtrTo_Scanner
}

GO TYPE text/tabwriter.Writer from text/tabwriter/tabwriter.go:
func ExtractGoObjectWriter(args []Object, index int) *_tabwriter.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _tabwriter.Writer:
			return &r
		case *_tabwriter.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/tabwriter.Writer]"))
}

func _mapToWriter(o Map) *_tabwriter.Writer {
	return &_tabwriter.Writer{}
}

func _vectorToWriter(o *Vector) *_tabwriter.Writer {
	return &_tabwriter.Writer{}
}

func _ConstructWriter(_v Object) *_tabwriter.Writer {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _tabwriter.Writer:
			return &_g
		case *_tabwriter.Writer:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWriter(_o.(Map))
	case *Vector:
		return _vectorToWriter(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[tabwriter.Writer] or: Map or Vector"))
}

GO FUNC text/tabwriter.NewWriter from text/tabwriter/tabwriter.go:
// func __newWriter(output ABEND987(genutils.go: imports not yet supported: io.Writer), minwidth int, tabwidth int, padding int, padchar byte, flags uint) Object {
// 	_res := _tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	return MakeGoObject(_res)
// }

GO FUNC text/tabwriter.__ptrTo_Writer_Flush from text/tabwriter/tabwriter.go:
func __ptrTo_Writer_Flush(o GoObject, args Object) Object {
	CheckGoArity("(*_text/tabwriter.Writer)Flush()", args, 0, 0)
	_res := o.O.(*_tabwriter.Writer).Flush()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC text/tabwriter.__ptrTo_Writer_Init from text/tabwriter/tabwriter.go:
// func __ptrTo_Writer_Init(o GoObject, args Object) Object {
// output ABEND987(genutils.go: imports not yet supported: io.Writer), minwidth int, tabwidth int, padding int, padchar byte, flags uint}

GO FUNC text/tabwriter.__ptrTo_Writer_Write from text/tabwriter/tabwriter.go:
// func __ptrTo_Writer_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(buf)))}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package tabwriter

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_tabwriter "text/tabwriter"
)
var members_PtrTo_Writer = GoTypeInfo{Members: GoMembers{
	"Flush": __ptrTo_Writer_Flush,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_tabwriter.Writer)(nil))] = &members_PtrTo_Writer
}

GO TYPE text/template.ExecError from text/template/exec.go:
func ExtractGoObjectExecError(args []Object, index int) *_template.ExecError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.ExecError:
			return &r
		case *_template.ExecError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.ExecError]"))
}

func _mapToExecError(o Map) *_template.ExecError {
	return &_template.ExecError{}
}

func _vectorToExecError(o *Vector) *_template.ExecError {
	return &_template.ExecError{
		Name: AssertString(o.Nth(0), "").S,
		Err: _errors.New(AssertString(o.Nth(1), "").S),
	}
}

func _ConstructExecError(_v Object) *_template.ExecError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.ExecError:
			return &_g
		case *_template.ExecError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToExecError(_o.(Map))
	case *Vector:
		return _vectorToExecError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.ExecError] or: Map or Vector"))
}

GO TYPE text/template.FuncMap from text/template/funcs.go:
func ExtractGoObjectFuncMap(args []Object, index int) *_template.FuncMap {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.FuncMap:
			return &r
		case *_template.FuncMap:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.FuncMap]"))
}

// func _ConstructFuncMap(_v Object) _template.FuncMap {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _template.FuncMap:
// 			return _g
// 		case *_template.FuncMap:
// 			return *_g
// 		}
// 	default:
// 		return _template.FuncMap(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for FuncMap))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[template.FuncMap] or: whatever"))
// }

GO TYPE text/template.Template from text/template/template.go:
func ExtractGoObjectTemplate(args []Object, index int) *_template.Template {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _template.Template:
			return &r
		case *_template.Template:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template.Template]"))
}

func _mapToTemplate(o Map) *_template.Template {
	return &_template.Template{}
}

func _vectorToTemplate(o *Vector) *_template.Template {
	return &_template.Template{}
}

func _ConstructTemplate(_v Object) *_template.Template {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _template.Template:
			return &_g
		case *_template.Template:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTemplate(_o.(Map))
	case *Vector:
		return _vectorToTemplate(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[template.Template] or: Map or Vector"))
}

GO FUNC text/template.HTMLEscape from text/template/funcs.go:
// func __hTMLEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.HTMLEscaper from text/template/funcs.go:
// func __hTMLEscaper(args ...interface {})  {
// 	_res := _template.HTMLEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.IsTrue from text/template/exec.go:
// func __isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeBoolean(truth))
// 	_res = _res.Conjoin(MakeBoolean(ok))
// 	return _res
// }

GO FUNC text/template.JSEscape from text/template/funcs.go:
// func __jSEscape(w ABEND987(genutils.go: imports not yet supported: io.Writer), b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.JSEscaper from text/template/funcs.go:
// func __jSEscaper(args ...interface {})  {
// 	_res := _template.JSEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.Must from text/template/helper.go:
func __must(t *_template.Template, err error) Object {
	_res := _template.Must(t, err)
	return MakeGoObject(_res)
}

GO FUNC text/template.New from text/template/template.go:
func __new(name string) Object {
	_res := _template.New(name)
	return MakeGoObject(_res)
}

GO FUNC text/template.ParseFiles from text/template/helper.go:
// func __parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC text/template.ParseGlob from text/template/helper.go:
func __parseGlob(pattern string) Object {
	_res1, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.URLQueryEscaper from text/template/funcs.go:
// func __uRLQueryEscaper(args ...interface {})  {
// 	_res := _template.URLQueryEscaper(args)
// 	return MakeString(_res)
// }

GO FUNC text/template.__execError_Error from text/template/exec.go:
func __execError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_text/template.ExecError)Error()", args, 0, 0)
	_res := o.O.(_template.ExecError).Error()
	return MakeString(_res)
}

GO FUNC text/template.__ptrTo_Template_AddParseTree from text/template/template.go:
// func __ptrTo_Template_AddParseTree(o GoObject, args Object) Object {
// name string, tree *ABEND987(genutils.go: imports not yet supported: parse.Tree)}

GO FUNC text/template.__ptrTo_Template_Clone from text/template/template.go:
func __ptrTo_Template_Clone(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template.Template)Clone()", args, 0, 0)
	_res1, _res2 := o.O.(*_template.Template).Clone()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.__ptrTo_Template_DefinedTemplates from text/template/exec.go:
func __ptrTo_Template_DefinedTemplates(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template.Template)DefinedTemplates()", args, 0, 0)
	_res := o.O.(*_template.Template).DefinedTemplates()
	return MakeString(_res)
}

GO FUNC text/template.__ptrTo_Template_Delims from text/template/template.go:
func __ptrTo_Template_Delims(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)Delims()", args, 2, 2)
	left := ExtractGoString("(*_text/template.Template)Delims()", "left", _argList, 0)
	right := ExtractGoString("(*_text/template.Template)Delims()", "right", _argList, 1)
	_res := o.O.(*_template.Template).Delims(left, right)
	return MakeGoObject(_res)
}

GO FUNC text/template.__ptrTo_Template_Execute from text/template/exec.go:
// func __ptrTo_Template_Execute(o GoObject, args Object) Object {
// wr ABEND987(genutils.go: imports not yet supported: io.Writer), data interface {}}

GO FUNC text/template.__ptrTo_Template_ExecuteTemplate from text/template/exec.go:
// func __ptrTo_Template_ExecuteTemplate(o GoObject, args Object) Object {
// wr ABEND987(genutils.go: imports not yet supported: io.Writer), name string, data interface {}}

GO FUNC text/template.__ptrTo_Template_Funcs from text/template/template.go:
func __ptrTo_Template_Funcs(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)Funcs()", args, 1, 1)
	funcMap := ExtractGo_go_std_text_template__FuncMap("(*_text/template.Template)Funcs()", "funcMap", _argList, 0)
	_res := o.O.(*_template.Template).Funcs(funcMap)
	return MakeGoObject(_res)
}

GO FUNC text/template.__ptrTo_Template_Lookup from text/template/template.go:
func __ptrTo_Template_Lookup(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)Lookup()", args, 1, 1)
	name := ExtractGoString("(*_text/template.Template)Lookup()", "name", _argList, 0)
	_res := o.O.(*_template.Template).Lookup(name)
	return MakeGoObject(_res)
}

GO FUNC text/template.__ptrTo_Template_Name from text/template/template.go:
func __ptrTo_Template_Name(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template.Template)Name()", args, 0, 0)
	_res := o.O.(*_template.Template).Name()
	return MakeString(_res)
}

GO FUNC text/template.__ptrTo_Template_New from text/template/template.go:
func __ptrTo_Template_New(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)New()", args, 1, 1)
	name := ExtractGoString("(*_text/template.Template)New()", "name", _argList, 0)
	_res := o.O.(*_template.Template).New(name)
	return MakeGoObject(_res)
}

GO FUNC text/template.__ptrTo_Template_Option from text/template/option.go:
// func __ptrTo_Template_Option(o GoObject, args Object) Object {
// (ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(opt)))}

GO FUNC text/template.__ptrTo_Template_Parse from text/template/template.go:
func __ptrTo_Template_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)Parse()", args, 1, 1)
	text := ExtractGoString("(*_text/template.Template)Parse()", "text", _argList, 0)
	_res1, _res2 := o.O.(*_template.Template).Parse(text)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.__ptrTo_Template_ParseFiles from text/template/helper.go:
// func __ptrTo_Template_ParseFiles(o GoObject, args Object) Object {
// (ABEND905(pre.go: custom-runtime routine not implemented: ConvertToEllipsisHaHastring(filenames)))}

GO FUNC text/template.__ptrTo_Template_ParseGlob from text/template/helper.go:
func __ptrTo_Template_ParseGlob(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template.Template)ParseGlob()", args, 1, 1)
	pattern := ExtractGoString("(*_text/template.Template)ParseGlob()", "pattern", _argList, 0)
	_res1, _res2 := o.O.(*_template.Template).ParseGlob(pattern)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template.__ptrTo_Template_Templates from text/template/template.go:
func __ptrTo_Template_Templates(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template.Template)Templates()", args, 0, 0)
	_res := o.O.(*_template.Template).Templates()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package template

import (
	_errors "errors"
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_template "text/template"
)
var members_ExecError = GoTypeInfo{Members: GoMembers{
	"Error": __execError_Error,
}}

var members_PtrTo_Template = GoTypeInfo{Members: GoMembers{
	"Clone": __ptrTo_Template_Clone,
	"DefinedTemplates": __ptrTo_Template_DefinedTemplates,
	"Delims": __ptrTo_Template_Delims,
	"Funcs": __ptrTo_Template_Funcs,
	"Lookup": __ptrTo_Template_Lookup,
	"Name": __ptrTo_Template_Name,
	"New": __ptrTo_Template_New,
	"Parse": __ptrTo_Template_Parse,
	"ParseGlob": __ptrTo_Template_ParseGlob,
	"Templates": __ptrTo_Template_Templates,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_template.ExecError)(nil)).Elem()] = &members_ExecError
	GoTypes[_reflect.TypeOf((*_template.Template)(nil))] = &members_PtrTo_Template
}

GO TYPE text/template/parse.ActionNode from text/template/parse/node.go:
func ExtractGoObjectActionNode(args []Object, index int) *_parse.ActionNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ActionNode:
			return &r
		case *_parse.ActionNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ActionNode]"))
}

// func _mapToActionNode(o Map) *_parse.ActionNode {
// 	return &_parse.ActionNode{}
// }

// func _vectorToActionNode(o *Vector) *_parse.ActionNode {
// 	return &_parse.ActionNode{
// 		Line: AssertInt(o.Nth(0), "").I,
// 		Pipe: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.PipeNode (text/template/parse.PipeNode)),
// 	}
// }

// func _ConstructActionNode(_v Object) *_parse.ActionNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.ActionNode:
// 			return &_g
// 		case *_parse.ActionNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToActionNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToActionNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ActionNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.BoolNode from text/template/parse/node.go:
func ExtractGoObjectBoolNode(args []Object, index int) *_parse.BoolNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.BoolNode:
			return &r
		case *_parse.BoolNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.BoolNode]"))
}

func _mapToBoolNode(o Map) *_parse.BoolNode {
	return &_parse.BoolNode{}
}

func _vectorToBoolNode(o *Vector) *_parse.BoolNode {
	return &_parse.BoolNode{
		True: ToBool(o.Nth(0)),
	}
}

func _ConstructBoolNode(_v Object) *_parse.BoolNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.BoolNode:
			return &_g
		case *_parse.BoolNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToBoolNode(_o.(Map))
	case *Vector:
		return _vectorToBoolNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.BoolNode] or: Map or Vector"))
}

GO TYPE text/template/parse.BranchNode from text/template/parse/node.go:
func ExtractGoObjectBranchNode(args []Object, index int) *_parse.BranchNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.BranchNode:
			return &r
		case *_parse.BranchNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.BranchNode]"))
}

// func _mapToBranchNode(o Map) *_parse.BranchNode {
// 	return &_parse.BranchNode{}
// }

// func _vectorToBranchNode(o *Vector) *_parse.BranchNode {
// 	return &_parse.BranchNode{
// 		Line: AssertInt(o.Nth(0), "").I,
// 		Pipe: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.PipeNode (text/template/parse.PipeNode)),
// 		List: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.ListNode (text/template/parse.ListNode)),
// 		ElseList: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.ListNode (text/template/parse.ListNode)),
// 	}
// }

// func _ConstructBranchNode(_v Object) *_parse.BranchNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.BranchNode:
// 			return &_g
// 		case *_parse.BranchNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToBranchNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToBranchNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.BranchNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.ChainNode from text/template/parse/node.go:
func ExtractGoObjectChainNode(args []Object, index int) *_parse.ChainNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ChainNode:
			return &r
		case *_parse.ChainNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ChainNode]"))
}

// func _mapToChainNode(o Map) *_parse.ChainNode {
// 	return &_parse.ChainNode{}
// }

// func _vectorToChainNode(o *Vector) *_parse.ChainNode {
// 	return &_parse.ChainNode{
// 		Node: ABEND048(codegen.go: no conversion from Clojure for text/template/parse.Node (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Field: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructChainNode(_v Object) *_parse.ChainNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.ChainNode:
// 			return &_g
// 		case *_parse.ChainNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToChainNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToChainNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ChainNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.CommandNode from text/template/parse/node.go:
func ExtractGoObjectCommandNode(args []Object, index int) *_parse.CommandNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.CommandNode:
			return &r
		case *_parse.CommandNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.CommandNode]"))
}

// func _mapToCommandNode(o Map) *_parse.CommandNode {
// 	return &_parse.CommandNode{}
// }

// func _vectorToCommandNode(o *Vector) *_parse.CommandNode {
// 	return &_parse.CommandNode{
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []text/template/parse.Node (text/template/parse.Node)),
// 	}
// }

// func _ConstructCommandNode(_v Object) *_parse.CommandNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.CommandNode:
// 			return &_g
// 		case *_parse.CommandNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCommandNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToCommandNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.CommandNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.DotNode from text/template/parse/node.go:
func ExtractGoObjectDotNode(args []Object, index int) *_parse.DotNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.DotNode:
			return &r
		case *_parse.DotNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.DotNode]"))
}

func _mapToDotNode(o Map) *_parse.DotNode {
	return &_parse.DotNode{}
}

func _vectorToDotNode(o *Vector) *_parse.DotNode {
	return &_parse.DotNode{}
}

func _ConstructDotNode(_v Object) *_parse.DotNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.DotNode:
			return &_g
		case *_parse.DotNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDotNode(_o.(Map))
	case *Vector:
		return _vectorToDotNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.DotNode] or: Map or Vector"))
}

GO TYPE text/template/parse.FieldNode from text/template/parse/node.go:
func ExtractGoObjectFieldNode(args []Object, index int) *_parse.FieldNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.FieldNode:
			return &r
		case *_parse.FieldNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.FieldNode]"))
}

// func _mapToFieldNode(o Map) *_parse.FieldNode {
// 	return &_parse.FieldNode{}
// }

// func _vectorToFieldNode(o *Vector) *_parse.FieldNode {
// 	return &_parse.FieldNode{
// 		Ident: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructFieldNode(_v Object) *_parse.FieldNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.FieldNode:
// 			return &_g
// 		case *_parse.FieldNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToFieldNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToFieldNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.FieldNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.IdentifierNode from text/template/parse/node.go:
func ExtractGoObjectIdentifierNode(args []Object, index int) *_parse.IdentifierNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.IdentifierNode:
			return &r
		case *_parse.IdentifierNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.IdentifierNode]"))
}

func _mapToIdentifierNode(o Map) *_parse.IdentifierNode {
	return &_parse.IdentifierNode{}
}

func _vectorToIdentifierNode(o *Vector) *_parse.IdentifierNode {
	return &_parse.IdentifierNode{
		Ident: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructIdentifierNode(_v Object) *_parse.IdentifierNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.IdentifierNode:
			return &_g
		case *_parse.IdentifierNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIdentifierNode(_o.(Map))
	case *Vector:
		return _vectorToIdentifierNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.IdentifierNode] or: Map or Vector"))
}

GO TYPE text/template/parse.IfNode from text/template/parse/node.go:
func ExtractGoObjectIfNode(args []Object, index int) *_parse.IfNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.IfNode:
			return &r
		case *_parse.IfNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.IfNode]"))
}

func _mapToIfNode(o Map) *_parse.IfNode {
	return &_parse.IfNode{}
}

func _vectorToIfNode(o *Vector) *_parse.IfNode {
	return &_parse.IfNode{}
}

func _ConstructIfNode(_v Object) *_parse.IfNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.IfNode:
			return &_g
		case *_parse.IfNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIfNode(_o.(Map))
	case *Vector:
		return _vectorToIfNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.IfNode] or: Map or Vector"))
}

GO TYPE text/template/parse.ListNode from text/template/parse/node.go:
func ExtractGoObjectListNode(args []Object, index int) *_parse.ListNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.ListNode:
			return &r
		case *_parse.ListNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.ListNode]"))
}

// func _mapToListNode(o Map) *_parse.ListNode {
// 	return &_parse.ListNode{}
// }

// func _vectorToListNode(o *Vector) *_parse.ListNode {
// 	return &_parse.ListNode{
// 		Nodes: ABEND048(codegen.go: no conversion from Clojure for []text/template/parse.Node (text/template/parse.Node)),
// 	}
// }

// func _ConstructListNode(_v Object) *_parse.ListNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.ListNode:
// 			return &_g
// 		case *_parse.ListNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToListNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToListNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.ListNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.NilNode from text/template/parse/node.go:
func ExtractGoObjectNilNode(args []Object, index int) *_parse.NilNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NilNode:
			return &r
		case *_parse.NilNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NilNode]"))
}

func _mapToNilNode(o Map) *_parse.NilNode {
	return &_parse.NilNode{}
}

func _vectorToNilNode(o *Vector) *_parse.NilNode {
	return &_parse.NilNode{}
}

func _ConstructNilNode(_v Object) *_parse.NilNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.NilNode:
			return &_g
		case *_parse.NilNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNilNode(_o.(Map))
	case *Vector:
		return _vectorToNilNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NilNode] or: Map or Vector"))
}

GO TYPE text/template/parse.Node from text/template/parse/node.go:
func ExtractGoObjectNode(args []Object, index int) *_parse.Node {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Node:
			return &r
		case *_parse.Node:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Node]"))
}

// func _ConstructNode(_v Object) _parse.Node {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.Node:
// 			return _g
// 		case *_parse.Node:
// 			return *_g
// 		}
// 	default:
// 		return _parse.Node(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Node))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Node] or: whatever"))
// }

GO TYPE text/template/parse.NodeType from text/template/parse/node.go:
func ExtractGoObjectNodeType(args []Object, index int) *_parse.NodeType {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NodeType:
			return &r
		case *_parse.NodeType:
			return r
		}
	case Int:
		v := _parse.NodeType(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NodeType]"))
}

func _ConstructNodeType(_v Object) _parse.NodeType {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.NodeType:
			return _g
		case *_parse.NodeType:
			return *_g
		}
	case Number:
		return _parse.NodeType(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NodeType] or: Number"))
}

GO TYPE text/template/parse.NumberNode from text/template/parse/node.go:
func ExtractGoObjectNumberNode(args []Object, index int) *_parse.NumberNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.NumberNode:
			return &r
		case *_parse.NumberNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.NumberNode]"))
}

// func _mapToNumberNode(o Map) *_parse.NumberNode {
// 	return &_parse.NumberNode{}
// }

// func _vectorToNumberNode(o *Vector) *_parse.NumberNode {
// 	return &_parse.NumberNode{
// 		IsInt: ToBool(o.Nth(0)),
// 		IsUint: ToBool(o.Nth(1)),
// 		IsFloat: ToBool(o.Nth(2)),
// 		IsComplex: ToBool(o.Nth(3)),
// 		Int64: AssertNumber(o.Nth(4), "").BigInt().Int64(),
// 		Uint64: AssertNumber(o.Nth(5), "").BigInt().Uint64(),
// 		Float64: float64(AssertDouble(o.Nth(6), "").D),
// 		Complex128: ABEND048(codegen.go: no conversion from Clojure for complex128 (-)),
// 		Text: AssertString(o.Nth(8), "").S,
// 	}
// }

// func _ConstructNumberNode(_v Object) *_parse.NumberNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.NumberNode:
// 			return &_g
// 		case *_parse.NumberNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToNumberNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToNumberNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.NumberNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.PipeNode from text/template/parse/node.go:
func ExtractGoObjectPipeNode(args []Object, index int) *_parse.PipeNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.PipeNode:
			return &r
		case *_parse.PipeNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.PipeNode]"))
}

// func _mapToPipeNode(o Map) *_parse.PipeNode {
// 	return &_parse.PipeNode{}
// }

// func _vectorToPipeNode(o *Vector) *_parse.PipeNode {
// 	return &_parse.PipeNode{
// 		Line: AssertInt(o.Nth(0), "").I,
// 		IsAssign: ToBool(o.Nth(1)),
// 		Decl: ABEND048(codegen.go: no conversion from Clojure for []*text/template/parse.VariableNode (*text/template/parse.VariableNode)),
// 		Cmds: ABEND048(codegen.go: no conversion from Clojure for []*text/template/parse.CommandNode (*text/template/parse.CommandNode)),
// 	}
// }

// func _ConstructPipeNode(_v Object) *_parse.PipeNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.PipeNode:
// 			return &_g
// 		case *_parse.PipeNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPipeNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToPipeNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.PipeNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.Pos from text/template/parse/node.go:
func ExtractGoObjectPos(args []Object, index int) *_parse.Pos {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Pos:
			return &r
		case *_parse.Pos:
			return r
		}
	case Int:
		v := _parse.Pos(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Pos]"))
}

func _ConstructPos(_v Object) _parse.Pos {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.Pos:
			return _g
		case *_parse.Pos:
			return *_g
		}
	case Number:
		return _parse.Pos(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Pos] or: Number"))
}

GO TYPE text/template/parse.RangeNode from text/template/parse/node.go:
func ExtractGoObjectRangeNode(args []Object, index int) *_parse.RangeNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.RangeNode:
			return &r
		case *_parse.RangeNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.RangeNode]"))
}

func _mapToRangeNode(o Map) *_parse.RangeNode {
	return &_parse.RangeNode{}
}

func _vectorToRangeNode(o *Vector) *_parse.RangeNode {
	return &_parse.RangeNode{}
}

func _ConstructRangeNode(_v Object) *_parse.RangeNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.RangeNode:
			return &_g
		case *_parse.RangeNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRangeNode(_o.(Map))
	case *Vector:
		return _vectorToRangeNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.RangeNode] or: Map or Vector"))
}

GO TYPE text/template/parse.StringNode from text/template/parse/node.go:
func ExtractGoObjectStringNode(args []Object, index int) *_parse.StringNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.StringNode:
			return &r
		case *_parse.StringNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.StringNode]"))
}

func _mapToStringNode(o Map) *_parse.StringNode {
	return &_parse.StringNode{}
}

func _vectorToStringNode(o *Vector) *_parse.StringNode {
	return &_parse.StringNode{
		Quoted: AssertString(o.Nth(0), "").S,
		Text: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructStringNode(_v Object) *_parse.StringNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.StringNode:
			return &_g
		case *_parse.StringNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToStringNode(_o.(Map))
	case *Vector:
		return _vectorToStringNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.StringNode] or: Map or Vector"))
}

GO TYPE text/template/parse.TemplateNode from text/template/parse/node.go:
func ExtractGoObjectTemplateNode(args []Object, index int) *_parse.TemplateNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.TemplateNode:
			return &r
		case *_parse.TemplateNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.TemplateNode]"))
}

// func _mapToTemplateNode(o Map) *_parse.TemplateNode {
// 	return &_parse.TemplateNode{}
// }

// func _vectorToTemplateNode(o *Vector) *_parse.TemplateNode {
// 	return &_parse.TemplateNode{
// 		Line: AssertInt(o.Nth(0), "").I,
// 		Name: AssertString(o.Nth(1), "").S,
// 		Pipe: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.PipeNode (text/template/parse.PipeNode)),
// 	}
// }

// func _ConstructTemplateNode(_v Object) *_parse.TemplateNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.TemplateNode:
// 			return &_g
// 		case *_parse.TemplateNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTemplateNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToTemplateNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.TemplateNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.TextNode from text/template/parse/node.go:
func ExtractGoObjectTextNode(args []Object, index int) *_parse.TextNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.TextNode:
			return &r
		case *_parse.TextNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.TextNode]"))
}

// func _mapToTextNode(o Map) *_parse.TextNode {
// 	return &_parse.TextNode{}
// }

// func _vectorToTextNode(o *Vector) *_parse.TextNode {
// 	return &_parse.TextNode{
// 		Text: ABEND048(codegen.go: no conversion from Clojure for []byte (byte)),
// 	}
// }

// func _ConstructTextNode(_v Object) *_parse.TextNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.TextNode:
// 			return &_g
// 		case *_parse.TextNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTextNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToTextNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.TextNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.Tree from text/template/parse/parse.go:
func ExtractGoObjectTree(args []Object, index int) *_parse.Tree {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.Tree:
			return &r
		case *_parse.Tree:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.Tree]"))
}

// func _mapToTree(o Map) *_parse.Tree {
// 	return &_parse.Tree{}
// }

// func _vectorToTree(o *Vector) *_parse.Tree {
// 	return &_parse.Tree{
// 		Name: AssertString(o.Nth(0), "").S,
// 		ParseName: AssertString(o.Nth(1), "").S,
// 		Root: ABEND048(codegen.go: no conversion from Clojure for *text/template/parse.ListNode (text/template/parse.ListNode)),
// 	}
// }

// func _ConstructTree(_v Object) *_parse.Tree {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.Tree:
// 			return &_g
// 		case *_parse.Tree:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTree(_o.(Map))
// 	case *Vector:
// 		return _vectorToTree(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.Tree] or: Map or Vector"))
// }

GO TYPE text/template/parse.VariableNode from text/template/parse/node.go:
func ExtractGoObjectVariableNode(args []Object, index int) *_parse.VariableNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.VariableNode:
			return &r
		case *_parse.VariableNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.VariableNode]"))
}

// func _mapToVariableNode(o Map) *_parse.VariableNode {
// 	return &_parse.VariableNode{}
// }

// func _vectorToVariableNode(o *Vector) *_parse.VariableNode {
// 	return &_parse.VariableNode{
// 		Ident: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructVariableNode(_v Object) *_parse.VariableNode {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _parse.VariableNode:
// 			return &_g
// 		case *_parse.VariableNode:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToVariableNode(_o.(Map))
// 	case *Vector:
// 		return _vectorToVariableNode(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.VariableNode] or: Map or Vector"))
// }

GO TYPE text/template/parse.WithNode from text/template/parse/node.go:
func ExtractGoObjectWithNode(args []Object, index int) *_parse.WithNode {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _parse.WithNode:
			return &r
		case *_parse.WithNode:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[text/template/parse.WithNode]"))
}

func _mapToWithNode(o Map) *_parse.WithNode {
	return &_parse.WithNode{}
}

func _vectorToWithNode(o *Vector) *_parse.WithNode {
	return &_parse.WithNode{}
}

func _ConstructWithNode(_v Object) *_parse.WithNode {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _parse.WithNode:
			return &_g
		case *_parse.WithNode:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWithNode(_o.(Map))
	case *Vector:
		return _vectorToWithNode(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[parse.WithNode] or: Map or Vector"))
}

GO FUNC text/template/parse.New from text/template/parse/parse.go:
// func __new(name string, funcs ...map[]) Object {
// 	_res := _parse.New(name, funcs)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template/parse.NewIdentifier from text/template/parse/node.go:
func __newIdentifier(ident string) Object {
	_res := _parse.NewIdentifier(ident)
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.Parse from text/template/parse/parse.go:
// func __parse(name string, text string, leftDelim string, rightDelim string, funcs ...map[]) Object {
// 	_res1, _res2 := _parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC text/template/parse.__nodeType_Type from text/template/parse/node.go:
func __nodeType_Type(o GoObject, args Object) Object {
	CheckGoArity("(_text/template/parse.NodeType)Type()", args, 0, 0)
	_res := o.O.(_parse.NodeType).Type()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__pos_Position from text/template/parse/node.go:
func __pos_Position(o GoObject, args Object) Object {
	CheckGoArity("(_text/template/parse.Pos)Position()", args, 0, 0)
	_res := o.O.(_parse.Pos).Position()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ActionNode_Copy from text/template/parse/node.go:
func __ptrTo_ActionNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ActionNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.ActionNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ActionNode_String from text/template/parse/node.go:
func __ptrTo_ActionNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ActionNode)String()", args, 0, 0)
	_res := o.O.(*_parse.ActionNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_BoolNode_Copy from text/template/parse/node.go:
func __ptrTo_BoolNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.BoolNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.BoolNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_BoolNode_String from text/template/parse/node.go:
func __ptrTo_BoolNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.BoolNode)String()", args, 0, 0)
	_res := o.O.(*_parse.BoolNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_BranchNode_Copy from text/template/parse/node.go:
func __ptrTo_BranchNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.BranchNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.BranchNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_BranchNode_String from text/template/parse/node.go:
func __ptrTo_BranchNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.BranchNode)String()", args, 0, 0)
	_res := o.O.(*_parse.BranchNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_ChainNode_Add from text/template/parse/node.go:
// func __ptrTo_ChainNode_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC text/template/parse.__ptrTo_ChainNode_Copy from text/template/parse/node.go:
func __ptrTo_ChainNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ChainNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.ChainNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ChainNode_String from text/template/parse/node.go:
func __ptrTo_ChainNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ChainNode)String()", args, 0, 0)
	_res := o.O.(*_parse.ChainNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_CommandNode_Copy from text/template/parse/node.go:
func __ptrTo_CommandNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.CommandNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.CommandNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_CommandNode_String from text/template/parse/node.go:
func __ptrTo_CommandNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.CommandNode)String()", args, 0, 0)
	_res := o.O.(*_parse.CommandNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_DotNode_Copy from text/template/parse/node.go:
func __ptrTo_DotNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.DotNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.DotNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_DotNode_String from text/template/parse/node.go:
func __ptrTo_DotNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.DotNode)String()", args, 0, 0)
	_res := o.O.(*_parse.DotNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_DotNode_Type from text/template/parse/node.go:
func __ptrTo_DotNode_Type(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.DotNode)Type()", args, 0, 0)
	_res := o.O.(*_parse.DotNode).Type()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_FieldNode_Copy from text/template/parse/node.go:
func __ptrTo_FieldNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.FieldNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.FieldNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_FieldNode_String from text/template/parse/node.go:
func __ptrTo_FieldNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.FieldNode)String()", args, 0, 0)
	_res := o.O.(*_parse.FieldNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_IdentifierNode_Copy from text/template/parse/node.go:
func __ptrTo_IdentifierNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.IdentifierNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.IdentifierNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_IdentifierNode_SetPos from text/template/parse/node.go:
func __ptrTo_IdentifierNode_SetPos(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template/parse.IdentifierNode)SetPos()", args, 1, 1)
	pos := ExtractGo_go_std_text_template_parse__Pos("(*_text/template/parse.IdentifierNode)SetPos()", "pos", _argList, 0)
	_res := o.O.(*_parse.IdentifierNode).SetPos(pos)
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_IdentifierNode_SetTree from text/template/parse/node.go:
// func __ptrTo_IdentifierNode_SetTree(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_text/template/parse.IdentifierNode)SetTree()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for t at: /usr/local/go/src/text/template/parse/node.go:305:36)
// 	_res := o.O.(*_parse.IdentifierNode).SetTree(t)
// 	return MakeGoObject(_res)
// }

GO FUNC text/template/parse.__ptrTo_IdentifierNode_String from text/template/parse/node.go:
func __ptrTo_IdentifierNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.IdentifierNode)String()", args, 0, 0)
	_res := o.O.(*_parse.IdentifierNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_IfNode_Copy from text/template/parse/node.go:
func __ptrTo_IfNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.IfNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.IfNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ListNode_Copy from text/template/parse/node.go:
func __ptrTo_ListNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ListNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.ListNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ListNode_CopyList from text/template/parse/node.go:
func __ptrTo_ListNode_CopyList(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ListNode)CopyList()", args, 0, 0)
	_res := o.O.(*_parse.ListNode).CopyList()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_ListNode_String from text/template/parse/node.go:
func __ptrTo_ListNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.ListNode)String()", args, 0, 0)
	_res := o.O.(*_parse.ListNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_NilNode_Copy from text/template/parse/node.go:
func __ptrTo_NilNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.NilNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.NilNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_NilNode_String from text/template/parse/node.go:
func __ptrTo_NilNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.NilNode)String()", args, 0, 0)
	_res := o.O.(*_parse.NilNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_NilNode_Type from text/template/parse/node.go:
func __ptrTo_NilNode_Type(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.NilNode)Type()", args, 0, 0)
	_res := o.O.(*_parse.NilNode).Type()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_NumberNode_Copy from text/template/parse/node.go:
func __ptrTo_NumberNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.NumberNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.NumberNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_NumberNode_String from text/template/parse/node.go:
func __ptrTo_NumberNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.NumberNode)String()", args, 0, 0)
	_res := o.O.(*_parse.NumberNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_PipeNode_Copy from text/template/parse/node.go:
func __ptrTo_PipeNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.PipeNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.PipeNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_PipeNode_CopyPipe from text/template/parse/node.go:
func __ptrTo_PipeNode_CopyPipe(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.PipeNode)CopyPipe()", args, 0, 0)
	_res := o.O.(*_parse.PipeNode).CopyPipe()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_PipeNode_String from text/template/parse/node.go:
func __ptrTo_PipeNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.PipeNode)String()", args, 0, 0)
	_res := o.O.(*_parse.PipeNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_RangeNode_Copy from text/template/parse/node.go:
func __ptrTo_RangeNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.RangeNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.RangeNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_StringNode_Copy from text/template/parse/node.go:
func __ptrTo_StringNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.StringNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.StringNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_StringNode_String from text/template/parse/node.go:
func __ptrTo_StringNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.StringNode)String()", args, 0, 0)
	_res := o.O.(*_parse.StringNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_TemplateNode_Copy from text/template/parse/node.go:
func __ptrTo_TemplateNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.TemplateNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.TemplateNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_TemplateNode_String from text/template/parse/node.go:
func __ptrTo_TemplateNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.TemplateNode)String()", args, 0, 0)
	_res := o.O.(*_parse.TemplateNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_TextNode_Copy from text/template/parse/node.go:
func __ptrTo_TextNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.TextNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.TextNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_TextNode_String from text/template/parse/node.go:
func __ptrTo_TextNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.TextNode)String()", args, 0, 0)
	_res := o.O.(*_parse.TextNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_Tree_Copy from text/template/parse/parse.go:
func __ptrTo_Tree_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.Tree)Copy()", args, 0, 0)
	_res := o.O.(*_parse.Tree).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_Tree_ErrorContext from text/template/parse/parse.go:
func __ptrTo_Tree_ErrorContext(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_text/template/parse.Tree)ErrorContext()", args, 1, 1)
	n := ExtractGo_go_std_text_template_parse__Node("(*_text/template/parse.Tree)ErrorContext()", "n", _argList, 0)
	location, context := o.O.(*_parse.Tree).ErrorContext(n)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(location))
	_res = _res.Conjoin(MakeString(context))
	return _res
}

GO FUNC text/template/parse.__ptrTo_Tree_Parse from text/template/parse/parse.go:
// func __ptrTo_Tree_Parse(o GoObject, args Object) Object {
// (text, leftDelim, rightDelim, ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()), ConvertToEllipsisHaHamap[](ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa())))}

GO FUNC text/template/parse.__ptrTo_VariableNode_Copy from text/template/parse/node.go:
func __ptrTo_VariableNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.VariableNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.VariableNode).Copy()
	return MakeGoObject(_res)
}

GO FUNC text/template/parse.__ptrTo_VariableNode_String from text/template/parse/node.go:
func __ptrTo_VariableNode_String(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.VariableNode)String()", args, 0, 0)
	_res := o.O.(*_parse.VariableNode).String()
	return MakeString(_res)
}

GO FUNC text/template/parse.__ptrTo_WithNode_Copy from text/template/parse/node.go:
func __ptrTo_WithNode_Copy(o GoObject, args Object) Object {
	CheckGoArity("(*_text/template/parse.WithNode)Copy()", args, 0, 0)
	_res := o.O.(*_parse.WithNode).Copy()
	return MakeGoObject(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package parse

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_parse "text/template/parse"
)
var members_PtrTo_ActionNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_ActionNode_Copy,
	"String": __ptrTo_ActionNode_String,
}}

var members_PtrTo_BoolNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_BoolNode_Copy,
	"String": __ptrTo_BoolNode_String,
}}

var members_PtrTo_BranchNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_BranchNode_Copy,
	"String": __ptrTo_BranchNode_String,
}}

var members_PtrTo_ChainNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_ChainNode_Copy,
	"String": __ptrTo_ChainNode_String,
}}

var members_PtrTo_CommandNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_CommandNode_Copy,
	"String": __ptrTo_CommandNode_String,
}}

var members_PtrTo_DotNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_DotNode_Copy,
	"String": __ptrTo_DotNode_String,
	"Type": __ptrTo_DotNode_Type,
}}

var members_PtrTo_FieldNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_FieldNode_Copy,
	"String": __ptrTo_FieldNode_String,
}}

var members_PtrTo_IdentifierNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_IdentifierNode_Copy,
	"SetPos": __ptrTo_IdentifierNode_SetPos,
	"String": __ptrTo_IdentifierNode_String,
}}

var members_PtrTo_IfNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_IfNode_Copy,
}}

var members_PtrTo_ListNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_ListNode_Copy,
	"CopyList": __ptrTo_ListNode_CopyList,
	"String": __ptrTo_ListNode_String,
}}

var members_PtrTo_NilNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_NilNode_Copy,
	"String": __ptrTo_NilNode_String,
	"Type": __ptrTo_NilNode_Type,
}}

var members_NodeType = GoTypeInfo{Members: GoMembers{
	"Type": __nodeType_Type,
}}

var members_PtrTo_NumberNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_NumberNode_Copy,
	"String": __ptrTo_NumberNode_String,
}}

var members_PtrTo_PipeNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_PipeNode_Copy,
	"CopyPipe": __ptrTo_PipeNode_CopyPipe,
	"String": __ptrTo_PipeNode_String,
}}

var members_Pos = GoTypeInfo{Members: GoMembers{
	"Position": __pos_Position,
}}

var members_PtrTo_RangeNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_RangeNode_Copy,
}}

var members_PtrTo_StringNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_StringNode_Copy,
	"String": __ptrTo_StringNode_String,
}}

var members_PtrTo_TemplateNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_TemplateNode_Copy,
	"String": __ptrTo_TemplateNode_String,
}}

var members_PtrTo_TextNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_TextNode_Copy,
	"String": __ptrTo_TextNode_String,
}}

var members_PtrTo_Tree = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_Tree_Copy,
	"ErrorContext": __ptrTo_Tree_ErrorContext,
}}

var members_PtrTo_VariableNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_VariableNode_Copy,
	"String": __ptrTo_VariableNode_String,
}}

var members_PtrTo_WithNode = GoTypeInfo{Members: GoMembers{
	"Copy": __ptrTo_WithNode_Copy,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_parse.ActionNode)(nil))] = &members_PtrTo_ActionNode
	GoTypes[_reflect.TypeOf((*_parse.BoolNode)(nil))] = &members_PtrTo_BoolNode
	GoTypes[_reflect.TypeOf((*_parse.BranchNode)(nil))] = &members_PtrTo_BranchNode
	GoTypes[_reflect.TypeOf((*_parse.ChainNode)(nil))] = &members_PtrTo_ChainNode
	GoTypes[_reflect.TypeOf((*_parse.CommandNode)(nil))] = &members_PtrTo_CommandNode
	GoTypes[_reflect.TypeOf((*_parse.DotNode)(nil))] = &members_PtrTo_DotNode
	GoTypes[_reflect.TypeOf((*_parse.FieldNode)(nil))] = &members_PtrTo_FieldNode
	GoTypes[_reflect.TypeOf((*_parse.IdentifierNode)(nil))] = &members_PtrTo_IdentifierNode
	GoTypes[_reflect.TypeOf((*_parse.IfNode)(nil))] = &members_PtrTo_IfNode
	GoTypes[_reflect.TypeOf((*_parse.ListNode)(nil))] = &members_PtrTo_ListNode
	GoTypes[_reflect.TypeOf((*_parse.NilNode)(nil))] = &members_PtrTo_NilNode
	GoTypes[_reflect.TypeOf((*_parse.NodeType)(nil)).Elem()] = &members_NodeType
	GoTypes[_reflect.TypeOf((*_parse.NumberNode)(nil))] = &members_PtrTo_NumberNode
	GoTypes[_reflect.TypeOf((*_parse.PipeNode)(nil))] = &members_PtrTo_PipeNode
	GoTypes[_reflect.TypeOf((*_parse.Pos)(nil)).Elem()] = &members_Pos
	GoTypes[_reflect.TypeOf((*_parse.RangeNode)(nil))] = &members_PtrTo_RangeNode
	GoTypes[_reflect.TypeOf((*_parse.StringNode)(nil))] = &members_PtrTo_StringNode
	GoTypes[_reflect.TypeOf((*_parse.TemplateNode)(nil))] = &members_PtrTo_TemplateNode
	GoTypes[_reflect.TypeOf((*_parse.TextNode)(nil))] = &members_PtrTo_TextNode
	GoTypes[_reflect.TypeOf((*_parse.Tree)(nil))] = &members_PtrTo_Tree
	GoTypes[_reflect.TypeOf((*_parse.VariableNode)(nil))] = &members_PtrTo_VariableNode
	GoTypes[_reflect.TypeOf((*_parse.WithNode)(nil))] = &members_PtrTo_WithNode
}

GO TYPE time.Duration from time/time.go:
func ExtractGoObjectDuration(args []Object, index int) *_time.Duration {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Duration:
			return &r
		case *_time.Duration:
			return r
		}
	case Number:
		v := _time.Duration(ExtractInt64(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Duration]"))
}

func _ConstructDuration(_v Object) _time.Duration {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Duration:
			return _g
		case *_time.Duration:
			return *_g
		}
	case Number:
		return _time.Duration(_o.BigInt().Int64())
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Duration] or: Number"))
}

GO TYPE time.Location from time/zoneinfo.go:
func ExtractGoObjectLocation(args []Object, index int) *_time.Location {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Location:
			return &r
		case *_time.Location:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Location]"))
}

func _mapToLocation(o Map) *_time.Location {
	return &_time.Location{}
}

func _vectorToLocation(o *Vector) *_time.Location {
	return &_time.Location{}
}

func _ConstructLocation(_v Object) *_time.Location {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Location:
			return &_g
		case *_time.Location:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToLocation(_o.(Map))
	case *Vector:
		return _vectorToLocation(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Location] or: Map or Vector"))
}

GO TYPE time.Month from time/time.go:
func ExtractGoObjectMonth(args []Object, index int) *_time.Month {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Month:
			return &r
		case *_time.Month:
			return r
		}
	case Int:
		v := _time.Month(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Month]"))
}

func _ConstructMonth(_v Object) _time.Month {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Month:
			return _g
		case *_time.Month:
			return *_g
		}
	case Number:
		return _time.Month(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Month] or: Number"))
}

GO TYPE time.ParseError from time/format.go:
func ExtractGoObjectParseError(args []Object, index int) *_time.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.ParseError:
			return &r
		case *_time.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.ParseError]"))
}

func _mapToParseError(o Map) *_time.ParseError {
	return &_time.ParseError{}
}

func _vectorToParseError(o *Vector) *_time.ParseError {
	return &_time.ParseError{
		Layout: AssertString(o.Nth(0), "").S,
		Value: AssertString(o.Nth(1), "").S,
		LayoutElem: AssertString(o.Nth(2), "").S,
		ValueElem: AssertString(o.Nth(3), "").S,
		Message: AssertString(o.Nth(4), "").S,
	}
}

func _ConstructParseError(_v Object) *_time.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.ParseError:
			return &_g
		case *_time.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.ParseError] or: Map or Vector"))
}

GO TYPE time.Ticker from time/tick.go:
func ExtractGoObjectTicker(args []Object, index int) *_time.Ticker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Ticker:
			return &r
		case *_time.Ticker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Ticker]"))
}

// func _mapToTicker(o Map) *_time.Ticker {
// 	return &_time.Ticker{}
// }

// func _vectorToTicker(o *Vector) *_time.Ticker {
// 	return &_time.Ticker{
// 		C: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructTicker(_v Object) *_time.Ticker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _time.Ticker:
// 			return &_g
// 		case *_time.Ticker:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTicker(_o.(Map))
// 	case *Vector:
// 		return _vectorToTicker(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Ticker] or: Map or Vector"))
// }

GO TYPE time.Time from time/time.go:
func ExtractGoObjectTime(args []Object, index int) *_time.Time {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Time:
			return &r
		case *_time.Time:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Time]"))
}

func _mapToTime(o Map) *_time.Time {
	return &_time.Time{}
}

func _vectorToTime(o *Vector) *_time.Time {
	return &_time.Time{}
}

func _ConstructTime(_v Object) *_time.Time {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Time:
			return &_g
		case *_time.Time:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTime(_o.(Map))
	case *Vector:
		return _vectorToTime(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Time] or: Map or Vector"))
}

GO TYPE time.Timer from time/sleep.go:
func ExtractGoObjectTimer(args []Object, index int) *_time.Timer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Timer:
			return &r
		case *_time.Timer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Timer]"))
}

// func _mapToTimer(o Map) *_time.Timer {
// 	return &_time.Timer{}
// }

// func _vectorToTimer(o *Vector) *_time.Timer {
// 	return &_time.Timer{
// 		C: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructTimer(_v Object) *_time.Timer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _time.Timer:
// 			return &_g
// 		case *_time.Timer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTimer(_o.(Map))
// 	case *Vector:
// 		return _vectorToTimer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Timer] or: Map or Vector"))
// }

GO TYPE time.Weekday from time/time.go:
func ExtractGoObjectWeekday(args []Object, index int) *_time.Weekday {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _time.Weekday:
			return &r
		case *_time.Weekday:
			return r
		}
	case Int:
		v := _time.Weekday(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[time.Weekday]"))
}

func _ConstructWeekday(_v Object) _time.Weekday {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _time.Weekday:
			return _g
		case *_time.Weekday:
			return *_g
		}
	case Number:
		return _time.Weekday(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[time.Weekday] or: Number"))
}

GO FUNC time.After from time/sleep.go:
// func __after(d _time.Duration) Object {
// 	return _time.After(d)
// }

GO FUNC time.AfterFunc from time/sleep.go:
// func __afterFunc(d _time.Duration, f func) Object {
// 	_res := _time.AfterFunc(d, f)
// 	return MakeGoObject(_res)
// }

GO FUNC time.Date from time/time.go:
func __date(year int, month _time.Month, day int, hour int, min int, sec int, nsec int, loc *_time.Location) Object {
	_res := _time.Date(year, month, day, hour, min, sec, nsec, loc)
	return MakeGoObject(_res)
}

GO FUNC time.FixedZone from time/zoneinfo.go:
func __fixedZone(name string, offset int) Object {
	_res := _time.FixedZone(name, offset)
	return MakeGoObject(_res)
}

GO FUNC time.LoadLocation from time/zoneinfo.go:
func __loadLocation(name string) Object {
	_res1, _res2 := _time.LoadLocation(name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.LoadLocationFromTZData from time/zoneinfo_read.go:
// func __loadLocationFromTZData(name string, data []byte) Object {
// 	_res1, _res2 := _time.LoadLocationFromTZData(name, data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.NewTicker from time/tick.go:
func __newTicker(d _time.Duration) Object {
	_res := _time.NewTicker(d)
	return MakeGoObject(_res)
}

GO FUNC time.NewTimer from time/sleep.go:
func __newTimer(d _time.Duration) Object {
	_res := _time.NewTimer(d)
	return MakeGoObject(_res)
}

GO FUNC time.Now from time/time.go:
func __now() Object {
	_res := _time.Now()
	return MakeGoObject(_res)
}

GO FUNC time.Parse from time/format.go:
func __parse(layout string, value string) Object {
	_res1, _res2 := _time.Parse(layout, value)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseDuration from time/format.go:
func __parseDuration(s string) Object {
	_res1, _res2 := _time.ParseDuration(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseInLocation from time/format.go:
func __parseInLocation(layout string, value string, loc *_time.Location) Object {
	_res1, _res2 := _time.ParseInLocation(layout, value, loc)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.Since from time/time.go:
func __since(t _time.Time) Object {
	_res := _time.Since(t)
	return MakeGoObject(_res)
}

GO FUNC time.Sleep from time/sleep.go:
// func __sleep(d _time.Duration) Object {
// 	_time.Sleep(d)
// 	...ABEND675: TODO...
// }

GO FUNC time.Tick from time/tick.go:
// func __tick(d _time.Duration) Object {
// 	return _time.Tick(d)
// }

GO FUNC time.Unix from time/time.go:
func __unix(sec int64, nsec int64) Object {
	_res := _time.Unix(sec, nsec)
	return MakeGoObject(_res)
}

GO FUNC time.Until from time/time.go:
func __until(t _time.Time) Object {
	_res := _time.Until(t)
	return MakeGoObject(_res)
}

GO FUNC time.__duration_Hours from time/time.go:
// func __duration_Hours(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC time.__duration_Minutes from time/time.go:
// func __duration_Minutes(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC time.__duration_Nanoseconds from time/time.go:
func __duration_Nanoseconds(o GoObject, args Object) Object {
	CheckGoArity("(_time.Duration)Nanoseconds()", args, 0, 0)
	_res := o.O.(_time.Duration).Nanoseconds()
	return MakeBigInt(_res)
}

GO FUNC time.__duration_Round from time/time.go:
func __duration_Round(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Duration)Round()", args, 1, 1)
	m := ExtractGo_go_std_time__Duration("(_time.Duration)Round()", "m", _argList, 0)
	_res := o.O.(_time.Duration).Round(m)
	return MakeGoObject(_res)
}

GO FUNC time.__duration_Seconds from time/time.go:
// func __duration_Seconds(o GoObject, args Object) Object {
// ABEND007(find these)}

GO FUNC time.__duration_String from time/time.go:
func __duration_String(o GoObject, args Object) Object {
	CheckGoArity("(_time.Duration)String()", args, 0, 0)
	_res := o.O.(_time.Duration).String()
	return MakeString(_res)
}

GO FUNC time.__duration_Truncate from time/time.go:
func __duration_Truncate(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Duration)Truncate()", args, 1, 1)
	m := ExtractGo_go_std_time__Duration("(_time.Duration)Truncate()", "m", _argList, 0)
	_res := o.O.(_time.Duration).Truncate(m)
	return MakeGoObject(_res)
}

GO FUNC time.__month_String from time/time.go:
func __month_String(o GoObject, args Object) Object {
	CheckGoArity("(_time.Month)String()", args, 0, 0)
	_res := o.O.(_time.Month).String()
	return MakeString(_res)
}

GO FUNC time.__ptrTo_Location_String from time/zoneinfo.go:
func __ptrTo_Location_String(o GoObject, args Object) Object {
	CheckGoArity("(*_time.Location)String()", args, 0, 0)
	_res := o.O.(*_time.Location).String()
	return MakeString(_res)
}

GO FUNC time.__ptrTo_ParseError_Error from time/format.go:
func __ptrTo_ParseError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_time.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_time.ParseError).Error()
	return MakeString(_res)
}

GO FUNC time.__ptrTo_Ticker_Stop from time/tick.go:
// func __ptrTo_Ticker_Stop(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC time.__ptrTo_Time_GobDecode from time/time.go:
// func __ptrTo_Time_GobDecode(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC time.__ptrTo_Time_UnmarshalBinary from time/time.go:
// func __ptrTo_Time_UnmarshalBinary(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC time.__ptrTo_Time_UnmarshalJSON from time/time.go:
// func __ptrTo_Time_UnmarshalJSON(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC time.__ptrTo_Time_UnmarshalText from time/time.go:
// func __ptrTo_Time_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(data)))}

GO FUNC time.__ptrTo_Timer_Reset from time/sleep.go:
func __ptrTo_Timer_Reset(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_time.Timer)Reset()", args, 1, 1)
	d := ExtractGo_go_std_time__Duration("(*_time.Timer)Reset()", "d", _argList, 0)
	_res := o.O.(*_time.Timer).Reset(d)
	return MakeBoolean(_res)
}

GO FUNC time.__ptrTo_Timer_Stop from time/sleep.go:
func __ptrTo_Timer_Stop(o GoObject, args Object) Object {
	CheckGoArity("(*_time.Timer)Stop()", args, 0, 0)
	_res := o.O.(*_time.Timer).Stop()
	return MakeBoolean(_res)
}

GO FUNC time.__time_Add from time/time.go:
func __time_Add(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Add()", args, 1, 1)
	d := ExtractGo_go_std_time__Duration("(_time.Time)Add()", "d", _argList, 0)
	_res := o.O.(_time.Time).Add(d)
	return MakeGoObject(_res)
}

GO FUNC time.__time_AddDate from time/time.go:
func __time_AddDate(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)AddDate()", args, 3, 3)
	years := ExtractGoInt("(_time.Time)AddDate()", "years", _argList, 0)
	months := ExtractGoInt("(_time.Time)AddDate()", "months", _argList, 1)
	days := ExtractGoInt("(_time.Time)AddDate()", "days", _argList, 2)
	_res := o.O.(_time.Time).AddDate(years, months, days)
	return MakeGoObject(_res)
}

GO FUNC time.__time_After from time/time.go:
func __time_After(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)After()", args, 1, 1)
	u := ExtractGo_go_std_time__Time("(_time.Time)After()", "u", _argList, 0)
	_res := o.O.(_time.Time).After(u)
	return MakeBoolean(_res)
}

GO FUNC time.__time_AppendFormat from time/format.go:
// func __time_AppendFormat(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(b)), layout)}

GO FUNC time.__time_Before from time/time.go:
func __time_Before(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Before()", args, 1, 1)
	u := ExtractGo_go_std_time__Time("(_time.Time)Before()", "u", _argList, 0)
	_res := o.O.(_time.Time).Before(u)
	return MakeBoolean(_res)
}

GO FUNC time.__time_Clock from time/time.go:
func __time_Clock(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Clock()", args, 0, 0)
	hour, min, sec := o.O.(_time.Time).Clock()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(hour))
	_res = _res.Conjoin(MakeInt(min))
	_res = _res.Conjoin(MakeInt(sec))
	return _res
}

GO FUNC time.__time_Date from time/time.go:
func __time_Date(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Date()", args, 0, 0)
	year, month, day := o.O.(_time.Time).Date()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(year))
	_res = _res.Conjoin(MakeGoObject(month))
	_res = _res.Conjoin(MakeInt(day))
	return _res
}

GO FUNC time.__time_Day from time/time.go:
func __time_Day(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Day()", args, 0, 0)
	_res := o.O.(_time.Time).Day()
	return MakeInt(_res)
}

GO FUNC time.__time_Equal from time/time.go:
func __time_Equal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Equal()", args, 1, 1)
	u := ExtractGo_go_std_time__Time("(_time.Time)Equal()", "u", _argList, 0)
	_res := o.O.(_time.Time).Equal(u)
	return MakeBoolean(_res)
}

GO FUNC time.__time_Format from time/format.go:
func __time_Format(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Format()", args, 1, 1)
	layout := ExtractGoString("(_time.Time)Format()", "layout", _argList, 0)
	_res := o.O.(_time.Time).Format(layout)
	return MakeString(_res)
}

GO FUNC time.__time_GobEncode from time/time.go:
func __time_GobEncode(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)GobEncode()", args, 0, 0)
	_res1, _res2 := o.O.(_time.Time).GobEncode()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.__time_Hour from time/time.go:
func __time_Hour(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Hour()", args, 0, 0)
	_res := o.O.(_time.Time).Hour()
	return MakeInt(_res)
}

GO FUNC time.__time_ISOWeek from time/time.go:
func __time_ISOWeek(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)ISOWeek()", args, 0, 0)
	year, week := o.O.(_time.Time).ISOWeek()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(year))
	_res = _res.Conjoin(MakeInt(week))
	return _res
}

GO FUNC time.__time_In from time/time.go:
// func __time_In(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(_time.Time)In()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for loc at: /usr/local/go/src/time/time.go:1118:22)
// 	_res := o.O.(_time.Time).In(loc)
// 	return MakeGoObject(_res)
// }

GO FUNC time.__time_IsZero from time/time.go:
func __time_IsZero(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)IsZero()", args, 0, 0)
	_res := o.O.(_time.Time).IsZero()
	return MakeBoolean(_res)
}

GO FUNC time.__time_Local from time/time.go:
func __time_Local(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Local()", args, 0, 0)
	_res := o.O.(_time.Time).Local()
	return MakeGoObject(_res)
}

GO FUNC time.__time_Location from time/time.go:
func __time_Location(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Location()", args, 0, 0)
	_res := o.O.(_time.Time).Location()
	return MakeGoObject(_res)
}

GO FUNC time.__time_MarshalBinary from time/time.go:
func __time_MarshalBinary(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)MarshalBinary()", args, 0, 0)
	_res1, _res2 := o.O.(_time.Time).MarshalBinary()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.__time_MarshalJSON from time/time.go:
func __time_MarshalJSON(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)MarshalJSON()", args, 0, 0)
	_res1, _res2 := o.O.(_time.Time).MarshalJSON()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.__time_MarshalText from time/time.go:
func __time_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(_time.Time).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.__time_Minute from time/time.go:
func __time_Minute(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Minute()", args, 0, 0)
	_res := o.O.(_time.Time).Minute()
	return MakeInt(_res)
}

GO FUNC time.__time_Month from time/time.go:
func __time_Month(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Month()", args, 0, 0)
	_res := o.O.(_time.Time).Month()
	return MakeGoObject(_res)
}

GO FUNC time.__time_Nanosecond from time/time.go:
func __time_Nanosecond(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Nanosecond()", args, 0, 0)
	_res := o.O.(_time.Time).Nanosecond()
	return MakeInt(_res)
}

GO FUNC time.__time_Round from time/time.go:
func __time_Round(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Round()", args, 1, 1)
	d := ExtractGo_go_std_time__Duration("(_time.Time)Round()", "d", _argList, 0)
	_res := o.O.(_time.Time).Round(d)
	return MakeGoObject(_res)
}

GO FUNC time.__time_Second from time/time.go:
func __time_Second(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Second()", args, 0, 0)
	_res := o.O.(_time.Time).Second()
	return MakeInt(_res)
}

GO FUNC time.__time_String from time/format.go:
func __time_String(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)String()", args, 0, 0)
	_res := o.O.(_time.Time).String()
	return MakeString(_res)
}

GO FUNC time.__time_Sub from time/time.go:
func __time_Sub(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Sub()", args, 1, 1)
	u := ExtractGo_go_std_time__Time("(_time.Time)Sub()", "u", _argList, 0)
	_res := o.O.(_time.Time).Sub(u)
	return MakeGoObject(_res)
}

GO FUNC time.__time_Truncate from time/time.go:
func __time_Truncate(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_time.Time)Truncate()", args, 1, 1)
	d := ExtractGo_go_std_time__Duration("(_time.Time)Truncate()", "d", _argList, 0)
	_res := o.O.(_time.Time).Truncate(d)
	return MakeGoObject(_res)
}

GO FUNC time.__time_UTC from time/time.go:
func __time_UTC(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)UTC()", args, 0, 0)
	_res := o.O.(_time.Time).UTC()
	return MakeGoObject(_res)
}

GO FUNC time.__time_Unix from time/time.go:
func __time_Unix(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Unix()", args, 0, 0)
	_res := o.O.(_time.Time).Unix()
	return MakeBigInt(_res)
}

GO FUNC time.__time_UnixNano from time/time.go:
func __time_UnixNano(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)UnixNano()", args, 0, 0)
	_res := o.O.(_time.Time).UnixNano()
	return MakeBigInt(_res)
}

GO FUNC time.__time_Weekday from time/time.go:
func __time_Weekday(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Weekday()", args, 0, 0)
	_res := o.O.(_time.Time).Weekday()
	return MakeGoObject(_res)
}

GO FUNC time.__time_Year from time/time.go:
func __time_Year(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Year()", args, 0, 0)
	_res := o.O.(_time.Time).Year()
	return MakeInt(_res)
}

GO FUNC time.__time_YearDay from time/time.go:
func __time_YearDay(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)YearDay()", args, 0, 0)
	_res := o.O.(_time.Time).YearDay()
	return MakeInt(_res)
}

GO FUNC time.__time_Zone from time/time.go:
func __time_Zone(o GoObject, args Object) Object {
	CheckGoArity("(_time.Time)Zone()", args, 0, 0)
	name, offset := o.O.(_time.Time).Zone()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(MakeInt(offset))
	return _res
}

GO FUNC time.__weekday_String from time/time.go:
func __weekday_String(o GoObject, args Object) Object {
	CheckGoArity("(_time.Weekday)String()", args, 0, 0)
	_res := o.O.(_time.Weekday).String()
	return MakeString(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package time

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_time "time"
)
var members_Duration = GoTypeInfo{Members: GoMembers{
	"Nanoseconds": __duration_Nanoseconds,
	"Round": __duration_Round,
	"String": __duration_String,
	"Truncate": __duration_Truncate,
}}

var members_PtrTo_Location = GoTypeInfo{Members: GoMembers{
	"String": __ptrTo_Location_String,
}}

var members_Month = GoTypeInfo{Members: GoMembers{
	"String": __month_String,
}}

var members_PtrTo_ParseError = GoTypeInfo{Members: GoMembers{
	"Error": __ptrTo_ParseError_Error,
}}

var members_Time = GoTypeInfo{Members: GoMembers{
	"Add": __time_Add,
	"AddDate": __time_AddDate,
	"After": __time_After,
	"Before": __time_Before,
	"Clock": __time_Clock,
	"Date": __time_Date,
	"Day": __time_Day,
	"Equal": __time_Equal,
	"Format": __time_Format,
	"GobEncode": __time_GobEncode,
	"Hour": __time_Hour,
	"ISOWeek": __time_ISOWeek,
	"IsZero": __time_IsZero,
	"Local": __time_Local,
	"Location": __time_Location,
	"MarshalBinary": __time_MarshalBinary,
	"MarshalJSON": __time_MarshalJSON,
	"MarshalText": __time_MarshalText,
	"Minute": __time_Minute,
	"Month": __time_Month,
	"Nanosecond": __time_Nanosecond,
	"Round": __time_Round,
	"Second": __time_Second,
	"String": __time_String,
	"Sub": __time_Sub,
	"Truncate": __time_Truncate,
	"UTC": __time_UTC,
	"Unix": __time_Unix,
	"UnixNano": __time_UnixNano,
	"Weekday": __time_Weekday,
	"Year": __time_Year,
	"YearDay": __time_YearDay,
	"Zone": __time_Zone,
}}

var members_PtrTo_Timer = GoTypeInfo{Members: GoMembers{
	"Reset": __ptrTo_Timer_Reset,
	"Stop": __ptrTo_Timer_Stop,
}}

var members_Weekday = GoTypeInfo{Members: GoMembers{
	"String": __weekday_String,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_time.Duration)(nil)).Elem()] = &members_Duration
	GoTypes[_reflect.TypeOf((*_time.Location)(nil))] = &members_PtrTo_Location
	GoTypes[_reflect.TypeOf((*_time.Month)(nil)).Elem()] = &members_Month
	GoTypes[_reflect.TypeOf((*_time.ParseError)(nil))] = &members_PtrTo_ParseError
	GoTypes[_reflect.TypeOf((*_time.Time)(nil)).Elem()] = &members_Time
	GoTypes[_reflect.TypeOf((*_time.Timer)(nil))] = &members_PtrTo_Timer
	GoTypes[_reflect.TypeOf((*_time.Weekday)(nil)).Elem()] = &members_Weekday
}

GO TYPE unicode.CaseRange from unicode/letter.go:
func ExtractGoObjectCaseRange(args []Object, index int) *_unicode.CaseRange {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _unicode.CaseRange:
			return &r
		case *_unicode.CaseRange:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[unicode.CaseRange]"))
}

// func _mapToCaseRange(o Map) *_unicode.CaseRange {
// 	return &_unicode.CaseRange{}
// }

// func _vectorToCaseRange(o *Vector) *_unicode.CaseRange {
// 	return &_unicode.CaseRange{
// 		Lo: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
// 		Hi: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
// 		Delta: ABEND048(codegen.go: no conversion from Clojure for unicode.d ([MaxCase]rune)),
// 	}
// }

// func _ConstructCaseRange(_v Object) *_unicode.CaseRange {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _unicode.CaseRange:
// 			return &_g
// 		case *_unicode.CaseRange:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCaseRange(_o.(Map))
// 	case *Vector:
// 		return _vectorToCaseRange(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[unicode.CaseRange] or: Map or Vector"))
// }

GO TYPE unicode.Range16 from unicode/letter.go:
func ExtractGoObjectRange16(args []Object, index int) *_unicode.Range16 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _unicode.Range16:
			return &r
		case *_unicode.Range16:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[unicode.Range16]"))
}

func _mapToRange16(o Map) *_unicode.Range16 {
	return &_unicode.Range16{}
}

func _vectorToRange16(o *Vector) *_unicode.Range16 {
	return &_unicode.Range16{
		Lo: uint16(AssertInt(o.Nth(0), "").I),
		Hi: uint16(AssertInt(o.Nth(1), "").I),
		Stride: uint16(AssertInt(o.Nth(2), "").I),
	}
}

func _ConstructRange16(_v Object) *_unicode.Range16 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _unicode.Range16:
			return &_g
		case *_unicode.Range16:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRange16(_o.(Map))
	case *Vector:
		return _vectorToRange16(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[unicode.Range16] or: Map or Vector"))
}

GO TYPE unicode.Range32 from unicode/letter.go:
func ExtractGoObjectRange32(args []Object, index int) *_unicode.Range32 {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _unicode.Range32:
			return &r
		case *_unicode.Range32:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[unicode.Range32]"))
}

func _mapToRange32(o Map) *_unicode.Range32 {
	return &_unicode.Range32{}
}

func _vectorToRange32(o *Vector) *_unicode.Range32 {
	return &_unicode.Range32{
		Lo: uint32(AssertNumber(o.Nth(0), "").BigInt().Uint64()),
		Hi: uint32(AssertNumber(o.Nth(1), "").BigInt().Uint64()),
		Stride: uint32(AssertNumber(o.Nth(2), "").BigInt().Uint64()),
	}
}

func _ConstructRange32(_v Object) *_unicode.Range32 {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _unicode.Range32:
			return &_g
		case *_unicode.Range32:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRange32(_o.(Map))
	case *Vector:
		return _vectorToRange32(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[unicode.Range32] or: Map or Vector"))
}

GO TYPE unicode.RangeTable from unicode/letter.go:
func ExtractGoObjectRangeTable(args []Object, index int) *_unicode.RangeTable {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _unicode.RangeTable:
			return &r
		case *_unicode.RangeTable:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[unicode.RangeTable]"))
}

// func _mapToRangeTable(o Map) *_unicode.RangeTable {
// 	return &_unicode.RangeTable{}
// }

// func _vectorToRangeTable(o *Vector) *_unicode.RangeTable {
// 	return &_unicode.RangeTable{
// 		R16: ABEND048(codegen.go: no conversion from Clojure for []unicode.Range16 (unicode.Range16)),
// 		R32: ABEND048(codegen.go: no conversion from Clojure for []unicode.Range32 (unicode.Range32)),
// 		LatinOffset: AssertInt(o.Nth(2), "").I,
// 	}
// }

// func _ConstructRangeTable(_v Object) *_unicode.RangeTable {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _unicode.RangeTable:
// 			return &_g
// 		case *_unicode.RangeTable:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRangeTable(_o.(Map))
// 	case *Vector:
// 		return _vectorToRangeTable(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[unicode.RangeTable] or: Map or Vector"))
// }

GO TYPE unicode.SpecialCase from unicode/letter.go:
func ExtractGoObjectSpecialCase(args []Object, index int) *_unicode.SpecialCase {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _unicode.SpecialCase:
			return &r
		case *_unicode.SpecialCase:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[unicode.SpecialCase]"))
}

// func _ConstructSpecialCase(_v Object) _unicode.SpecialCase {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _unicode.SpecialCase:
// 			return _g
// 		case *_unicode.SpecialCase:
// 			return *_g
// 		}
// 	default:
// 		return _unicode.SpecialCase(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for SpecialCase))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[unicode.SpecialCase] or: whatever"))
// }

GO FUNC unicode.In from unicode/graphic.go:
// func __in(r rune, ranges ...*_unicode.RangeTable)  {
// 	_res := _unicode.In(r, ranges)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.IsOneOf from unicode/graphic.go:
// func __isOneOf(ranges []*_unicode.RangeTable, r rune)  {
// 	_res := _unicode.IsOneOf(ranges, r)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode.SimpleFold from unicode/letter.go:
func __simpleFold(r rune) Object {
	_res := _unicode.SimpleFold(r)
	return MakeChar(_res)
}

GO FUNC unicode.To from unicode/letter.go:
func __to(_case int, r rune) Object {
	_res := _unicode.To(_case, r)
	return MakeChar(_res)
}

GO FUNC unicode.ToLower from unicode/letter.go:
func __toLower(r rune) Object {
	_res := _unicode.ToLower(r)
	return MakeChar(_res)
}

GO FUNC unicode.ToTitle from unicode/letter.go:
func __toTitle(r rune) Object {
	_res := _unicode.ToTitle(r)
	return MakeChar(_res)
}

GO FUNC unicode.ToUpper from unicode/letter.go:
func __toUpper(r rune) Object {
	_res := _unicode.ToUpper(r)
	return MakeChar(_res)
}

GO FUNC unicode.__specialCase_ToLower from unicode/letter.go:
func __specialCase_ToLower(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_unicode.SpecialCase)ToLower()", args, 1, 1)
	r := ExtractGoChar("(_unicode.SpecialCase)ToLower()", "r", _argList, 0)
	_res := o.O.(_unicode.SpecialCase).ToLower(r)
	return MakeChar(_res)
}

GO FUNC unicode.__specialCase_ToTitle from unicode/letter.go:
func __specialCase_ToTitle(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_unicode.SpecialCase)ToTitle()", args, 1, 1)
	r := ExtractGoChar("(_unicode.SpecialCase)ToTitle()", "r", _argList, 0)
	_res := o.O.(_unicode.SpecialCase).ToTitle(r)
	return MakeChar(_res)
}

GO FUNC unicode.__specialCase_ToUpper from unicode/letter.go:
func __specialCase_ToUpper(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_unicode.SpecialCase)ToUpper()", args, 1, 1)
	r := ExtractGoChar("(_unicode.SpecialCase)ToUpper()", "r", _argList, 0)
	_res := o.O.(_unicode.SpecialCase).ToUpper(r)
	return MakeChar(_res)
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package unicode

import (
	. "github.com/candid82/joker/core"
	_reflect "reflect"
	_unicode "unicode"
)
var members_SpecialCase = GoTypeInfo{Members: GoMembers{
	"ToLower": __specialCase_ToLower,
	"ToTitle": __specialCase_ToTitle,
	"ToUpper": __specialCase_ToUpper,
}}


func init() {
	GoTypes[_reflect.TypeOf((*_unicode.SpecialCase)(nil)).Elem()] = &members_SpecialCase
}

GO FUNC unicode/utf16.Decode from unicode/utf16/utf16.go:
// func __decode(s []uint16) Object {
// 	_res := _utf16.Decode(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeChar(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.DecodeRune from unicode/utf16/utf16.go:
func __decodeRune(r1 rune, r2 rune) Object {
	_res := _utf16.DecodeRune(r1, r2)
	return MakeChar(_res)
}

GO FUNC unicode/utf16.Encode from unicode/utf16/utf16.go:
// func __encode(s []rune) Object {
// 	_res := _utf16.Encode(s)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.EncodeRune from unicode/utf16/utf16.go:
func __encodeRune(r rune) Object {
	r1, r2 := _utf16.EncodeRune(r)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(r1))
	_res = _res.Conjoin(MakeChar(r2))
	return _res
}

// Auto-generated by gostd at (omitted for testing), do not edit!!

package utf16

import (
	. "github.com/candid82/joker/core"
	_utf16 "unicode/utf16"
)

func init() {
}

GO FUNC unicode/utf8.DecodeLastRune from unicode/utf8/utf8.go:
// func __decodeLastRune(p []byte) Object {
// 	r, size := _utf8.DecodeLastRune(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeChar(r))
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeLastRuneInString from unicode/utf8/utf8.go:
func __decodeLastRuneInString(s string) Object {
	r, size := _utf8.DecodeLastRuneInString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(r))
	_res = _res.Conjoin(MakeInt(size))
	return _res
}

GO FUNC unicode/utf8.DecodeRune from unicode/utf8/utf8.go:
// func __decodeRune(p []byte) Object {
// 	r, size := _utf8.DecodeRune(p)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeChar(r))
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRuneInString from unicode/utf8/utf8.go:
func __decodeRuneInString(s string) Object {
	r, size := _utf8.DecodeRuneInString(s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeChar(r))
	_res = _res.Conjoin(MakeInt(size))
	return _res
}

GO FUNC unicode/utf8.EncodeRune from unicode/utf8/utf8.go:
// func __encodeRune(p []byte, r rune)  {
// 	_res := _utf8.EncodeRune(p, r)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.FullRune from unicode/utf8/utf8.go:
// func __fullRune(p []byte)  {
// 	_res := _utf8.FullRune(p)
// 	return MakeBoolean(_res)
// }

GO FUNC unicode/utf8.RuneCount from unicode/utf8/utf8.go:
// func __runeCount(p []byte)  {
// 	_res := _utf8.RuneCount(p)
// 	return MakeInt(_res)
// }

GO FUNC unicode/utf8.Valid from unicode/utf8/utf8.go:
// func __valid(p []byte)  {
// 	_res := _utf8.Valid(p)
// 	return MakeBoolean(_res)
// }

// Auto-generated by gostd at (omitted for testing), do not edit!!

package utf8

import (
	. "github.com/candid82/joker/core"
	_utf8 "unicode/utf8"
)

func init() {
}

ABENDs: 987(488) 048(481) 047(439) 902(423) 674(181) 275(142) 907(141) 675(129) 043(119) 644(104) 906(60) 007(43) 903(41) 883(20) 905(18) 908(8) 909(3) 042(2) 171(2) 901(2) 044(1)
Totals: functions=3450 generated=2099 (60.84%)
          non-receivers=1487 (43.10%) generated=737 (49.56%)
          receivers=1963 (56.90%) generated=1362 (69.38%)
        types=959 generated=425 (44.32%)
