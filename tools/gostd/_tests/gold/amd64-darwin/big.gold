goSrcDir: _tests/big/src
goSourcePath: /Users/craig/go/src
ClojureSourceDir (for import line): github.com/candid82/joker
JokerSourceDir: ../..
Excluding _tests/big/src/net/http/cgi/testdata
Excluding _tests/big/src/net/http/internal
Excluding _tests/big/src/net/http/testdata
Excluding _tests/big/src/net/internal
Excluding _tests/big/src/net/testdata
Ignoring test code in addrselect_test.go
Ignoring test code in all_test.go
Ignoring test code in cgo_unix_test.go
Ignoring test code in child_test.go
Ignoring test code in client_test.go
Ignoring test code in clientserver_test.go
Ignoring test code in conf_test.go
Ignoring test code in conn_test.go
Ignoring test code in cookie_test.go
Ignoring test code in dial_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in dnsclient_test.go
Ignoring test code in dnsclient_unix_test.go
Ignoring test code in dnsconfig_unix_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in dummy_publicsuffix_test.go
Ignoring test code in dump_test.go
Ignoring test code in error_plan9_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in error_test.go
Ignoring test code in error_unix_test.go
Ignoring test code in error_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in external_test.go
Ignoring test code in fcgi_test.go
Ignoring test code in file_test.go
Ignoring test code in filetransport_test.go
Ignoring test code in fs_test.go
Ignoring test code in header_test.go
Ignoring test code in host_test.go
Ignoring test code in hosts_test.go
Ignoring test code in http_test.go
Ignoring test code in httptest_test.go
Ignoring test code in interface_bsd_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in interface_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in ip_test.go
Ignoring test code in iprawsock_test.go
Ignoring test code in ipsock_test.go
Ignoring test code in jar_test.go
Ignoring test code in listen_test.go
Ignoring test code in lookup_test.go
Ignoring test code in lookup_windows_test.go
Ignoring test code in mac_test.go
Ignoring test code in main_cloexec_test.go
Ignoring test code in main_conf_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in main_plan9_test.go
Ignoring test code in main_posix_test.go
Ignoring test code in main_test.go
Ignoring test code in main_unix_test.go
Ignoring test code in main_windows_test.go
Ignoring test code in matryoshka_test.go
Ignoring test code in message_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in net_test.go
Ignoring test code in net_windows_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in npn_test.go
Ignoring test code in nss_test.go
Ignoring test code in packetconn_test.go
Ignoring test code in parse_test.go
Ignoring test code in pipe_test.go
Ignoring test code in plan9_test.go
Ignoring test code in platform_test.go
Ignoring test code in port_test.go
Ignoring test code in posix_test.go
Ignoring test code in pprof_test.go
Ignoring test code in protoconn_test.go
Ignoring test code in proxy_test.go
Ignoring test code in punycode_test.go
Ignoring test code in range_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in rawconn_test.go
Ignoring test code in rawconn_unix_test.go
Ignoring test code in rawconn_windows_test.go
Ignoring test code in reader_test.go
Ignoring test code in readrequest_test.go
Ignoring test code in recorder_test.go
Ignoring test code in request_test.go
Ignoring test code in requestwrite_test.go
Ignoring test code in response_test.go
Ignoring test code in responsewrite_test.go
Ignoring test code in reverseproxy_test.go
Ignoring test code in sendfile_test.go
Ignoring test code in serve_test.go
Ignoring test code in server_test.go
Ignoring test code in smtp_test.go
Ignoring test code in sniff_test.go
Ignoring test code in splice_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in tcpsock_unix_test.go
Ignoring test code in timeout_test.go
Ignoring test code in trace_test.go
Ignoring test code in transfer_test.go
Ignoring test code in transport_internal_test.go
Ignoring test code in transport_test.go
Ignoring test code in udpsock_plan9_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in unixsock_linux_test.go
Ignoring test code in unixsock_test.go
Ignoring test code in url_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in writer_test.go
Ignoring test code in writev_test.go
Matchfile(_tests/big/src/net/addrselect.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_android.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_linux.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_netbsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_resnew.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_resold.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_socknew.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_sockold.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_stub.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_unix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_windows.go) => false <nil>
Matchfile(_tests/big/src/net/conf.go) => true <nil>
Matchfile(_tests/big/src/net/conf_netcgo.go) => false <nil>
Matchfile(_tests/big/src/net/dial.go) => true <nil>
Matchfile(_tests/big/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/big/src/net/dnsclient_unix.go) => true <nil>
Matchfile(_tests/big/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_nacl.go) => false <nil>
Matchfile(_tests/big/src/net/error_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/error_posix.go) => true <nil>
Matchfile(_tests/big/src/net/error_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_windows.go) => false <nil>
Matchfile(_tests/big/src/net/fd_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/fd_unix.go) => true <nil>
Matchfile(_tests/big/src/net/fd_windows.go) => false <nil>
Matchfile(_tests/big/src/net/file.go) => true <nil>
Matchfile(_tests/big/src/net/file_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/file_stub.go) => false <nil>
Matchfile(_tests/big/src/net/file_unix.go) => true <nil>
Matchfile(_tests/big/src/net/file_windows.go) => false <nil>
Matchfile(_tests/big/src/net/hook.go) => true <nil>
Matchfile(_tests/big/src/net/hook_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/hook_unix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_windows.go) => false <nil>
Matchfile(_tests/big/src/net/hosts.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/child.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/host.go) => true <nil>
Matchfile(_tests/big/src/net/http/client.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookie.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookiejar/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookiejar/punycode.go) => true <nil>
Matchfile(_tests/big/src/net/http/doc.go) => true <nil>
Matchfile(_tests/big/src/net/http/fcgi/child.go) => true <nil>
Matchfile(_tests/big/src/net/http/fcgi/fcgi.go) => true <nil>
Matchfile(_tests/big/src/net/http/filetransport.go) => true <nil>
Matchfile(_tests/big/src/net/http/fs.go) => true <nil>
Matchfile(_tests/big/src/net/http/h2_bundle.go) => true <nil>
Matchfile(_tests/big/src/net/http/header.go) => true <nil>
Matchfile(_tests/big/src/net/http/http.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/httptest.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/recorder.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptrace/trace.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/dump.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/persist.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/reverseproxy.go) => true <nil>
Matchfile(_tests/big/src/net/http/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/method.go) => true <nil>
Matchfile(_tests/big/src/net/http/pprof/pprof.go) => true <nil>
Matchfile(_tests/big/src/net/http/race.go) => false <nil>
Matchfile(_tests/big/src/net/http/request.go) => true <nil>
Matchfile(_tests/big/src/net/http/response.go) => true <nil>
Matchfile(_tests/big/src/net/http/roundtrip.go) => true <nil>
Matchfile(_tests/big/src/net/http/roundtrip_js.go) => false <nil>
Matchfile(_tests/big/src/net/http/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/sniff.go) => true <nil>
Matchfile(_tests/big/src/net/http/socks_bundle.go) => true <nil>
Matchfile(_tests/big/src/net/http/status.go) => true <nil>
Matchfile(_tests/big/src/net/http/transfer.go) => true <nil>
Matchfile(_tests/big/src/net/http/transport.go) => true <nil>
Matchfile(_tests/big/src/net/http/triv.go) => false <nil>
Matchfile(_tests/big/src/net/interface.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsdvar.go) => false <nil>
Matchfile(_tests/big/src/net/interface_darwin.go) => true <nil>
Matchfile(_tests/big/src/net/interface_freebsd.go) => false <nil>
Matchfile(_tests/big/src/net/interface_linux.go) => false <nil>
Matchfile(_tests/big/src/net/interface_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/interface_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/interface_stub.go) => false <nil>
Matchfile(_tests/big/src/net/interface_windows.go) => false <nil>
Matchfile(_tests/big/src/net/ip.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/iprawsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/ipsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_fake.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_unix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_windows.go) => false <nil>
Matchfile(_tests/big/src/net/mac.go) => true <nil>
Matchfile(_tests/big/src/net/mail/message.go) => true <nil>
Matchfile(_tests/big/src/net/net.go) => true <nil>
Matchfile(_tests/big/src/net/net_fake.go) => false <nil>
Matchfile(_tests/big/src/net/nss.go) => true <nil>
Matchfile(_tests/big/src/net/parse.go) => true <nil>
Matchfile(_tests/big/src/net/pipe.go) => true <nil>
Matchfile(_tests/big/src/net/port.go) => true <nil>
Matchfile(_tests/big/src/net/port_unix.go) => true <nil>
Matchfile(_tests/big/src/net/rawconn.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/client.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/debug.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/jsonrpc/client.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_linux.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_stub.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_windows.go) => false <nil>
Matchfile(_tests/big/src/net/smtp/auth.go) => true <nil>
Matchfile(_tests/big/src/net/smtp/smtp.go) => true <nil>
Matchfile(_tests/big/src/net/sock_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/sock_cloexec.go) => false <nil>
Matchfile(_tests/big/src/net/sock_linux.go) => false <nil>
Matchfile(_tests/big/src/net/sock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sock_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sockaddr_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_bsd.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_linux.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_bsdvar.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_linux.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_windows.go) => false <nil>
Matchfile(_tests/big/src/net/splice_linux.go) => false <nil>
Matchfile(_tests/big/src/net/splice_stub.go) => true <nil>
Matchfile(_tests/big/src/net/sys_cloexec.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsock.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_darwin.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_dragonfly.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_unix.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/textproto/header.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/pipeline.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/reader.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/textproto.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/writer.go) => true <nil>
Matchfile(_tests/big/src/net/udpsock.go) => true <nil>
Matchfile(_tests/big/src/net/udpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/udpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/unixsock.go) => true <nil>
Matchfile(_tests/big/src/net/unixsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/unixsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/url/url.go) => true <nil>
Matchfile(_tests/big/src/net/writev_unix.go) => true <nil>
Processing go:
Processing net/http/cgi:
Processing net/http/cookiejar:
Processing net/http/fcgi:
Processing net/http/httptest:
Processing net/http/httptrace:
Processing net/http/httputil:
Processing net/http/pprof:
Processing net/http:
Processing net/mail:
Processing net/rpc/jsonrpc:
Processing net/rpc:
Processing net/smtp:
Processing net/textproto:
Processing net/url:
Processing net:
Processing package=net/http/cgi:
Processing package=net/http/cookiejar:
Processing package=net/http/fcgi:
Processing package=net/http/httptest:
Processing package=net/http/httptrace:
Processing package=net/http/httputil:
Processing package=net/http/pprof:
Processing package=net/http:
Processing package=net/mail:
Processing package=net/rpc/jsonrpc:
Processing package=net/rpc:
Processing package=net/smtp:
Processing package=net/textproto:
Processing package=net/url:
Processing package=net:
CLOJURE CONSTANT FlagBroadcast from net/interface.go:
(def
  ^{:doc "interface supports broadcast access capability\n"
    :added "1.0"
    :tag "Number"
    :const true
    :go "uint64(uint(net.FlagBroadcast))"}
  FlagBroadcast)

CLOJURE CONSTANT FlagLoopback from net/interface.go:
(def
  ^{:doc "interface is a loopback interface\n"
    :added "1.0"
    :tag "Number"
    :const true
    :go "uint64(uint(net.FlagLoopback))"}
  FlagLoopback)

CLOJURE CONSTANT FlagMulticast from net/interface.go:
(def
  ^{:doc "interface supports multicast access capability\n"
    :added "1.0"
    :tag "Number"
    :const true
    :go "uint64(uint(net.FlagMulticast))"}
  FlagMulticast)

CLOJURE CONSTANT FlagPointToPoint from net/interface.go:
(def
  ^{:doc "interface belongs to a point-to-point link\n"
    :added "1.0"
    :tag "Number"
    :const true
    :go "uint64(uint(net.FlagPointToPoint))"}
  FlagPointToPoint)

CLOJURE CONSTANT FlagUp from net/interface.go:
(def
  ^{:doc "interface is up\n"
    :added "1.0"
    :tag "Number"
    :const true
    :go "uint64(uint(net.FlagUp))"}
  FlagUp)

CLOJURE CONSTANT IPv4len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "net.IPv4len"}
  IPv4len)

CLOJURE CONSTANT IPv6len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "net.IPv6len"}
  IPv6len)

CLOJURE VARIABLE DefaultResolver from net/lookup.go:
(def
  ^{:doc "DefaultResolver is the resolver used by the package-level Lookup\nfunctions and by Dialers without a specified Resolver.\n"
    :added "1.0"
    :tag "Var"
    :go "net.DefaultResolver"}
  DefaultResolver)

CLOJURE VARIABLE ErrWriteToConnected from net/net.go:
(def
  ^{:doc "Various errors contained in OpError.\n"
    :added "1.0"
    :tag "Var"
    :go "net.ErrWriteToConnected"}
  ErrWriteToConnected)

CLOJURE VARIABLE IPv4allrouter from net/ip.go:
(def
  ^{:doc "all routers\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allrouter"}
  IPv4allrouter)

CLOJURE VARIABLE IPv4allsys from net/ip.go:
(def
  ^{:doc "all systems\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allsys"}
  IPv4allsys)

CLOJURE VARIABLE IPv4bcast from net/ip.go:
(def
  ^{:doc "limited broadcast\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4bcast"}
  IPv4bcast)

CLOJURE VARIABLE IPv4zero from net/ip.go:
(def
  ^{:doc "all zeros\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4zero"}
  IPv4zero)

CLOJURE VARIABLE IPv6interfacelocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6interfacelocalallnodes"}
  IPv6interfacelocalallnodes)

CLOJURE VARIABLE IPv6linklocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallnodes"}
  IPv6linklocalallnodes)

CLOJURE VARIABLE IPv6linklocalallrouters from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallrouters"}
  IPv6linklocalallrouters)

CLOJURE VARIABLE IPv6loopback from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6loopback"}
  IPv6loopback)

CLOJURE VARIABLE IPv6unspecified from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6unspecified"}
  IPv6unspecified)

CLOJURE VARIABLE IPv6zero from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6zero"}
  IPv6zero)

CLOJURE TYPE []*net.MX from net/dnsclient.go:
CLOJURE TYPE []*net.NS from net/dnsclient.go:
CLOJURE TYPE []*net.SRV from net/dnsclient.go:
CLOJURE TYPE []net.Addr from net/net.go:
CLOJURE TYPE []net.AddrError from net/net.go:
CLOJURE TYPE []net.Buffers from net/net.go:
CLOJURE TYPE []net.DNSConfigError from net/net.go:
CLOJURE TYPE []net.DNSError from net/net.go:
CLOJURE TYPE []net.Dialer from net/dial.go:
CLOJURE TYPE []net.Flags from net/interface.go:
CLOJURE TYPE []net.HardwareAddr from net/mac.go:
CLOJURE TYPE []net.IP from net/ip.go:
CLOJURE TYPE []net.IPAddr from net/iprawsock.go:
CLOJURE TYPE []net.IPConn from net/iprawsock.go:
CLOJURE TYPE []net.IPMask from net/ip.go:
CLOJURE TYPE []net.IPNet from net/ip.go:
CLOJURE TYPE []net.Interface from net/interface.go:
CLOJURE TYPE []net.InvalidAddrError from net/net.go:
CLOJURE TYPE []net.ListenConfig from net/dial.go:
CLOJURE TYPE []net.MX from net/dnsclient.go:
CLOJURE TYPE []net.NS from net/dnsclient.go:
CLOJURE TYPE []net.OpError from net/net.go:
CLOJURE TYPE []net.ParseError from net/net.go:
CLOJURE TYPE []net.Resolver from net/lookup.go:
CLOJURE TYPE []net.SRV from net/dnsclient.go:
CLOJURE TYPE []net.TCPAddr from net/tcpsock.go:
CLOJURE TYPE []net.TCPConn from net/tcpsock.go:
CLOJURE TYPE []net.TCPListener from net/tcpsock.go:
CLOJURE TYPE []net.UDPAddr from net/udpsock.go:
CLOJURE TYPE []net.UDPConn from net/udpsock.go:
CLOJURE TYPE []net.UnixAddr from net/unixsock.go:
CLOJURE TYPE []net.UnixConn from net/unixsock.go:
CLOJURE TYPE []net.UnixListener from net/unixsock.go:
CLOJURE TYPE []net.UnknownNetworkError from net/net.go:
CLOJURE TYPE net.Addr from net/net.go:
CLOJURE TYPE net.AddrError from net/net.go:
CLOJURE TYPE *net.AddrError from net/net.go:
CLOJURE TYPE net.Buffers from net/net.go:
CLOJURE TYPE *net.Buffers from net/net.go:
CLOJURE TYPE net.Conn from net/net.go:
CLOJURE TYPE net.DNSConfigError from net/net.go:
CLOJURE TYPE *net.DNSConfigError from net/net.go:
CLOJURE TYPE net.DNSError from net/net.go:
CLOJURE TYPE *net.DNSError from net/net.go:
CLOJURE TYPE net.Dialer from net/dial.go:
CLOJURE TYPE *net.Dialer from net/dial.go:
CLOJURE TYPE net.Error from net/net.go:
CLOJURE TYPE net.Flags from net/interface.go:
CLOJURE TYPE *net.Flags from net/interface.go:
CLOJURE TYPE net.HardwareAddr from net/mac.go:
CLOJURE TYPE *net.HardwareAddr from net/mac.go:
CLOJURE TYPE net.IP from net/ip.go:
CLOJURE TYPE *net.IP from net/ip.go:
CLOJURE TYPE net.IPAddr from net/iprawsock.go:
CLOJURE TYPE *net.IPAddr from net/iprawsock.go:
CLOJURE TYPE net.IPConn from net/iprawsock.go:
CLOJURE TYPE *net.IPConn from net/iprawsock.go:
CLOJURE TYPE net.IPMask from net/ip.go:
CLOJURE TYPE *net.IPMask from net/ip.go:
CLOJURE TYPE net.IPNet from net/ip.go:
CLOJURE TYPE *net.IPNet from net/ip.go:
CLOJURE TYPE net.Interface from net/interface.go:
CLOJURE TYPE *net.Interface from net/interface.go:
CLOJURE TYPE net.InvalidAddrError from net/net.go:
CLOJURE TYPE *net.InvalidAddrError from net/net.go:
CLOJURE TYPE net.ListenConfig from net/dial.go:
CLOJURE TYPE *net.ListenConfig from net/dial.go:
CLOJURE TYPE net.Listener from net/net.go:
CLOJURE TYPE net.MX from net/dnsclient.go:
CLOJURE TYPE *net.MX from net/dnsclient.go:
CLOJURE TYPE net.NS from net/dnsclient.go:
CLOJURE TYPE *net.NS from net/dnsclient.go:
CLOJURE TYPE net.OpError from net/net.go:
CLOJURE TYPE *net.OpError from net/net.go:
CLOJURE TYPE net.PacketConn from net/net.go:
CLOJURE TYPE net.ParseError from net/net.go:
CLOJURE TYPE *net.ParseError from net/net.go:
CLOJURE TYPE net.Resolver from net/lookup.go:
CLOJURE TYPE *net.Resolver from net/lookup.go:
CLOJURE TYPE net.SRV from net/dnsclient.go:
CLOJURE TYPE *net.SRV from net/dnsclient.go:
CLOJURE TYPE net.TCPAddr from net/tcpsock.go:
CLOJURE TYPE *net.TCPAddr from net/tcpsock.go:
CLOJURE TYPE net.TCPConn from net/tcpsock.go:
CLOJURE TYPE *net.TCPConn from net/tcpsock.go:
CLOJURE TYPE net.TCPListener from net/tcpsock.go:
CLOJURE TYPE *net.TCPListener from net/tcpsock.go:
CLOJURE TYPE net.UDPAddr from net/udpsock.go:
CLOJURE TYPE *net.UDPAddr from net/udpsock.go:
CLOJURE TYPE net.UDPConn from net/udpsock.go:
CLOJURE TYPE *net.UDPConn from net/udpsock.go:
CLOJURE TYPE net.UnixAddr from net/unixsock.go:
CLOJURE TYPE *net.UnixAddr from net/unixsock.go:
CLOJURE TYPE net.UnixConn from net/unixsock.go:
CLOJURE TYPE *net.UnixConn from net/unixsock.go:
CLOJURE TYPE net.UnixListener from net/unixsock.go:
CLOJURE TYPE *net.UnixListener from net/unixsock.go:
CLOJURE TYPE net.UnknownNetworkError from net/net.go:
CLOJURE TYPE *net.UnknownNetworkError from net/net.go:
CLOJURE FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo returns: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker returns: ^IPMask"
  {:added "1.0"
   :go "_f_cIDRMask(_v_ones, _v_bits)"}
  [^Int _v_ones, ^Int _v_bits])

CLOJURE FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo returns: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^Conn, ^Error]"
  {:added "1.0"
   :go "_f_dial(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo returns: (*IPConn, error)\n\nJoker input arguments: [^String network, ^refToIPAddr laddr, ^refToIPAddr raddr]\n\nJoker returns: [^refToIPConn, ^Error]"
  {:added "1.0"
   :go "_f_dialIP(_v_network, _v_laddr, _v_raddr)"}
  [^String _v_network, ^go.std.net/refToIPAddr _v_laddr, ^go.std.net/refToIPAddr _v_raddr])

CLOJURE FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo returns: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^refToTCPAddr laddr, ^refToTCPAddr raddr]\n\nJoker returns: [^refToTCPConn, ^Error]"
  {:added "1.0"
   :go "_f_dialTCP(_v_network, _v_laddr, _v_raddr)"}
  [^String _v_network, ^go.std.net/refToTCPAddr _v_laddr, ^go.std.net/refToTCPAddr _v_raddr])

CLOJURE FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout ABEND002(reference to unavailable package `time' looking for type `Duration'))\n\nGo returns: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker returns: [^Conn, ^Error]"
;;   {:added "1.0"
;;    :go "_f_dialTimeout(_v_network, _v_address, _v_timeout)"}
;;   [^String _v_network, ^String _v_address, ^ABEND707(API 'go.std.time/Extract_ns_Duration' is unimplemented: go.std.time/Duration) _v_timeout])

CLOJURE FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo returns: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^refToUDPAddr laddr, ^refToUDPAddr raddr]\n\nJoker returns: [^refToUDPConn, ^Error]"
  {:added "1.0"
   :go "_f_dialUDP(_v_network, _v_laddr, _v_raddr)"}
  [^String _v_network, ^go.std.net/refToUDPAddr _v_laddr, ^go.std.net/refToUDPAddr _v_raddr])

CLOJURE FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo returns: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^refToUnixAddr laddr, ^refToUnixAddr raddr]\n\nJoker returns: [^refToUnixConn, ^Error]"
  {:added "1.0"
   :go "_f_dialUnix(_v_network, _v_laddr, _v_raddr)"}
  [^String _v_network, ^go.std.net/refToUnixAddr _v_laddr, ^go.std.net/refToUnixAddr _v_raddr])

CLOJURE FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *ABEND002(reference to unavailable package `os' looking for type `File'))\n\nGo returns: (c Conn, err error)\n\nJoker input arguments: [^go.std.os/refToFile f]\n\nJoker returns: [^Conn c, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_fileConn(_v_f)"}
;;   [^ABEND707(API 'go.std.os/Extract_ns_refToFile' is unimplemented: go.std.os/refToFile) _v_f])

CLOJURE FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *ABEND002(reference to unavailable package `os' looking for type `File'))\n\nGo returns: (ln Listener, err error)\n\nJoker input arguments: [^go.std.os/refToFile f]\n\nJoker returns: [^Listener ln, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_fileListener(_v_f)"}
;;   [^ABEND707(API 'go.std.os/Extract_ns_refToFile' is unimplemented: go.std.os/refToFile) _v_f])

CLOJURE FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *ABEND002(reference to unavailable package `os' looking for type `File'))\n\nGo returns: (c PacketConn, err error)\n\nJoker input arguments: [^go.std.os/refToFile f]\n\nJoker returns: [^PacketConn c, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_filePacketConn(_v_f)"}
;;   [^ABEND707(API 'go.std.os/Extract_ns_refToFile' is unimplemented: go.std.os/refToFile) _v_f])

CLOJURE FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo returns: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker returns: ^IP"
  {:added "1.0"
   :go "_f_iPv4(_v_a, _v_b, _v_c, _v_d)"}
  [^Byte _v_a, ^Byte _v_b, ^Byte _v_c, ^Byte _v_d])

CLOJURE FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo returns: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker returns: ^IPMask"
  {:added "1.0"
   :go "_f_iPv4Mask(_v_a, _v_b, _v_c, _v_d)"}
  [^Byte _v_a, ^Byte _v_b, ^Byte _v_c, ^Byte _v_d])

CLOJURE FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo returns: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker returns: [^arrayOfAddr, ^Error]"
  {:added "1.0"
   :go "_f_interfaceAddrs()"}
  [])

CLOJURE FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo returns: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker returns: [^refToInterface, ^Error]"
  {:added "1.0"
   :go "_f_interfaceByIndex(_v_index)"}
  [^Int _v_index])

CLOJURE FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo returns: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^refToInterface, ^Error]"
  {:added "1.0"
   :go "_f_interfaceByName(_v_name)"}
  [^String _v_name])

CLOJURE FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo returns: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker returns: [^arrayOfInterface, ^Error]"
  {:added "1.0"
   :go "_f_interfaces()"}
  [])

CLOJURE FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo returns: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "net.JoinHostPort(_v_host, _v_port)"}
  [^String _v_host, ^String _v_port])

CLOJURE FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^Listener, ^Error]"
  {:added "1.0"
   :go "_f_listen(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo returns: (*IPConn, error)\n\nJoker input arguments: [^String network, ^refToIPAddr laddr]\n\nJoker returns: [^refToIPConn, ^Error]"
  {:added "1.0"
   :go "_f_listenIP(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToIPAddr _v_laddr])

CLOJURE FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo returns: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^refToInterface ifi, ^refToUDPAddr gaddr]\n\nJoker returns: [^refToUDPConn, ^Error]"
  {:added "1.0"
   :go "_f_listenMulticastUDP(_v_network, _v_ifi, _v_gaddr)"}
  [^String _v_network, ^go.std.net/refToInterface _v_ifi, ^go.std.net/refToUDPAddr _v_gaddr])

CLOJURE FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^PacketConn, ^Error]"
  {:added "1.0"
   :go "_f_listenPacket(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo returns: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^refToTCPAddr laddr]\n\nJoker returns: [^refToTCPListener, ^Error]"
  {:added "1.0"
   :go "_f_listenTCP(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToTCPAddr _v_laddr])

CLOJURE FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo returns: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^refToUDPAddr laddr]\n\nJoker returns: [^refToUDPConn, ^Error]"
  {:added "1.0"
   :go "_f_listenUDP(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToUDPAddr _v_laddr])

CLOJURE FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo returns: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^refToUnixAddr laddr]\n\nJoker returns: [^refToUnixListener, ^Error]"
  {:added "1.0"
   :go "_f_listenUnix(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToUnixAddr _v_laddr])

CLOJURE FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo returns: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^refToUnixAddr laddr]\n\nJoker returns: [^refToUnixConn, ^Error]"
  {:added "1.0"
   :go "_f_listenUnixgram(_v_network, _v_laddr)"}
  [^String _v_network, ^go.std.net/refToUnixAddr _v_laddr])

CLOJURE FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo returns: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker returns: [^arrayOfString names, ^Error err]"
  {:added "1.0"
   :go "_f_lookupAddr(_v_addr)"}
  [^String _v_addr])

CLOJURE FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo returns: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^String cname, ^Error err]"
  {:added "1.0"
   :go "_f_lookupCNAME(_v_host)"}
  [^String _v_host])

CLOJURE FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo returns: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^arrayOfString addrs, ^Error err]"
  {:added "1.0"
   :go "_f_lookupHost(_v_host)"}
  [^String _v_host])

CLOJURE FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo returns: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker returns: [^arrayOfIP, ^Error]"
  {:added "1.0"
   :go "_f_lookupIP(_v_host)"}
  [^String _v_host])

CLOJURE FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo returns: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfrefToMX, ^Error]"
  {:added "1.0"
   :go "_f_lookupMX(_v_name)"}
  [^String _v_name])

CLOJURE FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo returns: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfrefToNS, ^Error]"
  {:added "1.0"
   :go "_f_lookupNS(_v_name)"}
  [^String _v_name])

CLOJURE FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo returns: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker returns: [^Int port, ^Error err]"
  {:added "1.0"
   :go "_f_lookupPort(_v_network, _v_service)"}
  [^String _v_network, ^String _v_service])

CLOJURE FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo returns: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker returns: [^String cname, ^arrayOfrefToSRV addrs, ^Error err]"
  {:added "1.0"
   :go "_f_lookupSRV(_v_service, _v_proto, _v_name)"}
  [^String _v_service, ^String _v_proto, ^String _v_name])

CLOJURE FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo returns: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker returns: [^arrayOfString, ^Error]"
  {:added "1.0"
   :go "_f_lookupTXT(_v_name)"}
  [^String _v_name])

CLOJURE FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo returns: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^IP, ^refToIPNet, ^Error]"
  {:added "1.0"
   :go "_f_parseCIDR(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo returns: IP\n\nJoker input arguments: [^String s]\n\nJoker returns: ^IP"
  {:added "1.0"
   :go "_f_parseIP(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo returns: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^HardwareAddr hw, ^Error err]"
  {:added "1.0"
   :go "_f_parseMAC(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo returns: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker returns: [^Conn, ^Conn]"
  {:added "1.0"
   :go "_f_pipe()"}
  [])

CLOJURE FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToIPAddr, ^Error]"
  {:added "1.0"
   :go "_f_resolveIPAddr(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToTCPAddr, ^Error]"
  {:added "1.0"
   :go "_f_resolveTCPAddr(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToUDPAddr, ^Error]"
  {:added "1.0"
   :go "_f_resolveUDPAddr(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToUnixAddr, ^Error]"
  {:added "1.0"
   :go "_f_resolveUnixAddr(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo returns: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker returns: [^String host, ^String port, ^Error err]"
  {:added "1.0"
   :go "_f_splitHostPort(_v_hostport)"}
  [^String _v_hostport])

CLOJURE TYPE go.std.net/Addr:
(def
  ^{:doc "Addr represents a network end point address.\n\nThe two methods Network and String conventionally return strings\nthat can be passed as the arguments to Dial, but the exact form\nand meaning of the strings is up to the implementation.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_Addr"}
  Addr)

CLOJURE TYPE go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrError"}
  AddrError)

CLOJURE TYPE go.std.net/refToAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddrError"}
  refToAddrError)

CLOJURE TYPE go.std.net/arrayOfAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_AddrError"}
  arrayOfAddrError)

CLOJURE TYPE go.std.net/Buffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffers"}
  Buffers)

CLOJURE TYPE go.std.net/refToBuffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Buffers"}
  refToBuffers)

CLOJURE TYPE go.std.net/arrayOfBuffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Buffers"}
  arrayOfBuffers)

CLOJURE TYPE go.std.net/Conn:
(def
  ^{:doc "Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 8
    :go "&info_Conn"}
  Conn)

CLOJURE TYPE go.std.net/DNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSConfigError"}
  DNSConfigError)

CLOJURE TYPE go.std.net/refToDNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSConfigError"}
  refToDNSConfigError)

CLOJURE TYPE go.std.net/arrayOfDNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSConfigError"}
  arrayOfDNSConfigError)

CLOJURE TYPE go.std.net/DNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSError"}
  DNSError)

CLOJURE TYPE go.std.net/refToDNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSError"}
  refToDNSError)

CLOJURE TYPE go.std.net/arrayOfDNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSError"}
  arrayOfDNSError)

CLOJURE TYPE go.std.net/Dialer:
(def
  ^{:doc "A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing\nwithout that option. Dialing with the zero value of Dialer\nis therefore equivalent to just calling the Dial function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dialer"}
  Dialer)

CLOJURE TYPE go.std.net/refToDialer:
(def
  ^{:doc "A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing\nwithout that option. Dialing with the zero value of Dialer\nis therefore equivalent to just calling the Dial function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Dialer"}
  refToDialer)

CLOJURE TYPE go.std.net/arrayOfDialer:
(def
  ^{:doc "A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing\nwithout that option. Dialing with the zero value of Dialer\nis therefore equivalent to just calling the Dial function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Dialer"}
  arrayOfDialer)

CLOJURE TYPE go.std.net/Error:
(def
  ^{:doc "An Error represents a network error.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 3
    :go "&info_Error"}
  Error)

CLOJURE TYPE go.std.net/Flags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Flags"}
  Flags)

CLOJURE TYPE go.std.net/refToFlags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Flags"}
  refToFlags)

CLOJURE TYPE go.std.net/arrayOfFlags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Flags"}
  arrayOfFlags)

CLOJURE TYPE go.std.net/HardwareAddr:
(def
  ^{:doc "A HardwareAddr represents a physical hardware address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HardwareAddr"}
  HardwareAddr)

CLOJURE TYPE go.std.net/refToHardwareAddr:
(def
  ^{:doc "A HardwareAddr represents a physical hardware address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_HardwareAddr"}
  refToHardwareAddr)

CLOJURE TYPE go.std.net/arrayOfHardwareAddr:
(def
  ^{:doc "A HardwareAddr represents a physical hardware address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_HardwareAddr"}
  arrayOfHardwareAddr)

CLOJURE TYPE go.std.net/IP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IP"}
  IP)

CLOJURE TYPE go.std.net/refToIP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IP"}
  refToIP)

CLOJURE TYPE go.std.net/IPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPAddr"}
  IPAddr)

CLOJURE TYPE go.std.net/refToIPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPAddr"}
  refToIPAddr)

CLOJURE TYPE go.std.net/arrayOfIPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPAddr"}
  arrayOfIPAddr)

CLOJURE TYPE go.std.net/IPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPConn"}
  IPConn)

CLOJURE TYPE go.std.net/refToIPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPConn"}
  refToIPConn)

CLOJURE TYPE go.std.net/arrayOfIPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPConn"}
  arrayOfIPConn)

CLOJURE TYPE go.std.net/IPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMask"}
  IPMask)

CLOJURE TYPE go.std.net/refToIPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPMask"}
  refToIPMask)

CLOJURE TYPE go.std.net/arrayOfIPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPMask"}
  arrayOfIPMask)

CLOJURE TYPE go.std.net/IPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPNet"}
  IPNet)

CLOJURE TYPE go.std.net/refToIPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPNet"}
  refToIPNet)

CLOJURE TYPE go.std.net/arrayOfIPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IPNet"}
  arrayOfIPNet)

CLOJURE TYPE go.std.net/arrayOfIP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_IP"}
  arrayOfIP)

CLOJURE TYPE go.std.net/Interface:
(def
  ^{:doc "Interface represents a mapping between network interface name\nand index. It also represents network interface facility\ninformation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

CLOJURE TYPE go.std.net/refToInterface:
(def
  ^{:doc "Interface represents a mapping between network interface name\nand index. It also represents network interface facility\ninformation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Interface"}
  refToInterface)

CLOJURE TYPE go.std.net/arrayOfInterface:
(def
  ^{:doc "Interface represents a mapping between network interface name\nand index. It also represents network interface facility\ninformation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Interface"}
  arrayOfInterface)

CLOJURE TYPE go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidAddrError"}
  InvalidAddrError)

CLOJURE TYPE go.std.net/refToInvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidAddrError"}
  refToInvalidAddrError)

CLOJURE TYPE go.std.net/arrayOfInvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_InvalidAddrError"}
  arrayOfInvalidAddrError)

CLOJURE TYPE go.std.net/ListenConfig:
(def
  ^{:doc "ListenConfig contains options for listening to an address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ListenConfig"}
  ListenConfig)

CLOJURE TYPE go.std.net/refToListenConfig:
(def
  ^{:doc "ListenConfig contains options for listening to an address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ListenConfig"}
  refToListenConfig)

CLOJURE TYPE go.std.net/arrayOfListenConfig:
(def
  ^{:doc "ListenConfig contains options for listening to an address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ListenConfig"}
  arrayOfListenConfig)

CLOJURE TYPE go.std.net/Listener:
(def
  ^{:doc "A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 3
    :go "&info_Listener"}
  Listener)

CLOJURE TYPE go.std.net/MX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MX"}
  MX)

CLOJURE TYPE go.std.net/refToMX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MX"}
  refToMX)

CLOJURE TYPE go.std.net/arrayOfMX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_MX"}
  arrayOfMX)

CLOJURE TYPE go.std.net/NS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NS"}
  NS)

CLOJURE TYPE go.std.net/refToNS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_NS"}
  refToNS)

CLOJURE TYPE go.std.net/arrayOfNS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_NS"}
  arrayOfNS)

CLOJURE TYPE go.std.net/OpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OpError"}
  OpError)

CLOJURE TYPE go.std.net/refToOpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_OpError"}
  refToOpError)

CLOJURE TYPE go.std.net/arrayOfOpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_OpError"}
  arrayOfOpError)

CLOJURE TYPE go.std.net/PacketConn:
(def
  ^{:doc "PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 7
    :go "&info_PacketConn"}
  PacketConn)

CLOJURE TYPE go.std.net/ParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

CLOJURE TYPE go.std.net/refToParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ParseError"}
  refToParseError)

CLOJURE TYPE go.std.net/arrayOfParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ParseError"}
  arrayOfParseError)

CLOJURE TYPE go.std.net/Resolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resolver"}
  Resolver)

CLOJURE TYPE go.std.net/refToResolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Resolver"}
  refToResolver)

CLOJURE TYPE go.std.net/arrayOfResolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Resolver"}
  arrayOfResolver)

CLOJURE TYPE go.std.net/SRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SRV"}
  SRV)

CLOJURE TYPE go.std.net/refToSRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SRV"}
  refToSRV)

CLOJURE TYPE go.std.net/arrayOfSRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_SRV"}
  arrayOfSRV)

CLOJURE TYPE go.std.net/TCPAddr:
(def
  ^{:doc "TCPAddr represents the address of a TCP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPAddr"}
  TCPAddr)

CLOJURE TYPE go.std.net/refToTCPAddr:
(def
  ^{:doc "TCPAddr represents the address of a TCP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPAddr"}
  refToTCPAddr)

CLOJURE TYPE go.std.net/arrayOfTCPAddr:
(def
  ^{:doc "TCPAddr represents the address of a TCP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_TCPAddr"}
  arrayOfTCPAddr)

CLOJURE TYPE go.std.net/TCPConn:
(def
  ^{:doc "TCPConn is an implementation of the Conn interface for TCP network\nconnections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPConn"}
  TCPConn)

CLOJURE TYPE go.std.net/refToTCPConn:
(def
  ^{:doc "TCPConn is an implementation of the Conn interface for TCP network\nconnections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPConn"}
  refToTCPConn)

CLOJURE TYPE go.std.net/arrayOfTCPConn:
(def
  ^{:doc "TCPConn is an implementation of the Conn interface for TCP network\nconnections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_TCPConn"}
  arrayOfTCPConn)

CLOJURE TYPE go.std.net/TCPListener:
(def
  ^{:doc "TCPListener is a TCP network listener. Clients should typically\nuse variables of type Listener instead of assuming TCP.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPListener"}
  TCPListener)

CLOJURE TYPE go.std.net/refToTCPListener:
(def
  ^{:doc "TCPListener is a TCP network listener. Clients should typically\nuse variables of type Listener instead of assuming TCP.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPListener"}
  refToTCPListener)

CLOJURE TYPE go.std.net/arrayOfTCPListener:
(def
  ^{:doc "TCPListener is a TCP network listener. Clients should typically\nuse variables of type Listener instead of assuming TCP.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_TCPListener"}
  arrayOfTCPListener)

CLOJURE TYPE go.std.net/UDPAddr:
(def
  ^{:doc "UDPAddr represents the address of a UDP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPAddr"}
  UDPAddr)

CLOJURE TYPE go.std.net/refToUDPAddr:
(def
  ^{:doc "UDPAddr represents the address of a UDP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UDPAddr"}
  refToUDPAddr)

CLOJURE TYPE go.std.net/arrayOfUDPAddr:
(def
  ^{:doc "UDPAddr represents the address of a UDP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UDPAddr"}
  arrayOfUDPAddr)

CLOJURE TYPE go.std.net/UDPConn:
(def
  ^{:doc "UDPConn is the implementation of the Conn and PacketConn interfaces\nfor UDP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPConn"}
  UDPConn)

CLOJURE TYPE go.std.net/refToUDPConn:
(def
  ^{:doc "UDPConn is the implementation of the Conn and PacketConn interfaces\nfor UDP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UDPConn"}
  refToUDPConn)

CLOJURE TYPE go.std.net/arrayOfUDPConn:
(def
  ^{:doc "UDPConn is the implementation of the Conn and PacketConn interfaces\nfor UDP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UDPConn"}
  arrayOfUDPConn)

CLOJURE TYPE go.std.net/UnixAddr:
(def
  ^{:doc "UnixAddr represents the address of a Unix domain socket end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixAddr"}
  UnixAddr)

CLOJURE TYPE go.std.net/refToUnixAddr:
(def
  ^{:doc "UnixAddr represents the address of a Unix domain socket end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixAddr"}
  refToUnixAddr)

CLOJURE TYPE go.std.net/arrayOfUnixAddr:
(def
  ^{:doc "UnixAddr represents the address of a Unix domain socket end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UnixAddr"}
  arrayOfUnixAddr)

CLOJURE TYPE go.std.net/UnixConn:
(def
  ^{:doc "UnixConn is an implementation of the Conn interface for connections\nto Unix domain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixConn"}
  UnixConn)

CLOJURE TYPE go.std.net/refToUnixConn:
(def
  ^{:doc "UnixConn is an implementation of the Conn interface for connections\nto Unix domain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixConn"}
  refToUnixConn)

CLOJURE TYPE go.std.net/arrayOfUnixConn:
(def
  ^{:doc "UnixConn is an implementation of the Conn interface for connections\nto Unix domain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UnixConn"}
  arrayOfUnixConn)

CLOJURE TYPE go.std.net/UnixListener:
(def
  ^{:doc "UnixListener is a Unix domain socket listener. Clients should\ntypically use variables of type Listener instead of assuming Unix\ndomain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixListener"}
  UnixListener)

CLOJURE TYPE go.std.net/refToUnixListener:
(def
  ^{:doc "UnixListener is a Unix domain socket listener. Clients should\ntypically use variables of type Listener instead of assuming Unix\ndomain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixListener"}
  refToUnixListener)

CLOJURE TYPE go.std.net/arrayOfUnixListener:
(def
  ^{:doc "UnixListener is a Unix domain socket listener. Clients should\ntypically use variables of type Listener instead of assuming Unix\ndomain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UnixListener"}
  arrayOfUnixListener)

CLOJURE TYPE go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownNetworkError"}
  UnknownNetworkError)

CLOJURE TYPE go.std.net/refToUnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnknownNetworkError"}
  refToUnknownNetworkError)

CLOJURE TYPE go.std.net/arrayOfUnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_UnknownNetworkError"}
  arrayOfUnknownNetworkError)

CLOJURE CONSTANT DefaultMaxHeaderBytes from net/http/server.go:
(def
  ^{:doc "1 MB\n"
    :added "1.0"
    :tag "BigInt"
    :const true
    :go "int64(http.DefaultMaxHeaderBytes)"}
  DefaultMaxHeaderBytes)

CLOJURE CONSTANT DefaultMaxIdleConnsPerHost from net/http/transport.go:
(def
  ^{:doc "DefaultMaxIdleConnsPerHost is the default value of Transport's\nMaxIdleConnsPerHost.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.DefaultMaxIdleConnsPerHost"}
  DefaultMaxIdleConnsPerHost)

CLOJURE CONSTANT MethodConnect from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodConnect"}
  MethodConnect)

CLOJURE CONSTANT MethodDelete from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodDelete"}
  MethodDelete)

CLOJURE CONSTANT MethodGet from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodGet"}
  MethodGet)

CLOJURE CONSTANT MethodHead from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodHead"}
  MethodHead)

CLOJURE CONSTANT MethodOptions from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodOptions"}
  MethodOptions)

CLOJURE CONSTANT MethodPatch from net/http/method.go:
(def
  ^{:doc "RFC 5789\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodPatch"}
  MethodPatch)

CLOJURE CONSTANT MethodPost from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodPost"}
  MethodPost)

CLOJURE CONSTANT MethodPut from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodPut"}
  MethodPut)

CLOJURE CONSTANT MethodTrace from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.MethodTrace"}
  MethodTrace)

CLOJURE CONSTANT SameSiteDefaultMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.SameSiteDefaultMode)"}
  SameSiteDefaultMode)

CLOJURE CONSTANT SameSiteLaxMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.SameSiteLaxMode)"}
  SameSiteLaxMode)

CLOJURE CONSTANT SameSiteStrictMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.SameSiteStrictMode)"}
  SameSiteStrictMode)

CLOJURE CONSTANT StateActive from net/http/server.go:
(def
  ^{:doc "StateActive represents a connection that has read 1 or more\nbytes of a request. The Server.ConnState hook for\nStateActive fires before the request has entered a handler\nand doesn't fire again until the request has been\nhandled. After the request is handled, the state\ntransitions to StateClosed, StateHijacked, or StateIdle.\nFor HTTP/2, StateActive fires on the transition from zero\nto one active request, and only transitions away once all\nactive requests are complete. That means that ConnState\ncannot be used to do per-request work; ConnState only notes\nthe overall state of the connection.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.StateActive)"}
  StateActive)

CLOJURE CONSTANT StateClosed from net/http/server.go:
(def
  ^{:doc "StateClosed represents a closed connection.\nThis is a terminal state. Hijacked connections do not\ntransition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.StateClosed)"}
  StateClosed)

CLOJURE CONSTANT StateHijacked from net/http/server.go:
(def
  ^{:doc "StateHijacked represents a hijacked connection.\nThis is a terminal state. It does not transition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.StateHijacked)"}
  StateHijacked)

CLOJURE CONSTANT StateIdle from net/http/server.go:
(def
  ^{:doc "StateIdle represents a connection that has finished\nhandling a request and is in the keep-alive state, waiting\nfor a new request. Connections transition from StateIdle\nto either StateActive or StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.StateIdle)"}
  StateIdle)

CLOJURE CONSTANT StateNew from net/http/server.go:
(def
  ^{:doc "StateNew represents a new connection that is expected to\nsend a request immediately. Connections begin at this\nstate and then transition to either StateActive or\nStateClosed.\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "int(http.StateNew)"}
  StateNew)

CLOJURE CONSTANT StatusAccepted from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusAccepted"}
  StatusAccepted)

CLOJURE CONSTANT StatusAlreadyReported from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusAlreadyReported"}
  StatusAlreadyReported)

CLOJURE CONSTANT StatusBadGateway from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusBadGateway"}
  StatusBadGateway)

CLOJURE CONSTANT StatusBadRequest from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusBadRequest"}
  StatusBadRequest)

CLOJURE CONSTANT StatusConflict from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.8\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusConflict"}
  StatusConflict)

CLOJURE CONSTANT StatusContinue from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusContinue"}
  StatusContinue)

CLOJURE CONSTANT StatusCreated from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusCreated"}
  StatusCreated)

CLOJURE CONSTANT StatusExpectationFailed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.14\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusExpectationFailed"}
  StatusExpectationFailed)

CLOJURE CONSTANT StatusFailedDependency from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusFailedDependency"}
  StatusFailedDependency)

CLOJURE CONSTANT StatusForbidden from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusForbidden"}
  StatusForbidden)

CLOJURE CONSTANT StatusFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusFound"}
  StatusFound)

CLOJURE CONSTANT StatusGatewayTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusGatewayTimeout"}
  StatusGatewayTimeout)

CLOJURE CONSTANT StatusGone from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.9\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusGone"}
  StatusGone)

CLOJURE CONSTANT StatusHTTPVersionNotSupported from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.6\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusHTTPVersionNotSupported"}
  StatusHTTPVersionNotSupported)

CLOJURE CONSTANT StatusIMUsed from net/http/status.go:
(def
  ^{:doc "RFC 3229, 10.4.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusIMUsed"}
  StatusIMUsed)

CLOJURE CONSTANT StatusInsufficientStorage from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusInsufficientStorage"}
  StatusInsufficientStorage)

CLOJURE CONSTANT StatusInternalServerError from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusInternalServerError"}
  StatusInternalServerError)

CLOJURE CONSTANT StatusLengthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.10\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusLengthRequired"}
  StatusLengthRequired)

CLOJURE CONSTANT StatusLocked from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusLocked"}
  StatusLocked)

CLOJURE CONSTANT StatusLoopDetected from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusLoopDetected"}
  StatusLoopDetected)

CLOJURE CONSTANT StatusMethodNotAllowed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusMethodNotAllowed"}
  StatusMethodNotAllowed)

CLOJURE CONSTANT StatusMisdirectedRequest from net/http/status.go:
(def
  ^{:doc "RFC 7540, 9.1.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusMisdirectedRequest"}
  StatusMisdirectedRequest)

CLOJURE CONSTANT StatusMovedPermanently from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusMovedPermanently"}
  StatusMovedPermanently)

CLOJURE CONSTANT StatusMultiStatus from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusMultiStatus"}
  StatusMultiStatus)

CLOJURE CONSTANT StatusMultipleChoices from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusMultipleChoices"}
  StatusMultipleChoices)

CLOJURE CONSTANT StatusNetworkAuthenticationRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 6\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNetworkAuthenticationRequired"}
  StatusNetworkAuthenticationRequired)

CLOJURE CONSTANT StatusNoContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNoContent"}
  StatusNoContent)

CLOJURE CONSTANT StatusNonAuthoritativeInfo from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNonAuthoritativeInfo"}
  StatusNonAuthoritativeInfo)

CLOJURE CONSTANT StatusNotAcceptable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.6\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNotAcceptable"}
  StatusNotAcceptable)

CLOJURE CONSTANT StatusNotExtended from net/http/status.go:
(def
  ^{:doc "RFC 2774, 7\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNotExtended"}
  StatusNotExtended)

CLOJURE CONSTANT StatusNotFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNotFound"}
  StatusNotFound)

CLOJURE CONSTANT StatusNotImplemented from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNotImplemented"}
  StatusNotImplemented)

CLOJURE CONSTANT StatusNotModified from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusNotModified"}
  StatusNotModified)

CLOJURE CONSTANT StatusOK from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusOK"}
  StatusOK)

CLOJURE CONSTANT StatusPartialContent from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusPartialContent"}
  StatusPartialContent)

CLOJURE CONSTANT StatusPaymentRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusPaymentRequired"}
  StatusPaymentRequired)

CLOJURE CONSTANT StatusPermanentRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7538, 3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusPermanentRedirect"}
  StatusPermanentRedirect)

CLOJURE CONSTANT StatusPreconditionFailed from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusPreconditionFailed"}
  StatusPreconditionFailed)

CLOJURE CONSTANT StatusPreconditionRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusPreconditionRequired"}
  StatusPreconditionRequired)

CLOJURE CONSTANT StatusProcessing from net/http/status.go:
(def
  ^{:doc "RFC 2518, 10.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusProcessing"}
  StatusProcessing)

CLOJURE CONSTANT StatusProxyAuthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusProxyAuthRequired"}
  StatusProxyAuthRequired)

CLOJURE CONSTANT StatusRequestEntityTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.11\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusRequestEntityTooLarge"}
  StatusRequestEntityTooLarge)

CLOJURE CONSTANT StatusRequestHeaderFieldsTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 6585, 5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusRequestHeaderFieldsTooLarge"}
  StatusRequestHeaderFieldsTooLarge)

CLOJURE CONSTANT StatusRequestTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.7\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusRequestTimeout"}
  StatusRequestTimeout)

CLOJURE CONSTANT StatusRequestURITooLong from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.12\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusRequestURITooLong"}
  StatusRequestURITooLong)

CLOJURE CONSTANT StatusRequestedRangeNotSatisfiable from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusRequestedRangeNotSatisfiable"}
  StatusRequestedRangeNotSatisfiable)

CLOJURE CONSTANT StatusResetContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.6\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusResetContent"}
  StatusResetContent)

CLOJURE CONSTANT StatusSeeOther from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusSeeOther"}
  StatusSeeOther)

CLOJURE CONSTANT StatusServiceUnavailable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusServiceUnavailable"}
  StatusServiceUnavailable)

CLOJURE CONSTANT StatusSwitchingProtocols from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusSwitchingProtocols"}
  StatusSwitchingProtocols)

CLOJURE CONSTANT StatusTeapot from net/http/status.go:
(def
  ^{:doc "RFC 7168, 2.3.3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusTeapot"}
  StatusTeapot)

CLOJURE CONSTANT StatusTemporaryRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.7\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusTemporaryRedirect"}
  StatusTemporaryRedirect)

CLOJURE CONSTANT StatusTooManyRequests from net/http/status.go:
(def
  ^{:doc "RFC 6585, 4\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusTooManyRequests"}
  StatusTooManyRequests)

CLOJURE CONSTANT StatusUnauthorized from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUnauthorized"}
  StatusUnauthorized)

CLOJURE CONSTANT StatusUnavailableForLegalReasons from net/http/status.go:
(def
  ^{:doc "RFC 7725, 3\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUnavailableForLegalReasons"}
  StatusUnavailableForLegalReasons)

CLOJURE CONSTANT StatusUnprocessableEntity from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.2\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUnprocessableEntity"}
  StatusUnprocessableEntity)

CLOJURE CONSTANT StatusUnsupportedMediaType from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.13\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUnsupportedMediaType"}
  StatusUnsupportedMediaType)

CLOJURE CONSTANT StatusUpgradeRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.15\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUpgradeRequired"}
  StatusUpgradeRequired)

CLOJURE CONSTANT StatusUseProxy from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.5\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusUseProxy"}
  StatusUseProxy)

CLOJURE CONSTANT StatusVariantAlsoNegotiates from net/http/status.go:
(def
  ^{:doc "RFC 2295, 8.1\n"
    :added "1.0"
    :tag "Int"
    :const true
    :go "http.StatusVariantAlsoNegotiates"}
  StatusVariantAlsoNegotiates)

CLOJURE CONSTANT TimeFormat from net/http/server.go:
(def
  ^{:doc "TimeFormat is the time format to use when generating times in HTTP\nheaders. It is like time.RFC1123 but hard-codes GMT as the time\nzone. The time being formatted must be in UTC for Format to\ngenerate the correct format.\n\nFor parsing this time format, see ParseTime.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.TimeFormat"}
  TimeFormat)

CLOJURE CONSTANT TrailerPrefix from net/http/server.go:
(def
  ^{:doc "TrailerPrefix is a magic prefix for ResponseWriter.Header map keys\nthat, if present, signals that the map entry is actually for\nthe response trailers, and not the response headers. The prefix\nis stripped after the ServeHTTP call finishes and the values are\nsent in the trailers.\n\nThis mechanism is intended only for trailers that are not known\nprior to the headers being written. If the set of trailers is fixed\nor known before the header is written, the normal Go trailers mechanism\nis preferred:\n   https://golang.org/pkg/net/http/#ResponseWriter\n   https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "http.TrailerPrefix"}
  TrailerPrefix)

CLOJURE VARIABLE DefaultClient from net/http/client.go:
(def
  ^{:doc "DefaultClient is the default Client and is used by Get, Head, and Post.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultClient"}
  DefaultClient)

CLOJURE VARIABLE DefaultServeMux from net/http/server.go:
(def
  ^{:doc "DefaultServeMux is the default ServeMux used by Serve.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultServeMux"}
  DefaultServeMux)

CLOJURE VARIABLE DefaultTransport from net/http/transport.go:
(def
  ^{:doc "DefaultTransport is the default implementation of Transport and is\nused by DefaultClient. It establishes network connections as needed\nand caches them for reuse by subsequent calls. It uses HTTP proxies\nas directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and\n$no_proxy) environment variables.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultTransport"}
  DefaultTransport)

CLOJURE VARIABLE ErrAbortHandler from net/http/server.go:
(def
  ^{:doc "ErrAbortHandler is a sentinel panic value to abort a handler.\nWhile any panic from ServeHTTP aborts the response to the client,\npanicking with ErrAbortHandler also suppresses logging of a stack\ntrace to the server's error log.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrAbortHandler"}
  ErrAbortHandler)

CLOJURE VARIABLE ErrBodyNotAllowed from net/http/server.go:
(def
  ^{:doc "ErrBodyNotAllowed is returned by ResponseWriter.Write calls\nwhen the HTTP method or response code does not permit a\nbody.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyNotAllowed"}
  ErrBodyNotAllowed)

CLOJURE VARIABLE ErrBodyReadAfterClose from net/http/transfer.go:
(def
  ^{:doc "ErrBodyReadAfterClose is returned when reading a Request or Response\nBody after the body has been closed. This typically happens when the body is\nread after an HTTP Handler calls WriteHeader or Write on its\nResponseWriter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyReadAfterClose"}
  ErrBodyReadAfterClose)

CLOJURE VARIABLE ErrContentLength from net/http/server.go:
(def
  ^{:doc "ErrContentLength is returned by ResponseWriter.Write calls\nwhen a Handler set a Content-Length response header with a\ndeclared size and then attempted to write more bytes than\ndeclared.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrContentLength"}
  ErrContentLength)

CLOJURE VARIABLE ErrHandlerTimeout from net/http/server.go:
(def
  ^{:doc "ErrHandlerTimeout is returned on ResponseWriter Write calls\nin handlers which have timed out.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHandlerTimeout"}
  ErrHandlerTimeout)

CLOJURE VARIABLE ErrHeaderTooLong from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrHeaderTooLong is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHeaderTooLong"}
  ErrHeaderTooLong)

CLOJURE VARIABLE ErrHijacked from net/http/server.go:
(def
  ^{:doc "ErrHijacked is returned by ResponseWriter.Write calls when\nthe underlying connection has been hijacked using the\nHijacker interface. A zero-byte write on a hijacked\nconnection will return ErrHijacked without any other side\neffects.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHijacked"}
  ErrHijacked)

CLOJURE VARIABLE ErrLineTooLong from net/http/transfer.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading request or response bodies\nwith malformed chunked encoding.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrLineTooLong"}
  ErrLineTooLong)

CLOJURE VARIABLE ErrMissingBoundary from net/http/request.go:
(def
  ^{:doc "ErrMissingBoundary is returned by Request.MultipartReader when the\nrequest's Content-Type does not include a \"boundary\" parameter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingBoundary"}
  ErrMissingBoundary)

CLOJURE VARIABLE ErrMissingContentLength from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrMissingContentLength is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingContentLength"}
  ErrMissingContentLength)

CLOJURE VARIABLE ErrMissingFile from net/http/request.go:
(def
  ^{:doc "ErrMissingFile is returned by FormFile when the provided file field name\nis either not present in the request or not a file field.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingFile"}
  ErrMissingFile)

CLOJURE VARIABLE ErrNoCookie from net/http/request.go:
(def
  ^{:doc "ErrNoCookie is returned by Request's Cookie method when a cookie is not found.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoCookie"}
  ErrNoCookie)

CLOJURE VARIABLE ErrNoLocation from net/http/response.go:
(def
  ^{:doc "ErrNoLocation is returned by Response's Location method\nwhen no Location header is present.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoLocation"}
  ErrNoLocation)

CLOJURE VARIABLE ErrNotMultipart from net/http/request.go:
(def
  ^{:doc "ErrNotMultipart is returned by Request.MultipartReader when the\nrequest's Content-Type is not multipart/form-data.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotMultipart"}
  ErrNotMultipart)

CLOJURE VARIABLE ErrNotSupported from net/http/request.go:
(def
  ^{:doc "ErrNotSupported is returned by the Push method of Pusher\nimplementations to indicate that HTTP/2 Push support is not\navailable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotSupported"}
  ErrNotSupported)

CLOJURE VARIABLE ErrServerClosed from net/http/server.go:
(def
  ^{:doc "ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe,\nand ListenAndServeTLS methods after a call to Shutdown or Close.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrServerClosed"}
  ErrServerClosed)

CLOJURE VARIABLE ErrShortBody from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrShortBody is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrShortBody"}
  ErrShortBody)

CLOJURE VARIABLE ErrSkipAltProtocol from net/http/transport.go:
(def
  ^{:doc "ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrSkipAltProtocol"}
  ErrSkipAltProtocol)

CLOJURE VARIABLE ErrUnexpectedTrailer from net/http/request.go:
(def
  ^{:doc "ErrUnexpectedTrailer is returned by the Transport when a server\nreplies with a Trailer header, but without a chunked reply.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUnexpectedTrailer"}
  ErrUnexpectedTrailer)

CLOJURE VARIABLE ErrUseLastResponse from net/http/client.go:
(def
  ^{:doc "ErrUseLastResponse can be returned by Client.CheckRedirect hooks to\ncontrol how redirects are processed. If returned, the next request\nis not sent and the most recent response is returned with its body\nunclosed.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUseLastResponse"}
  ErrUseLastResponse)

CLOJURE VARIABLE ErrWriteAfterFlush from net/http/server.go:
(def
  ^{:doc "Deprecated: ErrWriteAfterFlush is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrWriteAfterFlush"}
  ErrWriteAfterFlush)

CLOJURE VARIABLE LocalAddrContextKey from net/http/server.go:
(def
  ^{:doc "LocalAddrContextKey is a context key. It can be used in\nHTTP handlers with context.WithValue to access the local\naddress the connection arrived on.\nThe associated value will be of type net.Addr.\n"
    :added "1.0"
    :tag "Var"
    :go "http.LocalAddrContextKey"}
  LocalAddrContextKey)

CLOJURE VARIABLE NoBody from net/http/http.go:
(def
  ^{:doc "NoBody is an io.ReadCloser with no bytes. Read always returns EOF\nand Close always returns nil. It can be used in an outgoing client\nrequest to explicitly signal that a request has zero bytes.\nAn alternative, however, is to simply set Request.Body to nil.\n"
    :added "1.0"
    :tag "Var"
    :go "http.NoBody"}
  NoBody)

CLOJURE VARIABLE ServerContextKey from net/http/server.go:
(def
  ^{:doc "ServerContextKey is a context key. It can be used in HTTP\nhandlers with context.WithValue to access the server that\nstarted the handler. The associated value will be of\ntype *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ServerContextKey"}
  ServerContextKey)

CLOJURE TYPE []*net/http.Cookie from net/http/cookie.go:
CLOJURE TYPE []net/http.Client from net/http/client.go:
CLOJURE TYPE []net/http.ConnState from net/http/server.go:
CLOJURE TYPE []net/http.Cookie from net/http/cookie.go:
CLOJURE TYPE []net/http.Dir from net/http/fs.go:
CLOJURE TYPE []net/http.HandlerFunc from net/http/server.go:
CLOJURE TYPE []net/http.Header from net/http/header.go:
CLOJURE TYPE []net/http.ProtocolError from net/http/request.go:
CLOJURE TYPE []net/http.PushOptions from net/http/http.go:
CLOJURE TYPE []net/http.Request from net/http/request.go:
CLOJURE TYPE []net/http.Response from net/http/response.go:
CLOJURE TYPE []net/http.SameSite from net/http/cookie.go:
CLOJURE TYPE []net/http.ServeMux from net/http/server.go:
CLOJURE TYPE []net/http.Server from net/http/server.go:
CLOJURE TYPE []net/http.Transport from net/http/transport.go:
CLOJURE TYPE net/http.Client from net/http/client.go:
CLOJURE TYPE *net/http.Client from net/http/client.go:
CLOJURE TYPE net/http.CloseNotifier from net/http/server.go:
CLOJURE TYPE net/http.ConnState from net/http/server.go:
CLOJURE TYPE *net/http.ConnState from net/http/server.go:
CLOJURE TYPE net/http.Cookie from net/http/cookie.go:
CLOJURE TYPE *net/http.Cookie from net/http/cookie.go:
CLOJURE TYPE net/http.CookieJar from net/http/jar.go:
CLOJURE TYPE net/http.Dir from net/http/fs.go:
CLOJURE TYPE *net/http.Dir from net/http/fs.go:
CLOJURE TYPE net/http.File from net/http/fs.go:
CLOJURE TYPE net/http.FileSystem from net/http/fs.go:
CLOJURE TYPE net/http.Flusher from net/http/server.go:
CLOJURE TYPE net/http.Handler from net/http/server.go:
CLOJURE TYPE net/http.HandlerFunc from net/http/server.go:
CLOJURE TYPE *net/http.HandlerFunc from net/http/server.go:
CLOJURE TYPE net/http.Header from net/http/header.go:
CLOJURE TYPE *net/http.Header from net/http/header.go:
CLOJURE TYPE net/http.Hijacker from net/http/server.go:
CLOJURE TYPE net/http.ProtocolError from net/http/request.go:
CLOJURE TYPE *net/http.ProtocolError from net/http/request.go:
CLOJURE TYPE net/http.PushOptions from net/http/http.go:
CLOJURE TYPE *net/http.PushOptions from net/http/http.go:
CLOJURE TYPE net/http.Pusher from net/http/http.go:
CLOJURE TYPE net/http.Request from net/http/request.go:
CLOJURE TYPE *net/http.Request from net/http/request.go:
CLOJURE TYPE net/http.Response from net/http/response.go:
CLOJURE TYPE *net/http.Response from net/http/response.go:
CLOJURE TYPE net/http.ResponseWriter from net/http/server.go:
CLOJURE TYPE net/http.RoundTripper from net/http/client.go:
CLOJURE TYPE net/http.SameSite from net/http/cookie.go:
CLOJURE TYPE *net/http.SameSite from net/http/cookie.go:
CLOJURE TYPE net/http.ServeMux from net/http/server.go:
CLOJURE TYPE *net/http.ServeMux from net/http/server.go:
CLOJURE TYPE net/http.Server from net/http/server.go:
CLOJURE TYPE *net/http.Server from net/http/server.go:
CLOJURE TYPE net/http.Transport from net/http/transport.go:
CLOJURE TYPE *net/http.Transport from net/http/transport.go:
CLOJURE FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/http.DetectContentType from net/http/sniff.go:
(defn ^"String" DetectContentType
  "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo returns: string\n\nJoker input arguments: [^arrayOfByte data]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "http.DetectContentType(_v_data)"}
  [^arrayOfByte _v_data])

CLOJURE FUNC net/http.Error from net/http/server.go:
(defn Error
  "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^ResponseWriter w, ^String error, ^Int code]"
  {:added "1.0"
   :go "_f_error(_v_w, _v_error, _v_code)"}
  [^go.std.net.http/ResponseWriter _v_w, ^String _v_error, ^Int _v_code])

CLOJURE FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo returns: Handler\n\nJoker input arguments: [^FileSystem root]\n\nJoker returns: ^Handler"
  {:added "1.0"
   :go "_f_fileServer(_v_root)"}
  [^go.std.net.http/FileSystem _v_root])

CLOJURE FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo returns: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker returns: [^refToResponse resp, ^Error err]"
  {:added "1.0"
   :go "_f_get(_v_url)"}
  [^String _v_url])

CLOJURE FUNC net/http.Handle from net/http/server.go:
(defn Handle
  "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^Handler handler]"
  {:added "1.0"
   :go "_f_handle(_v_pattern, _v_handler)"}
  [^String _v_pattern, ^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler ABEND727(gtypes.go: func(ResponseWriter,*Request) not supported))\n\nJoker input arguments: [^String pattern, ^ABEND727(jtypes.go: func(ResponseWriter,*Request) not supported) handler]"
;;   {:added "1.0"
;;    :go "_f_handleFunc(_v_pattern, _v_handler)"}
;;   [^String _v_pattern, ^ABEND727(jtypes.go: func(ResponseWriter,*Request) not supported) _v_handler])

CLOJURE FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo returns: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker returns: [^refToResponse resp, ^Error err]"
  {:added "1.0"
   :go "_f_head(_v_url)"}
  [^String _v_url])

CLOJURE FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo returns: error\n\nJoker input arguments: [^String addr, ^Handler handler]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "http.ListenAndServe(_v_addr, _v_handler)"}
  [^String _v_addr, ^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo returns: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^Handler handler]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(_v_addr, _v_certFile, _v_keyFile, _v_handler)"}
  [^String _v_addr, ^String _v_certFile, ^String _v_keyFile, ^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r ABEND002(reference to unavailable package `io' looking for type `ReadCloser'), n int64)\n\nGo returns: ABEND002(reference to unavailable package `io' looking for type `ReadCloser')\n\nJoker input arguments: [^ResponseWriter w, ^go.std.io/ReadCloser r, ^BigInt n]\n\nJoker returns: ^go.std.io/ReadCloser"
;;   {:added "1.0"
;;    :go "_f_maxBytesReader(_v_w, _v_r, _v_n)"}
;;   [^go.std.net.http/ResponseWriter _v_w, ^ABEND707(API 'go.std.io/Extract_ns_ReadCloser' is unimplemented: go.std.io/ReadCloser) _v_r, ^Int64 _v_n])

CLOJURE FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo returns: RoundTripper\n\nJoker input arguments: [^FileSystem fs]\n\nJoker returns: ^RoundTripper"
  {:added "1.0"
   :go "_f_newFileTransport(_v_fs)"}
  [^go.std.net.http/FileSystem _v_fs])

CLOJURE FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body ABEND002(reference to unavailable package `io' looking for type `Reader'))\n\nGo returns: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker returns: [^refToRequest, ^Error]"
;;   {:added "1.0"
;;    :go "_f_newRequest(_v_method, _v_url, _v_body)"}
;;   [^String _v_method, ^String _v_url, ^ABEND707(API 'go.std.io/Extract_ns_Reader' is unimplemented: go.std.io/Reader) _v_body])

CLOJURE FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo returns: *ServeMux\n\nJoker input arguments: []\n\nJoker returns: ^refToServeMux"
  {:added "1.0"
   :go "_f_newServeMux()"}
  [])

CLOJURE FUNC net/http.NotFound from net/http/server.go:
(defn NotFound
  "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^ResponseWriter w, ^refToRequest r]"
  {:added "1.0"
   :go "_f_notFound(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo returns: Handler\n\nJoker input arguments: []\n\nJoker returns: ^Handler"
  {:added "1.0"
   :go "_f_notFoundHandler()"}
  [])

CLOJURE FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo returns: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker returns: [^Int major, ^Int minor, ^Boolean ok]"
  {:added "1.0"
   :go "_f_parseHTTPVersion(_v_vers)"}
  [^String _v_vers])

CLOJURE FUNC net/http.ParseTime from net/http/header.go:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo returns: (t ABEND002(reference to unavailable package `time' looking for type `Time'), err error)\n\nJoker input arguments: [^String text]\n\nJoker returns: [^go.std.time/Time t, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_parseTime(_v_text)"}
;;   [^String _v_text])

CLOJURE FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body ABEND002(reference to unavailable package `io' looking for type `Reader'))\n\nGo returns: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker returns: [^refToResponse resp, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_post(_v_url, _v_contentType, _v_body)"}
;;   [^String _v_url, ^String _v_contentType, ^ABEND707(API 'go.std.io/Extract_ns_Reader' is unimplemented: go.std.io/Reader) _v_body])

CLOJURE FUNC net/http.PostForm from net/http/client.go:
(defn PostForm
  "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data net/url.Values)\n\nGo returns: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker returns: [^refToResponse resp, ^Error err]"
  {:added "1.0"
   :go "_f_postForm(_v_url, *_v_data)"}
  [^String _v_url, ^go.std.net.url/Values _v_data])

CLOJURE FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo returns: (*net/url.URL, error)\n\nJoker input arguments: [^refToRequest req]\n\nJoker returns: [^go.std.net.url/refToURL, ^Error]"
  {:added "1.0"
   :go "_f_proxyFromEnvironment(_v_req)"}
  [^go.std.net.http/refToRequest _v_req])

CLOJURE FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *net/url.URL)\n\nGo returns: ABEND727(gtypes.go: func(*Request)(*url.URL,error) not supported)\n\nJoker input arguments: [^go.std.net.url/refToURL fixedURL]\n\nJoker returns: ^ABEND727(jtypes.go: func(*Request)(*url.URL,error) not supported)"
;;   {:added "1.0"
;;    :go "_f_proxyURL(_v_fixedURL)"}
;;   [^go.std.net.url/refToURL _v_fixedURL])

CLOJURE FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))\n\nGo returns: (*Request, error)\n\nJoker input arguments: [^go.std.bufio/refToReader b]\n\nJoker returns: [^refToRequest, ^Error]"
;;   {:added "1.0"
;;    :go "_f_readRequest(_v_b)"}
;;   [^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_b])

CLOJURE FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'), req *Request)\n\nGo returns: (*Response, error)\n\nJoker input arguments: [^go.std.bufio/refToReader r, ^refToRequest req]\n\nJoker returns: [^refToResponse, ^Error]"
;;   {:added "1.0"
;;    :go "_f_readResponse(_v_r, _v_req)"}
;;   [^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_r, ^go.std.net.http/refToRequest _v_req])

CLOJURE FUNC net/http.Redirect from net/http/server.go:
(defn Redirect
  "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^ResponseWriter w, ^refToRequest r, ^String url, ^Int code]"
  {:added "1.0"
   :go "_f_redirect(_v_w, _v_r, _v_url, _v_code)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r, ^String _v_url, ^Int _v_code])

CLOJURE FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo returns: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker returns: ^Handler"
  {:added "1.0"
   :go "_f_redirectHandler(_v_url, _v_code)"}
  [^String _v_url, ^Int _v_code])

CLOJURE FUNC net/http.Serve from net/http/server.go:
(defn ^"Error" Serve
  "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo returns: error\n\nJoker input arguments: [^go.std.net/Listener l, ^Handler handler]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "http.Serve(_v_l, _v_handler)"}
  [^go.std.net/Listener _v_l, ^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime ABEND002(reference to unavailable package `time' looking for type `Time'), content ABEND002(reference to unavailable package `io' looking for type `ReadSeeker'))\n\nJoker input arguments: [^ResponseWriter w, ^refToRequest req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "_f_serveContent(_v_w, _v_req, _v_name, _v_modtime, _v_content)"}
;;   [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_req, ^String _v_name, ^ABEND707(API 'go.std.time/Extract_ns_Time' is unimplemented: go.std.time/Time) _v_modtime, ^ABEND707(API 'go.std.io/Extract_ns_ReadSeeker' is unimplemented: go.std.io/ReadSeeker) _v_content])

CLOJURE FUNC net/http.ServeFile from net/http/fs.go:
(defn ServeFile
  "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^ResponseWriter w, ^refToRequest r, ^String name]"
  {:added "1.0"
   :go "_f_serveFile(_v_w, _v_r, _v_name)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r, ^String _v_name])

CLOJURE FUNC net/http.ServeTLS from net/http/server.go:
(defn ^"Error" ServeTLS
  "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo returns: error\n\nJoker input arguments: [^go.std.net/Listener l, ^Handler handler, ^String certFile, ^String keyFile]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "http.ServeTLS(_v_l, _v_handler, _v_certFile, _v_keyFile)"}
  [^go.std.net/Listener _v_l, ^go.std.net.http/Handler _v_handler, ^String _v_certFile, ^String _v_keyFile])

CLOJURE FUNC net/http.SetCookie from net/http/cookie.go:
(defn SetCookie
  "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^ResponseWriter w, ^refToCookie cookie]"
  {:added "1.0"
   :go "_f_setCookie(_v_w, _v_cookie)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToCookie _v_cookie])

CLOJURE FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo returns: string\n\nJoker input arguments: [^Int code]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "http.StatusText(_v_code)"}
  [^Int _v_code])

CLOJURE FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo returns: Handler\n\nJoker input arguments: [^String prefix, ^Handler h]\n\nJoker returns: ^Handler"
  {:added "1.0"
   :go "_f_stripPrefix(_v_prefix, _v_h)"}
  [^String _v_prefix, ^go.std.net.http/Handler _v_h])

CLOJURE FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt ABEND002(reference to unavailable package `time' looking for type `Duration'), msg string)\n\nGo returns: Handler\n\nJoker input arguments: [^Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker returns: ^Handler"
;;   {:added "1.0"
;;    :go "_f_timeoutHandler(_v_h, _v_dt, _v_msg)"}
;;   [^go.std.net.http/Handler _v_h, ^ABEND707(API 'go.std.time/Extract_ns_Duration' is unimplemented: go.std.time/Duration) _v_dt, ^String _v_msg])

CLOJURE TYPE go.std.net.http/Client:
(def
  ^{:doc "A Client is an HTTP client. Its zero value (DefaultClient) is a\nusable client that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as\nneeded. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport)\nand additionally handles HTTP details such as cookies and\nredirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n when forwarding sensitive headers like \"Authorization\",\n\"WWW-Authenticate\", and \"Cookie\" to untrusted targets.\nThese headers will be ignored when following a redirect to a domain\nthat is not a subdomain match or exact match of the initial domain.\nFor example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\nwill forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\n when forwarding the \"Cookie\" header with a non-nil cookie Jar.\nSince each redirect may mutate the state of the cookie jar,\na redirect may possibly alter a cookie set in the initial request.\nWhen forwarding the \"Cookie\" header, any mutated cookies will be omitted,\nwith the expectation that the Jar will insert those mutated cookies\nwith the updated values (assuming the origin matches).\nIf Jar is nil, the initial cookies are forwarded without change.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

CLOJURE TYPE go.std.net.http/refToClient:
(def
  ^{:doc "A Client is an HTTP client. Its zero value (DefaultClient) is a\nusable client that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as\nneeded. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport)\nand additionally handles HTTP details such as cookies and\nredirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n when forwarding sensitive headers like \"Authorization\",\n\"WWW-Authenticate\", and \"Cookie\" to untrusted targets.\nThese headers will be ignored when following a redirect to a domain\nthat is not a subdomain match or exact match of the initial domain.\nFor example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\nwill forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\n when forwarding the \"Cookie\" header with a non-nil cookie Jar.\nSince each redirect may mutate the state of the cookie jar,\na redirect may possibly alter a cookie set in the initial request.\nWhen forwarding the \"Cookie\" header, any mutated cookies will be omitted,\nwith the expectation that the Jar will insert those mutated cookies\nwith the updated values (assuming the origin matches).\nIf Jar is nil, the initial cookies are forwarded without change.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  refToClient)

CLOJURE TYPE go.std.net.http/arrayOfClient:
(def
  ^{:doc "A Client is an HTTP client. Its zero value (DefaultClient) is a\nusable client that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as\nneeded. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport)\nand additionally handles HTTP details such as cookies and\nredirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n when forwarding sensitive headers like \"Authorization\",\n\"WWW-Authenticate\", and \"Cookie\" to untrusted targets.\nThese headers will be ignored when following a redirect to a domain\nthat is not a subdomain match or exact match of the initial domain.\nFor example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\nwill forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\n when forwarding the \"Cookie\" header with a non-nil cookie Jar.\nSince each redirect may mutate the state of the cookie jar,\na redirect may possibly alter a cookie set in the initial request.\nWhen forwarding the \"Cookie\" header, any mutated cookies will be omitted,\nwith the expectation that the Jar will insert those mutated cookies\nwith the updated values (assuming the origin matches).\nIf Jar is nil, the initial cookies are forwarded without change.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Client"}
  arrayOfClient)

CLOJURE TYPE go.std.net.http/CloseNotifier:
(def
  ^{:doc "The CloseNotifier interface is implemented by ResponseWriters which\nallow detecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server\nif the client has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package.\nNew code should use Request.Context instead.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_CloseNotifier"}
  CloseNotifier)

CLOJURE TYPE go.std.net.http/ConnState:
(def
  ^{:doc "A ConnState represents the state of a client connection to a server.\nIt's used by the optional Server.ConnState hook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnState"}
  ConnState)

CLOJURE TYPE go.std.net.http/refToConnState:
(def
  ^{:doc "A ConnState represents the state of a client connection to a server.\nIt's used by the optional Server.ConnState hook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ConnState"}
  refToConnState)

CLOJURE TYPE go.std.net.http/arrayOfConnState:
(def
  ^{:doc "A ConnState represents the state of a client connection to a server.\nIt's used by the optional Server.ConnState hook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ConnState"}
  arrayOfConnState)

CLOJURE TYPE go.std.net.http/Cookie:
(def
  ^{:doc "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cookie"}
  Cookie)

CLOJURE TYPE go.std.net.http/refToCookie:
(def
  ^{:doc "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Cookie"}
  refToCookie)

CLOJURE TYPE go.std.net.http/CookieJar:
(def
  ^{:doc "A CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple\ngoroutines.\n\nThe net/http/cookiejar package provides a CookieJar implementation.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_CookieJar"}
  CookieJar)

CLOJURE TYPE go.std.net.http/arrayOfCookie:
(def
  ^{:doc "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Cookie"}
  arrayOfCookie)

CLOJURE TYPE go.std.net.http/Dir:
(def
  ^{:doc "A Dir implements FileSystem using the native file system restricted to a\nspecific directory tree.\n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string\nvalue is a filename on the native file system, not a URL, so it is separated\nby filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir will allow access to files and directories starting with a\nperiod, which could expose sensitive directories like a .git directory or\nsensitive files like .htpasswd. To exclude files with a leading period,\nremove the files/directories from the server or create a custom FileSystem\nimplementation.\n\nAn empty Dir is treated as \".\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dir"}
  Dir)

CLOJURE TYPE go.std.net.http/refToDir:
(def
  ^{:doc "A Dir implements FileSystem using the native file system restricted to a\nspecific directory tree.\n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string\nvalue is a filename on the native file system, not a URL, so it is separated\nby filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir will allow access to files and directories starting with a\nperiod, which could expose sensitive directories like a .git directory or\nsensitive files like .htpasswd. To exclude files with a leading period,\nremove the files/directories from the server or create a custom FileSystem\nimplementation.\n\nAn empty Dir is treated as \".\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Dir"}
  refToDir)

CLOJURE TYPE go.std.net.http/arrayOfDir:
(def
  ^{:doc "A Dir implements FileSystem using the native file system restricted to a\nspecific directory tree.\n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string\nvalue is a filename on the native file system, not a URL, so it is separated\nby filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir will allow access to files and directories starting with a\nperiod, which could expose sensitive directories like a .git directory or\nsensitive files like .htpasswd. To exclude files with a leading period,\nremove the files/directories from the server or create a custom FileSystem\nimplementation.\n\nAn empty Dir is treated as \".\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Dir"}
  arrayOfDir)

CLOJURE TYPE go.std.net.http/File:
(def
  ^{:doc "A File is returned by a FileSystem's Open method and can be\nserved by the FileServer implementation.\n\nThe methods should behave the same as those on an *os.File.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_File"}
  File)

CLOJURE TYPE go.std.net.http/FileSystem:
(def
  ^{:doc "A FileSystem implements access to a collection of named files.\nThe elements in a file path are separated by slash ('/', U+002F)\ncharacters, regardless of host operating system convention.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_FileSystem"}
  FileSystem)

CLOJURE TYPE go.std.net.http/Flusher:
(def
  ^{:doc "The Flusher interface is implemented by ResponseWriters that allow\nan HTTP handler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations\nsupport Flusher, but ResponseWriter wrappers may not. Handlers\nshould always test for this ability at runtime.\n\nNote that even for ResponseWriters that support Flush,\nif the client is connected through an HTTP proxy,\nthe buffered data may not reach the client until the response\ncompletes.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_Flusher"}
  Flusher)

CLOJURE TYPE go.std.net.http/Handler:
(def
  ^{:doc "A Handler responds to an HTTP request.\n\nServeHTTP should write reply headers and data to the ResponseWriter\nand then return. Returning signals that the request is finished; it\nis not valid to use the ResponseWriter or read from the\nRequest.Body after or concurrently with the completion of the\nServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and\nany intermediaries between the client and the Go server, it may not\nbe possible to read from the Request.Body after writing to the\nResponseWriter. Cautious handlers should read the Request.Body\nfirst, and then reply.\n\nExcept for reading the body, handlers should not modify the\nprovided Request.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes\nthat the effect of the panic was isolated to the active request.\nIt recovers the panic, logs a stack trace to the server error log,\nand either closes the network connection or sends an HTTP/2\nRST_STREAM, depending on the HTTP protocol. To abort a handler so\nthe client sees an interrupted response but the server doesn't log\nan error, panic with the value ErrAbortHandler.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_Handler"}
  Handler)

CLOJURE TYPE go.std.net.http/HandlerFunc:
(def
  ^{:doc "The HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers. If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler that calls f.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HandlerFunc"}
  HandlerFunc)

CLOJURE TYPE go.std.net.http/refToHandlerFunc:
(def
  ^{:doc "The HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers. If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler that calls f.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_HandlerFunc"}
  refToHandlerFunc)

CLOJURE TYPE go.std.net.http/arrayOfHandlerFunc:
(def
  ^{:doc "The HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers. If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler that calls f.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_HandlerFunc"}
  arrayOfHandlerFunc)

CLOJURE TYPE go.std.net.http/Header:
(def
  ^{:doc "A Header represents the key-value pairs in an HTTP header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

CLOJURE TYPE go.std.net.http/refToHeader:
(def
  ^{:doc "A Header represents the key-value pairs in an HTTP header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Header"}
  refToHeader)

CLOJURE TYPE go.std.net.http/arrayOfHeader:
(def
  ^{:doc "A Header represents the key-value pairs in an HTTP header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Header"}
  arrayOfHeader)

CLOJURE TYPE go.std.net.http/Hijacker:
(def
  ^{:doc "The Hijacker interface is implemented by ResponseWriters that allow\nan HTTP handler to take over the connection.\n\nThe default ResponseWriter for HTTP/1.x connections supports\nHijacker, but HTTP/2 connections intentionally do not.\nResponseWriter wrappers may also not support Hijacker. Handlers\nshould always test for this ability at runtime.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_Hijacker"}
  Hijacker)

CLOJURE TYPE go.std.net.http/ProtocolError:
(def
  ^{:doc "ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

CLOJURE TYPE go.std.net.http/refToProtocolError:
(def
  ^{:doc "ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ProtocolError"}
  refToProtocolError)

CLOJURE TYPE go.std.net.http/arrayOfProtocolError:
(def
  ^{:doc "ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ProtocolError"}
  arrayOfProtocolError)

CLOJURE TYPE go.std.net.http/PushOptions:
(def
  ^{:doc "PushOptions describes options for Pusher.Push.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PushOptions"}
  PushOptions)

CLOJURE TYPE go.std.net.http/refToPushOptions:
(def
  ^{:doc "PushOptions describes options for Pusher.Push.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_PushOptions"}
  refToPushOptions)

CLOJURE TYPE go.std.net.http/arrayOfPushOptions:
(def
  ^{:doc "PushOptions describes options for Pusher.Push.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_PushOptions"}
  arrayOfPushOptions)

CLOJURE TYPE go.std.net.http/Pusher:
(def
  ^{:doc "Pusher is the interface implemented by ResponseWriters that support\nHTTP/2 server push. For more background, see\nhttps://tools.ietf.org/html/rfc7540#section-8.2.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_Pusher"}
  Pusher)

CLOJURE TYPE go.std.net.http/Request:
(def
  ^{:doc "A Request represents an HTTP request received by a server\nor to be sent by a client.\n\nThe field semantics differ slightly between client and server\nusage. In addition to the notes on the fields below, see the\ndocumentation for Request.Write and RoundTripper.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

CLOJURE TYPE go.std.net.http/refToRequest:
(def
  ^{:doc "A Request represents an HTTP request received by a server\nor to be sent by a client.\n\nThe field semantics differ slightly between client and server\nusage. In addition to the notes on the fields below, see the\ndocumentation for Request.Write and RoundTripper.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Request"}
  refToRequest)

CLOJURE TYPE go.std.net.http/arrayOfRequest:
(def
  ^{:doc "A Request represents an HTTP request received by a server\nor to be sent by a client.\n\nThe field semantics differ slightly between client and server\nusage. In addition to the notes on the fields below, see the\ndocumentation for Request.Write and RoundTripper.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Request"}
  arrayOfRequest)

CLOJURE TYPE go.std.net.http/Response:
(def
  ^{:doc "Response represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once\nthe response headers have been received. The response body\nis streamed on demand as the Body field is read.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

CLOJURE TYPE go.std.net.http/refToResponse:
(def
  ^{:doc "Response represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once\nthe response headers have been received. The response body\nis streamed on demand as the Body field is read.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Response"}
  refToResponse)

CLOJURE TYPE go.std.net.http/ResponseWriter:
(def
  ^{:doc "A ResponseWriter interface is used by an HTTP handler to\nconstruct an HTTP response.\n\nA ResponseWriter may not be used after the Handler.ServeHTTP method\nhas returned.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 3
    :go "&info_ResponseWriter"}
  ResponseWriter)

CLOJURE TYPE go.std.net.http/arrayOfResponse:
(def
  ^{:doc "Response represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once\nthe response headers have been received. The response body\nis streamed on demand as the Body field is read.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Response"}
  arrayOfResponse)

CLOJURE TYPE go.std.net.http/RoundTripper:
(def
  ^{:doc "RoundTripper is an interface representing the ability to execute a\nsingle HTTP transaction, obtaining the Response for a given Request.\n\nA RoundTripper must be safe for concurrent use by multiple\ngoroutines.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 1
    :go "&info_RoundTripper"}
  RoundTripper)

CLOJURE TYPE go.std.net.http/SameSite:
(def
  ^{:doc "SameSite allows a server define a cookie attribute making it impossible to\nthe browser send this cookie along with cross-site requests. The main goal\nis mitigate the risk of cross-origin information leakage, and provides some\nprotection against cross-site request forgery attacks.\n\nSee https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SameSite"}
  SameSite)

CLOJURE TYPE go.std.net.http/refToSameSite:
(def
  ^{:doc "SameSite allows a server define a cookie attribute making it impossible to\nthe browser send this cookie along with cross-site requests. The main goal\nis mitigate the risk of cross-origin information leakage, and provides some\nprotection against cross-site request forgery attacks.\n\nSee https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SameSite"}
  refToSameSite)

CLOJURE TYPE go.std.net.http/arrayOfSameSite:
(def
  ^{:doc "SameSite allows a server define a cookie attribute making it impossible to\nthe browser send this cookie along with cross-site requests. The main goal\nis mitigate the risk of cross-origin information leakage, and provides some\nprotection against cross-site request forgery attacks.\n\nSee https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_SameSite"}
  arrayOfSameSite)

CLOJURE TYPE go.std.net.http/ServeMux:
(def
  ^{:doc "ServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n\nPatterns name fixed, rooted paths, like \"/favicon.ico\",\nor rooted subtrees, like \"/images/\" (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both \"/images/\"\nand \"/images/thumbnails/\", the latter handler will be\ncalled for paths beginning \"/images/thumbnails/\" and the\nformer will receive requests for any other paths in the\n\"/images/\" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree,\nthe pattern \"/\" matches all paths not matched by other registered\npatterns, not just the URL with Path == \"/\".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that\nrequest to the subtree root (adding the trailing slash). This behavior can\nbe overridden with a separate registration for the path without\nthe trailing slash. For example, registering \"/images/\" causes ServeMux\nto redirect a request for \"/images\" to \"/images/\", unless \"/images\" has\nbeen registered separately.\n\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only. Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n\"/codesearch\" and \"codesearch.google.com/\" without also taking over\nrequests for \"http://www.google.com/\".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing . or\n.. elements or repeated slashes to an equivalent, cleaner URL.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServeMux"}
  ServeMux)

CLOJURE TYPE go.std.net.http/refToServeMux:
(def
  ^{:doc "ServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n\nPatterns name fixed, rooted paths, like \"/favicon.ico\",\nor rooted subtrees, like \"/images/\" (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both \"/images/\"\nand \"/images/thumbnails/\", the latter handler will be\ncalled for paths beginning \"/images/thumbnails/\" and the\nformer will receive requests for any other paths in the\n\"/images/\" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree,\nthe pattern \"/\" matches all paths not matched by other registered\npatterns, not just the URL with Path == \"/\".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that\nrequest to the subtree root (adding the trailing slash). This behavior can\nbe overridden with a separate registration for the path without\nthe trailing slash. For example, registering \"/images/\" causes ServeMux\nto redirect a request for \"/images\" to \"/images/\", unless \"/images\" has\nbeen registered separately.\n\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only. Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n\"/codesearch\" and \"codesearch.google.com/\" without also taking over\nrequests for \"http://www.google.com/\".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing . or\n.. elements or repeated slashes to an equivalent, cleaner URL.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServeMux"}
  refToServeMux)

CLOJURE TYPE go.std.net.http/arrayOfServeMux:
(def
  ^{:doc "ServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n\nPatterns name fixed, rooted paths, like \"/favicon.ico\",\nor rooted subtrees, like \"/images/\" (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both \"/images/\"\nand \"/images/thumbnails/\", the latter handler will be\ncalled for paths beginning \"/images/thumbnails/\" and the\nformer will receive requests for any other paths in the\n\"/images/\" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree,\nthe pattern \"/\" matches all paths not matched by other registered\npatterns, not just the URL with Path == \"/\".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that\nrequest to the subtree root (adding the trailing slash). This behavior can\nbe overridden with a separate registration for the path without\nthe trailing slash. For example, registering \"/images/\" causes ServeMux\nto redirect a request for \"/images\" to \"/images/\", unless \"/images\" has\nbeen registered separately.\n\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only. Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n\"/codesearch\" and \"codesearch.google.com/\" without also taking over\nrequests for \"http://www.google.com/\".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing . or\n.. elements or repeated slashes to an equivalent, cleaner URL.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ServeMux"}
  arrayOfServeMux)

CLOJURE TYPE go.std.net.http/Server:
(def
  ^{:doc "A Server defines parameters for running an HTTP server.\nThe zero value for Server is a valid configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

CLOJURE TYPE go.std.net.http/refToServer:
(def
  ^{:doc "A Server defines parameters for running an HTTP server.\nThe zero value for Server is a valid configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  refToServer)

CLOJURE TYPE go.std.net.http/arrayOfServer:
(def
  ^{:doc "A Server defines parameters for running an HTTP server.\nThe zero value for Server is a valid configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Server"}
  arrayOfServer)

CLOJURE TYPE go.std.net.http/Transport:
(def
  ^{:doc "Transport is an implementation of RoundTripper that supports HTTP,\nHTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use.\nThis may leave many open connections when accessing many hosts.\nThis behavior can be managed using Transport's CloseIdleConnections method\nand the MaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed.\nTransports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests.\nFor high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\nfor HTTPS URLs, depending on whether the server supports HTTP/2,\nand how the Transport is configured. The DefaultTransport supports HTTP/2.\nTo explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\nand call ConfigureTransport. See the package docs for more about HTTP/2.\n\nThe Transport will send CONNECT requests to a proxy for its own use\nwhen processing HTTPS requests, but Transport should generally not\nbe used to send a CONNECT request. That is, the Request passed to\nthe RoundTrip method should not have a Method of \"CONNECT\", as Go's\nHTTP/1.x implementation does not support full-duplex request bodies\nbeing written while the response body is streamed. Go's HTTP/2\nimplementation does support full duplex, but many CONNECT proxies speak\nHTTP/1.x.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one\nexception is HTTP status code 101 (Switching Protocols), which is\nconsidered a terminal status and returned by RoundTrip. To see the\nignored 1xx responses, use the httptrace trace package's\nClientTrace.Got1xxResponse.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Transport"}
  Transport)

CLOJURE TYPE go.std.net.http/refToTransport:
(def
  ^{:doc "Transport is an implementation of RoundTripper that supports HTTP,\nHTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use.\nThis may leave many open connections when accessing many hosts.\nThis behavior can be managed using Transport's CloseIdleConnections method\nand the MaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed.\nTransports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests.\nFor high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\nfor HTTPS URLs, depending on whether the server supports HTTP/2,\nand how the Transport is configured. The DefaultTransport supports HTTP/2.\nTo explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\nand call ConfigureTransport. See the package docs for more about HTTP/2.\n\nThe Transport will send CONNECT requests to a proxy for its own use\nwhen processing HTTPS requests, but Transport should generally not\nbe used to send a CONNECT request. That is, the Request passed to\nthe RoundTrip method should not have a Method of \"CONNECT\", as Go's\nHTTP/1.x implementation does not support full-duplex request bodies\nbeing written while the response body is streamed. Go's HTTP/2\nimplementation does support full duplex, but many CONNECT proxies speak\nHTTP/1.x.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one\nexception is HTTP status code 101 (Switching Protocols), which is\nconsidered a terminal status and returned by RoundTrip. To see the\nignored 1xx responses, use the httptrace trace package's\nClientTrace.Got1xxResponse.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Transport"}
  refToTransport)

CLOJURE TYPE go.std.net.http/arrayOfTransport:
(def
  ^{:doc "Transport is an implementation of RoundTripper that supports HTTP,\nHTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use.\nThis may leave many open connections when accessing many hosts.\nThis behavior can be managed using Transport's CloseIdleConnections method\nand the MaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed.\nTransports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests.\nFor high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\nfor HTTPS URLs, depending on whether the server supports HTTP/2,\nand how the Transport is configured. The DefaultTransport supports HTTP/2.\nTo explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\nand call ConfigureTransport. See the package docs for more about HTTP/2.\n\nThe Transport will send CONNECT requests to a proxy for its own use\nwhen processing HTTPS requests, but Transport should generally not\nbe used to send a CONNECT request. That is, the Request passed to\nthe RoundTrip method should not have a Method of \"CONNECT\", as Go's\nHTTP/1.x implementation does not support full-duplex request bodies\nbeing written while the response body is streamed. Go's HTTP/2\nimplementation does support full duplex, but many CONNECT proxies speak\nHTTP/1.x.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one\nexception is HTTP status code 101 (Switching Protocols), which is\nconsidered a terminal status and returned by RoundTrip. To see the\nignored 1xx responses, use the httptrace trace package's\nClientTrace.Got1xxResponse.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Transport"}
  arrayOfTransport)

CLOJURE TYPE []net/http/cgi.Handler from net/http/cgi/host.go:
CLOJURE TYPE net/http/cgi.Handler from net/http/cgi/host.go:
CLOJURE TYPE *net/http/cgi.Handler from net/http/cgi/host.go:
CLOJURE FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo returns: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker returns: [^go.std.net.http/refToRequest, ^Error]"
  {:added "1.0"
   :go "_f_request()"}
  [])

CLOJURE FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[string]string)\n\nGo returns: (*net/http.Request, error)\n\nJoker input arguments: [^ABEND777(jtypes.go: multiple underlying expressions not supported: map_String_Of_<whatever>) params]\n\nJoker returns: [^go.std.net.http/refToRequest, ^Error]"
;;   {:added "1.0"
;;    :go "_f_requestFromMap(_v_params)"}
;;   [^ABEND777(jtypes.go: multiple underlying expressions not supported: map_String_Of_<whatever>) _v_params])

CLOJURE FUNC net/http/cgi.Serve from net/http/cgi/child.go:
(defn ^"Error" Serve
  "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler net/http.Handler)\n\nGo returns: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "cgi.Serve(_v_handler)"}
  [^go.std.net.http/Handler _v_handler])

CLOJURE TYPE go.std.net.http.cgi/Handler:
(def
  ^{:doc "Handler runs an executable in a subprocess with a CGI environment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Handler"}
  Handler)

CLOJURE TYPE go.std.net.http.cgi/refToHandler:
(def
  ^{:doc "Handler runs an executable in a subprocess with a CGI environment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Handler"}
  refToHandler)

CLOJURE TYPE go.std.net.http.cgi/arrayOfHandler:
(def
  ^{:doc "Handler runs an executable in a subprocess with a CGI environment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Handler"}
  arrayOfHandler)

CLOJURE TYPE []net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
CLOJURE TYPE []net/http/cookiejar.Options from net/http/cookiejar/jar.go:
CLOJURE TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
CLOJURE TYPE *net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
CLOJURE TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
CLOJURE TYPE *net/http/cookiejar.Options from net/http/cookiejar/jar.go:
CLOJURE TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
CLOJURE FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo returns: (*Jar, error)\n\nJoker input arguments: [^refToOptions o]\n\nJoker returns: [^refToJar, ^Error]"
  {:added "1.0"
   :go "_f_new(_v_o)"}
  [^go.std.net.http.cookiejar/refToOptions _v_o])

CLOJURE TYPE go.std.net.http.cookiejar/Jar:
(def
  ^{:doc "Jar implements the http.CookieJar interface from the net/http package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Jar"}
  Jar)

CLOJURE TYPE go.std.net.http.cookiejar/refToJar:
(def
  ^{:doc "Jar implements the http.CookieJar interface from the net/http package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Jar"}
  refToJar)

CLOJURE TYPE go.std.net.http.cookiejar/arrayOfJar:
(def
  ^{:doc "Jar implements the http.CookieJar interface from the net/http package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Jar"}
  arrayOfJar)

CLOJURE TYPE go.std.net.http.cookiejar/Options:
(def
  ^{:doc "Options are the options for creating a new Jar.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Options"}
  Options)

CLOJURE TYPE go.std.net.http.cookiejar/refToOptions:
(def
  ^{:doc "Options are the options for creating a new Jar.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Options"}
  refToOptions)

CLOJURE TYPE go.std.net.http.cookiejar/arrayOfOptions:
(def
  ^{:doc "Options are the options for creating a new Jar.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Options"}
  arrayOfOptions)

CLOJURE TYPE go.std.net.http.cookiejar/PublicSuffixList:
(def
  ^{:doc "PublicSuffixList provides the public suffix of a domain. For example:\n     - the public suffix of \"example.com\" is \"com\",\n     - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n     - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n\nImplementations of PublicSuffixList must be safe for concurrent use by\nmultiple goroutines.\n\nAn implementation that always returns \"\" is valid and may be useful for\ntesting but it is not secure: it means that the HTTP server for foo.com can\nset a cookie for bar.com.\n\nA public suffix list implementation is in the package\ngolang.org/x/net/publicsuffix.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_PublicSuffixList"}
  PublicSuffixList)

CLOJURE VARIABLE ErrConnClosed from net/http/fcgi/child.go:
(def
  ^{:doc "ErrConnClosed is returned by Read when a handler attempts to read the body of\na request after the connection to the web server has been closed.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrConnClosed"}
  ErrConnClosed)

CLOJURE VARIABLE ErrRequestAborted from net/http/fcgi/child.go:
(def
  ^{:doc "ErrRequestAborted is returned by Read when a handler attempts to read the\nbody of a request that has been aborted by the web server.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrRequestAborted"}
  ErrRequestAborted)

CLOJURE FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *net/http.Request)\n\nGo returns: map[string]string\n\nJoker input arguments: [^go.std.net.http/refToRequest r]\n\nJoker returns: ^ABEND777(jtypes.go: multiple underlying expressions not supported: map_String_Of_<whatever>)"
;;   {:added "1.0"
;;    :go "_f_processEnv(_v_r)"}
;;   [^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
(defn ^"Error" Serve
  "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler net/http.Handler)\n\nGo returns: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "fcgi.Serve(_v_l, _v_handler)"}
  [^go.std.net/Listener _v_l, ^go.std.net.http/Handler _v_handler])

CLOJURE CONSTANT DefaultRemoteAddr from net/http/httptest/recorder.go:
(def
  ^{:doc "DefaultRemoteAddr is the default remote address to return in RemoteAddr if\nan explicit DefaultRemoteAddr isn't set on ResponseRecorder.\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "httptest.DefaultRemoteAddr"}
  DefaultRemoteAddr)

CLOJURE TYPE []net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
CLOJURE TYPE []net/http/httptest.Server from net/http/httptest/server.go:
CLOJURE TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
CLOJURE TYPE *net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
CLOJURE TYPE net/http/httptest.Server from net/http/httptest/server.go:
CLOJURE TYPE *net/http/httptest.Server from net/http/httptest/server.go:
CLOJURE FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo returns: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker returns: ^refToResponseRecorder"
  {:added "1.0"
   :go "_f_newRecorder()"}
  [])

CLOJURE FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body ABEND002(reference to unavailable package `io' looking for type `Reader'))\n\nGo returns: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker returns: ^go.std.net.http/refToRequest"
;;   {:added "1.0"
;;    :go "_f_newRequest(_v_method, _v_target, _v_body)"}
;;   [^String _v_method, ^String _v_target, ^ABEND707(API 'go.std.io/Extract_ns_Reader' is unimplemented: go.std.io/Reader) _v_body])

CLOJURE FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
(defn NewServer
  "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo returns: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker returns: ^refToServer"
  {:added "1.0"
   :go "_f_newServer(_v_handler)"}
  [^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
(defn NewTLSServer
  "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo returns: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker returns: ^refToServer"
  {:added "1.0"
   :go "_f_newTLSServer(_v_handler)"}
  [^go.std.net.http/Handler _v_handler])

CLOJURE FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
(defn NewUnstartedServer
  "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo returns: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker returns: ^refToServer"
  {:added "1.0"
   :go "_f_newUnstartedServer(_v_handler)"}
  [^go.std.net.http/Handler _v_handler])

CLOJURE TYPE go.std.net.http.httptest/ResponseRecorder:
(def
  ^{:doc "ResponseRecorder is an implementation of http.ResponseWriter that\nrecords its mutations for later inspection in tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ResponseRecorder"}
  ResponseRecorder)

CLOJURE TYPE go.std.net.http.httptest/refToResponseRecorder:
(def
  ^{:doc "ResponseRecorder is an implementation of http.ResponseWriter that\nrecords its mutations for later inspection in tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ResponseRecorder"}
  refToResponseRecorder)

CLOJURE TYPE go.std.net.http.httptest/arrayOfResponseRecorder:
(def
  ^{:doc "ResponseRecorder is an implementation of http.ResponseWriter that\nrecords its mutations for later inspection in tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ResponseRecorder"}
  arrayOfResponseRecorder)

CLOJURE TYPE go.std.net.http.httptest/Server:
(def
  ^{:doc "A Server is an HTTP server listening on a system-chosen port on the\nlocal loopback interface, for use in end-to-end HTTP tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

CLOJURE TYPE go.std.net.http.httptest/refToServer:
(def
  ^{:doc "A Server is an HTTP server listening on a system-chosen port on the\nlocal loopback interface, for use in end-to-end HTTP tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  refToServer)

CLOJURE TYPE go.std.net.http.httptest/arrayOfServer:
(def
  ^{:doc "A Server is an HTTP server listening on a system-chosen port on the\nlocal loopback interface, for use in end-to-end HTTP tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Server"}
  arrayOfServer)

CLOJURE TYPE []net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
CLOJURE TYPE []net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
CLOJURE TYPE []net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
CLOJURE TYPE []net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
CLOJURE TYPE []net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
CLOJURE TYPE net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
CLOJURE TYPE *net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
CLOJURE TYPE net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
CLOJURE TYPE *net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
CLOJURE TYPE net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
CLOJURE TYPE *net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
CLOJURE TYPE net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
CLOJURE TYPE *net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
CLOJURE TYPE net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
CLOJURE TYPE *net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
CLOJURE FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx ABEND002(reference to unavailable package `context' looking for type `Context'))\n\nGo returns: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker returns: ^refToClientTrace"
;;   {:added "1.0"
;;    :go "_f_contextClientTrace(_v_ctx)"}
;;   [^ABEND707(API 'go.std.context/Extract_ns_Context' is unimplemented: go.std.context/Context) _v_ctx])

CLOJURE FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), trace *ClientTrace)\n\nGo returns: ABEND002(reference to unavailable package `context' looking for type `Context')\n\nJoker input arguments: [^go.std.context/Context ctx, ^refToClientTrace trace]\n\nJoker returns: ^go.std.context/Context"
;;   {:added "1.0"
;;    :go "_f_withClientTrace(_v_ctx, _v_trace)"}
;;   [^ABEND707(API 'go.std.context/Extract_ns_Context' is unimplemented: go.std.context/Context) _v_ctx, ^go.std.net.http.httptrace/refToClientTrace _v_trace])

CLOJURE TYPE go.std.net.http.httptrace/ClientTrace:
(def
  ^{:doc "ClientTrace is a set of hooks to run at various stages of an outgoing\nHTTP request. Any particular hook may be nil. Functions may be\ncalled concurrently from different goroutines and some may be called\nafter the request has completed or failed.\n\nClientTrace currently traces a single HTTP request & response\nduring a single round trip and has no hooks that span a series\nof redirected requests.\n\nSee https://blog.golang.org/http-tracing for more.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientTrace"}
  ClientTrace)

CLOJURE TYPE go.std.net.http.httptrace/refToClientTrace:
(def
  ^{:doc "ClientTrace is a set of hooks to run at various stages of an outgoing\nHTTP request. Any particular hook may be nil. Functions may be\ncalled concurrently from different goroutines and some may be called\nafter the request has completed or failed.\n\nClientTrace currently traces a single HTTP request & response\nduring a single round trip and has no hooks that span a series\nof redirected requests.\n\nSee https://blog.golang.org/http-tracing for more.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ClientTrace"}
  refToClientTrace)

CLOJURE TYPE go.std.net.http.httptrace/arrayOfClientTrace:
(def
  ^{:doc "ClientTrace is a set of hooks to run at various stages of an outgoing\nHTTP request. Any particular hook may be nil. Functions may be\ncalled concurrently from different goroutines and some may be called\nafter the request has completed or failed.\n\nClientTrace currently traces a single HTTP request & response\nduring a single round trip and has no hooks that span a series\nof redirected requests.\n\nSee https://blog.golang.org/http-tracing for more.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ClientTrace"}
  arrayOfClientTrace)

CLOJURE TYPE go.std.net.http.httptrace/DNSDoneInfo:
(def
  ^{:doc "DNSDoneInfo contains information about the results of a DNS lookup.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSDoneInfo"}
  DNSDoneInfo)

CLOJURE TYPE go.std.net.http.httptrace/refToDNSDoneInfo:
(def
  ^{:doc "DNSDoneInfo contains information about the results of a DNS lookup.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSDoneInfo"}
  refToDNSDoneInfo)

CLOJURE TYPE go.std.net.http.httptrace/arrayOfDNSDoneInfo:
(def
  ^{:doc "DNSDoneInfo contains information about the results of a DNS lookup.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSDoneInfo"}
  arrayOfDNSDoneInfo)

CLOJURE TYPE go.std.net.http.httptrace/DNSStartInfo:
(def
  ^{:doc "DNSStartInfo contains information about a DNS request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSStartInfo"}
  DNSStartInfo)

CLOJURE TYPE go.std.net.http.httptrace/refToDNSStartInfo:
(def
  ^{:doc "DNSStartInfo contains information about a DNS request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSStartInfo"}
  refToDNSStartInfo)

CLOJURE TYPE go.std.net.http.httptrace/arrayOfDNSStartInfo:
(def
  ^{:doc "DNSStartInfo contains information about a DNS request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_DNSStartInfo"}
  arrayOfDNSStartInfo)

CLOJURE TYPE go.std.net.http.httptrace/GotConnInfo:
(def
  ^{:doc "GotConnInfo is the argument to the ClientTrace.GotConn function and\ncontains information about the obtained connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GotConnInfo"}
  GotConnInfo)

CLOJURE TYPE go.std.net.http.httptrace/refToGotConnInfo:
(def
  ^{:doc "GotConnInfo is the argument to the ClientTrace.GotConn function and\ncontains information about the obtained connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_GotConnInfo"}
  refToGotConnInfo)

CLOJURE TYPE go.std.net.http.httptrace/arrayOfGotConnInfo:
(def
  ^{:doc "GotConnInfo is the argument to the ClientTrace.GotConn function and\ncontains information about the obtained connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_GotConnInfo"}
  arrayOfGotConnInfo)

CLOJURE TYPE go.std.net.http.httptrace/WroteRequestInfo:
(def
  ^{:doc "WroteRequestInfo contains information provided to the WroteRequest\nhook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WroteRequestInfo"}
  WroteRequestInfo)

CLOJURE TYPE go.std.net.http.httptrace/refToWroteRequestInfo:
(def
  ^{:doc "WroteRequestInfo contains information provided to the WroteRequest\nhook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_WroteRequestInfo"}
  refToWroteRequestInfo)

CLOJURE TYPE go.std.net.http.httptrace/arrayOfWroteRequestInfo:
(def
  ^{:doc "WroteRequestInfo contains information provided to the WroteRequest\nhook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_WroteRequestInfo"}
  arrayOfWroteRequestInfo)

CLOJURE VARIABLE ErrClosed from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrClosed"}
  ErrClosed)

CLOJURE VARIABLE ErrLineTooLong from net/http/httputil/httputil.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading malformed chunked data\nwith lines that are too long.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrLineTooLong"}
  ErrLineTooLong)

CLOJURE VARIABLE ErrPersistEOF from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPersistEOF"}
  ErrPersistEOF)

CLOJURE VARIABLE ErrPipeline from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPipeline"}
  ErrPipeline)

CLOJURE TYPE []net/http/httputil.ClientConn from net/http/httputil/persist.go:
CLOJURE TYPE []net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
CLOJURE TYPE []net/http/httputil.ServerConn from net/http/httputil/persist.go:
CLOJURE TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
CLOJURE TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
CLOJURE TYPE *net/http/httputil.ClientConn from net/http/httputil/persist.go:
CLOJURE TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
CLOJURE TYPE *net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
CLOJURE TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
CLOJURE TYPE *net/http/httputil.ServerConn from net/http/httputil/persist.go:
CLOJURE FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
(defn DumpRequest
  "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *net/http.Request, body bool)\n\nGo returns: ([]byte, error)\n\nJoker input arguments: [^go.std.net.http/refToRequest req, ^Boolean body]\n\nJoker returns: [^arrayOfByte, ^Error]"
  {:added "1.0"
   :go "_f_dumpRequest(_v_req, _v_body)"}
  [^go.std.net.http/refToRequest _v_req, ^Boolean _v_body])

CLOJURE FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
(defn DumpRequestOut
  "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *net/http.Request, body bool)\n\nGo returns: ([]byte, error)\n\nJoker input arguments: [^go.std.net.http/refToRequest req, ^Boolean body]\n\nJoker returns: [^arrayOfByte, ^Error]"
  {:added "1.0"
   :go "_f_dumpRequestOut(_v_req, _v_body)"}
  [^go.std.net.http/refToRequest _v_req, ^Boolean _v_body])

CLOJURE FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
(defn DumpResponse
  "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *net/http.Response, body bool)\n\nGo returns: ([]byte, error)\n\nJoker input arguments: [^go.std.net.http/refToResponse resp, ^Boolean body]\n\nJoker returns: [^arrayOfByte, ^Error]"
  {:added "1.0"
   :go "_f_dumpResponse(_v_resp, _v_body)"}
  [^go.std.net.http/refToResponse _v_resp, ^Boolean _v_body])

CLOJURE FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r ABEND002(reference to unavailable package `io' looking for type `Reader'))\n\nGo returns: ABEND002(reference to unavailable package `io' looking for type `Reader')\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker returns: ^go.std.io/Reader"
;;   {:added "1.0"
;;    :go "_f_newChunkedReader(_v_r)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_Reader' is unimplemented: go.std.io/Reader) _v_r])

CLOJURE FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w ABEND002(reference to unavailable package `io' looking for type `Writer'))\n\nGo returns: ABEND002(reference to unavailable package `io' looking for type `WriteCloser')\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker returns: ^go.std.io/WriteCloser"
;;   {:added "1.0"
;;    :go "_f_newChunkedWriter(_v_w)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_Writer' is unimplemented: go.std.io/Writer) _v_w])

CLOJURE FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))\n\nGo returns: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^go.std.bufio/refToReader r]\n\nJoker returns: ^refToClientConn"
;;   {:added "1.0"
;;    :go "_f_newClientConn(_v_c, _v_r)"}
;;   [^go.std.net/Conn _v_c, ^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_r])

CLOJURE FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))\n\nGo returns: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^go.std.bufio/refToReader r]\n\nJoker returns: ^refToClientConn"
;;   {:added "1.0"
;;    :go "_f_newProxyClientConn(_v_c, _v_r)"}
;;   [^go.std.net/Conn _v_c, ^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_r])

CLOJURE FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))\n\nGo returns: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^go.std.bufio/refToReader r]\n\nJoker returns: ^refToServerConn"
;;   {:added "1.0"
;;    :go "_f_newServerConn(_v_c, _v_r)"}
;;   [^go.std.net/Conn _v_c, ^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_r])

CLOJURE FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
(defn NewSingleHostReverseProxy
  "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *net/url.URL)\n\nGo returns: *ReverseProxy\n\nJoker input arguments: [^go.std.net.url/refToURL target]\n\nJoker returns: ^refToReverseProxy"
  {:added "1.0"
   :go "_f_newSingleHostReverseProxy(_v_target)"}
  [^go.std.net.url/refToURL _v_target])

CLOJURE TYPE go.std.net.http.httputil/BufferPool:
(def
  ^{:doc "A BufferPool is an interface for getting and returning temporary\nbyte slices for use by io.CopyBuffer.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_BufferPool"}
  BufferPool)

CLOJURE TYPE go.std.net.http.httputil/ClientConn:
(def
  ^{:doc "ClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientConn"}
  ClientConn)

CLOJURE TYPE go.std.net.http.httputil/refToClientConn:
(def
  ^{:doc "ClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ClientConn"}
  refToClientConn)

CLOJURE TYPE go.std.net.http.httputil/arrayOfClientConn:
(def
  ^{:doc "ClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ClientConn"}
  arrayOfClientConn)

CLOJURE TYPE go.std.net.http.httputil/ReverseProxy:
(def
  ^{:doc "ReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReverseProxy"}
  ReverseProxy)

CLOJURE TYPE go.std.net.http.httputil/refToReverseProxy:
(def
  ^{:doc "ReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ReverseProxy"}
  refToReverseProxy)

CLOJURE TYPE go.std.net.http.httputil/arrayOfReverseProxy:
(def
  ^{:doc "ReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ReverseProxy"}
  arrayOfReverseProxy)

CLOJURE TYPE go.std.net.http.httputil/ServerConn:
(def
  ^{:doc "ServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerConn"}
  ServerConn)

CLOJURE TYPE go.std.net.http.httputil/refToServerConn:
(def
  ^{:doc "ServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerConn"}
  refToServerConn)

CLOJURE TYPE go.std.net.http.httputil/arrayOfServerConn:
(def
  ^{:doc "ServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ServerConn"}
  arrayOfServerConn)

CLOJURE FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
(defn Cmdline
  "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.net.http/refToRequest r]"
  {:added "1.0"
   :go "_f_cmdline(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo returns: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker returns: ^go.std.net.http/Handler"
  {:added "1.0"
   :go "_f_handler(_v_name)"}
  [^String _v_name])

CLOJURE FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
(defn Index
  "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.net.http/refToRequest r]"
  {:added "1.0"
   :go "_f_index(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
(defn Profile
  "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.net.http/refToRequest r]"
  {:added "1.0"
   :go "_f_profile(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
(defn Symbol
  "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.net.http/refToRequest r]"
  {:added "1.0"
   :go "_f_symbol(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
(defn Trace
  "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.net.http/refToRequest r]"
  {:added "1.0"
   :go "_f_trace(_v_w, _v_r)"}
  [^go.std.net.http/ResponseWriter _v_w, ^go.std.net.http/refToRequest _v_r])

CLOJURE VARIABLE ErrHeaderNotPresent from net/mail/message.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "mail.ErrHeaderNotPresent"}
  ErrHeaderNotPresent)

CLOJURE TYPE []*net/mail.Address from net/mail/message.go:
CLOJURE TYPE []net/mail.Address from net/mail/message.go:
CLOJURE TYPE []net/mail.AddressParser from net/mail/message.go:
CLOJURE TYPE []net/mail.Header from net/mail/message.go:
CLOJURE TYPE []net/mail.Message from net/mail/message.go:
CLOJURE TYPE net/mail.Address from net/mail/message.go:
CLOJURE TYPE *net/mail.Address from net/mail/message.go:
CLOJURE TYPE net/mail.AddressParser from net/mail/message.go:
CLOJURE TYPE *net/mail.AddressParser from net/mail/message.go:
CLOJURE TYPE net/mail.Header from net/mail/message.go:
CLOJURE TYPE *net/mail.Header from net/mail/message.go:
CLOJURE TYPE net/mail.Message from net/mail/message.go:
CLOJURE TYPE *net/mail.Message from net/mail/message.go:
CLOJURE FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo returns: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker returns: [^refToAddress, ^Error]"
  {:added "1.0"
   :go "_f_parseAddress(_v_address)"}
  [^String _v_address])

CLOJURE FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo returns: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker returns: [^arrayOfrefToAddress, ^Error]"
  {:added "1.0"
   :go "_f_parseAddressList(_v_list)"}
  [^String _v_list])

CLOJURE FUNC net/mail.ParseDate from net/mail/message.go:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo returns: (ABEND002(reference to unavailable package `time' looking for type `Time'), error)\n\nJoker input arguments: [^String date]\n\nJoker returns: [^go.std.time/Time, ^Error]"
;;   {:added "1.0"
;;    :go "_f_parseDate(_v_date)"}
;;   [^String _v_date])

CLOJURE FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r ABEND002(reference to unavailable package `io' looking for type `Reader'))\n\nGo returns: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker returns: [^refToMessage msg, ^Error err]"
;;   {:added "1.0"
;;    :go "_f_readMessage(_v_r)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_Reader' is unimplemented: go.std.io/Reader) _v_r])

CLOJURE TYPE go.std.net.mail/Address:
(def
  ^{:doc "Address represents a single mail address.\nAn address such as \"Barry Gibbs <bg@example.com>\" is represented\nas Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Address"}
  Address)

CLOJURE TYPE go.std.net.mail/refToAddress:
(def
  ^{:doc "Address represents a single mail address.\nAn address such as \"Barry Gibbs <bg@example.com>\" is represented\nas Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Address"}
  refToAddress)

CLOJURE TYPE go.std.net.mail/AddressParser:
(def
  ^{:doc "An AddressParser is an RFC 5322 address parser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AddressParser"}
  AddressParser)

CLOJURE TYPE go.std.net.mail/refToAddressParser:
(def
  ^{:doc "An AddressParser is an RFC 5322 address parser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddressParser"}
  refToAddressParser)

CLOJURE TYPE go.std.net.mail/arrayOfAddressParser:
(def
  ^{:doc "An AddressParser is an RFC 5322 address parser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_AddressParser"}
  arrayOfAddressParser)

CLOJURE TYPE go.std.net.mail/arrayOfAddress:
(def
  ^{:doc "Address represents a single mail address.\nAn address such as \"Barry Gibbs <bg@example.com>\" is represented\nas Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Address"}
  arrayOfAddress)

CLOJURE TYPE go.std.net.mail/Header:
(def
  ^{:doc "A Header represents the key-value pairs in a mail message header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

CLOJURE TYPE go.std.net.mail/refToHeader:
(def
  ^{:doc "A Header represents the key-value pairs in a mail message header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Header"}
  refToHeader)

CLOJURE TYPE go.std.net.mail/arrayOfHeader:
(def
  ^{:doc "A Header represents the key-value pairs in a mail message header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Header"}
  arrayOfHeader)

CLOJURE TYPE go.std.net.mail/Message:
(def
  ^{:doc "A Message represents a parsed mail message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Message"}
  Message)

CLOJURE TYPE go.std.net.mail/refToMessage:
(def
  ^{:doc "A Message represents a parsed mail message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Message"}
  refToMessage)

CLOJURE TYPE go.std.net.mail/arrayOfMessage:
(def
  ^{:doc "A Message represents a parsed mail message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Message"}
  arrayOfMessage)

CLOJURE CONSTANT DefaultDebugPath from net/rpc/server.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :const true
    :go "rpc.DefaultDebugPath"}
  DefaultDebugPath)

CLOJURE CONSTANT DefaultRPCPath from net/rpc/server.go:
(def
  ^{:doc "Defaults used by HandleHTTP\n"
    :added "1.0"
    :tag "String"
    :const true
    :go "rpc.DefaultRPCPath"}
  DefaultRPCPath)

CLOJURE VARIABLE DefaultServer from net/rpc/server.go:
(def
  ^{:doc "DefaultServer is the default instance of *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "rpc.DefaultServer"}
  DefaultServer)

CLOJURE VARIABLE ErrShutdown from net/rpc/client.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "rpc.ErrShutdown"}
  ErrShutdown)

CLOJURE TYPE []net/rpc.Call from net/rpc/client.go:
CLOJURE TYPE []net/rpc.Client from net/rpc/client.go:
CLOJURE TYPE []net/rpc.Request from net/rpc/server.go:
CLOJURE TYPE []net/rpc.Response from net/rpc/server.go:
CLOJURE TYPE []net/rpc.Server from net/rpc/server.go:
CLOJURE TYPE []net/rpc.ServerError from net/rpc/client.go:
CLOJURE TYPE net/rpc.Call from net/rpc/client.go:
CLOJURE TYPE *net/rpc.Call from net/rpc/client.go:
CLOJURE TYPE net/rpc.Client from net/rpc/client.go:
CLOJURE TYPE *net/rpc.Client from net/rpc/client.go:
CLOJURE TYPE net/rpc.ClientCodec from net/rpc/client.go:
CLOJURE TYPE net/rpc.Request from net/rpc/server.go:
CLOJURE TYPE *net/rpc.Request from net/rpc/server.go:
CLOJURE TYPE net/rpc.Response from net/rpc/server.go:
CLOJURE TYPE *net/rpc.Response from net/rpc/server.go:
CLOJURE TYPE net/rpc.Server from net/rpc/server.go:
CLOJURE TYPE *net/rpc.Server from net/rpc/server.go:
CLOJURE TYPE net/rpc.ServerCodec from net/rpc/server.go:
CLOJURE TYPE net/rpc.ServerError from net/rpc/client.go:
CLOJURE TYPE *net/rpc.ServerError from net/rpc/client.go:
CLOJURE FUNC net/rpc.Accept from net/rpc/server.go:
(defn Accept
  "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
  {:added "1.0"
   :go "_f_accept(_v_lis)"}
  [^go.std.net/Listener _v_lis])

CLOJURE FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToClient, ^Error]"
  {:added "1.0"
   :go "_f_dial(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^refToClient, ^Error]"
  {:added "1.0"
   :go "_f_dialHTTP(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo returns: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker returns: [^refToClient, ^Error]"
  {:added "1.0"
   :go "_f_dialHTTPPath(_v_network, _v_address, _v_path)"}
  [^String _v_network, ^String _v_address, ^String _v_path])

CLOJURE FUNC net/rpc.HandleHTTP from net/rpc/server.go:
(defn HandleHTTP
  "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
  {:added "1.0"
   :go "_f_handleHTTP()"}
  [])

CLOJURE FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nGo returns: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker returns: ^refToClient"
;;   {:added "1.0"
;;    :go "_f_newClient(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo returns: *Client\n\nJoker input arguments: [^ClientCodec codec]\n\nJoker returns: ^refToClient"
  {:added "1.0"
   :go "_f_newClientWithCodec(_v_codec)"}
  [^go.std.net.rpc/ClientCodec _v_codec])

CLOJURE FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo returns: *Server\n\nJoker input arguments: []\n\nJoker returns: ^refToServer"
  {:added "1.0"
   :go "_f_newServer()"}
  [])

CLOJURE FUNC net/rpc.Register from net/rpc/server.go:
(defn ^"Error" Register
  "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface{})\n\nGo returns: error\n\nJoker input arguments: [^GoObject rcvr]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "rpc.Register(_v_rcvr)"}
  [^GoObject _v_rcvr])

CLOJURE FUNC net/rpc.RegisterName from net/rpc/server.go:
(defn ^"Error" RegisterName
  "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface{})\n\nGo returns: error\n\nJoker input arguments: [^String name, ^GoObject rcvr]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "rpc.RegisterName(_v_name, _v_rcvr)"}
  [^String _v_name, ^GoObject _v_rcvr])

CLOJURE FUNC net/rpc.ServeCodec from net/rpc/server.go:
(defn ServeCodec
  "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^ServerCodec codec]"
  {:added "1.0"
   :go "_f_serveCodec(_v_codec)"}
  [^go.std.net.rpc/ServerCodec _v_codec])

CLOJURE FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "_f_serveConn(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo returns: error\n\nJoker input arguments: [^ServerCodec codec]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "rpc.ServeRequest(_v_codec)"}
  [^go.std.net.rpc/ServerCodec _v_codec])

CLOJURE TYPE go.std.net.rpc/Call:
(def
  ^{:doc "Call represents an active RPC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Call"}
  Call)

CLOJURE TYPE go.std.net.rpc/refToCall:
(def
  ^{:doc "Call represents an active RPC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Call"}
  refToCall)

CLOJURE TYPE go.std.net.rpc/arrayOfCall:
(def
  ^{:doc "Call represents an active RPC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Call"}
  arrayOfCall)

CLOJURE TYPE go.std.net.rpc/Client:
(def
  ^{:doc "Client represents an RPC Client.\nThere may be multiple outstanding Calls associated\nwith a single Client, and a Client may be used by\nmultiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

CLOJURE TYPE go.std.net.rpc/refToClient:
(def
  ^{:doc "Client represents an RPC Client.\nThere may be multiple outstanding Calls associated\nwith a single Client, and a Client may be used by\nmultiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  refToClient)

CLOJURE TYPE go.std.net.rpc/ClientCodec:
(def
  ^{:doc "A ClientCodec implements writing of RPC requests and\nreading of RPC responses for the client side of an RPC session.\nThe client calls WriteRequest to write a request to the connection\nand calls ReadResponseHeader and ReadResponseBody in pairs\nto read responses. The client calls Close when finished with the\nconnection. ReadResponseBody may be called with a nil\nargument to force the body of the response to be read and then\ndiscarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 4
    :go "&info_ClientCodec"}
  ClientCodec)

CLOJURE TYPE go.std.net.rpc/arrayOfClient:
(def
  ^{:doc "Client represents an RPC Client.\nThere may be multiple outstanding Calls associated\nwith a single Client, and a Client may be used by\nmultiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Client"}
  arrayOfClient)

CLOJURE TYPE go.std.net.rpc/Request:
(def
  ^{:doc "Request is a header written before every RPC call. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

CLOJURE TYPE go.std.net.rpc/refToRequest:
(def
  ^{:doc "Request is a header written before every RPC call. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Request"}
  refToRequest)

CLOJURE TYPE go.std.net.rpc/arrayOfRequest:
(def
  ^{:doc "Request is a header written before every RPC call. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Request"}
  arrayOfRequest)

CLOJURE TYPE go.std.net.rpc/Response:
(def
  ^{:doc "Response is a header written before every RPC return. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

CLOJURE TYPE go.std.net.rpc/refToResponse:
(def
  ^{:doc "Response is a header written before every RPC return. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Response"}
  refToResponse)

CLOJURE TYPE go.std.net.rpc/arrayOfResponse:
(def
  ^{:doc "Response is a header written before every RPC return. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Response"}
  arrayOfResponse)

CLOJURE TYPE go.std.net.rpc/Server:
(def
  ^{:doc "Server represents an RPC Server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

CLOJURE TYPE go.std.net.rpc/refToServer:
(def
  ^{:doc "Server represents an RPC Server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  refToServer)

CLOJURE TYPE go.std.net.rpc/ServerCodec:
(def
  ^{:doc "A ServerCodec implements reading of RPC requests and writing of\nRPC responses for the server side of an RPC session.\nThe server calls ReadRequestHeader and ReadRequestBody in pairs\nto read requests from the connection, and it calls WriteResponse to\nwrite a response back. The server calls Close when finished with the\nconnection. ReadRequestBody may be called with a nil\nargument to force the body of the request to be read and discarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 4
    :go "&info_ServerCodec"}
  ServerCodec)

CLOJURE TYPE go.std.net.rpc/ServerError:
(def
  ^{:doc "ServerError represents an error that has been returned from\nthe remote side of the RPC connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerError"}
  ServerError)

CLOJURE TYPE go.std.net.rpc/refToServerError:
(def
  ^{:doc "ServerError represents an error that has been returned from\nthe remote side of the RPC connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerError"}
  refToServerError)

CLOJURE TYPE go.std.net.rpc/arrayOfServerError:
(def
  ^{:doc "ServerError represents an error that has been returned from\nthe remote side of the RPC connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ServerError"}
  arrayOfServerError)

CLOJURE TYPE go.std.net.rpc/arrayOfServer:
(def
  ^{:doc "Server represents an RPC Server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Server"}
  arrayOfServer)

CLOJURE FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo returns: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker returns: [^go.std.net.rpc/refToClient, ^Error]"
  {:added "1.0"
   :go "_f_dial(_v_network, _v_address)"}
  [^String _v_network, ^String _v_address])

CLOJURE FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nGo returns: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker returns: ^go.std.net.rpc/refToClient"
;;   {:added "1.0"
;;    :go "_f_newClient(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nGo returns: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker returns: ^go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "_f_newClientCodec(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nGo returns: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker returns: ^go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "_f_newServerCodec(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "_f_serveConn(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE TYPE []net/smtp.Client from net/smtp/smtp.go:
CLOJURE TYPE []net/smtp.ServerInfo from net/smtp/auth.go:
CLOJURE TYPE net/smtp.Auth from net/smtp/auth.go:
CLOJURE TYPE net/smtp.Client from net/smtp/smtp.go:
CLOJURE TYPE *net/smtp.Client from net/smtp/smtp.go:
CLOJURE TYPE net/smtp.ServerInfo from net/smtp/auth.go:
CLOJURE TYPE *net/smtp.ServerInfo from net/smtp/auth.go:
CLOJURE FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo returns: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker returns: ^Auth"
  {:added "1.0"
   :go "_f_cRAMMD5Auth(_v_username, _v_secret)"}
  [^String _v_username, ^String _v_secret])

CLOJURE FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo returns: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker returns: [^refToClient, ^Error]"
  {:added "1.0"
   :go "_f_dial(_v_addr)"}
  [^String _v_addr])

CLOJURE FUNC net/smtp.NewClient from net/smtp/smtp.go:
(defn NewClient
  "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo returns: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker returns: [^refToClient, ^Error]"
  {:added "1.0"
   :go "_f_newClient(_v_conn, _v_host)"}
  [^go.std.net/Conn _v_conn, ^String _v_host])

CLOJURE FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo returns: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker returns: ^Auth"
  {:added "1.0"
   :go "_f_plainAuth(_v_identity, _v_username, _v_password, _v_host)"}
  [^String _v_identity, ^String _v_username, ^String _v_password, ^String _v_host])

CLOJURE FUNC net/smtp.SendMail from net/smtp/smtp.go:
(defn ^"Error" SendMail
  "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo returns: error\n\nJoker input arguments: [^String addr, ^Auth a, ^String from, ^arrayOfString to, ^arrayOfByte msg]\n\nJoker returns: ^Error"
  {:added "1.0"
   :go "smtp.SendMail(_v_addr, _v_a, _v_from, _v_to, _v_msg)"}
  [^String _v_addr, ^go.std.net.smtp/Auth _v_a, ^String _v_from, ^arrayOfString _v_to, ^arrayOfByte _v_msg])

CLOJURE TYPE go.std.net.smtp/Auth:
(def
  ^{:doc "Auth is implemented by an SMTP authentication mechanism.\n"
    :added "1.0"
    :tag "GoType"
    :specificity 2
    :go "&info_Auth"}
  Auth)

CLOJURE TYPE go.std.net.smtp/Client:
(def
  ^{:doc "A Client represents a client connection to an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

CLOJURE TYPE go.std.net.smtp/refToClient:
(def
  ^{:doc "A Client represents a client connection to an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  refToClient)

CLOJURE TYPE go.std.net.smtp/arrayOfClient:
(def
  ^{:doc "A Client represents a client connection to an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Client"}
  arrayOfClient)

CLOJURE TYPE go.std.net.smtp/ServerInfo:
(def
  ^{:doc "ServerInfo records information about an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerInfo"}
  ServerInfo)

CLOJURE TYPE go.std.net.smtp/refToServerInfo:
(def
  ^{:doc "ServerInfo records information about an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerInfo"}
  refToServerInfo)

CLOJURE TYPE go.std.net.smtp/arrayOfServerInfo:
(def
  ^{:doc "ServerInfo records information about an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ServerInfo"}
  arrayOfServerInfo)

CLOJURE TYPE []net/textproto.Conn from net/textproto/textproto.go:
CLOJURE TYPE []net/textproto.Error from net/textproto/textproto.go:
CLOJURE TYPE []net/textproto.MIMEHeader from net/textproto/header.go:
CLOJURE TYPE []net/textproto.Pipeline from net/textproto/pipeline.go:
CLOJURE TYPE []net/textproto.ProtocolError from net/textproto/textproto.go:
CLOJURE TYPE []net/textproto.Reader from net/textproto/reader.go:
CLOJURE TYPE []net/textproto.Writer from net/textproto/writer.go:
CLOJURE TYPE net/textproto.Conn from net/textproto/textproto.go:
CLOJURE TYPE *net/textproto.Conn from net/textproto/textproto.go:
CLOJURE TYPE net/textproto.Error from net/textproto/textproto.go:
CLOJURE TYPE *net/textproto.Error from net/textproto/textproto.go:
CLOJURE TYPE net/textproto.MIMEHeader from net/textproto/header.go:
CLOJURE TYPE *net/textproto.MIMEHeader from net/textproto/header.go:
CLOJURE TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
CLOJURE TYPE *net/textproto.Pipeline from net/textproto/pipeline.go:
CLOJURE TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
CLOJURE TYPE *net/textproto.ProtocolError from net/textproto/textproto.go:
CLOJURE TYPE net/textproto.Reader from net/textproto/reader.go:
CLOJURE TYPE *net/textproto.Reader from net/textproto/reader.go:
CLOJURE TYPE net/textproto.Writer from net/textproto/writer.go:
CLOJURE TYPE *net/textproto.Writer from net/textproto/writer.go:
CLOJURE FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo returns: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker returns: [^refToConn, ^Error]"
  {:added "1.0"
   :go "_f_dial(_v_network, _v_addr)"}
  [^String _v_network, ^String _v_addr])

CLOJURE FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))\n\nGo returns: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker returns: ^refToConn"
;;   {:added "1.0"
;;    :go "_f_newConn(_v_conn)"}
;;   [^ABEND707(API 'go.std.io/Extract_ns_ReadWriteCloser' is unimplemented: go.std.io/ReadWriteCloser) _v_conn])

CLOJURE FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))\n\nGo returns: *Reader\n\nJoker input arguments: [^go.std.bufio/refToReader r]\n\nJoker returns: ^refToReader"
;;   {:added "1.0"
;;    :go "_f_newReader(_v_r)"}
;;   [^ABEND707(API 'go.std.bufio/Extract_ns_refToReader' is unimplemented: go.std.bufio/refToReader) _v_r])

CLOJURE FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *ABEND002(reference to unavailable package `bufio' looking for type `Writer'))\n\nGo returns: *Writer\n\nJoker input arguments: [^go.std.bufio/refToWriter w]\n\nJoker returns: ^refToWriter"
;;   {:added "1.0"
;;    :go "_f_newWriter(_v_w)"}
;;   [^ABEND707(API 'go.std.bufio/Extract_ns_refToWriter' is unimplemented: go.std.bufio/refToWriter) _v_w])

CLOJURE FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
(defn TrimBytes
  "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo returns: []byte\n\nJoker input arguments: [^arrayOfByte b]\n\nJoker returns: ^arrayOfByte"
  {:added "1.0"
   :go "_f_trimBytes(_v_b)"}
  [^arrayOfByte _v_b])

CLOJURE FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "textproto.TrimString(_v_s)"}
  [^String _v_s])

CLOJURE TYPE go.std.net.textproto/Conn:
(def
  ^{:doc "A Conn represents a textual network protocol connection.\nIt consists of a Reader and Writer to manage I/O\nand a Pipeline to sequence concurrent requests on the connection.\nThese embedded types carry methods with them;\nsee the documentation of those types for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

CLOJURE TYPE go.std.net.textproto/refToConn:
(def
  ^{:doc "A Conn represents a textual network protocol connection.\nIt consists of a Reader and Writer to manage I/O\nand a Pipeline to sequence concurrent requests on the connection.\nThese embedded types carry methods with them;\nsee the documentation of those types for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Conn"}
  refToConn)

CLOJURE TYPE go.std.net.textproto/arrayOfConn:
(def
  ^{:doc "A Conn represents a textual network protocol connection.\nIt consists of a Reader and Writer to manage I/O\nand a Pipeline to sequence concurrent requests on the connection.\nThese embedded types carry methods with them;\nsee the documentation of those types for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Conn"}
  arrayOfConn)

CLOJURE TYPE go.std.net.textproto/Error:
(def
  ^{:doc "An Error represents a numeric error response from a server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

CLOJURE TYPE go.std.net.textproto/refToError:
(def
  ^{:doc "An Error represents a numeric error response from a server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  refToError)

CLOJURE TYPE go.std.net.textproto/arrayOfError:
(def
  ^{:doc "An Error represents a numeric error response from a server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Error"}
  arrayOfError)

CLOJURE TYPE go.std.net.textproto/MIMEHeader:
(def
  ^{:doc "A MIMEHeader represents a MIME-style header mapping\nkeys to sets of values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MIMEHeader"}
  MIMEHeader)

CLOJURE TYPE go.std.net.textproto/refToMIMEHeader:
(def
  ^{:doc "A MIMEHeader represents a MIME-style header mapping\nkeys to sets of values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MIMEHeader"}
  refToMIMEHeader)

CLOJURE TYPE go.std.net.textproto/arrayOfMIMEHeader:
(def
  ^{:doc "A MIMEHeader represents a MIME-style header mapping\nkeys to sets of values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_MIMEHeader"}
  arrayOfMIMEHeader)

CLOJURE TYPE go.std.net.textproto/Pipeline:
(def
  ^{:doc "A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection,\neach client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\tsend request\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\tread response\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that\nresponses computed in parallel are written in the correct order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pipeline"}
  Pipeline)

CLOJURE TYPE go.std.net.textproto/refToPipeline:
(def
  ^{:doc "A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection,\neach client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\tsend request\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\tread response\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that\nresponses computed in parallel are written in the correct order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Pipeline"}
  refToPipeline)

CLOJURE TYPE go.std.net.textproto/arrayOfPipeline:
(def
  ^{:doc "A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection,\neach client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\tsend request\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\tread response\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that\nresponses computed in parallel are written in the correct order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Pipeline"}
  arrayOfPipeline)

CLOJURE TYPE go.std.net.textproto/ProtocolError:
(def
  ^{:doc "A ProtocolError describes a protocol violation such\nas an invalid response or a hung-up connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

CLOJURE TYPE go.std.net.textproto/refToProtocolError:
(def
  ^{:doc "A ProtocolError describes a protocol violation such\nas an invalid response or a hung-up connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ProtocolError"}
  refToProtocolError)

CLOJURE TYPE go.std.net.textproto/arrayOfProtocolError:
(def
  ^{:doc "A ProtocolError describes a protocol violation such\nas an invalid response or a hung-up connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_ProtocolError"}
  arrayOfProtocolError)

CLOJURE TYPE go.std.net.textproto/Reader:
(def
  ^{:doc "A Reader implements convenience methods for reading requests\nor responses from a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

CLOJURE TYPE go.std.net.textproto/refToReader:
(def
  ^{:doc "A Reader implements convenience methods for reading requests\nor responses from a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Reader"}
  refToReader)

CLOJURE TYPE go.std.net.textproto/arrayOfReader:
(def
  ^{:doc "A Reader implements convenience methods for reading requests\nor responses from a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Reader"}
  arrayOfReader)

CLOJURE TYPE go.std.net.textproto/Writer:
(def
  ^{:doc "A Writer implements convenience methods for writing\nrequests or responses to a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

CLOJURE TYPE go.std.net.textproto/refToWriter:
(def
  ^{:doc "A Writer implements convenience methods for writing\nrequests or responses to a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Writer"}
  refToWriter)

CLOJURE TYPE go.std.net.textproto/arrayOfWriter:
(def
  ^{:doc "A Writer implements convenience methods for writing\nrequests or responses to a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Writer"}
  arrayOfWriter)

CLOJURE TYPE []net/url.Error from net/url/url.go:
CLOJURE TYPE []net/url.EscapeError from net/url/url.go:
CLOJURE TYPE []net/url.InvalidHostError from net/url/url.go:
CLOJURE TYPE []net/url.URL from net/url/url.go:
CLOJURE TYPE []net/url.Userinfo from net/url/url.go:
CLOJURE TYPE []net/url.Values from net/url/url.go:
CLOJURE TYPE net/url.Error from net/url/url.go:
CLOJURE TYPE *net/url.Error from net/url/url.go:
CLOJURE TYPE net/url.EscapeError from net/url/url.go:
CLOJURE TYPE *net/url.EscapeError from net/url/url.go:
CLOJURE TYPE net/url.InvalidHostError from net/url/url.go:
CLOJURE TYPE *net/url.InvalidHostError from net/url/url.go:
CLOJURE TYPE net/url.URL from net/url/url.go:
CLOJURE TYPE *net/url.URL from net/url/url.go:
CLOJURE TYPE net/url.Userinfo from net/url/url.go:
CLOJURE TYPE *net/url.Userinfo from net/url/url.go:
CLOJURE TYPE net/url.Values from net/url/url.go:
CLOJURE TYPE *net/url.Values from net/url/url.go:
CLOJURE FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo returns: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker returns: [^refToURL, ^Error]"
  {:added "1.0"
   :go "_f_parse(_v_rawurl)"}
  [^String _v_rawurl])

CLOJURE FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo returns: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker returns: [^Values, ^Error]"
  {:added "1.0"
   :go "_f_parseQuery(_v_query)"}
  [^String _v_query])

CLOJURE FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo returns: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker returns: [^refToURL, ^Error]"
  {:added "1.0"
   :go "_f_parseRequestURI(_v_rawurl)"}
  [^String _v_rawurl])

CLOJURE FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "url.PathEscape(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo returns: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^String, ^Error]"
  {:added "1.0"
   :go "_f_pathUnescape(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo returns: string\n\nJoker input arguments: [^String s]\n\nJoker returns: ^String"
  {:added "1.0"
   :go "url.QueryEscape(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo returns: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker returns: [^String, ^Error]"
  {:added "1.0"
   :go "_f_queryUnescape(_v_s)"}
  [^String _v_s])

CLOJURE FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo returns: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker returns: ^refToUserinfo"
  {:added "1.0"
   :go "_f_user(_v_username)"}
  [^String _v_username])

CLOJURE FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo returns: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker returns: ^refToUserinfo"
  {:added "1.0"
   :go "_f_userPassword(_v_username, _v_password)"}
  [^String _v_username, ^String _v_password])

CLOJURE TYPE go.std.net.url/Error:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

CLOJURE TYPE go.std.net.url/refToError:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  refToError)

CLOJURE TYPE go.std.net.url/arrayOfError:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Error"}
  arrayOfError)

CLOJURE TYPE go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EscapeError"}
  EscapeError)

CLOJURE TYPE go.std.net.url/refToEscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_EscapeError"}
  refToEscapeError)

CLOJURE TYPE go.std.net.url/arrayOfEscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_EscapeError"}
  arrayOfEscapeError)

CLOJURE TYPE go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidHostError"}
  InvalidHostError)

CLOJURE TYPE go.std.net.url/refToInvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidHostError"}
  refToInvalidHostError)

CLOJURE TYPE go.std.net.url/arrayOfInvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_InvalidHostError"}
  arrayOfInvalidHostError)

CLOJURE TYPE go.std.net.url/URL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

CLOJURE TYPE go.std.net.url/refToURL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_URL"}
  refToURL)

CLOJURE TYPE go.std.net.url/arrayOfURL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_URL"}
  arrayOfURL)

CLOJURE TYPE go.std.net.url/Userinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Userinfo"}
  Userinfo)

CLOJURE TYPE go.std.net.url/refToUserinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Userinfo"}
  refToUserinfo)

CLOJURE TYPE go.std.net.url/arrayOfUserinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Userinfo"}
  arrayOfUserinfo)

CLOJURE TYPE go.std.net.url/Values:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Values"}
  Values)

CLOJURE TYPE go.std.net.url/refToValues:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Values"}
  refToValues)

CLOJURE TYPE go.std.net.url/arrayOfValues:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ArrayOf_Values"}
  arrayOfValues)

GO TYPE []*net.MX from net/dnsclient.go:
func Extract_ns_arrayOfrefToMX(args []Object, index int) []*net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.MX]"))
}

GO TYPE []*net.NS from net/dnsclient.go:
func Extract_ns_arrayOfrefToNS(args []Object, index int) []*net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.NS]"))
}

GO TYPE []*net.SRV from net/dnsclient.go:
func Extract_ns_arrayOfrefToSRV(args []Object, index int) []*net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net.SRV]"))
}

GO TYPE []net.Addr from net/net.go:
func Extract_ns_arrayOfAddr(args []Object, index int) []net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Addr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Addr]"))
}

GO TYPE []net.AddrError from net/net.go:
func Extract_ns_arrayOfAddrError(args []Object, index int) []net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.AddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.AddrError]"))
}

GO TYPE []net.Buffers from net/net.go:
func Extract_ns_arrayOfBuffers(args []Object, index int) []net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Buffers]"))
}

GO TYPE []net.DNSConfigError from net/net.go:
func Extract_ns_arrayOfDNSConfigError(args []Object, index int) []net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.DNSConfigError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.DNSConfigError]"))
}

GO TYPE []net.DNSError from net/net.go:
func Extract_ns_arrayOfDNSError(args []Object, index int) []net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.DNSError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.DNSError]"))
}

GO TYPE []net.Dialer from net/dial.go:
func Extract_ns_arrayOfDialer(args []Object, index int) []net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Dialer:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Dialer]"))
}

GO TYPE []net.Flags from net/interface.go:
func Extract_ns_arrayOfFlags(args []Object, index int) []net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Flags:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Flags]"))
}

GO TYPE []net.HardwareAddr from net/mac.go:
func Extract_ns_arrayOfHardwareAddr(args []Object, index int) []net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.HardwareAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.HardwareAddr]"))
}

GO TYPE []net.IP from net/ip.go:
func Extract_ns_arrayOfIP(args []Object, index int) []net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IP]"))
}

GO TYPE []net.IPAddr from net/iprawsock.go:
func Extract_ns_arrayOfIPAddr(args []Object, index int) []net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPAddr]"))
}

GO TYPE []net.IPConn from net/iprawsock.go:
func Extract_ns_arrayOfIPConn(args []Object, index int) []net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPConn]"))
}

GO TYPE []net.IPMask from net/ip.go:
func Extract_ns_arrayOfIPMask(args []Object, index int) []net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPMask]"))
}

GO TYPE []net.IPNet from net/ip.go:
func Extract_ns_arrayOfIPNet(args []Object, index int) []net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.IPNet:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.IPNet]"))
}

GO TYPE []net.Interface from net/interface.go:
func Extract_ns_arrayOfInterface(args []Object, index int) []net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Interface:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Interface]"))
}

GO TYPE []net.InvalidAddrError from net/net.go:
func Extract_ns_arrayOfInvalidAddrError(args []Object, index int) []net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.InvalidAddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.InvalidAddrError]"))
}

GO TYPE []net.ListenConfig from net/dial.go:
func Extract_ns_arrayOfListenConfig(args []Object, index int) []net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.ListenConfig:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.ListenConfig]"))
}

GO TYPE []net.MX from net/dnsclient.go:
func Extract_ns_arrayOfMX(args []Object, index int) []net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.MX]"))
}

GO TYPE []net.NS from net/dnsclient.go:
func Extract_ns_arrayOfNS(args []Object, index int) []net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.NS]"))
}

GO TYPE []net.OpError from net/net.go:
func Extract_ns_arrayOfOpError(args []Object, index int) []net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.OpError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.OpError]"))
}

GO TYPE []net.ParseError from net/net.go:
func Extract_ns_arrayOfParseError(args []Object, index int) []net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.ParseError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.ParseError]"))
}

GO TYPE []net.Resolver from net/lookup.go:
func Extract_ns_arrayOfResolver(args []Object, index int) []net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.Resolver:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.Resolver]"))
}

GO TYPE []net.SRV from net/dnsclient.go:
func Extract_ns_arrayOfSRV(args []Object, index int) []net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.SRV]"))
}

GO TYPE []net.TCPAddr from net/tcpsock.go:
func Extract_ns_arrayOfTCPAddr(args []Object, index int) []net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.TCPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.TCPAddr]"))
}

GO TYPE []net.TCPConn from net/tcpsock.go:
func Extract_ns_arrayOfTCPConn(args []Object, index int) []net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.TCPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.TCPConn]"))
}

GO TYPE []net.TCPListener from net/tcpsock.go:
func Extract_ns_arrayOfTCPListener(args []Object, index int) []net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.TCPListener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.TCPListener]"))
}

GO TYPE []net.UDPAddr from net/udpsock.go:
func Extract_ns_arrayOfUDPAddr(args []Object, index int) []net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UDPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UDPAddr]"))
}

GO TYPE []net.UDPConn from net/udpsock.go:
func Extract_ns_arrayOfUDPConn(args []Object, index int) []net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UDPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UDPConn]"))
}

GO TYPE []net.UnixAddr from net/unixsock.go:
func Extract_ns_arrayOfUnixAddr(args []Object, index int) []net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UnixAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UnixAddr]"))
}

GO TYPE []net.UnixConn from net/unixsock.go:
func Extract_ns_arrayOfUnixConn(args []Object, index int) []net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UnixConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UnixConn]"))
}

GO TYPE []net.UnixListener from net/unixsock.go:
func Extract_ns_arrayOfUnixListener(args []Object, index int) []net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UnixListener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UnixListener]"))
}

GO TYPE []net.UnknownNetworkError from net/net.go:
func Extract_ns_arrayOfUnknownNetworkError(args []Object, index int) []net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []net.UnknownNetworkError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net.UnknownNetworkError]"))
}

GO TYPE net.Addr from net/net.go:
func Extract_ns_Addr(args []Object, index int) net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Addr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

GO TYPE net.AddrError from net/net.go:
func Extract_ns_AddrError(args []Object, index int) *net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.AddrError:
			return r
		case net.AddrError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *net.AddrError {
	return &net.AddrError{
		Err: FieldAsString(o, "Err"),
		Addr: FieldAsString(o, "Addr"),
	}
}

func _Ctor_AddrError(_v Object) *net.AddrError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map"))
}

func _Wrapped_Ctor_AddrError(_o Object) Object {
	return MakeGoObject(_Ctor_AddrError(_o))
}

GO TYPE *net.AddrError from net/net.go:
func Extract_ns_refToAddrError(args []Object, index int) *net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.AddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.AddrError]"))
}

GO TYPE net.Buffers from net/net.go:
func Extract_ns_Buffers(args []Object, index int) net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _Ctor_Buffers(_v Object) net.Buffers {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

// func _Wrapped_Ctor_Buffers(_o Object) Object {
// 	return MakeGoObject(_Ctor_Buffers(_o))
// }

GO TYPE *net.Buffers from net/net.go:
func Extract_ns_refToBuffers(args []Object, index int) *net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Buffers:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Buffers]"))
}

GO TYPE net.Conn from net/net.go:
func Extract_ns_Conn(args []Object, index int) net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Conn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

GO TYPE net.DNSConfigError from net/net.go:
func Extract_ns_DNSConfigError(args []Object, index int) *net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSConfigError:
			return r
		case net.DNSConfigError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *net.DNSConfigError {
	return &net.DNSConfigError{
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_DNSConfigError(_v Object) *net.DNSConfigError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map"))
}

func _Wrapped_Ctor_DNSConfigError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSConfigError(_o))
}

GO TYPE *net.DNSConfigError from net/net.go:
func Extract_ns_refToDNSConfigError(args []Object, index int) *net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSConfigError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.DNSConfigError]"))
}

GO TYPE net.DNSError from net/net.go:
func Extract_ns_DNSError(args []Object, index int) *net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSError:
			return r
		case net.DNSError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *net.DNSError {
	return &net.DNSError{
		Err: FieldAsString(o, "Err"),
		Name: FieldAsString(o, "Name"),
		Server: FieldAsString(o, "Server"),
		IsTimeout: FieldAsBoolean(o, "IsTimeout"),
		IsTemporary: FieldAsBoolean(o, "IsTemporary"),
	}
}

func _Ctor_DNSError(_v Object) *net.DNSError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map"))
}

func _Wrapped_Ctor_DNSError(_o Object) Object {
	return MakeGoObject(_Ctor_DNSError(_o))
}

GO TYPE *net.DNSError from net/net.go:
func Extract_ns_refToDNSError(args []Object, index int) *net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.DNSError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.DNSError]"))
}

GO TYPE net.Dialer from net/dial.go:
func Extract_ns_Dialer(args []Object, index int) *net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Dialer:
			return r
		case net.Dialer:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

// func _mapToDialer(o Map) *net.Dialer {
// 	return &net.Dialer{
// 		Timeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		Deadline: time.ABEND002(reference to unavailable package `time' looking for type `Time'),
// 		LocalAddr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND320(gtypes.go: interface{Network func()string,String func()string} not supported))),
// 		DualStack: FieldAsBoolean(o, "DualStack"),
// 		FallbackDelay: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		KeepAlive: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		Resolver: ABEND048(codegen.go: no conversion from Clojure for *net.Resolver (net.Resolver)),
// 		Cancel: ABEND737(gtypes.go: <-chan struct{} not supported),
// 		Control: ABEND727(gtypes.go: func(network string,address string,c syscall.RawConn)error not supported),
// 	}
// }

// func _Ctor_Dialer(_v Object) *net.Dialer {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToDialer(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or: Map"))
// }

// func _Wrapped_Ctor_Dialer(_o Object) Object {
// 	return MakeGoObject(_Ctor_Dialer(_o))
// }

GO TYPE *net.Dialer from net/dial.go:
func Extract_ns_refToDialer(args []Object, index int) *net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Dialer:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Dialer]"))
}

GO TYPE net.Error from net/net.go:
func Extract_ns_Error(args []Object, index int) net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

GO TYPE net.Flags from net/interface.go:
func Extract_ns_Flags(args []Object, index int) *net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Flags:
			return r
		case net.Flags:
			return &r  // refTo
		}
	case Number:
		v := net.Flags(ExtractUint(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _Ctor_Flags(_v Object) net.Flags {
	switch _o := _v.(type) {
	case Number:
		return net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or: Number"))
}

func _Wrapped_Ctor_Flags(_o Object) Object {
	return MakeGoObject(_Ctor_Flags(_o))
}

GO TYPE *net.Flags from net/interface.go:
func Extract_ns_refToFlags(args []Object, index int) *net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Flags:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Flags]"))
}

GO TYPE net.HardwareAddr from net/mac.go:
func Extract_ns_HardwareAddr(args []Object, index int) net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.HardwareAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _Ctor_HardwareAddr(_v Object) net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or: whatever"))
// }

// func _Wrapped_Ctor_HardwareAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_HardwareAddr(_o))
// }

GO TYPE *net.HardwareAddr from net/mac.go:
func Extract_ns_refToHardwareAddr(args []Object, index int) *net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.HardwareAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.HardwareAddr]"))
}

GO TYPE net.IP from net/ip.go:
func Extract_ns_IP(args []Object, index int) net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _Ctor_IP(_v Object) net.IP {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

// func _Wrapped_Ctor_IP(_o Object) Object {
// 	return MakeGoObject(_Ctor_IP(_o))
// }

GO TYPE *net.IP from net/ip.go:
func Extract_ns_refToIP(args []Object, index int) *net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IP:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IP]"))
}

GO TYPE net.IPAddr from net/iprawsock.go:
func Extract_ns_IPAddr(args []Object, index int) *net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPAddr:
			return r
		case net.IPAddr:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *net.IPAddr {
// 	return &net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: FieldAsString(o, "Zone"),
// 	}
// }

// func _Ctor_IPAddr(_v Object) *net.IPAddr {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map"))
// }

// func _Wrapped_Ctor_IPAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPAddr(_o))
// }

GO TYPE *net.IPAddr from net/iprawsock.go:
func Extract_ns_refToIPAddr(args []Object, index int) *net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPAddr]"))
}

GO TYPE net.IPConn from net/iprawsock.go:
func Extract_ns_IPConn(args []Object, index int) *net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPConn:
			return r
		case net.IPConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *net.IPConn {
	return &net.IPConn{}
}

func _Ctor_IPConn(_v Object) *net.IPConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map"))
}

func _Wrapped_Ctor_IPConn(_o Object) Object {
	return MakeGoObject(_Ctor_IPConn(_o))
}

GO TYPE *net.IPConn from net/iprawsock.go:
func Extract_ns_refToIPConn(args []Object, index int) *net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPConn]"))
}

GO TYPE net.IPMask from net/ip.go:
func Extract_ns_IPMask(args []Object, index int) net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _Ctor_IPMask(_v Object) net.IPMask {
// 	switch _o := _v.(type) {
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

// func _Wrapped_Ctor_IPMask(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPMask(_o))
// }

GO TYPE *net.IPMask from net/ip.go:
func Extract_ns_refToIPMask(args []Object, index int) *net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPMask:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPMask]"))
}

GO TYPE net.IPNet from net/ip.go:
func Extract_ns_IPNet(args []Object, index int) *net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPNet:
			return r
		case net.IPNet:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *net.IPNet {
// 	return &net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _Ctor_IPNet(_v Object) *net.IPNet {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map"))
// }

// func _Wrapped_Ctor_IPNet(_o Object) Object {
// 	return MakeGoObject(_Ctor_IPNet(_o))
// }

GO TYPE *net.IPNet from net/ip.go:
func Extract_ns_refToIPNet(args []Object, index int) *net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.IPNet:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.IPNet]"))
}

GO TYPE net.Interface from net/interface.go:
func Extract_ns_Interface(args []Object, index int) *net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Interface:
			return r
		case net.Interface:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

// func _mapToInterface(o Map) *net.Interface {
// 	return &net.Interface{
// 		Index: FieldAsInt(o, "Index"),
// 		MTU: FieldAsInt(o, "MTU"),
// 		Name: FieldAsString(o, "Name"),
// 		HardwareAddr: ABEND048(codegen.go: no conversion from Clojure for net.HardwareAddr ([]byte)),
// 		Flags: ABEND048(codegen.go: no conversion from Clojure for net.Flags (uint)),
// 	}
// }

// func _Ctor_Interface(_v Object) *net.Interface {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterface(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or: Map"))
// }

// func _Wrapped_Ctor_Interface(_o Object) Object {
// 	return MakeGoObject(_Ctor_Interface(_o))
// }

GO TYPE *net.Interface from net/interface.go:
func Extract_ns_refToInterface(args []Object, index int) *net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Interface:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Interface]"))
}

GO TYPE net.InvalidAddrError from net/net.go:
func Extract_ns_InvalidAddrError(args []Object, index int) *net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.InvalidAddrError:
			return r
		case net.InvalidAddrError:
			return &r  // refTo
		}
	case String:
		v := net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _Ctor_InvalidAddrError(_v Object) net.InvalidAddrError {
	switch _o := _v.(type) {
	case String:
		return net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

func _Wrapped_Ctor_InvalidAddrError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidAddrError(_o))
}

GO TYPE *net.InvalidAddrError from net/net.go:
func Extract_ns_refToInvalidAddrError(args []Object, index int) *net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.InvalidAddrError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.InvalidAddrError]"))
}

GO TYPE net.ListenConfig from net/dial.go:
func Extract_ns_ListenConfig(args []Object, index int) *net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ListenConfig:
			return r
		case net.ListenConfig:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

// func _mapToListenConfig(o Map) *net.ListenConfig {
// 	return &net.ListenConfig{
// 		Control: ABEND727(gtypes.go: func(network string,address string,c syscall.RawConn)error not supported),
// 	}
// }

// func _Ctor_ListenConfig(_v Object) *net.ListenConfig {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToListenConfig(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or: Map"))
// }

// func _Wrapped_Ctor_ListenConfig(_o Object) Object {
// 	return MakeGoObject(_Ctor_ListenConfig(_o))
// }

GO TYPE *net.ListenConfig from net/dial.go:
func Extract_ns_refToListenConfig(args []Object, index int) *net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ListenConfig:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.ListenConfig]"))
}

GO TYPE net.Listener from net/net.go:
func Extract_ns_Listener(args []Object, index int) net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.Listener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

GO TYPE net.MX from net/dnsclient.go:
func Extract_ns_MX(args []Object, index int) *net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.MX:
			return r
		case net.MX:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *net.MX {
	return &net.MX{
		Host: FieldAsString(o, "Host"),
		Pref: FieldAsUint16(o, "Pref"),
	}
}

func _Ctor_MX(_v Object) *net.MX {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map"))
}

func _Wrapped_Ctor_MX(_o Object) Object {
	return MakeGoObject(_Ctor_MX(_o))
}

GO TYPE *net.MX from net/dnsclient.go:
func Extract_ns_refToMX(args []Object, index int) *net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.MX:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.MX]"))
}

GO TYPE net.NS from net/dnsclient.go:
func Extract_ns_NS(args []Object, index int) *net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.NS:
			return r
		case net.NS:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *net.NS {
	return &net.NS{
		Host: FieldAsString(o, "Host"),
	}
}

func _Ctor_NS(_v Object) *net.NS {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map"))
}

func _Wrapped_Ctor_NS(_o Object) Object {
	return MakeGoObject(_Ctor_NS(_o))
}

GO TYPE *net.NS from net/dnsclient.go:
func Extract_ns_refToNS(args []Object, index int) *net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.NS:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.NS]"))
}

GO TYPE net.OpError from net/net.go:
func Extract_ns_OpError(args []Object, index int) *net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.OpError:
			return r
		case net.OpError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *net.OpError {
// 	return &net.OpError{
// 		Op: FieldAsString(o, "Op"),
// 		Net: FieldAsString(o, "Net"),
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND320(gtypes.go: interface{Network func()string,String func()string} not supported))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND320(gtypes.go: interface{Network func()string,String func()string} not supported))),
// 		Err: FieldAsError(o, "Err"),
// 	}
// }

// func _Ctor_OpError(_v Object) *net.OpError {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map"))
// }

// func _Wrapped_Ctor_OpError(_o Object) Object {
// 	return MakeGoObject(_Ctor_OpError(_o))
// }

GO TYPE *net.OpError from net/net.go:
func Extract_ns_refToOpError(args []Object, index int) *net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.OpError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.OpError]"))
}

GO TYPE net.PacketConn from net/net.go:
func Extract_ns_PacketConn(args []Object, index int) net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case net.PacketConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

GO TYPE net.ParseError from net/net.go:
func Extract_ns_ParseError(args []Object, index int) *net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ParseError:
			return r
		case net.ParseError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *net.ParseError {
	return &net.ParseError{
		Type: FieldAsString(o, "Type"),
		Text: FieldAsString(o, "Text"),
	}
}

func _Ctor_ParseError(_v Object) *net.ParseError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map"))
}

func _Wrapped_Ctor_ParseError(_o Object) Object {
	return MakeGoObject(_Ctor_ParseError(_o))
}

GO TYPE *net.ParseError from net/net.go:
func Extract_ns_refToParseError(args []Object, index int) *net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.ParseError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.ParseError]"))
}

GO TYPE net.Resolver from net/lookup.go:
func Extract_ns_Resolver(args []Object, index int) *net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Resolver:
			return r
		case net.Resolver:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *net.Resolver {
// 	return &net.Resolver{
// 		PreferGo: FieldAsBoolean(o, "PreferGo"),
// 		StrictErrors: FieldAsBoolean(o, "StrictErrors"),
// 		Dial: ABEND727(gtypes.go: func(ctx context.Context,network string,address string)(Conn,error) not supported),
// 	}
// }

// func _Ctor_Resolver(_v Object) *net.Resolver {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map"))
// }

// func _Wrapped_Ctor_Resolver(_o Object) Object {
// 	return MakeGoObject(_Ctor_Resolver(_o))
// }

GO TYPE *net.Resolver from net/lookup.go:
func Extract_ns_refToResolver(args []Object, index int) *net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.Resolver:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.Resolver]"))
}

GO TYPE net.SRV from net/dnsclient.go:
func Extract_ns_SRV(args []Object, index int) *net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.SRV:
			return r
		case net.SRV:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *net.SRV {
	return &net.SRV{
		Target: FieldAsString(o, "Target"),
		Port: FieldAsUint16(o, "Port"),
		Priority: FieldAsUint16(o, "Priority"),
		Weight: FieldAsUint16(o, "Weight"),
	}
}

func _Ctor_SRV(_v Object) *net.SRV {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map"))
}

func _Wrapped_Ctor_SRV(_o Object) Object {
	return MakeGoObject(_Ctor_SRV(_o))
}

GO TYPE *net.SRV from net/dnsclient.go:
func Extract_ns_refToSRV(args []Object, index int) *net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.SRV:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.SRV]"))
}

GO TYPE net.TCPAddr from net/tcpsock.go:
func Extract_ns_TCPAddr(args []Object, index int) *net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPAddr:
			return r
		case net.TCPAddr:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

// func _mapToTCPAddr(o Map) *net.TCPAddr {
// 	return &net.TCPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: FieldAsInt(o, "Port"),
// 		Zone: FieldAsString(o, "Zone"),
// 	}
// }

// func _Ctor_TCPAddr(_v Object) *net.TCPAddr {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToTCPAddr(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or: Map"))
// }

// func _Wrapped_Ctor_TCPAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_TCPAddr(_o))
// }

GO TYPE *net.TCPAddr from net/tcpsock.go:
func Extract_ns_refToTCPAddr(args []Object, index int) *net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.TCPAddr]"))
}

GO TYPE net.TCPConn from net/tcpsock.go:
func Extract_ns_TCPConn(args []Object, index int) *net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPConn:
			return r
		case net.TCPConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *net.TCPConn {
	return &net.TCPConn{}
}

func _Ctor_TCPConn(_v Object) *net.TCPConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or: Map"))
}

func _Wrapped_Ctor_TCPConn(_o Object) Object {
	return MakeGoObject(_Ctor_TCPConn(_o))
}

GO TYPE *net.TCPConn from net/tcpsock.go:
func Extract_ns_refToTCPConn(args []Object, index int) *net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.TCPConn]"))
}

GO TYPE net.TCPListener from net/tcpsock.go:
func Extract_ns_TCPListener(args []Object, index int) *net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPListener:
			return r
		case net.TCPListener:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *net.TCPListener {
	return &net.TCPListener{}
}

func _Ctor_TCPListener(_v Object) *net.TCPListener {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or: Map"))
}

func _Wrapped_Ctor_TCPListener(_o Object) Object {
	return MakeGoObject(_Ctor_TCPListener(_o))
}

GO TYPE *net.TCPListener from net/tcpsock.go:
func Extract_ns_refToTCPListener(args []Object, index int) *net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.TCPListener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.TCPListener]"))
}

GO TYPE net.UDPAddr from net/udpsock.go:
func Extract_ns_UDPAddr(args []Object, index int) *net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UDPAddr:
			return r
		case net.UDPAddr:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

// func _mapToUDPAddr(o Map) *net.UDPAddr {
// 	return &net.UDPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: FieldAsInt(o, "Port"),
// 		Zone: FieldAsString(o, "Zone"),
// 	}
// }

// func _Ctor_UDPAddr(_v Object) *net.UDPAddr {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToUDPAddr(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or: Map"))
// }

// func _Wrapped_Ctor_UDPAddr(_o Object) Object {
// 	return MakeGoObject(_Ctor_UDPAddr(_o))
// }

GO TYPE *net.UDPAddr from net/udpsock.go:
func Extract_ns_refToUDPAddr(args []Object, index int) *net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UDPAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UDPAddr]"))
}

GO TYPE net.UDPConn from net/udpsock.go:
func Extract_ns_UDPConn(args []Object, index int) *net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UDPConn:
			return r
		case net.UDPConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *net.UDPConn {
	return &net.UDPConn{}
}

func _Ctor_UDPConn(_v Object) *net.UDPConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or: Map"))
}

func _Wrapped_Ctor_UDPConn(_o Object) Object {
	return MakeGoObject(_Ctor_UDPConn(_o))
}

GO TYPE *net.UDPConn from net/udpsock.go:
func Extract_ns_refToUDPConn(args []Object, index int) *net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UDPConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UDPConn]"))
}

GO TYPE net.UnixAddr from net/unixsock.go:
func Extract_ns_UnixAddr(args []Object, index int) *net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixAddr:
			return r
		case net.UnixAddr:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *net.UnixAddr {
	return &net.UnixAddr{
		Name: FieldAsString(o, "Name"),
		Net: FieldAsString(o, "Net"),
	}
}

func _Ctor_UnixAddr(_v Object) *net.UnixAddr {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or: Map"))
}

func _Wrapped_Ctor_UnixAddr(_o Object) Object {
	return MakeGoObject(_Ctor_UnixAddr(_o))
}

GO TYPE *net.UnixAddr from net/unixsock.go:
func Extract_ns_refToUnixAddr(args []Object, index int) *net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixAddr:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UnixAddr]"))
}

GO TYPE net.UnixConn from net/unixsock.go:
func Extract_ns_UnixConn(args []Object, index int) *net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixConn:
			return r
		case net.UnixConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *net.UnixConn {
	return &net.UnixConn{}
}

func _Ctor_UnixConn(_v Object) *net.UnixConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or: Map"))
}

func _Wrapped_Ctor_UnixConn(_o Object) Object {
	return MakeGoObject(_Ctor_UnixConn(_o))
}

GO TYPE *net.UnixConn from net/unixsock.go:
func Extract_ns_refToUnixConn(args []Object, index int) *net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UnixConn]"))
}

GO TYPE net.UnixListener from net/unixsock.go:
func Extract_ns_UnixListener(args []Object, index int) *net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixListener:
			return r
		case net.UnixListener:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *net.UnixListener {
	return &net.UnixListener{}
}

func _Ctor_UnixListener(_v Object) *net.UnixListener {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or: Map"))
}

func _Wrapped_Ctor_UnixListener(_o Object) Object {
	return MakeGoObject(_Ctor_UnixListener(_o))
}

GO TYPE *net.UnixListener from net/unixsock.go:
func Extract_ns_refToUnixListener(args []Object, index int) *net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnixListener:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UnixListener]"))
}

GO TYPE net.UnknownNetworkError from net/net.go:
func Extract_ns_UnknownNetworkError(args []Object, index int) *net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnknownNetworkError:
			return r
		case net.UnknownNetworkError:
			return &r  // refTo
		}
	case String:
		v := net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _Ctor_UnknownNetworkError(_v Object) net.UnknownNetworkError {
	switch _o := _v.(type) {
	case String:
		return net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

func _Wrapped_Ctor_UnknownNetworkError(_o Object) Object {
	return MakeGoObject(_Ctor_UnknownNetworkError(_o))
}

GO TYPE *net.UnknownNetworkError from net/net.go:
func Extract_ns_refToUnknownNetworkError(args []Object, index int) *net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *net.UnknownNetworkError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net.UnknownNetworkError]"))
}

GO FUNC net.CIDRMask from net/ip.go:
func _f_cIDRMask(_v_ones int, _v_bits int) Object {
	_res := net.CIDRMask(_v_ones, _v_bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func _f_dial(_v_network string, _v_address string) Object {
	_res1, _res2 := net.Dial(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
func _f_dialIP(_v_network string, _v_laddr *net.IPAddr, _v_raddr *net.IPAddr) Object {
	_res1, _res2 := net.DialIP(_v_network, _v_laddr, _v_raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTCP from net/tcpsock.go:
func _f_dialTCP(_v_network string, _v_laddr *net.TCPAddr, _v_raddr *net.TCPAddr) Object {
	_res1, _res2 := net.DialTCP(_v_network, _v_laddr, _v_raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTimeout from net/dial.go:
// func _f_dialTimeout(_v_network string, _v_address string, _v_timeout ABEND002(reference to unavailable package `time' looking for type `Duration')) Object {
// 	_res1, _res2 := net.DialTimeout(_v_network, _v_address, _v_timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
func _f_dialUDP(_v_network string, _v_laddr *net.UDPAddr, _v_raddr *net.UDPAddr) Object {
	_res1, _res2 := net.DialUDP(_v_network, _v_laddr, _v_raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialUnix from net/unixsock.go:
func _f_dialUnix(_v_network string, _v_laddr *net.UnixAddr, _v_raddr *net.UnixAddr) Object {
	_res1, _res2 := net.DialUnix(_v_network, _v_laddr, _v_raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.FileConn from net/file.go:
// func _f_fileConn(_v_f *ABEND002(reference to unavailable package `os' looking for type `File')) Object {
// 	c, err := net.FileConn(_v_f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func _f_fileListener(_v_f *ABEND002(reference to unavailable package `os' looking for type `File')) Object {
// 	ln, err := net.FileListener(_v_f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func _f_filePacketConn(_v_f *ABEND002(reference to unavailable package `os' looking for type `File')) Object {
// 	c, err := net.FilePacketConn(_v_f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func _f_iPv4(_v_a byte, _v_b byte, _v_c byte, _v_d byte) Object {
	_res := net.IPv4(_v_a, _v_b, _v_c, _v_d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func _f_iPv4Mask(_v_a byte, _v_b byte, _v_c byte, _v_d byte) Object {
	_res := net.IPv4Mask(_v_a, _v_b, _v_c, _v_d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func _f_interfaceAddrs() Object {
	_res1, _res2 := net.InterfaceAddrs()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func _f_interfaceByIndex(_v_index int) Object {
	_res1, _res2 := net.InterfaceByIndex(_v_index)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func _f_interfaceByName(_v_name string) Object {
	_res1, _res2 := net.InterfaceByName(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func _f_interfaces() Object {
	_res1, _res2 := net.Interfaces()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func _f_listen(_v_network string, _v_address string) Object {
	_res1, _res2 := net.Listen(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
func _f_listenIP(_v_network string, _v_laddr *net.IPAddr) Object {
	_res1, _res2 := net.ListenIP(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
func _f_listenMulticastUDP(_v_network string, _v_ifi *net.Interface, _v_gaddr *net.UDPAddr) Object {
	_res1, _res2 := net.ListenMulticastUDP(_v_network, _v_ifi, _v_gaddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenPacket from net/dial.go:
func _f_listenPacket(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ListenPacket(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
func _f_listenTCP(_v_network string, _v_laddr *net.TCPAddr) Object {
	_res1, _res2 := net.ListenTCP(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUDP from net/udpsock.go:
func _f_listenUDP(_v_network string, _v_laddr *net.UDPAddr) Object {
	_res1, _res2 := net.ListenUDP(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnix from net/unixsock.go:
func _f_listenUnix(_v_network string, _v_laddr *net.UnixAddr) Object {
	_res1, _res2 := net.ListenUnix(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnixgram from net/unixsock.go:
func _f_listenUnixgram(_v_network string, _v_laddr *net.UnixAddr) Object {
	_res1, _res2 := net.ListenUnixgram(_v_network, _v_laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func _f_lookupAddr(_v_addr string) Object {
	names, err := net.LookupAddr(_v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(names))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func _f_lookupCNAME(_v_host string) Object {
	cname, err := net.LookupCNAME(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func _f_lookupHost(_v_host string) Object {
	addrs, err := net.LookupHost(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(addrs))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func _f_lookupIP(_v_host string) Object {
	_res1, _res2 := net.LookupIP(_v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func _f_lookupMX(_v_name string) Object {
	_res1, _res2 := net.LookupMX(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func _f_lookupNS(_v_name string) Object {
	_res1, _res2 := net.LookupNS(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func _f_lookupPort(_v_network string, _v_service string) Object {
	port, err := net.LookupPort(_v_network, _v_service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func _f_lookupSRV(_v_service string, _v_proto string, _v_name string) Object {
	cname, addrs, err := net.LookupSRV(_v_service, _v_proto, _v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(MakeGoObject(addrs))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func _f_lookupTXT(_v_name string) Object {
	_res1, _res2 := net.LookupTXT(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func _f_parseCIDR(_v_s string) Object {
	_res1, _res2, _res3 := net.ParseCIDR(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func _f_parseIP(_v_s string) Object {
	_res := net.ParseIP(_v_s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func _f_parseMAC(_v_s string) Object {
	hw, err := net.ParseMAC(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func _f_pipe() Object {
	_res1, _res2 := net.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func _f_resolveIPAddr(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ResolveIPAddr(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func _f_resolveTCPAddr(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ResolveTCPAddr(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func _f_resolveUDPAddr(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ResolveUDPAddr(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func _f_resolveUnixAddr(_v_network string, _v_address string) Object {
	_res1, _res2 := net.ResolveUnixAddr(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func _f_splitHostPort(_v_hostport string) Object {
	host, port, err := net.SplitHostPort(_v_hostport)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_addr_Network from net/net.go:
func _f_addr_Network(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Addr)Network()", args, 0, 0)
	_res := o.O.(net.Addr).Network()
	return MakeString(_res)
}

GO FUNC net._f_addr_String from net/net.go:
func _f_addr_String(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Addr)String()", args, 0, 0)
	_res := o.O.(net.Addr).String()
	return MakeString(_res)
}

GO FUNC net._f_conn_Close from net/net.go:
func _f_conn_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)Close()", args, 0, 0)
	_res := o.O.(net.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_conn_LocalAddr from net/net.go:
func _f_conn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)LocalAddr()", args, 0, 0)
	_res := o.O.(net.Conn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net._f_conn_Read from net/net.go:
func _f_conn_Read(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.Conn)Read()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(net.Conn).Read(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_conn_RemoteAddr from net/net.go:
func _f_conn_RemoteAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Conn)RemoteAddr()", args, 0, 0)
	_res := o.O.(net.Conn).RemoteAddr()
	return MakeGoObject(_res)
}

GO FUNC net._f_conn_SetDeadline from net/net.go:
// func _f_conn_SetDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_conn_SetReadDeadline from net/net.go:
// func _f_conn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_conn_SetWriteDeadline from net/net.go:
// func _f_conn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_conn_Write from net/net.go:
func _f_conn_Write(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.Conn)Write()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(net.Conn).Write(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_error_Error from net/net.go:
// func _f_error_Error(o GoObject, args Object) Object {  // Method
// 	CheckReceiverArity("(net.Error)Error()", args, 0, 0)
// 	return o.O.(net.Error).Error()
// 	ABEND124(post.go: no public information returned)
// }

GO FUNC net._f_error_Temporary from net/net.go:
func _f_error_Temporary(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Error)Temporary()", args, 0, 0)
	_res := o.O.(net.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_error_Timeout from net/net.go:
func _f_error_Timeout(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Error)Timeout()", args, 0, 0)
	_res := o.O.(net.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_flags_String from net/interface.go:
func _f_flags_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.Flags)String()", args, 0, 0)
	_res := o.O.(net.Flags).String()
	return MakeString(_res)
}

GO FUNC net._f_hardwareAddr_String from net/mac.go:
func _f_hardwareAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.HardwareAddr)String()", args, 0, 0)
	_res := o.O.(net.HardwareAddr).String()
	return MakeString(_res)
}

GO FUNC net._f_iPMask_Size from net/ip.go:
func _f_iPMask_Size(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

GO FUNC net._f_iPMask_String from net/ip.go:
func _f_iPMask_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IPMask)String()", args, 0, 0)
	_res := o.O.(net.IPMask).String()
	return MakeString(_res)
}

GO FUNC net._f_iP_DefaultMask from net/ip.go:
func _f_iP_DefaultMask(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(net.IP).DefaultMask()
	return MakeGoObject(_res)
}

GO FUNC net._f_iP_Equal from net/ip.go:
func _f_iP_Equal(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(net.IP)Equal()", args, 1, 1)
	_v_x := SeqNth(_argList, 0).(GoObject).O.(net.IP)
	_res := o.O.(net.IP).Equal(_v_x)
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsGlobalUnicast from net/ip.go:
func _f_iP_IsGlobalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsInterfaceLocalMulticast from net/ip.go:
func _f_iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsLinkLocalMulticast from net/ip.go:
func _f_iP_IsLinkLocalMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsLinkLocalUnicast from net/ip.go:
func _f_iP_IsLinkLocalUnicast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsLoopback from net/ip.go:
func _f_iP_IsLoopback(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(net.IP).IsLoopback()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsMulticast from net/ip.go:
func _f_iP_IsMulticast(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(net.IP).IsMulticast()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_IsUnspecified from net/ip.go:
func _f_iP_IsUnspecified(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

GO FUNC net._f_iP_MarshalText from net/ip.go:
func _f_iP_MarshalText(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(net.IP).MarshalText()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_iP_Mask from net/ip.go:
func _f_iP_Mask(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(net.IP)Mask()", args, 1, 1)
	_v_mask := SeqNth(_argList, 0).(GoObject).O.(net.IPMask)
	_res := o.O.(net.IP).Mask(_v_mask)
	return MakeGoObject(_res)
}

GO FUNC net._f_iP_String from net/ip.go:
func _f_iP_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)String()", args, 0, 0)
	_res := o.O.(net.IP).String()
	return MakeString(_res)
}

GO FUNC net._f_iP_To16 from net/ip.go:
func _f_iP_To16(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)To16()", args, 0, 0)
	_res := o.O.(net.IP).To16()
	return MakeGoObject(_res)
}

GO FUNC net._f_iP_To4 from net/ip.go:
func _f_iP_To4(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.IP)To4()", args, 0, 0)
	_res := o.O.(net.IP).To4()
	return MakeGoObject(_res)
}

GO FUNC net._f_invalidAddrError_Error from net/net.go:
func _f_invalidAddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Error()
	return MakeString(_res)
}

GO FUNC net._f_invalidAddrError_Temporary from net/net.go:
func _f_invalidAddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_invalidAddrError_Timeout from net/net.go:
func _f_invalidAddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_listener_Accept from net/net.go:
func _f_listener_Accept(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(net.Listener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_listener_Addr from net/net.go:
func _f_listener_Addr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Addr()", args, 0, 0)
	_res := o.O.(net.Listener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net._f_listener_Close from net/net.go:
func _f_listener_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.Listener)Close()", args, 0, 0)
	_res := o.O.(net.Listener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_packetConn_Close from net/net.go:
func _f_packetConn_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.PacketConn)Close()", args, 0, 0)
	_res := o.O.(net.PacketConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_packetConn_LocalAddr from net/net.go:
func _f_packetConn_LocalAddr(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net.PacketConn)LocalAddr()", args, 0, 0)
	_res := o.O.(net.PacketConn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net._f_packetConn_ReadFrom from net/net.go:
func _f_packetConn_ReadFrom(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.PacketConn)ReadFrom()", args, 1, 1)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, addr, err := o.O.(net.PacketConn).ReadFrom(_v_p)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_packetConn_SetDeadline from net/net.go:
// func _f_packetConn_SetDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_packetConn_SetReadDeadline from net/net.go:
// func _f_packetConn_SetReadDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_packetConn_SetWriteDeadline from net/net.go:
// func _f_packetConn_SetWriteDeadline(o GoObject, args Object) Object {  // Method
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_packetConn_WriteTo from net/net.go:
func _f_packetConn_WriteTo(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net.PacketConn)WriteTo()", args, 2, 2)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	n, err := o.O.(net.PacketConn).WriteTo(_v_p, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_AddrError_Error from net/net.go:
func _f_ptrTo_AddrError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*net.AddrError).Error()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_AddrError_Temporary from net/net.go:
func _f_ptrTo_AddrError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*net.AddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_AddrError_Timeout from net/net.go:
func _f_ptrTo_AddrError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*net.AddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_Buffers_Read from net/net.go:
func _f_ptrTo_Buffers_Read(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.Buffers)Read()", args, 1, 1)
	_v_p := SeqNth(_argList, 0).(GoObject).O.([]byte)
	n, err := o.O.(*net.Buffers).Read(_v_p)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_Buffers_WriteTo from net/net.go:
// func _f_ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

GO FUNC net._f_ptrTo_DNSConfigError_Error from net/net.go:
func _f_ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Error()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_DNSConfigError_Temporary from net/net.go:
func _f_ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_DNSConfigError_Timeout from net/net.go:
func _f_ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_DNSError_Error from net/net.go:
func _f_ptrTo_DNSError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*net.DNSError).Error()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_DNSError_Temporary from net/net.go:
func _f_ptrTo_DNSError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*net.DNSError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_DNSError_Timeout from net/net.go:
func _f_ptrTo_DNSError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*net.DNSError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_Dialer_Dial from net/dial.go:
func _f_ptrTo_Dialer_Dial(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.Dialer)Dial()", args, 2, 2)
	_v_network := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_network): %s")
	_v_address := ObjectAsString(SeqNth(_argList, 1), "Arg[1] (_v_address): %s")
	_res1, _res2 := o.O.(*net.Dialer).Dial(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_Dialer_DialContext from net/dial.go:
// func _f_ptrTo_Dialer_DialContext(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), network string, address string)}

GO FUNC net._f_ptrTo_IPAddr_Network from net/iprawsock.go:
func _f_ptrTo_IPAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*net.IPAddr).Network()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_IPAddr_String from net/iprawsock.go:
func _f_ptrTo_IPAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*net.IPAddr).String()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_IPConn_ReadFrom from net/iprawsock.go:
func _f_ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadFrom()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.IPConn).ReadFrom(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPConn_ReadFromIP from net/iprawsock.go:
func _f_ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadFromIP()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.IPConn).ReadFromIP(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPConn_ReadMsgIP from net/iprawsock.go:
func _f_ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)ReadMsgIP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	n, oobn, flags, addr, err := o.O.(*net.IPConn).ReadMsgIP(_v_b, _v_oob)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(MakeInt(flags))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPConn_SyscallConn from net/iprawsock.go:
// func _f_ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_ptrTo_IPConn_WriteMsgIP from net/iprawsock.go:
func _f_ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteMsgIP()", args, 3, 3)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 2).(GoObject).O.(*net.IPAddr)
	n, oobn, err := o.O.(*net.IPConn).WriteMsgIP(_v_b, _v_oob, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPConn_WriteTo from net/iprawsock.go:
func _f_ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteTo()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	_res1, _res2 := o.O.(*net.IPConn).WriteTo(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPConn_WriteToIP from net/iprawsock.go:
func _f_ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPConn)WriteToIP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(*net.IPAddr)
	_res1, _res2 := o.O.(*net.IPConn).WriteToIP(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_IPNet_Contains from net/ip.go:
func _f_ptrTo_IPNet_Contains(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IPNet)Contains()", args, 1, 1)
	_v_ip := SeqNth(_argList, 0).(GoObject).O.(net.IP)
	_res := o.O.(*net.IPNet).Contains(_v_ip)
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_IPNet_Network from net/ip.go:
func _f_ptrTo_IPNet_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*net.IPNet).Network()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_IPNet_String from net/ip.go:
func _f_ptrTo_IPNet_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.IPNet)String()", args, 0, 0)
	_res := o.O.(*net.IPNet).String()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_IP_UnmarshalText from net/ip.go:
func _f_ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.IP)UnmarshalText()", args, 1, 1)
	_v_text := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res := o.O.(*net.IP).UnmarshalText(_v_text)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_Interface_Addrs from net/interface.go:
func _f_ptrTo_Interface_Addrs(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.Interface)Addrs()", args, 0, 0)
	_res1, _res2 := o.O.(*net.Interface).Addrs()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_Interface_MulticastAddrs from net/interface.go:
func _f_ptrTo_Interface_MulticastAddrs(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.Interface)MulticastAddrs()", args, 0, 0)
	_res1, _res2 := o.O.(*net.Interface).MulticastAddrs()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_ListenConfig_Listen from net/dial.go:
// func _f_ptrTo_ListenConfig_Listen(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), network string, address string)}

GO FUNC net._f_ptrTo_ListenConfig_ListenPacket from net/dial.go:
// func _f_ptrTo_ListenConfig_ListenPacket(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), network string, address string)}

GO FUNC net._f_ptrTo_OpError_Error from net/net.go:
func _f_ptrTo_OpError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Error()", args, 0, 0)
	_res := o.O.(*net.OpError).Error()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_OpError_Temporary from net/net.go:
func _f_ptrTo_OpError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*net.OpError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_OpError_Timeout from net/net.go:
func _f_ptrTo_OpError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*net.OpError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net._f_ptrTo_ParseError_Error from net/net.go:
func _f_ptrTo_ParseError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*net.ParseError).Error()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_Resolver_LookupAddr from net/lookup.go:
// func _f_ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), addr string)}

GO FUNC net._f_ptrTo_Resolver_LookupCNAME from net/lookup.go:
// func _f_ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

GO FUNC net._f_ptrTo_Resolver_LookupHost from net/lookup.go:
// func _f_ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

GO FUNC net._f_ptrTo_Resolver_LookupIPAddr from net/lookup.go:
// func _f_ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), host string)}

GO FUNC net._f_ptrTo_Resolver_LookupMX from net/lookup.go:
// func _f_ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

GO FUNC net._f_ptrTo_Resolver_LookupNS from net/lookup.go:
// func _f_ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

GO FUNC net._f_ptrTo_Resolver_LookupPort from net/lookup.go:
// func _f_ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), network string, service string)}

GO FUNC net._f_ptrTo_Resolver_LookupSRV from net/lookup.go:
// func _f_ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), service string, proto string, name string)}

GO FUNC net._f_ptrTo_Resolver_LookupTXT from net/lookup.go:
// func _f_ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'), name string)}

GO FUNC net._f_ptrTo_TCPAddr_Network from net/tcpsock.go:
func _f_ptrTo_TCPAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPAddr)Network()", args, 0, 0)
	_res := o.O.(*net.TCPAddr).Network()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_TCPAddr_String from net/tcpsock.go:
func _f_ptrTo_TCPAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPAddr)String()", args, 0, 0)
	_res := o.O.(*net.TCPAddr).String()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_TCPConn_CloseRead from net/tcpsock.go:
func _f_ptrTo_TCPConn_CloseRead(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPConn)CloseRead()", args, 0, 0)
	_res := o.O.(*net.TCPConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPConn_CloseWrite from net/tcpsock.go:
func _f_ptrTo_TCPConn_CloseWrite(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*net.TCPConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPConn_ReadFrom from net/tcpsock.go:
// func _f_ptrTo_TCPConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
// (r ABEND002(reference to unavailable package `io' looking for type `Reader'))}

GO FUNC net._f_ptrTo_TCPConn_SetKeepAlive from net/tcpsock.go:
func _f_ptrTo_TCPConn_SetKeepAlive(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.TCPConn)SetKeepAlive()", args, 1, 1)
	_v_keepalive := ObjectAsBoolean(SeqNth(_argList, 0), "Arg[0] (_v_keepalive): %s")
	_res := o.O.(*net.TCPConn).SetKeepAlive(_v_keepalive)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPConn_SetKeepAlivePeriod from net/tcpsock.go:
// func _f_ptrTo_TCPConn_SetKeepAlivePeriod(o GoObject, args Object) Object {  // Receiver
// (d ABEND002(reference to unavailable package `time' looking for type `Duration'))}

GO FUNC net._f_ptrTo_TCPConn_SetLinger from net/tcpsock.go:
func _f_ptrTo_TCPConn_SetLinger(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.TCPConn)SetLinger()", args, 1, 1)
	_v_sec := ObjectAsInt(SeqNth(_argList, 0), "Arg[0] (_v_sec): %s")
	_res := o.O.(*net.TCPConn).SetLinger(_v_sec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPConn_SetNoDelay from net/tcpsock.go:
func _f_ptrTo_TCPConn_SetNoDelay(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.TCPConn)SetNoDelay()", args, 1, 1)
	_v_noDelay := ObjectAsBoolean(SeqNth(_argList, 0), "Arg[0] (_v_noDelay): %s")
	_res := o.O.(*net.TCPConn).SetNoDelay(_v_noDelay)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPConn_SyscallConn from net/tcpsock.go:
// func _f_ptrTo_TCPConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_ptrTo_TCPListener_Accept from net/tcpsock.go:
func _f_ptrTo_TCPListener_Accept(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*net.TCPListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_TCPListener_AcceptTCP from net/tcpsock.go:
func _f_ptrTo_TCPListener_AcceptTCP(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPListener)AcceptTCP()", args, 0, 0)
	_res1, _res2 := o.O.(*net.TCPListener).AcceptTCP()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_TCPListener_Addr from net/tcpsock.go:
func _f_ptrTo_TCPListener_Addr(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPListener)Addr()", args, 0, 0)
	_res := o.O.(*net.TCPListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net._f_ptrTo_TCPListener_Close from net/tcpsock.go:
func _f_ptrTo_TCPListener_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.TCPListener)Close()", args, 0, 0)
	_res := o.O.(*net.TCPListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_TCPListener_File from net/tcpsock.go:
// func _f_ptrTo_TCPListener_File(o GoObject, args Object) Object {  // Receiver
// (f *ABEND002(reference to unavailable package `os' looking for type `File'), err error)}

GO FUNC net._f_ptrTo_TCPListener_SetDeadline from net/tcpsock.go:
// func _f_ptrTo_TCPListener_SetDeadline(o GoObject, args Object) Object {  // Receiver
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_ptrTo_TCPListener_SyscallConn from net/tcpsock.go:
// func _f_ptrTo_TCPListener_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_ptrTo_UDPAddr_Network from net/udpsock.go:
func _f_ptrTo_UDPAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UDPAddr)Network()", args, 0, 0)
	_res := o.O.(*net.UDPAddr).Network()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_UDPAddr_String from net/udpsock.go:
func _f_ptrTo_UDPAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UDPAddr)String()", args, 0, 0)
	_res := o.O.(*net.UDPAddr).String()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_UDPConn_ReadFrom from net/udpsock.go:
func _f_ptrTo_UDPConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)ReadFrom()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.UDPConn).ReadFrom(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_UDPConn_ReadFromUDP from net/udpsock.go:
func _f_ptrTo_UDPConn_ReadFromUDP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)ReadFromUDP()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.UDPConn).ReadFromUDP(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_UDPConn_ReadMsgUDP from net/udpsock.go:
func _f_ptrTo_UDPConn_ReadMsgUDP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)ReadMsgUDP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	n, oobn, flags, addr, err := o.O.(*net.UDPConn).ReadMsgUDP(_v_b, _v_oob)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(MakeInt(flags))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_UDPConn_SyscallConn from net/udpsock.go:
// func _f_ptrTo_UDPConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_ptrTo_UDPConn_WriteMsgUDP from net/udpsock.go:
func _f_ptrTo_UDPConn_WriteMsgUDP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)WriteMsgUDP()", args, 3, 3)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 2).(GoObject).O.(*net.UDPAddr)
	n, oobn, err := o.O.(*net.UDPConn).WriteMsgUDP(_v_b, _v_oob, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_UDPConn_WriteTo from net/udpsock.go:
func _f_ptrTo_UDPConn_WriteTo(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)WriteTo()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	_res1, _res2 := o.O.(*net.UDPConn).WriteTo(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UDPConn_WriteToUDP from net/udpsock.go:
func _f_ptrTo_UDPConn_WriteToUDP(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UDPConn)WriteToUDP()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(*net.UDPAddr)
	_res1, _res2 := o.O.(*net.UDPConn).WriteToUDP(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixAddr_Network from net/unixsock.go:
func _f_ptrTo_UnixAddr_Network(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixAddr)Network()", args, 0, 0)
	_res := o.O.(*net.UnixAddr).Network()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_UnixAddr_String from net/unixsock.go:
func _f_ptrTo_UnixAddr_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixAddr)String()", args, 0, 0)
	_res := o.O.(*net.UnixAddr).String()
	return MakeString(_res)
}

GO FUNC net._f_ptrTo_UnixConn_CloseRead from net/unixsock.go:
func _f_ptrTo_UnixConn_CloseRead(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixConn)CloseRead()", args, 0, 0)
	_res := o.O.(*net.UnixConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_UnixConn_CloseWrite from net/unixsock.go:
func _f_ptrTo_UnixConn_CloseWrite(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*net.UnixConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_UnixConn_ReadFrom from net/unixsock.go:
func _f_ptrTo_UnixConn_ReadFrom(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)ReadFrom()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.UnixConn).ReadFrom(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixConn_ReadFromUnix from net/unixsock.go:
func _f_ptrTo_UnixConn_ReadFromUnix(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)ReadFromUnix()", args, 1, 1)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2, _res3 := o.O.(*net.UnixConn).ReadFromUnix(_v_b)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixConn_ReadMsgUnix from net/unixsock.go:
func _f_ptrTo_UnixConn_ReadMsgUnix(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)ReadMsgUnix()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	n, oobn, flags, addr, err := o.O.(*net.UnixConn).ReadMsgUnix(_v_b, _v_oob)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(MakeInt(flags))
	_res = _res.Conjoin(MakeGoObject(addr))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixConn_SyscallConn from net/unixsock.go:
// func _f_ptrTo_UnixConn_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_ptrTo_UnixConn_WriteMsgUnix from net/unixsock.go:
func _f_ptrTo_UnixConn_WriteMsgUnix(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)WriteMsgUnix()", args, 3, 3)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_oob := SeqNth(_argList, 1).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 2).(GoObject).O.(*net.UnixAddr)
	n, oobn, err := o.O.(*net.UnixConn).WriteMsgUnix(_v_b, _v_oob, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(MakeInt(oobn))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixConn_WriteTo from net/unixsock.go:
func _f_ptrTo_UnixConn_WriteTo(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)WriteTo()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(net.Addr)
	_res1, _res2 := o.O.(*net.UnixConn).WriteTo(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixConn_WriteToUnix from net/unixsock.go:
func _f_ptrTo_UnixConn_WriteToUnix(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*net.UnixConn)WriteToUnix()", args, 2, 2)
	_v_b := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_addr := SeqNth(_argList, 1).(GoObject).O.(*net.UnixAddr)
	_res1, _res2 := o.O.(*net.UnixConn).WriteToUnix(_v_b, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixListener_Accept from net/unixsock.go:
func _f_ptrTo_UnixListener_Accept(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*net.UnixListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixListener_AcceptUnix from net/unixsock.go:
func _f_ptrTo_UnixListener_AcceptUnix(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixListener)AcceptUnix()", args, 0, 0)
	_res1, _res2 := o.O.(*net.UnixListener).AcceptUnix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net._f_ptrTo_UnixListener_Addr from net/unixsock.go:
func _f_ptrTo_UnixListener_Addr(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixListener)Addr()", args, 0, 0)
	_res := o.O.(*net.UnixListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net._f_ptrTo_UnixListener_Close from net/unixsock.go:
func _f_ptrTo_UnixListener_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*net.UnixListener)Close()", args, 0, 0)
	_res := o.O.(*net.UnixListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net._f_ptrTo_UnixListener_File from net/unixsock.go:
// func _f_ptrTo_UnixListener_File(o GoObject, args Object) Object {  // Receiver
// (f *ABEND002(reference to unavailable package `os' looking for type `File'), err error)}

GO FUNC net._f_ptrTo_UnixListener_SetDeadline from net/unixsock.go:
// func _f_ptrTo_UnixListener_SetDeadline(o GoObject, args Object) Object {  // Receiver
// (t ABEND002(reference to unavailable package `time' looking for type `Time'))}

GO FUNC net._f_ptrTo_UnixListener_SetUnlinkOnClose from net/unixsock_posix.go:
// func _f_ptrTo_UnixListener_SetUnlinkOnClose(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net._f_ptrTo_UnixListener_SyscallConn from net/unixsock.go:
// func _f_ptrTo_UnixListener_SyscallConn(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `syscall' looking for type `RawConn'), error)}

GO FUNC net._f_unknownNetworkError_Error from net/net.go:
func _f_unknownNetworkError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Error()
	return MakeString(_res)
}

GO FUNC net._f_unknownNetworkError_Temporary from net/net.go:
func _f_unknownNetworkError_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net._f_unknownNetworkError_Timeout from net/net.go:
func _f_unknownNetworkError_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}

GO VARDEF FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
var info_Addr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
var info_AddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToAddrError from _tests/big/src/net/net.go:520:6:
var info_PtrTo_AddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfAddrError from _tests/big/src/net/net.go:520:6:
var info_ArrayOf_AddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
var info_Buffers GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToBuffers from _tests/big/src/net/net.go:642:6:
var info_PtrTo_Buffers GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfBuffers from _tests/big/src/net/net.go:642:6:
var info_ArrayOf_Buffers GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
var info_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
var info_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToDNSConfigError from _tests/big/src/net/net.go:553:6:
var info_PtrTo_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfDNSConfigError from _tests/big/src/net/net.go:553:6:
var info_ArrayOf_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
var info_DNSError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToDNSError from _tests/big/src/net/net.go:567:6:
var info_PtrTo_DNSError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfDNSError from _tests/big/src/net/net.go:567:6:
var info_ArrayOf_DNSError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
var info_Dialer GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToDialer from _tests/big/src/net/dial.go:20:6:
var info_PtrTo_Dialer GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfDialer from _tests/big/src/net/dial.go:20:6:
var info_ArrayOf_Dialer GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
var info_Flags GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToFlags from _tests/big/src/net/interface.go:38:6:
var info_PtrTo_Flags GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfFlags from _tests/big/src/net/interface.go:38:6:
var info_ArrayOf_Flags GoTypeInfo

GO VARDEF FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
var info_HardwareAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToHardwareAddr from _tests/big/src/net/mac.go:10:6:
var info_PtrTo_HardwareAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfHardwareAddr from _tests/big/src/net/mac.go:10:6:
var info_ArrayOf_HardwareAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
var info_IP GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToIP from _tests/big/src/net/ip.go:32:6:
var info_PtrTo_IP GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
var info_IPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToIPAddr from _tests/big/src/net/iprawsock.go:31:6:
var info_PtrTo_IPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfIPAddr from _tests/big/src/net/iprawsock.go:31:6:
var info_ArrayOf_IPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
var info_IPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToIPConn from _tests/big/src/net/iprawsock.go:99:6:
var info_PtrTo_IPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfIPConn from _tests/big/src/net/iprawsock.go:99:6:
var info_ArrayOf_IPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
var info_IPMask GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToIPMask from _tests/big/src/net/ip.go:35:6:
var info_PtrTo_IPMask GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfIPMask from _tests/big/src/net/ip.go:35:6:
var info_ArrayOf_IPMask GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
var info_IPNet GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToIPNet from _tests/big/src/net/ip.go:38:6:
var info_PtrTo_IPNet GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfIPNet from _tests/big/src/net/ip.go:38:6:
var info_ArrayOf_IPNet GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfIP from _tests/big/src/net/ip.go:32:6:
var info_ArrayOf_IP GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
var info_Interface GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToInterface from _tests/big/src/net/interface.go:30:6:
var info_PtrTo_Interface GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfInterface from _tests/big/src/net/interface.go:30:6:
var info_ArrayOf_Interface GoTypeInfo

GO VARDEF FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
var info_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToInvalidAddrError from _tests/big/src/net/net.go:545:6:
var info_PtrTo_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfInvalidAddrError from _tests/big/src/net/net.go:545:6:
var info_ArrayOf_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
var info_ListenConfig GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToListenConfig from _tests/big/src/net/dial.go:576:6:
var info_PtrTo_ListenConfig GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfListenConfig from _tests/big/src/net/dial.go:576:6:
var info_ArrayOf_ListenConfig GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
var info_Listener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
var info_MX GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToMX from _tests/big/src/net/dnsclient.go:193:6:
var info_PtrTo_MX GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfMX from _tests/big/src/net/dnsclient.go:193:6:
var info_ArrayOf_MX GoTypeInfo

GO VARDEF FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
var info_NS GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToNS from _tests/big/src/net/dnsclient.go:215:6:
var info_PtrTo_NS GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfNS from _tests/big/src/net/dnsclient.go:215:6:
var info_ArrayOf_NS GoTypeInfo

GO VARDEF FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
var info_OpError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToOpError from _tests/big/src/net/net.go:416:6:
var info_PtrTo_OpError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfOpError from _tests/big/src/net/net.go:416:6:
var info_ArrayOf_OpError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
var info_PacketConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
var info_ParseError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToParseError from _tests/big/src/net/net.go:509:6:
var info_PtrTo_ParseError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfParseError from _tests/big/src/net/net.go:509:6:
var info_ArrayOf_ParseError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
var info_Resolver GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToResolver from _tests/big/src/net/lookup.go:107:6:
var info_PtrTo_Resolver GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfResolver from _tests/big/src/net/lookup.go:107:6:
var info_ArrayOf_Resolver GoTypeInfo

GO VARDEF FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
var info_SRV GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToSRV from _tests/big/src/net/dnsclient.go:139:6:
var info_PtrTo_SRV GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfSRV from _tests/big/src/net/dnsclient.go:139:6:
var info_ArrayOf_SRV GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
var info_TCPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
var info_PtrTo_TCPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
var info_ArrayOf_TCPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
var info_TCPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToTCPConn from _tests/big/src/net/tcpsock.go:85:6:
var info_PtrTo_TCPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfTCPConn from _tests/big/src/net/tcpsock.go:85:6:
var info_ArrayOf_TCPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
var info_TCPListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToTCPListener from _tests/big/src/net/tcpsock.go:225:6:
var info_PtrTo_TCPListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfTCPListener from _tests/big/src/net/tcpsock.go:225:6:
var info_ArrayOf_TCPListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
var info_UDPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUDPAddr from _tests/big/src/net/udpsock.go:25:6:
var info_PtrTo_UDPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUDPAddr from _tests/big/src/net/udpsock.go:25:6:
var info_ArrayOf_UDPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
var info_UDPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUDPConn from _tests/big/src/net/udpsock.go:91:6:
var info_PtrTo_UDPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUDPConn from _tests/big/src/net/udpsock.go:91:6:
var info_ArrayOf_UDPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
var info_UnixAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUnixAddr from _tests/big/src/net/unixsock.go:19:6:
var info_PtrTo_UnixAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUnixAddr from _tests/big/src/net/unixsock.go:19:6:
var info_ArrayOf_UnixAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
var info_UnixConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUnixConn from _tests/big/src/net/unixsock.go:65:6:
var info_PtrTo_UnixConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUnixConn from _tests/big/src/net/unixsock.go:65:6:
var info_ArrayOf_UnixConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
var info_UnixListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUnixListener from _tests/big/src/net/unixsock.go:217:6:
var info_PtrTo_UnixListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUnixListener from _tests/big/src/net/unixsock.go:217:6:
var info_ArrayOf_UnixListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
var info_UnknownNetworkError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/refToUnknownNetworkError from _tests/big/src/net/net.go:539:6:
var info_PtrTo_UnknownNetworkError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/arrayOfUnknownNetworkError from _tests/big/src/net/net.go:539:6:
var info_ArrayOf_UnknownNetworkError GoTypeInfo

GO INFO FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
	info_Addr = GoTypeInfo{Name: "go.std.net/Addr",
		GoType: &GoType{T: &info_Addr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_addr_Network, "name of the network (for example, \"tcp\", \"udp\")\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_addr_String, "string form of address (for example, \"192.0.2.1:25\", \"[2001:db8::1]:80\")\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
	info_AddrError = GoTypeInfo{Name: "go.std.net/AddrError",
		GoType: &GoType{T: &info_AddrError},
		Ctor: _Wrapped_Ctor_AddrError,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToAddrError from _tests/big/src/net/net.go:520:6:
	info_PtrTo_AddrError = GoTypeInfo{Name: "go.std.net/refToAddrError",
		GoType: &GoType{T: &info_PtrTo_AddrError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_AddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_AddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_AddrError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfAddrError from _tests/big/src/net/net.go:520:6:
	info_ArrayOf_AddrError = GoTypeInfo{Name: "go.std.net/arrayOfAddrError",
		GoType: &GoType{T: &info_ArrayOf_AddrError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
	info_Buffers = GoTypeInfo{Name: "go.std.net/Buffers",
		GoType: &GoType{T: &info_Buffers},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToBuffers from _tests/big/src/net/net.go:642:6:
	info_PtrTo_Buffers = GoTypeInfo{Name: "go.std.net/refToBuffers",
		GoType: &GoType{T: &info_PtrTo_Buffers},
		Members: GoMembers{
			"Read": MakeGoReceiver("Read", _f_ptrTo_Buffers_Read, "", "1.0", NewVectorFrom(MakeSymbol("p"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfBuffers from _tests/big/src/net/net.go:642:6:
	info_ArrayOf_Buffers = GoTypeInfo{Name: "go.std.net/arrayOfBuffers",
		GoType: &GoType{T: &info_ArrayOf_Buffers},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
	info_Conn = GoTypeInfo{Name: "go.std.net/Conn",
		GoType: &GoType{T: &info_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_conn_Close, "Close closes the connection.\nAny blocked Read or Write operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", _f_conn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
			"Read": MakeGoReceiver("Read", _f_conn_Read, "Read reads data from the connection.\nRead can be made to time out and return an Error with Timeout() == true\nafter a fixed time limit; see SetDeadline and SetReadDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"RemoteAddr": MakeGoReceiver("RemoteAddr", _f_conn_RemoteAddr, "RemoteAddr returns the remote network address.\n", "1.0", NewVectorFrom()),
			"Write": MakeGoReceiver("Write", _f_conn_Write, "Write writes data to the connection.\nWrite can be made to time out and return an Error with Timeout() == true\nafter a fixed time limit; see SetDeadline and SetWriteDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
		},
	}


GO INFO FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
	info_DNSConfigError = GoTypeInfo{Name: "go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_DNSConfigError},
		Ctor: _Wrapped_Ctor_DNSConfigError,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToDNSConfigError from _tests/big/src/net/net.go:553:6:
	info_PtrTo_DNSConfigError = GoTypeInfo{Name: "go.std.net/refToDNSConfigError",
		GoType: &GoType{T: &info_PtrTo_DNSConfigError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_DNSConfigError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_DNSConfigError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_DNSConfigError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfDNSConfigError from _tests/big/src/net/net.go:553:6:
	info_ArrayOf_DNSConfigError = GoTypeInfo{Name: "go.std.net/arrayOfDNSConfigError",
		GoType: &GoType{T: &info_ArrayOf_DNSConfigError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
	info_DNSError = GoTypeInfo{Name: "go.std.net/DNSError",
		GoType: &GoType{T: &info_DNSError},
		Ctor: _Wrapped_Ctor_DNSError,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToDNSError from _tests/big/src/net/net.go:567:6:
	info_PtrTo_DNSError = GoTypeInfo{Name: "go.std.net/refToDNSError",
		GoType: &GoType{T: &info_PtrTo_DNSError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_DNSError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_DNSError_Temporary, "Temporary reports whether the DNS error is known to be temporary.\nThis is not always known; a DNS lookup may fail due to a temporary\nerror and return a DNSError for which Temporary returns false.\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_DNSError_Timeout, "Timeout reports whether the DNS lookup is known to have timed out.\nThis is not always known; a DNS lookup may fail due to a timeout\nand return a DNSError for which Timeout returns false.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfDNSError from _tests/big/src/net/net.go:567:6:
	info_ArrayOf_DNSError = GoTypeInfo{Name: "go.std.net/arrayOfDNSError",
		GoType: &GoType{T: &info_ArrayOf_DNSError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
	info_Dialer = GoTypeInfo{Name: "go.std.net/Dialer",
		GoType: &GoType{T: &info_Dialer},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToDialer from _tests/big/src/net/dial.go:20:6:
	info_PtrTo_Dialer = GoTypeInfo{Name: "go.std.net/refToDialer",
		GoType: &GoType{T: &info_PtrTo_Dialer},
		Members: GoMembers{
			"Dial": MakeGoReceiver("Dial", _f_ptrTo_Dialer_Dial, "Dial connects to the address on the named network.\n\nSee func Dial for a description of the network and address\nparameters.\n", "1.0", NewVectorFrom(MakeSymbol("network"), MakeSymbol("address"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfDialer from _tests/big/src/net/dial.go:20:6:
	info_ArrayOf_Dialer = GoTypeInfo{Name: "go.std.net/arrayOfDialer",
		GoType: &GoType{T: &info_ArrayOf_Dialer},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
	info_Error = GoTypeInfo{Name: "go.std.net/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
			"Temporary": MakeGoReceiver("Temporary", _f_error_Temporary, "Is the error temporary?\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_error_Timeout, "Is the error a timeout?\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
	info_Flags = GoTypeInfo{Name: "go.std.net/Flags",
		GoType: &GoType{T: &info_Flags},
		Ctor: _Wrapped_Ctor_Flags,
		Members: GoMembers{
			"String": MakeGoReceiver("String", _f_flags_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToFlags from _tests/big/src/net/interface.go:38:6:
	info_PtrTo_Flags = GoTypeInfo{Name: "go.std.net/refToFlags",
		GoType: &GoType{T: &info_PtrTo_Flags},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfFlags from _tests/big/src/net/interface.go:38:6:
	info_ArrayOf_Flags = GoTypeInfo{Name: "go.std.net/arrayOfFlags",
		GoType: &GoType{T: &info_ArrayOf_Flags},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
	info_HardwareAddr = GoTypeInfo{Name: "go.std.net/HardwareAddr",
		GoType: &GoType{T: &info_HardwareAddr},
		Members: GoMembers{
			"String": MakeGoReceiver("String", _f_hardwareAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToHardwareAddr from _tests/big/src/net/mac.go:10:6:
	info_PtrTo_HardwareAddr = GoTypeInfo{Name: "go.std.net/refToHardwareAddr",
		GoType: &GoType{T: &info_PtrTo_HardwareAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfHardwareAddr from _tests/big/src/net/mac.go:10:6:
	info_ArrayOf_HardwareAddr = GoTypeInfo{Name: "go.std.net/arrayOfHardwareAddr",
		GoType: &GoType{T: &info_ArrayOf_HardwareAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
	info_IP = GoTypeInfo{Name: "go.std.net/IP",
		GoType: &GoType{T: &info_IP},
		Members: GoMembers{
			"DefaultMask": MakeGoReceiver("DefaultMask", _f_iP_DefaultMask, "DefaultMask returns the default IP mask for the IP address ip.\nOnly IPv4 addresses have default masks; DefaultMask returns\nnil if ip is not a valid IPv4 address.\n", "1.0", NewVectorFrom()),
			"Equal": MakeGoReceiver("Equal", _f_iP_Equal, "Equal reports whether ip and x are the same IP address.\nAn IPv4 address and that same address in IPv6 form are\nconsidered to be equal.\n", "1.0", NewVectorFrom(MakeSymbol("x"))),
			"IsGlobalUnicast": MakeGoReceiver("IsGlobalUnicast", _f_iP_IsGlobalUnicast, "IsGlobalUnicast reports whether ip is a global unicast\naddress.\n\nThe identification of global unicast addresses uses address type\nidentification as defined in RFC 1122, RFC 4632 and RFC 4291 with\nthe exception of IPv4 directed broadcast addresses.\nIt returns true even if ip is in IPv4 private address space or\nlocal IPv6 unicast address space.\n", "1.0", NewVectorFrom()),
			"IsInterfaceLocalMulticast": MakeGoReceiver("IsInterfaceLocalMulticast", _f_iP_IsInterfaceLocalMulticast, "IsInterfaceLocalMulticast reports whether ip is\nan interface-local multicast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalMulticast": MakeGoReceiver("IsLinkLocalMulticast", _f_iP_IsLinkLocalMulticast, "IsLinkLocalMulticast reports whether ip is a link-local\nmulticast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalUnicast": MakeGoReceiver("IsLinkLocalUnicast", _f_iP_IsLinkLocalUnicast, "IsLinkLocalUnicast reports whether ip is a link-local\nunicast address.\n", "1.0", NewVectorFrom()),
			"IsLoopback": MakeGoReceiver("IsLoopback", _f_iP_IsLoopback, "IsLoopback reports whether ip is a loopback address.\n", "1.0", NewVectorFrom()),
			"IsMulticast": MakeGoReceiver("IsMulticast", _f_iP_IsMulticast, "IsMulticast reports whether ip is a multicast address.\n", "1.0", NewVectorFrom()),
			"IsUnspecified": MakeGoReceiver("IsUnspecified", _f_iP_IsUnspecified, "IsUnspecified reports whether ip is an unspecified address, either\nthe IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".\n", "1.0", NewVectorFrom()),
			"MarshalText": MakeGoReceiver("MarshalText", _f_iP_MarshalText, "MarshalText implements the encoding.TextMarshaler interface.\nThe encoding is the same as returned by String, with one exception:\nWhen len(ip) is zero, it returns an empty slice.\n", "1.0", NewVectorFrom()),
			"Mask": MakeGoReceiver("Mask", _f_iP_Mask, "Mask returns the result of masking the IP address ip with mask.\n", "1.0", NewVectorFrom(MakeSymbol("mask"))),
			"String": MakeGoReceiver("String", _f_iP_String, "String returns the string form of the IP address ip.\nIt returns one of 4 forms:\n  - \"<nil>\", if ip has length 0\n  - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n  - IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n  - the hexadecimal form of ip, without punctuation, if no other cases apply\n", "1.0", NewVectorFrom()),
			"To16": MakeGoReceiver("To16", _f_iP_To16, "To16 converts the IP address ip to a 16-byte representation.\nIf ip is not an IP address (it is the wrong length), To16 returns nil.\n", "1.0", NewVectorFrom()),
			"To4": MakeGoReceiver("To4", _f_iP_To4, "To4 converts the IPv4 address ip to a 4-byte representation.\nIf ip is not an IPv4 address, To4 returns nil.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToIP from _tests/big/src/net/ip.go:32:6:
	info_PtrTo_IP = GoTypeInfo{Name: "go.std.net/refToIP",
		GoType: &GoType{T: &info_PtrTo_IP},
		Members: GoMembers{
			"UnmarshalText": MakeGoReceiver("UnmarshalText", _f_ptrTo_IP_UnmarshalText, "UnmarshalText implements the encoding.TextUnmarshaler interface.\nThe IP address is expected in a form accepted by ParseIP.\n", "1.0", NewVectorFrom(MakeSymbol("text"))),
		},
	}


GO INFO FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
	info_IPAddr = GoTypeInfo{Name: "go.std.net/IPAddr",
		GoType: &GoType{T: &info_IPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToIPAddr from _tests/big/src/net/iprawsock.go:31:6:
	info_PtrTo_IPAddr = GoTypeInfo{Name: "go.std.net/refToIPAddr",
		GoType: &GoType{T: &info_PtrTo_IPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_ptrTo_IPAddr_Network, "Network returns the address's network name, \"ip\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_IPAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfIPAddr from _tests/big/src/net/iprawsock.go:31:6:
	info_ArrayOf_IPAddr = GoTypeInfo{Name: "go.std.net/arrayOfIPAddr",
		GoType: &GoType{T: &info_ArrayOf_IPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
	info_IPConn = GoTypeInfo{Name: "go.std.net/IPConn",
		GoType: &GoType{T: &info_IPConn},
		Ctor: _Wrapped_Ctor_IPConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToIPConn from _tests/big/src/net/iprawsock.go:99:6:
	info_PtrTo_IPConn = GoTypeInfo{Name: "go.std.net/refToIPConn",
		GoType: &GoType{T: &info_PtrTo_IPConn},
		Members: GoMembers{
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_ptrTo_IPConn_ReadFrom, "ReadFrom implements the PacketConn ReadFrom method.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadFromIP": MakeGoReceiver("ReadFromIP", _f_ptrTo_IPConn_ReadFromIP, "ReadFromIP acts like ReadFrom but returns an IPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadMsgIP": MakeGoReceiver("ReadMsgIP", _f_ptrTo_IPConn_ReadMsgIP, "ReadMsgIP reads a message from c, copying the payload into b and\nthe associated out-of-band data into oob. It returns the number of\nbytes copied into b, the number of bytes copied into oob, the flags\nthat were set on the message and the source address of the message.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"))),
			"WriteMsgIP": MakeGoReceiver("WriteMsgIP", _f_ptrTo_IPConn_WriteMsgIP, "WriteMsgIP writes a message to addr via c, copying the payload from\nb and the associated out-of-band data from oob. It returns the\nnumber of payload and out-of-band bytes written.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"), MakeSymbol("addr"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_ptrTo_IPConn_WriteTo, "WriteTo implements the PacketConn WriteTo method.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
			"WriteToIP": MakeGoReceiver("WriteToIP", _f_ptrTo_IPConn_WriteToIP, "WriteToIP acts like WriteTo but takes an IPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfIPConn from _tests/big/src/net/iprawsock.go:99:6:
	info_ArrayOf_IPConn = GoTypeInfo{Name: "go.std.net/arrayOfIPConn",
		GoType: &GoType{T: &info_ArrayOf_IPConn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
	info_IPMask = GoTypeInfo{Name: "go.std.net/IPMask",
		GoType: &GoType{T: &info_IPMask},
		Members: GoMembers{
			"Size": MakeGoReceiver("Size", _f_iPMask_Size, "Size returns the number of leading ones and total bits in the mask.\nIf the mask is not in the canonical form--ones followed by zeros--then\nSize returns 0, 0.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_iPMask_String, "String returns the hexadecimal form of m, with no punctuation.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToIPMask from _tests/big/src/net/ip.go:35:6:
	info_PtrTo_IPMask = GoTypeInfo{Name: "go.std.net/refToIPMask",
		GoType: &GoType{T: &info_PtrTo_IPMask},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfIPMask from _tests/big/src/net/ip.go:35:6:
	info_ArrayOf_IPMask = GoTypeInfo{Name: "go.std.net/arrayOfIPMask",
		GoType: &GoType{T: &info_ArrayOf_IPMask},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
	info_IPNet = GoTypeInfo{Name: "go.std.net/IPNet",
		GoType: &GoType{T: &info_IPNet},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToIPNet from _tests/big/src/net/ip.go:38:6:
	info_PtrTo_IPNet = GoTypeInfo{Name: "go.std.net/refToIPNet",
		GoType: &GoType{T: &info_PtrTo_IPNet},
		Members: GoMembers{
			"Contains": MakeGoReceiver("Contains", _f_ptrTo_IPNet_Contains, "Contains reports whether the network includes ip.\n", "1.0", NewVectorFrom(MakeSymbol("ip"))),
			"Network": MakeGoReceiver("Network", _f_ptrTo_IPNet_Network, "Network returns the address's network name, \"ip+net\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_IPNet_String, "String returns the CIDR notation of n like \"192.0.2.1/24\"\nor \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291.\nIf the mask is not in the canonical form, it returns the\nstring which consists of an IP address, followed by a slash\ncharacter and a mask expressed as hexadecimal form with no\npunctuation like \"198.51.100.1/c000ff00\".\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfIPNet from _tests/big/src/net/ip.go:38:6:
	info_ArrayOf_IPNet = GoTypeInfo{Name: "go.std.net/arrayOfIPNet",
		GoType: &GoType{T: &info_ArrayOf_IPNet},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfIP from _tests/big/src/net/ip.go:32:6:
	info_ArrayOf_IP = GoTypeInfo{Name: "go.std.net/arrayOfIP",
		GoType: &GoType{T: &info_ArrayOf_IP},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
	info_Interface = GoTypeInfo{Name: "go.std.net/Interface",
		GoType: &GoType{T: &info_Interface},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToInterface from _tests/big/src/net/interface.go:30:6:
	info_PtrTo_Interface = GoTypeInfo{Name: "go.std.net/refToInterface",
		GoType: &GoType{T: &info_PtrTo_Interface},
		Members: GoMembers{
			"Addrs": MakeGoReceiver("Addrs", _f_ptrTo_Interface_Addrs, "Addrs returns a list of unicast interface addresses for a specific\ninterface.\n", "1.0", NewVectorFrom()),
			"MulticastAddrs": MakeGoReceiver("MulticastAddrs", _f_ptrTo_Interface_MulticastAddrs, "MulticastAddrs returns a list of multicast, joined group addresses\nfor a specific interface.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfInterface from _tests/big/src/net/interface.go:30:6:
	info_ArrayOf_Interface = GoTypeInfo{Name: "go.std.net/arrayOfInterface",
		GoType: &GoType{T: &info_ArrayOf_Interface},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
	info_InvalidAddrError = GoTypeInfo{Name: "go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_InvalidAddrError},
		Ctor: _Wrapped_Ctor_InvalidAddrError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_invalidAddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_invalidAddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_invalidAddrError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToInvalidAddrError from _tests/big/src/net/net.go:545:6:
	info_PtrTo_InvalidAddrError = GoTypeInfo{Name: "go.std.net/refToInvalidAddrError",
		GoType: &GoType{T: &info_PtrTo_InvalidAddrError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfInvalidAddrError from _tests/big/src/net/net.go:545:6:
	info_ArrayOf_InvalidAddrError = GoTypeInfo{Name: "go.std.net/arrayOfInvalidAddrError",
		GoType: &GoType{T: &info_ArrayOf_InvalidAddrError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
	info_ListenConfig = GoTypeInfo{Name: "go.std.net/ListenConfig",
		GoType: &GoType{T: &info_ListenConfig},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToListenConfig from _tests/big/src/net/dial.go:576:6:
	info_PtrTo_ListenConfig = GoTypeInfo{Name: "go.std.net/refToListenConfig",
		GoType: &GoType{T: &info_PtrTo_ListenConfig},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfListenConfig from _tests/big/src/net/dial.go:576:6:
	info_ArrayOf_ListenConfig = GoTypeInfo{Name: "go.std.net/arrayOfListenConfig",
		GoType: &GoType{T: &info_ArrayOf_ListenConfig},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
	info_Listener = GoTypeInfo{Name: "go.std.net/Listener",
		GoType: &GoType{T: &info_Listener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", _f_listener_Accept, "Accept waits for and returns the next connection to the listener.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", _f_listener_Addr, "Addr returns the listener's network address.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", _f_listener_Close, "Close closes the listener.\nAny blocked Accept operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
	info_MX = GoTypeInfo{Name: "go.std.net/MX",
		GoType: &GoType{T: &info_MX},
		Ctor: _Wrapped_Ctor_MX,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToMX from _tests/big/src/net/dnsclient.go:193:6:
	info_PtrTo_MX = GoTypeInfo{Name: "go.std.net/refToMX",
		GoType: &GoType{T: &info_PtrTo_MX},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfMX from _tests/big/src/net/dnsclient.go:193:6:
	info_ArrayOf_MX = GoTypeInfo{Name: "go.std.net/arrayOfMX",
		GoType: &GoType{T: &info_ArrayOf_MX},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
	info_NS = GoTypeInfo{Name: "go.std.net/NS",
		GoType: &GoType{T: &info_NS},
		Ctor: _Wrapped_Ctor_NS,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToNS from _tests/big/src/net/dnsclient.go:215:6:
	info_PtrTo_NS = GoTypeInfo{Name: "go.std.net/refToNS",
		GoType: &GoType{T: &info_PtrTo_NS},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfNS from _tests/big/src/net/dnsclient.go:215:6:
	info_ArrayOf_NS = GoTypeInfo{Name: "go.std.net/arrayOfNS",
		GoType: &GoType{T: &info_ArrayOf_NS},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
	info_OpError = GoTypeInfo{Name: "go.std.net/OpError",
		GoType: &GoType{T: &info_OpError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToOpError from _tests/big/src/net/net.go:416:6:
	info_PtrTo_OpError = GoTypeInfo{Name: "go.std.net/refToOpError",
		GoType: &GoType{T: &info_PtrTo_OpError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_OpError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_OpError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_OpError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfOpError from _tests/big/src/net/net.go:416:6:
	info_ArrayOf_OpError = GoTypeInfo{Name: "go.std.net/arrayOfOpError",
		GoType: &GoType{T: &info_ArrayOf_OpError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
	info_PacketConn = GoTypeInfo{Name: "go.std.net/PacketConn",
		GoType: &GoType{T: &info_PacketConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_packetConn_Close, "Close closes the connection.\nAny blocked ReadFrom or WriteTo operations will be unblocked and return errors.\n", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", _f_packetConn_LocalAddr, "LocalAddr returns the local network address.\n", "1.0", NewVectorFrom()),
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_packetConn_ReadFrom, "ReadFrom reads a packet from the connection,\ncopying the payload into p. It returns the number of\nbytes copied into p and the return address that\nwas on the packet.\nIt returns the number of bytes read (0 <= n <= len(p))\nand any error encountered. Callers should always process\nthe n > 0 bytes returned before considering the error err.\nReadFrom can be made to time out and return\nan Error with Timeout() == true after a fixed time limit;\nsee SetDeadline and SetReadDeadline.\n", "1.0", NewVectorFrom(MakeSymbol("p"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_packetConn_WriteTo, "WriteTo writes a packet with payload p to addr.\nWriteTo can be made to time out and return\nan Error with Timeout() == true after a fixed time limit;\nsee SetDeadline and SetWriteDeadline.\nOn packet-oriented connections, write timeouts are rare.\n", "1.0", NewVectorFrom(MakeSymbol("p"), MakeSymbol("addr"))),
		},
	}


GO INFO FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
	info_ParseError = GoTypeInfo{Name: "go.std.net/ParseError",
		GoType: &GoType{T: &info_ParseError},
		Ctor: _Wrapped_Ctor_ParseError,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToParseError from _tests/big/src/net/net.go:509:6:
	info_PtrTo_ParseError = GoTypeInfo{Name: "go.std.net/refToParseError",
		GoType: &GoType{T: &info_PtrTo_ParseError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_ParseError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfParseError from _tests/big/src/net/net.go:509:6:
	info_ArrayOf_ParseError = GoTypeInfo{Name: "go.std.net/arrayOfParseError",
		GoType: &GoType{T: &info_ArrayOf_ParseError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
	info_Resolver = GoTypeInfo{Name: "go.std.net/Resolver",
		GoType: &GoType{T: &info_Resolver},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToResolver from _tests/big/src/net/lookup.go:107:6:
	info_PtrTo_Resolver = GoTypeInfo{Name: "go.std.net/refToResolver",
		GoType: &GoType{T: &info_PtrTo_Resolver},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfResolver from _tests/big/src/net/lookup.go:107:6:
	info_ArrayOf_Resolver = GoTypeInfo{Name: "go.std.net/arrayOfResolver",
		GoType: &GoType{T: &info_ArrayOf_Resolver},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
	info_SRV = GoTypeInfo{Name: "go.std.net/SRV",
		GoType: &GoType{T: &info_SRV},
		Ctor: _Wrapped_Ctor_SRV,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToSRV from _tests/big/src/net/dnsclient.go:139:6:
	info_PtrTo_SRV = GoTypeInfo{Name: "go.std.net/refToSRV",
		GoType: &GoType{T: &info_PtrTo_SRV},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfSRV from _tests/big/src/net/dnsclient.go:139:6:
	info_ArrayOf_SRV = GoTypeInfo{Name: "go.std.net/arrayOfSRV",
		GoType: &GoType{T: &info_ArrayOf_SRV},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	info_TCPAddr = GoTypeInfo{Name: "go.std.net/TCPAddr",
		GoType: &GoType{T: &info_TCPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	info_PtrTo_TCPAddr = GoTypeInfo{Name: "go.std.net/refToTCPAddr",
		GoType: &GoType{T: &info_PtrTo_TCPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_ptrTo_TCPAddr_Network, "Network returns the address's network name, \"tcp\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_TCPAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	info_ArrayOf_TCPAddr = GoTypeInfo{Name: "go.std.net/arrayOfTCPAddr",
		GoType: &GoType{T: &info_ArrayOf_TCPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
	info_TCPConn = GoTypeInfo{Name: "go.std.net/TCPConn",
		GoType: &GoType{T: &info_TCPConn},
		Ctor: _Wrapped_Ctor_TCPConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToTCPConn from _tests/big/src/net/tcpsock.go:85:6:
	info_PtrTo_TCPConn = GoTypeInfo{Name: "go.std.net/refToTCPConn",
		GoType: &GoType{T: &info_PtrTo_TCPConn},
		Members: GoMembers{
			"CloseRead": MakeGoReceiver("CloseRead", _f_ptrTo_TCPConn_CloseRead, "CloseRead shuts down the reading side of the TCP connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"CloseWrite": MakeGoReceiver("CloseWrite", _f_ptrTo_TCPConn_CloseWrite, "CloseWrite shuts down the writing side of the TCP connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"SetKeepAlive": MakeGoReceiver("SetKeepAlive", _f_ptrTo_TCPConn_SetKeepAlive, "SetKeepAlive sets whether the operating system should send\nkeepalive messages on the connection.\n", "1.0", NewVectorFrom(MakeSymbol("keepalive"))),
			"SetLinger": MakeGoReceiver("SetLinger", _f_ptrTo_TCPConn_SetLinger, "SetLinger sets the behavior of Close on a connection which still\nhas data waiting to be sent or to be acknowledged.\n\nIf sec < 0 (the default), the operating system finishes sending the\ndata in the background.\n\nIf sec == 0, the operating system discards any unsent or\nunacknowledged data.\n\nIf sec > 0, the data is sent in the background as with sec < 0. On\nsome operating systems after sec seconds have elapsed any remaining\nunsent data may be discarded.\n", "1.0", NewVectorFrom(MakeSymbol("sec"))),
			"SetNoDelay": MakeGoReceiver("SetNoDelay", _f_ptrTo_TCPConn_SetNoDelay, "SetNoDelay controls whether the operating system should delay\npacket transmission in hopes of sending fewer packets (Nagle's\nalgorithm).  The default is true (no delay), meaning that data is\nsent as soon as possible after a Write.\n", "1.0", NewVectorFrom(MakeSymbol("noDelay"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfTCPConn from _tests/big/src/net/tcpsock.go:85:6:
	info_ArrayOf_TCPConn = GoTypeInfo{Name: "go.std.net/arrayOfTCPConn",
		GoType: &GoType{T: &info_ArrayOf_TCPConn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
	info_TCPListener = GoTypeInfo{Name: "go.std.net/TCPListener",
		GoType: &GoType{T: &info_TCPListener},
		Ctor: _Wrapped_Ctor_TCPListener,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToTCPListener from _tests/big/src/net/tcpsock.go:225:6:
	info_PtrTo_TCPListener = GoTypeInfo{Name: "go.std.net/refToTCPListener",
		GoType: &GoType{T: &info_PtrTo_TCPListener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", _f_ptrTo_TCPListener_Accept, "Accept implements the Accept method in the Listener interface; it\nwaits for the next call and returns a generic Conn.\n", "1.0", NewVectorFrom()),
			"AcceptTCP": MakeGoReceiver("AcceptTCP", _f_ptrTo_TCPListener_AcceptTCP, "AcceptTCP accepts the next incoming call and returns the new\nconnection.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", _f_ptrTo_TCPListener_Addr, "Addr returns the listener's network address, a *TCPAddr.\nThe Addr returned is shared by all invocations of Addr, so\ndo not modify it.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", _f_ptrTo_TCPListener_Close, "Close stops listening on the TCP address.\nAlready Accepted connections are not closed.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfTCPListener from _tests/big/src/net/tcpsock.go:225:6:
	info_ArrayOf_TCPListener = GoTypeInfo{Name: "go.std.net/arrayOfTCPListener",
		GoType: &GoType{T: &info_ArrayOf_TCPListener},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
	info_UDPAddr = GoTypeInfo{Name: "go.std.net/UDPAddr",
		GoType: &GoType{T: &info_UDPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToUDPAddr from _tests/big/src/net/udpsock.go:25:6:
	info_PtrTo_UDPAddr = GoTypeInfo{Name: "go.std.net/refToUDPAddr",
		GoType: &GoType{T: &info_PtrTo_UDPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_ptrTo_UDPAddr_Network, "Network returns the address's network name, \"udp\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_UDPAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUDPAddr from _tests/big/src/net/udpsock.go:25:6:
	info_ArrayOf_UDPAddr = GoTypeInfo{Name: "go.std.net/arrayOfUDPAddr",
		GoType: &GoType{T: &info_ArrayOf_UDPAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
	info_UDPConn = GoTypeInfo{Name: "go.std.net/UDPConn",
		GoType: &GoType{T: &info_UDPConn},
		Ctor: _Wrapped_Ctor_UDPConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToUDPConn from _tests/big/src/net/udpsock.go:91:6:
	info_PtrTo_UDPConn = GoTypeInfo{Name: "go.std.net/refToUDPConn",
		GoType: &GoType{T: &info_PtrTo_UDPConn},
		Members: GoMembers{
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_ptrTo_UDPConn_ReadFrom, "ReadFrom implements the PacketConn ReadFrom method.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadFromUDP": MakeGoReceiver("ReadFromUDP", _f_ptrTo_UDPConn_ReadFromUDP, "ReadFromUDP acts like ReadFrom but returns a UDPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadMsgUDP": MakeGoReceiver("ReadMsgUDP", _f_ptrTo_UDPConn_ReadMsgUDP, "ReadMsgUDP reads a message from c, copying the payload into b and\nthe associated out-of-band data into oob. It returns the number of\nbytes copied into b, the number of bytes copied into oob, the flags\nthat were set on the message and the source address of the message.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"))),
			"WriteMsgUDP": MakeGoReceiver("WriteMsgUDP", _f_ptrTo_UDPConn_WriteMsgUDP, "WriteMsgUDP writes a message to addr via c if c isn't connected, or\nto c's remote address if c is connected (in which case addr must be\nnil). The payload is copied from b and the associated out-of-band\ndata is copied from oob. It returns the number of payload and\nout-of-band bytes written.\n\nThe packages golang.org/x/net/ipv4 and golang.org/x/net/ipv6 can be\nused to manipulate IP-level socket options in oob.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"), MakeSymbol("addr"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_ptrTo_UDPConn_WriteTo, "WriteTo implements the PacketConn WriteTo method.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
			"WriteToUDP": MakeGoReceiver("WriteToUDP", _f_ptrTo_UDPConn_WriteToUDP, "WriteToUDP acts like WriteTo but takes a UDPAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUDPConn from _tests/big/src/net/udpsock.go:91:6:
	info_ArrayOf_UDPConn = GoTypeInfo{Name: "go.std.net/arrayOfUDPConn",
		GoType: &GoType{T: &info_ArrayOf_UDPConn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
	info_UnixAddr = GoTypeInfo{Name: "go.std.net/UnixAddr",
		GoType: &GoType{T: &info_UnixAddr},
		Ctor: _Wrapped_Ctor_UnixAddr,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToUnixAddr from _tests/big/src/net/unixsock.go:19:6:
	info_PtrTo_UnixAddr = GoTypeInfo{Name: "go.std.net/refToUnixAddr",
		GoType: &GoType{T: &info_PtrTo_UnixAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", _f_ptrTo_UnixAddr_Network, "Network returns the address's network name, \"unix\", \"unixgram\" or\n\"unixpacket\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_UnixAddr_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUnixAddr from _tests/big/src/net/unixsock.go:19:6:
	info_ArrayOf_UnixAddr = GoTypeInfo{Name: "go.std.net/arrayOfUnixAddr",
		GoType: &GoType{T: &info_ArrayOf_UnixAddr},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
	info_UnixConn = GoTypeInfo{Name: "go.std.net/UnixConn",
		GoType: &GoType{T: &info_UnixConn},
		Ctor: _Wrapped_Ctor_UnixConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToUnixConn from _tests/big/src/net/unixsock.go:65:6:
	info_PtrTo_UnixConn = GoTypeInfo{Name: "go.std.net/refToUnixConn",
		GoType: &GoType{T: &info_PtrTo_UnixConn},
		Members: GoMembers{
			"CloseRead": MakeGoReceiver("CloseRead", _f_ptrTo_UnixConn_CloseRead, "CloseRead shuts down the reading side of the Unix domain connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"CloseWrite": MakeGoReceiver("CloseWrite", _f_ptrTo_UnixConn_CloseWrite, "CloseWrite shuts down the writing side of the Unix domain connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"ReadFrom": MakeGoReceiver("ReadFrom", _f_ptrTo_UnixConn_ReadFrom, "ReadFrom implements the PacketConn ReadFrom method.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadFromUnix": MakeGoReceiver("ReadFromUnix", _f_ptrTo_UnixConn_ReadFromUnix, "ReadFromUnix acts like ReadFrom but returns a UnixAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"))),
			"ReadMsgUnix": MakeGoReceiver("ReadMsgUnix", _f_ptrTo_UnixConn_ReadMsgUnix, "ReadMsgUnix reads a message from c, copying the payload into b and\nthe associated out-of-band data into oob. It returns the number of\nbytes copied into b, the number of bytes copied into oob, the flags\nthat were set on the message and the source address of the message.\n\nNote that if len(b) == 0 and len(oob) > 0, this function will still\nread (and discard) 1 byte from the connection.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"))),
			"WriteMsgUnix": MakeGoReceiver("WriteMsgUnix", _f_ptrTo_UnixConn_WriteMsgUnix, "WriteMsgUnix writes a message to addr via c, copying the payload\nfrom b and the associated out-of-band data from oob. It returns the\nnumber of payload and out-of-band bytes written.\n\nNote that if len(b) == 0 and len(oob) > 0, this function will still\nwrite 1 byte to the connection.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("oob"), MakeSymbol("addr"))),
			"WriteTo": MakeGoReceiver("WriteTo", _f_ptrTo_UnixConn_WriteTo, "WriteTo implements the PacketConn WriteTo method.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
			"WriteToUnix": MakeGoReceiver("WriteToUnix", _f_ptrTo_UnixConn_WriteToUnix, "WriteToUnix acts like WriteTo but takes a UnixAddr.\n", "1.0", NewVectorFrom(MakeSymbol("b"), MakeSymbol("addr"))),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUnixConn from _tests/big/src/net/unixsock.go:65:6:
	info_ArrayOf_UnixConn = GoTypeInfo{Name: "go.std.net/arrayOfUnixConn",
		GoType: &GoType{T: &info_ArrayOf_UnixConn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
	info_UnixListener = GoTypeInfo{Name: "go.std.net/UnixListener",
		GoType: &GoType{T: &info_UnixListener},
		Ctor: _Wrapped_Ctor_UnixListener,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/refToUnixListener from _tests/big/src/net/unixsock.go:217:6:
	info_PtrTo_UnixListener = GoTypeInfo{Name: "go.std.net/refToUnixListener",
		GoType: &GoType{T: &info_PtrTo_UnixListener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", _f_ptrTo_UnixListener_Accept, "Accept implements the Accept method in the Listener interface.\nReturned connections will be of type *UnixConn.\n", "1.0", NewVectorFrom()),
			"AcceptUnix": MakeGoReceiver("AcceptUnix", _f_ptrTo_UnixListener_AcceptUnix, "AcceptUnix accepts the next incoming call and returns the new\nconnection.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", _f_ptrTo_UnixListener_Addr, "Addr returns the listener's network address.\nThe Addr returned is shared by all invocations of Addr, so\ndo not modify it.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", _f_ptrTo_UnixListener_Close, "Close stops listening on the Unix address. Already accepted\nconnections are not closed.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUnixListener from _tests/big/src/net/unixsock.go:217:6:
	info_ArrayOf_UnixListener = GoTypeInfo{Name: "go.std.net/arrayOfUnixListener",
		GoType: &GoType{T: &info_ArrayOf_UnixListener},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
	info_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_UnknownNetworkError},
		Ctor: _Wrapped_Ctor_UnknownNetworkError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_unknownNetworkError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_unknownNetworkError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_unknownNetworkError_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net/refToUnknownNetworkError from _tests/big/src/net/net.go:539:6:
	info_PtrTo_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/refToUnknownNetworkError",
		GoType: &GoType{T: &info_PtrTo_UnknownNetworkError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net/arrayOfUnknownNetworkError from _tests/big/src/net/net.go:539:6:
	info_ArrayOf_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/arrayOfUnknownNetworkError",
		GoType: &GoType{T: &info_ArrayOf_UnknownNetworkError},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
	GoTypesVec[262] = &info_Addr

GO VECSET FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
	GoTypesVec[173] = &info_AddrError

GO VECSET FOR TYPE go.std.net/refToAddrError from _tests/big/src/net/net.go:520:6:
	GoTypesVec[0] = &info_PtrTo_AddrError

GO VECSET FOR TYPE go.std.net/arrayOfAddrError from _tests/big/src/net/net.go:520:6:
	GoTypesVec[90] = &info_ArrayOf_AddrError

GO VECSET FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
	GoTypesVec[174] = &info_Buffers

GO VECSET FOR TYPE go.std.net/refToBuffers from _tests/big/src/net/net.go:642:6:
	GoTypesVec[1] = &info_PtrTo_Buffers

GO VECSET FOR TYPE go.std.net/arrayOfBuffers from _tests/big/src/net/net.go:642:6:
	GoTypesVec[91] = &info_ArrayOf_Buffers

GO VECSET FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
	GoTypesVec[255] = &info_Conn

GO VECSET FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
	GoTypesVec[175] = &info_DNSConfigError

GO VECSET FOR TYPE go.std.net/refToDNSConfigError from _tests/big/src/net/net.go:553:6:
	GoTypesVec[2] = &info_PtrTo_DNSConfigError

GO VECSET FOR TYPE go.std.net/arrayOfDNSConfigError from _tests/big/src/net/net.go:553:6:
	GoTypesVec[92] = &info_ArrayOf_DNSConfigError

GO VECSET FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
	GoTypesVec[176] = &info_DNSError

GO VECSET FOR TYPE go.std.net/refToDNSError from _tests/big/src/net/net.go:567:6:
	GoTypesVec[3] = &info_PtrTo_DNSError

GO VECSET FOR TYPE go.std.net/arrayOfDNSError from _tests/big/src/net/net.go:567:6:
	GoTypesVec[93] = &info_ArrayOf_DNSError

GO VECSET FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
	GoTypesVec[177] = &info_Dialer

GO VECSET FOR TYPE go.std.net/refToDialer from _tests/big/src/net/dial.go:20:6:
	GoTypesVec[4] = &info_PtrTo_Dialer

GO VECSET FOR TYPE go.std.net/arrayOfDialer from _tests/big/src/net/dial.go:20:6:
	GoTypesVec[94] = &info_ArrayOf_Dialer

GO VECSET FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
	GoTypesVec[259] = &info_Error

GO VECSET FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
	GoTypesVec[178] = &info_Flags

GO VECSET FOR TYPE go.std.net/refToFlags from _tests/big/src/net/interface.go:38:6:
	GoTypesVec[5] = &info_PtrTo_Flags

GO VECSET FOR TYPE go.std.net/arrayOfFlags from _tests/big/src/net/interface.go:38:6:
	GoTypesVec[95] = &info_ArrayOf_Flags

GO VECSET FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
	GoTypesVec[179] = &info_HardwareAddr

GO VECSET FOR TYPE go.std.net/refToHardwareAddr from _tests/big/src/net/mac.go:10:6:
	GoTypesVec[6] = &info_PtrTo_HardwareAddr

GO VECSET FOR TYPE go.std.net/arrayOfHardwareAddr from _tests/big/src/net/mac.go:10:6:
	GoTypesVec[96] = &info_ArrayOf_HardwareAddr

GO VECSET FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
	GoTypesVec[180] = &info_IP

GO VECSET FOR TYPE go.std.net/refToIP from _tests/big/src/net/ip.go:32:6:
	GoTypesVec[7] = &info_PtrTo_IP

GO VECSET FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
	GoTypesVec[181] = &info_IPAddr

GO VECSET FOR TYPE go.std.net/refToIPAddr from _tests/big/src/net/iprawsock.go:31:6:
	GoTypesVec[8] = &info_PtrTo_IPAddr

GO VECSET FOR TYPE go.std.net/arrayOfIPAddr from _tests/big/src/net/iprawsock.go:31:6:
	GoTypesVec[98] = &info_ArrayOf_IPAddr

GO VECSET FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
	GoTypesVec[182] = &info_IPConn

GO VECSET FOR TYPE go.std.net/refToIPConn from _tests/big/src/net/iprawsock.go:99:6:
	GoTypesVec[9] = &info_PtrTo_IPConn

GO VECSET FOR TYPE go.std.net/arrayOfIPConn from _tests/big/src/net/iprawsock.go:99:6:
	GoTypesVec[99] = &info_ArrayOf_IPConn

GO VECSET FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
	GoTypesVec[183] = &info_IPMask

GO VECSET FOR TYPE go.std.net/refToIPMask from _tests/big/src/net/ip.go:35:6:
	GoTypesVec[10] = &info_PtrTo_IPMask

GO VECSET FOR TYPE go.std.net/arrayOfIPMask from _tests/big/src/net/ip.go:35:6:
	GoTypesVec[100] = &info_ArrayOf_IPMask

GO VECSET FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
	GoTypesVec[184] = &info_IPNet

GO VECSET FOR TYPE go.std.net/refToIPNet from _tests/big/src/net/ip.go:38:6:
	GoTypesVec[11] = &info_PtrTo_IPNet

GO VECSET FOR TYPE go.std.net/arrayOfIPNet from _tests/big/src/net/ip.go:38:6:
	GoTypesVec[101] = &info_ArrayOf_IPNet

GO VECSET FOR TYPE go.std.net/arrayOfIP from _tests/big/src/net/ip.go:32:6:
	GoTypesVec[97] = &info_ArrayOf_IP

GO VECSET FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
	GoTypesVec[185] = &info_Interface

GO VECSET FOR TYPE go.std.net/refToInterface from _tests/big/src/net/interface.go:30:6:
	GoTypesVec[12] = &info_PtrTo_Interface

GO VECSET FOR TYPE go.std.net/arrayOfInterface from _tests/big/src/net/interface.go:30:6:
	GoTypesVec[102] = &info_ArrayOf_Interface

GO VECSET FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
	GoTypesVec[186] = &info_InvalidAddrError

GO VECSET FOR TYPE go.std.net/refToInvalidAddrError from _tests/big/src/net/net.go:545:6:
	GoTypesVec[13] = &info_PtrTo_InvalidAddrError

GO VECSET FOR TYPE go.std.net/arrayOfInvalidAddrError from _tests/big/src/net/net.go:545:6:
	GoTypesVec[103] = &info_ArrayOf_InvalidAddrError

GO VECSET FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
	GoTypesVec[187] = &info_ListenConfig

GO VECSET FOR TYPE go.std.net/refToListenConfig from _tests/big/src/net/dial.go:576:6:
	GoTypesVec[14] = &info_PtrTo_ListenConfig

GO VECSET FOR TYPE go.std.net/arrayOfListenConfig from _tests/big/src/net/dial.go:576:6:
	GoTypesVec[104] = &info_ArrayOf_ListenConfig

GO VECSET FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
	GoTypesVec[260] = &info_Listener

GO VECSET FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
	GoTypesVec[188] = &info_MX

GO VECSET FOR TYPE go.std.net/refToMX from _tests/big/src/net/dnsclient.go:193:6:
	GoTypesVec[15] = &info_PtrTo_MX

GO VECSET FOR TYPE go.std.net/arrayOfMX from _tests/big/src/net/dnsclient.go:193:6:
	GoTypesVec[105] = &info_ArrayOf_MX

GO VECSET FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
	GoTypesVec[189] = &info_NS

GO VECSET FOR TYPE go.std.net/refToNS from _tests/big/src/net/dnsclient.go:215:6:
	GoTypesVec[16] = &info_PtrTo_NS

GO VECSET FOR TYPE go.std.net/arrayOfNS from _tests/big/src/net/dnsclient.go:215:6:
	GoTypesVec[106] = &info_ArrayOf_NS

GO VECSET FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
	GoTypesVec[190] = &info_OpError

GO VECSET FOR TYPE go.std.net/refToOpError from _tests/big/src/net/net.go:416:6:
	GoTypesVec[17] = &info_PtrTo_OpError

GO VECSET FOR TYPE go.std.net/arrayOfOpError from _tests/big/src/net/net.go:416:6:
	GoTypesVec[107] = &info_ArrayOf_OpError

GO VECSET FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
	GoTypesVec[256] = &info_PacketConn

GO VECSET FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
	GoTypesVec[191] = &info_ParseError

GO VECSET FOR TYPE go.std.net/refToParseError from _tests/big/src/net/net.go:509:6:
	GoTypesVec[18] = &info_PtrTo_ParseError

GO VECSET FOR TYPE go.std.net/arrayOfParseError from _tests/big/src/net/net.go:509:6:
	GoTypesVec[108] = &info_ArrayOf_ParseError

GO VECSET FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
	GoTypesVec[192] = &info_Resolver

GO VECSET FOR TYPE go.std.net/refToResolver from _tests/big/src/net/lookup.go:107:6:
	GoTypesVec[19] = &info_PtrTo_Resolver

GO VECSET FOR TYPE go.std.net/arrayOfResolver from _tests/big/src/net/lookup.go:107:6:
	GoTypesVec[109] = &info_ArrayOf_Resolver

GO VECSET FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
	GoTypesVec[193] = &info_SRV

GO VECSET FOR TYPE go.std.net/refToSRV from _tests/big/src/net/dnsclient.go:139:6:
	GoTypesVec[20] = &info_PtrTo_SRV

GO VECSET FOR TYPE go.std.net/arrayOfSRV from _tests/big/src/net/dnsclient.go:139:6:
	GoTypesVec[110] = &info_ArrayOf_SRV

GO VECSET FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	GoTypesVec[194] = &info_TCPAddr

GO VECSET FOR TYPE go.std.net/refToTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	GoTypesVec[21] = &info_PtrTo_TCPAddr

GO VECSET FOR TYPE go.std.net/arrayOfTCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	GoTypesVec[111] = &info_ArrayOf_TCPAddr

GO VECSET FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
	GoTypesVec[195] = &info_TCPConn

GO VECSET FOR TYPE go.std.net/refToTCPConn from _tests/big/src/net/tcpsock.go:85:6:
	GoTypesVec[22] = &info_PtrTo_TCPConn

GO VECSET FOR TYPE go.std.net/arrayOfTCPConn from _tests/big/src/net/tcpsock.go:85:6:
	GoTypesVec[112] = &info_ArrayOf_TCPConn

GO VECSET FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
	GoTypesVec[196] = &info_TCPListener

GO VECSET FOR TYPE go.std.net/refToTCPListener from _tests/big/src/net/tcpsock.go:225:6:
	GoTypesVec[23] = &info_PtrTo_TCPListener

GO VECSET FOR TYPE go.std.net/arrayOfTCPListener from _tests/big/src/net/tcpsock.go:225:6:
	GoTypesVec[113] = &info_ArrayOf_TCPListener

GO VECSET FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
	GoTypesVec[197] = &info_UDPAddr

GO VECSET FOR TYPE go.std.net/refToUDPAddr from _tests/big/src/net/udpsock.go:25:6:
	GoTypesVec[24] = &info_PtrTo_UDPAddr

GO VECSET FOR TYPE go.std.net/arrayOfUDPAddr from _tests/big/src/net/udpsock.go:25:6:
	GoTypesVec[114] = &info_ArrayOf_UDPAddr

GO VECSET FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
	GoTypesVec[198] = &info_UDPConn

GO VECSET FOR TYPE go.std.net/refToUDPConn from _tests/big/src/net/udpsock.go:91:6:
	GoTypesVec[25] = &info_PtrTo_UDPConn

GO VECSET FOR TYPE go.std.net/arrayOfUDPConn from _tests/big/src/net/udpsock.go:91:6:
	GoTypesVec[115] = &info_ArrayOf_UDPConn

GO VECSET FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
	GoTypesVec[199] = &info_UnixAddr

GO VECSET FOR TYPE go.std.net/refToUnixAddr from _tests/big/src/net/unixsock.go:19:6:
	GoTypesVec[26] = &info_PtrTo_UnixAddr

GO VECSET FOR TYPE go.std.net/arrayOfUnixAddr from _tests/big/src/net/unixsock.go:19:6:
	GoTypesVec[116] = &info_ArrayOf_UnixAddr

GO VECSET FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
	GoTypesVec[200] = &info_UnixConn

GO VECSET FOR TYPE go.std.net/refToUnixConn from _tests/big/src/net/unixsock.go:65:6:
	GoTypesVec[27] = &info_PtrTo_UnixConn

GO VECSET FOR TYPE go.std.net/arrayOfUnixConn from _tests/big/src/net/unixsock.go:65:6:
	GoTypesVec[117] = &info_ArrayOf_UnixConn

GO VECSET FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
	GoTypesVec[201] = &info_UnixListener

GO VECSET FOR TYPE go.std.net/refToUnixListener from _tests/big/src/net/unixsock.go:217:6:
	GoTypesVec[28] = &info_PtrTo_UnixListener

GO VECSET FOR TYPE go.std.net/arrayOfUnixListener from _tests/big/src/net/unixsock.go:217:6:
	GoTypesVec[118] = &info_ArrayOf_UnixListener

GO VECSET FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
	GoTypesVec[202] = &info_UnknownNetworkError

GO VECSET FOR TYPE go.std.net/refToUnknownNetworkError from _tests/big/src/net/net.go:539:6:
	GoTypesVec[29] = &info_PtrTo_UnknownNetworkError

GO VECSET FOR TYPE go.std.net/arrayOfUnknownNetworkError from _tests/big/src/net/net.go:539:6:
	GoTypesVec[119] = &info_ArrayOf_UnknownNetworkError

GO ENSURE-LOADED FOR net:
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/cgo_unix.go:21:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:20:2
	EnsureLoaded("go.std.golang_org.x.net.dns.dnsmessage")  // E.g. from: _tests/big/src/net/dnsclient.go:11:2
	EnsureLoaded("go.std.golang_org.x.net.route")  // E.g. from: _tests/big/src/net/interface_bsd.go:12:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:21:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/big/src/net/dnsclient.go:8:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/conf.go:10:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/conf.go:11:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/addrselect.go:11:8
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/conf.go:12:2
	EnsureLoaded("go.std.sync.atomic")  // E.g. from: _tests/big/src/net/dnsconfig_unix.go:13:2
	EnsureLoaded("go.std.syscall")  // E.g. from: _tests/big/src/net/cgo_sockold.go:19:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/dial.go:12:2
	EnsureLoaded("go.std.unsafe")  // E.g. from: _tests/big/src/net/cgo_resnew.go:18:8

GO TYPE []*net/http.Cookie from net/http/cookie.go:
func Extract_ns_arrayOfrefToCookie(args []Object, index int) []*http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*http.Cookie:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net/http.Cookie]"))
}

GO TYPE []net/http.Client from net/http/client.go:
func Extract_ns_arrayOfClient(args []Object, index int) []http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Client]"))
}

GO TYPE []net/http.ConnState from net/http/server.go:
func Extract_ns_arrayOfConnState(args []Object, index int) []http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.ConnState:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.ConnState]"))
}

GO TYPE []net/http.Cookie from net/http/cookie.go:
func Extract_ns_arrayOfCookie(args []Object, index int) []http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Cookie:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Cookie]"))
}

GO TYPE []net/http.Dir from net/http/fs.go:
func Extract_ns_arrayOfDir(args []Object, index int) []http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Dir:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Dir]"))
}

GO TYPE []net/http.HandlerFunc from net/http/server.go:
func Extract_ns_arrayOfHandlerFunc(args []Object, index int) []http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.HandlerFunc:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.HandlerFunc]"))
}

GO TYPE []net/http.Header from net/http/header.go:
func Extract_ns_arrayOfHeader(args []Object, index int) []http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Header:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Header]"))
}

GO TYPE []net/http.ProtocolError from net/http/request.go:
func Extract_ns_arrayOfProtocolError(args []Object, index int) []http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.ProtocolError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.ProtocolError]"))
}

GO TYPE []net/http.PushOptions from net/http/http.go:
func Extract_ns_arrayOfPushOptions(args []Object, index int) []http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.PushOptions:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.PushOptions]"))
}

GO TYPE []net/http.Request from net/http/request.go:
func Extract_ns_arrayOfRequest(args []Object, index int) []http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Request:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Request]"))
}

GO TYPE []net/http.Response from net/http/response.go:
func Extract_ns_arrayOfResponse(args []Object, index int) []http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Response:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Response]"))
}

GO TYPE []net/http.SameSite from net/http/cookie.go:
func Extract_ns_arrayOfSameSite(args []Object, index int) []http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.SameSite:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.SameSite]"))
}

GO TYPE []net/http.ServeMux from net/http/server.go:
func Extract_ns_arrayOfServeMux(args []Object, index int) []http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.ServeMux:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.ServeMux]"))
}

GO TYPE []net/http.Server from net/http/server.go:
func Extract_ns_arrayOfServer(args []Object, index int) []http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Server]"))
}

GO TYPE []net/http.Transport from net/http/transport.go:
func Extract_ns_arrayOfTransport(args []Object, index int) []http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []http.Transport:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http.Transport]"))
}

GO TYPE net/http.Client from net/http/client.go:
func Extract_ns_Client(args []Object, index int) *http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Client:
			return r
		case http.Client:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

// func _mapToClient(o Map) *http.Client {
// 	return &http.Client{
// 		Transport: ABEND048(codegen.go: no conversion from Clojure for net/http.RoundTripper (ABEND320(gtypes.go: interface{RoundTrip func(*Request)(*Response,error)} not supported))),
// 		CheckRedirect: ABEND727(gtypes.go: func(req *Request,via []*Request)error not supported),
// 		Jar: ABEND048(codegen.go: no conversion from Clojure for net/http.CookieJar (ABEND320(gtypes.go: interface{SetCookies func(u *url.URL,cookies []*Cookie),Cookies func(u *url.URL)[]*Cookie} not supported))),
// 		Timeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 	}
// }

// func _Ctor_Client(_v Object) *http.Client {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or: Map"))
// }

// func _Wrapped_Ctor_Client(_o Object) Object {
// 	return MakeGoObject(_Ctor_Client(_o))
// }

GO TYPE *net/http.Client from net/http/client.go:
func Extract_ns_refToClient(args []Object, index int) *http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Client]"))
}

GO TYPE net/http.CloseNotifier from net/http/server.go:
func Extract_ns_CloseNotifier(args []Object, index int) http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.CloseNotifier:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

GO TYPE net/http.ConnState from net/http/server.go:
func Extract_ns_ConnState(args []Object, index int) *http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ConnState:
			return r
		case http.ConnState:
			return &r  // refTo
		}
	case Number:
		v := http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _Ctor_ConnState(_v Object) http.ConnState {
	switch _o := _v.(type) {
	case Number:
		return http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or: Number"))
}

func _Wrapped_Ctor_ConnState(_o Object) Object {
	return MakeGoObject(_Ctor_ConnState(_o))
}

GO TYPE *net/http.ConnState from net/http/server.go:
func Extract_ns_refToConnState(args []Object, index int) *http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ConnState:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.ConnState]"))
}

GO TYPE net/http.Cookie from net/http/cookie.go:
func Extract_ns_Cookie(args []Object, index int) *http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Cookie:
			return r
		case http.Cookie:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

// func _mapToCookie(o Map) *http.Cookie {
// 	return &http.Cookie{
// 		Name: FieldAsString(o, "Name"),
// 		Value: FieldAsString(o, "Value"),
// 		Path: FieldAsString(o, "Path"),
// 		Domain: FieldAsString(o, "Domain"),
// 		Expires: time.ABEND002(reference to unavailable package `time' looking for type `Time'),
// 		RawExpires: FieldAsString(o, "RawExpires"),
// 		MaxAge: FieldAsInt(o, "MaxAge"),
// 		Secure: FieldAsBoolean(o, "Secure"),
// 		HttpOnly: FieldAsBoolean(o, "HttpOnly"),
// 		SameSite: ABEND048(codegen.go: no conversion from Clojure for net/http.SameSite (int)),
// 		Raw: FieldAsString(o, "Raw"),
// 		Unparsed: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 	}
// }

// func _Ctor_Cookie(_v Object) *http.Cookie {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToCookie(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or: Map"))
// }

// func _Wrapped_Ctor_Cookie(_o Object) Object {
// 	return MakeGoObject(_Ctor_Cookie(_o))
// }

GO TYPE *net/http.Cookie from net/http/cookie.go:
func Extract_ns_refToCookie(args []Object, index int) *http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Cookie:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Cookie]"))
}

GO TYPE net/http.CookieJar from net/http/jar.go:
func Extract_ns_CookieJar(args []Object, index int) http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.CookieJar:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

GO TYPE net/http.Dir from net/http/fs.go:
func Extract_ns_Dir(args []Object, index int) *http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Dir:
			return r
		case http.Dir:
			return &r  // refTo
		}
	case String:
		v := http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _Ctor_Dir(_v Object) http.Dir {
	switch _o := _v.(type) {
	case String:
		return http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or: String"))
}

func _Wrapped_Ctor_Dir(_o Object) Object {
	return MakeGoObject(_Ctor_Dir(_o))
}

GO TYPE *net/http.Dir from net/http/fs.go:
func Extract_ns_refToDir(args []Object, index int) *http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Dir:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Dir]"))
}

GO TYPE net/http.File from net/http/fs.go:
func Extract_ns_File(args []Object, index int) http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.File:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

GO TYPE net/http.FileSystem from net/http/fs.go:
func Extract_ns_FileSystem(args []Object, index int) http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.FileSystem:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

GO TYPE net/http.Flusher from net/http/server.go:
func Extract_ns_Flusher(args []Object, index int) http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.Flusher:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

GO TYPE net/http.Handler from net/http/server.go:
func Extract_ns_Handler(args []Object, index int) http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.Handler:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

GO TYPE net/http.HandlerFunc from net/http/server.go:
func Extract_ns_HandlerFunc(args []Object, index int) *http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.HandlerFunc:
			return r
		case http.HandlerFunc:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _Ctor_HandlerFunc(_v Object) http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or: whatever"))
// }

// func _Wrapped_Ctor_HandlerFunc(_o Object) Object {
// 	return MakeGoObject(_Ctor_HandlerFunc(_o))
// }

GO TYPE *net/http.HandlerFunc from net/http/server.go:
func Extract_ns_refToHandlerFunc(args []Object, index int) *http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.HandlerFunc:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.HandlerFunc]"))
}

GO TYPE net/http.Header from net/http/header.go:
func Extract_ns_Header(args []Object, index int) *http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Header:
			return r
		case http.Header:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _Ctor_Header(_v Object) http.Header {
// 	switch _o := _v.(type) {
// 	default:
// 		return _http.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or: whatever"))
// }

// func _Wrapped_Ctor_Header(_o Object) Object {
// 	return MakeGoObject(_Ctor_Header(_o))
// }

GO TYPE *net/http.Header from net/http/header.go:
func Extract_ns_refToHeader(args []Object, index int) *http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Header:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Header]"))
}

GO TYPE net/http.Hijacker from net/http/server.go:
func Extract_ns_Hijacker(args []Object, index int) http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.Hijacker:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

GO TYPE net/http.ProtocolError from net/http/request.go:
func Extract_ns_ProtocolError(args []Object, index int) *http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ProtocolError:
			return r
		case http.ProtocolError:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *http.ProtocolError {
	return &http.ProtocolError{
		ErrorString: FieldAsString(o, "ErrorString"),
	}
}

func _Ctor_ProtocolError(_v Object) *http.ProtocolError {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or: Map"))
}

func _Wrapped_Ctor_ProtocolError(_o Object) Object {
	return MakeGoObject(_Ctor_ProtocolError(_o))
}

GO TYPE *net/http.ProtocolError from net/http/request.go:
func Extract_ns_refToProtocolError(args []Object, index int) *http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ProtocolError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.ProtocolError]"))
}

GO TYPE net/http.PushOptions from net/http/http.go:
func Extract_ns_PushOptions(args []Object, index int) *http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.PushOptions:
			return r
		case http.PushOptions:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

// func _mapToPushOptions(o Map) *http.PushOptions {
// 	return &http.PushOptions{
// 		Method: FieldAsString(o, "Method"),
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 	}
// }

// func _Ctor_PushOptions(_v Object) *http.PushOptions {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToPushOptions(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or: Map"))
// }

// func _Wrapped_Ctor_PushOptions(_o Object) Object {
// 	return MakeGoObject(_Ctor_PushOptions(_o))
// }

GO TYPE *net/http.PushOptions from net/http/http.go:
func Extract_ns_refToPushOptions(args []Object, index int) *http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.PushOptions:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.PushOptions]"))
}

GO TYPE net/http.Pusher from net/http/http.go:
func Extract_ns_Pusher(args []Object, index int) http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.Pusher:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

GO TYPE net/http.Request from net/http/request.go:
func Extract_ns_Request(args []Object, index int) *http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Request:
			return r
		case http.Request:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

// func _mapToRequest(o Map) *http.Request {
// 	return &http.Request{
// 		Method: FieldAsString(o, "Method"),
// 		URL: ABEND048(codegen.go: no conversion from Clojure for *net/url.URL (net/url.URL)),
// 		Proto: FieldAsString(o, "Proto"),
// 		ProtoMajor: FieldAsInt(o, "ProtoMajor"),
// 		ProtoMinor: FieldAsInt(o, "ProtoMinor"),
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		Body: io.ABEND002(reference to unavailable package `io' looking for type `ReadCloser'),
// 		GetBody: ABEND727(gtypes.go: func()(io.ReadCloser,error) not supported),
// 		ContentLength: FieldAsInt64(o, "ContentLength"),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 		Close: FieldAsBoolean(o, "Close"),
// 		Host: FieldAsString(o, "Host"),
// 		Form: ABEND048(codegen.go: no conversion from Clojure for net/url.Values (map[string][]string)),
// 		PostForm: ABEND048(codegen.go: no conversion from Clojure for net/url.Values (map[string][]string)),
// 		MultipartForm: *ABEND002(reference to unavailable package `mime/multipart' looking for type `Form'),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		RemoteAddr: FieldAsString(o, "RemoteAddr"),
// 		RequestURI: FieldAsString(o, "RequestURI"),
// 		TLS: *ABEND002(reference to unavailable package `crypto/tls' looking for type `ConnectionState'),
// 		Cancel: ABEND737(gtypes.go: <-chan struct{} not supported),
// 		Response: ABEND048(codegen.go: no conversion from Clojure for *net/http.Response (net/http.Response)),
// 	}
// }

// func _Ctor_Request(_v Object) *http.Request {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToRequest(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or: Map"))
// }

// func _Wrapped_Ctor_Request(_o Object) Object {
// 	return MakeGoObject(_Ctor_Request(_o))
// }

GO TYPE *net/http.Request from net/http/request.go:
func Extract_ns_refToRequest(args []Object, index int) *http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Request:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Request]"))
}

GO TYPE net/http.Response from net/http/response.go:
func Extract_ns_Response(args []Object, index int) *http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Response:
			return r
		case http.Response:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

// func _mapToResponse(o Map) *http.Response {
// 	return &http.Response{
// 		Status: FieldAsString(o, "Status"),
// 		StatusCode: FieldAsInt(o, "StatusCode"),
// 		Proto: FieldAsString(o, "Proto"),
// 		ProtoMajor: FieldAsInt(o, "ProtoMajor"),
// 		ProtoMinor: FieldAsInt(o, "ProtoMinor"),
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		Body: io.ABEND002(reference to unavailable package `io' looking for type `ReadCloser'),
// 		ContentLength: FieldAsInt64(o, "ContentLength"),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 		Close: FieldAsBoolean(o, "Close"),
// 		Uncompressed: FieldAsBoolean(o, "Uncompressed"),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		Request: ABEND048(codegen.go: no conversion from Clojure for *net/http.Request (net/http.Request)),
// 		TLS: *ABEND002(reference to unavailable package `crypto/tls' looking for type `ConnectionState'),
// 	}
// }

// func _Ctor_Response(_v Object) *http.Response {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponse(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or: Map"))
// }

// func _Wrapped_Ctor_Response(_o Object) Object {
// 	return MakeGoObject(_Ctor_Response(_o))
// }

GO TYPE *net/http.Response from net/http/response.go:
func Extract_ns_refToResponse(args []Object, index int) *http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Response:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Response]"))
}

GO TYPE net/http.ResponseWriter from net/http/server.go:
func Extract_ns_ResponseWriter(args []Object, index int) http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.ResponseWriter:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

GO TYPE net/http.RoundTripper from net/http/client.go:
func Extract_ns_RoundTripper(args []Object, index int) http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case http.RoundTripper:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

GO TYPE net/http.SameSite from net/http/cookie.go:
func Extract_ns_SameSite(args []Object, index int) *http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.SameSite:
			return r
		case http.SameSite:
			return &r  // refTo
		}
	case Number:
		v := http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _Ctor_SameSite(_v Object) http.SameSite {
	switch _o := _v.(type) {
	case Number:
		return http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or: Number"))
}

func _Wrapped_Ctor_SameSite(_o Object) Object {
	return MakeGoObject(_Ctor_SameSite(_o))
}

GO TYPE *net/http.SameSite from net/http/cookie.go:
func Extract_ns_refToSameSite(args []Object, index int) *http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.SameSite:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.SameSite]"))
}

GO TYPE net/http.ServeMux from net/http/server.go:
func Extract_ns_ServeMux(args []Object, index int) *http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ServeMux:
			return r
		case http.ServeMux:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *http.ServeMux {
	return &http.ServeMux{}
}

func _Ctor_ServeMux(_v Object) *http.ServeMux {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or: Map"))
}

func _Wrapped_Ctor_ServeMux(_o Object) Object {
	return MakeGoObject(_Ctor_ServeMux(_o))
}

GO TYPE *net/http.ServeMux from net/http/server.go:
func Extract_ns_refToServeMux(args []Object, index int) *http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.ServeMux:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.ServeMux]"))
}

GO TYPE net/http.Server from net/http/server.go:
func Extract_ns_Server(args []Object, index int) *http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Server:
			return r
		case http.Server:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

// func _mapToServer(o Map) *http.Server {
// 	return &http.Server{
// 		Addr: FieldAsString(o, "Addr"),
// 		Handler: ABEND048(codegen.go: no conversion from Clojure for net/http.Handler (ABEND320(gtypes.go: interface{ServeHTTP func(ResponseWriter,*Request)} not supported))),
// 		TLSConfig: *ABEND002(reference to unavailable package `crypto/tls' looking for type `Config'),
// 		ReadTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		ReadHeaderTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		WriteTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		IdleTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		MaxHeaderBytes: FieldAsInt(o, "MaxHeaderBytes"),
// 		TLSNextProto: map[string]ABEND727(gtypes.go: func(*Server,*tls.Conn,Handler) not supported),
// 		ConnState: ABEND727(gtypes.go: func(net.Conn,ConnState) not supported),
// 		ErrorLog: *ABEND002(reference to unavailable package `log' looking for type `Logger'),
// 	}
// }

// func _Ctor_Server(_v Object) *http.Server {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or: Map"))
// }

// func _Wrapped_Ctor_Server(_o Object) Object {
// 	return MakeGoObject(_Ctor_Server(_o))
// }

GO TYPE *net/http.Server from net/http/server.go:
func Extract_ns_refToServer(args []Object, index int) *http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Server]"))
}

GO TYPE net/http.Transport from net/http/transport.go:
func Extract_ns_Transport(args []Object, index int) *http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Transport:
			return r
		case http.Transport:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

// func _mapToTransport(o Map) *http.Transport {
// 	return &http.Transport{
// 		Proxy: ABEND727(gtypes.go: func(*Request)(*url.URL,error) not supported),
// 		DialContext: ABEND727(gtypes.go: func(ctx context.Context,network string,addr string)(net.Conn,error) not supported),
// 		Dial: ABEND727(gtypes.go: func(network string,addr string)(net.Conn,error) not supported),
// 		DialTLS: ABEND727(gtypes.go: func(network string,addr string)(net.Conn,error) not supported),
// 		TLSClientConfig: *ABEND002(reference to unavailable package `crypto/tls' looking for type `Config'),
// 		TLSHandshakeTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		DisableKeepAlives: FieldAsBoolean(o, "DisableKeepAlives"),
// 		DisableCompression: FieldAsBoolean(o, "DisableCompression"),
// 		MaxIdleConns: FieldAsInt(o, "MaxIdleConns"),
// 		MaxIdleConnsPerHost: FieldAsInt(o, "MaxIdleConnsPerHost"),
// 		MaxConnsPerHost: FieldAsInt(o, "MaxConnsPerHost"),
// 		IdleConnTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		ResponseHeaderTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		ExpectContinueTimeout: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		TLSNextProto: map[string]ABEND727(gtypes.go: func(authority string,c *tls.Conn)RoundTripper not supported),
// 		ProxyConnectHeader: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		MaxResponseHeaderBytes: FieldAsInt64(o, "MaxResponseHeaderBytes"),
// 	}
// }

// func _Ctor_Transport(_v Object) *http.Transport {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToTransport(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or: Map"))
// }

// func _Wrapped_Ctor_Transport(_o Object) Object {
// 	return MakeGoObject(_Ctor_Transport(_o))
// }

GO TYPE *net/http.Transport from net/http/transport.go:
func Extract_ns_refToTransport(args []Object, index int) *http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *http.Transport:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http.Transport]"))
}

GO FUNC net/http.Error from net/http/server.go:
func _f_error(_v_w http.ResponseWriter, _v_error string, _v_code int) Object {
	http.Error(_v_w, _v_error, _v_code)
	return NIL
}

GO FUNC net/http.FileServer from net/http/fs.go:
func _f_fileServer(_v_root http.FileSystem) Object {
	_res := http.FileServer(_v_root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func _f_get(_v_url string) Object {
	resp, err := http.Get(_v_url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
func _f_handle(_v_pattern string, _v_handler http.Handler) Object {
	http.Handle(_v_pattern, _v_handler)
	return NIL
}

GO FUNC net/http.HandleFunc from net/http/server.go:
// func _f_handleFunc(_v_pattern string, _v_handler ABEND727(gtypes.go: func(ResponseWriter,*Request) not supported)) Object {
// 	http.HandleFunc(_v_pattern, _v_handler)
// 	return NIL
// }

GO FUNC net/http.Head from net/http/client.go:
func _f_head(_v_url string) Object {
	resp, err := http.Head(_v_url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func _f_maxBytesReader(_v_w http.ResponseWriter, _v_r ABEND002(reference to unavailable package `io' looking for type `ReadCloser'), _v_n int64) Object {
// 	_res := http.MaxBytesReader(_v_w, _v_r, _v_n)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func _f_newFileTransport(_v_fs http.FileSystem) Object {
	_res := http.NewFileTransport(_v_fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func _f_newRequest(_v_method string, _v_url string, _v_body ABEND002(reference to unavailable package `io' looking for type `Reader')) Object {
// 	_res1, _res2 := http.NewRequest(_v_method, _v_url, _v_body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func _f_newServeMux() Object {
	_res := http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
func _f_notFound(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	http.NotFound(_v_w, _v_r)
	return NIL
}

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func _f_notFoundHandler() Object {
	_res := http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func _f_parseHTTPVersion(_v_vers string) Object {
	major, minor, ok := http.ParseHTTPVersion(_v_vers)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
// func _f_parseTime(_v_text string) Object {
// 	t, err := http.ParseTime(_v_text)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(t))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Post from net/http/client.go:
// func _f_post(_v_url string, _v_contentType string, _v_body ABEND002(reference to unavailable package `io' looking for type `Reader')) Object {
// 	resp, err := http.Post(_v_url, _v_contentType, _v_body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
func _f_postForm(_v_url string, _v_data url.Values) Object {
	resp, err := http.PostForm(_v_url, _v_data)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
func _f_proxyFromEnvironment(_v_req *http.Request) Object {
	_res1, _res2 := http.ProxyFromEnvironment(_v_req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func _f_proxyURL(_v_fixedURL *url.URL) Object {
// 	_res := http.ProxyURL(_v_fixedURL)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func _f_readRequest(_v_b *ABEND002(reference to unavailable package `bufio' looking for type `Reader')) Object {
// 	_res1, _res2 := http.ReadRequest(_v_b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func _f_readResponse(_v_r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'), _v_req *http.Request) Object {
// 	_res1, _res2 := http.ReadResponse(_v_r, _v_req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
func _f_redirect(_v_w http.ResponseWriter, _v_r *http.Request, _v_url string, _v_code int) Object {
	http.Redirect(_v_w, _v_r, _v_url, _v_code)
	return NIL
}

GO FUNC net/http.RedirectHandler from net/http/server.go:
func _f_redirectHandler(_v_url string, _v_code int) Object {
	_res := http.RedirectHandler(_v_url, _v_code)
	return MakeGoObject(_res)
}

GO FUNC net/http.ServeContent from net/http/fs.go:
// func _f_serveContent(_v_w http.ResponseWriter, _v_req *http.Request, _v_name string, _v_modtime ABEND002(reference to unavailable package `time' looking for type `Time'), _v_content ABEND002(reference to unavailable package `io' looking for type `ReadSeeker')) Object {
// 	http.ServeContent(_v_w, _v_req, _v_name, _v_modtime, _v_content)
// 	return NIL
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
func _f_serveFile(_v_w http.ResponseWriter, _v_r *http.Request, _v_name string) Object {
	http.ServeFile(_v_w, _v_r, _v_name)
	return NIL
}

GO FUNC net/http.SetCookie from net/http/cookie.go:
func _f_setCookie(_v_w http.ResponseWriter, _v_cookie *http.Cookie) Object {
	http.SetCookie(_v_w, _v_cookie)
	return NIL
}

GO FUNC net/http.StripPrefix from net/http/server.go:
func _f_stripPrefix(_v_prefix string, _v_h http.Handler) Object {
	_res := http.StripPrefix(_v_prefix, _v_h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func _f_timeoutHandler(_v_h http.Handler, _v_dt ABEND002(reference to unavailable package `time' looking for type `Duration'), _v_msg string) Object {
// 	_res := http.TimeoutHandler(_v_h, _v_dt, _v_msg)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http._f_closeNotifier_CloseNotify from net/http/server.go:
// func _f_closeNotifier_CloseNotify(o GoObject, args Object) Object {  // Method
// ABEND737(gtypes.go: <-chan bool not supported)}

GO FUNC net/http._f_connState_String from net/http/server.go:
func _f_connState_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(http.ConnState)String()", args, 0, 0)
	_res := o.O.(http.ConnState).String()
	return MakeString(_res)
}

GO FUNC net/http._f_cookieJar_Cookies from net/http/jar.go:
func _f_cookieJar_Cookies(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http.CookieJar)Cookies()", args, 1, 1)
	_v_u := SeqNth(_argList, 0).(GoObject).O.(*url.URL)
	_res := o.O.(http.CookieJar).Cookies(_v_u)
	return MakeGoObject(_res)
}

GO FUNC net/http._f_cookieJar_SetCookies from net/http/jar.go:
// func _f_cookieJar_SetCookies(o GoObject, args Object) Object {  // Method
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_dir_Open from net/http/fs.go:
func _f_dir_Open(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(http.Dir)Open()", args, 1, 1)
	_v_name := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_name): %s")
	_res1, _res2 := o.O.(http.Dir).Open(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_fileSystem_Open from net/http/fs.go:
func _f_fileSystem_Open(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http.FileSystem)Open()", args, 1, 1)
	_v_name := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_name): %s")
	_res1, _res2 := o.O.(http.FileSystem).Open(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_flusher_Flush from net/http/server.go:
// func _f_flusher_Flush(o GoObject, args Object) Object {  // Method
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_handlerFunc_ServeHTTP from net/http/server.go:
// func _f_handlerFunc_ServeHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_handler_ServeHTTP from net/http/server.go:
// func _f_handler_ServeHTTP(o GoObject, args Object) Object {  // Method
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_header_Add from net/http/header.go:
// func _f_header_Add(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_header_Del from net/http/header.go:
// func _f_header_Del(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_header_Get from net/http/header.go:
func _f_header_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(http.Header)Get()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(http.Header).Get(_v_key)
	return MakeString(_res)
}

GO FUNC net/http._f_header_Set from net/http/header.go:
// func _f_header_Set(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_header_Write from net/http/header.go:
// func _f_header_Write(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

GO FUNC net/http._f_header_WriteSubset from net/http/header.go:
// func _f_header_WriteSubset(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'), exclude map[string]bool)}

GO FUNC net/http._f_hijacker_Hijack from net/http/server.go:
// func _f_hijacker_Hijack(o GoObject, args Object) Object {  // Method
// (net.Conn, *ABEND002(reference to unavailable package `bufio' looking for type `ReadWriter'), error)}

GO FUNC net/http._f_ptrTo_Client_Do from net/http/client.go:
func _f_ptrTo_Client_Do(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Client)Do()", args, 1, 1)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_res1, _res2 := o.O.(*http.Client).Do(_v_req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Client_Get from net/http/client.go:
func _f_ptrTo_Client_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Client)Get()", args, 1, 1)
	_v_url := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_url): %s")
	resp, err := o.O.(*http.Client).Get(_v_url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Client_Head from net/http/client.go:
func _f_ptrTo_Client_Head(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Client)Head()", args, 1, 1)
	_v_url := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_url): %s")
	resp, err := o.O.(*http.Client).Head(_v_url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Client_Post from net/http/client.go:
// func _f_ptrTo_Client_Post(o GoObject, args Object) Object {  // Receiver
// (url string, contentType string, body ABEND002(reference to unavailable package `io' looking for type `Reader'))}

GO FUNC net/http._f_ptrTo_Client_PostForm from net/http/client.go:
func _f_ptrTo_Client_PostForm(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Client)PostForm()", args, 2, 2)
	_v_url := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_url): %s")
	_v_data := SeqNth(_argList, 1).(GoObject).O.(url.Values)
	resp, err := o.O.(*http.Client).PostForm(_v_url, _v_data)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Cookie_String from net/http/cookie.go:
func _f_ptrTo_Cookie_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Cookie)String()", args, 0, 0)
	_res := o.O.(*http.Cookie).String()
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_ProtocolError_Error from net/http/request.go:
func _f_ptrTo_ProtocolError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(*http.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_Request_AddCookie from net/http/request.go:
// func _f_ptrTo_Request_AddCookie(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Request_BasicAuth from net/http/request.go:
func _f_ptrTo_Request_BasicAuth(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Request)BasicAuth()", args, 0, 0)
	username, password, ok := o.O.(*http.Request).BasicAuth()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(username))
	_res = _res.Conjoin(MakeString(password))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http._f_ptrTo_Request_Context from net/http/request.go:
// func _f_ptrTo_Request_Context(o GoObject, args Object) Object {  // Receiver
// ABEND002(reference to unavailable package `context' looking for type `Context')}

GO FUNC net/http._f_ptrTo_Request_Cookie from net/http/request.go:
func _f_ptrTo_Request_Cookie(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Request)Cookie()", args, 1, 1)
	_v_name := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_name): %s")
	_res1, _res2 := o.O.(*http.Request).Cookie(_v_name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Request_Cookies from net/http/request.go:
func _f_ptrTo_Request_Cookies(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Request)Cookies()", args, 0, 0)
	_res := o.O.(*http.Request).Cookies()
	return MakeGoObject(_res)
}

GO FUNC net/http._f_ptrTo_Request_FormFile from net/http/request.go:
// func _f_ptrTo_Request_FormFile(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `mime/multipart' looking for type `File'), *ABEND002(reference to unavailable package `mime/multipart' looking for type `FileHeader'), error)}

GO FUNC net/http._f_ptrTo_Request_FormValue from net/http/request.go:
func _f_ptrTo_Request_FormValue(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Request)FormValue()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(*http.Request).FormValue(_v_key)
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_Request_MultipartReader from net/http/request.go:
// func _f_ptrTo_Request_MultipartReader(o GoObject, args Object) Object {  // Receiver
// (*ABEND002(reference to unavailable package `mime/multipart' looking for type `Reader'), error)}

GO FUNC net/http._f_ptrTo_Request_ParseForm from net/http/request.go:
func _f_ptrTo_Request_ParseForm(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Request)ParseForm()", args, 0, 0)
	_res := o.O.(*http.Request).ParseForm()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Request_ParseMultipartForm from net/http/request.go:
func _f_ptrTo_Request_ParseMultipartForm(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Request)ParseMultipartForm()", args, 1, 1)
	_v_maxMemory := ObjectAsInt64(SeqNth(_argList, 0), "Arg[0] (_v_maxMemory): %s")
	_res := o.O.(*http.Request).ParseMultipartForm(_v_maxMemory)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Request_PostFormValue from net/http/request.go:
func _f_ptrTo_Request_PostFormValue(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Request)PostFormValue()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(*http.Request).PostFormValue(_v_key)
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_Request_ProtoAtLeast from net/http/request.go:
func _f_ptrTo_Request_ProtoAtLeast(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Request)ProtoAtLeast()", args, 2, 2)
	_v_major := ObjectAsInt(SeqNth(_argList, 0), "Arg[0] (_v_major): %s")
	_v_minor := ObjectAsInt(SeqNth(_argList, 1), "Arg[1] (_v_minor): %s")
	_res := o.O.(*http.Request).ProtoAtLeast(_v_major, _v_minor)
	return MakeBoolean(_res)
}

GO FUNC net/http._f_ptrTo_Request_Referer from net/http/request.go:
func _f_ptrTo_Request_Referer(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Request)Referer()", args, 0, 0)
	_res := o.O.(*http.Request).Referer()
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_Request_SetBasicAuth from net/http/request.go:
// func _f_ptrTo_Request_SetBasicAuth(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Request_UserAgent from net/http/request.go:
func _f_ptrTo_Request_UserAgent(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Request)UserAgent()", args, 0, 0)
	_res := o.O.(*http.Request).UserAgent()
	return MakeString(_res)
}

GO FUNC net/http._f_ptrTo_Request_WithContext from net/http/request.go:
// func _f_ptrTo_Request_WithContext(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'))}

GO FUNC net/http._f_ptrTo_Request_Write from net/http/request.go:
// func _f_ptrTo_Request_Write(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

GO FUNC net/http._f_ptrTo_Request_WriteProxy from net/http/request.go:
// func _f_ptrTo_Request_WriteProxy(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

GO FUNC net/http._f_ptrTo_Response_Cookies from net/http/response.go:
func _f_ptrTo_Response_Cookies(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Response)Cookies()", args, 0, 0)
	_res := o.O.(*http.Response).Cookies()
	return MakeGoObject(_res)
}

GO FUNC net/http._f_ptrTo_Response_Location from net/http/response.go:
func _f_ptrTo_Response_Location(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Response)Location()", args, 0, 0)
	_res1, _res2 := o.O.(*http.Response).Location()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_ptrTo_Response_ProtoAtLeast from net/http/response.go:
func _f_ptrTo_Response_ProtoAtLeast(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Response)ProtoAtLeast()", args, 2, 2)
	_v_major := ObjectAsInt(SeqNth(_argList, 0), "Arg[0] (_v_major): %s")
	_v_minor := ObjectAsInt(SeqNth(_argList, 1), "Arg[1] (_v_minor): %s")
	_res := o.O.(*http.Response).ProtoAtLeast(_v_major, _v_minor)
	return MakeBoolean(_res)
}

GO FUNC net/http._f_ptrTo_Response_Write from net/http/response.go:
// func _f_ptrTo_Response_Write(o GoObject, args Object) Object {  // Receiver
// (w ABEND002(reference to unavailable package `io' looking for type `Writer'))}

GO FUNC net/http._f_ptrTo_ServeMux_Handle from net/http/server.go:
// func _f_ptrTo_ServeMux_Handle(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_ServeMux_HandleFunc from net/http/server.go:
// func _f_ptrTo_ServeMux_HandleFunc(o GoObject, args Object) Object {  // Receiver
// (pattern string, handler ABEND727(gtypes.go: func(ResponseWriter,*Request) not supported))}

GO FUNC net/http._f_ptrTo_ServeMux_Handler from net/http/server.go:
func _f_ptrTo_ServeMux_Handler(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.ServeMux)Handler()", args, 1, 1)
	_v_r := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	h, pattern := o.O.(*http.ServeMux).Handler(_v_r)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(h))
	_res = _res.Conjoin(MakeString(pattern))
	return _res
}

GO FUNC net/http._f_ptrTo_ServeMux_ServeHTTP from net/http/server.go:
// func _f_ptrTo_ServeMux_ServeHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Server_Close from net/http/server.go:
func _f_ptrTo_Server_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Server)Close()", args, 0, 0)
	_res := o.O.(*http.Server).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Server_ListenAndServe from net/http/server.go:
func _f_ptrTo_Server_ListenAndServe(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*http.Server)ListenAndServe()", args, 0, 0)
	_res := o.O.(*http.Server).ListenAndServe()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Server_ListenAndServeTLS from net/http/server.go:
func _f_ptrTo_Server_ListenAndServeTLS(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Server)ListenAndServeTLS()", args, 2, 2)
	_v_certFile := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_certFile): %s")
	_v_keyFile := ObjectAsString(SeqNth(_argList, 1), "Arg[1] (_v_keyFile): %s")
	_res := o.O.(*http.Server).ListenAndServeTLS(_v_certFile, _v_keyFile)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Server_RegisterOnShutdown from net/http/server.go:
// func _f_ptrTo_Server_RegisterOnShutdown(o GoObject, args Object) Object {  // Receiver
// (f ABEND727(gtypes.go: func() not supported))}

GO FUNC net/http._f_ptrTo_Server_Serve from net/http/server.go:
func _f_ptrTo_Server_Serve(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Server)Serve()", args, 1, 1)
	_v_l := SeqNth(_argList, 0).(GoObject).O.(net.Listener)
	_res := o.O.(*http.Server).Serve(_v_l)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Server_ServeTLS from net/http/server.go:
func _f_ptrTo_Server_ServeTLS(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Server)ServeTLS()", args, 3, 3)
	_v_l := SeqNth(_argList, 0).(GoObject).O.(net.Listener)
	_v_certFile := ObjectAsString(SeqNth(_argList, 1), "Arg[1] (_v_certFile): %s")
	_v_keyFile := ObjectAsString(SeqNth(_argList, 2), "Arg[2] (_v_keyFile): %s")
	_res := o.O.(*http.Server).ServeTLS(_v_l, _v_certFile, _v_keyFile)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_ptrTo_Server_SetKeepAlivesEnabled from net/http/server.go:
// func _f_ptrTo_Server_SetKeepAlivesEnabled(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Server_Shutdown from net/http/server.go:
// func _f_ptrTo_Server_Shutdown(o GoObject, args Object) Object {  // Receiver
// (ctx ABEND002(reference to unavailable package `context' looking for type `Context'))}

GO FUNC net/http._f_ptrTo_Transport_CancelRequest from net/http/transport.go:
// func _f_ptrTo_Transport_CancelRequest(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Transport_CloseIdleConnections from net/http/transport.go:
// func _f_ptrTo_Transport_CloseIdleConnections(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Transport_RegisterProtocol from net/http/transport.go:
// func _f_ptrTo_Transport_RegisterProtocol(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_ptrTo_Transport_RoundTrip from net/http/roundtrip.go:
func _f_ptrTo_Transport_RoundTrip(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*http.Transport)RoundTrip()", args, 1, 1)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_res1, _res2 := o.O.(*http.Transport).RoundTrip(_v_req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_pusher_Push from net/http/http.go:
func _f_pusher_Push(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http.Pusher)Push()", args, 2, 2)
	_v_target := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_target): %s")
	_v_opts := SeqNth(_argList, 1).(GoObject).O.(*http.PushOptions)
	_res := o.O.(http.Pusher).Push(_v_target, _v_opts)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http._f_responseWriter_Header from net/http/server.go:
func _f_responseWriter_Header(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net/http.ResponseWriter)Header()", args, 0, 0)
	_res := o.O.(http.ResponseWriter).Header()
	return MakeGoObject(_res)
}

GO FUNC net/http._f_responseWriter_Write from net/http/server.go:
func _f_responseWriter_Write(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http.ResponseWriter)Write()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2 := o.O.(http.ResponseWriter).Write(__arg1)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http._f_responseWriter_WriteHeader from net/http/server.go:
// func _f_responseWriter_WriteHeader(o GoObject, args Object) Object {  // Method
// 	...ABEND275: TODO...
// }

GO FUNC net/http._f_roundTripper_RoundTrip from net/http/client.go:
func _f_roundTripper_RoundTrip(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http.RoundTripper)RoundTrip()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_res1, _res2 := o.O.(http.RoundTripper).RoundTrip(__arg1)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO VARDEF FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToClient from _tests/big/src/net/http/client.go:56:6:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfClient from _tests/big/src/net/http/client.go:56:6:
var info_ArrayOf_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
var info_CloseNotifier GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
var info_ConnState GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToConnState from _tests/big/src/net/http/server.go:2677:6:
var info_PtrTo_ConnState GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfConnState from _tests/big/src/net/http/server.go:2677:6:
var info_ArrayOf_ConnState GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
var info_Cookie GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToCookie from _tests/big/src/net/http/cookie.go:19:6:
var info_PtrTo_Cookie GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
var info_CookieJar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfCookie from _tests/big/src/net/http/cookie.go:19:6:
var info_ArrayOf_Cookie GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
var info_Dir GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToDir from _tests/big/src/net/http/fs.go:40:6:
var info_PtrTo_Dir GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfDir from _tests/big/src/net/http/fs.go:40:6:
var info_ArrayOf_Dir GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
var info_File GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
var info_FileSystem GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
var info_Flusher GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
var info_Handler GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
var info_HandlerFunc GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
var info_PtrTo_HandlerFunc GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
var info_ArrayOf_HandlerFunc GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
var info_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToHeader from _tests/big/src/net/http/header.go:20:6:
var info_PtrTo_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfHeader from _tests/big/src/net/http/header.go:20:6:
var info_ArrayOf_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
var info_Hijacker GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
var info_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToProtocolError from _tests/big/src/net/http/request.go:44:6:
var info_PtrTo_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfProtocolError from _tests/big/src/net/http/request.go:44:6:
var info_ArrayOf_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
var info_PushOptions GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToPushOptions from _tests/big/src/net/http/http.go:105:6:
var info_PtrTo_PushOptions GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfPushOptions from _tests/big/src/net/http/http.go:105:6:
var info_ArrayOf_PushOptions GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
var info_Pusher GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
var info_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToRequest from _tests/big/src/net/http/request.go:106:6:
var info_PtrTo_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfRequest from _tests/big/src/net/http/request.go:106:6:
var info_ArrayOf_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
var info_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToResponse from _tests/big/src/net/http/response.go:33:6:
var info_PtrTo_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
var info_ResponseWriter GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfResponse from _tests/big/src/net/http/response.go:33:6:
var info_ArrayOf_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
var info_RoundTripper GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
var info_SameSite GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToSameSite from _tests/big/src/net/http/cookie.go:45:6:
var info_PtrTo_SameSite GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfSameSite from _tests/big/src/net/http/cookie.go:45:6:
var info_ArrayOf_SameSite GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
var info_ServeMux GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToServeMux from _tests/big/src/net/http/server.go:2149:6:
var info_PtrTo_ServeMux GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfServeMux from _tests/big/src/net/http/server.go:2149:6:
var info_ArrayOf_ServeMux GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToServer from _tests/big/src/net/http/server.go:2445:6:
var info_PtrTo_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfServer from _tests/big/src/net/http/server.go:2445:6:
var info_ArrayOf_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
var info_Transport GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/refToTransport from _tests/big/src/net/http/transport.go:103:6:
var info_PtrTo_Transport GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/arrayOfTransport from _tests/big/src/net/http/transport.go:103:6:
var info_ArrayOf_Transport GoTypeInfo

GO INFO FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
	info_Client = GoTypeInfo{Name: "go.std.net.http/Client",
		GoType: &GoType{T: &info_Client},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToClient from _tests/big/src/net/http/client.go:56:6:
	info_PtrTo_Client = GoTypeInfo{Name: "go.std.net.http/refToClient",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Do": MakeGoReceiver("Do", _f_ptrTo_Client_Do, "Do sends an HTTP request and returns an HTTP response, following\npolicy (such as redirects, cookies, auth) as configured on the\nclient.\n\nAn error is returned if caused by client policy (such as\nCheckRedirect), or failure to speak HTTP (such as a network\nconnectivity problem). A non-2xx status code doesn't cause an\nerror.\n\nIf the returned error is nil, the Response will contain a non-nil\nBody which the user is expected to close. If the Body is not\nclosed, the Client's underlying RoundTripper (typically Transport)\nmay not be able to re-use a persistent TCP connection to the server\nfor a subsequent \"keep-alive\" request.\n\nThe request Body, if non-nil, will be closed by the underlying\nTransport, even on errors.\n\nOn error, any Response can be ignored. A non-nil Response with a\nnon-nil error only occurs when CheckRedirect fails, and even then\nthe returned Response.Body is already closed.\n\nGenerally Get, Post, or PostForm will be used instead of Do.\n\nIf the server replies with a redirect, the Client first uses the\nCheckRedirect function to determine whether the redirect should be\nfollowed. If permitted, a 301, 302, or 303 redirect causes\nsubsequent requests to use HTTP method GET\n(or HEAD if the original request was HEAD), with no body.\nA 307 or 308 redirect preserves the original HTTP method and body,\nprovided that the Request.GetBody function is defined.\nThe NewRequest function automatically sets GetBody for common\nstandard library body types.\n\nAny returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n", "1.0", NewVectorFrom(MakeSymbol("req"))),
			"Get": MakeGoReceiver("Get", _f_ptrTo_Client_Get, "Get issues a GET to the specified URL. If the response is one of the\nfollowing redirect codes, Get follows the redirect after calling the\nClient's CheckRedirect function:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if the Client's CheckRedirect function fails\nor if there was an HTTP protocol error. A non-2xx response doesn't\ncause an error. Any returned error will be of type *url.Error. The\nurl.Error value's Timeout method will report true if request timed\nout or was canceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nTo make a request with custom headers, use NewRequest and Client.Do.\n", "1.0", NewVectorFrom(MakeSymbol("url"))),
			"Head": MakeGoReceiver("Head", _f_ptrTo_Client_Head, "Head issues a HEAD to the specified URL. If the response is one of the\nfollowing redirect codes, Head follows the redirect after calling the\nClient's CheckRedirect function:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n", "1.0", NewVectorFrom(MakeSymbol("url"))),
			"PostForm": MakeGoReceiver("PostForm", _f_ptrTo_Client_PostForm, "PostForm issues a POST to the specified URL,\nwith data's keys and values URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and Client.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n", "1.0", NewVectorFrom(MakeSymbol("url"), MakeSymbol("data"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfClient from _tests/big/src/net/http/client.go:56:6:
	info_ArrayOf_Client = GoTypeInfo{Name: "go.std.net.http/arrayOfClient",
		GoType: &GoType{T: &info_ArrayOf_Client},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
	info_CloseNotifier = GoTypeInfo{Name: "go.std.net.http/CloseNotifier",
		GoType: &GoType{T: &info_CloseNotifier},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
	info_ConnState = GoTypeInfo{Name: "go.std.net.http/ConnState",
		GoType: &GoType{T: &info_ConnState},
		Ctor: _Wrapped_Ctor_ConnState,
		Members: GoMembers{
			"String": MakeGoReceiver("String", _f_connState_String, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http/refToConnState from _tests/big/src/net/http/server.go:2677:6:
	info_PtrTo_ConnState = GoTypeInfo{Name: "go.std.net.http/refToConnState",
		GoType: &GoType{T: &info_PtrTo_ConnState},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfConnState from _tests/big/src/net/http/server.go:2677:6:
	info_ArrayOf_ConnState = GoTypeInfo{Name: "go.std.net.http/arrayOfConnState",
		GoType: &GoType{T: &info_ArrayOf_ConnState},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
	info_Cookie = GoTypeInfo{Name: "go.std.net.http/Cookie",
		GoType: &GoType{T: &info_Cookie},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToCookie from _tests/big/src/net/http/cookie.go:19:6:
	info_PtrTo_Cookie = GoTypeInfo{Name: "go.std.net.http/refToCookie",
		GoType: &GoType{T: &info_PtrTo_Cookie},
		Members: GoMembers{
			"String": MakeGoReceiver("String", _f_ptrTo_Cookie_String, "String returns the serialization of the cookie for use in a Cookie\nheader (if only Name and Value are set) or a Set-Cookie response\nheader (if other fields are set).\nIf c is nil or c.Name is invalid, the empty string is returned.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
	info_CookieJar = GoTypeInfo{Name: "go.std.net.http/CookieJar",
		GoType: &GoType{T: &info_CookieJar},
		Members: GoMembers{
			"Cookies": MakeGoReceiver("Cookies", _f_cookieJar_Cookies, "Cookies returns the cookies to send in a request for the given URL.\nIt is up to the implementation to honor the standard cookie use\nrestrictions such as in RFC 6265.\n", "1.0", NewVectorFrom(MakeSymbol("u"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfCookie from _tests/big/src/net/http/cookie.go:19:6:
	info_ArrayOf_Cookie = GoTypeInfo{Name: "go.std.net.http/arrayOfCookie",
		GoType: &GoType{T: &info_ArrayOf_Cookie},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
	info_Dir = GoTypeInfo{Name: "go.std.net.http/Dir",
		GoType: &GoType{T: &info_Dir},
		Ctor: _Wrapped_Ctor_Dir,
		Members: GoMembers{
			"Open": MakeGoReceiver("Open", _f_dir_Open, "", "1.0", NewVectorFrom(MakeSymbol("name"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/refToDir from _tests/big/src/net/http/fs.go:40:6:
	info_PtrTo_Dir = GoTypeInfo{Name: "go.std.net.http/refToDir",
		GoType: &GoType{T: &info_PtrTo_Dir},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfDir from _tests/big/src/net/http/fs.go:40:6:
	info_ArrayOf_Dir = GoTypeInfo{Name: "go.std.net.http/arrayOfDir",
		GoType: &GoType{T: &info_ArrayOf_Dir},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
	info_File = GoTypeInfo{Name: "go.std.net.http/File",
		GoType: &GoType{T: &info_File},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
	info_FileSystem = GoTypeInfo{Name: "go.std.net.http/FileSystem",
		GoType: &GoType{T: &info_FileSystem},
		Members: GoMembers{
			"Open": MakeGoReceiver("Open", _f_fileSystem_Open, "", "1.0", NewVectorFrom(MakeSymbol("name"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
	info_Flusher = GoTypeInfo{Name: "go.std.net.http/Flusher",
		GoType: &GoType{T: &info_Flusher},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
	info_Handler = GoTypeInfo{Name: "go.std.net.http/Handler",
		GoType: &GoType{T: &info_Handler},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	info_HandlerFunc = GoTypeInfo{Name: "go.std.net.http/HandlerFunc",
		GoType: &GoType{T: &info_HandlerFunc},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	info_PtrTo_HandlerFunc = GoTypeInfo{Name: "go.std.net.http/refToHandlerFunc",
		GoType: &GoType{T: &info_PtrTo_HandlerFunc},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	info_ArrayOf_HandlerFunc = GoTypeInfo{Name: "go.std.net.http/arrayOfHandlerFunc",
		GoType: &GoType{T: &info_ArrayOf_HandlerFunc},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
	info_Header = GoTypeInfo{Name: "go.std.net.http/Header",
		GoType: &GoType{T: &info_Header},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", _f_header_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; textproto.CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/refToHeader from _tests/big/src/net/http/header.go:20:6:
	info_PtrTo_Header = GoTypeInfo{Name: "go.std.net.http/refToHeader",
		GoType: &GoType{T: &info_PtrTo_Header},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfHeader from _tests/big/src/net/http/header.go:20:6:
	info_ArrayOf_Header = GoTypeInfo{Name: "go.std.net.http/arrayOfHeader",
		GoType: &GoType{T: &info_ArrayOf_Header},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
	info_Hijacker = GoTypeInfo{Name: "go.std.net.http/Hijacker",
		GoType: &GoType{T: &info_Hijacker},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
	info_ProtocolError = GoTypeInfo{Name: "go.std.net.http/ProtocolError",
		GoType: &GoType{T: &info_ProtocolError},
		Ctor: _Wrapped_Ctor_ProtocolError,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToProtocolError from _tests/big/src/net/http/request.go:44:6:
	info_PtrTo_ProtocolError = GoTypeInfo{Name: "go.std.net.http/refToProtocolError",
		GoType: &GoType{T: &info_PtrTo_ProtocolError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_ProtocolError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfProtocolError from _tests/big/src/net/http/request.go:44:6:
	info_ArrayOf_ProtocolError = GoTypeInfo{Name: "go.std.net.http/arrayOfProtocolError",
		GoType: &GoType{T: &info_ArrayOf_ProtocolError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
	info_PushOptions = GoTypeInfo{Name: "go.std.net.http/PushOptions",
		GoType: &GoType{T: &info_PushOptions},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToPushOptions from _tests/big/src/net/http/http.go:105:6:
	info_PtrTo_PushOptions = GoTypeInfo{Name: "go.std.net.http/refToPushOptions",
		GoType: &GoType{T: &info_PtrTo_PushOptions},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfPushOptions from _tests/big/src/net/http/http.go:105:6:
	info_ArrayOf_PushOptions = GoTypeInfo{Name: "go.std.net.http/arrayOfPushOptions",
		GoType: &GoType{T: &info_ArrayOf_PushOptions},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
	info_Pusher = GoTypeInfo{Name: "go.std.net.http/Pusher",
		GoType: &GoType{T: &info_Pusher},
		Members: GoMembers{
			"Push": MakeGoReceiver("Push", _f_pusher_Push, "Push initiates an HTTP/2 server push. This constructs a synthetic\nrequest using the given target and options, serializes that request\ninto a PUSH_PROMISE frame, then dispatches that request using the\nserver's request handler. If opts is nil, default options are used.\n\nThe target must either be an absolute path (like \"/path\") or an absolute\nURL that contains a valid host and the same scheme as the parent request.\nIf the target is a path, it will inherit the scheme and host of the\nparent request.\n\nThe HTTP/2 spec disallows recursive pushes and cross-authority pushes.\nPush may or may not detect these invalid pushes; however, invalid\npushes will be detected and canceled by conforming clients.\n\nHandlers that wish to push URL X should call Push before sending any\ndata that may trigger a request for URL X. This avoids a race where the\nclient issues requests for X before receiving the PUSH_PROMISE for X.\n\nPush returns ErrNotSupported if the client has disabled push or if push\nis not supported on the underlying connection.\n", "1.0", NewVectorFrom(MakeSymbol("target"), MakeSymbol("opts"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
	info_Request = GoTypeInfo{Name: "go.std.net.http/Request",
		GoType: &GoType{T: &info_Request},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToRequest from _tests/big/src/net/http/request.go:106:6:
	info_PtrTo_Request = GoTypeInfo{Name: "go.std.net.http/refToRequest",
		GoType: &GoType{T: &info_PtrTo_Request},
		Members: GoMembers{
			"BasicAuth": MakeGoReceiver("BasicAuth", _f_ptrTo_Request_BasicAuth, "BasicAuth returns the username and password provided in the request's\nAuthorization header, if the request uses HTTP Basic Authentication.\nSee RFC 2617, Section 2.\n", "1.0", NewVectorFrom()),
			"Cookie": MakeGoReceiver("Cookie", _f_ptrTo_Request_Cookie, "Cookie returns the named cookie provided in the request or\nErrNoCookie if not found.\nIf multiple cookies match the given name, only one cookie will\nbe returned.\n", "1.0", NewVectorFrom(MakeSymbol("name"))),
			"Cookies": MakeGoReceiver("Cookies", _f_ptrTo_Request_Cookies, "Cookies parses and returns the HTTP cookies sent with the request.\n", "1.0", NewVectorFrom()),
			"FormValue": MakeGoReceiver("FormValue", _f_ptrTo_Request_FormValue, "FormValue returns the first value for the named component of the query.\nPOST and PUT body parameters take precedence over URL query string values.\nFormValue calls ParseMultipartForm and ParseForm if necessary and ignores\nany errors returned by these functions.\nIf key is not present, FormValue returns the empty string.\nTo access multiple values of the same key, call ParseForm and\nthen inspect Request.Form directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"ParseForm": MakeGoReceiver("ParseForm", _f_ptrTo_Request_ParseForm, "ParseForm populates r.Form and r.PostForm.\n\nFor all requests, ParseForm parses the raw query from the URL and updates\nr.Form.\n\nFor POST, PUT, and PATCH requests, it also parses the request body as a form\nand puts the results into both r.PostForm and r.Form. Request body parameters\ntake precedence over URL query string values in r.Form.\n\nFor other HTTP methods, or when the Content-Type is not\napplication/x-www-form-urlencoded, the request Body is not read, and\nr.PostForm is initialized to a non-nil, empty value.\n\nIf the request Body's size has not already been limited by MaxBytesReader,\nthe size is capped at 10MB.\n\nParseMultipartForm calls ParseForm automatically.\nParseForm is idempotent.\n", "1.0", NewVectorFrom()),
			"ParseMultipartForm": MakeGoReceiver("ParseMultipartForm", _f_ptrTo_Request_ParseMultipartForm, "ParseMultipartForm parses a request body as multipart/form-data.\nThe whole request body is parsed and up to a total of maxMemory bytes of\nits file parts are stored in memory, with the remainder stored on\ndisk in temporary files.\nParseMultipartForm calls ParseForm if necessary.\nAfter one call to ParseMultipartForm, subsequent calls have no effect.\n", "1.0", NewVectorFrom(MakeSymbol("maxMemory"))),
			"PostFormValue": MakeGoReceiver("PostFormValue", _f_ptrTo_Request_PostFormValue, "PostFormValue returns the first value for the named component of the POST,\nPATCH, or PUT request body. URL query parameters are ignored.\nPostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores\nany errors returned by these functions.\nIf key is not present, PostFormValue returns the empty string.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"ProtoAtLeast": MakeGoReceiver("ProtoAtLeast", _f_ptrTo_Request_ProtoAtLeast, "ProtoAtLeast reports whether the HTTP protocol used\nin the request is at least major.minor.\n", "1.0", NewVectorFrom(MakeSymbol("major"), MakeSymbol("minor"))),
			"Referer": MakeGoReceiver("Referer", _f_ptrTo_Request_Referer, "Referer returns the referring URL, if sent in the request.\n\nReferer is misspelled as in the request itself, a mistake from the\nearliest days of HTTP.  This value can also be fetched from the\nHeader map as Header[\"Referer\"]; the benefit of making it available\nas a method is that the compiler can diagnose programs that use the\nalternate (correct English) spelling req.Referrer() but cannot\ndiagnose programs that use Header[\"Referrer\"].\n", "1.0", NewVectorFrom()),
			"UserAgent": MakeGoReceiver("UserAgent", _f_ptrTo_Request_UserAgent, "UserAgent returns the client's User-Agent, if sent in the request.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfRequest from _tests/big/src/net/http/request.go:106:6:
	info_ArrayOf_Request = GoTypeInfo{Name: "go.std.net.http/arrayOfRequest",
		GoType: &GoType{T: &info_ArrayOf_Request},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
	info_Response = GoTypeInfo{Name: "go.std.net.http/Response",
		GoType: &GoType{T: &info_Response},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToResponse from _tests/big/src/net/http/response.go:33:6:
	info_PtrTo_Response = GoTypeInfo{Name: "go.std.net.http/refToResponse",
		GoType: &GoType{T: &info_PtrTo_Response},
		Members: GoMembers{
			"Cookies": MakeGoReceiver("Cookies", _f_ptrTo_Response_Cookies, "Cookies parses and returns the cookies set in the Set-Cookie headers.\n", "1.0", NewVectorFrom()),
			"Location": MakeGoReceiver("Location", _f_ptrTo_Response_Location, "Location returns the URL of the response's \"Location\" header,\nif present. Relative redirects are resolved relative to\nthe Response's Request. ErrNoLocation is returned if no\nLocation header is present.\n", "1.0", NewVectorFrom()),
			"ProtoAtLeast": MakeGoReceiver("ProtoAtLeast", _f_ptrTo_Response_ProtoAtLeast, "ProtoAtLeast reports whether the HTTP protocol used\nin the response is at least major.minor.\n", "1.0", NewVectorFrom(MakeSymbol("major"), MakeSymbol("minor"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
	info_ResponseWriter = GoTypeInfo{Name: "go.std.net.http/ResponseWriter",
		GoType: &GoType{T: &info_ResponseWriter},
		Members: GoMembers{
			"Header": MakeGoReceiver("Header", _f_responseWriter_Header, "Header returns the header map that will be sent by\nWriteHeader. The Header map also is the mechanism with which\nHandlers can set HTTP trailers.\n\nChanging the header map after a call to WriteHeader (or\nWrite) has no effect unless the modified headers are\ntrailers.\n\nThere are two ways to set Trailers. The preferred way is to\npredeclare in the headers which trailers you will later\nsend by setting the \"Trailer\" header to the names of the\ntrailer keys which will come later. In this case, those\nkeys of the Header map are treated as if they were\ntrailers. See the example. The second way, for trailer\nkeys not known to the Handler until after the first Write,\nis to prefix the Header map keys with the TrailerPrefix\nconstant value. See TrailerPrefix.\n\nTo suppress automatic response headers (such as \"Date\"), set\ntheir value to nil.\n", "1.0", NewVectorFrom()),
			"Write": MakeGoReceiver("Write", _f_responseWriter_Write, "Write writes the data to the connection as part of an HTTP reply.\n\nIf WriteHeader has not yet been called, Write calls\nWriteHeader(http.StatusOK) before writing the data. If the Header\ndoes not contain a Content-Type line, Write adds a Content-Type set\nto the result of passing the initial 512 bytes of written data to\nDetectContentType. Additionally, if the total size of all written\ndata is under a few KB and there are no Flush calls, the\nContent-Length header is added automatically.\n\nDepending on the HTTP protocol version and the client, calling\nWrite or WriteHeader may prevent future reads on the\nRequest.Body. For HTTP/1.x requests, handlers should read any\nneeded request body data before writing the response. Once the\nheaders have been flushed (due to either an explicit Flusher.Flush\ncall or writing enough data to trigger a flush), the request body\nmay be unavailable. For HTTP/2 requests, the Go HTTP server permits\nhandlers to continue to read the request body while concurrently\nwriting the response. However, such behavior may not be supported\nby all HTTP/2 clients. Handlers should read before writing if\npossible to maximize compatibility.\n", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfResponse from _tests/big/src/net/http/response.go:33:6:
	info_ArrayOf_Response = GoTypeInfo{Name: "go.std.net.http/arrayOfResponse",
		GoType: &GoType{T: &info_ArrayOf_Response},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
	info_RoundTripper = GoTypeInfo{Name: "go.std.net.http/RoundTripper",
		GoType: &GoType{T: &info_RoundTripper},
		Members: GoMembers{
			"RoundTrip": MakeGoReceiver("RoundTrip", _f_roundTripper_RoundTrip, "RoundTrip executes a single HTTP transaction, returning\na Response for the provided Request.\n\nRoundTrip should not attempt to interpret the response. In\nparticular, RoundTrip must return err == nil if it obtained\na response, regardless of the response's HTTP status code.\nA non-nil err should be reserved for failure to obtain a\nresponse. Similarly, RoundTrip should not attempt to\nhandle higher-level protocol details such as redirects,\nauthentication, or cookies.\n\nRoundTrip should not modify the request, except for\nconsuming and closing the Request's Body. RoundTrip may\nread fields of the request in a separate goroutine. Callers\nshould not mutate or reuse the request until the Response's\nBody has been closed.\n\nRoundTrip must always close the body, including on errors,\nbut depending on the implementation may do so in a separate\ngoroutine even after RoundTrip returns. This means that\ncallers wanting to reuse the body for subsequent requests\nmust arrange to wait for the Close call before doing so.\n\nThe Request's URL and Header fields must be initialized.\n", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
	info_SameSite = GoTypeInfo{Name: "go.std.net.http/SameSite",
		GoType: &GoType{T: &info_SameSite},
		Ctor: _Wrapped_Ctor_SameSite,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToSameSite from _tests/big/src/net/http/cookie.go:45:6:
	info_PtrTo_SameSite = GoTypeInfo{Name: "go.std.net.http/refToSameSite",
		GoType: &GoType{T: &info_PtrTo_SameSite},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfSameSite from _tests/big/src/net/http/cookie.go:45:6:
	info_ArrayOf_SameSite = GoTypeInfo{Name: "go.std.net.http/arrayOfSameSite",
		GoType: &GoType{T: &info_ArrayOf_SameSite},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
	info_ServeMux = GoTypeInfo{Name: "go.std.net.http/ServeMux",
		GoType: &GoType{T: &info_ServeMux},
		Ctor: _Wrapped_Ctor_ServeMux,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToServeMux from _tests/big/src/net/http/server.go:2149:6:
	info_PtrTo_ServeMux = GoTypeInfo{Name: "go.std.net.http/refToServeMux",
		GoType: &GoType{T: &info_PtrTo_ServeMux},
		Members: GoMembers{
			"Handler": MakeGoReceiver("Handler", _f_ptrTo_ServeMux_Handler, "Handler returns the handler to use for the given request,\nconsulting r.Method, r.Host, and r.URL.Path. It always returns\na non-nil handler. If the path is not in its canonical form, the\nhandler will be an internally-generated handler that redirects\nto the canonical path. If the host contains a port, it is ignored\nwhen matching handlers.\n\nThe path and host are used unchanged for CONNECT requests.\n\nHandler also returns the registered pattern that matches the\nrequest or, in the case of internally-generated redirects,\nthe pattern that will match after following the redirect.\n\nIf there is no registered handler that applies to the request,\nHandler returns a ``page not found'' handler and an empty pattern.\n", "1.0", NewVectorFrom(MakeSymbol("r"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfServeMux from _tests/big/src/net/http/server.go:2149:6:
	info_ArrayOf_ServeMux = GoTypeInfo{Name: "go.std.net.http/arrayOfServeMux",
		GoType: &GoType{T: &info_ArrayOf_ServeMux},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
	info_Server = GoTypeInfo{Name: "go.std.net.http/Server",
		GoType: &GoType{T: &info_Server},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToServer from _tests/big/src/net/http/server.go:2445:6:
	info_PtrTo_Server = GoTypeInfo{Name: "go.std.net.http/refToServer",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_ptrTo_Server_Close, "Close immediately closes all active net.Listeners and any\nconnections in state StateNew, StateActive, or StateIdle. For a\ngraceful shutdown, use Shutdown.\n\nClose does not attempt to close (and does not even know about)\nany hijacked connections, such as WebSockets.\n\nClose returns any error returned from closing the Server's\nunderlying Listener(s).\n", "1.0", NewVectorFrom()),
			"ListenAndServe": MakeGoReceiver("ListenAndServe", _f_ptrTo_Server_ListenAndServe, "ListenAndServe listens on the TCP network address srv.Addr and then\ncalls Serve to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nIf srv.Addr is blank, \":http\" is used.\n\nListenAndServe always returns a non-nil error. After Shutdown or Close,\nthe returned error is ErrServerClosed.\n", "1.0", NewVectorFrom()),
			"ListenAndServeTLS": MakeGoReceiver("ListenAndServeTLS", _f_ptrTo_Server_ListenAndServeTLS, "ListenAndServeTLS listens on the TCP network address srv.Addr and\nthen calls ServeTLS to handle requests on incoming TLS connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nFilenames containing a certificate and matching private key for the\nserver must be provided if neither the Server's TLSConfig.Certificates\nnor TLSConfig.GetCertificate are populated. If the certificate is\nsigned by a certificate authority, the certFile should be the\nconcatenation of the server's certificate, any intermediates, and\nthe CA's certificate.\n\nIf srv.Addr is blank, \":https\" is used.\n\nListenAndServeTLS always returns a non-nil error. After Shutdown or\nClose, the returned error is ErrServerClosed.\n", "1.0", NewVectorFrom(MakeSymbol("certFile"), MakeSymbol("keyFile"))),
			"Serve": MakeGoReceiver("Serve", _f_ptrTo_Server_Serve, "Serve accepts incoming connections on the Listener l, creating a\nnew service goroutine for each. The service goroutines read requests and\nthen call srv.Handler to reply to them.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error and closes l.\nAfter Shutdown or Close, the returned error is ErrServerClosed.\n", "1.0", NewVectorFrom(MakeSymbol("l"))),
			"ServeTLS": MakeGoReceiver("ServeTLS", _f_ptrTo_Server_ServeTLS, "ServeTLS accepts incoming connections on the Listener l, creating a\nnew service goroutine for each. The service goroutines perform TLS\nsetup and then read requests, calling srv.Handler to reply to them.\n\nFiles containing a certificate and matching private key for the\nserver must be provided if neither the Server's\nTLSConfig.Certificates nor TLSConfig.GetCertificate are populated.\nIf the certificate is signed by a certificate authority, the\ncertFile should be the concatenation of the server's certificate,\nany intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error. After Shutdown or Close, the\nreturned error is ErrServerClosed.\n", "1.0", NewVectorFrom(MakeSymbol("l"), MakeSymbol("certFile"), MakeSymbol("keyFile"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfServer from _tests/big/src/net/http/server.go:2445:6:
	info_ArrayOf_Server = GoTypeInfo{Name: "go.std.net.http/arrayOfServer",
		GoType: &GoType{T: &info_ArrayOf_Server},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
	info_Transport = GoTypeInfo{Name: "go.std.net.http/Transport",
		GoType: &GoType{T: &info_Transport},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http/refToTransport from _tests/big/src/net/http/transport.go:103:6:
	info_PtrTo_Transport = GoTypeInfo{Name: "go.std.net.http/refToTransport",
		GoType: &GoType{T: &info_PtrTo_Transport},
		Members: GoMembers{
			"RoundTrip": MakeGoReceiver("RoundTrip", _f_ptrTo_Transport_RoundTrip, "RoundTrip implements the RoundTripper interface.\n\nFor higher-level HTTP client support (such as handling of cookies\nand redirects), see Get, Post, and the Client type.\n\nLike the RoundTripper interface, the error types returned\nby RoundTrip are unspecified.\n", "1.0", NewVectorFrom(MakeSymbol("req"))),
		},
	}


GO INFO FOR TYPE go.std.net.http/arrayOfTransport from _tests/big/src/net/http/transport.go:103:6:
	info_ArrayOf_Transport = GoTypeInfo{Name: "go.std.net.http/arrayOfTransport",
		GoType: &GoType{T: &info_ArrayOf_Transport},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
	GoTypesVec[203] = &info_Client

GO VECSET FOR TYPE go.std.net.http/refToClient from _tests/big/src/net/http/client.go:56:6:
	GoTypesVec[30] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.http/arrayOfClient from _tests/big/src/net/http/client.go:56:6:
	GoTypesVec[120] = &info_ArrayOf_Client

GO VECSET FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
	GoTypesVec[268] = &info_CloseNotifier

GO VECSET FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
	GoTypesVec[204] = &info_ConnState

GO VECSET FOR TYPE go.std.net.http/refToConnState from _tests/big/src/net/http/server.go:2677:6:
	GoTypesVec[31] = &info_PtrTo_ConnState

GO VECSET FOR TYPE go.std.net.http/arrayOfConnState from _tests/big/src/net/http/server.go:2677:6:
	GoTypesVec[121] = &info_ArrayOf_ConnState

GO VECSET FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
	GoTypesVec[205] = &info_Cookie

GO VECSET FOR TYPE go.std.net.http/refToCookie from _tests/big/src/net/http/cookie.go:19:6:
	GoTypesVec[32] = &info_PtrTo_Cookie

GO VECSET FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
	GoTypesVec[263] = &info_CookieJar

GO VECSET FOR TYPE go.std.net.http/arrayOfCookie from _tests/big/src/net/http/cookie.go:19:6:
	GoTypesVec[122] = &info_ArrayOf_Cookie

GO VECSET FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
	GoTypesVec[206] = &info_Dir

GO VECSET FOR TYPE go.std.net.http/refToDir from _tests/big/src/net/http/fs.go:40:6:
	GoTypesVec[33] = &info_PtrTo_Dir

GO VECSET FOR TYPE go.std.net.http/arrayOfDir from _tests/big/src/net/http/fs.go:40:6:
	GoTypesVec[123] = &info_ArrayOf_Dir

GO VECSET FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
	GoTypesVec[264] = &info_File

GO VECSET FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
	GoTypesVec[269] = &info_FileSystem

GO VECSET FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
	GoTypesVec[270] = &info_Flusher

GO VECSET FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
	GoTypesVec[271] = &info_Handler

GO VECSET FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	GoTypesVec[207] = &info_HandlerFunc

GO VECSET FOR TYPE go.std.net.http/refToHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	GoTypesVec[34] = &info_PtrTo_HandlerFunc

GO VECSET FOR TYPE go.std.net.http/arrayOfHandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	GoTypesVec[124] = &info_ArrayOf_HandlerFunc

GO VECSET FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
	GoTypesVec[208] = &info_Header

GO VECSET FOR TYPE go.std.net.http/refToHeader from _tests/big/src/net/http/header.go:20:6:
	GoTypesVec[35] = &info_PtrTo_Header

GO VECSET FOR TYPE go.std.net.http/arrayOfHeader from _tests/big/src/net/http/header.go:20:6:
	GoTypesVec[125] = &info_ArrayOf_Header

GO VECSET FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
	GoTypesVec[272] = &info_Hijacker

GO VECSET FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
	GoTypesVec[209] = &info_ProtocolError

GO VECSET FOR TYPE go.std.net.http/refToProtocolError from _tests/big/src/net/http/request.go:44:6:
	GoTypesVec[36] = &info_PtrTo_ProtocolError

GO VECSET FOR TYPE go.std.net.http/arrayOfProtocolError from _tests/big/src/net/http/request.go:44:6:
	GoTypesVec[126] = &info_ArrayOf_ProtocolError

GO VECSET FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
	GoTypesVec[210] = &info_PushOptions

GO VECSET FOR TYPE go.std.net.http/refToPushOptions from _tests/big/src/net/http/http.go:105:6:
	GoTypesVec[37] = &info_PtrTo_PushOptions

GO VECSET FOR TYPE go.std.net.http/arrayOfPushOptions from _tests/big/src/net/http/http.go:105:6:
	GoTypesVec[127] = &info_ArrayOf_PushOptions

GO VECSET FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
	GoTypesVec[273] = &info_Pusher

GO VECSET FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
	GoTypesVec[211] = &info_Request

GO VECSET FOR TYPE go.std.net.http/refToRequest from _tests/big/src/net/http/request.go:106:6:
	GoTypesVec[38] = &info_PtrTo_Request

GO VECSET FOR TYPE go.std.net.http/arrayOfRequest from _tests/big/src/net/http/request.go:106:6:
	GoTypesVec[128] = &info_ArrayOf_Request

GO VECSET FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
	GoTypesVec[212] = &info_Response

GO VECSET FOR TYPE go.std.net.http/refToResponse from _tests/big/src/net/http/response.go:33:6:
	GoTypesVec[39] = &info_PtrTo_Response

GO VECSET FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
	GoTypesVec[261] = &info_ResponseWriter

GO VECSET FOR TYPE go.std.net.http/arrayOfResponse from _tests/big/src/net/http/response.go:33:6:
	GoTypesVec[129] = &info_ArrayOf_Response

GO VECSET FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
	GoTypesVec[274] = &info_RoundTripper

GO VECSET FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
	GoTypesVec[213] = &info_SameSite

GO VECSET FOR TYPE go.std.net.http/refToSameSite from _tests/big/src/net/http/cookie.go:45:6:
	GoTypesVec[40] = &info_PtrTo_SameSite

GO VECSET FOR TYPE go.std.net.http/arrayOfSameSite from _tests/big/src/net/http/cookie.go:45:6:
	GoTypesVec[130] = &info_ArrayOf_SameSite

GO VECSET FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
	GoTypesVec[214] = &info_ServeMux

GO VECSET FOR TYPE go.std.net.http/refToServeMux from _tests/big/src/net/http/server.go:2149:6:
	GoTypesVec[41] = &info_PtrTo_ServeMux

GO VECSET FOR TYPE go.std.net.http/arrayOfServeMux from _tests/big/src/net/http/server.go:2149:6:
	GoTypesVec[131] = &info_ArrayOf_ServeMux

GO VECSET FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
	GoTypesVec[215] = &info_Server

GO VECSET FOR TYPE go.std.net.http/refToServer from _tests/big/src/net/http/server.go:2445:6:
	GoTypesVec[42] = &info_PtrTo_Server

GO VECSET FOR TYPE go.std.net.http/arrayOfServer from _tests/big/src/net/http/server.go:2445:6:
	GoTypesVec[132] = &info_ArrayOf_Server

GO VECSET FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
	GoTypesVec[216] = &info_Transport

GO VECSET FOR TYPE go.std.net.http/refToTransport from _tests/big/src/net/http/transport.go:103:6:
	GoTypesVec[43] = &info_PtrTo_Transport

GO VECSET FOR TYPE go.std.net.http/arrayOfTransport from _tests/big/src/net/http/transport.go:103:6:
	GoTypesVec[133] = &info_ArrayOf_Transport

GO ENSURE-LOADED FOR http:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:20:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:21:2
	EnsureLoaded("go.std.compress.gzip")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:22:2
	EnsureLoaded("go.std.container.list")  // E.g. from: _tests/big/src/net/http/transport.go:15:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:23:2
	EnsureLoaded("go.std.crypto.rand")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:24:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/client.go:13:2
	EnsureLoaded("go.std.encoding.base64")  // E.g. from: _tests/big/src/net/http/client.go:14:2
	EnsureLoaded("go.std.encoding.binary")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:26:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/client.go:15:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/client.go:16:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpguts")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:47:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpproxy")  // E.g. from: _tests/big/src/net/http/transport.go:34:2
	EnsureLoaded("go.std.golang_org.x.net.http2.hpack")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:48:2
	EnsureLoaded("go.std.golang_org.x.net.idna")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:49:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/client.go:17:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/client.go:18:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/client.go:19:2
	EnsureLoaded("go.std.math")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:32:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:33:11
	EnsureLoaded("go.std.mime")  // E.g. from: _tests/big/src/net/http/fs.go:13:2
	EnsureLoaded("go.std.mime.multipart")  // E.g. from: _tests/big/src/net/http/fs.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/cookie.go:9:2
	EnsureLoaded("go.std.net.http.httptrace")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:35:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/fs.go:15:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/client.go:20:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/fs.go:17:2
	EnsureLoaded("go.std.path")  // E.g. from: _tests/big/src/net/http/fs.go:18:2
	EnsureLoaded("go.std.path.filepath")  // E.g. from: _tests/big/src/net/http/fs.go:19:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:39:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:40:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/client.go:21:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/cookie.go:10:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/client.go:22:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/client.go:23:2
	EnsureLoaded("go.std.sync.atomic")  // E.g. from: _tests/big/src/net/http/server.go:28:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/client.go:24:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/http/http.go:12:2

GO TYPE []net/http/cgi.Handler from net/http/cgi/host.go:
func Extract_ns_arrayOfHandler(args []Object, index int) []cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []cgi.Handler:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/cgi.Handler]"))
}

GO TYPE net/http/cgi.Handler from net/http/cgi/host.go:
func Extract_ns_Handler(args []Object, index int) *cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cgi.Handler:
			return r
		case cgi.Handler:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cgi.Handler]"))
}

// func _mapToHandler(o Map) *cgi.Handler {
// 	return &cgi.Handler{
// 		Path: FieldAsString(o, "Path"),
// 		Root: FieldAsString(o, "Root"),
// 		Dir: FieldAsString(o, "Dir"),
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 		InheritEnv: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 		Logger: *ABEND002(reference to unavailable package `log' looking for type `Logger'),
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 		Stderr: io.ABEND002(reference to unavailable package `io' looking for type `Writer'),
// 		PathLocationHandler: ABEND048(codegen.go: no conversion from Clojure for net/http.Handler (ABEND320(gtypes.go: interface{ServeHTTP func(ResponseWriter,*Request)} not supported))),
// 	}
// }

// func _Ctor_Handler(_v Object) *cgi.Handler {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToHandler(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cgi.Handler] or: Map"))
// }

// func _Wrapped_Ctor_Handler(_o Object) Object {
// 	return MakeGoObject(_Ctor_Handler(_o))
// }

GO TYPE *net/http/cgi.Handler from net/http/cgi/host.go:
func Extract_ns_refToHandler(args []Object, index int) *cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cgi.Handler:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/cgi.Handler]"))
}

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func _f_request() Object {
	_res1, _res2 := cgi.Request()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func _f_requestFromMap(_v_params map[string]string) Object {
// 	_res1, _res2 := cgi.RequestFromMap(_v_params)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi._f_ptrTo_Handler_ServeHTTP from net/http/cgi/host.go:
// func _f_ptrTo_Handler_ServeHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
var info_Handler GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cgi/refToHandler from _tests/big/src/net/http/cgi/host.go:47:6:
var info_PtrTo_Handler GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cgi/arrayOfHandler from _tests/big/src/net/http/cgi/host.go:47:6:
var info_ArrayOf_Handler GoTypeInfo

GO INFO FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
	info_Handler = GoTypeInfo{Name: "go.std.net.http.cgi/Handler",
		GoType: &GoType{T: &info_Handler},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cgi/refToHandler from _tests/big/src/net/http/cgi/host.go:47:6:
	info_PtrTo_Handler = GoTypeInfo{Name: "go.std.net.http.cgi/refToHandler",
		GoType: &GoType{T: &info_PtrTo_Handler},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cgi/arrayOfHandler from _tests/big/src/net/http/cgi/host.go:47:6:
	info_ArrayOf_Handler = GoTypeInfo{Name: "go.std.net.http.cgi/arrayOfHandler",
		GoType: &GoType{T: &info_ArrayOf_Handler},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
	GoTypesVec[217] = &info_Handler

GO VECSET FOR TYPE go.std.net.http.cgi/refToHandler from _tests/big/src/net/http/cgi/host.go:47:6:
	GoTypesVec[44] = &info_PtrTo_Handler

GO VECSET FOR TYPE go.std.net.http.cgi/arrayOfHandler from _tests/big/src/net/http/cgi/host.go:47:6:
	GoTypesVec[134] = &info_ArrayOf_Handler

GO ENSURE-LOADED FOR cgi:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/cgi/child.go:11:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/cgi/child.go:12:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/cgi/child.go:13:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/cgi/child.go:14:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/cgi/child.go:15:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/cgi/child.go:16:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/cgi/host.go:21:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/cgi/child.go:17:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/cgi/child.go:18:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/cgi/child.go:19:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/cgi/child.go:20:2
	EnsureLoaded("go.std.os.exec")  // E.g. from: _tests/big/src/net/http/cgi/host.go:25:2
	EnsureLoaded("go.std.path.filepath")  // E.g. from: _tests/big/src/net/http/cgi/host.go:26:2
	EnsureLoaded("go.std.regexp")  // E.g. from: _tests/big/src/net/http/cgi/host.go:27:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/cgi/host.go:28:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/cgi/child.go:21:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/cgi/child.go:22:2

GO TYPE []net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func Extract_ns_arrayOfJar(args []Object, index int) []cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []cookiejar.Jar:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/cookiejar.Jar]"))
}

GO TYPE []net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func Extract_ns_arrayOfOptions(args []Object, index int) []cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []cookiejar.Options:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/cookiejar.Options]"))
}

GO TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func Extract_ns_Jar(args []Object, index int) *cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cookiejar.Jar:
			return r
		case cookiejar.Jar:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *cookiejar.Jar {
	return &cookiejar.Jar{}
}

func _Ctor_Jar(_v Object) *cookiejar.Jar {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or: Map"))
}

func _Wrapped_Ctor_Jar(_o Object) Object {
	return MakeGoObject(_Ctor_Jar(_o))
}

GO TYPE *net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func Extract_ns_refToJar(args []Object, index int) *cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cookiejar.Jar:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/cookiejar.Jar]"))
}

GO TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func Extract_ns_Options(args []Object, index int) *cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cookiejar.Options:
			return r
		case cookiejar.Options:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

// func _mapToOptions(o Map) *cookiejar.Options {
// 	return &cookiejar.Options{
// 		PublicSuffixList: ABEND048(codegen.go: no conversion from Clojure for net/http/cookiejar.PublicSuffixList (ABEND320(gtypes.go: interface{PublicSuffix func(domain string)string,String func()string} not supported))),
// 	}
// }

// func _Ctor_Options(_v Object) *cookiejar.Options {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptions(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or: Map"))
// }

// func _Wrapped_Ctor_Options(_o Object) Object {
// 	return MakeGoObject(_Ctor_Options(_o))
// }

GO TYPE *net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func Extract_ns_refToOptions(args []Object, index int) *cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *cookiejar.Options:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/cookiejar.Options]"))
}

GO TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
func Extract_ns_PublicSuffixList(args []Object, index int) cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case cookiejar.PublicSuffixList:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
func _f_new(_v_o *cookiejar.Options) Object {
	_res1, _res2 := cookiejar.New(_v_o)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cookiejar._f_ptrTo_Jar_Cookies from net/http/cookiejar/jar.go:
func _f_ptrTo_Jar_Cookies(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*cookiejar.Jar)Cookies()", args, 1, 1)
	_v_u := SeqNth(_argList, 0).(GoObject).O.(*url.URL)
	_res := o.O.(*cookiejar.Jar).Cookies(_v_u)
	return MakeGoObject(_res)
}

GO FUNC net/http/cookiejar._f_ptrTo_Jar_SetCookies from net/http/cookiejar/jar.go:
// func _f_ptrTo_Jar_SetCookies(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/cookiejar._f_publicSuffixList_PublicSuffix from net/http/cookiejar/jar.go:
func _f_publicSuffixList_PublicSuffix(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/http/cookiejar.PublicSuffixList)PublicSuffix()", args, 1, 1)
	_v_domain := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_domain): %s")
	_res := o.O.(cookiejar.PublicSuffixList).PublicSuffix(_v_domain)
	return MakeString(_res)
}

GO FUNC net/http/cookiejar._f_publicSuffixList_String from net/http/cookiejar/jar.go:
func _f_publicSuffixList_String(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net/http/cookiejar.PublicSuffixList)String()", args, 0, 0)
	_res := o.O.(cookiejar.PublicSuffixList).String()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
var info_Jar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/refToJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
var info_PtrTo_Jar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/arrayOfJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
var info_ArrayOf_Jar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
var info_Options GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/refToOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
var info_PtrTo_Options GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/arrayOfOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
var info_ArrayOf_Options GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
var info_PublicSuffixList GoTypeInfo

GO INFO FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	info_Jar = GoTypeInfo{Name: "go.std.net.http.cookiejar/Jar",
		GoType: &GoType{T: &info_Jar},
		Ctor: _Wrapped_Ctor_Jar,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/refToJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	info_PtrTo_Jar = GoTypeInfo{Name: "go.std.net.http.cookiejar/refToJar",
		GoType: &GoType{T: &info_PtrTo_Jar},
		Members: GoMembers{
			"Cookies": MakeGoReceiver("Cookies", _f_ptrTo_Jar_Cookies, "Cookies implements the Cookies method of the http.CookieJar interface.\n\nIt returns an empty slice if the URL's scheme is not HTTP or HTTPS.\n", "1.0", NewVectorFrom(MakeSymbol("u"))),
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/arrayOfJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	info_ArrayOf_Jar = GoTypeInfo{Name: "go.std.net.http.cookiejar/arrayOfJar",
		GoType: &GoType{T: &info_ArrayOf_Jar},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	info_Options = GoTypeInfo{Name: "go.std.net.http.cookiejar/Options",
		GoType: &GoType{T: &info_Options},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/refToOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	info_PtrTo_Options = GoTypeInfo{Name: "go.std.net.http.cookiejar/refToOptions",
		GoType: &GoType{T: &info_PtrTo_Options},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/arrayOfOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	info_ArrayOf_Options = GoTypeInfo{Name: "go.std.net.http.cookiejar/arrayOfOptions",
		GoType: &GoType{T: &info_ArrayOf_Options},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
	info_PublicSuffixList = GoTypeInfo{Name: "go.std.net.http.cookiejar/PublicSuffixList",
		GoType: &GoType{T: &info_PublicSuffixList},
		Members: GoMembers{
			"PublicSuffix": MakeGoReceiver("PublicSuffix", _f_publicSuffixList_PublicSuffix, "PublicSuffix returns the public suffix of domain.\n\nTODO: specify which of the caller and callee is responsible for IP\naddresses, for leading and trailing dots, for case sensitivity, and\nfor IDN/Punycode.\n", "1.0", NewVectorFrom(MakeSymbol("domain"))),
			"String": MakeGoReceiver("String", _f_publicSuffixList_String, "String returns a description of the source of this public suffix\nlist. The description will typically contain something like a time\nstamp or version number.\n", "1.0", NewVectorFrom()),
		},
	}


GO VECSET FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	GoTypesVec[218] = &info_Jar

GO VECSET FOR TYPE go.std.net.http.cookiejar/refToJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	GoTypesVec[45] = &info_PtrTo_Jar

GO VECSET FOR TYPE go.std.net.http.cookiejar/arrayOfJar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	GoTypesVec[135] = &info_ArrayOf_Jar

GO VECSET FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	GoTypesVec[219] = &info_Options

GO VECSET FOR TYPE go.std.net.http.cookiejar/refToOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	GoTypesVec[46] = &info_PtrTo_Options

GO VECSET FOR TYPE go.std.net.http.cookiejar/arrayOfOptions from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	GoTypesVec[136] = &info_ArrayOf_Options

GO VECSET FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
	GoTypesVec[265] = &info_PublicSuffixList

GO ENSURE-LOADED FOR cookiejar:
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:10:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:11:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:12:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:13:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:14:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:15:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:16:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:17:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/http/cookiejar/punycode.go:12:2

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func _f_processEnv(_v_r *http.Request) Object {
// 	_res := fcgi.ProcessEnv(_v_r)
// 	return MakeGoObject(_res)
// }

GO ENSURE-LOADED FOR fcgi:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:17:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:18:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:10:2
	EnsureLoaded("go.std.encoding.binary")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:19:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:11:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:12:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:13:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:15:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:16:2
	EnsureLoaded("go.std.net.http.cgi")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:17:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:18:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:19:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:20:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:21:2

GO TYPE []net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func Extract_ns_arrayOfResponseRecorder(args []Object, index int) []httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptest.ResponseRecorder:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptest.ResponseRecorder]"))
}

GO TYPE []net/http/httptest.Server from net/http/httptest/server.go:
func Extract_ns_arrayOfServer(args []Object, index int) []httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptest.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptest.Server]"))
}

GO TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func Extract_ns_ResponseRecorder(args []Object, index int) *httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptest.ResponseRecorder:
			return r
		case httptest.ResponseRecorder:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.ResponseRecorder]"))
}

// func _mapToResponseRecorder(o Map) *httptest.ResponseRecorder {
// 	return &httptest.ResponseRecorder{
// 		Code: FieldAsInt(o, "Code"),
// 		HeaderMap: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (map[string][]string)),
// 		Body: *ABEND002(reference to unavailable package `bytes' looking for type `Buffer'),
// 		Flushed: FieldAsBoolean(o, "Flushed"),
// 	}
// }

// func _Ctor_ResponseRecorder(_v Object) *httptest.ResponseRecorder {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponseRecorder(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.ResponseRecorder] or: Map"))
// }

// func _Wrapped_Ctor_ResponseRecorder(_o Object) Object {
// 	return MakeGoObject(_Ctor_ResponseRecorder(_o))
// }

GO TYPE *net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func Extract_ns_refToResponseRecorder(args []Object, index int) *httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptest.ResponseRecorder:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptest.ResponseRecorder]"))
}

GO TYPE net/http/httptest.Server from net/http/httptest/server.go:
func Extract_ns_Server(args []Object, index int) *httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptest.Server:
			return r
		case httptest.Server:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.Server]"))
}

// func _mapToServer(o Map) *httptest.Server {
// 	return &httptest.Server{
// 		URL: FieldAsString(o, "URL"),
// 		Listener: ABEND048(codegen.go: no conversion from Clojure for net.Listener (ABEND320(gtypes.go: interface{Accept func()(Conn,error),Close func()error,Addr func()Addr} not supported))),
// 		TLS: *ABEND002(reference to unavailable package `crypto/tls' looking for type `Config'),
// 		Config: ABEND048(codegen.go: no conversion from Clojure for *net/http.Server (net/http.Server)),
// 	}
// }

// func _Ctor_Server(_v Object) *httptest.Server {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.Server] or: Map"))
// }

// func _Wrapped_Ctor_Server(_o Object) Object {
// 	return MakeGoObject(_Ctor_Server(_o))
// }

GO TYPE *net/http/httptest.Server from net/http/httptest/server.go:
func Extract_ns_refToServer(args []Object, index int) *httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptest.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptest.Server]"))
}

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func _f_newRecorder() Object {
	_res := httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func _f_newRequest(_v_method string, _v_target string, _v_body ABEND002(reference to unavailable package `io' looking for type `Reader')) Object {
// 	_res := httptest.NewRequest(_v_method, _v_target, _v_body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
func _f_newServer(_v_handler http.Handler) Object {
	_res := httptest.NewServer(_v_handler)
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
func _f_newTLSServer(_v_handler http.Handler) Object {
	_res := httptest.NewTLSServer(_v_handler)
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
func _f_newUnstartedServer(_v_handler http.Handler) Object {
	_res := httptest.NewUnstartedServer(_v_handler)
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_Flush from net/http/httptest/recorder.go:
// func _f_ptrTo_ResponseRecorder_Flush(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_Header from net/http/httptest/recorder.go:
func _f_ptrTo_ResponseRecorder_Header(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httptest.ResponseRecorder)Header()", args, 0, 0)
	_res := o.O.(*httptest.ResponseRecorder).Header()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_Result from net/http/httptest/recorder.go:
func _f_ptrTo_ResponseRecorder_Result(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httptest.ResponseRecorder)Result()", args, 0, 0)
	_res := o.O.(*httptest.ResponseRecorder).Result()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_Write from net/http/httptest/recorder.go:
func _f_ptrTo_ResponseRecorder_Write(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httptest.ResponseRecorder)Write()", args, 1, 1)
	_v_buf := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res1, _res2 := o.O.(*httptest.ResponseRecorder).Write(_v_buf)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_WriteHeader from net/http/httptest/recorder.go:
// func _f_ptrTo_ResponseRecorder_WriteHeader(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest._f_ptrTo_ResponseRecorder_WriteString from net/http/httptest/recorder.go:
func _f_ptrTo_ResponseRecorder_WriteString(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httptest.ResponseRecorder)WriteString()", args, 1, 1)
	_v_str := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_str): %s")
	_res1, _res2 := o.O.(*httptest.ResponseRecorder).WriteString(_v_str)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httptest._f_ptrTo_Server_Certificate from net/http/httptest/server.go:
// func _f_ptrTo_Server_Certificate(o GoObject, args Object) Object {  // Receiver
// *ABEND002(reference to unavailable package `crypto/x509' looking for type `Certificate')}

GO FUNC net/http/httptest._f_ptrTo_Server_Client from net/http/httptest/server.go:
func _f_ptrTo_Server_Client(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httptest.Server)Client()", args, 0, 0)
	_res := o.O.(*httptest.Server).Client()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest._f_ptrTo_Server_Close from net/http/httptest/server.go:
// func _f_ptrTo_Server_Close(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest._f_ptrTo_Server_CloseClientConnections from net/http/httptest/server.go:
// func _f_ptrTo_Server_CloseClientConnections(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest._f_ptrTo_Server_Start from net/http/httptest/server.go:
// func _f_ptrTo_Server_Start(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest._f_ptrTo_Server_StartTLS from net/http/httptest/server.go:
// func _f_ptrTo_Server_StartTLS(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
var info_ResponseRecorder GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/refToResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
var info_PtrTo_ResponseRecorder GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/arrayOfResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
var info_ArrayOf_ResponseRecorder GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/refToServer from _tests/big/src/net/http/httptest/server.go:26:6:
var info_PtrTo_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/arrayOfServer from _tests/big/src/net/http/httptest/server.go:26:6:
var info_ArrayOf_Server GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	info_ResponseRecorder = GoTypeInfo{Name: "go.std.net.http.httptest/ResponseRecorder",
		GoType: &GoType{T: &info_ResponseRecorder},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptest/refToResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	info_PtrTo_ResponseRecorder = GoTypeInfo{Name: "go.std.net.http.httptest/refToResponseRecorder",
		GoType: &GoType{T: &info_PtrTo_ResponseRecorder},
		Members: GoMembers{
			"Header": MakeGoReceiver("Header", _f_ptrTo_ResponseRecorder_Header, "Header returns the response headers.\n", "1.0", NewVectorFrom()),
			"Result": MakeGoReceiver("Result", _f_ptrTo_ResponseRecorder_Result, "Result returns the response generated by the handler.\n\nThe returned Response will have at least its StatusCode,\nHeader, Body, and optionally Trailer populated.\nMore fields may be populated in the future, so callers should\nnot DeepEqual the result in tests.\n\nThe Response.Header is a snapshot of the headers at the time of the\nfirst write call, or at the time of this call, if the handler never\ndid a write.\n\nThe Response.Body is guaranteed to be non-nil and Body.Read call is\nguaranteed to not return any error other than io.EOF.\n\nResult must only be called after the handler has finished running.\n", "1.0", NewVectorFrom()),
			"Write": MakeGoReceiver("Write", _f_ptrTo_ResponseRecorder_Write, "Write always succeeds and writes to rw.Body, if not nil.\n", "1.0", NewVectorFrom(MakeSymbol("buf"))),
			"WriteString": MakeGoReceiver("WriteString", _f_ptrTo_ResponseRecorder_WriteString, "WriteString always succeeds and writes to rw.Body, if not nil.\n", "1.0", NewVectorFrom(MakeSymbol("str"))),
		},
	}


GO INFO FOR TYPE go.std.net.http.httptest/arrayOfResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	info_ArrayOf_ResponseRecorder = GoTypeInfo{Name: "go.std.net.http.httptest/arrayOfResponseRecorder",
		GoType: &GoType{T: &info_ArrayOf_ResponseRecorder},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
	info_Server = GoTypeInfo{Name: "go.std.net.http.httptest/Server",
		GoType: &GoType{T: &info_Server},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptest/refToServer from _tests/big/src/net/http/httptest/server.go:26:6:
	info_PtrTo_Server = GoTypeInfo{Name: "go.std.net.http.httptest/refToServer",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"Client": MakeGoReceiver("Client", _f_ptrTo_Server_Client, "Client returns an HTTP client configured for making requests to the server.\nIt is configured to trust the server's TLS test certificate and will\nclose its idle connections on Server.Close.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http.httptest/arrayOfServer from _tests/big/src/net/http/httptest/server.go:26:6:
	info_ArrayOf_Server = GoTypeInfo{Name: "go.std.net.http.httptest/arrayOfServer",
		GoType: &GoType{T: &info_ArrayOf_Server},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	GoTypesVec[220] = &info_ResponseRecorder

GO VECSET FOR TYPE go.std.net.http.httptest/refToResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	GoTypesVec[47] = &info_PtrTo_ResponseRecorder

GO VECSET FOR TYPE go.std.net.http.httptest/arrayOfResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	GoTypesVec[137] = &info_ArrayOf_ResponseRecorder

GO VECSET FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
	GoTypesVec[221] = &info_Server

GO VECSET FOR TYPE go.std.net.http.httptest/refToServer from _tests/big/src/net/http/httptest/server.go:26:6:
	GoTypesVec[48] = &info_PtrTo_Server

GO VECSET FOR TYPE go.std.net.http.httptest/arrayOfServer from _tests/big/src/net/http/httptest/server.go:26:6:
	GoTypesVec[138] = &info_ArrayOf_Server

GO ENSURE-LOADED FOR httptest:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:9:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:10:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:11:2
	EnsureLoaded("go.std.crypto.x509")  // E.g. from: _tests/big/src/net/http/httptest/server.go:11:2
	EnsureLoaded("go.std.flag")  // E.g. from: _tests/big/src/net/http/httptest/server.go:12:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/httptest/recorder.go:9:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpguts")  // E.g. from: _tests/big/src/net/http/httptest/recorder.go:15:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:12:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:13:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/httptest/server.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httptest/server.go:15:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:14:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/httptest/server.go:18:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/httptest/recorder.go:12:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:15:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/httptest/server.go:20:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httptest/server.go:21:2

GO TYPE []net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
func Extract_ns_arrayOfClientTrace(args []Object, index int) []httptrace.ClientTrace {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptrace.ClientTrace:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptrace.ClientTrace]"))
}

GO TYPE []net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
func Extract_ns_arrayOfDNSDoneInfo(args []Object, index int) []httptrace.DNSDoneInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptrace.DNSDoneInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptrace.DNSDoneInfo]"))
}

GO TYPE []net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
func Extract_ns_arrayOfDNSStartInfo(args []Object, index int) []httptrace.DNSStartInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptrace.DNSStartInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptrace.DNSStartInfo]"))
}

GO TYPE []net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
func Extract_ns_arrayOfGotConnInfo(args []Object, index int) []httptrace.GotConnInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptrace.GotConnInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptrace.GotConnInfo]"))
}

GO TYPE []net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
func Extract_ns_arrayOfWroteRequestInfo(args []Object, index int) []httptrace.WroteRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httptrace.WroteRequestInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httptrace.WroteRequestInfo]"))
}

GO TYPE net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
func Extract_ns_ClientTrace(args []Object, index int) *httptrace.ClientTrace {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.ClientTrace:
			return r
		case httptrace.ClientTrace:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.ClientTrace]"))
}

// func _mapToClientTrace(o Map) *httptrace.ClientTrace {
// 	return &httptrace.ClientTrace{
// 		GetConn: ABEND727(gtypes.go: func(hostPort string) not supported),
// 		GotConn: ABEND727(gtypes.go: func(GotConnInfo) not supported),
// 		PutIdleConn: ABEND727(gtypes.go: func(err error) not supported),
// 		GotFirstResponseByte: ABEND727(gtypes.go: func() not supported),
// 		Got100Continue: ABEND727(gtypes.go: func() not supported),
// 		Got1xxResponse: ABEND727(gtypes.go: func(code int,header textproto.MIMEHeader)error not supported),
// 		DNSStart: ABEND727(gtypes.go: func(DNSStartInfo) not supported),
// 		DNSDone: ABEND727(gtypes.go: func(DNSDoneInfo) not supported),
// 		ConnectStart: ABEND727(gtypes.go: func(network string,addr string) not supported),
// 		ConnectDone: ABEND727(gtypes.go: func(network string,addr string,err error) not supported),
// 		TLSHandshakeStart: ABEND727(gtypes.go: func() not supported),
// 		TLSHandshakeDone: ABEND727(gtypes.go: func(tls.ConnectionState,error) not supported),
// 		WroteHeaderField: ABEND727(gtypes.go: func(key string,value []string) not supported),
// 		WroteHeaders: ABEND727(gtypes.go: func() not supported),
// 		Wait100Continue: ABEND727(gtypes.go: func() not supported),
// 		WroteRequest: ABEND727(gtypes.go: func(WroteRequestInfo) not supported),
// 	}
// }

// func _Ctor_ClientTrace(_v Object) *httptrace.ClientTrace {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToClientTrace(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.ClientTrace] or: Map"))
// }

// func _Wrapped_Ctor_ClientTrace(_o Object) Object {
// 	return MakeGoObject(_Ctor_ClientTrace(_o))
// }

GO TYPE *net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
func Extract_ns_refToClientTrace(args []Object, index int) *httptrace.ClientTrace {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.ClientTrace:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptrace.ClientTrace]"))
}

GO TYPE net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
func Extract_ns_DNSDoneInfo(args []Object, index int) *httptrace.DNSDoneInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.DNSDoneInfo:
			return r
		case httptrace.DNSDoneInfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.DNSDoneInfo]"))
}

// func _mapToDNSDoneInfo(o Map) *httptrace.DNSDoneInfo {
// 	return &httptrace.DNSDoneInfo{
// 		Addrs: ABEND048(codegen.go: no conversion from Clojure for []net.IPAddr (net.IPAddr)),
// 		Err: FieldAsError(o, "Err"),
// 		Coalesced: FieldAsBoolean(o, "Coalesced"),
// 	}
// }

// func _Ctor_DNSDoneInfo(_v Object) *httptrace.DNSDoneInfo {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToDNSDoneInfo(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.DNSDoneInfo] or: Map"))
// }

// func _Wrapped_Ctor_DNSDoneInfo(_o Object) Object {
// 	return MakeGoObject(_Ctor_DNSDoneInfo(_o))
// }

GO TYPE *net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
func Extract_ns_refToDNSDoneInfo(args []Object, index int) *httptrace.DNSDoneInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.DNSDoneInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptrace.DNSDoneInfo]"))
}

GO TYPE net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
func Extract_ns_DNSStartInfo(args []Object, index int) *httptrace.DNSStartInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.DNSStartInfo:
			return r
		case httptrace.DNSStartInfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.DNSStartInfo]"))
}

func _mapToDNSStartInfo(o Map) *httptrace.DNSStartInfo {
	return &httptrace.DNSStartInfo{
		Host: FieldAsString(o, "Host"),
	}
}

func _Ctor_DNSStartInfo(_v Object) *httptrace.DNSStartInfo {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToDNSStartInfo(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.DNSStartInfo] or: Map"))
}

func _Wrapped_Ctor_DNSStartInfo(_o Object) Object {
	return MakeGoObject(_Ctor_DNSStartInfo(_o))
}

GO TYPE *net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
func Extract_ns_refToDNSStartInfo(args []Object, index int) *httptrace.DNSStartInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.DNSStartInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptrace.DNSStartInfo]"))
}

GO TYPE net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
func Extract_ns_GotConnInfo(args []Object, index int) *httptrace.GotConnInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.GotConnInfo:
			return r
		case httptrace.GotConnInfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.GotConnInfo]"))
}

// func _mapToGotConnInfo(o Map) *httptrace.GotConnInfo {
// 	return &httptrace.GotConnInfo{
// 		Conn: ABEND048(codegen.go: no conversion from Clojure for net.Conn (ABEND320(gtypes.go: interface{Read func(b []byte)(n int,err error),Write func(b []byte)(n int,err error),Close func()error,LocalAddr func()Addr,RemoteAddr func()Addr,SetDeadline func(t time.Time)error,SetReadDeadline func(t time.Time)error,SetWriteDeadline func(t time.Time)error} not supported))),
// 		Reused: FieldAsBoolean(o, "Reused"),
// 		WasIdle: FieldAsBoolean(o, "WasIdle"),
// 		IdleTime: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 	}
// }

// func _Ctor_GotConnInfo(_v Object) *httptrace.GotConnInfo {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToGotConnInfo(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.GotConnInfo] or: Map"))
// }

// func _Wrapped_Ctor_GotConnInfo(_o Object) Object {
// 	return MakeGoObject(_Ctor_GotConnInfo(_o))
// }

GO TYPE *net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
func Extract_ns_refToGotConnInfo(args []Object, index int) *httptrace.GotConnInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.GotConnInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptrace.GotConnInfo]"))
}

GO TYPE net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
func Extract_ns_WroteRequestInfo(args []Object, index int) *httptrace.WroteRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.WroteRequestInfo:
			return r
		case httptrace.WroteRequestInfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.WroteRequestInfo]"))
}

func _mapToWroteRequestInfo(o Map) *httptrace.WroteRequestInfo {
	return &httptrace.WroteRequestInfo{
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_WroteRequestInfo(_v Object) *httptrace.WroteRequestInfo {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToWroteRequestInfo(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.WroteRequestInfo] or: Map"))
}

func _Wrapped_Ctor_WroteRequestInfo(_o Object) Object {
	return MakeGoObject(_Ctor_WroteRequestInfo(_o))
}

GO TYPE *net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
func Extract_ns_refToWroteRequestInfo(args []Object, index int) *httptrace.WroteRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httptrace.WroteRequestInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httptrace.WroteRequestInfo]"))
}

GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func _f_contextClientTrace(_v_ctx ABEND002(reference to unavailable package `context' looking for type `Context')) Object {
// 	_res := httptrace.ContextClientTrace(_v_ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func _f_withClientTrace(_v_ctx ABEND002(reference to unavailable package `context' looking for type `Context'), _v_trace *httptrace.ClientTrace) Object {
// 	_res := httptrace.WithClientTrace(_v_ctx, _v_trace)
// 	return MakeGoObject(_res)
// }

GO VARDEF FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
var info_ClientTrace GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/refToClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
var info_PtrTo_ClientTrace GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/arrayOfClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
var info_ArrayOf_ClientTrace GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
var info_DNSDoneInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/refToDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
var info_PtrTo_DNSDoneInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/arrayOfDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
var info_ArrayOf_DNSDoneInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
var info_DNSStartInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/refToDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
var info_PtrTo_DNSStartInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/arrayOfDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
var info_ArrayOf_DNSStartInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
var info_GotConnInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/refToGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
var info_PtrTo_GotConnInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/arrayOfGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
var info_ArrayOf_GotConnInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
var info_WroteRequestInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/refToWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
var info_PtrTo_WroteRequestInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/arrayOfWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
var info_ArrayOf_WroteRequestInfo GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	info_ClientTrace = GoTypeInfo{Name: "go.std.net.http.httptrace/ClientTrace",
		GoType: &GoType{T: &info_ClientTrace},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/refToClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	info_PtrTo_ClientTrace = GoTypeInfo{Name: "go.std.net.http.httptrace/refToClientTrace",
		GoType: &GoType{T: &info_PtrTo_ClientTrace},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/arrayOfClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	info_ArrayOf_ClientTrace = GoTypeInfo{Name: "go.std.net.http.httptrace/arrayOfClientTrace",
		GoType: &GoType{T: &info_ArrayOf_ClientTrace},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	info_DNSDoneInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/DNSDoneInfo",
		GoType: &GoType{T: &info_DNSDoneInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/refToDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	info_PtrTo_DNSDoneInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/refToDNSDoneInfo",
		GoType: &GoType{T: &info_PtrTo_DNSDoneInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/arrayOfDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	info_ArrayOf_DNSDoneInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/arrayOfDNSDoneInfo",
		GoType: &GoType{T: &info_ArrayOf_DNSDoneInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	info_DNSStartInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/DNSStartInfo",
		GoType: &GoType{T: &info_DNSStartInfo},
		Ctor: _Wrapped_Ctor_DNSStartInfo,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/refToDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	info_PtrTo_DNSStartInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/refToDNSStartInfo",
		GoType: &GoType{T: &info_PtrTo_DNSStartInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/arrayOfDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	info_ArrayOf_DNSStartInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/arrayOfDNSStartInfo",
		GoType: &GoType{T: &info_ArrayOf_DNSStartInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	info_GotConnInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/GotConnInfo",
		GoType: &GoType{T: &info_GotConnInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/refToGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	info_PtrTo_GotConnInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/refToGotConnInfo",
		GoType: &GoType{T: &info_PtrTo_GotConnInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/arrayOfGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	info_ArrayOf_GotConnInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/arrayOfGotConnInfo",
		GoType: &GoType{T: &info_ArrayOf_GotConnInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	info_WroteRequestInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/WroteRequestInfo",
		GoType: &GoType{T: &info_WroteRequestInfo},
		Ctor: _Wrapped_Ctor_WroteRequestInfo,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/refToWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	info_PtrTo_WroteRequestInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/refToWroteRequestInfo",
		GoType: &GoType{T: &info_PtrTo_WroteRequestInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httptrace/arrayOfWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	info_ArrayOf_WroteRequestInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/arrayOfWroteRequestInfo",
		GoType: &GoType{T: &info_ArrayOf_WroteRequestInfo},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	GoTypesVec[222] = &info_ClientTrace

GO VECSET FOR TYPE go.std.net.http.httptrace/refToClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	GoTypesVec[49] = &info_PtrTo_ClientTrace

GO VECSET FOR TYPE go.std.net.http.httptrace/arrayOfClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	GoTypesVec[139] = &info_ArrayOf_ClientTrace

GO VECSET FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	GoTypesVec[223] = &info_DNSDoneInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/refToDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	GoTypesVec[50] = &info_PtrTo_DNSDoneInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/arrayOfDNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	GoTypesVec[140] = &info_ArrayOf_DNSDoneInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	GoTypesVec[224] = &info_DNSStartInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/refToDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	GoTypesVec[51] = &info_PtrTo_DNSStartInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/arrayOfDNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	GoTypesVec[141] = &info_ArrayOf_DNSStartInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	GoTypesVec[225] = &info_GotConnInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/refToGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	GoTypesVec[52] = &info_PtrTo_GotConnInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/arrayOfGotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	GoTypesVec[142] = &info_ArrayOf_GotConnInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	GoTypesVec[226] = &info_WroteRequestInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/refToWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	GoTypesVec[53] = &info_PtrTo_WroteRequestInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/arrayOfWroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	GoTypesVec[143] = &info_ArrayOf_WroteRequestInfo

GO ENSURE-LOADED FOR httptrace:
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:10:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:11:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:13:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:14:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:15:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:16:2

GO TYPE []net/http/httputil.ClientConn from net/http/httputil/persist.go:
func Extract_ns_arrayOfClientConn(args []Object, index int) []httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httputil.ClientConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httputil.ClientConn]"))
}

GO TYPE []net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
func Extract_ns_arrayOfReverseProxy(args []Object, index int) []httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httputil.ReverseProxy:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httputil.ReverseProxy]"))
}

GO TYPE []net/http/httputil.ServerConn from net/http/httputil/persist.go:
func Extract_ns_arrayOfServerConn(args []Object, index int) []httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []httputil.ServerConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/http/httputil.ServerConn]"))
}

GO TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
func Extract_ns_BufferPool(args []Object, index int) httputil.BufferPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case httputil.BufferPool:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.BufferPool]"))
}

GO TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
func Extract_ns_ClientConn(args []Object, index int) *httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ClientConn:
			return r
		case httputil.ClientConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ClientConn]"))
}

func _mapToClientConn(o Map) *httputil.ClientConn {
	return &httputil.ClientConn{}
}

func _Ctor_ClientConn(_v Object) *httputil.ClientConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToClientConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ClientConn] or: Map"))
}

func _Wrapped_Ctor_ClientConn(_o Object) Object {
	return MakeGoObject(_Ctor_ClientConn(_o))
}

GO TYPE *net/http/httputil.ClientConn from net/http/httputil/persist.go:
func Extract_ns_refToClientConn(args []Object, index int) *httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ClientConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httputil.ClientConn]"))
}

GO TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
func Extract_ns_ReverseProxy(args []Object, index int) *httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ReverseProxy:
			return r
		case httputil.ReverseProxy:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ReverseProxy]"))
}

// func _mapToReverseProxy(o Map) *httputil.ReverseProxy {
// 	return &httputil.ReverseProxy{
// 		Director: ABEND727(gtypes.go: func(*http.Request) not supported),
// 		Transport: ABEND048(codegen.go: no conversion from Clojure for net/http.RoundTripper (ABEND320(gtypes.go: interface{RoundTrip func(*Request)(*Response,error)} not supported))),
// 		FlushInterval: time.ABEND002(reference to unavailable package `time' looking for type `Duration'),
// 		ErrorLog: *ABEND002(reference to unavailable package `log' looking for type `Logger'),
// 		BufferPool: ABEND048(codegen.go: no conversion from Clojure for net/http/httputil.BufferPool (ABEND320(gtypes.go: interface{Get func()[]byte,Put func([]byte)} not supported))),
// 		ModifyResponse: ABEND727(gtypes.go: func(*http.Response)error not supported),
// 		ErrorHandler: ABEND727(gtypes.go: func(http.ResponseWriter,*http.Request,error) not supported),
// 	}
// }

// func _Ctor_ReverseProxy(_v Object) *httputil.ReverseProxy {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToReverseProxy(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ReverseProxy] or: Map"))
// }

// func _Wrapped_Ctor_ReverseProxy(_o Object) Object {
// 	return MakeGoObject(_Ctor_ReverseProxy(_o))
// }

GO TYPE *net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
func Extract_ns_refToReverseProxy(args []Object, index int) *httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ReverseProxy:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httputil.ReverseProxy]"))
}

GO TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
func Extract_ns_ServerConn(args []Object, index int) *httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ServerConn:
			return r
		case httputil.ServerConn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ServerConn]"))
}

func _mapToServerConn(o Map) *httputil.ServerConn {
	return &httputil.ServerConn{}
}

func _Ctor_ServerConn(_v Object) *httputil.ServerConn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToServerConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ServerConn] or: Map"))
}

func _Wrapped_Ctor_ServerConn(_o Object) Object {
	return MakeGoObject(_Ctor_ServerConn(_o))
}

GO TYPE *net/http/httputil.ServerConn from net/http/httputil/persist.go:
func Extract_ns_refToServerConn(args []Object, index int) *httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *httputil.ServerConn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/http/httputil.ServerConn]"))
}

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
func _f_dumpRequest(_v_req *http.Request, _v_body bool) Object {
	_res1, _res2 := httputil.DumpRequest(_v_req, _v_body)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
func _f_dumpRequestOut(_v_req *http.Request, _v_body bool) Object {
	_res1, _res2 := httputil.DumpRequestOut(_v_req, _v_body)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
func _f_dumpResponse(_v_resp *http.Response, _v_body bool) Object {
	_res1, _res2 := httputil.DumpResponse(_v_resp, _v_body)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func _f_newChunkedReader(_v_r ABEND002(reference to unavailable package `io' looking for type `Reader')) Object {
// 	_res := httputil.NewChunkedReader(_v_r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func _f_newChunkedWriter(_v_w ABEND002(reference to unavailable package `io' looking for type `Writer')) Object {
// 	_res := httputil.NewChunkedWriter(_v_w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func _f_newClientConn(_v_c net.Conn, _v_r *ABEND002(reference to unavailable package `bufio' looking for type `Reader')) Object {
// 	_res := httputil.NewClientConn(_v_c, _v_r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func _f_newProxyClientConn(_v_c net.Conn, _v_r *ABEND002(reference to unavailable package `bufio' looking for type `Reader')) Object {
// 	_res := httputil.NewProxyClientConn(_v_c, _v_r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func _f_newServerConn(_v_c net.Conn, _v_r *ABEND002(reference to unavailable package `bufio' looking for type `Reader')) Object {
// 	_res := httputil.NewServerConn(_v_c, _v_r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
func _f_newSingleHostReverseProxy(_v_target *url.URL) Object {
	_res := httputil.NewSingleHostReverseProxy(_v_target)
	return MakeGoObject(_res)
}

GO FUNC net/http/httputil._f_bufferPool_Get from net/http/httputil/reverseproxy.go:
func _f_bufferPool_Get(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net/http/httputil.BufferPool)Get()", args, 0, 0)
	_res := o.O.(httputil.BufferPool).Get()
	return MakeGoObject(_res)
}

GO FUNC net/http/httputil._f_bufferPool_Put from net/http/httputil/reverseproxy.go:
// func _f_bufferPool_Put(o GoObject, args Object) Object {  // Method
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Close from net/http/httputil/persist.go:
func _f_ptrTo_ClientConn_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httputil.ClientConn)Close()", args, 0, 0)
	_res := o.O.(*httputil.ClientConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Do from net/http/httputil/persist.go:
func _f_ptrTo_ClientConn_Do(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httputil.ClientConn)Do()", args, 1, 1)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_res1, _res2 := o.O.(*httputil.ClientConn).Do(_v_req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Hijack from net/http/httputil/persist.go:
// func _f_ptrTo_ClientConn_Hijack(o GoObject, args Object) Object {  // Receiver
// (c net.Conn, r *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))}

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Pending from net/http/httputil/persist.go:
func _f_ptrTo_ClientConn_Pending(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httputil.ClientConn)Pending()", args, 0, 0)
	_res := o.O.(*httputil.ClientConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Read from net/http/httputil/persist.go:
func _f_ptrTo_ClientConn_Read(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httputil.ClientConn)Read()", args, 1, 1)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	resp, err := o.O.(*httputil.ClientConn).Read(_v_req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http/httputil._f_ptrTo_ClientConn_Write from net/http/httputil/persist.go:
func _f_ptrTo_ClientConn_Write(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httputil.ClientConn)Write()", args, 1, 1)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_res := o.O.(*httputil.ClientConn).Write(_v_req)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil._f_ptrTo_ReverseProxy_ServeHTTP from net/http/httputil/reverseproxy.go:
// func _f_ptrTo_ReverseProxy_ServeHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httputil._f_ptrTo_ServerConn_Close from net/http/httputil/persist.go:
func _f_ptrTo_ServerConn_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httputil.ServerConn)Close()", args, 0, 0)
	_res := o.O.(*httputil.ServerConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil._f_ptrTo_ServerConn_Hijack from net/http/httputil/persist.go:
// func _f_ptrTo_ServerConn_Hijack(o GoObject, args Object) Object {  // Receiver
// (net.Conn, *ABEND002(reference to unavailable package `bufio' looking for type `Reader'))}

GO FUNC net/http/httputil._f_ptrTo_ServerConn_Pending from net/http/httputil/persist.go:
func _f_ptrTo_ServerConn_Pending(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httputil.ServerConn)Pending()", args, 0, 0)
	_res := o.O.(*httputil.ServerConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil._f_ptrTo_ServerConn_Read from net/http/httputil/persist.go:
func _f_ptrTo_ServerConn_Read(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*httputil.ServerConn)Read()", args, 0, 0)
	_res1, _res2 := o.O.(*httputil.ServerConn).Read()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil._f_ptrTo_ServerConn_Write from net/http/httputil/persist.go:
func _f_ptrTo_ServerConn_Write(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*httputil.ServerConn)Write()", args, 2, 2)
	_v_req := SeqNth(_argList, 0).(GoObject).O.(*http.Request)
	_v_resp := SeqNth(_argList, 1).(GoObject).O.(*http.Response)
	_res := o.O.(*httputil.ServerConn).Write(_v_req, _v_resp)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO VARDEF FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
var info_BufferPool GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
var info_ClientConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/refToClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
var info_PtrTo_ClientConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/arrayOfClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
var info_ArrayOf_ClientConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
var info_ReverseProxy GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/refToReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
var info_PtrTo_ReverseProxy GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/arrayOfReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
var info_ArrayOf_ReverseProxy GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
var info_ServerConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/refToServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
var info_PtrTo_ServerConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/arrayOfServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
var info_ArrayOf_ServerConn GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
	info_BufferPool = GoTypeInfo{Name: "go.std.net.http.httputil/BufferPool",
		GoType: &GoType{T: &info_BufferPool},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", _f_bufferPool_Get, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	info_ClientConn = GoTypeInfo{Name: "go.std.net.http.httputil/ClientConn",
		GoType: &GoType{T: &info_ClientConn},
		Ctor: _Wrapped_Ctor_ClientConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/refToClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	info_PtrTo_ClientConn = GoTypeInfo{Name: "go.std.net.http.httputil/refToClientConn",
		GoType: &GoType{T: &info_PtrTo_ClientConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_ptrTo_ClientConn_Close, "Close calls Hijack and then also closes the underlying connection.\n", "1.0", NewVectorFrom()),
			"Do": MakeGoReceiver("Do", _f_ptrTo_ClientConn_Do, "Do is convenience method that writes a request and reads a response.\n", "1.0", NewVectorFrom(MakeSymbol("req"))),
			"Pending": MakeGoReceiver("Pending", _f_ptrTo_ClientConn_Pending, "Pending returns the number of unanswered requests\nthat have been sent on the connection.\n", "1.0", NewVectorFrom()),
			"Read": MakeGoReceiver("Read", _f_ptrTo_ClientConn_Read, "Read reads the next response from the wire. A valid response might be\nreturned together with an ErrPersistEOF, which means that the remote\nrequested that this be the last request serviced. Read can be called\nconcurrently with Write, but not with another Read.\n", "1.0", NewVectorFrom(MakeSymbol("req"))),
			"Write": MakeGoReceiver("Write", _f_ptrTo_ClientConn_Write, "Write writes a request. An ErrPersistEOF error is returned if the connection\nhas been closed in an HTTP keepalive sense. If req.Close equals true, the\nkeepalive connection is logically closed after this request and the opposing\nserver is informed. An ErrUnexpectedEOF indicates the remote closed the\nunderlying TCP connection, which is usually considered as graceful close.\n", "1.0", NewVectorFrom(MakeSymbol("req"))),
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/arrayOfClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	info_ArrayOf_ClientConn = GoTypeInfo{Name: "go.std.net.http.httputil/arrayOfClientConn",
		GoType: &GoType{T: &info_ArrayOf_ClientConn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	info_ReverseProxy = GoTypeInfo{Name: "go.std.net.http.httputil/ReverseProxy",
		GoType: &GoType{T: &info_ReverseProxy},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/refToReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	info_PtrTo_ReverseProxy = GoTypeInfo{Name: "go.std.net.http.httputil/refToReverseProxy",
		GoType: &GoType{T: &info_PtrTo_ReverseProxy},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/arrayOfReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	info_ArrayOf_ReverseProxy = GoTypeInfo{Name: "go.std.net.http.httputil/arrayOfReverseProxy",
		GoType: &GoType{T: &info_ArrayOf_ReverseProxy},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	info_ServerConn = GoTypeInfo{Name: "go.std.net.http.httputil/ServerConn",
		GoType: &GoType{T: &info_ServerConn},
		Ctor: _Wrapped_Ctor_ServerConn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/refToServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	info_PtrTo_ServerConn = GoTypeInfo{Name: "go.std.net.http.httputil/refToServerConn",
		GoType: &GoType{T: &info_PtrTo_ServerConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_ptrTo_ServerConn_Close, "Close calls Hijack and then also closes the underlying connection.\n", "1.0", NewVectorFrom()),
			"Pending": MakeGoReceiver("Pending", _f_ptrTo_ServerConn_Pending, "Pending returns the number of unanswered requests\nthat have been received on the connection.\n", "1.0", NewVectorFrom()),
			"Read": MakeGoReceiver("Read", _f_ptrTo_ServerConn_Read, "Read returns the next request on the wire. An ErrPersistEOF is returned if\nit is gracefully determined that there are no more requests (e.g. after the\nfirst request on an HTTP/1.0 connection, or after a Connection:close on a\nHTTP/1.1 connection).\n", "1.0", NewVectorFrom()),
			"Write": MakeGoReceiver("Write", _f_ptrTo_ServerConn_Write, "Write writes resp in response to req. To close the connection gracefully, set the\nResponse.Close field to true. Write should be considered operational until\nit returns an error, regardless of any errors returned on the Read side.\n", "1.0", NewVectorFrom(MakeSymbol("req"), MakeSymbol("resp"))),
		},
	}


GO INFO FOR TYPE go.std.net.http.httputil/arrayOfServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	info_ArrayOf_ServerConn = GoTypeInfo{Name: "go.std.net.http.httputil/arrayOfServerConn",
		GoType: &GoType{T: &info_ArrayOf_ServerConn},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
	GoTypesVec[266] = &info_BufferPool

GO VECSET FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	GoTypesVec[227] = &info_ClientConn

GO VECSET FOR TYPE go.std.net.http.httputil/refToClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	GoTypesVec[54] = &info_PtrTo_ClientConn

GO VECSET FOR TYPE go.std.net.http.httputil/arrayOfClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	GoTypesVec[144] = &info_ArrayOf_ClientConn

GO VECSET FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	GoTypesVec[228] = &info_ReverseProxy

GO VECSET FOR TYPE go.std.net.http.httputil/refToReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	GoTypesVec[55] = &info_PtrTo_ReverseProxy

GO VECSET FOR TYPE go.std.net.http.httputil/arrayOfReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	GoTypesVec[145] = &info_ArrayOf_ReverseProxy

GO VECSET FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	GoTypesVec[229] = &info_ServerConn

GO VECSET FOR TYPE go.std.net.http.httputil/refToServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	GoTypesVec[56] = &info_PtrTo_ServerConn

GO VECSET FOR TYPE go.std.net.http.httputil/arrayOfServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	GoTypesVec[146] = &info_ArrayOf_ServerConn

GO ENSURE-LOADED FOR httputil:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:8:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:9:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/httputil/reverseproxy.go:10:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:10:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:11:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:12:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:13:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/httputil/reverseproxy.go:12:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:14:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:15:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/httputil/persist.go:13:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:16:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:17:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/httputil/persist.go:14:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:18:2

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
func _f_cmdline(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	pprof.Cmdline(_v_w, _v_r)
	return NIL
}

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func _f_handler(_v_name string) Object {
	_res := pprof.Handler(_v_name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
func _f_index(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	pprof.Index(_v_w, _v_r)
	return NIL
}

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
func _f_profile(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	pprof.Profile(_v_w, _v_r)
	return NIL
}

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
func _f_symbol(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	pprof.Symbol(_v_w, _v_r)
	return NIL
}

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
func _f_trace(_v_w http.ResponseWriter, _v_r *http.Request) Object {
	pprof.Trace(_v_w, _v_r)
	return NIL
}

GO ENSURE-LOADED FOR pprof:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:55:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:56:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:57:2
	EnsureLoaded("go.std.html.template")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:58:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:59:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:60:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:61:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:62:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:63:2
	EnsureLoaded("go.std.runtime.pprof")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:64:2
	EnsureLoaded("go.std.runtime.trace")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:65:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:66:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:67:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:68:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:69:2

GO TYPE []*net/mail.Address from net/mail/message.go:
func Extract_ns_arrayOfrefToAddress(args []Object, index int) []*mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []*mail.Address:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]*net/mail.Address]"))
}

GO TYPE []net/mail.Address from net/mail/message.go:
func Extract_ns_arrayOfAddress(args []Object, index int) []mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []mail.Address:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/mail.Address]"))
}

GO TYPE []net/mail.AddressParser from net/mail/message.go:
func Extract_ns_arrayOfAddressParser(args []Object, index int) []mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []mail.AddressParser:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/mail.AddressParser]"))
}

GO TYPE []net/mail.Header from net/mail/message.go:
func Extract_ns_arrayOfHeader(args []Object, index int) []mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []mail.Header:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/mail.Header]"))
}

GO TYPE []net/mail.Message from net/mail/message.go:
func Extract_ns_arrayOfMessage(args []Object, index int) []mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []mail.Message:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/mail.Message]"))
}

GO TYPE net/mail.Address from net/mail/message.go:
func Extract_ns_Address(args []Object, index int) *mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Address:
			return r
		case mail.Address:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *mail.Address {
	return &mail.Address{
		Name: FieldAsString(o, "Name"),
		Address: FieldAsString(o, "Address"),
	}
}

func _Ctor_Address(_v Object) *mail.Address {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or: Map"))
}

func _Wrapped_Ctor_Address(_o Object) Object {
	return MakeGoObject(_Ctor_Address(_o))
}

GO TYPE *net/mail.Address from net/mail/message.go:
func Extract_ns_refToAddress(args []Object, index int) *mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Address:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/mail.Address]"))
}

GO TYPE net/mail.AddressParser from net/mail/message.go:
func Extract_ns_AddressParser(args []Object, index int) *mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.AddressParser:
			return r
		case mail.AddressParser:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

// func _mapToAddressParser(o Map) *mail.AddressParser {
// 	return &mail.AddressParser{
// 		WordDecoder: *ABEND002(reference to unavailable package `mime' looking for type `WordDecoder'),
// 	}
// }

// func _Ctor_AddressParser(_v Object) *mail.AddressParser {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToAddressParser(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or: Map"))
// }

// func _Wrapped_Ctor_AddressParser(_o Object) Object {
// 	return MakeGoObject(_Ctor_AddressParser(_o))
// }

GO TYPE *net/mail.AddressParser from net/mail/message.go:
func Extract_ns_refToAddressParser(args []Object, index int) *mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.AddressParser:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/mail.AddressParser]"))
}

GO TYPE net/mail.Header from net/mail/message.go:
func Extract_ns_Header(args []Object, index int) *mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Header:
			return r
		case mail.Header:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _Ctor_Header(_v Object) mail.Header {
// 	switch _o := _v.(type) {
// 	default:
// 		return _mail.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or: whatever"))
// }

// func _Wrapped_Ctor_Header(_o Object) Object {
// 	return MakeGoObject(_Ctor_Header(_o))
// }

GO TYPE *net/mail.Header from net/mail/message.go:
func Extract_ns_refToHeader(args []Object, index int) *mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Header:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/mail.Header]"))
}

GO TYPE net/mail.Message from net/mail/message.go:
func Extract_ns_Message(args []Object, index int) *mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Message:
			return r
		case mail.Message:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

// func _mapToMessage(o Map) *mail.Message {
// 	return &mail.Message{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/mail.Header (map[string][]string)),
// 		Body: io.ABEND002(reference to unavailable package `io' looking for type `Reader'),
// 	}
// }

// func _Ctor_Message(_v Object) *mail.Message {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToMessage(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or: Map"))
// }

// func _Wrapped_Ctor_Message(_o Object) Object {
// 	return MakeGoObject(_Ctor_Message(_o))
// }

GO TYPE *net/mail.Message from net/mail/message.go:
func Extract_ns_refToMessage(args []Object, index int) *mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *mail.Message:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/mail.Message]"))
}

GO FUNC net/mail.ParseAddress from net/mail/message.go:
func _f_parseAddress(_v_address string) Object {
	_res1, _res2 := mail.ParseAddress(_v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func _f_parseAddressList(_v_list string) Object {
	_res1, _res2 := mail.ParseAddressList(_v_list)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
// func _f_parseDate(_v_date string) Object {
// 	_res1, _res2 := mail.ParseDate(_v_date)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func _f_readMessage(_v_r ABEND002(reference to unavailable package `io' looking for type `Reader')) Object {
// 	msg, err := mail.ReadMessage(_v_r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/mail._f_header_AddressList from net/mail/message.go:
func _f_header_AddressList(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(mail.Header)AddressList()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res1, _res2 := o.O.(mail.Header).AddressList(_v_key)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail._f_header_Date from net/mail/message.go:
// func _f_header_Date(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `time' looking for type `Time'), error)}

GO FUNC net/mail._f_header_Get from net/mail/message.go:
func _f_header_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(mail.Header)Get()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(mail.Header).Get(_v_key)
	return MakeString(_res)
}

GO FUNC net/mail._f_ptrTo_AddressParser_Parse from net/mail/message.go:
func _f_ptrTo_AddressParser_Parse(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*mail.AddressParser)Parse()", args, 1, 1)
	_v_address := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_address): %s")
	_res1, _res2 := o.O.(*mail.AddressParser).Parse(_v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail._f_ptrTo_AddressParser_ParseList from net/mail/message.go:
func _f_ptrTo_AddressParser_ParseList(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*mail.AddressParser)ParseList()", args, 1, 1)
	_v_list := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_list): %s")
	_res1, _res2 := o.O.(*mail.AddressParser).ParseList(_v_list)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail._f_ptrTo_Address_String from net/mail/message.go:
func _f_ptrTo_Address_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*mail.Address)String()", args, 0, 0)
	_res := o.O.(*mail.Address).String()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
var info_Address GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/refToAddress from _tests/big/src/net/mail/message.go:141:6:
var info_PtrTo_Address GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
var info_AddressParser GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/refToAddressParser from _tests/big/src/net/mail/message.go:157:6:
var info_PtrTo_AddressParser GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/arrayOfAddressParser from _tests/big/src/net/mail/message.go:157:6:
var info_ArrayOf_AddressParser GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/arrayOfAddress from _tests/big/src/net/mail/message.go:141:6:
var info_ArrayOf_Address GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
var info_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/refToHeader from _tests/big/src/net/mail/message.go:106:6:
var info_PtrTo_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/arrayOfHeader from _tests/big/src/net/mail/message.go:106:6:
var info_ArrayOf_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
var info_Message GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/refToMessage from _tests/big/src/net/mail/message.go:44:6:
var info_PtrTo_Message GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/arrayOfMessage from _tests/big/src/net/mail/message.go:44:6:
var info_ArrayOf_Message GoTypeInfo

GO INFO FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
	info_Address = GoTypeInfo{Name: "go.std.net.mail/Address",
		GoType: &GoType{T: &info_Address},
		Ctor: _Wrapped_Ctor_Address,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/refToAddress from _tests/big/src/net/mail/message.go:141:6:
	info_PtrTo_Address = GoTypeInfo{Name: "go.std.net.mail/refToAddress",
		GoType: &GoType{T: &info_PtrTo_Address},
		Members: GoMembers{
			"String": MakeGoReceiver("String", _f_ptrTo_Address_String, "String formats the address as a valid RFC 5322 address.\nIf the address's name contains non-ASCII characters\nthe name will be rendered according to RFC 2047.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
	info_AddressParser = GoTypeInfo{Name: "go.std.net.mail/AddressParser",
		GoType: &GoType{T: &info_AddressParser},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/refToAddressParser from _tests/big/src/net/mail/message.go:157:6:
	info_PtrTo_AddressParser = GoTypeInfo{Name: "go.std.net.mail/refToAddressParser",
		GoType: &GoType{T: &info_PtrTo_AddressParser},
		Members: GoMembers{
			"Parse": MakeGoReceiver("Parse", _f_ptrTo_AddressParser_Parse, "Parse parses a single RFC 5322 address of the\nform \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".\n", "1.0", NewVectorFrom(MakeSymbol("address"))),
			"ParseList": MakeGoReceiver("ParseList", _f_ptrTo_AddressParser_ParseList, "ParseList parses the given string as a list of comma-separated addresses\nof the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".\n", "1.0", NewVectorFrom(MakeSymbol("list"))),
		},
	}


GO INFO FOR TYPE go.std.net.mail/arrayOfAddressParser from _tests/big/src/net/mail/message.go:157:6:
	info_ArrayOf_AddressParser = GoTypeInfo{Name: "go.std.net.mail/arrayOfAddressParser",
		GoType: &GoType{T: &info_ArrayOf_AddressParser},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/arrayOfAddress from _tests/big/src/net/mail/message.go:141:6:
	info_ArrayOf_Address = GoTypeInfo{Name: "go.std.net.mail/arrayOfAddress",
		GoType: &GoType{T: &info_ArrayOf_Address},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
	info_Header = GoTypeInfo{Name: "go.std.net.mail/Header",
		GoType: &GoType{T: &info_Header},
		Members: GoMembers{
			"AddressList": MakeGoReceiver("AddressList", _f_header_AddressList, "AddressList parses the named header field as a list of addresses.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"Get": MakeGoReceiver("Get", _f_header_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		},
	}


GO INFO FOR TYPE go.std.net.mail/refToHeader from _tests/big/src/net/mail/message.go:106:6:
	info_PtrTo_Header = GoTypeInfo{Name: "go.std.net.mail/refToHeader",
		GoType: &GoType{T: &info_PtrTo_Header},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/arrayOfHeader from _tests/big/src/net/mail/message.go:106:6:
	info_ArrayOf_Header = GoTypeInfo{Name: "go.std.net.mail/arrayOfHeader",
		GoType: &GoType{T: &info_ArrayOf_Header},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
	info_Message = GoTypeInfo{Name: "go.std.net.mail/Message",
		GoType: &GoType{T: &info_Message},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/refToMessage from _tests/big/src/net/mail/message.go:44:6:
	info_PtrTo_Message = GoTypeInfo{Name: "go.std.net.mail/refToMessage",
		GoType: &GoType{T: &info_PtrTo_Message},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.mail/arrayOfMessage from _tests/big/src/net/mail/message.go:44:6:
	info_ArrayOf_Message = GoTypeInfo{Name: "go.std.net.mail/arrayOfMessage",
		GoType: &GoType{T: &info_ArrayOf_Message},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
	GoTypesVec[230] = &info_Address

GO VECSET FOR TYPE go.std.net.mail/refToAddress from _tests/big/src/net/mail/message.go:141:6:
	GoTypesVec[57] = &info_PtrTo_Address

GO VECSET FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
	GoTypesVec[231] = &info_AddressParser

GO VECSET FOR TYPE go.std.net.mail/refToAddressParser from _tests/big/src/net/mail/message.go:157:6:
	GoTypesVec[58] = &info_PtrTo_AddressParser

GO VECSET FOR TYPE go.std.net.mail/arrayOfAddressParser from _tests/big/src/net/mail/message.go:157:6:
	GoTypesVec[148] = &info_ArrayOf_AddressParser

GO VECSET FOR TYPE go.std.net.mail/arrayOfAddress from _tests/big/src/net/mail/message.go:141:6:
	GoTypesVec[147] = &info_ArrayOf_Address

GO VECSET FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
	GoTypesVec[232] = &info_Header

GO VECSET FOR TYPE go.std.net.mail/refToHeader from _tests/big/src/net/mail/message.go:106:6:
	GoTypesVec[59] = &info_PtrTo_Header

GO VECSET FOR TYPE go.std.net.mail/arrayOfHeader from _tests/big/src/net/mail/message.go:106:6:
	GoTypesVec[149] = &info_ArrayOf_Header

GO VECSET FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
	GoTypesVec[233] = &info_Message

GO VECSET FOR TYPE go.std.net.mail/refToMessage from _tests/big/src/net/mail/message.go:44:6:
	GoTypesVec[60] = &info_PtrTo_Message

GO VECSET FOR TYPE go.std.net.mail/arrayOfMessage from _tests/big/src/net/mail/message.go:44:6:
	GoTypesVec[150] = &info_ArrayOf_Message

GO ENSURE-LOADED FOR mail:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/mail/message.go:21:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/mail/message.go:22:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/mail/message.go:23:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/mail/message.go:24:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/mail/message.go:25:2
	EnsureLoaded("go.std.mime")  // E.g. from: _tests/big/src/net/mail/message.go:26:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/mail/message.go:27:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/mail/message.go:28:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/mail/message.go:29:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/mail/message.go:30:2

GO TYPE []net/rpc.Call from net/rpc/client.go:
func Extract_ns_arrayOfCall(args []Object, index int) []rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.Call:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.Call]"))
}

GO TYPE []net/rpc.Client from net/rpc/client.go:
func Extract_ns_arrayOfClient(args []Object, index int) []rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.Client]"))
}

GO TYPE []net/rpc.Request from net/rpc/server.go:
func Extract_ns_arrayOfRequest(args []Object, index int) []rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.Request:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.Request]"))
}

GO TYPE []net/rpc.Response from net/rpc/server.go:
func Extract_ns_arrayOfResponse(args []Object, index int) []rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.Response:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.Response]"))
}

GO TYPE []net/rpc.Server from net/rpc/server.go:
func Extract_ns_arrayOfServer(args []Object, index int) []rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.Server]"))
}

GO TYPE []net/rpc.ServerError from net/rpc/client.go:
func Extract_ns_arrayOfServerError(args []Object, index int) []rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []rpc.ServerError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/rpc.ServerError]"))
}

GO TYPE net/rpc.Call from net/rpc/client.go:
func Extract_ns_Call(args []Object, index int) *rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Call:
			return r
		case rpc.Call:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

// func _mapToCall(o Map) *rpc.Call {
// 	return &rpc.Call{
// 		ServiceMethod: FieldAsString(o, "ServiceMethod"),
// 		Args: ABEND049(codegen.go: no conversion to private type interface{} (-)),
// 		Reply: ABEND049(codegen.go: no conversion to private type interface{} (-)),
// 		Error: FieldAsError(o, "Error"),
// 		Done: ABEND737(gtypes.go: chan *Call not supported),
// 	}
// }

// func _Ctor_Call(_v Object) *rpc.Call {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToCall(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or: Map"))
// }

// func _Wrapped_Ctor_Call(_o Object) Object {
// 	return MakeGoObject(_Ctor_Call(_o))
// }

GO TYPE *net/rpc.Call from net/rpc/client.go:
func Extract_ns_refToCall(args []Object, index int) *rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Call:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.Call]"))
}

GO TYPE net/rpc.Client from net/rpc/client.go:
func Extract_ns_Client(args []Object, index int) *rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Client:
			return r
		case rpc.Client:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *rpc.Client {
	return &rpc.Client{}
}

func _Ctor_Client(_v Object) *rpc.Client {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or: Map"))
}

func _Wrapped_Ctor_Client(_o Object) Object {
	return MakeGoObject(_Ctor_Client(_o))
}

GO TYPE *net/rpc.Client from net/rpc/client.go:
func Extract_ns_refToClient(args []Object, index int) *rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.Client]"))
}

GO TYPE net/rpc.ClientCodec from net/rpc/client.go:
func Extract_ns_ClientCodec(args []Object, index int) rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case rpc.ClientCodec:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

GO TYPE net/rpc.Request from net/rpc/server.go:
func Extract_ns_Request(args []Object, index int) *rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Request:
			return r
		case rpc.Request:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *rpc.Request {
	return &rpc.Request{
		ServiceMethod: FieldAsString(o, "ServiceMethod"),
		Seq: FieldAsUint64(o, "Seq"),
	}
}

func _Ctor_Request(_v Object) *rpc.Request {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or: Map"))
}

func _Wrapped_Ctor_Request(_o Object) Object {
	return MakeGoObject(_Ctor_Request(_o))
}

GO TYPE *net/rpc.Request from net/rpc/server.go:
func Extract_ns_refToRequest(args []Object, index int) *rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Request:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.Request]"))
}

GO TYPE net/rpc.Response from net/rpc/server.go:
func Extract_ns_Response(args []Object, index int) *rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Response:
			return r
		case rpc.Response:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *rpc.Response {
	return &rpc.Response{
		ServiceMethod: FieldAsString(o, "ServiceMethod"),
		Seq: FieldAsUint64(o, "Seq"),
		Error: FieldAsString(o, "Error"),
	}
}

func _Ctor_Response(_v Object) *rpc.Response {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or: Map"))
}

func _Wrapped_Ctor_Response(_o Object) Object {
	return MakeGoObject(_Ctor_Response(_o))
}

GO TYPE *net/rpc.Response from net/rpc/server.go:
func Extract_ns_refToResponse(args []Object, index int) *rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Response:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.Response]"))
}

GO TYPE net/rpc.Server from net/rpc/server.go:
func Extract_ns_Server(args []Object, index int) *rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Server:
			return r
		case rpc.Server:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *rpc.Server {
	return &rpc.Server{}
}

func _Ctor_Server(_v Object) *rpc.Server {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or: Map"))
}

func _Wrapped_Ctor_Server(_o Object) Object {
	return MakeGoObject(_Ctor_Server(_o))
}

GO TYPE *net/rpc.Server from net/rpc/server.go:
func Extract_ns_refToServer(args []Object, index int) *rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.Server:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.Server]"))
}

GO TYPE net/rpc.ServerCodec from net/rpc/server.go:
func Extract_ns_ServerCodec(args []Object, index int) rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case rpc.ServerCodec:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

GO TYPE net/rpc.ServerError from net/rpc/client.go:
func Extract_ns_ServerError(args []Object, index int) *rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.ServerError:
			return r
		case rpc.ServerError:
			return &r  // refTo
		}
	case String:
		v := rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _Ctor_ServerError(_v Object) rpc.ServerError {
	switch _o := _v.(type) {
	case String:
		return rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or: String"))
}

func _Wrapped_Ctor_ServerError(_o Object) Object {
	return MakeGoObject(_Ctor_ServerError(_o))
}

GO TYPE *net/rpc.ServerError from net/rpc/client.go:
func Extract_ns_refToServerError(args []Object, index int) *rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *rpc.ServerError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/rpc.ServerError]"))
}

GO FUNC net/rpc.Accept from net/rpc/server.go:
func _f_accept(_v_lis net.Listener) Object {
	rpc.Accept(_v_lis)
	return NIL
}

GO FUNC net/rpc.Dial from net/rpc/client.go:
func _f_dial(_v_network string, _v_address string) Object {
	_res1, _res2 := rpc.Dial(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func _f_dialHTTP(_v_network string, _v_address string) Object {
	_res1, _res2 := rpc.DialHTTP(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func _f_dialHTTPPath(_v_network string, _v_address string, _v_path string) Object {
	_res1, _res2 := rpc.DialHTTPPath(_v_network, _v_address, _v_path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
func _f_handleHTTP() Object {
	rpc.HandleHTTP()
	return NIL
}

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func _f_newClient(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	_res := rpc.NewClient(_v_conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func _f_newClientWithCodec(_v_codec rpc.ClientCodec) Object {
	_res := rpc.NewClientWithCodec(_v_codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func _f_newServer() Object {
	_res := rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
func _f_serveCodec(_v_codec rpc.ServerCodec) Object {
	rpc.ServeCodec(_v_codec)
	return NIL
}

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func _f_serveConn(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	rpc.ServeConn(_v_conn)
// 	return NIL
// }

GO FUNC net/rpc._f_clientCodec_Close from net/rpc/client.go:
func _f_clientCodec_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net/rpc.ClientCodec)Close()", args, 0, 0)
	_res := o.O.(rpc.ClientCodec).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_clientCodec_ReadResponseBody from net/rpc/client.go:
func _f_clientCodec_ReadResponseBody(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ClientCodec)ReadResponseBody()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(interface{})
	_res := o.O.(rpc.ClientCodec).ReadResponseBody(__arg1)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_clientCodec_ReadResponseHeader from net/rpc/client.go:
func _f_clientCodec_ReadResponseHeader(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ClientCodec)ReadResponseHeader()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(*rpc.Response)
	_res := o.O.(rpc.ClientCodec).ReadResponseHeader(__arg1)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_clientCodec_WriteRequest from net/rpc/client.go:
func _f_clientCodec_WriteRequest(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ClientCodec)WriteRequest()", args, 2, 2)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(*rpc.Request)
	__arg2 := SeqNth(_argList, 1).(GoObject).O.(interface{})
	_res := o.O.(rpc.ClientCodec).WriteRequest(__arg1, __arg2)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_ptrTo_Client_Call from net/rpc/client.go:
func _f_ptrTo_Client_Call(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*rpc.Client)Call()", args, 3, 3)
	_v_serviceMethod := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_serviceMethod): %s")
	_v_args := SeqNth(_argList, 1).(GoObject).O.(interface{})
	_v_reply := SeqNth(_argList, 2).(GoObject).O.(interface{})
	_res := o.O.(*rpc.Client).Call(_v_serviceMethod, _v_args, _v_reply)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_ptrTo_Client_Close from net/rpc/client.go:
func _f_ptrTo_Client_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*rpc.Client)Close()", args, 0, 0)
	_res := o.O.(*rpc.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_ptrTo_Client_Go from net/rpc/client.go:
// func _f_ptrTo_Client_Go(o GoObject, args Object) Object {  // Receiver
// (serviceMethod string, args interface{}, reply interface{}, done ABEND737(gtypes.go: chan *Call not supported))}

GO FUNC net/rpc._f_ptrTo_Server_Accept from net/rpc/server.go:
// func _f_ptrTo_Server_Accept(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc._f_ptrTo_Server_HandleHTTP from net/rpc/server.go:
// func _f_ptrTo_Server_HandleHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc._f_ptrTo_Server_Register from net/rpc/server.go:
func _f_ptrTo_Server_Register(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*rpc.Server)Register()", args, 1, 1)
	_v_rcvr := SeqNth(_argList, 0).(GoObject).O.(interface{})
	_res := o.O.(*rpc.Server).Register(_v_rcvr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_ptrTo_Server_RegisterName from net/rpc/server.go:
func _f_ptrTo_Server_RegisterName(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*rpc.Server)RegisterName()", args, 2, 2)
	_v_name := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_name): %s")
	_v_rcvr := SeqNth(_argList, 1).(GoObject).O.(interface{})
	_res := o.O.(*rpc.Server).RegisterName(_v_name, _v_rcvr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_ptrTo_Server_ServeCodec from net/rpc/server.go:
// func _f_ptrTo_Server_ServeCodec(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc._f_ptrTo_Server_ServeConn from net/rpc/server.go:
// func _f_ptrTo_Server_ServeConn(o GoObject, args Object) Object {  // Receiver
// (conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser'))}

GO FUNC net/rpc._f_ptrTo_Server_ServeHTTP from net/rpc/server.go:
// func _f_ptrTo_Server_ServeHTTP(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc._f_ptrTo_Server_ServeRequest from net/rpc/server.go:
func _f_ptrTo_Server_ServeRequest(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*rpc.Server)ServeRequest()", args, 1, 1)
	_v_codec := SeqNth(_argList, 0).(GoObject).O.(rpc.ServerCodec)
	_res := o.O.(*rpc.Server).ServeRequest(_v_codec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_serverCodec_Close from net/rpc/server.go:
func _f_serverCodec_Close(o GoObject, args Object) Object {  // Method
	CheckReceiverArity("(net/rpc.ServerCodec)Close()", args, 0, 0)
	_res := o.O.(rpc.ServerCodec).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_serverCodec_ReadRequestBody from net/rpc/server.go:
func _f_serverCodec_ReadRequestBody(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ServerCodec)ReadRequestBody()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(interface{})
	_res := o.O.(rpc.ServerCodec).ReadRequestBody(__arg1)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_serverCodec_ReadRequestHeader from net/rpc/server.go:
func _f_serverCodec_ReadRequestHeader(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ServerCodec)ReadRequestHeader()", args, 1, 1)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(*rpc.Request)
	_res := o.O.(rpc.ServerCodec).ReadRequestHeader(__arg1)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_serverCodec_WriteResponse from net/rpc/server.go:
func _f_serverCodec_WriteResponse(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/rpc.ServerCodec)WriteResponse()", args, 2, 2)
	__arg1 := SeqNth(_argList, 0).(GoObject).O.(*rpc.Response)
	__arg2 := SeqNth(_argList, 1).(GoObject).O.(interface{})
	_res := o.O.(rpc.ServerCodec).WriteResponse(__arg1, __arg2)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc._f_serverError_Error from net/rpc/client.go:
func _f_serverError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(rpc.ServerError)Error()", args, 0, 0)
	_res := o.O.(rpc.ServerError).Error()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
var info_Call GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToCall from _tests/big/src/net/rpc/client.go:29:6:
var info_PtrTo_Call GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfCall from _tests/big/src/net/rpc/client.go:29:6:
var info_ArrayOf_Call GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToClient from _tests/big/src/net/rpc/client.go:41:6:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
var info_ClientCodec GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfClient from _tests/big/src/net/rpc/client.go:41:6:
var info_ArrayOf_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
var info_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToRequest from _tests/big/src/net/rpc/server.go:172:6:
var info_PtrTo_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfRequest from _tests/big/src/net/rpc/server.go:172:6:
var info_ArrayOf_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
var info_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToResponse from _tests/big/src/net/rpc/server.go:181:6:
var info_PtrTo_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfResponse from _tests/big/src/net/rpc/server.go:181:6:
var info_ArrayOf_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToServer from _tests/big/src/net/rpc/server.go:189:6:
var info_PtrTo_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
var info_ServerCodec GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
var info_ServerError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/refToServerError from _tests/big/src/net/rpc/client.go:20:6:
var info_PtrTo_ServerError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfServerError from _tests/big/src/net/rpc/client.go:20:6:
var info_ArrayOf_ServerError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/arrayOfServer from _tests/big/src/net/rpc/server.go:189:6:
var info_ArrayOf_Server GoTypeInfo

GO INFO FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
	info_Call = GoTypeInfo{Name: "go.std.net.rpc/Call",
		GoType: &GoType{T: &info_Call},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToCall from _tests/big/src/net/rpc/client.go:29:6:
	info_PtrTo_Call = GoTypeInfo{Name: "go.std.net.rpc/refToCall",
		GoType: &GoType{T: &info_PtrTo_Call},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfCall from _tests/big/src/net/rpc/client.go:29:6:
	info_ArrayOf_Call = GoTypeInfo{Name: "go.std.net.rpc/arrayOfCall",
		GoType: &GoType{T: &info_ArrayOf_Call},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
	info_Client = GoTypeInfo{Name: "go.std.net.rpc/Client",
		GoType: &GoType{T: &info_Client},
		Ctor: _Wrapped_Ctor_Client,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToClient from _tests/big/src/net/rpc/client.go:41:6:
	info_PtrTo_Client = GoTypeInfo{Name: "go.std.net.rpc/refToClient",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Call": MakeGoReceiver("Call", _f_ptrTo_Client_Call, "Call invokes the named function, waits for it to complete, and returns its error status.\n", "1.0", NewVectorFrom(MakeSymbol("serviceMethod"), MakeSymbol("args"), MakeSymbol("reply"))),
			"Close": MakeGoReceiver("Close", _f_ptrTo_Client_Close, "Close calls the underlying codec's Close method. If the connection is already\nshutting down, ErrShutdown is returned.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
	info_ClientCodec = GoTypeInfo{Name: "go.std.net.rpc/ClientCodec",
		GoType: &GoType{T: &info_ClientCodec},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_clientCodec_Close, "", "1.0", NewVectorFrom()),
			"ReadResponseBody": MakeGoReceiver("ReadResponseBody", _f_clientCodec_ReadResponseBody, "", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
			"ReadResponseHeader": MakeGoReceiver("ReadResponseHeader", _f_clientCodec_ReadResponseHeader, "", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
			"WriteRequest": MakeGoReceiver("WriteRequest", _f_clientCodec_WriteRequest, "", "1.0", NewVectorFrom(MakeSymbol("arg1"), MakeSymbol("arg2"))),
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfClient from _tests/big/src/net/rpc/client.go:41:6:
	info_ArrayOf_Client = GoTypeInfo{Name: "go.std.net.rpc/arrayOfClient",
		GoType: &GoType{T: &info_ArrayOf_Client},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
	info_Request = GoTypeInfo{Name: "go.std.net.rpc/Request",
		GoType: &GoType{T: &info_Request},
		Ctor: _Wrapped_Ctor_Request,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToRequest from _tests/big/src/net/rpc/server.go:172:6:
	info_PtrTo_Request = GoTypeInfo{Name: "go.std.net.rpc/refToRequest",
		GoType: &GoType{T: &info_PtrTo_Request},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfRequest from _tests/big/src/net/rpc/server.go:172:6:
	info_ArrayOf_Request = GoTypeInfo{Name: "go.std.net.rpc/arrayOfRequest",
		GoType: &GoType{T: &info_ArrayOf_Request},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
	info_Response = GoTypeInfo{Name: "go.std.net.rpc/Response",
		GoType: &GoType{T: &info_Response},
		Ctor: _Wrapped_Ctor_Response,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToResponse from _tests/big/src/net/rpc/server.go:181:6:
	info_PtrTo_Response = GoTypeInfo{Name: "go.std.net.rpc/refToResponse",
		GoType: &GoType{T: &info_PtrTo_Response},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfResponse from _tests/big/src/net/rpc/server.go:181:6:
	info_ArrayOf_Response = GoTypeInfo{Name: "go.std.net.rpc/arrayOfResponse",
		GoType: &GoType{T: &info_ArrayOf_Response},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
	info_Server = GoTypeInfo{Name: "go.std.net.rpc/Server",
		GoType: &GoType{T: &info_Server},
		Ctor: _Wrapped_Ctor_Server,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToServer from _tests/big/src/net/rpc/server.go:189:6:
	info_PtrTo_Server = GoTypeInfo{Name: "go.std.net.rpc/refToServer",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"Register": MakeGoReceiver("Register", _f_ptrTo_Server_Register, "Register publishes in the server the set of methods of the\nreceiver value that satisfy the following conditions:\n\t- exported method of exported type\n\t- two arguments, both of exported type\n\t- the second argument is a pointer\n\t- one return value, of type error\nIt returns an error if the receiver is not an exported type or has\nno suitable methods. It also logs the error using package log.\nThe client accesses each method using a string of the form \"Type.Method\",\nwhere Type is the receiver's concrete type.\n", "1.0", NewVectorFrom(MakeSymbol("rcvr"))),
			"RegisterName": MakeGoReceiver("RegisterName", _f_ptrTo_Server_RegisterName, "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n", "1.0", NewVectorFrom(MakeSymbol("name"), MakeSymbol("rcvr"))),
			"ServeRequest": MakeGoReceiver("ServeRequest", _f_ptrTo_Server_ServeRequest, "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n", "1.0", NewVectorFrom(MakeSymbol("codec"))),
		},
	}


GO INFO FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
	info_ServerCodec = GoTypeInfo{Name: "go.std.net.rpc/ServerCodec",
		GoType: &GoType{T: &info_ServerCodec},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_serverCodec_Close, "Close can be called multiple times and must be idempotent.\n", "1.0", NewVectorFrom()),
			"ReadRequestBody": MakeGoReceiver("ReadRequestBody", _f_serverCodec_ReadRequestBody, "", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
			"ReadRequestHeader": MakeGoReceiver("ReadRequestHeader", _f_serverCodec_ReadRequestHeader, "", "1.0", NewVectorFrom(MakeSymbol("arg1"))),
			"WriteResponse": MakeGoReceiver("WriteResponse", _f_serverCodec_WriteResponse, "", "1.0", NewVectorFrom(MakeSymbol("arg1"), MakeSymbol("arg2"))),
		},
	}


GO INFO FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
	info_ServerError = GoTypeInfo{Name: "go.std.net.rpc/ServerError",
		GoType: &GoType{T: &info_ServerError},
		Ctor: _Wrapped_Ctor_ServerError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_serverError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.rpc/refToServerError from _tests/big/src/net/rpc/client.go:20:6:
	info_PtrTo_ServerError = GoTypeInfo{Name: "go.std.net.rpc/refToServerError",
		GoType: &GoType{T: &info_PtrTo_ServerError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfServerError from _tests/big/src/net/rpc/client.go:20:6:
	info_ArrayOf_ServerError = GoTypeInfo{Name: "go.std.net.rpc/arrayOfServerError",
		GoType: &GoType{T: &info_ArrayOf_ServerError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.rpc/arrayOfServer from _tests/big/src/net/rpc/server.go:189:6:
	info_ArrayOf_Server = GoTypeInfo{Name: "go.std.net.rpc/arrayOfServer",
		GoType: &GoType{T: &info_ArrayOf_Server},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
	GoTypesVec[234] = &info_Call

GO VECSET FOR TYPE go.std.net.rpc/refToCall from _tests/big/src/net/rpc/client.go:29:6:
	GoTypesVec[61] = &info_PtrTo_Call

GO VECSET FOR TYPE go.std.net.rpc/arrayOfCall from _tests/big/src/net/rpc/client.go:29:6:
	GoTypesVec[151] = &info_ArrayOf_Call

GO VECSET FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
	GoTypesVec[235] = &info_Client

GO VECSET FOR TYPE go.std.net.rpc/refToClient from _tests/big/src/net/rpc/client.go:41:6:
	GoTypesVec[62] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
	GoTypesVec[257] = &info_ClientCodec

GO VECSET FOR TYPE go.std.net.rpc/arrayOfClient from _tests/big/src/net/rpc/client.go:41:6:
	GoTypesVec[152] = &info_ArrayOf_Client

GO VECSET FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
	GoTypesVec[236] = &info_Request

GO VECSET FOR TYPE go.std.net.rpc/refToRequest from _tests/big/src/net/rpc/server.go:172:6:
	GoTypesVec[63] = &info_PtrTo_Request

GO VECSET FOR TYPE go.std.net.rpc/arrayOfRequest from _tests/big/src/net/rpc/server.go:172:6:
	GoTypesVec[153] = &info_ArrayOf_Request

GO VECSET FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
	GoTypesVec[237] = &info_Response

GO VECSET FOR TYPE go.std.net.rpc/refToResponse from _tests/big/src/net/rpc/server.go:181:6:
	GoTypesVec[64] = &info_PtrTo_Response

GO VECSET FOR TYPE go.std.net.rpc/arrayOfResponse from _tests/big/src/net/rpc/server.go:181:6:
	GoTypesVec[154] = &info_ArrayOf_Response

GO VECSET FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
	GoTypesVec[238] = &info_Server

GO VECSET FOR TYPE go.std.net.rpc/refToServer from _tests/big/src/net/rpc/server.go:189:6:
	GoTypesVec[65] = &info_PtrTo_Server

GO VECSET FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
	GoTypesVec[258] = &info_ServerCodec

GO VECSET FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
	GoTypesVec[239] = &info_ServerError

GO VECSET FOR TYPE go.std.net.rpc/refToServerError from _tests/big/src/net/rpc/client.go:20:6:
	GoTypesVec[66] = &info_PtrTo_ServerError

GO VECSET FOR TYPE go.std.net.rpc/arrayOfServerError from _tests/big/src/net/rpc/client.go:20:6:
	GoTypesVec[156] = &info_ArrayOf_ServerError

GO VECSET FOR TYPE go.std.net.rpc/arrayOfServer from _tests/big/src/net/rpc/server.go:189:6:
	GoTypesVec[155] = &info_ArrayOf_Server

GO ENSURE-LOADED FOR rpc:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/rpc/client.go:8:2
	EnsureLoaded("go.std.encoding.gob")  // E.g. from: _tests/big/src/net/rpc/client.go:9:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/rpc/client.go:10:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/rpc/debug.go:13:2
	EnsureLoaded("go.std.html.template")  // E.g. from: _tests/big/src/net/rpc/debug.go:14:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/rpc/client.go:11:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/rpc/client.go:12:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/rpc/client.go:13:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/rpc/client.go:14:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/rpc/server.go:137:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/rpc/debug.go:16:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/rpc/server.go:138:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/rpc/client.go:15:2
	EnsureLoaded("go.std.unicode")  // E.g. from: _tests/big/src/net/rpc/server.go:140:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/rpc/server.go:141:2

GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func _f_dial(_v_network string, _v_address string) Object {
	_res1, _res2 := jsonrpc.Dial(_v_network, _v_address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func _f_newClient(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	_res := jsonrpc.NewClient(_v_conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func _f_newClientCodec(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	_res := jsonrpc.NewClientCodec(_v_conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func _f_newServerCodec(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	_res := jsonrpc.NewServerCodec(_v_conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func _f_serveConn(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	jsonrpc.ServeConn(_v_conn)
// 	return NIL
// }

GO ENSURE-LOADED FOR jsonrpc:
	EnsureLoaded("go.std.encoding.json")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:11:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:12:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:13:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:14:2
	EnsureLoaded("go.std.net.rpc")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:15:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:16:2

GO TYPE []net/smtp.Client from net/smtp/smtp.go:
func Extract_ns_arrayOfClient(args []Object, index int) []smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []smtp.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/smtp.Client]"))
}

GO TYPE []net/smtp.ServerInfo from net/smtp/auth.go:
func Extract_ns_arrayOfServerInfo(args []Object, index int) []smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []smtp.ServerInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/smtp.ServerInfo]"))
}

GO TYPE net/smtp.Auth from net/smtp/auth.go:
func Extract_ns_Auth(args []Object, index int) smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case smtp.Auth:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

GO TYPE net/smtp.Client from net/smtp/smtp.go:
func Extract_ns_Client(args []Object, index int) *smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *smtp.Client:
			return r
		case smtp.Client:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

// func _mapToClient(o Map) *smtp.Client {
// 	return &smtp.Client{
// 		Text: ABEND048(codegen.go: no conversion from Clojure for *net/textproto.Conn (net/textproto.Conn)),
// 	}
// }

// func _Ctor_Client(_v Object) *smtp.Client {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or: Map"))
// }

// func _Wrapped_Ctor_Client(_o Object) Object {
// 	return MakeGoObject(_Ctor_Client(_o))
// }

GO TYPE *net/smtp.Client from net/smtp/smtp.go:
func Extract_ns_refToClient(args []Object, index int) *smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *smtp.Client:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/smtp.Client]"))
}

GO TYPE net/smtp.ServerInfo from net/smtp/auth.go:
func Extract_ns_ServerInfo(args []Object, index int) *smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *smtp.ServerInfo:
			return r
		case smtp.ServerInfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

// func _mapToServerInfo(o Map) *smtp.ServerInfo {
// 	return &smtp.ServerInfo{
// 		Name: FieldAsString(o, "Name"),
// 		TLS: FieldAsBoolean(o, "TLS"),
// 		Auth: ABEND048(codegen.go: no conversion from Clojure for []string (-)),
// 	}
// }

// func _Ctor_ServerInfo(_v Object) *smtp.ServerInfo {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToServerInfo(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or: Map"))
// }

// func _Wrapped_Ctor_ServerInfo(_o Object) Object {
// 	return MakeGoObject(_Ctor_ServerInfo(_o))
// }

GO TYPE *net/smtp.ServerInfo from net/smtp/auth.go:
func Extract_ns_refToServerInfo(args []Object, index int) *smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *smtp.ServerInfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/smtp.ServerInfo]"))
}

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func _f_cRAMMD5Auth(_v_username string, _v_secret string) Object {
	_res := smtp.CRAMMD5Auth(_v_username, _v_secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func _f_dial(_v_addr string) Object {
	_res1, _res2 := smtp.Dial(_v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
func _f_newClient(_v_conn net.Conn, _v_host string) Object {
	_res1, _res2 := smtp.NewClient(_v_conn, _v_host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func _f_plainAuth(_v_identity string, _v_username string, _v_password string, _v_host string) Object {
	_res := smtp.PlainAuth(_v_identity, _v_username, _v_password, _v_host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp._f_auth_Next from net/smtp/auth.go:
func _f_auth_Next(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/smtp.Auth)Next()", args, 2, 2)
	_v_fromServer := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_v_more := ObjectAsBoolean(SeqNth(_argList, 1), "Arg[1] (_v_more): %s")
	toServer, err := o.O.(smtp.Auth).Next(_v_fromServer, _v_more)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(toServer))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/smtp._f_auth_Start from net/smtp/auth.go:
func _f_auth_Start(o GoObject, args Object) Object {  // Method
	_argList := CheckReceiverArity("(net/smtp.Auth)Start()", args, 1, 1)
	_v_server := SeqNth(_argList, 0).(GoObject).O.(*smtp.ServerInfo)
	proto, toServer, err := o.O.(smtp.Auth).Start(_v_server)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(proto))
	_res = _res.Conjoin(MakeGoObject(toServer))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/smtp._f_ptrTo_Client_Auth from net/smtp/smtp.go:
func _f_ptrTo_Client_Auth(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Auth()", args, 1, 1)
	_v_a := SeqNth(_argList, 0).(GoObject).O.(smtp.Auth)
	_res := o.O.(*smtp.Client).Auth(_v_a)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Close from net/smtp/smtp.go:
func _f_ptrTo_Client_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*smtp.Client)Close()", args, 0, 0)
	_res := o.O.(*smtp.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Data from net/smtp/smtp.go:
// func _f_ptrTo_Client_Data(o GoObject, args Object) Object {  // Receiver
// (ABEND002(reference to unavailable package `io' looking for type `WriteCloser'), error)}

GO FUNC net/smtp._f_ptrTo_Client_Extension from net/smtp/smtp.go:
func _f_ptrTo_Client_Extension(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Extension()", args, 1, 1)
	_v_ext := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_ext): %s")
	_res1, _res2 := o.O.(*smtp.Client).Extension(_v_ext)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(MakeString(_res2))
	return _res
}

GO FUNC net/smtp._f_ptrTo_Client_Hello from net/smtp/smtp.go:
func _f_ptrTo_Client_Hello(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Hello()", args, 1, 1)
	_v_localName := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_localName): %s")
	_res := o.O.(*smtp.Client).Hello(_v_localName)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Mail from net/smtp/smtp.go:
func _f_ptrTo_Client_Mail(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Mail()", args, 1, 1)
	_v_from := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_from): %s")
	_res := o.O.(*smtp.Client).Mail(_v_from)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Noop from net/smtp/smtp.go:
func _f_ptrTo_Client_Noop(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*smtp.Client)Noop()", args, 0, 0)
	_res := o.O.(*smtp.Client).Noop()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Quit from net/smtp/smtp.go:
func _f_ptrTo_Client_Quit(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*smtp.Client)Quit()", args, 0, 0)
	_res := o.O.(*smtp.Client).Quit()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Rcpt from net/smtp/smtp.go:
func _f_ptrTo_Client_Rcpt(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Rcpt()", args, 1, 1)
	_v_to := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_to): %s")
	_res := o.O.(*smtp.Client).Rcpt(_v_to)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_Reset from net/smtp/smtp.go:
func _f_ptrTo_Client_Reset(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*smtp.Client)Reset()", args, 0, 0)
	_res := o.O.(*smtp.Client).Reset()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp._f_ptrTo_Client_StartTLS from net/smtp/smtp.go:
// func _f_ptrTo_Client_StartTLS(o GoObject, args Object) Object {  // Receiver
// (config *ABEND002(reference to unavailable package `crypto/tls' looking for type `Config'))}

GO FUNC net/smtp._f_ptrTo_Client_TLSConnectionState from net/smtp/smtp.go:
// func _f_ptrTo_Client_TLSConnectionState(o GoObject, args Object) Object {  // Receiver
// (state ABEND002(reference to unavailable package `crypto/tls' looking for type `ConnectionState'), ok bool)}

GO FUNC net/smtp._f_ptrTo_Client_Verify from net/smtp/smtp.go:
func _f_ptrTo_Client_Verify(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*smtp.Client)Verify()", args, 1, 1)
	_v_addr := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_addr): %s")
	_res := o.O.(*smtp.Client).Verify(_v_addr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO VARDEF FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
var info_Auth GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/refToClient from _tests/big/src/net/smtp/smtp.go:30:6:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/arrayOfClient from _tests/big/src/net/smtp/smtp.go:30:6:
var info_ArrayOf_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
var info_ServerInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/refToServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
var info_PtrTo_ServerInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/arrayOfServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
var info_ArrayOf_ServerInfo GoTypeInfo

GO INFO FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
	info_Auth = GoTypeInfo{Name: "go.std.net.smtp/Auth",
		GoType: &GoType{T: &info_Auth},
		Members: GoMembers{
			"Next": MakeGoReceiver("Next", _f_auth_Next, "Next continues the authentication. The server has just sent\nthe fromServer data. If more is true, the server expects a\nresponse, which Next should return as toServer; otherwise\nNext should return toServer == nil.\nIf Next returns a non-nil error, the SMTP client aborts\nthe authentication attempt and closes the connection.\n", "1.0", NewVectorFrom(MakeSymbol("fromServer"), MakeSymbol("more"))),
			"Start": MakeGoReceiver("Start", _f_auth_Start, "Start begins an authentication with a server.\nIt returns the name of the authentication protocol\nand optionally data to include in the initial AUTH message\nsent to the server. It can return proto == \"\" to indicate\nthat the authentication should be skipped.\nIf it returns a non-nil error, the SMTP client aborts\nthe authentication attempt and closes the connection.\n", "1.0", NewVectorFrom(MakeSymbol("server"))),
		},
	}


GO INFO FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
	info_Client = GoTypeInfo{Name: "go.std.net.smtp/Client",
		GoType: &GoType{T: &info_Client},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.smtp/refToClient from _tests/big/src/net/smtp/smtp.go:30:6:
	info_PtrTo_Client = GoTypeInfo{Name: "go.std.net.smtp/refToClient",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Auth": MakeGoReceiver("Auth", _f_ptrTo_Client_Auth, "Auth authenticates a client using the provided authentication mechanism.\nA failed authentication closes the connection.\nOnly servers that advertise the AUTH extension support this function.\n", "1.0", NewVectorFrom(MakeSymbol("a"))),
			"Close": MakeGoReceiver("Close", _f_ptrTo_Client_Close, "Close closes the connection.\n", "1.0", NewVectorFrom()),
			"Extension": MakeGoReceiver("Extension", _f_ptrTo_Client_Extension, "Extension reports whether an extension is support by the server.\nThe extension name is case-insensitive. If the extension is supported,\nExtension also returns a string that contains any parameters the\nserver specifies for the extension.\n", "1.0", NewVectorFrom(MakeSymbol("ext"))),
			"Hello": MakeGoReceiver("Hello", _f_ptrTo_Client_Hello, "Hello sends a HELO or EHLO to the server as the given host name.\nCalling this method is only necessary if the client needs control\nover the host name used. The client will introduce itself as \"localhost\"\nautomatically otherwise. If Hello is called, it must be called before\nany of the other methods.\n", "1.0", NewVectorFrom(MakeSymbol("localName"))),
			"Mail": MakeGoReceiver("Mail", _f_ptrTo_Client_Mail, "Mail issues a MAIL command to the server using the provided email address.\nIf the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME\nparameter.\nThis initiates a mail transaction and is followed by one or more Rcpt calls.\n", "1.0", NewVectorFrom(MakeSymbol("from"))),
			"Noop": MakeGoReceiver("Noop", _f_ptrTo_Client_Noop, "Noop sends the NOOP command to the server. It does nothing but check\nthat the connection to the server is okay.\n", "1.0", NewVectorFrom()),
			"Quit": MakeGoReceiver("Quit", _f_ptrTo_Client_Quit, "Quit sends the QUIT command and closes the connection to the server.\n", "1.0", NewVectorFrom()),
			"Rcpt": MakeGoReceiver("Rcpt", _f_ptrTo_Client_Rcpt, "Rcpt issues a RCPT command to the server using the provided email address.\nA call to Rcpt must be preceded by a call to Mail and may be followed by\na Data call or another Rcpt call.\n", "1.0", NewVectorFrom(MakeSymbol("to"))),
			"Reset": MakeGoReceiver("Reset", _f_ptrTo_Client_Reset, "Reset sends the RSET command to the server, aborting the current mail\ntransaction.\n", "1.0", NewVectorFrom()),
			"Verify": MakeGoReceiver("Verify", _f_ptrTo_Client_Verify, "Verify checks the validity of an email address on the server.\nIf Verify returns nil, the address is valid. A non-nil return\ndoes not necessarily indicate an invalid address. Many servers\nwill not verify addresses for security reasons.\n", "1.0", NewVectorFrom(MakeSymbol("addr"))),
		},
	}


GO INFO FOR TYPE go.std.net.smtp/arrayOfClient from _tests/big/src/net/smtp/smtp.go:30:6:
	info_ArrayOf_Client = GoTypeInfo{Name: "go.std.net.smtp/arrayOfClient",
		GoType: &GoType{T: &info_ArrayOf_Client},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	info_ServerInfo = GoTypeInfo{Name: "go.std.net.smtp/ServerInfo",
		GoType: &GoType{T: &info_ServerInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.smtp/refToServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	info_PtrTo_ServerInfo = GoTypeInfo{Name: "go.std.net.smtp/refToServerInfo",
		GoType: &GoType{T: &info_PtrTo_ServerInfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.smtp/arrayOfServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	info_ArrayOf_ServerInfo = GoTypeInfo{Name: "go.std.net.smtp/arrayOfServerInfo",
		GoType: &GoType{T: &info_ArrayOf_ServerInfo},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
	GoTypesVec[267] = &info_Auth

GO VECSET FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
	GoTypesVec[240] = &info_Client

GO VECSET FOR TYPE go.std.net.smtp/refToClient from _tests/big/src/net/smtp/smtp.go:30:6:
	GoTypesVec[67] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.smtp/arrayOfClient from _tests/big/src/net/smtp/smtp.go:30:6:
	GoTypesVec[157] = &info_ArrayOf_Client

GO VECSET FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	GoTypesVec[241] = &info_ServerInfo

GO VECSET FOR TYPE go.std.net.smtp/refToServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	GoTypesVec[68] = &info_PtrTo_ServerInfo

GO VECSET FOR TYPE go.std.net.smtp/arrayOfServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	GoTypesVec[158] = &info_ArrayOf_ServerInfo

GO ENSURE-LOADED FOR smtp:
	EnsureLoaded("go.std.crypto.hmac")  // E.g. from: _tests/big/src/net/smtp/auth.go:8:2
	EnsureLoaded("go.std.crypto.md5")  // E.g. from: _tests/big/src/net/smtp/auth.go:9:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/smtp/smtp.go:19:2
	EnsureLoaded("go.std.encoding.base64")  // E.g. from: _tests/big/src/net/smtp/smtp.go:20:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/smtp/auth.go:10:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/smtp/auth.go:11:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/smtp/smtp.go:23:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/smtp/smtp.go:24:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/smtp/smtp.go:25:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/smtp/smtp.go:26:2

GO TYPE []net/textproto.Conn from net/textproto/textproto.go:
func Extract_ns_arrayOfConn(args []Object, index int) []textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.Conn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.Conn]"))
}

GO TYPE []net/textproto.Error from net/textproto/textproto.go:
func Extract_ns_arrayOfError(args []Object, index int) []textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.Error]"))
}

GO TYPE []net/textproto.MIMEHeader from net/textproto/header.go:
func Extract_ns_arrayOfMIMEHeader(args []Object, index int) []textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.MIMEHeader:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.MIMEHeader]"))
}

GO TYPE []net/textproto.Pipeline from net/textproto/pipeline.go:
func Extract_ns_arrayOfPipeline(args []Object, index int) []textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.Pipeline:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.Pipeline]"))
}

GO TYPE []net/textproto.ProtocolError from net/textproto/textproto.go:
func Extract_ns_arrayOfProtocolError(args []Object, index int) []textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.ProtocolError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.ProtocolError]"))
}

GO TYPE []net/textproto.Reader from net/textproto/reader.go:
func Extract_ns_arrayOfReader(args []Object, index int) []textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.Reader:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.Reader]"))
}

GO TYPE []net/textproto.Writer from net/textproto/writer.go:
func Extract_ns_arrayOfWriter(args []Object, index int) []textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []textproto.Writer:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/textproto.Writer]"))
}

GO TYPE net/textproto.Conn from net/textproto/textproto.go:
func Extract_ns_Conn(args []Object, index int) *textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Conn:
			return r
		case textproto.Conn:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *textproto.Conn {
	return &textproto.Conn{}
}

func _Ctor_Conn(_v Object) *textproto.Conn {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or: Map"))
}

func _Wrapped_Ctor_Conn(_o Object) Object {
	return MakeGoObject(_Ctor_Conn(_o))
}

GO TYPE *net/textproto.Conn from net/textproto/textproto.go:
func Extract_ns_refToConn(args []Object, index int) *textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Conn:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.Conn]"))
}

GO TYPE net/textproto.Error from net/textproto/textproto.go:
func Extract_ns_Error(args []Object, index int) *textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Error:
			return r
		case textproto.Error:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *textproto.Error {
	return &textproto.Error{
		Code: FieldAsInt(o, "Code"),
		Msg: FieldAsString(o, "Msg"),
	}
}

func _Ctor_Error(_v Object) *textproto.Error {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or: Map"))
}

func _Wrapped_Ctor_Error(_o Object) Object {
	return MakeGoObject(_Ctor_Error(_o))
}

GO TYPE *net/textproto.Error from net/textproto/textproto.go:
func Extract_ns_refToError(args []Object, index int) *textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.Error]"))
}

GO TYPE net/textproto.MIMEHeader from net/textproto/header.go:
func Extract_ns_MIMEHeader(args []Object, index int) *textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.MIMEHeader:
			return r
		case textproto.MIMEHeader:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _Ctor_MIMEHeader(_v Object) textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or: whatever"))
// }

// func _Wrapped_Ctor_MIMEHeader(_o Object) Object {
// 	return MakeGoObject(_Ctor_MIMEHeader(_o))
// }

GO TYPE *net/textproto.MIMEHeader from net/textproto/header.go:
func Extract_ns_refToMIMEHeader(args []Object, index int) *textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.MIMEHeader:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.MIMEHeader]"))
}

GO TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
func Extract_ns_Pipeline(args []Object, index int) *textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Pipeline:
			return r
		case textproto.Pipeline:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *textproto.Pipeline {
	return &textproto.Pipeline{}
}

func _Ctor_Pipeline(_v Object) *textproto.Pipeline {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or: Map"))
}

func _Wrapped_Ctor_Pipeline(_o Object) Object {
	return MakeGoObject(_Ctor_Pipeline(_o))
}

GO TYPE *net/textproto.Pipeline from net/textproto/pipeline.go:
func Extract_ns_refToPipeline(args []Object, index int) *textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Pipeline:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.Pipeline]"))
}

GO TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
func Extract_ns_ProtocolError(args []Object, index int) *textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.ProtocolError:
			return r
		case textproto.ProtocolError:
			return &r  // refTo
		}
	case String:
		v := textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _Ctor_ProtocolError(_v Object) textproto.ProtocolError {
	switch _o := _v.(type) {
	case String:
		return textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or: String"))
}

func _Wrapped_Ctor_ProtocolError(_o Object) Object {
	return MakeGoObject(_Ctor_ProtocolError(_o))
}

GO TYPE *net/textproto.ProtocolError from net/textproto/textproto.go:
func Extract_ns_refToProtocolError(args []Object, index int) *textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.ProtocolError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.ProtocolError]"))
}

GO TYPE net/textproto.Reader from net/textproto/reader.go:
func Extract_ns_Reader(args []Object, index int) *textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Reader:
			return r
		case textproto.Reader:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

// func _mapToReader(o Map) *textproto.Reader {
// 	return &textproto.Reader{
// 		R: *ABEND002(reference to unavailable package `bufio' looking for type `Reader'),
// 	}
// }

// func _Ctor_Reader(_v Object) *textproto.Reader {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or: Map"))
// }

// func _Wrapped_Ctor_Reader(_o Object) Object {
// 	return MakeGoObject(_Ctor_Reader(_o))
// }

GO TYPE *net/textproto.Reader from net/textproto/reader.go:
func Extract_ns_refToReader(args []Object, index int) *textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Reader:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.Reader]"))
}

GO TYPE net/textproto.Writer from net/textproto/writer.go:
func Extract_ns_Writer(args []Object, index int) *textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Writer:
			return r
		case textproto.Writer:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

// func _mapToWriter(o Map) *textproto.Writer {
// 	return &textproto.Writer{
// 		W: *ABEND002(reference to unavailable package `bufio' looking for type `Writer'),
// 	}
// }

// func _Ctor_Writer(_v Object) *textproto.Writer {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToWriter(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or: Map"))
// }

// func _Wrapped_Ctor_Writer(_o Object) Object {
// 	return MakeGoObject(_Ctor_Writer(_o))
// }

GO TYPE *net/textproto.Writer from net/textproto/writer.go:
func Extract_ns_refToWriter(args []Object, index int) *textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *textproto.Writer:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/textproto.Writer]"))
}

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func _f_dial(_v_network string, _v_addr string) Object {
	_res1, _res2 := textproto.Dial(_v_network, _v_addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func _f_newConn(_v_conn ABEND002(reference to unavailable package `io' looking for type `ReadWriteCloser')) Object {
// 	_res := textproto.NewConn(_v_conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func _f_newReader(_v_r *ABEND002(reference to unavailable package `bufio' looking for type `Reader')) Object {
// 	_res := textproto.NewReader(_v_r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func _f_newWriter(_v_w *ABEND002(reference to unavailable package `bufio' looking for type `Writer')) Object {
// 	_res := textproto.NewWriter(_v_w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
func _f_trimBytes(_v_b []byte) Object {
	_res := textproto.TrimBytes(_v_b)
	return MakeGoObject(_res)
}

GO FUNC net/textproto._f_mIMEHeader_Add from net/textproto/header.go:
// func _f_mIMEHeader_Add(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_mIMEHeader_Del from net/textproto/header.go:
// func _f_mIMEHeader_Del(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_mIMEHeader_Get from net/textproto/header.go:
func _f_mIMEHeader_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(textproto.MIMEHeader)Get()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(textproto.MIMEHeader).Get(_v_key)
	return MakeString(_res)
}

GO FUNC net/textproto._f_mIMEHeader_Set from net/textproto/header.go:
// func _f_mIMEHeader_Set(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_protocolError_Error from net/textproto/textproto.go:
func _f_protocolError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(textproto.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(textproto.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/textproto._f_ptrTo_Conn_Close from net/textproto/textproto.go:
func _f_ptrTo_Conn_Close(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Conn)Close()", args, 0, 0)
	_res := o.O.(*textproto.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/textproto._f_ptrTo_Conn_Cmd from net/textproto/textproto.go:
// func _f_ptrTo_Conn_Cmd(o GoObject, args Object) Object {  // Receiver
// (format string, args ABEND747(jtypes.go: ...interface{} not supported))}

GO FUNC net/textproto._f_ptrTo_Error_Error from net/textproto/textproto.go:
func _f_ptrTo_Error_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Error)Error()", args, 0, 0)
	_res := o.O.(*textproto.Error).Error()
	return MakeString(_res)
}

GO FUNC net/textproto._f_ptrTo_Pipeline_EndRequest from net/textproto/pipeline.go:
// func _f_ptrTo_Pipeline_EndRequest(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_ptrTo_Pipeline_EndResponse from net/textproto/pipeline.go:
// func _f_ptrTo_Pipeline_EndResponse(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_ptrTo_Pipeline_Next from net/textproto/pipeline.go:
func _f_ptrTo_Pipeline_Next(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Pipeline)Next()", args, 0, 0)
	_res := o.O.(*textproto.Pipeline).Next()
	return MakeBigIntU(uint64(_res))
}

GO FUNC net/textproto._f_ptrTo_Pipeline_StartRequest from net/textproto/pipeline.go:
// func _f_ptrTo_Pipeline_StartRequest(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_ptrTo_Pipeline_StartResponse from net/textproto/pipeline.go:
// func _f_ptrTo_Pipeline_StartResponse(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto._f_ptrTo_Reader_DotReader from net/textproto/reader.go:
// func _f_ptrTo_Reader_DotReader(o GoObject, args Object) Object {  // Receiver
// ABEND002(reference to unavailable package `io' looking for type `Reader')}

GO FUNC net/textproto._f_ptrTo_Reader_ReadCodeLine from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadCodeLine(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*textproto.Reader)ReadCodeLine()", args, 1, 1)
	_v_expectCode := ObjectAsInt(SeqNth(_argList, 0), "Arg[0] (_v_expectCode): %s")
	code, message, err := o.O.(*textproto.Reader).ReadCodeLine(_v_expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadContinuedLine from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadContinuedLine(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadContinuedLine()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadContinuedLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadContinuedLineBytes from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadContinuedLineBytes(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadContinuedLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadContinuedLineBytes()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadDotBytes from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadDotBytes(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadDotBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadDotBytes()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadDotLines from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadDotLines(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadDotLines()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadDotLines()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadLine from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadLine(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadLine()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadLineBytes from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadLineBytes(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadLineBytes()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadMIMEHeader from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadMIMEHeader(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*textproto.Reader)ReadMIMEHeader()", args, 0, 0)
	_res1, _res2 := o.O.(*textproto.Reader).ReadMIMEHeader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Reader_ReadResponse from net/textproto/reader.go:
func _f_ptrTo_Reader_ReadResponse(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*textproto.Reader)ReadResponse()", args, 1, 1)
	_v_expectCode := ObjectAsInt(SeqNth(_argList, 0), "Arg[0] (_v_expectCode): %s")
	code, message, err := o.O.(*textproto.Reader).ReadResponse(_v_expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto._f_ptrTo_Writer_DotWriter from net/textproto/writer.go:
// func _f_ptrTo_Writer_DotWriter(o GoObject, args Object) Object {  // Receiver
// ABEND002(reference to unavailable package `io' looking for type `WriteCloser')}

GO FUNC net/textproto._f_ptrTo_Writer_PrintfLine from net/textproto/writer.go:
// func _f_ptrTo_Writer_PrintfLine(o GoObject, args Object) Object {  // Receiver
// (format string, args ABEND747(jtypes.go: ...interface{} not supported))}

GO VARDEF FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
var info_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToConn from _tests/big/src/net/textproto/textproto.go:58:6:
var info_PtrTo_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfConn from _tests/big/src/net/textproto/textproto.go:58:6:
var info_ArrayOf_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToError from _tests/big/src/net/textproto/textproto.go:36:6:
var info_PtrTo_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfError from _tests/big/src/net/textproto/textproto.go:36:6:
var info_ArrayOf_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
var info_MIMEHeader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
var info_PtrTo_MIMEHeader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
var info_ArrayOf_MIMEHeader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
var info_Pipeline GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
var info_PtrTo_Pipeline GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
var info_ArrayOf_Pipeline GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
var info_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
var info_PtrTo_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
var info_ArrayOf_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
var info_Reader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToReader from _tests/big/src/net/textproto/reader.go:18:6:
var info_PtrTo_Reader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfReader from _tests/big/src/net/textproto/reader.go:18:6:
var info_ArrayOf_Reader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
var info_Writer GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/refToWriter from _tests/big/src/net/textproto/writer.go:15:6:
var info_PtrTo_Writer GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/arrayOfWriter from _tests/big/src/net/textproto/writer.go:15:6:
var info_ArrayOf_Writer GoTypeInfo

GO INFO FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
	info_Conn = GoTypeInfo{Name: "go.std.net.textproto/Conn",
		GoType: &GoType{T: &info_Conn},
		Ctor: _Wrapped_Ctor_Conn,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToConn from _tests/big/src/net/textproto/textproto.go:58:6:
	info_PtrTo_Conn = GoTypeInfo{Name: "go.std.net.textproto/refToConn",
		GoType: &GoType{T: &info_PtrTo_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", _f_ptrTo_Conn_Close, "Close closes the connection.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfConn from _tests/big/src/net/textproto/textproto.go:58:6:
	info_ArrayOf_Conn = GoTypeInfo{Name: "go.std.net.textproto/arrayOfConn",
		GoType: &GoType{T: &info_ArrayOf_Conn},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
	info_Error = GoTypeInfo{Name: "go.std.net.textproto/Error",
		GoType: &GoType{T: &info_Error},
		Ctor: _Wrapped_Ctor_Error,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToError from _tests/big/src/net/textproto/textproto.go:36:6:
	info_PtrTo_Error = GoTypeInfo{Name: "go.std.net.textproto/refToError",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfError from _tests/big/src/net/textproto/textproto.go:36:6:
	info_ArrayOf_Error = GoTypeInfo{Name: "go.std.net.textproto/arrayOfError",
		GoType: &GoType{T: &info_ArrayOf_Error},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	info_MIMEHeader = GoTypeInfo{Name: "go.std.net.textproto/MIMEHeader",
		GoType: &GoType{T: &info_MIMEHeader},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", _f_mIMEHeader_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	info_PtrTo_MIMEHeader = GoTypeInfo{Name: "go.std.net.textproto/refToMIMEHeader",
		GoType: &GoType{T: &info_PtrTo_MIMEHeader},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	info_ArrayOf_MIMEHeader = GoTypeInfo{Name: "go.std.net.textproto/arrayOfMIMEHeader",
		GoType: &GoType{T: &info_ArrayOf_MIMEHeader},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	info_Pipeline = GoTypeInfo{Name: "go.std.net.textproto/Pipeline",
		GoType: &GoType{T: &info_Pipeline},
		Ctor: _Wrapped_Ctor_Pipeline,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	info_PtrTo_Pipeline = GoTypeInfo{Name: "go.std.net.textproto/refToPipeline",
		GoType: &GoType{T: &info_PtrTo_Pipeline},
		Members: GoMembers{
			"Next": MakeGoReceiver("Next", _f_ptrTo_Pipeline_Next, "Next returns the next id for a request/response pair.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	info_ArrayOf_Pipeline = GoTypeInfo{Name: "go.std.net.textproto/arrayOfPipeline",
		GoType: &GoType{T: &info_ArrayOf_Pipeline},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	info_ProtocolError = GoTypeInfo{Name: "go.std.net.textproto/ProtocolError",
		GoType: &GoType{T: &info_ProtocolError},
		Ctor: _Wrapped_Ctor_ProtocolError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_protocolError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	info_PtrTo_ProtocolError = GoTypeInfo{Name: "go.std.net.textproto/refToProtocolError",
		GoType: &GoType{T: &info_PtrTo_ProtocolError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	info_ArrayOf_ProtocolError = GoTypeInfo{Name: "go.std.net.textproto/arrayOfProtocolError",
		GoType: &GoType{T: &info_ArrayOf_ProtocolError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
	info_Reader = GoTypeInfo{Name: "go.std.net.textproto/Reader",
		GoType: &GoType{T: &info_Reader},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToReader from _tests/big/src/net/textproto/reader.go:18:6:
	info_PtrTo_Reader = GoTypeInfo{Name: "go.std.net.textproto/refToReader",
		GoType: &GoType{T: &info_PtrTo_Reader},
		Members: GoMembers{
			"ReadCodeLine": MakeGoReceiver("ReadCodeLine", _f_ptrTo_Reader_ReadCodeLine, "ReadCodeLine reads a response code line of the form\n\tcode message\nwhere code is a three-digit status code and the message\nextends to the rest of the line. An example of such a line is:\n\t220 plan9.bell-labs.com ESMTP\n\nIf the prefix of the status does not match the digits in expectCode,\nReadCodeLine returns with err set to &Error{code, message}.\nFor example, if expectCode is 31, an error will be returned if\nthe status is not in the range [310,319].\n\nIf the response is multi-line, ReadCodeLine returns an error.\n\nAn expectCode <= 0 disables the check of the status code.\n", "1.0", NewVectorFrom(MakeSymbol("expectCode"))),
			"ReadContinuedLine": MakeGoReceiver("ReadContinuedLine", _f_ptrTo_Reader_ReadContinuedLine, "ReadContinuedLine reads a possibly continued line from r,\neliding the final trailing ASCII white space.\nLines after the first are considered continuations if they\nbegin with a space or tab character. In the returned data,\ncontinuation lines are separated from the previous line\nonly by a single space: the newline and leading white space\nare removed.\n\nFor example, consider this input:\n\n\tLine 1\n\t  continued...\n\tLine 2\n\nThe first call to ReadContinuedLine will return \"Line 1 continued...\"\nand the second will return \"Line 2\".\n\nA line consisting of only white space is never continued.\n", "1.0", NewVectorFrom()),
			"ReadContinuedLineBytes": MakeGoReceiver("ReadContinuedLineBytes", _f_ptrTo_Reader_ReadContinuedLineBytes, "ReadContinuedLineBytes is like ReadContinuedLine but\nreturns a []byte instead of a string.\n", "1.0", NewVectorFrom()),
			"ReadDotBytes": MakeGoReceiver("ReadDotBytes", _f_ptrTo_Reader_ReadDotBytes, "ReadDotBytes reads a dot-encoding and returns the decoded data.\n\nSee the documentation for the DotReader method for details about dot-encoding.\n", "1.0", NewVectorFrom()),
			"ReadDotLines": MakeGoReceiver("ReadDotLines", _f_ptrTo_Reader_ReadDotLines, "ReadDotLines reads a dot-encoding and returns a slice\ncontaining the decoded lines, with the final \\r\\n or \\n elided from each.\n\nSee the documentation for the DotReader method for details about dot-encoding.\n", "1.0", NewVectorFrom()),
			"ReadLine": MakeGoReceiver("ReadLine", _f_ptrTo_Reader_ReadLine, "ReadLine reads a single line from r,\neliding the final \\n or \\r\\n from the returned string.\n", "1.0", NewVectorFrom()),
			"ReadLineBytes": MakeGoReceiver("ReadLineBytes", _f_ptrTo_Reader_ReadLineBytes, "ReadLineBytes is like ReadLine but returns a []byte instead of a string.\n", "1.0", NewVectorFrom()),
			"ReadMIMEHeader": MakeGoReceiver("ReadMIMEHeader", _f_ptrTo_Reader_ReadMIMEHeader, "ReadMIMEHeader reads a MIME-style header from r.\nThe header is a sequence of possibly continued Key: Value lines\nending in a blank line.\nThe returned map m maps CanonicalMIMEHeaderKey(key) to a\nsequence of values in the same order encountered in the input.\n\nFor example, consider this input:\n\n\tMy-Key: Value 1\n\tLong-Key: Even\n\t       Longer Value\n\tMy-Key: Value 2\n\nGiven that input, ReadMIMEHeader returns the map:\n\n\tmap[string][]string{\n\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n\t\t\"Long-Key\": {\"Even Longer Value\"},\n\t}\n", "1.0", NewVectorFrom()),
			"ReadResponse": MakeGoReceiver("ReadResponse", _f_ptrTo_Reader_ReadResponse, "ReadResponse reads a multi-line response of the form:\n\n\tcode-message line 1\n\tcode-message line 2\n\t...\n\tcode message line n\n\nwhere code is a three-digit status code. The first line starts with the\ncode and a hyphen. The response is terminated by a line that starts\nwith the same code followed by a space. Each line in message is\nseparated by a newline (\\n).\n\nSee page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for\ndetails of another form of response accepted:\n\n code-message line 1\n message line 2\n ...\n code message line n\n\nIf the prefix of the status does not match the digits in expectCode,\nReadResponse returns with err set to &Error{code, message}.\nFor example, if expectCode is 31, an error will be returned if\nthe status is not in the range [310,319].\n\nAn expectCode <= 0 disables the check of the status code.\n", "1.0", NewVectorFrom(MakeSymbol("expectCode"))),
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfReader from _tests/big/src/net/textproto/reader.go:18:6:
	info_ArrayOf_Reader = GoTypeInfo{Name: "go.std.net.textproto/arrayOfReader",
		GoType: &GoType{T: &info_ArrayOf_Reader},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
	info_Writer = GoTypeInfo{Name: "go.std.net.textproto/Writer",
		GoType: &GoType{T: &info_Writer},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/refToWriter from _tests/big/src/net/textproto/writer.go:15:6:
	info_PtrTo_Writer = GoTypeInfo{Name: "go.std.net.textproto/refToWriter",
		GoType: &GoType{T: &info_PtrTo_Writer},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.textproto/arrayOfWriter from _tests/big/src/net/textproto/writer.go:15:6:
	info_ArrayOf_Writer = GoTypeInfo{Name: "go.std.net.textproto/arrayOfWriter",
		GoType: &GoType{T: &info_ArrayOf_Writer},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
	GoTypesVec[242] = &info_Conn

GO VECSET FOR TYPE go.std.net.textproto/refToConn from _tests/big/src/net/textproto/textproto.go:58:6:
	GoTypesVec[69] = &info_PtrTo_Conn

GO VECSET FOR TYPE go.std.net.textproto/arrayOfConn from _tests/big/src/net/textproto/textproto.go:58:6:
	GoTypesVec[159] = &info_ArrayOf_Conn

GO VECSET FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
	GoTypesVec[243] = &info_Error

GO VECSET FOR TYPE go.std.net.textproto/refToError from _tests/big/src/net/textproto/textproto.go:36:6:
	GoTypesVec[70] = &info_PtrTo_Error

GO VECSET FOR TYPE go.std.net.textproto/arrayOfError from _tests/big/src/net/textproto/textproto.go:36:6:
	GoTypesVec[160] = &info_ArrayOf_Error

GO VECSET FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	GoTypesVec[244] = &info_MIMEHeader

GO VECSET FOR TYPE go.std.net.textproto/refToMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	GoTypesVec[71] = &info_PtrTo_MIMEHeader

GO VECSET FOR TYPE go.std.net.textproto/arrayOfMIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	GoTypesVec[161] = &info_ArrayOf_MIMEHeader

GO VECSET FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	GoTypesVec[245] = &info_Pipeline

GO VECSET FOR TYPE go.std.net.textproto/refToPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	GoTypesVec[72] = &info_PtrTo_Pipeline

GO VECSET FOR TYPE go.std.net.textproto/arrayOfPipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	GoTypesVec[162] = &info_ArrayOf_Pipeline

GO VECSET FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	GoTypesVec[246] = &info_ProtocolError

GO VECSET FOR TYPE go.std.net.textproto/refToProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	GoTypesVec[73] = &info_PtrTo_ProtocolError

GO VECSET FOR TYPE go.std.net.textproto/arrayOfProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	GoTypesVec[163] = &info_ArrayOf_ProtocolError

GO VECSET FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
	GoTypesVec[247] = &info_Reader

GO VECSET FOR TYPE go.std.net.textproto/refToReader from _tests/big/src/net/textproto/reader.go:18:6:
	GoTypesVec[74] = &info_PtrTo_Reader

GO VECSET FOR TYPE go.std.net.textproto/arrayOfReader from _tests/big/src/net/textproto/reader.go:18:6:
	GoTypesVec[164] = &info_ArrayOf_Reader

GO VECSET FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
	GoTypesVec[248] = &info_Writer

GO VECSET FOR TYPE go.std.net.textproto/refToWriter from _tests/big/src/net/textproto/writer.go:15:6:
	GoTypesVec[75] = &info_PtrTo_Writer

GO VECSET FOR TYPE go.std.net.textproto/arrayOfWriter from _tests/big/src/net/textproto/writer.go:15:6:
	GoTypesVec[165] = &info_ArrayOf_Writer

GO ENSURE-LOADED FOR textproto:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/textproto/reader.go:8:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/textproto/reader.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/textproto/textproto.go:30:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/textproto/reader.go:10:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/textproto/reader.go:11:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/textproto/textproto.go:32:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/textproto/reader.go:12:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/textproto/reader.go:13:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/textproto/pipeline.go:8:2

GO TYPE []net/url.Error from net/url/url.go:
func Extract_ns_arrayOfError(args []Object, index int) []url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Error]"))
}

GO TYPE []net/url.EscapeError from net/url/url.go:
func Extract_ns_arrayOfEscapeError(args []Object, index int) []url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.EscapeError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.EscapeError]"))
}

GO TYPE []net/url.InvalidHostError from net/url/url.go:
func Extract_ns_arrayOfInvalidHostError(args []Object, index int) []url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.InvalidHostError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.InvalidHostError]"))
}

GO TYPE []net/url.URL from net/url/url.go:
func Extract_ns_arrayOfURL(args []Object, index int) []url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.URL:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.URL]"))
}

GO TYPE []net/url.Userinfo from net/url/url.go:
func Extract_ns_arrayOfUserinfo(args []Object, index int) []url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Userinfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Userinfo]"))
}

GO TYPE []net/url.Values from net/url/url.go:
func Extract_ns_arrayOfValues(args []Object, index int) []url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case []url.Values:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[[]net/url.Values]"))
}

GO TYPE net/url.Error from net/url/url.go:
func Extract_ns_Error(args []Object, index int) *url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Error:
			return r
		case url.Error:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *url.Error {
	return &url.Error{
		Op: FieldAsString(o, "Op"),
		URL: FieldAsString(o, "URL"),
		Err: FieldAsError(o, "Err"),
	}
}

func _Ctor_Error(_v Object) *url.Error {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map"))
}

func _Wrapped_Ctor_Error(_o Object) Object {
	return MakeGoObject(_Ctor_Error(_o))
}

GO TYPE *net/url.Error from net/url/url.go:
func Extract_ns_refToError(args []Object, index int) *url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Error:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Error]"))
}

GO TYPE net/url.EscapeError from net/url/url.go:
func Extract_ns_EscapeError(args []Object, index int) *url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.EscapeError:
			return r
		case url.EscapeError:
			return &r  // refTo
		}
	case String:
		v := url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _Ctor_EscapeError(_v Object) url.EscapeError {
	switch _o := _v.(type) {
	case String:
		return url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

func _Wrapped_Ctor_EscapeError(_o Object) Object {
	return MakeGoObject(_Ctor_EscapeError(_o))
}

GO TYPE *net/url.EscapeError from net/url/url.go:
func Extract_ns_refToEscapeError(args []Object, index int) *url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.EscapeError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.EscapeError]"))
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func Extract_ns_InvalidHostError(args []Object, index int) *url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.InvalidHostError:
			return r
		case url.InvalidHostError:
			return &r  // refTo
		}
	case String:
		v := url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _Ctor_InvalidHostError(_v Object) url.InvalidHostError {
	switch _o := _v.(type) {
	case String:
		return url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

func _Wrapped_Ctor_InvalidHostError(_o Object) Object {
	return MakeGoObject(_Ctor_InvalidHostError(_o))
}

GO TYPE *net/url.InvalidHostError from net/url/url.go:
func Extract_ns_refToInvalidHostError(args []Object, index int) *url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.InvalidHostError:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.InvalidHostError]"))
}

GO TYPE net/url.URL from net/url/url.go:
func Extract_ns_URL(args []Object, index int) *url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.URL:
			return r
		case url.URL:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *url.URL {
// 	return &url.URL{
// 		Scheme: FieldAsString(o, "Scheme"),
// 		Opaque: FieldAsString(o, "Opaque"),
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: FieldAsString(o, "Host"),
// 		Path: FieldAsString(o, "Path"),
// 		RawPath: FieldAsString(o, "RawPath"),
// 		ForceQuery: FieldAsBoolean(o, "ForceQuery"),
// 		RawQuery: FieldAsString(o, "RawQuery"),
// 		Fragment: FieldAsString(o, "Fragment"),
// 	}
// }

// func _Ctor_URL(_v Object) *url.URL {
// 	switch _o := _v.(type) {
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map"))
// }

// func _Wrapped_Ctor_URL(_o Object) Object {
// 	return MakeGoObject(_Ctor_URL(_o))
// }

GO TYPE *net/url.URL from net/url/url.go:
func Extract_ns_refToURL(args []Object, index int) *url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.URL:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.URL]"))
}

GO TYPE net/url.Userinfo from net/url/url.go:
func Extract_ns_Userinfo(args []Object, index int) *url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Userinfo:
			return r
		case url.Userinfo:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *url.Userinfo {
	return &url.Userinfo{}
}

func _Ctor_Userinfo(_v Object) *url.Userinfo {
	switch _o := _v.(type) {
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map"))
}

func _Wrapped_Ctor_Userinfo(_o Object) Object {
	return MakeGoObject(_Ctor_Userinfo(_o))
}

GO TYPE *net/url.Userinfo from net/url/url.go:
func Extract_ns_refToUserinfo(args []Object, index int) *url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Userinfo:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Userinfo]"))
}

GO TYPE net/url.Values from net/url/url.go:
func Extract_ns_Values(args []Object, index int) *url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Values:
			return r
		case url.Values:
			return &r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _Ctor_Values(_v Object) url.Values {
// 	switch _o := _v.(type) {
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

// func _Wrapped_Ctor_Values(_o Object) Object {
// 	return MakeGoObject(_Ctor_Values(_o))
// }

GO TYPE *net/url.Values from net/url/url.go:
func Extract_ns_refToValues(args []Object, index int) *url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case *url.Values:
			return r  // refTo
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[*net/url.Values]"))
}

GO FUNC net/url.Parse from net/url/url.go:
func _f_parse(_v_rawurl string) Object {
	_res1, _res2 := url.Parse(_v_rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func _f_parseQuery(_v_query string) Object {
	_res1, _res2 := url.ParseQuery(_v_query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func _f_parseRequestURI(_v_rawurl string) Object {
	_res1, _res2 := url.ParseRequestURI(_v_rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func _f_pathUnescape(_v_s string) Object {
	_res1, _res2 := url.PathUnescape(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func _f_queryUnescape(_v_s string) Object {
	_res1, _res2 := url.QueryUnescape(_v_s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func _f_user(_v_username string) Object {
	_res := url.User(_v_username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func _f_userPassword(_v_username string, _v_password string) Object {
	_res := url.UserPassword(_v_username, _v_password)
	return MakeGoObject(_res)
}

GO FUNC net/url._f_escapeError_Error from net/url/url.go:
func _f_escapeError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(url.EscapeError).Error()
	return MakeString(_res)
}

GO FUNC net/url._f_invalidHostError_Error from net/url/url.go:
func _f_invalidHostError_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(url.InvalidHostError).Error()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_Error_Error from net/url/url.go:
func _f_ptrTo_Error_Error(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Error()", args, 0, 0)
	_res := o.O.(*url.Error).Error()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_Error_Temporary from net/url/url.go:
func _f_ptrTo_Error_Temporary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*url.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net/url._f_ptrTo_Error_Timeout from net/url/url.go:
func _f_ptrTo_Error_Timeout(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*url.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net/url._f_ptrTo_URL_EscapedPath from net/url/url.go:
func _f_ptrTo_URL_EscapedPath(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*url.URL).EscapedPath()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_URL_Hostname from net/url/url.go:
func _f_ptrTo_URL_Hostname(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*url.URL).Hostname()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_URL_IsAbs from net/url/url.go:
func _f_ptrTo_URL_IsAbs(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*url.URL).IsAbs()
	return MakeBoolean(_res)
}

GO FUNC net/url._f_ptrTo_URL_MarshalBinary from net/url/url.go:
func _f_ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*url.URL).MarshalBinary()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(text))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/url._f_ptrTo_URL_Parse from net/url/url.go:
func _f_ptrTo_URL_Parse(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)Parse()", args, 1, 1)
	_v_ref := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_ref): %s")
	_res1, _res2 := o.O.(*url.URL).Parse(_v_ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url._f_ptrTo_URL_Port from net/url/url.go:
func _f_ptrTo_URL_Port(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Port()", args, 0, 0)
	_res := o.O.(*url.URL).Port()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_URL_Query from net/url/url.go:
func _f_ptrTo_URL_Query(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)Query()", args, 0, 0)
	_res := o.O.(*url.URL).Query()
	return MakeGoObject(_res)
}

GO FUNC net/url._f_ptrTo_URL_RequestURI from net/url/url.go:
func _f_ptrTo_URL_RequestURI(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*url.URL).RequestURI()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_URL_ResolveReference from net/url/url.go:
func _f_ptrTo_URL_ResolveReference(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)ResolveReference()", args, 1, 1)
	_v_ref := SeqNth(_argList, 0).(GoObject).O.(*url.URL)
	_res := o.O.(*url.URL).ResolveReference(_v_ref)
	return MakeGoObject(_res)
}

GO FUNC net/url._f_ptrTo_URL_String from net/url/url.go:
func _f_ptrTo_URL_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.URL)String()", args, 0, 0)
	_res := o.O.(*url.URL).String()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_URL_UnmarshalBinary from net/url/url.go:
func _f_ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(*url.URL)UnmarshalBinary()", args, 1, 1)
	_v_text := SeqNth(_argList, 0).(GoObject).O.([]byte)
	_res := o.O.(*url.URL).UnmarshalBinary(_v_text)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/url._f_ptrTo_Userinfo_Password from net/url/url.go:
func _f_ptrTo_Userinfo_Password(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC net/url._f_ptrTo_Userinfo_String from net/url/url.go:
func _f_ptrTo_Userinfo_String(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*url.Userinfo).String()
	return MakeString(_res)
}

GO FUNC net/url._f_ptrTo_Userinfo_Username from net/url/url.go:
func _f_ptrTo_Userinfo_Username(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(*url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*url.Userinfo).Username()
	return MakeString(_res)
}

GO FUNC net/url._f_values_Add from net/url/url.go:
// func _f_values_Add(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/url._f_values_Del from net/url/url.go:
// func _f_values_Del(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO FUNC net/url._f_values_Encode from net/url/url.go:
func _f_values_Encode(o GoObject, args Object) Object {  // Receiver
	CheckReceiverArity("(url.Values)Encode()", args, 0, 0)
	_res := o.O.(url.Values).Encode()
	return MakeString(_res)
}

GO FUNC net/url._f_values_Get from net/url/url.go:
func _f_values_Get(o GoObject, args Object) Object {  // Receiver
	_argList := CheckReceiverArity("(url.Values)Get()", args, 1, 1)
	_v_key := ObjectAsString(SeqNth(_argList, 0), "Arg[0] (_v_key): %s")
	_res := o.O.(url.Values).Get(_v_key)
	return MakeString(_res)
}

GO FUNC net/url._f_values_Set from net/url/url.go:
// func _f_values_Set(o GoObject, args Object) Object {  // Receiver
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToError from _tests/big/src/net/url/url.go:22:6:
var info_PtrTo_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfError from _tests/big/src/net/url/url.go:22:6:
var info_ArrayOf_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
var info_EscapeError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToEscapeError from _tests/big/src/net/url/url.go:84:6:
var info_PtrTo_EscapeError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfEscapeError from _tests/big/src/net/url/url.go:84:6:
var info_ArrayOf_EscapeError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
var info_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToInvalidHostError from _tests/big/src/net/url/url.go:90:6:
var info_PtrTo_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfInvalidHostError from _tests/big/src/net/url/url.go:90:6:
var info_ArrayOf_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
var info_URL GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToURL from _tests/big/src/net/url/url.go:344:6:
var info_PtrTo_URL GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfURL from _tests/big/src/net/url/url.go:344:6:
var info_ArrayOf_URL GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
var info_Userinfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToUserinfo from _tests/big/src/net/url/url.go:378:6:
var info_PtrTo_Userinfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfUserinfo from _tests/big/src/net/url/url.go:378:6:
var info_ArrayOf_Userinfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
var info_Values GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/refToValues from _tests/big/src/net/url/url.go:804:6:
var info_PtrTo_Values GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/arrayOfValues from _tests/big/src/net/url/url.go:804:6:
var info_ArrayOf_Values GoTypeInfo

GO INFO FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
	info_Error = GoTypeInfo{Name: "go.std.net.url/Error",
		GoType: &GoType{T: &info_Error},
		Ctor: _Wrapped_Ctor_Error,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/refToError from _tests/big/src/net/url/url.go:22:6:
	info_PtrTo_Error = GoTypeInfo{Name: "go.std.net.url/refToError",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", _f_ptrTo_Error_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", _f_ptrTo_Error_Timeout, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfError from _tests/big/src/net/url/url.go:22:6:
	info_ArrayOf_Error = GoTypeInfo{Name: "go.std.net.url/arrayOfError",
		GoType: &GoType{T: &info_ArrayOf_Error},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
	info_EscapeError = GoTypeInfo{Name: "go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_EscapeError},
		Ctor: _Wrapped_Ctor_EscapeError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_escapeError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.url/refToEscapeError from _tests/big/src/net/url/url.go:84:6:
	info_PtrTo_EscapeError = GoTypeInfo{Name: "go.std.net.url/refToEscapeError",
		GoType: &GoType{T: &info_PtrTo_EscapeError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfEscapeError from _tests/big/src/net/url/url.go:84:6:
	info_ArrayOf_EscapeError = GoTypeInfo{Name: "go.std.net.url/arrayOfEscapeError",
		GoType: &GoType{T: &info_ArrayOf_EscapeError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
	info_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_InvalidHostError},
		Ctor: _Wrapped_Ctor_InvalidHostError,
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", _f_invalidHostError_Error, "", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.url/refToInvalidHostError from _tests/big/src/net/url/url.go:90:6:
	info_PtrTo_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/refToInvalidHostError",
		GoType: &GoType{T: &info_PtrTo_InvalidHostError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfInvalidHostError from _tests/big/src/net/url/url.go:90:6:
	info_ArrayOf_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/arrayOfInvalidHostError",
		GoType: &GoType{T: &info_ArrayOf_InvalidHostError},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
	info_URL = GoTypeInfo{Name: "go.std.net.url/URL",
		GoType: &GoType{T: &info_URL},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/refToURL from _tests/big/src/net/url/url.go:344:6:
	info_PtrTo_URL = GoTypeInfo{Name: "go.std.net.url/refToURL",
		GoType: &GoType{T: &info_PtrTo_URL},
		Members: GoMembers{
			"EscapedPath": MakeGoReceiver("EscapedPath", _f_ptrTo_URL_EscapedPath, "EscapedPath returns the escaped form of u.Path.\nIn general there are multiple possible escaped forms of any path.\nEscapedPath returns u.RawPath when it is a valid escaping of u.Path.\nOtherwise EscapedPath ignores u.RawPath and computes an escaped\nform on its own.\nThe String and RequestURI methods use EscapedPath to construct\ntheir results.\nIn general, code should call EscapedPath instead of\nreading u.RawPath directly.\n", "1.0", NewVectorFrom()),
			"Hostname": MakeGoReceiver("Hostname", _f_ptrTo_URL_Hostname, "Hostname returns u.Host, without any port number.\n\nIf Host is an IPv6 literal with a port number, Hostname returns the\nIPv6 literal without the square brackets. IPv6 literals may include\na zone identifier.\n", "1.0", NewVectorFrom()),
			"IsAbs": MakeGoReceiver("IsAbs", _f_ptrTo_URL_IsAbs, "IsAbs reports whether the URL is absolute.\nAbsolute means that it has a non-empty scheme.\n", "1.0", NewVectorFrom()),
			"MarshalBinary": MakeGoReceiver("MarshalBinary", _f_ptrTo_URL_MarshalBinary, "", "1.0", NewVectorFrom()),
			"Parse": MakeGoReceiver("Parse", _f_ptrTo_URL_Parse, "Parse parses a URL in the context of the receiver. The provided URL\nmay be relative or absolute. Parse returns nil, err on parse\nfailure, otherwise its return value is the same as ResolveReference.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"Port": MakeGoReceiver("Port", _f_ptrTo_URL_Port, "Port returns the port part of u.Host, without the leading colon.\nIf u.Host doesn't contain a port, Port returns an empty string.\n", "1.0", NewVectorFrom()),
			"Query": MakeGoReceiver("Query", _f_ptrTo_URL_Query, "Query parses RawQuery and returns the corresponding values.\nIt silently discards malformed value pairs.\nTo check errors use ParseQuery.\n", "1.0", NewVectorFrom()),
			"RequestURI": MakeGoReceiver("RequestURI", _f_ptrTo_URL_RequestURI, "RequestURI returns the encoded path?query or opaque?query\nstring that would be used in an HTTP request for u.\n", "1.0", NewVectorFrom()),
			"ResolveReference": MakeGoReceiver("ResolveReference", _f_ptrTo_URL_ResolveReference, "ResolveReference resolves a URI reference to an absolute URI from\nan absolute base URI u, per RFC 3986 Section 5.2. The URI reference\nmay be relative or absolute. ResolveReference always returns a new\nURL instance, even if the returned URL is identical to either the\nbase or reference. If ref is an absolute URL, then ResolveReference\nignores base and returns a copy of ref.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"String": MakeGoReceiver("String", _f_ptrTo_URL_String, "String reassembles the URL into a valid URL string.\nThe general form of the result is one of:\n\n\tscheme:opaque?query#fragment\n\tscheme://userinfo@host/path?query#fragment\n\nIf u.Opaque is non-empty, String uses the first form;\notherwise it uses the second form.\nTo obtain the path, String uses u.EscapedPath().\n\nIn the second form, the following rules apply:\n\t- if u.Scheme is empty, scheme: is omitted.\n\t- if u.User is nil, userinfo@ is omitted.\n\t- if u.Host is empty, host/ is omitted.\n\t- if u.Scheme and u.Host are empty and u.User is nil,\n\t   the entire scheme://userinfo@host/ is omitted.\n\t- if u.Host is non-empty and u.Path begins with a /,\n\t   the form host/path does not add its own /.\n\t- if u.RawQuery is empty, ?query is omitted.\n\t- if u.Fragment is empty, #fragment is omitted.\n", "1.0", NewVectorFrom()),
			"UnmarshalBinary": MakeGoReceiver("UnmarshalBinary", _f_ptrTo_URL_UnmarshalBinary, "", "1.0", NewVectorFrom(MakeSymbol("text"))),
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfURL from _tests/big/src/net/url/url.go:344:6:
	info_ArrayOf_URL = GoTypeInfo{Name: "go.std.net.url/arrayOfURL",
		GoType: &GoType{T: &info_ArrayOf_URL},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
	info_Userinfo = GoTypeInfo{Name: "go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_Userinfo},
		Ctor: _Wrapped_Ctor_Userinfo,
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/refToUserinfo from _tests/big/src/net/url/url.go:378:6:
	info_PtrTo_Userinfo = GoTypeInfo{Name: "go.std.net.url/refToUserinfo",
		GoType: &GoType{T: &info_PtrTo_Userinfo},
		Members: GoMembers{
			"Password": MakeGoReceiver("Password", _f_ptrTo_Userinfo_Password, "Password returns the password in case it is set, and whether it is set.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", _f_ptrTo_Userinfo_String, "String returns the encoded userinfo information in the standard form\nof \"username[:password]\".\n", "1.0", NewVectorFrom()),
			"Username": MakeGoReceiver("Username", _f_ptrTo_Userinfo_Username, "Username returns the username.\n", "1.0", NewVectorFrom()),
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfUserinfo from _tests/big/src/net/url/url.go:378:6:
	info_ArrayOf_Userinfo = GoTypeInfo{Name: "go.std.net.url/arrayOfUserinfo",
		GoType: &GoType{T: &info_ArrayOf_Userinfo},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
	info_Values = GoTypeInfo{Name: "go.std.net.url/Values",
		GoType: &GoType{T: &info_Values},
		Members: GoMembers{
			"Encode": MakeGoReceiver("Encode", _f_values_Encode, "Encode encodes the values into ``URL encoded'' form\n(\"bar=baz&foo=quux\") sorted by key.\n", "1.0", NewVectorFrom()),
			"Get": MakeGoReceiver("Get", _f_values_Get, "Get gets the first value associated with the given key.\nIf there are no values associated with the key, Get returns\nthe empty string. To access multiple values, use the map\ndirectly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		},
	}


GO INFO FOR TYPE go.std.net.url/refToValues from _tests/big/src/net/url/url.go:804:6:
	info_PtrTo_Values = GoTypeInfo{Name: "go.std.net.url/refToValues",
		GoType: &GoType{T: &info_PtrTo_Values},
		Members: GoMembers{
		},
	}


GO INFO FOR TYPE go.std.net.url/arrayOfValues from _tests/big/src/net/url/url.go:804:6:
	info_ArrayOf_Values = GoTypeInfo{Name: "go.std.net.url/arrayOfValues",
		GoType: &GoType{T: &info_ArrayOf_Values},
		Members: GoMembers{
		},
	}


GO VECSET FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
	GoTypesVec[249] = &info_Error

GO VECSET FOR TYPE go.std.net.url/refToError from _tests/big/src/net/url/url.go:22:6:
	GoTypesVec[76] = &info_PtrTo_Error

GO VECSET FOR TYPE go.std.net.url/arrayOfError from _tests/big/src/net/url/url.go:22:6:
	GoTypesVec[166] = &info_ArrayOf_Error

GO VECSET FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
	GoTypesVec[250] = &info_EscapeError

GO VECSET FOR TYPE go.std.net.url/refToEscapeError from _tests/big/src/net/url/url.go:84:6:
	GoTypesVec[77] = &info_PtrTo_EscapeError

GO VECSET FOR TYPE go.std.net.url/arrayOfEscapeError from _tests/big/src/net/url/url.go:84:6:
	GoTypesVec[167] = &info_ArrayOf_EscapeError

GO VECSET FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
	GoTypesVec[251] = &info_InvalidHostError

GO VECSET FOR TYPE go.std.net.url/refToInvalidHostError from _tests/big/src/net/url/url.go:90:6:
	GoTypesVec[78] = &info_PtrTo_InvalidHostError

GO VECSET FOR TYPE go.std.net.url/arrayOfInvalidHostError from _tests/big/src/net/url/url.go:90:6:
	GoTypesVec[168] = &info_ArrayOf_InvalidHostError

GO VECSET FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
	GoTypesVec[252] = &info_URL

GO VECSET FOR TYPE go.std.net.url/refToURL from _tests/big/src/net/url/url.go:344:6:
	GoTypesVec[79] = &info_PtrTo_URL

GO VECSET FOR TYPE go.std.net.url/arrayOfURL from _tests/big/src/net/url/url.go:344:6:
	GoTypesVec[169] = &info_ArrayOf_URL

GO VECSET FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
	GoTypesVec[253] = &info_Userinfo

GO VECSET FOR TYPE go.std.net.url/refToUserinfo from _tests/big/src/net/url/url.go:378:6:
	GoTypesVec[80] = &info_PtrTo_Userinfo

GO VECSET FOR TYPE go.std.net.url/arrayOfUserinfo from _tests/big/src/net/url/url.go:378:6:
	GoTypesVec[170] = &info_ArrayOf_Userinfo

GO VECSET FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
	GoTypesVec[254] = &info_Values

GO VECSET FOR TYPE go.std.net.url/refToValues from _tests/big/src/net/url/url.go:804:6:
	GoTypesVec[81] = &info_PtrTo_Values

GO VECSET FOR TYPE go.std.net.url/arrayOfValues from _tests/big/src/net/url/url.go:804:6:
	GoTypesVec[171] = &info_ArrayOf_Values

GO ENSURE-LOADED FOR url:
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/url/url.go:14:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/url/url.go:15:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/url/url.go:16:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/url/url.go:17:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/url/url.go:18:2

Adding 15 custom imports to _tests/gold/amd64-darwin/joker/g_custom.go
Adding 15 custom loaded libraries to _tests/gold/amd64-darwin/joker/core/data/g_customlibs.joke
Adding only 275 types (out of 286) to _tests/gold/amd64-darwin/joker/core/g_goswitch.go
Generated file g_goswitch.go:
// Auto-modified by gostd at (omitted for testing)

package core

import (
	"net"
	"net/http"
	"net/http/cgi"
	"net/http/cookiejar"
	"net/http/httptest"
	"net/http/httptrace"
	"net/http/httputil"
	"net/mail"
	"net/rpc"
	"net/smtp"
	"net/textproto"
	"net/url"
)

var GoTypesVec [275]*GoTypeInfo

func SwitchGoType(g interface{}) int {
	switch g.(type) {
	case *net.AddrError:
		return 0
	case *net.Buffers:
		return 1
	case *net.DNSConfigError:
		return 2
	case *net.DNSError:
		return 3
	case *net.Dialer:
		return 4
	case *net.Flags:
		return 5
	case *net.HardwareAddr:
		return 6
	case *net.IP:
		return 7
	case *net.IPAddr:
		return 8
	case *net.IPConn:
		return 9
	case *net.IPMask:
		return 10
	case *net.IPNet:
		return 11
	case *net.Interface:
		return 12
	case *net.InvalidAddrError:
		return 13
	case *net.ListenConfig:
		return 14
	case *net.MX:
		return 15
	case *net.NS:
		return 16
	case *net.OpError:
		return 17
	case *net.ParseError:
		return 18
	case *net.Resolver:
		return 19
	case *net.SRV:
		return 20
	case *net.TCPAddr:
		return 21
	case *net.TCPConn:
		return 22
	case *net.TCPListener:
		return 23
	case *net.UDPAddr:
		return 24
	case *net.UDPConn:
		return 25
	case *net.UnixAddr:
		return 26
	case *net.UnixConn:
		return 27
	case *net.UnixListener:
		return 28
	case *net.UnknownNetworkError:
		return 29
	case *http.Client:
		return 30
	case *http.ConnState:
		return 31
	case *http.Cookie:
		return 32
	case *http.Dir:
		return 33
	case *http.HandlerFunc:
		return 34
	case *http.Header:
		return 35
	case *http.ProtocolError:
		return 36
	case *http.PushOptions:
		return 37
	case *http.Request:
		return 38
	case *http.Response:
		return 39
	case *http.SameSite:
		return 40
	case *http.ServeMux:
		return 41
	case *http.Server:
		return 42
	case *http.Transport:
		return 43
	case *cgi.Handler:
		return 44
	case *cookiejar.Jar:
		return 45
	case *cookiejar.Options:
		return 46
	case *httptest.ResponseRecorder:
		return 47
	case *httptest.Server:
		return 48
	case *httptrace.ClientTrace:
		return 49
	case *httptrace.DNSDoneInfo:
		return 50
	case *httptrace.DNSStartInfo:
		return 51
	case *httptrace.GotConnInfo:
		return 52
	case *httptrace.WroteRequestInfo:
		return 53
	case *httputil.ClientConn:
		return 54
	case *httputil.ReverseProxy:
		return 55
	case *httputil.ServerConn:
		return 56
	case *mail.Address:
		return 57
	case *mail.AddressParser:
		return 58
	case *mail.Header:
		return 59
	case *mail.Message:
		return 60
	case *rpc.Call:
		return 61
	case *rpc.Client:
		return 62
	case *rpc.Request:
		return 63
	case *rpc.Response:
		return 64
	case *rpc.Server:
		return 65
	case *rpc.ServerError:
		return 66
	case *smtp.Client:
		return 67
	case *smtp.ServerInfo:
		return 68
	case *textproto.Conn:
		return 69
	case *textproto.Error:
		return 70
	case *textproto.MIMEHeader:
		return 71
	case *textproto.Pipeline:
		return 72
	case *textproto.ProtocolError:
		return 73
	case *textproto.Reader:
		return 74
	case *textproto.Writer:
		return 75
	case *url.Error:
		return 76
	case *url.EscapeError:
		return 77
	case *url.InvalidHostError:
		return 78
	case *url.URL:
		return 79
	case *url.Userinfo:
		return 80
	case *url.Values:
		return 81
	case [8]byte:
		return 82
	case []*net.MX:
		return 83
	case []*net.NS:
		return 84
	case []*net.SRV:
		return 85
	case []*http.Cookie:
		return 86
	case []*mail.Address:
		return 87
	case []byte:
		return 88
	case []net.Addr:
		return 89
	case []net.AddrError:
		return 90
	case []net.Buffers:
		return 91
	case []net.DNSConfigError:
		return 92
	case []net.DNSError:
		return 93
	case []net.Dialer:
		return 94
	case []net.Flags:
		return 95
	case []net.HardwareAddr:
		return 96
	case []net.IP:
		return 97
	case []net.IPAddr:
		return 98
	case []net.IPConn:
		return 99
	case []net.IPMask:
		return 100
	case []net.IPNet:
		return 101
	case []net.Interface:
		return 102
	case []net.InvalidAddrError:
		return 103
	case []net.ListenConfig:
		return 104
	case []net.MX:
		return 105
	case []net.NS:
		return 106
	case []net.OpError:
		return 107
	case []net.ParseError:
		return 108
	case []net.Resolver:
		return 109
	case []net.SRV:
		return 110
	case []net.TCPAddr:
		return 111
	case []net.TCPConn:
		return 112
	case []net.TCPListener:
		return 113
	case []net.UDPAddr:
		return 114
	case []net.UDPConn:
		return 115
	case []net.UnixAddr:
		return 116
	case []net.UnixConn:
		return 117
	case []net.UnixListener:
		return 118
	case []net.UnknownNetworkError:
		return 119
	case []http.Client:
		return 120
	case []http.ConnState:
		return 121
	case []http.Cookie:
		return 122
	case []http.Dir:
		return 123
	case []http.HandlerFunc:
		return 124
	case []http.Header:
		return 125
	case []http.ProtocolError:
		return 126
	case []http.PushOptions:
		return 127
	case []http.Request:
		return 128
	case []http.Response:
		return 129
	case []http.SameSite:
		return 130
	case []http.ServeMux:
		return 131
	case []http.Server:
		return 132
	case []http.Transport:
		return 133
	case []cgi.Handler:
		return 134
	case []cookiejar.Jar:
		return 135
	case []cookiejar.Options:
		return 136
	case []httptest.ResponseRecorder:
		return 137
	case []httptest.Server:
		return 138
	case []httptrace.ClientTrace:
		return 139
	case []httptrace.DNSDoneInfo:
		return 140
	case []httptrace.DNSStartInfo:
		return 141
	case []httptrace.GotConnInfo:
		return 142
	case []httptrace.WroteRequestInfo:
		return 143
	case []httputil.ClientConn:
		return 144
	case []httputil.ReverseProxy:
		return 145
	case []httputil.ServerConn:
		return 146
	case []mail.Address:
		return 147
	case []mail.AddressParser:
		return 148
	case []mail.Header:
		return 149
	case []mail.Message:
		return 150
	case []rpc.Call:
		return 151
	case []rpc.Client:
		return 152
	case []rpc.Request:
		return 153
	case []rpc.Response:
		return 154
	case []rpc.Server:
		return 155
	case []rpc.ServerError:
		return 156
	case []smtp.Client:
		return 157
	case []smtp.ServerInfo:
		return 158
	case []textproto.Conn:
		return 159
	case []textproto.Error:
		return 160
	case []textproto.MIMEHeader:
		return 161
	case []textproto.Pipeline:
		return 162
	case []textproto.ProtocolError:
		return 163
	case []textproto.Reader:
		return 164
	case []textproto.Writer:
		return 165
	case []url.Error:
		return 166
	case []url.EscapeError:
		return 167
	case []url.InvalidHostError:
		return 168
	case []url.URL:
		return 169
	case []url.Userinfo:
		return 170
	case []url.Values:
		return 171
	case []string:
		return 172
	case net.AddrError:
		return 173
	case net.Buffers:
		return 174
	case net.DNSConfigError:
		return 175
	case net.DNSError:
		return 176
	case net.Dialer:
		return 177
	case net.Flags:
		return 178
	case net.HardwareAddr:
		return 179
	case net.IP:
		return 180
	case net.IPAddr:
		return 181
	case net.IPConn:
		return 182
	case net.IPMask:
		return 183
	case net.IPNet:
		return 184
	case net.Interface:
		return 185
	case net.InvalidAddrError:
		return 186
	case net.ListenConfig:
		return 187
	case net.MX:
		return 188
	case net.NS:
		return 189
	case net.OpError:
		return 190
	case net.ParseError:
		return 191
	case net.Resolver:
		return 192
	case net.SRV:
		return 193
	case net.TCPAddr:
		return 194
	case net.TCPConn:
		return 195
	case net.TCPListener:
		return 196
	case net.UDPAddr:
		return 197
	case net.UDPConn:
		return 198
	case net.UnixAddr:
		return 199
	case net.UnixConn:
		return 200
	case net.UnixListener:
		return 201
	case net.UnknownNetworkError:
		return 202
	case http.Client:
		return 203
	case http.ConnState:
		return 204
	case http.Cookie:
		return 205
	case http.Dir:
		return 206
	case http.HandlerFunc:
		return 207
	case http.Header:
		return 208
	case http.ProtocolError:
		return 209
	case http.PushOptions:
		return 210
	case http.Request:
		return 211
	case http.Response:
		return 212
	case http.SameSite:
		return 213
	case http.ServeMux:
		return 214
	case http.Server:
		return 215
	case http.Transport:
		return 216
	case cgi.Handler:
		return 217
	case cookiejar.Jar:
		return 218
	case cookiejar.Options:
		return 219
	case httptest.ResponseRecorder:
		return 220
	case httptest.Server:
		return 221
	case httptrace.ClientTrace:
		return 222
	case httptrace.DNSDoneInfo:
		return 223
	case httptrace.DNSStartInfo:
		return 224
	case httptrace.GotConnInfo:
		return 225
	case httptrace.WroteRequestInfo:
		return 226
	case httputil.ClientConn:
		return 227
	case httputil.ReverseProxy:
		return 228
	case httputil.ServerConn:
		return 229
	case mail.Address:
		return 230
	case mail.AddressParser:
		return 231
	case mail.Header:
		return 232
	case mail.Message:
		return 233
	case rpc.Call:
		return 234
	case rpc.Client:
		return 235
	case rpc.Request:
		return 236
	case rpc.Response:
		return 237
	case rpc.Server:
		return 238
	case rpc.ServerError:
		return 239
	case smtp.Client:
		return 240
	case smtp.ServerInfo:
		return 241
	case textproto.Conn:
		return 242
	case textproto.Error:
		return 243
	case textproto.MIMEHeader:
		return 244
	case textproto.Pipeline:
		return 245
	case textproto.ProtocolError:
		return 246
	case textproto.Reader:
		return 247
	case textproto.Writer:
		return 248
	case url.Error:
		return 249
	case url.EscapeError:
		return 250
	case url.InvalidHostError:
		return 251
	case url.URL:
		return 252
	case url.Userinfo:
		return 253
	case url.Values:
		return 254
	case net.Conn:  // Specificity=8
		return 255
	case net.PacketConn:  // Specificity=7
		return 256
	case rpc.ClientCodec:  // Specificity=4
		return 257
	case rpc.ServerCodec:  // Specificity=4
		return 258
	case net.Error:  // Specificity=3
		return 259
	case net.Listener:  // Specificity=3
		return 260
	case http.ResponseWriter:  // Specificity=3
		return 261
	case net.Addr:  // Specificity=2
		return 262
	case http.CookieJar:  // Specificity=2
		return 263
	case http.File:  // Specificity=2
		return 264
	case cookiejar.PublicSuffixList:  // Specificity=2
		return 265
	case httputil.BufferPool:  // Specificity=2
		return 266
	case smtp.Auth:  // Specificity=2
		return 267
	case http.CloseNotifier:  // Specificity=1
		return 268
	case http.FileSystem:  // Specificity=1
		return 269
	case http.Flusher:  // Specificity=1
		return 270
	case http.Handler:  // Specificity=1
		return 271
	case http.Hijacker:  // Specificity=1
		return 272
	case http.Pusher:  // Specificity=1
		return 273
	case http.RoundTripper:  // Specificity=1
		return 274
	}
	return -1
}
ABENDs: 002(153) 048(45) 275(41) 727(39) 707(30) 320(12) 674(9) 737(5) 777(3) 049(2) 747(2) 124(1)
Totals: functions=470 generated=334 (71.06%)
          non-receivers=148 (31.49%) generated=113 (76.35%)
          receivers=273 (58.09%) generated=186 (68.13%)
          methods=49 (10.43%) generated=35 (71.43%)
        types=266
          constructable=246 ctors=41 (16.67%)
        constants=91 generated=91 (100.00%)
        variables=48 generated=48 (100.00%)
