goSourceDir: _tests/big/src
goSourcePath: /home/craig/go/src
Excluding _tests/big/src/net/http/cgi/testdata
Excluding _tests/big/src/net/http/internal
Excluding _tests/big/src/net/http/testdata
Excluding _tests/big/src/net/internal
Excluding _tests/big/src/net/testdata
Ignoring test code in addrselect_test.go
Ignoring test code in all_test.go
Ignoring test code in cgo_unix_test.go
Ignoring test code in child_test.go
Ignoring test code in client_test.go
Ignoring test code in clientserver_test.go
Ignoring test code in conf_test.go
Ignoring test code in conn_test.go
Ignoring test code in cookie_test.go
Ignoring test code in dial_test.go
Ignoring test code in dial_unix_test.go
Ignoring test code in dnsclient_test.go
Ignoring test code in dnsclient_unix_test.go
Ignoring test code in dnsconfig_unix_test.go
Ignoring test code in dnsname_test.go
Ignoring test code in dummy_publicsuffix_test.go
Ignoring test code in dump_test.go
Ignoring test code in error_plan9_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in error_test.go
Ignoring test code in error_unix_test.go
Ignoring test code in error_windows_test.go
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Ignoring test code in external_test.go
Ignoring test code in fcgi_test.go
Ignoring test code in file_test.go
Ignoring test code in filetransport_test.go
Ignoring test code in fs_test.go
Ignoring test code in header_test.go
Ignoring test code in host_test.go
Ignoring test code in hosts_test.go
Ignoring test code in http_test.go
Ignoring test code in httptest_test.go
Ignoring test code in interface_bsd_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in interface_test.go
Ignoring test code in interface_unix_test.go
Ignoring test code in ip_test.go
Ignoring test code in iprawsock_test.go
Ignoring test code in ipsock_test.go
Ignoring test code in jar_test.go
Ignoring test code in listen_test.go
Ignoring test code in lookup_test.go
Ignoring test code in lookup_windows_test.go
Ignoring test code in mac_test.go
Ignoring test code in main_cloexec_test.go
Ignoring test code in main_conf_test.go
Ignoring test code in main_noconf_test.go
Ignoring test code in main_plan9_test.go
Ignoring test code in main_posix_test.go
Ignoring test code in main_test.go
Ignoring test code in main_unix_test.go
Ignoring test code in main_windows_test.go
Ignoring test code in matryoshka_test.go
Ignoring test code in message_test.go
Ignoring test code in mockserver_test.go
Ignoring test code in net_test.go
Ignoring test code in net_windows_test.go
Ignoring test code in netgo_unix_test.go
Ignoring test code in npn_test.go
Ignoring test code in nss_test.go
Ignoring test code in packetconn_test.go
Ignoring test code in parse_test.go
Ignoring test code in pipe_test.go
Ignoring test code in plan9_test.go
Ignoring test code in platform_test.go
Ignoring test code in port_test.go
Ignoring test code in posix_test.go
Ignoring test code in pprof_test.go
Ignoring test code in protoconn_test.go
Ignoring test code in proxy_test.go
Ignoring test code in punycode_test.go
Ignoring test code in range_test.go
Ignoring test code in rawconn_stub_test.go
Ignoring test code in rawconn_test.go
Ignoring test code in rawconn_unix_test.go
Ignoring test code in rawconn_windows_test.go
Ignoring test code in reader_test.go
Ignoring test code in readrequest_test.go
Ignoring test code in recorder_test.go
Ignoring test code in request_test.go
Ignoring test code in requestwrite_test.go
Ignoring test code in response_test.go
Ignoring test code in responsewrite_test.go
Ignoring test code in reverseproxy_test.go
Ignoring test code in sendfile_test.go
Ignoring test code in serve_test.go
Ignoring test code in server_test.go
Ignoring test code in smtp_test.go
Ignoring test code in sniff_test.go
Ignoring test code in splice_test.go
Ignoring test code in tcpsock_test.go
Ignoring test code in tcpsock_unix_test.go
Ignoring test code in timeout_test.go
Ignoring test code in trace_test.go
Ignoring test code in transfer_test.go
Ignoring test code in transport_internal_test.go
Ignoring test code in transport_test.go
Ignoring test code in udpsock_plan9_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in unixsock_linux_test.go
Ignoring test code in unixsock_test.go
Ignoring test code in url_test.go
Ignoring test code in write_unix_test.go
Ignoring test code in writer_test.go
Ignoring test code in writev_test.go
Matchfile(_tests/big/src/net/addrselect.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_android.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_linux.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_netbsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_resnew.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_resold.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_socknew.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_sockold.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_stub.go) => false <nil>
Matchfile(_tests/big/src/net/cgo_unix.go) => true <nil>
Matchfile(_tests/big/src/net/cgo_windows.go) => false <nil>
Matchfile(_tests/big/src/net/conf.go) => true <nil>
Matchfile(_tests/big/src/net/conf_netcgo.go) => false <nil>
Matchfile(_tests/big/src/net/dial.go) => true <nil>
Matchfile(_tests/big/src/net/dnsclient.go) => true <nil>
Matchfile(_tests/big/src/net/dnsclient_unix.go) => true <nil>
Matchfile(_tests/big/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_nacl.go) => false <nil>
Matchfile(_tests/big/src/net/error_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/error_posix.go) => true <nil>
Matchfile(_tests/big/src/net/error_unix.go) => true <nil>
Matchfile(_tests/big/src/net/error_windows.go) => false <nil>
Matchfile(_tests/big/src/net/fd_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/fd_unix.go) => true <nil>
Matchfile(_tests/big/src/net/fd_windows.go) => false <nil>
Matchfile(_tests/big/src/net/file.go) => true <nil>
Matchfile(_tests/big/src/net/file_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/file_stub.go) => false <nil>
Matchfile(_tests/big/src/net/file_unix.go) => true <nil>
Matchfile(_tests/big/src/net/file_windows.go) => false <nil>
Matchfile(_tests/big/src/net/hook.go) => true <nil>
Matchfile(_tests/big/src/net/hook_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/hook_unix.go) => true <nil>
Matchfile(_tests/big/src/net/hook_windows.go) => false <nil>
Matchfile(_tests/big/src/net/hosts.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/child.go) => true <nil>
Matchfile(_tests/big/src/net/http/cgi/host.go) => true <nil>
Matchfile(_tests/big/src/net/http/client.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookie.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookiejar/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/cookiejar/punycode.go) => true <nil>
Matchfile(_tests/big/src/net/http/doc.go) => true <nil>
Matchfile(_tests/big/src/net/http/fcgi/child.go) => true <nil>
Matchfile(_tests/big/src/net/http/fcgi/fcgi.go) => true <nil>
Matchfile(_tests/big/src/net/http/filetransport.go) => true <nil>
Matchfile(_tests/big/src/net/http/fs.go) => true <nil>
Matchfile(_tests/big/src/net/http/h2_bundle.go) => true <nil>
Matchfile(_tests/big/src/net/http/header.go) => true <nil>
Matchfile(_tests/big/src/net/http/http.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/httptest.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/recorder.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptest/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/httptrace/trace.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/dump.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/persist.go) => true <nil>
Matchfile(_tests/big/src/net/http/httputil/reverseproxy.go) => true <nil>
Matchfile(_tests/big/src/net/http/jar.go) => true <nil>
Matchfile(_tests/big/src/net/http/method.go) => true <nil>
Matchfile(_tests/big/src/net/http/pprof/pprof.go) => true <nil>
Matchfile(_tests/big/src/net/http/race.go) => false <nil>
Matchfile(_tests/big/src/net/http/request.go) => true <nil>
Matchfile(_tests/big/src/net/http/response.go) => true <nil>
Matchfile(_tests/big/src/net/http/roundtrip.go) => true <nil>
Matchfile(_tests/big/src/net/http/roundtrip_js.go) => false <nil>
Matchfile(_tests/big/src/net/http/server.go) => true <nil>
Matchfile(_tests/big/src/net/http/sniff.go) => true <nil>
Matchfile(_tests/big/src/net/http/socks_bundle.go) => true <nil>
Matchfile(_tests/big/src/net/http/status.go) => true <nil>
Matchfile(_tests/big/src/net/http/transfer.go) => true <nil>
Matchfile(_tests/big/src/net/http/transport.go) => true <nil>
Matchfile(_tests/big/src/net/http/triv.go) => false <nil>
Matchfile(_tests/big/src/net/interface.go) => true <nil>
Matchfile(_tests/big/src/net/interface_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/interface_bsdvar.go) => false <nil>
Matchfile(_tests/big/src/net/interface_darwin.go) => false <nil>
Matchfile(_tests/big/src/net/interface_freebsd.go) => false <nil>
Matchfile(_tests/big/src/net/interface_linux.go) => true <nil>
Matchfile(_tests/big/src/net/interface_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/interface_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/interface_stub.go) => false <nil>
Matchfile(_tests/big/src/net/interface_windows.go) => false <nil>
Matchfile(_tests/big/src/net/ip.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock.go) => true <nil>
Matchfile(_tests/big/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/iprawsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock.go) => true <nil>
Matchfile(_tests/big/src/net/ipsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/ipsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_fake.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/lookup_unix.go) => true <nil>
Matchfile(_tests/big/src/net/lookup_windows.go) => false <nil>
Matchfile(_tests/big/src/net/mac.go) => true <nil>
Matchfile(_tests/big/src/net/mail/message.go) => true <nil>
Matchfile(_tests/big/src/net/net.go) => true <nil>
Matchfile(_tests/big/src/net/net_fake.go) => false <nil>
Matchfile(_tests/big/src/net/nss.go) => true <nil>
Matchfile(_tests/big/src/net/parse.go) => true <nil>
Matchfile(_tests/big/src/net/pipe.go) => true <nil>
Matchfile(_tests/big/src/net/port.go) => true <nil>
Matchfile(_tests/big/src/net/port_unix.go) => true <nil>
Matchfile(_tests/big/src/net/rawconn.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/client.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/debug.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/jsonrpc/client.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/jsonrpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/rpc/server.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sendfile_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_unix_alt.go) => false <nil>
Matchfile(_tests/big/src/net/sendfile_windows.go) => false <nil>
Matchfile(_tests/big/src/net/smtp/auth.go) => true <nil>
Matchfile(_tests/big/src/net/smtp/smtp.go) => true <nil>
Matchfile(_tests/big/src/net/sock_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sock_cloexec.go) => true <nil>
Matchfile(_tests/big/src/net/sock_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sock_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sock_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sockaddr_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_bsd.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_bsdvar.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_linux.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_posix.go) => true <nil>
Matchfile(_tests/big/src/net/sockoptip_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sockoptip_windows.go) => false <nil>
Matchfile(_tests/big/src/net/splice_linux.go) => true <nil>
Matchfile(_tests/big/src/net/splice_stub.go) => false <nil>
Matchfile(_tests/big/src/net/sys_cloexec.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_darwin.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_dragonfly.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_solaris.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(_tests/big/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(_tests/big/src/net/tcpsockopt_windows.go) => false <nil>
Matchfile(_tests/big/src/net/textproto/header.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/pipeline.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/reader.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/textproto.go) => true <nil>
Matchfile(_tests/big/src/net/textproto/writer.go) => true <nil>
Matchfile(_tests/big/src/net/udpsock.go) => true <nil>
Matchfile(_tests/big/src/net/udpsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/udpsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/unixsock.go) => true <nil>
Matchfile(_tests/big/src/net/unixsock_plan9.go) => false <nil>
Matchfile(_tests/big/src/net/unixsock_posix.go) => true <nil>
Matchfile(_tests/big/src/net/url/url.go) => true <nil>
Matchfile(_tests/big/src/net/writev_unix.go) => true <nil>
Processing go:
Processing net/http/cgi:
Processing net/http/cookiejar:
Processing net/http/fcgi:
Processing net/http/httptest:
Processing net/http/httptrace:
Processing net/http/httputil:
Processing net/http/pprof:
Processing net/http:
Processing net/mail:
Processing net/rpc/jsonrpc:
Processing net/rpc:
Processing net/smtp:
Processing net/textproto:
Processing net/url:
Processing net:
Processing package=net/http/cgi:
Processing package=net/http/cookiejar:
Processing package=net/http/fcgi:
Processing package=net/http/httptest:
Processing package=net/http/httptrace:
Processing package=net/http/httputil:
Processing package=net/http/pprof:
Processing package=net/http:
Processing package=net/mail:
Processing package=net/rpc/jsonrpc:
Processing package=net/rpc:
Processing package=net/smtp:
Processing package=net/textproto:
Processing package=net/url:
Processing package=net:
JOKER CONSTANT FlagBroadcast from net/interface.go:
(def
  ^{:doc "interface supports broadcast access capability\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagBroadcast))"}
  FlagBroadcast)

JOKER CONSTANT FlagLoopback from net/interface.go:
(def
  ^{:doc "interface is a loopback interface\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagLoopback))"}
  FlagLoopback)

JOKER CONSTANT FlagMulticast from net/interface.go:
(def
  ^{:doc "interface supports multicast access capability\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagMulticast))"}
  FlagMulticast)

JOKER CONSTANT FlagPointToPoint from net/interface.go:
(def
  ^{:doc "interface belongs to a point-to-point link\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagPointToPoint))"}
  FlagPointToPoint)

JOKER CONSTANT FlagUp from net/interface.go:
(def
  ^{:doc "interface is up\n"
    :added "1.0"
    :tag "Number"
    :go "uint64(uint(net.FlagUp))"}
  FlagUp)

JOKER CONSTANT IPv4len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv4len"}
  IPv4len)

JOKER CONSTANT IPv6len from net/ip.go:
(def
  ^{:doc "IP address lengths (bytes).\n"
    :added "1.0"
    :tag "Int"
    :go "net.IPv6len"}
  IPv6len)

JOKER VARIABLE DefaultResolver from net/lookup.go:
(def
  ^{:doc "DefaultResolver is the resolver used by the package-level Lookup\nfunctions and by Dialers without a specified Resolver.\n"
    :added "1.0"
    :tag "Var"
    :go "net.DefaultResolver"}
  DefaultResolver)

JOKER VARIABLE ErrWriteToConnected from net/net.go:
(def
  ^{:doc "Various errors contained in OpError.\n"
    :added "1.0"
    :tag "Var"
    :go "net.ErrWriteToConnected"}
  ErrWriteToConnected)

JOKER VARIABLE IPv4allrouter from net/ip.go:
(def
  ^{:doc "all routers\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allrouter"}
  IPv4allrouter)

JOKER VARIABLE IPv4allsys from net/ip.go:
(def
  ^{:doc "all systems\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4allsys"}
  IPv4allsys)

JOKER VARIABLE IPv4bcast from net/ip.go:
(def
  ^{:doc "limited broadcast\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4bcast"}
  IPv4bcast)

JOKER VARIABLE IPv4zero from net/ip.go:
(def
  ^{:doc "all zeros\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv4zero"}
  IPv4zero)

JOKER VARIABLE IPv6interfacelocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6interfacelocalallnodes"}
  IPv6interfacelocalallnodes)

JOKER VARIABLE IPv6linklocalallnodes from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallnodes"}
  IPv6linklocalallnodes)

JOKER VARIABLE IPv6linklocalallrouters from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6linklocalallrouters"}
  IPv6linklocalallrouters)

JOKER VARIABLE IPv6loopback from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6loopback"}
  IPv6loopback)

JOKER VARIABLE IPv6unspecified from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6unspecified"}
  IPv6unspecified)

JOKER VARIABLE IPv6zero from net/ip.go:
(def
  ^{:doc "Well-known IPv6 addresses\n"
    :added "1.0"
    :tag "Var"
    :go "net.IPv6zero"}
  IPv6zero)

JOKER TYPE net.Addr from net/net.go:
;; (defn ^"GoObject" Addr.
;;   "Constructor for net.Addr"
;;   {:added "1.0"
;;    :go "_ConstructAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.AddrError from net/net.go:
(defn ^"GoObject" AddrError.
  "Constructor for net.AddrError"
  {:added "1.0"
   :go "_ConstructAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.Buffers from net/net.go:
;; (defn ^"GoObject" Buffers.
;;   "Constructor for net.Buffers"
;;   {:added "1.0"
;;    :go "_ConstructBuffers(_v)"}
;;   [^Object _v])

JOKER TYPE net.Conn from net/net.go:
;; (defn ^"GoObject" Conn.
;;   "Constructor for net.Conn"
;;   {:added "1.0"
;;    :go "_ConstructConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.DNSConfigError from net/net.go:
(defn ^"GoObject" DNSConfigError.
  "Constructor for net.DNSConfigError"
  {:added "1.0"
   :go "_ConstructDNSConfigError(_v)"}
  [^Object _v])

JOKER TYPE net.DNSError from net/net.go:
(defn ^"GoObject" DNSError.
  "Constructor for net.DNSError"
  {:added "1.0"
   :go "_ConstructDNSError(_v)"}
  [^Object _v])

JOKER TYPE net.Dialer from net/dial.go:
;; (defn ^"GoObject" Dialer.
;;   "Constructor for net.Dialer"
;;   {:added "1.0"
;;    :go "_ConstructDialer(_v)"}
;;   [^Object _v])

JOKER TYPE net.Error from net/net.go:
;; (defn ^"GoObject" Error.
;;   "Constructor for net.Error"
;;   {:added "1.0"
;;    :go "_ConstructError(_v)"}
;;   [^Object _v])

JOKER TYPE net.Flags from net/interface.go:
(defn ^"GoObject" Flags.
  "Constructor for net.Flags"
  {:added "1.0"
   :go "_ConstructFlags(_v)"}
  [^Object _v])

JOKER TYPE net.HardwareAddr from net/mac.go:
;; (defn ^"GoObject" HardwareAddr.
;;   "Constructor for net.HardwareAddr"
;;   {:added "1.0"
;;    :go "_ConstructHardwareAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IP from net/ip.go:
;; (defn ^"GoObject" IP.
;;   "Constructor for net.IP"
;;   {:added "1.0"
;;    :go "_ConstructIP(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPAddr from net/iprawsock.go:
;; (defn ^"GoObject" IPAddr.
;;   "Constructor for net.IPAddr"
;;   {:added "1.0"
;;    :go "_ConstructIPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPConn from net/iprawsock.go:
(defn ^"GoObject" IPConn.
  "Constructor for net.IPConn"
  {:added "1.0"
   :go "_ConstructIPConn(_v)"}
  [^Object _v])

JOKER TYPE net.IPMask from net/ip.go:
;; (defn ^"GoObject" IPMask.
;;   "Constructor for net.IPMask"
;;   {:added "1.0"
;;    :go "_ConstructIPMask(_v)"}
;;   [^Object _v])

JOKER TYPE net.IPNet from net/ip.go:
;; (defn ^"GoObject" IPNet.
;;   "Constructor for net.IPNet"
;;   {:added "1.0"
;;    :go "_ConstructIPNet(_v)"}
;;   [^Object _v])

JOKER TYPE net.Interface from net/interface.go:
;; (defn ^"GoObject" Interface.
;;   "Constructor for net.Interface"
;;   {:added "1.0"
;;    :go "_ConstructInterface(_v)"}
;;   [^Object _v])

JOKER TYPE net.InvalidAddrError from net/net.go:
(defn ^"GoObject" InvalidAddrError.
  "Constructor for net.InvalidAddrError"
  {:added "1.0"
   :go "_ConstructInvalidAddrError(_v)"}
  [^Object _v])

JOKER TYPE net.ListenConfig from net/dial.go:
;; (defn ^"GoObject" ListenConfig.
;;   "Constructor for net.ListenConfig"
;;   {:added "1.0"
;;    :go "_ConstructListenConfig(_v)"}
;;   [^Object _v])

JOKER TYPE net.Listener from net/net.go:
;; (defn ^"GoObject" Listener.
;;   "Constructor for net.Listener"
;;   {:added "1.0"
;;    :go "_ConstructListener(_v)"}
;;   [^Object _v])

JOKER TYPE net.MX from net/dnsclient.go:
(defn ^"GoObject" MX.
  "Constructor for net.MX"
  {:added "1.0"
   :go "_ConstructMX(_v)"}
  [^Object _v])

JOKER TYPE net.NS from net/dnsclient.go:
(defn ^"GoObject" NS.
  "Constructor for net.NS"
  {:added "1.0"
   :go "_ConstructNS(_v)"}
  [^Object _v])

JOKER TYPE net.OpError from net/net.go:
;; (defn ^"GoObject" OpError.
;;   "Constructor for net.OpError"
;;   {:added "1.0"
;;    :go "_ConstructOpError(_v)"}
;;   [^Object _v])

JOKER TYPE net.PacketConn from net/net.go:
;; (defn ^"GoObject" PacketConn.
;;   "Constructor for net.PacketConn"
;;   {:added "1.0"
;;    :go "_ConstructPacketConn(_v)"}
;;   [^Object _v])

JOKER TYPE net.ParseError from net/net.go:
(defn ^"GoObject" ParseError.
  "Constructor for net.ParseError"
  {:added "1.0"
   :go "_ConstructParseError(_v)"}
  [^Object _v])

JOKER TYPE net.Resolver from net/lookup.go:
;; (defn ^"GoObject" Resolver.
;;   "Constructor for net.Resolver"
;;   {:added "1.0"
;;    :go "_ConstructResolver(_v)"}
;;   [^Object _v])

JOKER TYPE net.SRV from net/dnsclient.go:
(defn ^"GoObject" SRV.
  "Constructor for net.SRV"
  {:added "1.0"
   :go "_ConstructSRV(_v)"}
  [^Object _v])

JOKER TYPE net.TCPAddr from net/tcpsock.go:
;; (defn ^"GoObject" TCPAddr.
;;   "Constructor for net.TCPAddr"
;;   {:added "1.0"
;;    :go "_ConstructTCPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.TCPConn from net/tcpsock.go:
(defn ^"GoObject" TCPConn.
  "Constructor for net.TCPConn"
  {:added "1.0"
   :go "_ConstructTCPConn(_v)"}
  [^Object _v])

JOKER TYPE net.TCPListener from net/tcpsock.go:
(defn ^"GoObject" TCPListener.
  "Constructor for net.TCPListener"
  {:added "1.0"
   :go "_ConstructTCPListener(_v)"}
  [^Object _v])

JOKER TYPE net.UDPAddr from net/udpsock.go:
;; (defn ^"GoObject" UDPAddr.
;;   "Constructor for net.UDPAddr"
;;   {:added "1.0"
;;    :go "_ConstructUDPAddr(_v)"}
;;   [^Object _v])

JOKER TYPE net.UDPConn from net/udpsock.go:
(defn ^"GoObject" UDPConn.
  "Constructor for net.UDPConn"
  {:added "1.0"
   :go "_ConstructUDPConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixAddr from net/unixsock.go:
(defn ^"GoObject" UnixAddr.
  "Constructor for net.UnixAddr"
  {:added "1.0"
   :go "_ConstructUnixAddr(_v)"}
  [^Object _v])

JOKER TYPE net.UnixConn from net/unixsock.go:
(defn ^"GoObject" UnixConn.
  "Constructor for net.UnixConn"
  {:added "1.0"
   :go "_ConstructUnixConn(_v)"}
  [^Object _v])

JOKER TYPE net.UnixListener from net/unixsock.go:
(defn ^"GoObject" UnixListener.
  "Constructor for net.UnixListener"
  {:added "1.0"
   :go "_ConstructUnixListener(_v)"}
  [^Object _v])

JOKER TYPE net.UnknownNetworkError from net/net.go:
(defn ^"GoObject" UnknownNetworkError.
  "Constructor for net.UnknownNetworkError"
  {:added "1.0"
   :go "_ConstructUnknownNetworkError(_v)"}
  [^Object _v])

JOKER FUNC net.CIDRMask from net/ip.go:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__cIDRMask(__ones, __bits)"}
  [^Int __ones, ^Int __bits])

JOKER FUNC net.Dial from net/dial.go:
(defn Dial
  "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Conn Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.DialIP from net/iprawsock.go:
(defn DialIP
  "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *IPAddr, raddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr, ^(atom-of go.std.net/IPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__dialIP(__network, __laddr, __raddr)"}
  [^String __network, ^net/IPAddr __laddr, ^net/IPAddr __raddr])

JOKER FUNC net.DialTCP from net/tcpsock.go:
(defn DialTCP
  "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *TCPAddr, raddr *TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr, ^(atom-of go.std.net/TCPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/TCPConn) Error]"
  {:added "1.0"
   :go "__dialTCP(__network, __laddr, __raddr)"}
  [^String __network, ^net/TCPAddr __laddr, ^net/TCPAddr __raddr])

JOKER FUNC net.DialTimeout from net/dial.go:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^go.std.time/Duration timeout]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__dialTimeout(__network, __address, *__timeout)"}
;;   [^String __network, ^String __address, ^time/Duration __timeout])

JOKER FUNC net.DialUDP from net/udpsock.go:
(defn DialUDP
  "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *UDPAddr, raddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr, ^(atom-of go.std.net/UDPAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__dialUDP(__network, __laddr, __raddr)"}
  [^String __network, ^net/UDPAddr __laddr, ^net/UDPAddr __raddr])

JOKER FUNC net.DialUnix from net/unixsock.go:
(defn DialUnix
  "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *UnixAddr, raddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr, ^(atom-of go.std.net/UnixAddr) raddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__dialUnix(__network, __laddr, __raddr)"}
  [^String __network, ^net/UnixAddr __laddr, ^net/UnixAddr __raddr])

JOKER FUNC net.FileConn from net/file.go:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Conn Error]"
;;   {:added "1.0"
;;    :go "__fileConn(__f)"}
;;   [^os/File __f])

JOKER FUNC net.FileListener from net/file.go:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/Listener Error]"
;;   {:added "1.0"
;;    :go "__fileListener(__f)"}
;;   [^os/File __f])

JOKER FUNC net.FilePacketConn from net/file.go:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of go.std.os/File) f]\n\nJoker return type: [go.std.net/PacketConn Error]"
;;   {:added "1.0"
;;    :go "__filePacketConn(__f)"}
;;   [^os/File __f])

JOKER FUNC net.IPv4 from net/ip.go:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__iPv4(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.IPv4Mask from net/ip.go:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int a, ^Int b, ^Int c, ^Int d]\n\nJoker return type: go.std.net/IPMask"
  {:added "1.0"
   :go "__iPv4Mask(__a, __b, __c, __d)"}
  [^Byte __a, ^Byte __b, ^Byte __c, ^Byte __d])

JOKER FUNC net.InterfaceAddrs from net/interface.go:
(defn InterfaceAddrs
  "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Addr) Error]"
  {:added "1.0"
   :go "__interfaceAddrs()"}
  [])

JOKER FUNC net.InterfaceByIndex from net/interface.go:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByIndex(__index)"}
  [^Int __index])

JOKER FUNC net.InterfaceByName from net/interface.go:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(atom-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaceByName(__name)"}
  [^String __name])

JOKER FUNC net.Interfaces from net/interface.go:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of go.std.net/Interface) Error]"
  {:added "1.0"
   :go "__interfaces()"}
  [])

JOKER FUNC net.JoinHostPort from net/ipsock.go:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(__host, __port)"}
  [^String __host, ^String __port])

JOKER FUNC net.Listen from net/dial.go:
(defn Listen
  "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/Listener Error]"
  {:added "1.0"
   :go "__listen(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ListenIP from net/iprawsock.go:
(defn ListenIP
  "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/IPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/IPConn) Error]"
  {:added "1.0"
   :go "__listenIP(__network, __laddr)"}
  [^String __network, ^net/IPAddr __laddr])

JOKER FUNC net.ListenMulticastUDP from net/udpsock.go:
(defn ListenMulticastUDP
  "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *Interface, gaddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/Interface) ifi, ^(atom-of go.std.net/UDPAddr) gaddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenMulticastUDP(__network, __ifi, __gaddr)"}
  [^String __network, ^net/Interface __ifi, ^net/UDPAddr __gaddr])

JOKER FUNC net.ListenPacket from net/dial.go:
(defn ListenPacket
  "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [go.std.net/PacketConn Error]"
  {:added "1.0"
   :go "__listenPacket(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ListenTCP from net/tcpsock.go:
(defn ListenTCP
  "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/TCPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/TCPListener) Error]"
  {:added "1.0"
   :go "__listenTCP(__network, __laddr)"}
  [^String __network, ^net/TCPAddr __laddr])

JOKER FUNC net.ListenUDP from net/udpsock.go:
(defn ListenUDP
  "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UDPAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UDPConn) Error]"
  {:added "1.0"
   :go "__listenUDP(__network, __laddr)"}
  [^String __network, ^net/UDPAddr __laddr])

JOKER FUNC net.ListenUnix from net/unixsock.go:
(defn ListenUnix
  "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixListener) Error]"
  {:added "1.0"
   :go "__listenUnix(__network, __laddr)"}
  [^String __network, ^net/UnixAddr __laddr])

JOKER FUNC net.ListenUnixgram from net/unixsock.go:
(defn ListenUnixgram
  "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of go.std.net/UnixAddr) laddr]\n\nJoker return type: [(atom-of go.std.net/UnixConn) Error]"
  {:added "1.0"
   :go "__listenUnixgram(__network, __laddr)"}
  [^String __network, ^net/UnixAddr __laddr])

JOKER FUNC net.LookupAddr from net/lookup.go:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupAddr(__addr)"}
  [^String __addr])

JOKER FUNC net.LookupCNAME from net/lookup.go:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__lookupCNAME(__host)"}
  [^String __host])

JOKER FUNC net.LookupHost from net/lookup.go:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupHost(__host)"}
  [^String __host])

JOKER FUNC net.LookupIP from net/lookup.go:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of go.std.net/IP) Error]"
  {:added "1.0"
   :go "__lookupIP(__host)"}
  [^String __host])

JOKER FUNC net.LookupMX from net/lookup.go:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/MX)) Error]"
  {:added "1.0"
   :go "__lookupMX(__name)"}
  [^String __name])

JOKER FUNC net.LookupNS from net/lookup.go:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of (atom-of go.std.net/NS)) Error]"
  {:added "1.0"
   :go "__lookupNS(__name)"}
  [^String __name])

JOKER FUNC net.LookupPort from net/lookup.go:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "__lookupPort(__network, __service)"}
  [^String __network, ^String __service])

JOKER FUNC net.LookupSRV from net/lookup.go:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of (atom-of go.std.net/SRV)) Error]"
  {:added "1.0"
   :go "__lookupSRV(__service, __proto, __name)"}
  [^String __service, ^String __proto, ^String __name])

JOKER FUNC net.LookupTXT from net/lookup.go:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "__lookupTXT(__name)"}
  [^String __name])

JOKER FUNC net.ParseCIDR from net/ip.go:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/IP (atom-of go.std.net/IPNet) Error]"
  {:added "1.0"
   :go "__parseCIDR(__s)"}
  [^String __s])

JOKER FUNC net.ParseIP from net/ip.go:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: go.std.net/IP"
  {:added "1.0"
   :go "__parseIP(__s)"}
  [^String __s])

JOKER FUNC net.ParseMAC from net/mac.go:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [go.std.net/HardwareAddr Error]"
  {:added "1.0"
   :go "__parseMAC(__s)"}
  [^String __s])

JOKER FUNC net.Pipe from net/pipe.go:
(defn Pipe
  "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [go.std.net/Conn go.std.net/Conn]"
  {:added "1.0"
   :go "__pipe()"}
  [])

JOKER FUNC net.ResolveIPAddr from net/iprawsock.go:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/IPAddr) Error]"
  {:added "1.0"
   :go "__resolveIPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveTCPAddr from net/tcpsock.go:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/TCPAddr) Error]"
  {:added "1.0"
   :go "__resolveTCPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveUDPAddr from net/udpsock.go:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UDPAddr) Error]"
  {:added "1.0"
   :go "__resolveUDPAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.ResolveUnixAddr from net/unixsock.go:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net/UnixAddr) Error]"
  {:added "1.0"
   :go "__resolveUnixAddr(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net.SplitHostPort from net/ipsock.go:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "__splitHostPort(__hostport)"}
  [^String __hostport])

JOKER TYPE go.std.net/Addr:
(def
  ^{:doc "Addr represents a network end point address.\n\nThe two methods Network and String conventionally return strings\nthat can be passed as the arguments to Dial, but the exact form\nand meaning of the strings is up to the implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Addr"}
  Addr)

JOKER TYPE go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_AddrError"}
  AddrError)

JOKER TYPE *go.std.net/AddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddrError"}
  *AddrError)

JOKER TYPE go.std.net/Buffers:
(def
  ^{:doc "Buffers contains zero or more runs of bytes to write.\n\nOn certain machines, for certain types of connections, this is\noptimized into an OS-specific batch write operation (such as\n\"writev\").\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Buffers"}
  Buffers)

JOKER TYPE *go.std.net/Buffers:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Buffers"}
  *Buffers)

JOKER TYPE go.std.net/Conn:
(def
  ^{:doc "Conn is a generic stream-oriented network connection.\n\nMultiple goroutines may invoke methods on a Conn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE go.std.net/DNSConfigError:
(def
  ^{:doc "DNSConfigError represents an error reading the machine's DNS configuration.\n(No longer used; kept for compatibility.)\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSConfigError"}
  DNSConfigError)

JOKER TYPE *go.std.net/DNSConfigError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSConfigError"}
  *DNSConfigError)

JOKER TYPE go.std.net/DNSError:
(def
  ^{:doc "DNSError represents a DNS lookup error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSError"}
  DNSError)

JOKER TYPE *go.std.net/DNSError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSError"}
  *DNSError)

JOKER TYPE go.std.net/Dialer:
(def
  ^{:doc "A Dialer contains options for connecting to an address.\n\nThe zero value for each field is equivalent to dialing\nwithout that option. Dialing with the zero value of Dialer\nis therefore equivalent to just calling the Dial function.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dialer"}
  Dialer)

JOKER TYPE *go.std.net/Dialer:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Dialer"}
  *Dialer)

JOKER TYPE go.std.net/Error:
(def
  ^{:doc "An Error represents a network error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE go.std.net/Flags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_Flags"}
  Flags)

JOKER TYPE *go.std.net/Flags:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Flags"}
  *Flags)

JOKER TYPE go.std.net/HardwareAddr:
(def
  ^{:doc "A HardwareAddr represents a physical hardware address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HardwareAddr"}
  HardwareAddr)

JOKER TYPE *go.std.net/HardwareAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_HardwareAddr"}
  *HardwareAddr)

JOKER TYPE go.std.net/IP:
(def
  ^{:doc "An IP is a single IP address, a slice of bytes.\nFunctions in this package accept either 4-byte (IPv4)\nor 16-byte (IPv6) slices as input.\n\nNote that in this documentation, referring to an\nIP address as an IPv4 address or an IPv6 address\nis a semantic property of the address, not just the\nlength of the byte slice: a 16-byte slice can still\nbe an IPv4 address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IP"}
  IP)

JOKER TYPE *go.std.net/IP:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IP"}
  *IP)

JOKER TYPE go.std.net/IPAddr:
(def
  ^{:doc "IPAddr represents the address of an IP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPAddr"}
  IPAddr)

JOKER TYPE *go.std.net/IPAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPAddr"}
  *IPAddr)

JOKER TYPE go.std.net/IPConn:
(def
  ^{:doc "IPConn is the implementation of the Conn and PacketConn interfaces\nfor IP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPConn"}
  IPConn)

JOKER TYPE *go.std.net/IPConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPConn"}
  *IPConn)

JOKER TYPE go.std.net/IPMask:
(def
  ^{:doc "An IP mask is an IP address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPMask"}
  IPMask)

JOKER TYPE *go.std.net/IPMask:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPMask"}
  *IPMask)

JOKER TYPE go.std.net/IPNet:
(def
  ^{:doc "An IPNet represents an IP network.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_IPNet"}
  IPNet)

JOKER TYPE *go.std.net/IPNet:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_IPNet"}
  *IPNet)

JOKER TYPE go.std.net/Interface:
(def
  ^{:doc "Interface represents a mapping between network interface name\nand index. It also represents network interface facility\ninformation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Interface"}
  Interface)

JOKER TYPE *go.std.net/Interface:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Interface"}
  *Interface)

JOKER TYPE go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidAddrError"}
  InvalidAddrError)

JOKER TYPE *go.std.net/InvalidAddrError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidAddrError"}
  *InvalidAddrError)

JOKER TYPE go.std.net/ListenConfig:
(def
  ^{:doc "ListenConfig contains options for listening to an address.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ListenConfig"}
  ListenConfig)

JOKER TYPE *go.std.net/ListenConfig:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ListenConfig"}
  *ListenConfig)

JOKER TYPE go.std.net/Listener:
(def
  ^{:doc "A Listener is a generic network listener for stream-oriented protocols.\n\nMultiple goroutines may invoke methods on a Listener simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Listener"}
  Listener)

JOKER TYPE go.std.net/MX:
(def
  ^{:doc "An MX represents a single DNS MX record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MX"}
  MX)

JOKER TYPE *go.std.net/MX:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MX"}
  *MX)

JOKER TYPE go.std.net/NS:
(def
  ^{:doc "An NS represents a single DNS NS record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_NS"}
  NS)

JOKER TYPE *go.std.net/NS:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_NS"}
  *NS)

JOKER TYPE go.std.net/OpError:
(def
  ^{:doc "OpError is the error type usually returned by functions in the net\npackage. It describes the operation, network type, and address of\nan error.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_OpError"}
  OpError)

JOKER TYPE *go.std.net/OpError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_OpError"}
  *OpError)

JOKER TYPE go.std.net/PacketConn:
(def
  ^{:doc "PacketConn is a generic packet-oriented network connection.\n\nMultiple goroutines may invoke methods on a PacketConn simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PacketConn"}
  PacketConn)

JOKER TYPE go.std.net/ParseError:
(def
  ^{:doc "A ParseError is the error type of literal network address parsers.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ParseError"}
  ParseError)

JOKER TYPE *go.std.net/ParseError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ParseError"}
  *ParseError)

JOKER TYPE go.std.net/Resolver:
(def
  ^{:doc "A Resolver looks up names and numbers.\n\nA nil *Resolver is equivalent to a zero Resolver.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Resolver"}
  Resolver)

JOKER TYPE *go.std.net/Resolver:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Resolver"}
  *Resolver)

JOKER TYPE go.std.net/SRV:
(def
  ^{:doc "An SRV represents a single DNS SRV record.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SRV"}
  SRV)

JOKER TYPE *go.std.net/SRV:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SRV"}
  *SRV)

JOKER TYPE go.std.net/TCPAddr:
(def
  ^{:doc "TCPAddr represents the address of a TCP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPAddr"}
  TCPAddr)

JOKER TYPE *go.std.net/TCPAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPAddr"}
  *TCPAddr)

JOKER TYPE go.std.net/TCPConn:
(def
  ^{:doc "TCPConn is an implementation of the Conn interface for TCP network\nconnections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPConn"}
  TCPConn)

JOKER TYPE *go.std.net/TCPConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPConn"}
  *TCPConn)

JOKER TYPE go.std.net/TCPListener:
(def
  ^{:doc "TCPListener is a TCP network listener. Clients should typically\nuse variables of type Listener instead of assuming TCP.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_TCPListener"}
  TCPListener)

JOKER TYPE *go.std.net/TCPListener:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_TCPListener"}
  *TCPListener)

JOKER TYPE go.std.net/UDPAddr:
(def
  ^{:doc "UDPAddr represents the address of a UDP end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPAddr"}
  UDPAddr)

JOKER TYPE *go.std.net/UDPAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UDPAddr"}
  *UDPAddr)

JOKER TYPE go.std.net/UDPConn:
(def
  ^{:doc "UDPConn is the implementation of the Conn and PacketConn interfaces\nfor UDP network connections.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UDPConn"}
  UDPConn)

JOKER TYPE *go.std.net/UDPConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UDPConn"}
  *UDPConn)

JOKER TYPE go.std.net/UnixAddr:
(def
  ^{:doc "UnixAddr represents the address of a Unix domain socket end point.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixAddr"}
  UnixAddr)

JOKER TYPE *go.std.net/UnixAddr:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixAddr"}
  *UnixAddr)

JOKER TYPE go.std.net/UnixConn:
(def
  ^{:doc "UnixConn is an implementation of the Conn interface for connections\nto Unix domain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixConn"}
  UnixConn)

JOKER TYPE *go.std.net/UnixConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixConn"}
  *UnixConn)

JOKER TYPE go.std.net/UnixListener:
(def
  ^{:doc "UnixListener is a Unix domain socket listener. Clients should\ntypically use variables of type Listener instead of assuming Unix\ndomain sockets.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_UnixListener"}
  UnixListener)

JOKER TYPE *go.std.net/UnixListener:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnixListener"}
  *UnixListener)

JOKER TYPE go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_UnknownNetworkError"}
  UnknownNetworkError)

JOKER TYPE *go.std.net/UnknownNetworkError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_UnknownNetworkError"}
  *UnknownNetworkError)

JOKER CONSTANT DefaultMaxHeaderBytes from net/http/server.go:
(def
  ^{:doc "1 MB\n"
    :added "1.0"
    :tag "Number"
    :go "int64(http.DefaultMaxHeaderBytes)"}
  DefaultMaxHeaderBytes)

JOKER CONSTANT DefaultMaxIdleConnsPerHost from net/http/transport.go:
(def
  ^{:doc "DefaultMaxIdleConnsPerHost is the default value of Transport's\nMaxIdleConnsPerHost.\n"
    :added "1.0"
    :tag "Int"
    :go "http.DefaultMaxIdleConnsPerHost"}
  DefaultMaxIdleConnsPerHost)

JOKER CONSTANT MethodConnect from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodConnect"}
  MethodConnect)

JOKER CONSTANT MethodDelete from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodDelete"}
  MethodDelete)

JOKER CONSTANT MethodGet from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodGet"}
  MethodGet)

JOKER CONSTANT MethodHead from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodHead"}
  MethodHead)

JOKER CONSTANT MethodOptions from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodOptions"}
  MethodOptions)

JOKER CONSTANT MethodPatch from net/http/method.go:
(def
  ^{:doc "RFC 5789\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPatch"}
  MethodPatch)

JOKER CONSTANT MethodPost from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPost"}
  MethodPost)

JOKER CONSTANT MethodPut from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodPut"}
  MethodPut)

JOKER CONSTANT MethodTrace from net/http/method.go:
(def
  ^{:doc "Common HTTP methods.\n\nUnless otherwise noted, these are defined in RFC 7231 section 4.3.\n"
    :added "1.0"
    :tag "String"
    :go "http.MethodTrace"}
  MethodTrace)

JOKER CONSTANT SameSiteDefaultMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteDefaultMode)"}
  SameSiteDefaultMode)

JOKER CONSTANT SameSiteLaxMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteLaxMode)"}
  SameSiteLaxMode)

JOKER CONSTANT SameSiteStrictMode from net/http/cookie.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Int"
    :go "int(http.SameSiteStrictMode)"}
  SameSiteStrictMode)

JOKER CONSTANT StateActive from net/http/server.go:
(def
  ^{:doc "StateActive represents a connection that has read 1 or more\nbytes of a request. The Server.ConnState hook for\nStateActive fires before the request has entered a handler\nand doesn't fire again until the request has been\nhandled. After the request is handled, the state\ntransitions to StateClosed, StateHijacked, or StateIdle.\nFor HTTP/2, StateActive fires on the transition from zero\nto one active request, and only transitions away once all\nactive requests are complete. That means that ConnState\ncannot be used to do per-request work; ConnState only notes\nthe overall state of the connection.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateActive)"}
  StateActive)

JOKER CONSTANT StateClosed from net/http/server.go:
(def
  ^{:doc "StateClosed represents a closed connection.\nThis is a terminal state. Hijacked connections do not\ntransition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateClosed)"}
  StateClosed)

JOKER CONSTANT StateHijacked from net/http/server.go:
(def
  ^{:doc "StateHijacked represents a hijacked connection.\nThis is a terminal state. It does not transition to StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateHijacked)"}
  StateHijacked)

JOKER CONSTANT StateIdle from net/http/server.go:
(def
  ^{:doc "StateIdle represents a connection that has finished\nhandling a request and is in the keep-alive state, waiting\nfor a new request. Connections transition from StateIdle\nto either StateActive or StateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateIdle)"}
  StateIdle)

JOKER CONSTANT StateNew from net/http/server.go:
(def
  ^{:doc "StateNew represents a new connection that is expected to\nsend a request immediately. Connections begin at this\nstate and then transition to either StateActive or\nStateClosed.\n"
    :added "1.0"
    :tag "Int"
    :go "int(http.StateNew)"}
  StateNew)

JOKER CONSTANT StatusAccepted from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusAccepted"}
  StatusAccepted)

JOKER CONSTANT StatusAlreadyReported from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusAlreadyReported"}
  StatusAlreadyReported)

JOKER CONSTANT StatusBadGateway from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusBadGateway"}
  StatusBadGateway)

JOKER CONSTANT StatusBadRequest from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusBadRequest"}
  StatusBadRequest)

JOKER CONSTANT StatusConflict from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.8\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusConflict"}
  StatusConflict)

JOKER CONSTANT StatusContinue from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusContinue"}
  StatusContinue)

JOKER CONSTANT StatusCreated from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusCreated"}
  StatusCreated)

JOKER CONSTANT StatusExpectationFailed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.14\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusExpectationFailed"}
  StatusExpectationFailed)

JOKER CONSTANT StatusFailedDependency from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusFailedDependency"}
  StatusFailedDependency)

JOKER CONSTANT StatusForbidden from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusForbidden"}
  StatusForbidden)

JOKER CONSTANT StatusFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusFound"}
  StatusFound)

JOKER CONSTANT StatusGatewayTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusGatewayTimeout"}
  StatusGatewayTimeout)

JOKER CONSTANT StatusGone from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.9\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusGone"}
  StatusGone)

JOKER CONSTANT StatusHTTPVersionNotSupported from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusHTTPVersionNotSupported"}
  StatusHTTPVersionNotSupported)

JOKER CONSTANT StatusIMUsed from net/http/status.go:
(def
  ^{:doc "RFC 3229, 10.4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusIMUsed"}
  StatusIMUsed)

JOKER CONSTANT StatusInsufficientStorage from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusInsufficientStorage"}
  StatusInsufficientStorage)

JOKER CONSTANT StatusInternalServerError from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusInternalServerError"}
  StatusInternalServerError)

JOKER CONSTANT StatusLengthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.10\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLengthRequired"}
  StatusLengthRequired)

JOKER CONSTANT StatusLocked from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLocked"}
  StatusLocked)

JOKER CONSTANT StatusLoopDetected from net/http/status.go:
(def
  ^{:doc "RFC 5842, 7.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusLoopDetected"}
  StatusLoopDetected)

JOKER CONSTANT StatusMethodNotAllowed from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMethodNotAllowed"}
  StatusMethodNotAllowed)

JOKER CONSTANT StatusMisdirectedRequest from net/http/status.go:
(def
  ^{:doc "RFC 7540, 9.1.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMisdirectedRequest"}
  StatusMisdirectedRequest)

JOKER CONSTANT StatusMovedPermanently from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMovedPermanently"}
  StatusMovedPermanently)

JOKER CONSTANT StatusMultiStatus from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMultiStatus"}
  StatusMultiStatus)

JOKER CONSTANT StatusMultipleChoices from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusMultipleChoices"}
  StatusMultipleChoices)

JOKER CONSTANT StatusNetworkAuthenticationRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNetworkAuthenticationRequired"}
  StatusNetworkAuthenticationRequired)

JOKER CONSTANT StatusNoContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNoContent"}
  StatusNoContent)

JOKER CONSTANT StatusNonAuthoritativeInfo from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNonAuthoritativeInfo"}
  StatusNonAuthoritativeInfo)

JOKER CONSTANT StatusNotAcceptable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotAcceptable"}
  StatusNotAcceptable)

JOKER CONSTANT StatusNotExtended from net/http/status.go:
(def
  ^{:doc "RFC 2774, 7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotExtended"}
  StatusNotExtended)

JOKER CONSTANT StatusNotFound from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotFound"}
  StatusNotFound)

JOKER CONSTANT StatusNotImplemented from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotImplemented"}
  StatusNotImplemented)

JOKER CONSTANT StatusNotModified from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusNotModified"}
  StatusNotModified)

JOKER CONSTANT StatusOK from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusOK"}
  StatusOK)

JOKER CONSTANT StatusPartialContent from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPartialContent"}
  StatusPartialContent)

JOKER CONSTANT StatusPaymentRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPaymentRequired"}
  StatusPaymentRequired)

JOKER CONSTANT StatusPermanentRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7538, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPermanentRedirect"}
  StatusPermanentRedirect)

JOKER CONSTANT StatusPreconditionFailed from net/http/status.go:
(def
  ^{:doc "RFC 7232, 4.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPreconditionFailed"}
  StatusPreconditionFailed)

JOKER CONSTANT StatusPreconditionRequired from net/http/status.go:
(def
  ^{:doc "RFC 6585, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusPreconditionRequired"}
  StatusPreconditionRequired)

JOKER CONSTANT StatusProcessing from net/http/status.go:
(def
  ^{:doc "RFC 2518, 10.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusProcessing"}
  StatusProcessing)

JOKER CONSTANT StatusProxyAuthRequired from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusProxyAuthRequired"}
  StatusProxyAuthRequired)

JOKER CONSTANT StatusRequestEntityTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.11\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestEntityTooLarge"}
  StatusRequestEntityTooLarge)

JOKER CONSTANT StatusRequestHeaderFieldsTooLarge from net/http/status.go:
(def
  ^{:doc "RFC 6585, 5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestHeaderFieldsTooLarge"}
  StatusRequestHeaderFieldsTooLarge)

JOKER CONSTANT StatusRequestTimeout from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestTimeout"}
  StatusRequestTimeout)

JOKER CONSTANT StatusRequestURITooLong from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.12\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestURITooLong"}
  StatusRequestURITooLong)

JOKER CONSTANT StatusRequestedRangeNotSatisfiable from net/http/status.go:
(def
  ^{:doc "RFC 7233, 4.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusRequestedRangeNotSatisfiable"}
  StatusRequestedRangeNotSatisfiable)

JOKER CONSTANT StatusResetContent from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.3.6\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusResetContent"}
  StatusResetContent)

JOKER CONSTANT StatusSeeOther from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusSeeOther"}
  StatusSeeOther)

JOKER CONSTANT StatusServiceUnavailable from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.6.4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusServiceUnavailable"}
  StatusServiceUnavailable)

JOKER CONSTANT StatusSwitchingProtocols from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.2.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusSwitchingProtocols"}
  StatusSwitchingProtocols)

JOKER CONSTANT StatusTeapot from net/http/status.go:
(def
  ^{:doc "RFC 7168, 2.3.3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTeapot"}
  StatusTeapot)

JOKER CONSTANT StatusTemporaryRedirect from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.7\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTemporaryRedirect"}
  StatusTemporaryRedirect)

JOKER CONSTANT StatusTooManyRequests from net/http/status.go:
(def
  ^{:doc "RFC 6585, 4\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusTooManyRequests"}
  StatusTooManyRequests)

JOKER CONSTANT StatusUnauthorized from net/http/status.go:
(def
  ^{:doc "RFC 7235, 3.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnauthorized"}
  StatusUnauthorized)

JOKER CONSTANT StatusUnavailableForLegalReasons from net/http/status.go:
(def
  ^{:doc "RFC 7725, 3\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnavailableForLegalReasons"}
  StatusUnavailableForLegalReasons)

JOKER CONSTANT StatusUnprocessableEntity from net/http/status.go:
(def
  ^{:doc "RFC 4918, 11.2\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnprocessableEntity"}
  StatusUnprocessableEntity)

JOKER CONSTANT StatusUnsupportedMediaType from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.13\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUnsupportedMediaType"}
  StatusUnsupportedMediaType)

JOKER CONSTANT StatusUpgradeRequired from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.5.15\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUpgradeRequired"}
  StatusUpgradeRequired)

JOKER CONSTANT StatusUseProxy from net/http/status.go:
(def
  ^{:doc "RFC 7231, 6.4.5\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusUseProxy"}
  StatusUseProxy)

JOKER CONSTANT StatusVariantAlsoNegotiates from net/http/status.go:
(def
  ^{:doc "RFC 2295, 8.1\n"
    :added "1.0"
    :tag "Int"
    :go "http.StatusVariantAlsoNegotiates"}
  StatusVariantAlsoNegotiates)

JOKER CONSTANT TimeFormat from net/http/server.go:
(def
  ^{:doc "TimeFormat is the time format to use when generating times in HTTP\nheaders. It is like time.RFC1123 but hard-codes GMT as the time\nzone. The time being formatted must be in UTC for Format to\ngenerate the correct format.\n\nFor parsing this time format, see ParseTime.\n"
    :added "1.0"
    :tag "String"
    :go "http.TimeFormat"}
  TimeFormat)

JOKER CONSTANT TrailerPrefix from net/http/server.go:
(def
  ^{:doc "TrailerPrefix is a magic prefix for ResponseWriter.Header map keys\nthat, if present, signals that the map entry is actually for\nthe response trailers, and not the response headers. The prefix\nis stripped after the ServeHTTP call finishes and the values are\nsent in the trailers.\n\nThis mechanism is intended only for trailers that are not known\nprior to the headers being written. If the set of trailers is fixed\nor known before the header is written, the normal Go trailers mechanism\nis preferred:\n   https://golang.org/pkg/net/http/#ResponseWriter\n   https://golang.org/pkg/net/http/#example_ResponseWriter_trailers\n"
    :added "1.0"
    :tag "String"
    :go "http.TrailerPrefix"}
  TrailerPrefix)

JOKER VARIABLE DefaultClient from net/http/client.go:
(def
  ^{:doc "DefaultClient is the default Client and is used by Get, Head, and Post.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultClient"}
  DefaultClient)

JOKER VARIABLE DefaultServeMux from net/http/server.go:
(def
  ^{:doc "DefaultServeMux is the default ServeMux used by Serve.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultServeMux"}
  DefaultServeMux)

JOKER VARIABLE DefaultTransport from net/http/transport.go:
(def
  ^{:doc "DefaultTransport is the default implementation of Transport and is\nused by DefaultClient. It establishes network connections as needed\nand caches them for reuse by subsequent calls. It uses HTTP proxies\nas directed by the $HTTP_PROXY and $NO_PROXY (or $http_proxy and\n$no_proxy) environment variables.\n"
    :added "1.0"
    :tag "Var"
    :go "http.DefaultTransport"}
  DefaultTransport)

JOKER VARIABLE ErrAbortHandler from net/http/server.go:
(def
  ^{:doc "ErrAbortHandler is a sentinel panic value to abort a handler.\nWhile any panic from ServeHTTP aborts the response to the client,\npanicking with ErrAbortHandler also suppresses logging of a stack\ntrace to the server's error log.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrAbortHandler"}
  ErrAbortHandler)

JOKER VARIABLE ErrBodyNotAllowed from net/http/server.go:
(def
  ^{:doc "ErrBodyNotAllowed is returned by ResponseWriter.Write calls\nwhen the HTTP method or response code does not permit a\nbody.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyNotAllowed"}
  ErrBodyNotAllowed)

JOKER VARIABLE ErrBodyReadAfterClose from net/http/transfer.go:
(def
  ^{:doc "ErrBodyReadAfterClose is returned when reading a Request or Response\nBody after the body has been closed. This typically happens when the body is\nread after an HTTP Handler calls WriteHeader or Write on its\nResponseWriter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrBodyReadAfterClose"}
  ErrBodyReadAfterClose)

JOKER VARIABLE ErrContentLength from net/http/server.go:
(def
  ^{:doc "ErrContentLength is returned by ResponseWriter.Write calls\nwhen a Handler set a Content-Length response header with a\ndeclared size and then attempted to write more bytes than\ndeclared.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrContentLength"}
  ErrContentLength)

JOKER VARIABLE ErrHandlerTimeout from net/http/server.go:
(def
  ^{:doc "ErrHandlerTimeout is returned on ResponseWriter Write calls\nin handlers which have timed out.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHandlerTimeout"}
  ErrHandlerTimeout)

JOKER VARIABLE ErrHeaderTooLong from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrHeaderTooLong is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHeaderTooLong"}
  ErrHeaderTooLong)

JOKER VARIABLE ErrHijacked from net/http/server.go:
(def
  ^{:doc "ErrHijacked is returned by ResponseWriter.Write calls when\nthe underlying connection has been hijacked using the\nHijacker interface. A zero-byte write on a hijacked\nconnection will return ErrHijacked without any other side\neffects.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrHijacked"}
  ErrHijacked)

JOKER VARIABLE ErrLineTooLong from net/http/transfer.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading request or response bodies\nwith malformed chunked encoding.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrLineTooLong"}
  ErrLineTooLong)

JOKER VARIABLE ErrMissingBoundary from net/http/request.go:
(def
  ^{:doc "ErrMissingBoundary is returned by Request.MultipartReader when the\nrequest's Content-Type does not include a \"boundary\" parameter.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingBoundary"}
  ErrMissingBoundary)

JOKER VARIABLE ErrMissingContentLength from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrMissingContentLength is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingContentLength"}
  ErrMissingContentLength)

JOKER VARIABLE ErrMissingFile from net/http/request.go:
(def
  ^{:doc "ErrMissingFile is returned by FormFile when the provided file field name\nis either not present in the request or not a file field.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrMissingFile"}
  ErrMissingFile)

JOKER VARIABLE ErrNoCookie from net/http/request.go:
(def
  ^{:doc "ErrNoCookie is returned by Request's Cookie method when a cookie is not found.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoCookie"}
  ErrNoCookie)

JOKER VARIABLE ErrNoLocation from net/http/response.go:
(def
  ^{:doc "ErrNoLocation is returned by Response's Location method\nwhen no Location header is present.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNoLocation"}
  ErrNoLocation)

JOKER VARIABLE ErrNotMultipart from net/http/request.go:
(def
  ^{:doc "ErrNotMultipart is returned by Request.MultipartReader when the\nrequest's Content-Type is not multipart/form-data.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotMultipart"}
  ErrNotMultipart)

JOKER VARIABLE ErrNotSupported from net/http/request.go:
(def
  ^{:doc "ErrNotSupported is returned by the Push method of Pusher\nimplementations to indicate that HTTP/2 Push support is not\navailable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrNotSupported"}
  ErrNotSupported)

JOKER VARIABLE ErrServerClosed from net/http/server.go:
(def
  ^{:doc "ErrServerClosed is returned by the Server's Serve, ServeTLS, ListenAndServe,\nand ListenAndServeTLS methods after a call to Shutdown or Close.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrServerClosed"}
  ErrServerClosed)

JOKER VARIABLE ErrShortBody from net/http/request.go:
(def
  ^{:doc "Deprecated: ErrShortBody is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrShortBody"}
  ErrShortBody)

JOKER VARIABLE ErrSkipAltProtocol from net/http/transport.go:
(def
  ^{:doc "ErrSkipAltProtocol is a sentinel error value defined by Transport.RegisterProtocol.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrSkipAltProtocol"}
  ErrSkipAltProtocol)

JOKER VARIABLE ErrUnexpectedTrailer from net/http/request.go:
(def
  ^{:doc "ErrUnexpectedTrailer is returned by the Transport when a server\nreplies with a Trailer header, but without a chunked reply.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUnexpectedTrailer"}
  ErrUnexpectedTrailer)

JOKER VARIABLE ErrUseLastResponse from net/http/client.go:
(def
  ^{:doc "ErrUseLastResponse can be returned by Client.CheckRedirect hooks to\ncontrol how redirects are processed. If returned, the next request\nis not sent and the most recent response is returned with its body\nunclosed.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrUseLastResponse"}
  ErrUseLastResponse)

JOKER VARIABLE ErrWriteAfterFlush from net/http/server.go:
(def
  ^{:doc "Deprecated: ErrWriteAfterFlush is no longer returned by\nanything in the net/http package. Callers should not\ncompare errors against this variable.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ErrWriteAfterFlush"}
  ErrWriteAfterFlush)

JOKER VARIABLE LocalAddrContextKey from net/http/server.go:
(def
  ^{:doc "LocalAddrContextKey is a context key. It can be used in\nHTTP handlers with context.WithValue to access the local\naddress the connection arrived on.\nThe associated value will be of type net.Addr.\n"
    :added "1.0"
    :tag "Var"
    :go "http.LocalAddrContextKey"}
  LocalAddrContextKey)

JOKER VARIABLE NoBody from net/http/http.go:
(def
  ^{:doc "NoBody is an io.ReadCloser with no bytes. Read always returns EOF\nand Close always returns nil. It can be used in an outgoing client\nrequest to explicitly signal that a request has zero bytes.\nAn alternative, however, is to simply set Request.Body to nil.\n"
    :added "1.0"
    :tag "Var"
    :go "http.NoBody"}
  NoBody)

JOKER VARIABLE ServerContextKey from net/http/server.go:
(def
  ^{:doc "ServerContextKey is a context key. It can be used in HTTP\nhandlers with context.WithValue to access the server that\nstarted the handler. The associated value will be of\ntype *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "http.ServerContextKey"}
  ServerContextKey)

JOKER TYPE net/http.Client from net/http/client.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for http.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CloseNotifier from net/http/server.go:
;; (defn ^"GoObject" CloseNotifier.
;;   "Constructor for http.CloseNotifier"
;;   {:added "1.0"
;;    :go "_ConstructCloseNotifier(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ConnState from net/http/server.go:
(defn ^"GoObject" ConnState.
  "Constructor for http.ConnState"
  {:added "1.0"
   :go "_ConstructConnState(_v)"}
  [^Object _v])

JOKER TYPE net/http.Cookie from net/http/cookie.go:
;; (defn ^"GoObject" Cookie.
;;   "Constructor for http.Cookie"
;;   {:added "1.0"
;;    :go "_ConstructCookie(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.CookieJar from net/http/jar.go:
;; (defn ^"GoObject" CookieJar.
;;   "Constructor for http.CookieJar"
;;   {:added "1.0"
;;    :go "_ConstructCookieJar(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Dir from net/http/fs.go:
(defn ^"GoObject" Dir.
  "Constructor for http.Dir"
  {:added "1.0"
   :go "_ConstructDir(_v)"}
  [^Object _v])

JOKER TYPE net/http.File from net/http/fs.go:
;; (defn ^"GoObject" File.
;;   "Constructor for http.File"
;;   {:added "1.0"
;;    :go "_ConstructFile(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.FileSystem from net/http/fs.go:
;; (defn ^"GoObject" FileSystem.
;;   "Constructor for http.FileSystem"
;;   {:added "1.0"
;;    :go "_ConstructFileSystem(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Flusher from net/http/server.go:
;; (defn ^"GoObject" Flusher.
;;   "Constructor for http.Flusher"
;;   {:added "1.0"
;;    :go "_ConstructFlusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Handler from net/http/server.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for http.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.HandlerFunc from net/http/server.go:
;; (defn ^"GoObject" HandlerFunc.
;;   "Constructor for http.HandlerFunc"
;;   {:added "1.0"
;;    :go "_ConstructHandlerFunc(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Header from net/http/header.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for http.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Hijacker from net/http/server.go:
;; (defn ^"GoObject" Hijacker.
;;   "Constructor for http.Hijacker"
;;   {:added "1.0"
;;    :go "_ConstructHijacker(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ProtocolError from net/http/request.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for http.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/http.PushOptions from net/http/http.go:
;; (defn ^"GoObject" PushOptions.
;;   "Constructor for http.PushOptions"
;;   {:added "1.0"
;;    :go "_ConstructPushOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Pusher from net/http/http.go:
;; (defn ^"GoObject" Pusher.
;;   "Constructor for http.Pusher"
;;   {:added "1.0"
;;    :go "_ConstructPusher(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Request from net/http/request.go:
;; (defn ^"GoObject" Request.
;;   "Constructor for http.Request"
;;   {:added "1.0"
;;    :go "_ConstructRequest(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Response from net/http/response.go:
;; (defn ^"GoObject" Response.
;;   "Constructor for http.Response"
;;   {:added "1.0"
;;    :go "_ConstructResponse(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.ResponseWriter from net/http/server.go:
;; (defn ^"GoObject" ResponseWriter.
;;   "Constructor for http.ResponseWriter"
;;   {:added "1.0"
;;    :go "_ConstructResponseWriter(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.RoundTripper from net/http/client.go:
;; (defn ^"GoObject" RoundTripper.
;;   "Constructor for http.RoundTripper"
;;   {:added "1.0"
;;    :go "_ConstructRoundTripper(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.SameSite from net/http/cookie.go:
(defn ^"GoObject" SameSite.
  "Constructor for http.SameSite"
  {:added "1.0"
   :go "_ConstructSameSite(_v)"}
  [^Object _v])

JOKER TYPE net/http.ServeMux from net/http/server.go:
(defn ^"GoObject" ServeMux.
  "Constructor for http.ServeMux"
  {:added "1.0"
   :go "_ConstructServeMux(_v)"}
  [^Object _v])

JOKER TYPE net/http.Server from net/http/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for http.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER TYPE net/http.Transport from net/http/transport.go:
;; (defn ^"GoObject" Transport.
;;   "Constructor for http.Transport"
;;   {:added "1.0"
;;    :go "_ConstructTransport(_v)"}
;;   [^Object _v])

JOKER FUNC net/http.CanonicalHeaderKey from net/http/header.go:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(__s)"}
  [^String __s])

JOKER FUNC net/http.DetectContentType from net/http/sniff.go:
;; (defn ^"String" DetectContentType
;;   "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Int) data]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "http.DetectContentType(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__data)))"}
;;   [^Object __data])

JOKER FUNC net/http.Error from net/http/server.go:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w ResponseWriter, error string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "__error(*__w, __error, __code)"}
;;   [^http/ResponseWriter __w, ^String __error, ^Int __code])

JOKER FUNC net/http.FileServer from net/http/fs.go:
(defn FileServer
  "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/FileSystem root]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__fileServer(*__root)"}
  [^http/FileSystem __root])

JOKER FUNC net/http.Get from net/http/client.go:
(defn Get
  "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__get(__url)"}
  [^String __url])

JOKER FUNC net/http.Handle from net/http/server.go:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler Handler)\n\nJoker input arguments: [^String pattern, ^go.std.net.http/Handler handler]"
;;   {:added "1.0"
;;    :go "__handle(__pattern, *__handler)"}
;;   [^String __pattern, ^http/Handler __handler])

JOKER FUNC net/http.HandleFunc from net/http/server.go:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "__handleFunc(__pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))"}
;;   [^String __pattern, ^fn __handler])

JOKER FUNC net/http.Head from net/http/client.go:
(defn Head
  "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
  {:added "1.0"
   :go "__head(__url)"}
  [^String __url])

JOKER FUNC net/http.ListenAndServe from net/http/server.go:
(defn ^"Error" ListenAndServe
  "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServe(__addr, *__handler)"}
  [^String __addr, ^http/Handler __handler])

JOKER FUNC net/http.ListenAndServeTLS from net/http/server.go:
(defn ^"Error" ListenAndServeTLS
  "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
  {:added "1.0"
   :go "http.ListenAndServeTLS(__addr, __certFile, __keyFile, *__handler)"}
  [^String __addr, ^String __certFile, ^String __keyFile, ^http/Handler __handler])

JOKER FUNC net/http.MaxBytesReader from net/http/request.go:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^go.std.io/ReadCloser r, ^Number n]\n\nJoker return type: ABEND042(post.go: cannot find typename io.ReadCloser)"
;;   {:added "1.0"
;;    :go "__maxBytesReader(*__w, *__r, __n)"}
;;   [^http/ResponseWriter __w, ^io/ReadCloser __r, ^Int64 __n])

JOKER FUNC net/http.NewFileTransport from net/http/filetransport.go:
(defn NewFileTransport
  "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^go.std.net.http/FileSystem fs]\n\nJoker return type: go.std.net.http/RoundTripper"
  {:added "1.0"
   :go "__newFileTransport(*__fs)"}
  [^http/FileSystem __fs])

JOKER FUNC net/http.NewRequest from net/http/request.go:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__newRequest(__method, __url, *__body)"}
;;   [^String __method, ^String __url, ^io/Reader __body])

JOKER FUNC net/http.NewServeMux from net/http/server.go:
(defn NewServeMux
  "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http/ServeMux)"
  {:added "1.0"
   :go "__newServeMux()"}
  [])

JOKER FUNC net/http.NotFound from net/http/server.go:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w ResponseWriter, r *Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__notFound(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http.NotFoundHandler from net/http/server.go:
(defn NotFoundHandler
  "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__notFoundHandler()"}
  [])

JOKER FUNC net/http.ParseHTTPVersion from net/http/request.go:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Boolean]"
  {:added "1.0"
   :go "__parseHTTPVersion(__vers)"}
  [^String __vers])

JOKER FUNC net/http.ParseTime from net/http/header.go:
;; (defn ParseTime
;;   "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t ..., err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [ABEND042(post.go: cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "__parseTime(__text)"}
;;   [^String __text])

JOKER FUNC net/http.Post from net/http/client.go:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^go.std.io/Reader body]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__post(__url, __contentType, *__body)"}
;;   [^String __url, ^String __contentType, ^io/Reader __body])

JOKER FUNC net/http.PostForm from net/http/client.go:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^go.std.net.url/Values data]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__postForm(__url, *__data)"}
;;   [^String __url, ^url/Values __data])

JOKER FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
(defn ProxyFromEnvironment
  "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *Request)\n\nGo return type: (*net/url.URL, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__proxyFromEnvironment(__req)"}
  [^http/Request __req])

JOKER FUNC net/http.ProxyURL from net/http/transport.go:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) fixedURL]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.FuncType at: _tests/big/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "__proxyURL(__fixedURL)"}
;;   [^url/URL __fixedURL])

JOKER FUNC net/http.ReadRequest from net/http/request.go:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) b]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__readRequest(__b)"}
;;   [^bufio/Reader __b])

JOKER FUNC net/http.ReadResponse from net/http/response.go:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r, ^(atom-of go.std.net.http/Request) req]\n\nJoker return type: [(atom-of go.std.net.http/Response) Error]"
;;   {:added "1.0"
;;    :go "__readResponse(__r, __req)"}
;;   [^bufio/Reader __r, ^http/Request __req])

JOKER FUNC net/http.Redirect from net/http/server.go:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w ResponseWriter, r *Request, url string, code int)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "__redirect(*__w, __r, __url, __code)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __url, ^Int __code])

JOKER FUNC net/http.RedirectHandler from net/http/server.go:
(defn RedirectHandler
  "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__redirectHandler(__url, __code)"}
  [^String __url, ^Int __code])

JOKER FUNC net/http.Serve from net/http/server.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(*__l, *__handler)"}
;;   [^net/Listener __l, ^http/Handler __handler])

JOKER FUNC net/http.ServeContent from net/http/fs.go:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w ResponseWriter, req *Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) req, ^String name, ^go.std.time/Time modtime, ^go.std.io/ReadSeeker content]"
;;   {:added "1.0"
;;    :go "__serveContent(*__w, __req, __name, *__modtime, *__content)"}
;;   [^http/ResponseWriter __w, ^http/Request __req, ^String __name, ^time/Time __modtime, ^io/ReadSeeker __content])

JOKER FUNC net/http.ServeFile from net/http/fs.go:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w ResponseWriter, r *Request, name string)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "__serveFile(*__w, __r, __name)"}
;;   [^http/ResponseWriter __w, ^http/Request __r, ^String __name])

JOKER FUNC net/http.ServeTLS from net/http/server.go:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(*__l, *__handler, __certFile, __keyFile)"}
;;   [^net/Listener __l, ^http/Handler __handler, ^String __certFile, ^String __keyFile])

JOKER FUNC net/http.SetCookie from net/http/cookie.go:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w ResponseWriter, cookie *Cookie)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Cookie) cookie]"
;;   {:added "1.0"
;;    :go "__setCookie(*__w, __cookie)"}
;;   [^http/ResponseWriter __w, ^http/Cookie __cookie])

JOKER FUNC net/http.StatusText from net/http/status.go:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(__code)"}
  [^Int __code])

JOKER FUNC net/http.StripPrefix from net/http/server.go:
(defn StripPrefix
  "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^go.std.net.http/Handler h]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__stripPrefix(__prefix, *__h)"}
  [^String __prefix, ^http/Handler __h])

JOKER FUNC net/http.TimeoutHandler from net/http/server.go:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^go.std.net.http/Handler h, ^go.std.time/Duration dt, ^String msg]\n\nJoker return type: go.std.net.http/Handler"
;;   {:added "1.0"
;;    :go "__timeoutHandler(*__h, *__dt, __msg)"}
;;   [^http/Handler __h, ^time/Duration __dt, ^String __msg])

JOKER TYPE go.std.net.http/Client:
(def
  ^{:doc "A Client is an HTTP client. Its zero value (DefaultClient) is a\nusable client that uses DefaultTransport.\n\nThe Client's Transport typically has internal state (cached TCP\nconnections), so Clients should be reused instead of created as\nneeded. Clients are safe for concurrent use by multiple goroutines.\n\nA Client is higher-level than a RoundTripper (such as Transport)\nand additionally handles HTTP details such as cookies and\nredirects.\n\nWhen following redirects, the Client will forward all headers set on the\ninitial Request except:\n\n when forwarding sensitive headers like \"Authorization\",\n\"WWW-Authenticate\", and \"Cookie\" to untrusted targets.\nThese headers will be ignored when following a redirect to a domain\nthat is not a subdomain match or exact match of the initial domain.\nFor example, a redirect from \"foo.com\" to either \"foo.com\" or \"sub.foo.com\"\nwill forward the sensitive headers, but a redirect to \"bar.com\" will not.\n\n when forwarding the \"Cookie\" header with a non-nil cookie Jar.\nSince each redirect may mutate the state of the cookie jar,\na redirect may possibly alter a cookie set in the initial request.\nWhen forwarding the \"Cookie\" header, any mutated cookies will be omitted,\nwith the expectation that the Jar will insert those mutated cookies\nwith the updated values (assuming the origin matches).\nIf Jar is nil, the initial cookies are forwarded without change.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE *go.std.net.http/Client:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  *Client)

JOKER TYPE go.std.net.http/CloseNotifier:
(def
  ^{:doc "The CloseNotifier interface is implemented by ResponseWriters which\nallow detecting when the underlying connection has gone away.\n\nThis mechanism can be used to cancel long operations on the server\nif the client has disconnected before the response is ready.\n\nDeprecated: the CloseNotifier interface predates Go's context package.\nNew code should use Request.Context instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CloseNotifier"}
  CloseNotifier)

JOKER TYPE go.std.net.http/ConnState:
(def
  ^{:doc "A ConnState represents the state of a client connection to a server.\nIt's used by the optional Server.ConnState hook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ConnState"}
  ConnState)

JOKER TYPE *go.std.net.http/ConnState:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ConnState"}
  *ConnState)

JOKER TYPE go.std.net.http/Cookie:
(def
  ^{:doc "A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\nHTTP response or the Cookie header of an HTTP request.\n\nSee https://tools.ietf.org/html/rfc6265 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Cookie"}
  Cookie)

JOKER TYPE *go.std.net.http/Cookie:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Cookie"}
  *Cookie)

JOKER TYPE go.std.net.http/CookieJar:
(def
  ^{:doc "A CookieJar manages storage and use of cookies in HTTP requests.\n\nImplementations of CookieJar must be safe for concurrent use by multiple\ngoroutines.\n\nThe net/http/cookiejar package provides a CookieJar implementation.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_CookieJar"}
  CookieJar)

JOKER TYPE go.std.net.http/Dir:
(def
  ^{:doc "A Dir implements FileSystem using the native file system restricted to a\nspecific directory tree.\n\nWhile the FileSystem.Open method takes '/'-separated paths, a Dir's string\nvalue is a filename on the native file system, not a URL, so it is separated\nby filepath.Separator, which isn't necessarily '/'.\n\nNote that Dir will allow access to files and directories starting with a\nperiod, which could expose sensitive directories like a .git directory or\nsensitive files like .htpasswd. To exclude files with a leading period,\nremove the files/directories from the server or create a custom FileSystem\nimplementation.\n\nAn empty Dir is treated as \".\".\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Dir"}
  Dir)

JOKER TYPE *go.std.net.http/Dir:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Dir"}
  *Dir)

JOKER TYPE go.std.net.http/File:
(def
  ^{:doc "A File is returned by a FileSystem's Open method and can be\nserved by the FileServer implementation.\n\nThe methods should behave the same as those on an *os.File.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_File"}
  File)

JOKER TYPE go.std.net.http/FileSystem:
(def
  ^{:doc "A FileSystem implements access to a collection of named files.\nThe elements in a file path are separated by slash ('/', U+002F)\ncharacters, regardless of host operating system convention.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_FileSystem"}
  FileSystem)

JOKER TYPE go.std.net.http/Flusher:
(def
  ^{:doc "The Flusher interface is implemented by ResponseWriters that allow\nan HTTP handler to flush buffered data to the client.\n\nThe default HTTP/1.x and HTTP/2 ResponseWriter implementations\nsupport Flusher, but ResponseWriter wrappers may not. Handlers\nshould always test for this ability at runtime.\n\nNote that even for ResponseWriters that support Flush,\nif the client is connected through an HTTP proxy,\nthe buffered data may not reach the client until the response\ncompletes.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Flusher"}
  Flusher)

JOKER TYPE go.std.net.http/Handler:
(def
  ^{:doc "A Handler responds to an HTTP request.\n\nServeHTTP should write reply headers and data to the ResponseWriter\nand then return. Returning signals that the request is finished; it\nis not valid to use the ResponseWriter or read from the\nRequest.Body after or concurrently with the completion of the\nServeHTTP call.\n\nDepending on the HTTP client software, HTTP protocol version, and\nany intermediaries between the client and the Go server, it may not\nbe possible to read from the Request.Body after writing to the\nResponseWriter. Cautious handlers should read the Request.Body\nfirst, and then reply.\n\nExcept for reading the body, handlers should not modify the\nprovided Request.\n\nIf ServeHTTP panics, the server (the caller of ServeHTTP) assumes\nthat the effect of the panic was isolated to the active request.\nIt recovers the panic, logs a stack trace to the server error log,\nand either closes the network connection or sends an HTTP/2\nRST_STREAM, depending on the HTTP protocol. To abort a handler so\nthe client sees an interrupted response but the server doesn't log\nan error, panic with the value ErrAbortHandler.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Handler"}
  Handler)

JOKER TYPE go.std.net.http/HandlerFunc:
(def
  ^{:doc "The HandlerFunc type is an adapter to allow the use of\nordinary functions as HTTP handlers. If f is a function\nwith the appropriate signature, HandlerFunc(f) is a\nHandler that calls f.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_HandlerFunc"}
  HandlerFunc)

JOKER TYPE *go.std.net.http/HandlerFunc:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_HandlerFunc"}
  *HandlerFunc)

JOKER TYPE go.std.net.http/Header:
(def
  ^{:doc "A Header represents the key-value pairs in an HTTP header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE *go.std.net.http/Header:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Header"}
  *Header)

JOKER TYPE go.std.net.http/Hijacker:
(def
  ^{:doc "The Hijacker interface is implemented by ResponseWriters that allow\nan HTTP handler to take over the connection.\n\nThe default ResponseWriter for HTTP/1.x connections supports\nHijacker, but HTTP/2 connections intentionally do not.\nResponseWriter wrappers may also not support Hijacker. Handlers\nshould always test for this ability at runtime.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Hijacker"}
  Hijacker)

JOKER TYPE go.std.net.http/ProtocolError:
(def
  ^{:doc "ProtocolError represents an HTTP protocol error.\n\nDeprecated: Not all errors in the http package related to protocol errors\nare of type ProtocolError.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

JOKER TYPE *go.std.net.http/ProtocolError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ProtocolError"}
  *ProtocolError)

JOKER TYPE go.std.net.http/PushOptions:
(def
  ^{:doc "PushOptions describes options for Pusher.Push.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PushOptions"}
  PushOptions)

JOKER TYPE *go.std.net.http/PushOptions:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_PushOptions"}
  *PushOptions)

JOKER TYPE go.std.net.http/Pusher:
(def
  ^{:doc "Pusher is the interface implemented by ResponseWriters that support\nHTTP/2 server push. For more background, see\nhttps://tools.ietf.org/html/rfc7540#section-8.2.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pusher"}
  Pusher)

JOKER TYPE go.std.net.http/Request:
(def
  ^{:doc "A Request represents an HTTP request received by a server\nor to be sent by a client.\n\nThe field semantics differ slightly between client and server\nusage. In addition to the notes on the fields below, see the\ndocumentation for Request.Write and RoundTripper.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

JOKER TYPE *go.std.net.http/Request:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Request"}
  *Request)

JOKER TYPE go.std.net.http/Response:
(def
  ^{:doc "Response represents the response from an HTTP request.\n\nThe Client and Transport return Responses from servers once\nthe response headers have been received. The response body\nis streamed on demand as the Body field is read.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

JOKER TYPE *go.std.net.http/Response:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Response"}
  *Response)

JOKER TYPE go.std.net.http/ResponseWriter:
(def
  ^{:doc "A ResponseWriter interface is used by an HTTP handler to\nconstruct an HTTP response.\n\nA ResponseWriter may not be used after the Handler.ServeHTTP method\nhas returned.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ResponseWriter"}
  ResponseWriter)

JOKER TYPE go.std.net.http/RoundTripper:
(def
  ^{:doc "RoundTripper is an interface representing the ability to execute a\nsingle HTTP transaction, obtaining the Response for a given Request.\n\nA RoundTripper must be safe for concurrent use by multiple\ngoroutines.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_RoundTripper"}
  RoundTripper)

JOKER TYPE go.std.net.http/SameSite:
(def
  ^{:doc "SameSite allows a server define a cookie attribute making it impossible to\nthe browser send this cookie along with cross-site requests. The main goal\nis mitigate the risk of cross-origin information leakage, and provides some\nprotection against cross-site request forgery attacks.\n\nSee https://tools.ietf.org/html/draft-ietf-httpbis-cookie-same-site-00 for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_SameSite"}
  SameSite)

JOKER TYPE *go.std.net.http/SameSite:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_SameSite"}
  *SameSite)

JOKER TYPE go.std.net.http/ServeMux:
(def
  ^{:doc "ServeMux is an HTTP request multiplexer.\nIt matches the URL of each incoming request against a list of registered\npatterns and calls the handler for the pattern that\nmost closely matches the URL.\n\nPatterns name fixed, rooted paths, like \"/favicon.ico\",\nor rooted subtrees, like \"/images/\" (note the trailing slash).\nLonger patterns take precedence over shorter ones, so that\nif there are handlers registered for both \"/images/\"\nand \"/images/thumbnails/\", the latter handler will be\ncalled for paths beginning \"/images/thumbnails/\" and the\nformer will receive requests for any other paths in the\n\"/images/\" subtree.\n\nNote that since a pattern ending in a slash names a rooted subtree,\nthe pattern \"/\" matches all paths not matched by other registered\npatterns, not just the URL with Path == \"/\".\n\nIf a subtree has been registered and a request is received naming the\nsubtree root without its trailing slash, ServeMux redirects that\nrequest to the subtree root (adding the trailing slash). This behavior can\nbe overridden with a separate registration for the path without\nthe trailing slash. For example, registering \"/images/\" causes ServeMux\nto redirect a request for \"/images\" to \"/images/\", unless \"/images\" has\nbeen registered separately.\n\nPatterns may optionally begin with a host name, restricting matches to\nURLs on that host only. Host-specific patterns take precedence over\ngeneral patterns, so that a handler might register for the two patterns\n\"/codesearch\" and \"codesearch.google.com/\" without also taking over\nrequests for \"http://www.google.com/\".\n\nServeMux also takes care of sanitizing the URL request path and the Host\nheader, stripping the port number and redirecting any request containing . or\n.. elements or repeated slashes to an equivalent, cleaner URL.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServeMux"}
  ServeMux)

JOKER TYPE *go.std.net.http/ServeMux:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServeMux"}
  *ServeMux)

JOKER TYPE go.std.net.http/Server:
(def
  ^{:doc "A Server defines parameters for running an HTTP server.\nThe zero value for Server is a valid configuration.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

JOKER TYPE *go.std.net.http/Server:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  *Server)

JOKER TYPE go.std.net.http/Transport:
(def
  ^{:doc "Transport is an implementation of RoundTripper that supports HTTP,\nHTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).\n\nBy default, Transport caches connections for future re-use.\nThis may leave many open connections when accessing many hosts.\nThis behavior can be managed using Transport's CloseIdleConnections method\nand the MaxIdleConnsPerHost and DisableKeepAlives fields.\n\nTransports should be reused instead of created as needed.\nTransports are safe for concurrent use by multiple goroutines.\n\nA Transport is a low-level primitive for making HTTP and HTTPS requests.\nFor high-level functionality, such as cookies and redirects, see Client.\n\nTransport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2\nfor HTTPS URLs, depending on whether the server supports HTTP/2,\nand how the Transport is configured. The DefaultTransport supports HTTP/2.\nTo explicitly enable HTTP/2 on a transport, use golang.org/x/net/http2\nand call ConfigureTransport. See the package docs for more about HTTP/2.\n\nThe Transport will send CONNECT requests to a proxy for its own use\nwhen processing HTTPS requests, but Transport should generally not\nbe used to send a CONNECT request. That is, the Request passed to\nthe RoundTrip method should not have a Method of \"CONNECT\", as Go's\nHTTP/1.x implementation does not support full-duplex request bodies\nbeing written while the response body is streamed. Go's HTTP/2\nimplementation does support full duplex, but many CONNECT proxies speak\nHTTP/1.x.\n\nResponses with status codes in the 1xx range are either handled\nautomatically (100 expect-continue) or ignored. The one\nexception is HTTP status code 101 (Switching Protocols), which is\nconsidered a terminal status and returned by RoundTrip. To see the\nignored 1xx responses, use the httptrace trace package's\nClientTrace.Got1xxResponse.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Transport"}
  Transport)

JOKER TYPE *go.std.net.http/Transport:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Transport"}
  *Transport)

JOKER TYPE net/http/cgi.Handler from net/http/cgi/host.go:
;; (defn ^"GoObject" Handler.
;;   "Constructor for cgi.Handler"
;;   {:added "1.0"
;;    :go "_ConstructHandler(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cgi.Request from net/http/cgi/child.go:
(defn Request
  "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: []\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
  {:added "1.0"
   :go "__request()"}
  [])

JOKER FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*net/http.Request, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [(atom-of go.std.net.http/Request) Error]"
;;   {:added "1.0"
;;    :go "__requestFromMap(ABEND908(pre.go: custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} __params])

JOKER FUNC net/http/cgi.Serve from net/http/cgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(*__handler)"}
;;   [^http/Handler __handler])

JOKER TYPE go.std.net.http.cgi/Handler:
(def
  ^{:doc "Handler runs an executable in a subprocess with a CGI environment.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Handler"}
  Handler)

JOKER TYPE *go.std.net.http.cgi/Handler:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Handler"}
  *Handler)

JOKER TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
(defn ^"GoObject" Jar.
  "Constructor for cookiejar.Jar"
  {:added "1.0"
   :go "_ConstructJar(_v)"}
  [^Object _v])

JOKER TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" Options.
;;   "Constructor for cookiejar.Options"
;;   {:added "1.0"
;;    :go "_ConstructOptions(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
;; (defn ^"GoObject" PublicSuffixList.
;;   "Constructor for cookiejar.PublicSuffixList"
;;   {:added "1.0"
;;    :go "_ConstructPublicSuffixList(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
(defn New
  "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of go.std.net.http.cookiejar/Options) o]\n\nJoker return type: [(atom-of go.std.net.http.cookiejar/Jar) Error]"
  {:added "1.0"
   :go "__new(__o)"}
  [^cookiejar/Options __o])

JOKER TYPE go.std.net.http.cookiejar/Jar:
(def
  ^{:doc "Jar implements the http.CookieJar interface from the net/http package.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Jar"}
  Jar)

JOKER TYPE *go.std.net.http.cookiejar/Jar:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Jar"}
  *Jar)

JOKER TYPE go.std.net.http.cookiejar/Options:
(def
  ^{:doc "Options are the options for creating a new Jar.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Options"}
  Options)

JOKER TYPE *go.std.net.http.cookiejar/Options:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Options"}
  *Options)

JOKER TYPE go.std.net.http.cookiejar/PublicSuffixList:
(def
  ^{:doc "PublicSuffixList provides the public suffix of a domain. For example:\n     - the public suffix of \"example.com\" is \"com\",\n     - the public suffix of \"foo1.foo2.foo3.co.uk\" is \"co.uk\", and\n     - the public suffix of \"bar.pvt.k12.ma.us\" is \"pvt.k12.ma.us\".\n\nImplementations of PublicSuffixList must be safe for concurrent use by\nmultiple goroutines.\n\nAn implementation that always returns \"\" is valid and may be useful for\ntesting but it is not secure: it means that the HTTP server for foo.com can\nset a cookie for bar.com.\n\nA public suffix list implementation is in the package\ngolang.org/x/net/publicsuffix.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_PublicSuffixList"}
  PublicSuffixList)

JOKER VARIABLE ErrConnClosed from net/http/fcgi/child.go:
(def
  ^{:doc "ErrConnClosed is returned by Read when a handler attempts to read the body of\na request after the connection to the web server has been closed.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrConnClosed"}
  ErrConnClosed)

JOKER VARIABLE ErrRequestAborted from net/http/fcgi/child.go:
(def
  ^{:doc "ErrRequestAborted is returned by Read when a handler attempts to read the\nbody of a request that has been aborted by the web server.\n"
    :added "1.0"
    :tag "Var"
    :go "fcgi.ErrRequestAborted"}
  ErrRequestAborted)

JOKER FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) r]\n\nJoker return type: ABEND883(post.go: unrecognized Expr type *ast.MapType at: _tests/big/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "__processEnv(__r)"}
;;   [^http/Request __r])

JOKER FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net/Listener l, ^go.std.net.http/Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(*__l, *__handler)"}
;;   [^net/Listener __l, ^http/Handler __handler])

JOKER CONSTANT DefaultRemoteAddr from net/http/httptest/recorder.go:
(def
  ^{:doc "DefaultRemoteAddr is the default remote address to return in RemoteAddr if\nan explicit DefaultRemoteAddr isn't set on ResponseRecorder.\n"
    :added "1.0"
    :tag "String"
    :go "httptest.DefaultRemoteAddr"}
  DefaultRemoteAddr)

JOKER TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
;; (defn ^"GoObject" ResponseRecorder.
;;   "Constructor for httptest.ResponseRecorder"
;;   {:added "1.0"
;;    :go "_ConstructResponseRecorder(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptest.Server from net/http/httptest/server.go:
;; (defn ^"GoObject" Server.
;;   "Constructor for httptest.Server"
;;   {:added "1.0"
;;    :go "_ConstructServer(_v)"}
;;   [^Object _v])

JOKER FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
(defn NewRecorder
  "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.http.httptest/ResponseRecorder)"
  {:added "1.0"
   :go "__newRecorder()"}
  [])

JOKER FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *net/http.Request\n\nJoker input arguments: [^String method, ^String target, ^go.std.io/Reader body]\n\nJoker return type: (atom-of go.std.net.http/Request)"
;;   {:added "1.0"
;;    :go "__newRequest(__method, __target, *__body)"}
;;   [^String __method, ^String __target, ^io/Reader __body])

JOKER FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newTLSServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^go.std.net.http/Handler handler]\n\nJoker return type: (atom-of go.std.net.http.httptest/Server)"
;;   {:added "1.0"
;;    :go "__newUnstartedServer(*__handler)"}
;;   [^http/Handler __handler])

JOKER TYPE go.std.net.http.httptest/ResponseRecorder:
(def
  ^{:doc "ResponseRecorder is an implementation of http.ResponseWriter that\nrecords its mutations for later inspection in tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ResponseRecorder"}
  ResponseRecorder)

JOKER TYPE *go.std.net.http.httptest/ResponseRecorder:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ResponseRecorder"}
  *ResponseRecorder)

JOKER TYPE go.std.net.http.httptest/Server:
(def
  ^{:doc "A Server is an HTTP server listening on a system-chosen port on the\nlocal loopback interface, for use in end-to-end HTTP tests.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

JOKER TYPE *go.std.net.http.httptest/Server:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  *Server)

JOKER TYPE net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
;; (defn ^"GoObject" ClientTrace.
;;   "Constructor for httptrace.ClientTrace"
;;   {:added "1.0"
;;    :go "_ConstructClientTrace(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
;; (defn ^"GoObject" DNSDoneInfo.
;;   "Constructor for httptrace.DNSDoneInfo"
;;   {:added "1.0"
;;    :go "_ConstructDNSDoneInfo(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
(defn ^"GoObject" DNSStartInfo.
  "Constructor for httptrace.DNSStartInfo"
  {:added "1.0"
   :go "_ConstructDNSStartInfo(_v)"}
  [^Object _v])

JOKER TYPE net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
;; (defn ^"GoObject" GotConnInfo.
;;   "Constructor for httptrace.GotConnInfo"
;;   {:added "1.0"
;;    :go "_ConstructGotConnInfo(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
(defn ^"GoObject" WroteRequestInfo.
  "Constructor for httptrace.WroteRequestInfo"
  {:added "1.0"
   :go "_ConstructWroteRequestInfo(_v)"}
  [^Object _v])

JOKER FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^go.std.context/Context ctx]\n\nJoker return type: (atom-of go.std.net.http.httptrace/ClientTrace)"
;;   {:added "1.0"
;;    :go "__contextClientTrace(*__ctx)"}
;;   [^context/Context __ctx])

JOKER FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *ClientTrace)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.context/Context ctx, ^(atom-of go.std.net.http.httptrace/ClientTrace) trace]\n\nJoker return type: ABEND042(post.go: cannot find typename context.Context)"
;;   {:added "1.0"
;;    :go "__withClientTrace(*__ctx, __trace)"}
;;   [^context/Context __ctx, ^httptrace/ClientTrace __trace])

JOKER TYPE go.std.net.http.httptrace/ClientTrace:
(def
  ^{:doc "ClientTrace is a set of hooks to run at various stages of an outgoing\nHTTP request. Any particular hook may be nil. Functions may be\ncalled concurrently from different goroutines and some may be called\nafter the request has completed or failed.\n\nClientTrace currently traces a single HTTP request & response\nduring a single round trip and has no hooks that span a series\nof redirected requests.\n\nSee https://blog.golang.org/http-tracing for more.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientTrace"}
  ClientTrace)

JOKER TYPE *go.std.net.http.httptrace/ClientTrace:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ClientTrace"}
  *ClientTrace)

JOKER TYPE go.std.net.http.httptrace/DNSDoneInfo:
(def
  ^{:doc "DNSDoneInfo contains information about the results of a DNS lookup.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSDoneInfo"}
  DNSDoneInfo)

JOKER TYPE *go.std.net.http.httptrace/DNSDoneInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSDoneInfo"}
  *DNSDoneInfo)

JOKER TYPE go.std.net.http.httptrace/DNSStartInfo:
(def
  ^{:doc "DNSStartInfo contains information about a DNS request.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_DNSStartInfo"}
  DNSStartInfo)

JOKER TYPE *go.std.net.http.httptrace/DNSStartInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_DNSStartInfo"}
  *DNSStartInfo)

JOKER TYPE go.std.net.http.httptrace/GotConnInfo:
(def
  ^{:doc "GotConnInfo is the argument to the ClientTrace.GotConn function and\ncontains information about the obtained connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_GotConnInfo"}
  GotConnInfo)

JOKER TYPE *go.std.net.http.httptrace/GotConnInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_GotConnInfo"}
  *GotConnInfo)

JOKER TYPE go.std.net.http.httptrace/WroteRequestInfo:
(def
  ^{:doc "WroteRequestInfo contains information provided to the WroteRequest\nhook.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_WroteRequestInfo"}
  WroteRequestInfo)

JOKER TYPE *go.std.net.http.httptrace/WroteRequestInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_WroteRequestInfo"}
  *WroteRequestInfo)

JOKER VARIABLE ErrClosed from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrClosed"}
  ErrClosed)

JOKER VARIABLE ErrLineTooLong from net/http/httputil/httputil.go:
(def
  ^{:doc "ErrLineTooLong is returned when reading malformed chunked data\nwith lines that are too long.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrLineTooLong"}
  ErrLineTooLong)

JOKER VARIABLE ErrPersistEOF from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPersistEOF"}
  ErrPersistEOF)

JOKER VARIABLE ErrPipeline from net/http/httputil/persist.go:
(def
  ^{:doc "Deprecated: No longer used.\n"
    :added "1.0"
    :tag "Var"
    :go "httputil.ErrPipeline"}
  ErrPipeline)

JOKER TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" BufferPool.
;;   "Constructor for httputil.BufferPool"
;;   {:added "1.0"
;;    :go "_ConstructBufferPool(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
(defn ^"GoObject" ClientConn.
  "Constructor for httputil.ClientConn"
  {:added "1.0"
   :go "_ConstructClientConn(_v)"}
  [^Object _v])

JOKER TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn ^"GoObject" ReverseProxy.
;;   "Constructor for httputil.ReverseProxy"
;;   {:added "1.0"
;;    :go "_ConstructReverseProxy(_v)"}
;;   [^Object _v])

JOKER TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
(defn ^"GoObject" ServerConn.
  "Constructor for httputil.ServerConn"
  {:added "1.0"
   :go "_ConstructServerConn(_v)"}
  [^Object _v])

JOKER FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequest(__req, __body)"}
;;   [^http/Request __req, ^Boolean __body])

JOKER FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *http.Request, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Request) req, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpRequestOut(__req, __body)"}
;;   [^http/Request __req, ^Boolean __body])

JOKER FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *http.Response, body bool)\n\nGo return type: ([]byte, error)\n\nJoker input arguments: [^(atom-of go.std.net.http/Response) resp, ^Boolean body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "__dumpResponse(__resp, __body)"}
;;   [^http/Response __resp, ^Boolean __body])

JOKER FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: ABEND042(post.go: cannot find typename io.Reader)"
;;   {:added "1.0"
;;    :go "__newChunkedReader(*__r)"}
;;   [^io/Reader __r])

JOKER FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^go.std.io/Writer w]\n\nJoker return type: ABEND042(post.go: cannot find typename io.WriteCloser)"
;;   {:added "1.0"
;;    :go "__newChunkedWriter(*__w)"}
;;   [^io/Writer __w])

JOKER FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newClientConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ClientConn)"
;;   {:added "1.0"
;;    :go "__newProxyClientConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^go.std.net/Conn c, ^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.http.httputil/ServerConn)"
;;   {:added "1.0"
;;    :go "__newServerConn(*__c, __r)"}
;;   [^net/Conn __c, ^bufio/Reader __r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of go.std.net.url/URL) target]\n\nJoker return type: (atom-of go.std.net.http.httputil/ReverseProxy)"
;;   {:added "1.0"
;;    :go "__newSingleHostReverseProxy(__target)"}
;;   [^url/URL __target])

JOKER TYPE go.std.net.http.httputil/BufferPool:
(def
  ^{:doc "A BufferPool is an interface for getting and returning temporary\nbyte slices for use by io.CopyBuffer.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_BufferPool"}
  BufferPool)

JOKER TYPE go.std.net.http.httputil/ClientConn:
(def
  ^{:doc "ClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use Client or Transport in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientConn"}
  ClientConn)

JOKER TYPE *go.std.net.http.httputil/ClientConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ClientConn"}
  *ClientConn)

JOKER TYPE go.std.net.http.httputil/ReverseProxy:
(def
  ^{:doc "ReverseProxy is an HTTP Handler that takes an incoming request and\nsends it to another server, proxying the response back to the\nclient.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ReverseProxy"}
  ReverseProxy)

JOKER TYPE *go.std.net.http.httputil/ReverseProxy:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ReverseProxy"}
  *ReverseProxy)

JOKER TYPE go.std.net.http.httputil/ServerConn:
(def
  ^{:doc "ServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerConn"}
  ServerConn)

JOKER TYPE *go.std.net.http.httputil/ServerConn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerConn"}
  *ServerConn)

JOKER FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__cmdline(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
(defn Handler
  "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: net/http.Handler\n\nJoker input arguments: [^String name]\n\nJoker return type: go.std.net.http/Handler"
  {:added "1.0"
   :go "__handler(__name)"}
  [^String __name])

JOKER FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__index(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__profile(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__symbol(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w http.ResponseWriter, r *http.Request)\n\nJoker input arguments: [^go.std.net.http/ResponseWriter w, ^(atom-of go.std.net.http/Request) r]"
;;   {:added "1.0"
;;    :go "__trace(*__w, __r)"}
;;   [^http/ResponseWriter __w, ^http/Request __r])

JOKER VARIABLE ErrHeaderNotPresent from net/mail/message.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "mail.ErrHeaderNotPresent"}
  ErrHeaderNotPresent)

JOKER TYPE net/mail.Address from net/mail/message.go:
(defn ^"GoObject" Address.
  "Constructor for mail.Address"
  {:added "1.0"
   :go "_ConstructAddress(_v)"}
  [^Object _v])

JOKER TYPE net/mail.AddressParser from net/mail/message.go:
;; (defn ^"GoObject" AddressParser.
;;   "Constructor for mail.AddressParser"
;;   {:added "1.0"
;;    :go "_ConstructAddressParser(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Header from net/mail/message.go:
;; (defn ^"GoObject" Header.
;;   "Constructor for mail.Header"
;;   {:added "1.0"
;;    :go "_ConstructHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/mail.Message from net/mail/message.go:
;; (defn ^"GoObject" Message.
;;   "Constructor for mail.Message"
;;   {:added "1.0"
;;    :go "_ConstructMessage(_v)"}
;;   [^Object _v])

JOKER FUNC net/mail.ParseAddress from net/mail/message.go:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [(atom-of go.std.net.mail/Address) Error]"
  {:added "1.0"
   :go "__parseAddress(__address)"}
  [^String __address])

JOKER FUNC net/mail.ParseAddressList from net/mail/message.go:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of (atom-of go.std.net.mail/Address)) Error]"
  {:added "1.0"
   :go "__parseAddressList(__list)"}
  [^String __list])

JOKER FUNC net/mail.ParseDate from net/mail/message.go:
;; (defn ParseDate
;;   "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [ABEND042(post.go: cannot find typename time.Time) Error]"
;;   {:added "1.0"
;;    :go "__parseDate(__date)"}
;;   [^String __date])

JOKER FUNC net/mail.ReadMessage from net/mail/message.go:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^go.std.io/Reader r]\n\nJoker return type: [(atom-of go.std.net.mail/Message) Error]"
;;   {:added "1.0"
;;    :go "__readMessage(*__r)"}
;;   [^io/Reader __r])

JOKER TYPE go.std.net.mail/Address:
(def
  ^{:doc "Address represents a single mail address.\nAn address such as \"Barry Gibbs <bg@example.com>\" is represented\nas Address{Name: \"Barry Gibbs\", Address: \"bg@example.com\"}.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Address"}
  Address)

JOKER TYPE *go.std.net.mail/Address:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Address"}
  *Address)

JOKER TYPE go.std.net.mail/AddressParser:
(def
  ^{:doc "An AddressParser is an RFC 5322 address parser.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_AddressParser"}
  AddressParser)

JOKER TYPE *go.std.net.mail/AddressParser:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_AddressParser"}
  *AddressParser)

JOKER TYPE go.std.net.mail/Header:
(def
  ^{:doc "A Header represents the key-value pairs in a mail message header.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Header"}
  Header)

JOKER TYPE *go.std.net.mail/Header:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Header"}
  *Header)

JOKER TYPE go.std.net.mail/Message:
(def
  ^{:doc "A Message represents a parsed mail message.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Message"}
  Message)

JOKER TYPE *go.std.net.mail/Message:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Message"}
  *Message)

JOKER CONSTANT DefaultDebugPath from net/rpc/server.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "String"
    :go "rpc.DefaultDebugPath"}
  DefaultDebugPath)

JOKER CONSTANT DefaultRPCPath from net/rpc/server.go:
(def
  ^{:doc "Defaults used by HandleHTTP\n"
    :added "1.0"
    :tag "String"
    :go "rpc.DefaultRPCPath"}
  DefaultRPCPath)

JOKER VARIABLE DefaultServer from net/rpc/server.go:
(def
  ^{:doc "DefaultServer is the default instance of *Server.\n"
    :added "1.0"
    :tag "Var"
    :go "rpc.DefaultServer"}
  DefaultServer)

JOKER VARIABLE ErrShutdown from net/rpc/client.go:
(def
  ^{:doc ""
    :added "1.0"
    :tag "Var"
    :go "rpc.ErrShutdown"}
  ErrShutdown)

JOKER TYPE net/rpc.Call from net/rpc/client.go:
;; (defn ^"GoObject" Call.
;;   "Constructor for rpc.Call"
;;   {:added "1.0"
;;    :go "_ConstructCall(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Client from net/rpc/client.go:
(defn ^"GoObject" Client.
  "Constructor for rpc.Client"
  {:added "1.0"
   :go "_ConstructClient(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ClientCodec from net/rpc/client.go:
;; (defn ^"GoObject" ClientCodec.
;;   "Constructor for rpc.ClientCodec"
;;   {:added "1.0"
;;    :go "_ConstructClientCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.Request from net/rpc/server.go:
(defn ^"GoObject" Request.
  "Constructor for rpc.Request"
  {:added "1.0"
   :go "_ConstructRequest(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Response from net/rpc/server.go:
(defn ^"GoObject" Response.
  "Constructor for rpc.Response"
  {:added "1.0"
   :go "_ConstructResponse(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.Server from net/rpc/server.go:
(defn ^"GoObject" Server.
  "Constructor for rpc.Server"
  {:added "1.0"
   :go "_ConstructServer(_v)"}
  [^Object _v])

JOKER TYPE net/rpc.ServerCodec from net/rpc/server.go:
;; (defn ^"GoObject" ServerCodec.
;;   "Constructor for rpc.ServerCodec"
;;   {:added "1.0"
;;    :go "_ConstructServerCodec(_v)"}
;;   [^Object _v])

JOKER TYPE net/rpc.ServerError from net/rpc/client.go:
(defn ^"GoObject" ServerError.
  "Constructor for rpc.ServerError"
  {:added "1.0"
   :go "_ConstructServerError(_v)"}
  [^Object _v])

JOKER FUNC net/rpc.Accept from net/rpc/server.go:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^go.std.net/Listener lis]"
;;   {:added "1.0"
;;    :go "__accept(*__lis)"}
;;   [^net/Listener __lis])

JOKER FUNC net/rpc.Dial from net/rpc/client.go:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc.DialHTTP from net/rpc/client.go:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTP(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dialHTTPPath(__network, __address, __path)"}
  [^String __network, ^String __address, ^String __path])

JOKER FUNC net/rpc.HandleHTTP from net/rpc/server.go:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "__handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient from net/rpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
(defn NewClientWithCodec
  "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^go.std.net.rpc/ClientCodec codec]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
  {:added "1.0"
   :go "__newClientWithCodec(*__codec)"}
  [^rpc/ClientCodec __codec])

JOKER FUNC net/rpc.NewServer from net/rpc/server.go:
(defn NewServer
  "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: (atom-of go.std.net.rpc/Server)"
  {:added "1.0"
   :go "__newServer()"}
  [])

JOKER FUNC net/rpc.Register from net/rpc/server.go:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> __rcvr])

JOKER FUNC net/rpc.RegisterName from net/rpc/server.go:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String __name, ^<protocol-or-something> __rcvr])

JOKER FUNC net/rpc.ServeCodec from net/rpc/server.go:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec ServerCodec)\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]"
;;   {:added "1.0"
;;    :go "__serveCodec(*__codec)"}
;;   [^rpc/ServerCodec __codec])

JOKER FUNC net/rpc.ServeConn from net/rpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc.ServeRequest from net/rpc/server.go:
(defn ^"Error" ServeRequest
  "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^go.std.net.rpc/ServerCodec codec]\n\nJoker return type: Error"
  {:added "1.0"
   :go "rpc.ServeRequest(*__codec)"}
  [^rpc/ServerCodec __codec])

JOKER TYPE go.std.net.rpc/Call:
(def
  ^{:doc "Call represents an active RPC.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Call"}
  Call)

JOKER TYPE *go.std.net.rpc/Call:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Call"}
  *Call)

JOKER TYPE go.std.net.rpc/Client:
(def
  ^{:doc "Client represents an RPC Client.\nThere may be multiple outstanding Calls associated\nwith a single Client, and a Client may be used by\nmultiple goroutines simultaneously.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE *go.std.net.rpc/Client:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  *Client)

JOKER TYPE go.std.net.rpc/ClientCodec:
(def
  ^{:doc "A ClientCodec implements writing of RPC requests and\nreading of RPC responses for the client side of an RPC session.\nThe client calls WriteRequest to write a request to the connection\nand calls ReadResponseHeader and ReadResponseBody in pairs\nto read responses. The client calls Close when finished with the\nconnection. ReadResponseBody may be called with a nil\nargument to force the body of the response to be read and then\ndiscarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ClientCodec"}
  ClientCodec)

JOKER TYPE go.std.net.rpc/Request:
(def
  ^{:doc "Request is a header written before every RPC call. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Request"}
  Request)

JOKER TYPE *go.std.net.rpc/Request:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Request"}
  *Request)

JOKER TYPE go.std.net.rpc/Response:
(def
  ^{:doc "Response is a header written before every RPC return. It is used internally\nbut documented here as an aid to debugging, such as when analyzing\nnetwork traffic.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Response"}
  Response)

JOKER TYPE *go.std.net.rpc/Response:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Response"}
  *Response)

JOKER TYPE go.std.net.rpc/Server:
(def
  ^{:doc "Server represents an RPC Server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Server"}
  Server)

JOKER TYPE *go.std.net.rpc/Server:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Server"}
  *Server)

JOKER TYPE go.std.net.rpc/ServerCodec:
(def
  ^{:doc "A ServerCodec implements reading of RPC requests and writing of\nRPC responses for the server side of an RPC session.\nThe server calls ReadRequestHeader and ReadRequestBody in pairs\nto read requests from the connection, and it calls WriteResponse to\nwrite a response back. The server calls Close when finished with the\nconnection. ReadRequestBody may be called with a nil\nargument to force the body of the request to be read and discarded.\nSee NewClient's comment for information about concurrent access.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerCodec"}
  ServerCodec)

JOKER TYPE go.std.net.rpc/ServerError:
(def
  ^{:doc "ServerError represents an error that has been returned from\nthe remote side of the RPC connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerError"}
  ServerError)

JOKER TYPE *go.std.net.rpc/ServerError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerError"}
  *ServerError)

JOKER FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*net/rpc.Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [(atom-of go.std.net.rpc/Client) Error]"
  {:added "1.0"
   :go "__dial(__network, __address)"}
  [^String __network, ^String __address])

JOKER FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *net/rpc.Client\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.rpc/Client)"
;;   {:added "1.0"
;;    :go "__newClient(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ClientCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ClientCodec"
;;   {:added "1.0"
;;    :go "__newClientCodec(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: net/rpc.ServerCodec\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: go.std.net.rpc/ServerCodec"
;;   {:added "1.0"
;;    :go "__newServerCodec(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "__serveConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER TYPE net/smtp.Auth from net/smtp/auth.go:
;; (defn ^"GoObject" Auth.
;;   "Constructor for smtp.Auth"
;;   {:added "1.0"
;;    :go "_ConstructAuth(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.Client from net/smtp/smtp.go:
;; (defn ^"GoObject" Client.
;;   "Constructor for smtp.Client"
;;   {:added "1.0"
;;    :go "_ConstructClient(_v)"}
;;   [^Object _v])

JOKER TYPE net/smtp.ServerInfo from net/smtp/auth.go:
;; (defn ^"GoObject" ServerInfo.
;;   "Constructor for smtp.ServerInfo"
;;   {:added "1.0"
;;    :go "_ConstructServerInfo(_v)"}
;;   [^Object _v])

JOKER FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
(defn CRAMMD5Auth
  "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__cRAMMD5Auth(__username, __secret)"}
  [^String __username, ^String __secret])

JOKER FUNC net/smtp.Dial from net/smtp/smtp.go:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
  {:added "1.0"
   :go "__dial(__addr)"}
  [^String __addr])

JOKER FUNC net/smtp.NewClient from net/smtp/smtp.go:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^go.std.net/Conn conn, ^String host]\n\nJoker return type: [(atom-of go.std.net.smtp/Client) Error]"
;;   {:added "1.0"
;;    :go "__newClient(*__conn, __host)"}
;;   [^net/Conn __conn, ^String __host])

JOKER FUNC net/smtp.PlainAuth from net/smtp/auth.go:
(defn PlainAuth
  "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: go.std.net.smtp/Auth"
  {:added "1.0"
   :go "__plainAuth(__identity, __username, __password, __host)"}
  [^String __identity, ^String __username, ^String __password, ^String __host])

JOKER FUNC net/smtp.SendMail from net/smtp/smtp.go:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^go.std.net.smtp/Auth a, ^String from, ^(vector-of String) to, ^(vector-of Int) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(__addr, *__a, __from, ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfstring(__to)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__msg)))"}
;;   [^String __addr, ^smtp/Auth __a, ^String __from, ^Object __to, ^Object __msg])

JOKER TYPE go.std.net.smtp/Auth:
(def
  ^{:doc "Auth is implemented by an SMTP authentication mechanism.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Auth"}
  Auth)

JOKER TYPE go.std.net.smtp/Client:
(def
  ^{:doc "A Client represents a client connection to an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Client"}
  Client)

JOKER TYPE *go.std.net.smtp/Client:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Client"}
  *Client)

JOKER TYPE go.std.net.smtp/ServerInfo:
(def
  ^{:doc "ServerInfo records information about an SMTP server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ServerInfo"}
  ServerInfo)

JOKER TYPE *go.std.net.smtp/ServerInfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ServerInfo"}
  *ServerInfo)

JOKER TYPE net/textproto.Conn from net/textproto/textproto.go:
(defn ^"GoObject" Conn.
  "Constructor for textproto.Conn"
  {:added "1.0"
   :go "_ConstructConn(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Error from net/textproto/textproto.go:
(defn ^"GoObject" Error.
  "Constructor for textproto.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.MIMEHeader from net/textproto/header.go:
;; (defn ^"GoObject" MIMEHeader.
;;   "Constructor for textproto.MIMEHeader"
;;   {:added "1.0"
;;    :go "_ConstructMIMEHeader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
(defn ^"GoObject" Pipeline.
  "Constructor for textproto.Pipeline"
  {:added "1.0"
   :go "_ConstructPipeline(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
(defn ^"GoObject" ProtocolError.
  "Constructor for textproto.ProtocolError"
  {:added "1.0"
   :go "_ConstructProtocolError(_v)"}
  [^Object _v])

JOKER TYPE net/textproto.Reader from net/textproto/reader.go:
;; (defn ^"GoObject" Reader.
;;   "Constructor for textproto.Reader"
;;   {:added "1.0"
;;    :go "_ConstructReader(_v)"}
;;   [^Object _v])

JOKER TYPE net/textproto.Writer from net/textproto/writer.go:
;; (defn ^"GoObject" Writer.
;;   "Constructor for textproto.Writer"
;;   {:added "1.0"
;;    :go "_ConstructWriter(_v)"}
;;   [^Object _v])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey from net/textproto/reader.go:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(__s)"}
  [^String __s])

JOKER FUNC net/textproto.Dial from net/textproto/textproto.go:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [(atom-of go.std.net.textproto/Conn) Error]"
  {:added "1.0"
   :go "__dial(__network, __addr)"}
  [^String __network, ^String __addr])

JOKER FUNC net/textproto.NewConn from net/textproto/textproto.go:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^go.std.io/ReadWriteCloser conn]\n\nJoker return type: (atom-of go.std.net.textproto/Conn)"
;;   {:added "1.0"
;;    :go "__newConn(*__conn)"}
;;   [^io/ReadWriteCloser __conn])

JOKER FUNC net/textproto.NewReader from net/textproto/reader.go:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of go.std.bufio/Reader) r]\n\nJoker return type: (atom-of go.std.net.textproto/Reader)"
;;   {:added "1.0"
;;    :go "__newReader(__r)"}
;;   [^bufio/Reader __r])

JOKER FUNC net/textproto.NewWriter from net/textproto/writer.go:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of go.std.bufio/Writer) w]\n\nJoker return type: (atom-of go.std.net.textproto/Writer)"
;;   {:added "1.0"
;;    :go "__newWriter(__w)"}
;;   [^bufio/Writer __w])

JOKER FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
;; (defn TrimBytes
;;   "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []byte\n\nJoker input arguments: [^(vector-of Int) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "__trimBytes(ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))"}
;;   [^Object __b])

JOKER FUNC net/textproto.TrimString from net/textproto/textproto.go:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(__s)"}
  [^String __s])

JOKER TYPE go.std.net.textproto/Conn:
(def
  ^{:doc "A Conn represents a textual network protocol connection.\nIt consists of a Reader and Writer to manage I/O\nand a Pipeline to sequence concurrent requests on the connection.\nThese embedded types carry methods with them;\nsee the documentation of those types for details.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Conn"}
  Conn)

JOKER TYPE *go.std.net.textproto/Conn:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Conn"}
  *Conn)

JOKER TYPE go.std.net.textproto/Error:
(def
  ^{:doc "An Error represents a numeric error response from a server.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE *go.std.net.textproto/Error:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  *Error)

JOKER TYPE go.std.net.textproto/MIMEHeader:
(def
  ^{:doc "A MIMEHeader represents a MIME-style header mapping\nkeys to sets of values.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_MIMEHeader"}
  MIMEHeader)

JOKER TYPE *go.std.net.textproto/MIMEHeader:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_MIMEHeader"}
  *MIMEHeader)

JOKER TYPE go.std.net.textproto/Pipeline:
(def
  ^{:doc "A Pipeline manages a pipelined in-order request/response sequence.\n\nTo use a Pipeline p to manage multiple clients on a connection,\neach client should run:\n\n\tid := p.Next()\t// take a number\n\n\tp.StartRequest(id)\t// wait for turn to send request\n\tsend request\n\tp.EndRequest(id)\t// notify Pipeline that request is sent\n\n\tp.StartResponse(id)\t// wait for turn to read response\n\tread response\n\tp.EndResponse(id)\t// notify Pipeline that response is read\n\nA pipelined server can use the same calls to ensure that\nresponses computed in parallel are written in the correct order.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Pipeline"}
  Pipeline)

JOKER TYPE *go.std.net.textproto/Pipeline:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Pipeline"}
  *Pipeline)

JOKER TYPE go.std.net.textproto/ProtocolError:
(def
  ^{:doc "A ProtocolError describes a protocol violation such\nas an invalid response or a hung-up connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_ProtocolError"}
  ProtocolError)

JOKER TYPE *go.std.net.textproto/ProtocolError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_ProtocolError"}
  *ProtocolError)

JOKER TYPE go.std.net.textproto/Reader:
(def
  ^{:doc "A Reader implements convenience methods for reading requests\nor responses from a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Reader"}
  Reader)

JOKER TYPE *go.std.net.textproto/Reader:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Reader"}
  *Reader)

JOKER TYPE go.std.net.textproto/Writer:
(def
  ^{:doc "A Writer implements convenience methods for writing\nrequests or responses to a text protocol network connection.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Writer"}
  Writer)

JOKER TYPE *go.std.net.textproto/Writer:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Writer"}
  *Writer)

JOKER TYPE net/url.Error from net/url/url.go:
(defn ^"GoObject" Error.
  "Constructor for url.Error"
  {:added "1.0"
   :go "_ConstructError(_v)"}
  [^Object _v])

JOKER TYPE net/url.EscapeError from net/url/url.go:
(defn ^"GoObject" EscapeError.
  "Constructor for url.EscapeError"
  {:added "1.0"
   :go "_ConstructEscapeError(_v)"}
  [^Object _v])

JOKER TYPE net/url.InvalidHostError from net/url/url.go:
(defn ^"GoObject" InvalidHostError.
  "Constructor for url.InvalidHostError"
  {:added "1.0"
   :go "_ConstructInvalidHostError(_v)"}
  [^Object _v])

JOKER TYPE net/url.URL from net/url/url.go:
;; (defn ^"GoObject" URL.
;;   "Constructor for url.URL"
;;   {:added "1.0"
;;    :go "_ConstructURL(_v)"}
;;   [^Object _v])

JOKER TYPE net/url.Userinfo from net/url/url.go:
(defn ^"GoObject" Userinfo.
  "Constructor for url.Userinfo"
  {:added "1.0"
   :go "_ConstructUserinfo(_v)"}
  [^Object _v])

JOKER TYPE net/url.Values from net/url/url.go:
;; (defn ^"GoObject" Values.
;;   "Constructor for url.Values"
;;   {:added "1.0"
;;    :go "_ConstructValues(_v)"}
;;   [^Object _v])

JOKER FUNC net/url.Parse from net/url/url.go:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parse(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.ParseQuery from net/url/url.go:
(defn ParseQuery
  "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [go.std.net.url/Values Error]"
  {:added "1.0"
   :go "__parseQuery(__query)"}
  [^String __query])

JOKER FUNC net/url.ParseRequestURI from net/url/url.go:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [(atom-of go.std.net.url/URL) Error]"
  {:added "1.0"
   :go "__parseRequestURI(__rawurl)"}
  [^String __rawurl])

JOKER FUNC net/url.PathEscape from net/url/url.go:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.PathUnescape from net/url/url.go:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__pathUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryEscape from net/url/url.go:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(__s)"}
  [^String __s])

JOKER FUNC net/url.QueryUnescape from net/url/url.go:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "__queryUnescape(__s)"}
  [^String __s])

JOKER FUNC net/url.User from net/url/url.go:
(defn User
  "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__user(__username)"}
  [^String __username])

JOKER FUNC net/url.UserPassword from net/url/url.go:
(defn UserPassword
  "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: (atom-of go.std.net.url/Userinfo)"
  {:added "1.0"
   :go "__userPassword(__username, __password)"}
  [^String __username, ^String __password])

JOKER TYPE go.std.net.url/Error:
(def
  ^{:doc "Error reports an error and the operation and URL that caused it.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Error"}
  Error)

JOKER TYPE *go.std.net.url/Error:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Error"}
  *Error)

JOKER TYPE go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_EscapeError"}
  EscapeError)

JOKER TYPE *go.std.net.url/EscapeError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_EscapeError"}
  *EscapeError)

JOKER TYPE go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_InvalidHostError"}
  InvalidHostError)

JOKER TYPE *go.std.net.url/InvalidHostError:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_InvalidHostError"}
  *InvalidHostError)

JOKER TYPE go.std.net.url/URL:
(def
  ^{:doc "A URL represents a parsed URL (technically, a URI reference).\n\nThe general form represented is:\n\n\t[scheme:][//[userinfo@]host][/]path[?query][#fragment]\n\nURLs that do not start with a slash after the scheme are interpreted as:\n\n\tscheme:opaque[?query][#fragment]\n\nNote that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.\nA consequence is that it is impossible to tell which slashes in the Path were\nslashes in the raw URL and which were %2f. This distinction is rarely important,\nbut when it is, code must not use Path directly.\nThe Parse function sets both Path and RawPath in the URL it returns,\nand URL's String method uses RawPath if it is a valid encoding of Path,\nby calling the EscapedPath method.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_URL"}
  URL)

JOKER TYPE *go.std.net.url/URL:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_URL"}
  *URL)

JOKER TYPE go.std.net.url/Userinfo:
(def
  ^{:doc "The Userinfo type is an immutable encapsulation of username and\npassword details for a URL. An existing Userinfo value is guaranteed\nto have a username set (potentially empty, as allowed by RFC 2396),\nand optionally a password.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Userinfo"}
  Userinfo)

JOKER TYPE *go.std.net.url/Userinfo:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Userinfo"}
  *Userinfo)

JOKER TYPE go.std.net.url/Values:
(def
  ^{:doc "Values maps a string key to a list of values.\nIt is typically used for query parameters and form values.\nUnlike in the http.Header map, the keys in a Values map\nare case-sensitive.\n"
    :added "1.0"
    :tag "GoType"
    :go "&info_Values"}
  Values)

JOKER TYPE *go.std.net.url/Values:
(def
  ^{:doc ""
    :added "1.0"
    :tag "GoType"
    :go "&info_PtrTo_Values"}
  *Values)

GO TYPE net.Addr from net/net.go:
func ExtractGoObjectAddr(args []Object, index int) *_net.Addr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Addr:
			return &r
		case *_net.Addr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Addr]"))
}

// func _ConstructAddr(_v Object) _net.Addr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Addr:
// 			return _g
// 		case *_net.Addr:
// 			return *_g
// 		}
// 	default:
// 		return _net.Addr(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Addr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Addr] or: whatever"))
// }

func ExtractGo_go_std_net__Addr(rcvr, arg string, args *ArraySeq, n int) (res _net.Addr) {
	a := CheckGoNth(rcvr, "go.std.net/Addr", arg, args, n).O
	res, ok := a.(_net.Addr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Addr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.AddrError from net/net.go:
func ExtractGoObjectAddrError(args []Object, index int) *_net.AddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.AddrError:
			return &r
		case *_net.AddrError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.AddrError]"))
}

func _mapToAddrError(o Map) *_net.AddrError {
	return &_net.AddrError{}
}

func _vectorToAddrError(o *Vector) *_net.AddrError {
	return &_net.AddrError{
		Err: AssertString(o.Nth(0), "").S,
		Addr: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddrError(_v Object) *_net.AddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.AddrError:
			return &_g
		case *_net.AddrError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddrError(_o.(Map))
	case *Vector:
		return _vectorToAddrError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.AddrError] or: Map or Vector"))
}

func ExtractGo_go_std_net__AddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.AddrError) {
	a := CheckGoNth(rcvr, "go.std.net/AddrError", arg, args, n).O
	res, ok := a.(_net.AddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/AddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Buffers from net/net.go:
func ExtractGoObjectBuffers(args []Object, index int) *_net.Buffers {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Buffers:
			return &r
		case *_net.Buffers:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Buffers]"))
}

// func _ConstructBuffers(_v Object) _net.Buffers {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Buffers:
// 			return _g
// 		case *_net.Buffers:
// 			return *_g
// 		}
// 	default:
// 		return _net.Buffers(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for Buffers))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Buffers] or: whatever"))
// }

func ExtractGo_go_std_net__Buffers(rcvr, arg string, args *ArraySeq, n int) (res _net.Buffers) {
	a := CheckGoNth(rcvr, "go.std.net/Buffers", arg, args, n).O
	res, ok := a.(_net.Buffers)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Buffers], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Conn from net/net.go:
func ExtractGoObjectConn(args []Object, index int) *_net.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Conn:
			return &r
		case *_net.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Conn]"))
}

// func _ConstructConn(_v Object) _net.Conn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Conn:
// 			return _g
// 		case *_net.Conn:
// 			return *_g
// 		}
// 	default:
// 		return _net.Conn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Conn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Conn] or: whatever"))
// }

func ExtractGo_go_std_net__Conn(rcvr, arg string, args *ArraySeq, n int) (res _net.Conn) {
	a := CheckGoNth(rcvr, "go.std.net/Conn", arg, args, n).O
	res, ok := a.(_net.Conn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Conn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.DNSConfigError from net/net.go:
func ExtractGoObjectDNSConfigError(args []Object, index int) *_net.DNSConfigError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSConfigError:
			return &r
		case *_net.DNSConfigError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSConfigError]"))
}

func _mapToDNSConfigError(o Map) *_net.DNSConfigError {
	return &_net.DNSConfigError{}
}

func _vectorToDNSConfigError(o *Vector) *_net.DNSConfigError {
	return &_net.DNSConfigError{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructDNSConfigError(_v Object) *_net.DNSConfigError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSConfigError:
			return &_g
		case *_net.DNSConfigError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSConfigError(_o.(Map))
	case *Vector:
		return _vectorToDNSConfigError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSConfigError] or: Map or Vector"))
}

func ExtractGo_go_std_net__DNSConfigError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSConfigError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSConfigError", arg, args, n).O
	res, ok := a.(_net.DNSConfigError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSConfigError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.DNSError from net/net.go:
func ExtractGoObjectDNSError(args []Object, index int) *_net.DNSError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.DNSError:
			return &r
		case *_net.DNSError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.DNSError]"))
}

func _mapToDNSError(o Map) *_net.DNSError {
	return &_net.DNSError{}
}

func _vectorToDNSError(o *Vector) *_net.DNSError {
	return &_net.DNSError{
		Err: AssertString(o.Nth(0), "").S,
		Name: AssertString(o.Nth(1), "").S,
		Server: AssertString(o.Nth(2), "").S,
		IsTimeout: ToBool(o.Nth(3)),
		IsTemporary: ToBool(o.Nth(4)),
	}
}

func _ConstructDNSError(_v Object) *_net.DNSError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.DNSError:
			return &_g
		case *_net.DNSError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSError(_o.(Map))
	case *Vector:
		return _vectorToDNSError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.DNSError] or: Map or Vector"))
}

func ExtractGo_go_std_net__DNSError(rcvr, arg string, args *ArraySeq, n int) (res _net.DNSError) {
	a := CheckGoNth(rcvr, "go.std.net/DNSError", arg, args, n).O
	res, ok := a.(_net.DNSError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/DNSError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Dialer from net/dial.go:
func ExtractGoObjectDialer(args []Object, index int) *_net.Dialer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Dialer:
			return &r
		case *_net.Dialer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Dialer]"))
}

// func _mapToDialer(o Map) *_net.Dialer {
// 	return &_net.Dialer{}
// }

// func _vectorToDialer(o *Vector) *_net.Dialer {
// 	return &_net.Dialer{
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Deadline: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		LocalAddr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		DualStack: ToBool(o.Nth(3)),
// 		FallbackDelay: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		KeepAlive: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Resolver: ABEND048(codegen.go: no conversion from Clojure for *net.Resolver (net.Resolver)),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructDialer(_v Object) *_net.Dialer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Dialer:
// 			return &_g
// 		case *_net.Dialer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDialer(_o.(Map))
// 	case *Vector:
// 		return _vectorToDialer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Dialer] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Dialer(rcvr, arg string, args *ArraySeq, n int) (res _net.Dialer) {
	a := CheckGoNth(rcvr, "go.std.net/Dialer", arg, args, n).O
	res, ok := a.(_net.Dialer)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Dialer], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Error from net/net.go:
func ExtractGoObjectError(args []Object, index int) *_net.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Error:
			return &r
		case *_net.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Error]"))
}

// func _ConstructError(_v Object) _net.Error {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Error:
// 			return _g
// 		case *_net.Error:
// 			return *_g
// 		}
// 	default:
// 		return _net.Error(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Error))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Error] or: whatever"))
// }

func ExtractGo_go_std_net__Error(rcvr, arg string, args *ArraySeq, n int) (res _net.Error) {
	a := CheckGoNth(rcvr, "go.std.net/Error", arg, args, n).O
	res, ok := a.(_net.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Flags from net/interface.go:
func ExtractGoObjectFlags(args []Object, index int) *_net.Flags {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Flags:
			return &r
		case *_net.Flags:
			return r
		}
	case Number:
		v := _net.Flags(ExtractUInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Flags]"))
}

func _ConstructFlags(_v Object) _net.Flags {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.Flags:
			return _g
		case *_net.Flags:
			return *_g
		}
	case Number:
		return _net.Flags(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Flags] or: Number"))
}

func ExtractGo_go_std_net__Flags(rcvr, arg string, args *ArraySeq, n int) (res _net.Flags) {
	a := CheckGoNth(rcvr, "go.std.net/Flags", arg, args, n).O
	res, ok := a.(_net.Flags)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Flags], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.HardwareAddr from net/mac.go:
func ExtractGoObjectHardwareAddr(args []Object, index int) *_net.HardwareAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.HardwareAddr:
			return &r
		case *_net.HardwareAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.HardwareAddr]"))
}

// func _ConstructHardwareAddr(_v Object) _net.HardwareAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.HardwareAddr:
// 			return _g
// 		case *_net.HardwareAddr:
// 			return *_g
// 		}
// 	default:
// 		return _net.HardwareAddr(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for HardwareAddr))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.HardwareAddr] or: whatever"))
// }

func ExtractGo_go_std_net__HardwareAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.HardwareAddr) {
	a := CheckGoNth(rcvr, "go.std.net/HardwareAddr", arg, args, n).O
	res, ok := a.(_net.HardwareAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/HardwareAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IP from net/ip.go:
func ExtractGoObjectIP(args []Object, index int) *_net.IP {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IP:
			return &r
		case *_net.IP:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IP]"))
}

// func _ConstructIP(_v Object) _net.IP {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IP:
// 			return _g
// 		case *_net.IP:
// 			return *_g
// 		}
// 	default:
// 		return _net.IP(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IP))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IP] or: whatever"))
// }

func ExtractGo_go_std_net__IP(rcvr, arg string, args *ArraySeq, n int) (res _net.IP) {
	a := CheckGoNth(rcvr, "go.std.net/IP", arg, args, n).O
	res, ok := a.(_net.IP)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IP], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IPAddr from net/iprawsock.go:
func ExtractGoObjectIPAddr(args []Object, index int) *_net.IPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPAddr:
			return &r
		case *_net.IPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPAddr]"))
}

// func _mapToIPAddr(o Map) *_net.IPAddr {
// 	return &_net.IPAddr{}
// }

// func _vectorToIPAddr(o *Vector) *_net.IPAddr {
// 	return &_net.IPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Zone: AssertString(o.Nth(1), "").S,
// 	}
// }

// func _ConstructIPAddr(_v Object) *_net.IPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPAddr:
// 			return &_g
// 		case *_net.IPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__IPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.IPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/IPAddr", arg, args, n).O
	res, ok := a.(_net.IPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IPConn from net/iprawsock.go:
func ExtractGoObjectIPConn(args []Object, index int) *_net.IPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPConn:
			return &r
		case *_net.IPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPConn]"))
}

func _mapToIPConn(o Map) *_net.IPConn {
	return &_net.IPConn{}
}

func _vectorToIPConn(o *Vector) *_net.IPConn {
	return &_net.IPConn{}
}

func _ConstructIPConn(_v Object) *_net.IPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.IPConn:
			return &_g
		case *_net.IPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToIPConn(_o.(Map))
	case *Vector:
		return _vectorToIPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__IPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.IPConn) {
	a := CheckGoNth(rcvr, "go.std.net/IPConn", arg, args, n).O
	res, ok := a.(_net.IPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IPMask from net/ip.go:
func ExtractGoObjectIPMask(args []Object, index int) *_net.IPMask {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPMask:
			return &r
		case *_net.IPMask:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPMask]"))
}

// func _ConstructIPMask(_v Object) _net.IPMask {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPMask:
// 			return _g
// 		case *_net.IPMask:
// 			return *_g
// 		}
// 	default:
// 		return _net.IPMask(_o.ABEND674(codegen.go: unknown underlying type *ast.ArrayType for IPMask))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPMask] or: whatever"))
// }

func ExtractGo_go_std_net__IPMask(rcvr, arg string, args *ArraySeq, n int) (res _net.IPMask) {
	a := CheckGoNth(rcvr, "go.std.net/IPMask", arg, args, n).O
	res, ok := a.(_net.IPMask)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPMask], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.IPNet from net/ip.go:
func ExtractGoObjectIPNet(args []Object, index int) *_net.IPNet {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.IPNet:
			return &r
		case *_net.IPNet:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.IPNet]"))
}

// func _mapToIPNet(o Map) *_net.IPNet {
// 	return &_net.IPNet{}
// }

// func _vectorToIPNet(o *Vector) *_net.IPNet {
// 	return &_net.IPNet{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Mask: ABEND048(codegen.go: no conversion from Clojure for net.IPMask ([]byte)),
// 	}
// }

// func _ConstructIPNet(_v Object) *_net.IPNet {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.IPNet:
// 			return &_g
// 		case *_net.IPNet:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToIPNet(_o.(Map))
// 	case *Vector:
// 		return _vectorToIPNet(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.IPNet] or: Map or Vector"))
// }

func ExtractGo_go_std_net__IPNet(rcvr, arg string, args *ArraySeq, n int) (res _net.IPNet) {
	a := CheckGoNth(rcvr, "go.std.net/IPNet", arg, args, n).O
	res, ok := a.(_net.IPNet)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/IPNet], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Interface from net/interface.go:
func ExtractGoObjectInterface(args []Object, index int) *_net.Interface {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Interface:
			return &r
		case *_net.Interface:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Interface]"))
}

// func _mapToInterface(o Map) *_net.Interface {
// 	return &_net.Interface{}
// }

// func _vectorToInterface(o *Vector) *_net.Interface {
// 	return &_net.Interface{
// 		Index: AssertInt(o.Nth(0), "").I,
// 		MTU: AssertInt(o.Nth(1), "").I,
// 		Name: AssertString(o.Nth(2), "").S,
// 		HardwareAddr: ABEND048(codegen.go: no conversion from Clojure for net.HardwareAddr ([]byte)),
// 		Flags: _net.Flags(uint(AssertInt(o.Nth(4), "").I)),
// 	}
// }

// func _ConstructInterface(_v Object) *_net.Interface {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Interface:
// 			return &_g
// 		case *_net.Interface:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToInterface(_o.(Map))
// 	case *Vector:
// 		return _vectorToInterface(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Interface] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Interface(rcvr, arg string, args *ArraySeq, n int) (res _net.Interface) {
	a := CheckGoNth(rcvr, "go.std.net/Interface", arg, args, n).O
	res, ok := a.(_net.Interface)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Interface], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.InvalidAddrError from net/net.go:
func ExtractGoObjectInvalidAddrError(args []Object, index int) *_net.InvalidAddrError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.InvalidAddrError:
			return &r
		case *_net.InvalidAddrError:
			return r
		}
	case String:
		v := _net.InvalidAddrError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.InvalidAddrError]"))
}

func _ConstructInvalidAddrError(_v Object) _net.InvalidAddrError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.InvalidAddrError:
			return _g
		case *_net.InvalidAddrError:
			return *_g
		}
	case String:
		return _net.InvalidAddrError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.InvalidAddrError] or: String"))
}

func ExtractGo_go_std_net__InvalidAddrError(rcvr, arg string, args *ArraySeq, n int) (res _net.InvalidAddrError) {
	a := CheckGoNth(rcvr, "go.std.net/InvalidAddrError", arg, args, n).O
	res, ok := a.(_net.InvalidAddrError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/InvalidAddrError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.ListenConfig from net/dial.go:
func ExtractGoObjectListenConfig(args []Object, index int) *_net.ListenConfig {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ListenConfig:
			return &r
		case *_net.ListenConfig:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ListenConfig]"))
}

// func _mapToListenConfig(o Map) *_net.ListenConfig {
// 	return &_net.ListenConfig{}
// }

// func _vectorToListenConfig(o *Vector) *_net.ListenConfig {
// 	return &_net.ListenConfig{
// 		Control: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructListenConfig(_v Object) *_net.ListenConfig {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.ListenConfig:
// 			return &_g
// 		case *_net.ListenConfig:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToListenConfig(_o.(Map))
// 	case *Vector:
// 		return _vectorToListenConfig(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ListenConfig] or: Map or Vector"))
// }

func ExtractGo_go_std_net__ListenConfig(rcvr, arg string, args *ArraySeq, n int) (res _net.ListenConfig) {
	a := CheckGoNth(rcvr, "go.std.net/ListenConfig", arg, args, n).O
	res, ok := a.(_net.ListenConfig)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/ListenConfig], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Listener from net/net.go:
func ExtractGoObjectListener(args []Object, index int) *_net.Listener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Listener:
			return &r
		case *_net.Listener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Listener]"))
}

// func _ConstructListener(_v Object) _net.Listener {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Listener:
// 			return _g
// 		case *_net.Listener:
// 			return *_g
// 		}
// 	default:
// 		return _net.Listener(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Listener))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Listener] or: whatever"))
// }

func ExtractGo_go_std_net__Listener(rcvr, arg string, args *ArraySeq, n int) (res _net.Listener) {
	a := CheckGoNth(rcvr, "go.std.net/Listener", arg, args, n).O
	res, ok := a.(_net.Listener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Listener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.MX from net/dnsclient.go:
func ExtractGoObjectMX(args []Object, index int) *_net.MX {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.MX:
			return &r
		case *_net.MX:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.MX]"))
}

func _mapToMX(o Map) *_net.MX {
	return &_net.MX{}
}

func _vectorToMX(o *Vector) *_net.MX {
	return &_net.MX{
		Host: AssertString(o.Nth(0), "").S,
		Pref: uint16(AssertInt(o.Nth(1), "").I),
	}
}

func _ConstructMX(_v Object) *_net.MX {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.MX:
			return &_g
		case *_net.MX:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToMX(_o.(Map))
	case *Vector:
		return _vectorToMX(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.MX] or: Map or Vector"))
}

func ExtractGo_go_std_net__MX(rcvr, arg string, args *ArraySeq, n int) (res _net.MX) {
	a := CheckGoNth(rcvr, "go.std.net/MX", arg, args, n).O
	res, ok := a.(_net.MX)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/MX], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.NS from net/dnsclient.go:
func ExtractGoObjectNS(args []Object, index int) *_net.NS {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.NS:
			return &r
		case *_net.NS:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.NS]"))
}

func _mapToNS(o Map) *_net.NS {
	return &_net.NS{}
}

func _vectorToNS(o *Vector) *_net.NS {
	return &_net.NS{
		Host: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructNS(_v Object) *_net.NS {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.NS:
			return &_g
		case *_net.NS:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToNS(_o.(Map))
	case *Vector:
		return _vectorToNS(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.NS] or: Map or Vector"))
}

func ExtractGo_go_std_net__NS(rcvr, arg string, args *ArraySeq, n int) (res _net.NS) {
	a := CheckGoNth(rcvr, "go.std.net/NS", arg, args, n).O
	res, ok := a.(_net.NS)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/NS], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.OpError from net/net.go:
func ExtractGoObjectOpError(args []Object, index int) *_net.OpError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.OpError:
			return &r
		case *_net.OpError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.OpError]"))
}

// func _mapToOpError(o Map) *_net.OpError {
// 	return &_net.OpError{}
// }

// func _vectorToOpError(o *Vector) *_net.OpError {
// 	return &_net.OpError{
// 		Op: AssertString(o.Nth(0), "").S,
// 		Net: AssertString(o.Nth(1), "").S,
// 		Source: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Addr: ABEND048(codegen.go: no conversion from Clojure for net.Addr (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Err: _errors.New(AssertString(o.Nth(4), "").S),
// 	}
// }

// func _ConstructOpError(_v Object) *_net.OpError {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.OpError:
// 			return &_g
// 		case *_net.OpError:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOpError(_o.(Map))
// 	case *Vector:
// 		return _vectorToOpError(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.OpError] or: Map or Vector"))
// }

func ExtractGo_go_std_net__OpError(rcvr, arg string, args *ArraySeq, n int) (res _net.OpError) {
	a := CheckGoNth(rcvr, "go.std.net/OpError", arg, args, n).O
	res, ok := a.(_net.OpError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/OpError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.PacketConn from net/net.go:
func ExtractGoObjectPacketConn(args []Object, index int) *_net.PacketConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.PacketConn:
			return &r
		case *_net.PacketConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.PacketConn]"))
}

// func _ConstructPacketConn(_v Object) _net.PacketConn {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.PacketConn:
// 			return _g
// 		case *_net.PacketConn:
// 			return *_g
// 		}
// 	default:
// 		return _net.PacketConn(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PacketConn))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.PacketConn] or: whatever"))
// }

func ExtractGo_go_std_net__PacketConn(rcvr, arg string, args *ArraySeq, n int) (res _net.PacketConn) {
	a := CheckGoNth(rcvr, "go.std.net/PacketConn", arg, args, n).O
	res, ok := a.(_net.PacketConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/PacketConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.ParseError from net/net.go:
func ExtractGoObjectParseError(args []Object, index int) *_net.ParseError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.ParseError:
			return &r
		case *_net.ParseError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.ParseError]"))
}

func _mapToParseError(o Map) *_net.ParseError {
	return &_net.ParseError{}
}

func _vectorToParseError(o *Vector) *_net.ParseError {
	return &_net.ParseError{
		Type: AssertString(o.Nth(0), "").S,
		Text: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructParseError(_v Object) *_net.ParseError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.ParseError:
			return &_g
		case *_net.ParseError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToParseError(_o.(Map))
	case *Vector:
		return _vectorToParseError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.ParseError] or: Map or Vector"))
}

func ExtractGo_go_std_net__ParseError(rcvr, arg string, args *ArraySeq, n int) (res _net.ParseError) {
	a := CheckGoNth(rcvr, "go.std.net/ParseError", arg, args, n).O
	res, ok := a.(_net.ParseError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/ParseError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.Resolver from net/lookup.go:
func ExtractGoObjectResolver(args []Object, index int) *_net.Resolver {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.Resolver:
			return &r
		case *_net.Resolver:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.Resolver]"))
}

// func _mapToResolver(o Map) *_net.Resolver {
// 	return &_net.Resolver{}
// }

// func _vectorToResolver(o *Vector) *_net.Resolver {
// 	return &_net.Resolver{
// 		PreferGo: ToBool(o.Nth(0)),
// 		StrictErrors: ToBool(o.Nth(1)),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructResolver(_v Object) *_net.Resolver {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.Resolver:
// 			return &_g
// 		case *_net.Resolver:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResolver(_o.(Map))
// 	case *Vector:
// 		return _vectorToResolver(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.Resolver] or: Map or Vector"))
// }

func ExtractGo_go_std_net__Resolver(rcvr, arg string, args *ArraySeq, n int) (res _net.Resolver) {
	a := CheckGoNth(rcvr, "go.std.net/Resolver", arg, args, n).O
	res, ok := a.(_net.Resolver)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/Resolver], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.SRV from net/dnsclient.go:
func ExtractGoObjectSRV(args []Object, index int) *_net.SRV {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.SRV:
			return &r
		case *_net.SRV:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.SRV]"))
}

func _mapToSRV(o Map) *_net.SRV {
	return &_net.SRV{}
}

func _vectorToSRV(o *Vector) *_net.SRV {
	return &_net.SRV{
		Target: AssertString(o.Nth(0), "").S,
		Port: uint16(AssertInt(o.Nth(1), "").I),
		Priority: uint16(AssertInt(o.Nth(2), "").I),
		Weight: uint16(AssertInt(o.Nth(3), "").I),
	}
}

func _ConstructSRV(_v Object) *_net.SRV {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.SRV:
			return &_g
		case *_net.SRV:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToSRV(_o.(Map))
	case *Vector:
		return _vectorToSRV(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.SRV] or: Map or Vector"))
}

func ExtractGo_go_std_net__SRV(rcvr, arg string, args *ArraySeq, n int) (res _net.SRV) {
	a := CheckGoNth(rcvr, "go.std.net/SRV", arg, args, n).O
	res, ok := a.(_net.SRV)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/SRV], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.TCPAddr from net/tcpsock.go:
func ExtractGoObjectTCPAddr(args []Object, index int) *_net.TCPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPAddr:
			return &r
		case *_net.TCPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPAddr]"))
}

// func _mapToTCPAddr(o Map) *_net.TCPAddr {
// 	return &_net.TCPAddr{}
// }

// func _vectorToTCPAddr(o *Vector) *_net.TCPAddr {
// 	return &_net.TCPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructTCPAddr(_v Object) *_net.TCPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.TCPAddr:
// 			return &_g
// 		case *_net.TCPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTCPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToTCPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__TCPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/TCPAddr", arg, args, n).O
	res, ok := a.(_net.TCPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.TCPConn from net/tcpsock.go:
func ExtractGoObjectTCPConn(args []Object, index int) *_net.TCPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPConn:
			return &r
		case *_net.TCPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPConn]"))
}

func _mapToTCPConn(o Map) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _vectorToTCPConn(o *Vector) *_net.TCPConn {
	return &_net.TCPConn{}
}

func _ConstructTCPConn(_v Object) *_net.TCPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPConn:
			return &_g
		case *_net.TCPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPConn(_o.(Map))
	case *Vector:
		return _vectorToTCPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__TCPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPConn) {
	a := CheckGoNth(rcvr, "go.std.net/TCPConn", arg, args, n).O
	res, ok := a.(_net.TCPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.TCPListener from net/tcpsock.go:
func ExtractGoObjectTCPListener(args []Object, index int) *_net.TCPListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.TCPListener:
			return &r
		case *_net.TCPListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.TCPListener]"))
}

func _mapToTCPListener(o Map) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _vectorToTCPListener(o *Vector) *_net.TCPListener {
	return &_net.TCPListener{}
}

func _ConstructTCPListener(_v Object) *_net.TCPListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.TCPListener:
			return &_g
		case *_net.TCPListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToTCPListener(_o.(Map))
	case *Vector:
		return _vectorToTCPListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.TCPListener] or: Map or Vector"))
}

func ExtractGo_go_std_net__TCPListener(rcvr, arg string, args *ArraySeq, n int) (res _net.TCPListener) {
	a := CheckGoNth(rcvr, "go.std.net/TCPListener", arg, args, n).O
	res, ok := a.(_net.TCPListener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/TCPListener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UDPAddr from net/udpsock.go:
func ExtractGoObjectUDPAddr(args []Object, index int) *_net.UDPAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPAddr:
			return &r
		case *_net.UDPAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPAddr]"))
}

// func _mapToUDPAddr(o Map) *_net.UDPAddr {
// 	return &_net.UDPAddr{}
// }

// func _vectorToUDPAddr(o *Vector) *_net.UDPAddr {
// 	return &_net.UDPAddr{
// 		IP: ABEND048(codegen.go: no conversion from Clojure for net.IP ([]byte)),
// 		Port: AssertInt(o.Nth(1), "").I,
// 		Zone: AssertString(o.Nth(2), "").S,
// 	}
// }

// func _ConstructUDPAddr(_v Object) *_net.UDPAddr {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _net.UDPAddr:
// 			return &_g
// 		case *_net.UDPAddr:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToUDPAddr(_o.(Map))
// 	case *Vector:
// 		return _vectorToUDPAddr(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPAddr] or: Map or Vector"))
// }

func ExtractGo_go_std_net__UDPAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.UDPAddr) {
	a := CheckGoNth(rcvr, "go.std.net/UDPAddr", arg, args, n).O
	res, ok := a.(_net.UDPAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UDPAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UDPConn from net/udpsock.go:
func ExtractGoObjectUDPConn(args []Object, index int) *_net.UDPConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UDPConn:
			return &r
		case *_net.UDPConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UDPConn]"))
}

func _mapToUDPConn(o Map) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _vectorToUDPConn(o *Vector) *_net.UDPConn {
	return &_net.UDPConn{}
}

func _ConstructUDPConn(_v Object) *_net.UDPConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UDPConn:
			return &_g
		case *_net.UDPConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUDPConn(_o.(Map))
	case *Vector:
		return _vectorToUDPConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UDPConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__UDPConn(rcvr, arg string, args *ArraySeq, n int) (res _net.UDPConn) {
	a := CheckGoNth(rcvr, "go.std.net/UDPConn", arg, args, n).O
	res, ok := a.(_net.UDPConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UDPConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UnixAddr from net/unixsock.go:
func ExtractGoObjectUnixAddr(args []Object, index int) *_net.UnixAddr {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixAddr:
			return &r
		case *_net.UnixAddr:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixAddr]"))
}

func _mapToUnixAddr(o Map) *_net.UnixAddr {
	return &_net.UnixAddr{}
}

func _vectorToUnixAddr(o *Vector) *_net.UnixAddr {
	return &_net.UnixAddr{
		Name: AssertString(o.Nth(0), "").S,
		Net: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructUnixAddr(_v Object) *_net.UnixAddr {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixAddr:
			return &_g
		case *_net.UnixAddr:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixAddr(_o.(Map))
	case *Vector:
		return _vectorToUnixAddr(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixAddr] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixAddr(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixAddr) {
	a := CheckGoNth(rcvr, "go.std.net/UnixAddr", arg, args, n).O
	res, ok := a.(_net.UnixAddr)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixAddr], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UnixConn from net/unixsock.go:
func ExtractGoObjectUnixConn(args []Object, index int) *_net.UnixConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixConn:
			return &r
		case *_net.UnixConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixConn]"))
}

func _mapToUnixConn(o Map) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _vectorToUnixConn(o *Vector) *_net.UnixConn {
	return &_net.UnixConn{}
}

func _ConstructUnixConn(_v Object) *_net.UnixConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixConn:
			return &_g
		case *_net.UnixConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixConn(_o.(Map))
	case *Vector:
		return _vectorToUnixConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixConn] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixConn(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixConn) {
	a := CheckGoNth(rcvr, "go.std.net/UnixConn", arg, args, n).O
	res, ok := a.(_net.UnixConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UnixListener from net/unixsock.go:
func ExtractGoObjectUnixListener(args []Object, index int) *_net.UnixListener {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnixListener:
			return &r
		case *_net.UnixListener:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnixListener]"))
}

func _mapToUnixListener(o Map) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _vectorToUnixListener(o *Vector) *_net.UnixListener {
	return &_net.UnixListener{}
}

func _ConstructUnixListener(_v Object) *_net.UnixListener {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnixListener:
			return &_g
		case *_net.UnixListener:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUnixListener(_o.(Map))
	case *Vector:
		return _vectorToUnixListener(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnixListener] or: Map or Vector"))
}

func ExtractGo_go_std_net__UnixListener(rcvr, arg string, args *ArraySeq, n int) (res _net.UnixListener) {
	a := CheckGoNth(rcvr, "go.std.net/UnixListener", arg, args, n).O
	res, ok := a.(_net.UnixListener)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnixListener], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net.UnknownNetworkError from net/net.go:
func ExtractGoObjectUnknownNetworkError(args []Object, index int) *_net.UnknownNetworkError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _net.UnknownNetworkError:
			return &r
		case *_net.UnknownNetworkError:
			return r
		}
	case String:
		v := _net.UnknownNetworkError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net.UnknownNetworkError]"))
}

func _ConstructUnknownNetworkError(_v Object) _net.UnknownNetworkError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _net.UnknownNetworkError:
			return _g
		case *_net.UnknownNetworkError:
			return *_g
		}
	case String:
		return _net.UnknownNetworkError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[net.UnknownNetworkError] or: String"))
}

func ExtractGo_go_std_net__UnknownNetworkError(rcvr, arg string, args *ArraySeq, n int) (res _net.UnknownNetworkError) {
	a := CheckGoNth(rcvr, "go.std.net/UnknownNetworkError", arg, args, n).O
	res, ok := a.(_net.UnknownNetworkError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net/UnknownNetworkError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net.CIDRMask from net/ip.go:
func __cIDRMask(__ones int, __bits int) Object {
	_res := _net.CIDRMask(__ones, __bits)
	return MakeGoObject(_res)
}

GO FUNC net.Dial from net/dial.go:
func __dial(__network string, __address string) Object {
	_res1, _res2 := _net.Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialIP from net/iprawsock.go:
func __dialIP(__network string, __laddr *_net.IPAddr, __raddr *_net.IPAddr) Object {
	_res1, _res2 := _net.DialIP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTCP from net/tcpsock.go:
func __dialTCP(__network string, __laddr *_net.TCPAddr, __raddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.DialTCP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialTimeout from net/dial.go:
// func __dialTimeout(__network string, __address string, __timeout ABEND987(genutils.go: imports not yet supported: time.Duration)) Object {
// 	_res1, _res2 := _net.DialTimeout(__network, __address, __timeout)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP from net/udpsock.go:
func __dialUDP(__network string, __laddr *_net.UDPAddr, __raddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.DialUDP(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.DialUnix from net/unixsock.go:
func __dialUnix(__network string, __laddr *_net.UnixAddr, __raddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.DialUnix(__network, __laddr, __raddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.FileConn from net/file.go:
// func __fileConn(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FileConn(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener from net/file.go:
// func __fileListener(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	ln, err := _net.FileListener(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(ln))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn from net/file.go:
// func __filePacketConn(__f *ABEND987(genutils.go: imports not yet supported: os.File)) Object {
// 	c, err := _net.FilePacketConn(__f)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(c))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4 from net/ip.go:
func __iPv4(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

GO FUNC net.IPv4Mask from net/ip.go:
func __iPv4Mask(__a byte, __b byte, __c byte, __d byte) Object {
	_res := _net.IPv4Mask(__a, __b, __c, __d)
	return MakeGoObject(_res)
}

GO FUNC net.InterfaceAddrs from net/interface.go:
func __interfaceAddrs() Object {
	_res1, _res2 := _net.InterfaceAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByIndex from net/interface.go:
func __interfaceByIndex(__index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(__index)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName from net/interface.go:
func __interfaceByName(__name string) Object {
	_res1, _res2 := _net.InterfaceByName(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces from net/interface.go:
func __interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen from net/dial.go:
func __listen(__network string, __address string) Object {
	_res1, _res2 := _net.Listen(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenIP from net/iprawsock.go:
func __listenIP(__network string, __laddr *_net.IPAddr) Object {
	_res1, _res2 := _net.ListenIP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenMulticastUDP from net/udpsock.go:
func __listenMulticastUDP(__network string, __ifi *_net.Interface, __gaddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenMulticastUDP(__network, __ifi, __gaddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenPacket from net/dial.go:
func __listenPacket(__network string, __address string) Object {
	_res1, _res2 := _net.ListenPacket(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenTCP from net/tcpsock.go:
func __listenTCP(__network string, __laddr *_net.TCPAddr) Object {
	_res1, _res2 := _net.ListenTCP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUDP from net/udpsock.go:
func __listenUDP(__network string, __laddr *_net.UDPAddr) Object {
	_res1, _res2 := _net.ListenUDP(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnix from net/unixsock.go:
func __listenUnix(__network string, __laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnix(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ListenUnixgram from net/unixsock.go:
func __listenUnixgram(__network string, __laddr *_net.UnixAddr) Object {
	_res1, _res2 := _net.ListenUnixgram(__network, __laddr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupAddr from net/lookup.go:
func __lookupAddr(__addr string) Object {
	names, err := _net.LookupAddr(__addr)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME from net/lookup.go:
func __lookupCNAME(__host string) Object {
	cname, err := _net.LookupCNAME(__host)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost from net/lookup.go:
func __lookupHost(__host string) Object {
	addrs, err := _net.LookupHost(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP from net/lookup.go:
func __lookupIP(__host string) Object {
	_res1, _res2 := _net.LookupIP(__host)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX from net/lookup.go:
func __lookupMX(__name string) Object {
	_res1, _res2 := _net.LookupMX(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS from net/lookup.go:
func __lookupNS(__name string) Object {
	_res1, _res2 := _net.LookupNS(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort from net/lookup.go:
func __lookupPort(__network string, __service string) Object {
	port, err := _net.LookupPort(__network, __service)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV from net/lookup.go:
func __lookupSRV(__service string, __proto string, __name string) Object {
	cname, addrs, err := _net.LookupSRV(__service, __proto, __name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector()
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT from net/lookup.go:
func __lookupTXT(__name string) Object {
	_res1, _res2 := _net.LookupTXT(__name)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR from net/ip.go:
func __parseCIDR(__s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP from net/ip.go:
func __parseIP(__s string) Object {
	_res := _net.ParseIP(__s)
	return MakeGoObject(_res)
}

GO FUNC net.ParseMAC from net/mac.go:
func __parseMAC(__s string) Object {
	hw, err := _net.ParseMAC(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(hw))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe from net/pipe.go:
func __pipe() Object {
	_res1, _res2 := _net.Pipe()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(MakeGoObject(_res2))
	return _res
}

GO FUNC net.ResolveIPAddr from net/iprawsock.go:
func __resolveIPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr from net/tcpsock.go:
func __resolveTCPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr from net/udpsock.go:
func __resolveUDPAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr from net/unixsock.go:
func __resolveUnixAddr(__network string, __address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort from net/ipsock.go:
func __splitHostPort(__hostport string) Object {
	host, port, err := _net.SplitHostPort(__hostport)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.__addr_Network from net/net.go:
func __addr_Network(o GoObject, args Object) Object {
	CheckGoArity("(net.Addr)Network()", args, 0, 0)
	_res := o.O.(_net.Addr).Network()
	return MakeString(_res)
}

GO FUNC net.__addr_String from net/net.go:
func __addr_String(o GoObject, args Object) Object {
	CheckGoArity("(net.Addr)String()", args, 0, 0)
	_res := o.O.(_net.Addr).String()
	return MakeString(_res)
}

GO FUNC net.__conn_Close from net/net.go:
func __conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(net.Conn)Close()", args, 0, 0)
	_res := o.O.(_net.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__conn_LocalAddr from net/net.go:
func __conn_LocalAddr(o GoObject, args Object) Object {
	CheckGoArity("(net.Conn)LocalAddr()", args, 0, 0)
	_res := o.O.(_net.Conn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__conn_Read from net/net.go:
// func __conn_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__conn_RemoteAddr from net/net.go:
func __conn_RemoteAddr(o GoObject, args Object) Object {
	CheckGoArity("(net.Conn)RemoteAddr()", args, 0, 0)
	_res := o.O.(_net.Conn).RemoteAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__conn_SetDeadline from net/net.go:
// func __conn_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_SetReadDeadline from net/net.go:
// func __conn_SetReadDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_SetWriteDeadline from net/net.go:
// func __conn_SetWriteDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__conn_Write from net/net.go:
// func __conn_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__error_Error from net/net.go:
// func __error_Error(o GoObject, args Object) Object {
// 	CheckGoArity("(net.Error)Error()", args, 0, 0)
// 	return o.O.(_net.Error).Error()
// 	ABEND124(post.go: no public information returned)
// }

GO FUNC net.__error_Temporary from net/net.go:
func __error_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(net.Error)Temporary()", args, 0, 0)
	_res := o.O.(_net.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__error_Timeout from net/net.go:
func __error_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(net.Error)Timeout()", args, 0, 0)
	_res := o.O.(_net.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__flags_String from net/interface.go:
func __flags_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.Flags)String()", args, 0, 0)
	_res := o.O.(_net.Flags).String()
	return MakeString(_res)
}

GO FUNC net.__hardwareAddr_String from net/mac.go:
func __hardwareAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.HardwareAddr)String()", args, 0, 0)
	_res := o.O.(_net.HardwareAddr).String()
	return MakeString(_res)
}

GO FUNC net.__iPMask_Size from net/ip.go:
func __iPMask_Size(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)Size()", args, 0, 0)
	ones, bits := o.O.(_net.IPMask).Size()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(ones))
	_res = _res.Conjoin(MakeInt(bits))
	return _res
}

GO FUNC net.__iPMask_String from net/ip.go:
func __iPMask_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IPMask)String()", args, 0, 0)
	_res := o.O.(_net.IPMask).String()
	return MakeString(_res)
}

GO FUNC net.__iP_DefaultMask from net/ip.go:
func __iP_DefaultMask(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)DefaultMask()", args, 0, 0)
	_res := o.O.(_net.IP).DefaultMask()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_Equal from net/ip.go:
func __iP_Equal(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Equal()", args, 1, 1)
	__x := ExtractGo_go_std_net__IP("(_net.IP)Equal()", "__x", _argList, 0)
	_res := o.O.(_net.IP).Equal(__x)
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsGlobalUnicast from net/ip.go:
func __iP_IsGlobalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsGlobalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsGlobalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsInterfaceLocalMulticast from net/ip.go:
func __iP_IsInterfaceLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsInterfaceLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsInterfaceLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalMulticast from net/ip.go:
func __iP_IsLinkLocalMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLinkLocalUnicast from net/ip.go:
func __iP_IsLinkLocalUnicast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLinkLocalUnicast()", args, 0, 0)
	_res := o.O.(_net.IP).IsLinkLocalUnicast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsLoopback from net/ip.go:
func __iP_IsLoopback(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsLoopback()", args, 0, 0)
	_res := o.O.(_net.IP).IsLoopback()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsMulticast from net/ip.go:
func __iP_IsMulticast(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsMulticast()", args, 0, 0)
	_res := o.O.(_net.IP).IsMulticast()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_IsUnspecified from net/ip.go:
func __iP_IsUnspecified(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)IsUnspecified()", args, 0, 0)
	_res := o.O.(_net.IP).IsUnspecified()
	return MakeBoolean(_res)
}

GO FUNC net.__iP_MarshalText from net/ip.go:
func __iP_MarshalText(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)MarshalText()", args, 0, 0)
	_res1, _res2 := o.O.(_net.IP).MarshalText()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__iP_Mask from net/ip.go:
func __iP_Mask(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net.IP)Mask()", args, 1, 1)
	__mask := ExtractGo_go_std_net__IPMask("(_net.IP)Mask()", "__mask", _argList, 0)
	_res := o.O.(_net.IP).Mask(__mask)
	return MakeGoObject(_res)
}

GO FUNC net.__iP_String from net/ip.go:
func __iP_String(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)String()", args, 0, 0)
	_res := o.O.(_net.IP).String()
	return MakeString(_res)
}

GO FUNC net.__iP_To16 from net/ip.go:
func __iP_To16(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To16()", args, 0, 0)
	_res := o.O.(_net.IP).To16()
	return MakeGoObject(_res)
}

GO FUNC net.__iP_To4 from net/ip.go:
func __iP_To4(o GoObject, args Object) Object {
	CheckGoArity("(_net.IP)To4()", args, 0, 0)
	_res := o.O.(_net.IP).To4()
	return MakeGoObject(_res)
}

GO FUNC net.__invalidAddrError_Error from net/net.go:
func __invalidAddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Error()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__invalidAddrError_Temporary from net/net.go:
func __invalidAddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Temporary()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__invalidAddrError_Timeout from net/net.go:
func __invalidAddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.InvalidAddrError)Timeout()", args, 0, 0)
	_res := o.O.(_net.InvalidAddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__listener_Accept from net/net.go:
func __listener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(net.Listener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(_net.Listener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__listener_Addr from net/net.go:
func __listener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(net.Listener)Addr()", args, 0, 0)
	_res := o.O.(_net.Listener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__listener_Close from net/net.go:
func __listener_Close(o GoObject, args Object) Object {
	CheckGoArity("(net.Listener)Close()", args, 0, 0)
	_res := o.O.(_net.Listener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__packetConn_Close from net/net.go:
func __packetConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(net.PacketConn)Close()", args, 0, 0)
	_res := o.O.(_net.PacketConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__packetConn_LocalAddr from net/net.go:
func __packetConn_LocalAddr(o GoObject, args Object) Object {
	CheckGoArity("(net.PacketConn)LocalAddr()", args, 0, 0)
	_res := o.O.(_net.PacketConn).LocalAddr()
	return MakeGoObject(_res)
}

GO FUNC net.__packetConn_ReadFrom from net/net.go:
// func __packetConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))}

GO FUNC net.__packetConn_SetDeadline from net/net.go:
// func __packetConn_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_SetReadDeadline from net/net.go:
// func __packetConn_SetReadDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_SetWriteDeadline from net/net.go:
// func __packetConn_SetWriteDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__packetConn_WriteTo from net/net.go:
// func __packetConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)), *__addr)}

GO FUNC net.__ptrTo_AddrError_Error from net/net.go:
func __ptrTo_AddrError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Error()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_AddrError_Temporary from net/net.go:
func __ptrTo_AddrError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_AddrError_Timeout from net/net.go:
func __ptrTo_AddrError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.AddrError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.AddrError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_Buffers_Read from net/net.go:
// func __ptrTo_Buffers_Read(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__p)))}

GO FUNC net.__ptrTo_Buffers_WriteTo from net/net.go:
// func __ptrTo_Buffers_WriteTo(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net.__ptrTo_DNSConfigError_Error from net/net.go:
func __ptrTo_DNSConfigError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Temporary from net/net.go:
func __ptrTo_DNSConfigError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSConfigError_Timeout from net/net.go:
func __ptrTo_DNSConfigError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSConfigError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSConfigError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Error from net/net.go:
func __ptrTo_DNSError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Error()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_DNSError_Temporary from net/net.go:
func __ptrTo_DNSError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_DNSError_Timeout from net/net.go:
func __ptrTo_DNSError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.DNSError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.DNSError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_Dialer_Dial from net/dial.go:
func __ptrTo_Dialer_Dial(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.Dialer)Dial()", args, 2, 2)
	__network := ExtractGoString("(*_net.Dialer)Dial()", "__network", _argList, 0)
	__address := ExtractGoString("(*_net.Dialer)Dial()", "__address", _argList, 1)
	_res1, _res2 := o.O.(*_net.Dialer).Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_Dialer_DialContext from net/dial.go:
// func __ptrTo_Dialer_DialContext(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

GO FUNC net.__ptrTo_IPAddr_Network from net/iprawsock.go:
func __ptrTo_IPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPAddr_String from net/iprawsock.go:
func __ptrTo_IPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.IPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPConn_ReadFrom from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_IPConn_ReadFromIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadFromIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_IPConn_ReadMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_ReadMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

GO FUNC net.__ptrTo_IPConn_SyscallConn from net/iprawsock.go:
// func __ptrTo_IPConn_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_IPConn_WriteMsgIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteMsgIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

GO FUNC net.__ptrTo_IPConn_WriteTo from net/iprawsock.go:
// func __ptrTo_IPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

GO FUNC net.__ptrTo_IPConn_WriteToIP from net/iprawsock.go:
// func __ptrTo_IPConn_WriteToIP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

GO FUNC net.__ptrTo_IPNet_Contains from net/ip.go:
func __ptrTo_IPNet_Contains(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.IPNet)Contains()", args, 1, 1)
	__ip := ExtractGo_go_std_net__IP("(*_net.IPNet)Contains()", "__ip", _argList, 0)
	_res := o.O.(*_net.IPNet).Contains(__ip)
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_IPNet_Network from net/ip.go:
func __ptrTo_IPNet_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)Network()", args, 0, 0)
	_res := o.O.(*_net.IPNet).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IPNet_String from net/ip.go:
func __ptrTo_IPNet_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.IPNet)String()", args, 0, 0)
	_res := o.O.(*_net.IPNet).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_IP_UnmarshalText from net/ip.go:
// func __ptrTo_IP_UnmarshalText(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

GO FUNC net.__ptrTo_Interface_Addrs from net/interface.go:
func __ptrTo_Interface_Addrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)Addrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).Addrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_Interface_MulticastAddrs from net/interface.go:
func __ptrTo_Interface_MulticastAddrs(o GoObject, args Object) Object {
	CheckGoArity("(*_net.Interface)MulticastAddrs()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.Interface).MulticastAddrs()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_ListenConfig_Listen from net/dial.go:
// func __ptrTo_ListenConfig_Listen(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

GO FUNC net.__ptrTo_ListenConfig_ListenPacket from net/dial.go:
// func __ptrTo_ListenConfig_ListenPacket(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __address string}

GO FUNC net.__ptrTo_OpError_Error from net/net.go:
func __ptrTo_OpError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Error()", args, 0, 0)
	_res := o.O.(*_net.OpError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_OpError_Temporary from net/net.go:
func __ptrTo_OpError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Temporary()", args, 0, 0)
	_res := o.O.(*_net.OpError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_OpError_Timeout from net/net.go:
func __ptrTo_OpError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net.OpError)Timeout()", args, 0, 0)
	_res := o.O.(*_net.OpError).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net.__ptrTo_ParseError_Error from net/net.go:
func __ptrTo_ParseError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net.ParseError)Error()", args, 0, 0)
	_res := o.O.(*_net.ParseError).Error()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_Resolver_LookupAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupAddr(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __addr string}

GO FUNC net.__ptrTo_Resolver_LookupCNAME from net/lookup.go:
// func __ptrTo_Resolver_LookupCNAME(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupHost from net/lookup.go:
// func __ptrTo_Resolver_LookupHost(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupIPAddr from net/lookup.go:
// func __ptrTo_Resolver_LookupIPAddr(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __host string}

GO FUNC net.__ptrTo_Resolver_LookupMX from net/lookup.go:
// func __ptrTo_Resolver_LookupMX(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__ptrTo_Resolver_LookupNS from net/lookup.go:
// func __ptrTo_Resolver_LookupNS(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__ptrTo_Resolver_LookupPort from net/lookup.go:
// func __ptrTo_Resolver_LookupPort(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __network string, __service string}

GO FUNC net.__ptrTo_Resolver_LookupSRV from net/lookup.go:
// func __ptrTo_Resolver_LookupSRV(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __service string, __proto string, __name string}

GO FUNC net.__ptrTo_Resolver_LookupTXT from net/lookup.go:
// func __ptrTo_Resolver_LookupTXT(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context), __name string}

GO FUNC net.__ptrTo_TCPAddr_Network from net/tcpsock.go:
func __ptrTo_TCPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_TCPAddr_String from net/tcpsock.go:
func __ptrTo_TCPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.TCPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_TCPConn_CloseRead from net/tcpsock.go:
func __ptrTo_TCPConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_CloseWrite from net/tcpsock.go:
func __ptrTo_TCPConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.TCPConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_ReadFrom from net/tcpsock.go:
// func __ptrTo_TCPConn_ReadFrom(o GoObject, args Object) Object {
// __r ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC net.__ptrTo_TCPConn_SetKeepAlive from net/tcpsock.go:
func __ptrTo_TCPConn_SetKeepAlive(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetKeepAlive()", args, 1, 1)
	__keepalive := ExtractGoBoolean("(*_net.TCPConn)SetKeepAlive()", "__keepalive", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetKeepAlive(__keepalive)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SetKeepAlivePeriod from net/tcpsock.go:
// func __ptrTo_TCPConn_SetKeepAlivePeriod(o GoObject, args Object) Object {
// __d ABEND987(genutils.go: imports not yet supported: time.Duration)}

GO FUNC net.__ptrTo_TCPConn_SetLinger from net/tcpsock.go:
func __ptrTo_TCPConn_SetLinger(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetLinger()", args, 1, 1)
	__sec := ExtractGoInt("(*_net.TCPConn)SetLinger()", "__sec", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetLinger(__sec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SetNoDelay from net/tcpsock.go:
func __ptrTo_TCPConn_SetNoDelay(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net.TCPConn)SetNoDelay()", args, 1, 1)
	__noDelay := ExtractGoBoolean("(*_net.TCPConn)SetNoDelay()", "__noDelay", _argList, 0)
	_res := o.O.(*_net.TCPConn).SetNoDelay(__noDelay)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPConn_SyscallConn from net/tcpsock.go:
// func __ptrTo_TCPConn_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_TCPListener_Accept from net/tcpsock.go:
func __ptrTo_TCPListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_AcceptTCP from net/tcpsock.go:
func __ptrTo_TCPListener_AcceptTCP(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)AcceptTCP()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.TCPListener).AcceptTCP()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_TCPListener_Addr from net/tcpsock.go:
func __ptrTo_TCPListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__ptrTo_TCPListener_Close from net/tcpsock.go:
func __ptrTo_TCPListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.TCPListener)Close()", args, 0, 0)
	_res := o.O.(*_net.TCPListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_TCPListener_File from net/tcpsock.go:
// func __ptrTo_TCPListener_File(o GoObject, args Object) Object {
// [(atom-of ABEND042(post.go: cannot find typename os.File)) Error]}

GO FUNC net.__ptrTo_TCPListener_SetDeadline from net/tcpsock.go:
// func __ptrTo_TCPListener_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__ptrTo_TCPListener_SyscallConn from net/tcpsock.go:
// func __ptrTo_TCPListener_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_UDPAddr_Network from net/udpsock.go:
func __ptrTo_UDPAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UDPAddr_String from net/udpsock.go:
func __ptrTo_UDPAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UDPAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UDPAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UDPConn_ReadFrom from net/udpsock.go:
// func __ptrTo_UDPConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_UDPConn_ReadFromUDP from net/udpsock.go:
// func __ptrTo_UDPConn_ReadFromUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_UDPConn_ReadMsgUDP from net/udpsock.go:
// func __ptrTo_UDPConn_ReadMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

GO FUNC net.__ptrTo_UDPConn_SyscallConn from net/udpsock.go:
// func __ptrTo_UDPConn_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_UDPConn_WriteMsgUDP from net/udpsock.go:
// func __ptrTo_UDPConn_WriteMsgUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

GO FUNC net.__ptrTo_UDPConn_WriteTo from net/udpsock.go:
// func __ptrTo_UDPConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

GO FUNC net.__ptrTo_UDPConn_WriteToUDP from net/udpsock.go:
// func __ptrTo_UDPConn_WriteToUDP(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

GO FUNC net.__ptrTo_UnixAddr_Network from net/unixsock.go:
func __ptrTo_UnixAddr_Network(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)Network()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).Network()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UnixAddr_String from net/unixsock.go:
func __ptrTo_UnixAddr_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixAddr)String()", args, 0, 0)
	_res := o.O.(*_net.UnixAddr).String()
	return MakeString(_res)
}

GO FUNC net.__ptrTo_UnixConn_CloseRead from net/unixsock.go:
func __ptrTo_UnixConn_CloseRead(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseRead()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseRead()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixConn_CloseWrite from net/unixsock.go:
func __ptrTo_UnixConn_CloseWrite(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixConn)CloseWrite()", args, 0, 0)
	_res := o.O.(*_net.UnixConn).CloseWrite()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixConn_ReadFrom from net/unixsock.go:
// func __ptrTo_UnixConn_ReadFrom(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_UnixConn_ReadFromUnix from net/unixsock.go:
// func __ptrTo_UnixConn_ReadFromUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)))}

GO FUNC net.__ptrTo_UnixConn_ReadMsgUnix from net/unixsock.go:
// func __ptrTo_UnixConn_ReadMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)))}

GO FUNC net.__ptrTo_UnixConn_SyscallConn from net/unixsock.go:
// func __ptrTo_UnixConn_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__ptrTo_UnixConn_WriteMsgUnix from net/unixsock.go:
// func __ptrTo_UnixConn_WriteMsgUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__oob)), __addr)}

GO FUNC net.__ptrTo_UnixConn_WriteTo from net/unixsock.go:
// func __ptrTo_UnixConn_WriteTo(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), *__addr)}

GO FUNC net.__ptrTo_UnixConn_WriteToUnix from net/unixsock.go:
// func __ptrTo_UnixConn_WriteToUnix(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__b)), __addr)}

GO FUNC net.__ptrTo_UnixListener_Accept from net/unixsock.go:
func __ptrTo_UnixListener_Accept(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Accept()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).Accept()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixListener_AcceptUnix from net/unixsock.go:
func __ptrTo_UnixListener_AcceptUnix(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)AcceptUnix()", args, 0, 0)
	_res1, _res2 := o.O.(*_net.UnixListener).AcceptUnix()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.__ptrTo_UnixListener_Addr from net/unixsock.go:
func __ptrTo_UnixListener_Addr(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Addr()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Addr()
	return MakeGoObject(_res)
}

GO FUNC net.__ptrTo_UnixListener_Close from net/unixsock.go:
func __ptrTo_UnixListener_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net.UnixListener)Close()", args, 0, 0)
	_res := o.O.(*_net.UnixListener).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net.__ptrTo_UnixListener_File from net/unixsock.go:
// func __ptrTo_UnixListener_File(o GoObject, args Object) Object {
// [(atom-of ABEND042(post.go: cannot find typename os.File)) Error]}

GO FUNC net.__ptrTo_UnixListener_SetDeadline from net/unixsock.go:
// func __ptrTo_UnixListener_SetDeadline(o GoObject, args Object) Object {
// __t ABEND987(genutils.go: imports not yet supported: time.Time)}

GO FUNC net.__ptrTo_UnixListener_SetUnlinkOnClose from net/unixsock_posix.go:
// func __ptrTo_UnixListener_SetUnlinkOnClose(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net.__ptrTo_UnixListener_SyscallConn from net/unixsock.go:
// func __ptrTo_UnixListener_SyscallConn(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename syscall.RawConn) Error]}

GO FUNC net.__unknownNetworkError_Error from net/net.go:
func __unknownNetworkError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Error()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Error()
	return MakeString(_res)
}

GO FUNC net.__unknownNetworkError_Temporary from net/net.go:
func __unknownNetworkError_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Temporary()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net.__unknownNetworkError_Timeout from net/net.go:
func __unknownNetworkError_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(_net.UnknownNetworkError)Timeout()", args, 0, 0)
	_res := o.O.(_net.UnknownNetworkError).Timeout()
	return MakeBoolean(_res)
}

GO VARDEF FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
var info_Addr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
var info_AddrError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/AddrError from -:
var info_PtrTo_AddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
var info_Buffers GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Buffers from -:
var info_PtrTo_Buffers GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
var info_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
var info_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/DNSConfigError from -:
var info_PtrTo_DNSConfigError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
var info_DNSError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/DNSError from -:
var info_PtrTo_DNSError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
var info_Dialer GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Dialer from -:
var info_PtrTo_Dialer GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
var info_Flags GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Flags from -:
var info_PtrTo_Flags GoTypeInfo

GO VARDEF FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
var info_HardwareAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/HardwareAddr from -:
var info_PtrTo_HardwareAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
var info_IP GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IP from -:
var info_PtrTo_IP GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
var info_IPAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPAddr from -:
var info_PtrTo_IPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
var info_IPConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPConn from -:
var info_PtrTo_IPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
var info_IPMask GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPMask from -:
var info_PtrTo_IPMask GoTypeInfo

GO VARDEF FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
var info_IPNet GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/IPNet from -:
var info_PtrTo_IPNet GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
var info_Interface GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Interface from -:
var info_PtrTo_Interface GoTypeInfo

GO VARDEF FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
var info_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/InvalidAddrError from -:
var info_PtrTo_InvalidAddrError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
var info_ListenConfig GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/ListenConfig from -:
var info_PtrTo_ListenConfig GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
var info_Listener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
var info_MX GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/MX from -:
var info_PtrTo_MX GoTypeInfo

GO VARDEF FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
var info_NS GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/NS from -:
var info_PtrTo_NS GoTypeInfo

GO VARDEF FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
var info_OpError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/OpError from -:
var info_PtrTo_OpError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
var info_PacketConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
var info_ParseError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/ParseError from -:
var info_PtrTo_ParseError GoTypeInfo

GO VARDEF FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
var info_Resolver GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/Resolver from -:
var info_PtrTo_Resolver GoTypeInfo

GO VARDEF FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
var info_SRV GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/SRV from -:
var info_PtrTo_SRV GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
var info_TCPAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/TCPAddr from -:
var info_PtrTo_TCPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
var info_TCPConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/TCPConn from -:
var info_PtrTo_TCPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
var info_TCPListener GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/TCPListener from -:
var info_PtrTo_TCPListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
var info_UDPAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UDPAddr from -:
var info_PtrTo_UDPAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
var info_UDPConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UDPConn from -:
var info_PtrTo_UDPConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
var info_UnixAddr GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UnixAddr from -:
var info_PtrTo_UnixAddr GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
var info_UnixConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UnixConn from -:
var info_PtrTo_UnixConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
var info_UnixListener GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UnixListener from -:
var info_PtrTo_UnixListener GoTypeInfo

GO VARDEF FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
var info_UnknownNetworkError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net/UnknownNetworkError from -:
var info_PtrTo_UnknownNetworkError GoTypeInfo

GO INFO FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
	info_Addr = GoTypeInfo{Name: "go.std.net/Addr",
		GoType: &GoType{T: &info_Addr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __addr_Network, "", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __addr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
	info_AddrError = GoTypeInfo{Name: "go.std.net/AddrError",
		GoType: &GoType{T: &info_AddrError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/AddrError from -:
	info_PtrTo_AddrError = GoTypeInfo{Name: "*go.std.net/AddrError",
		GoType: &GoType{T: &info_PtrTo_AddrError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_AddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_AddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_AddrError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
	info_Buffers = GoTypeInfo{Name: "go.std.net/Buffers",
		GoType: &GoType{T: &info_Buffers},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Buffers from -:
	info_PtrTo_Buffers = GoTypeInfo{Name: "*go.std.net/Buffers",
		GoType: &GoType{T: &info_PtrTo_Buffers},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
	info_Conn = GoTypeInfo{Name: "go.std.net/Conn",
		GoType: &GoType{T: &info_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __conn_Close, "", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", __conn_LocalAddr, "", "1.0", NewVectorFrom()),
			"RemoteAddr": MakeGoReceiver("RemoteAddr", __conn_RemoteAddr, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
	info_DNSConfigError = GoTypeInfo{Name: "go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_DNSConfigError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/DNSConfigError from -:
	info_PtrTo_DNSConfigError = GoTypeInfo{Name: "*go.std.net/DNSConfigError",
		GoType: &GoType{T: &info_PtrTo_DNSConfigError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_DNSConfigError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_DNSConfigError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_DNSConfigError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
	info_DNSError = GoTypeInfo{Name: "go.std.net/DNSError",
		GoType: &GoType{T: &info_DNSError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/DNSError from -:
	info_PtrTo_DNSError = GoTypeInfo{Name: "*go.std.net/DNSError",
		GoType: &GoType{T: &info_PtrTo_DNSError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_DNSError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_DNSError_Temporary, "Temporary reports whether the DNS error is known to be temporary.\nThis is not always known; a DNS lookup may fail due to a temporary\nerror and return a DNSError for which Temporary returns false.\n", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_DNSError_Timeout, "Timeout reports whether the DNS lookup is known to have timed out.\nThis is not always known; a DNS lookup may fail due to a timeout\nand return a DNSError for which Timeout returns false.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
	info_Dialer = GoTypeInfo{Name: "go.std.net/Dialer",
		GoType: &GoType{T: &info_Dialer},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Dialer from -:
	info_PtrTo_Dialer = GoTypeInfo{Name: "*go.std.net/Dialer",
		GoType: &GoType{T: &info_PtrTo_Dialer},
		Members: GoMembers{
			"Dial": MakeGoReceiver("Dial", __ptrTo_Dialer_Dial, "Dial connects to the address on the named network.\n\nSee func Dial for a description of the network and address\nparameters.\n", "1.0", NewVectorFrom(MakeSymbol("network"), MakeSymbol("address"))),
		}}


GO INFO FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
	info_Error = GoTypeInfo{Name: "go.std.net/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
			"Temporary": MakeGoReceiver("Temporary", __error_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __error_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
	info_Flags = GoTypeInfo{Name: "go.std.net/Flags",
		GoType: &GoType{T: &info_Flags},
		Members: GoMembers{
			"String": MakeGoReceiver("String", __flags_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/Flags from -:
	info_PtrTo_Flags = GoTypeInfo{Name: "*go.std.net/Flags",
		GoType: &GoType{T: &info_PtrTo_Flags},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
	info_HardwareAddr = GoTypeInfo{Name: "go.std.net/HardwareAddr",
		GoType: &GoType{T: &info_HardwareAddr},
		Members: GoMembers{
			"String": MakeGoReceiver("String", __hardwareAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/HardwareAddr from -:
	info_PtrTo_HardwareAddr = GoTypeInfo{Name: "*go.std.net/HardwareAddr",
		GoType: &GoType{T: &info_PtrTo_HardwareAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
	info_IP = GoTypeInfo{Name: "go.std.net/IP",
		GoType: &GoType{T: &info_IP},
		Members: GoMembers{
			"DefaultMask": MakeGoReceiver("DefaultMask", __iP_DefaultMask, "DefaultMask returns the default IP mask for the IP address ip.\nOnly IPv4 addresses have default masks; DefaultMask returns\nnil if ip is not a valid IPv4 address.\n", "1.0", NewVectorFrom()),
			"Equal": MakeGoReceiver("Equal", __iP_Equal, "Equal reports whether ip and x are the same IP address.\nAn IPv4 address and that same address in IPv6 form are\nconsidered to be equal.\n", "1.0", NewVectorFrom(MakeSymbol("x"))),
			"IsGlobalUnicast": MakeGoReceiver("IsGlobalUnicast", __iP_IsGlobalUnicast, "IsGlobalUnicast reports whether ip is a global unicast\naddress.\n\nThe identification of global unicast addresses uses address type\nidentification as defined in RFC 1122, RFC 4632 and RFC 4291 with\nthe exception of IPv4 directed broadcast addresses.\nIt returns true even if ip is in IPv4 private address space or\nlocal IPv6 unicast address space.\n", "1.0", NewVectorFrom()),
			"IsInterfaceLocalMulticast": MakeGoReceiver("IsInterfaceLocalMulticast", __iP_IsInterfaceLocalMulticast, "IsInterfaceLocalMulticast reports whether ip is\nan interface-local multicast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalMulticast": MakeGoReceiver("IsLinkLocalMulticast", __iP_IsLinkLocalMulticast, "IsLinkLocalMulticast reports whether ip is a link-local\nmulticast address.\n", "1.0", NewVectorFrom()),
			"IsLinkLocalUnicast": MakeGoReceiver("IsLinkLocalUnicast", __iP_IsLinkLocalUnicast, "IsLinkLocalUnicast reports whether ip is a link-local\nunicast address.\n", "1.0", NewVectorFrom()),
			"IsLoopback": MakeGoReceiver("IsLoopback", __iP_IsLoopback, "IsLoopback reports whether ip is a loopback address.\n", "1.0", NewVectorFrom()),
			"IsMulticast": MakeGoReceiver("IsMulticast", __iP_IsMulticast, "IsMulticast reports whether ip is a multicast address.\n", "1.0", NewVectorFrom()),
			"IsUnspecified": MakeGoReceiver("IsUnspecified", __iP_IsUnspecified, "IsUnspecified reports whether ip is an unspecified address, either\nthe IPv4 address \"0.0.0.0\" or the IPv6 address \"::\".\n", "1.0", NewVectorFrom()),
			"MarshalText": MakeGoReceiver("MarshalText", __iP_MarshalText, "MarshalText implements the encoding.TextMarshaler interface.\nThe encoding is the same as returned by String, with one exception:\nWhen len(ip) is zero, it returns an empty slice.\n", "1.0", NewVectorFrom()),
			"Mask": MakeGoReceiver("Mask", __iP_Mask, "Mask returns the result of masking the IP address ip with mask.\n", "1.0", NewVectorFrom(MakeSymbol("mask"))),
			"String": MakeGoReceiver("String", __iP_String, "String returns the string form of the IP address ip.\nIt returns one of 4 forms:\n  - \"<nil>\", if ip has length 0\n  - dotted decimal (\"192.0.2.1\"), if ip is an IPv4 or IP4-mapped IPv6 address\n  - IPv6 (\"2001:db8::1\"), if ip is a valid IPv6 address\n  - the hexadecimal form of ip, without punctuation, if no other cases apply\n", "1.0", NewVectorFrom()),
			"To16": MakeGoReceiver("To16", __iP_To16, "To16 converts the IP address ip to a 16-byte representation.\nIf ip is not an IP address (it is the wrong length), To16 returns nil.\n", "1.0", NewVectorFrom()),
			"To4": MakeGoReceiver("To4", __iP_To4, "To4 converts the IPv4 address ip to a 4-byte representation.\nIf ip is not an IPv4 address, To4 returns nil.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/IP from -:
	info_PtrTo_IP = GoTypeInfo{Name: "*go.std.net/IP",
		GoType: &GoType{T: &info_PtrTo_IP},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
	info_IPAddr = GoTypeInfo{Name: "go.std.net/IPAddr",
		GoType: &GoType{T: &info_IPAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPAddr from -:
	info_PtrTo_IPAddr = GoTypeInfo{Name: "*go.std.net/IPAddr",
		GoType: &GoType{T: &info_PtrTo_IPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __ptrTo_IPAddr_Network, "Network returns the address's network name, \"ip\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_IPAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
	info_IPConn = GoTypeInfo{Name: "go.std.net/IPConn",
		GoType: &GoType{T: &info_IPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPConn from -:
	info_PtrTo_IPConn = GoTypeInfo{Name: "*go.std.net/IPConn",
		GoType: &GoType{T: &info_PtrTo_IPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
	info_IPMask = GoTypeInfo{Name: "go.std.net/IPMask",
		GoType: &GoType{T: &info_IPMask},
		Members: GoMembers{
			"Size": MakeGoReceiver("Size", __iPMask_Size, "Size returns the number of leading ones and total bits in the mask.\nIf the mask is not in the canonical form--ones followed by zeros--then\nSize returns 0, 0.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __iPMask_String, "String returns the hexadecimal form of m, with no punctuation.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/IPMask from -:
	info_PtrTo_IPMask = GoTypeInfo{Name: "*go.std.net/IPMask",
		GoType: &GoType{T: &info_PtrTo_IPMask},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
	info_IPNet = GoTypeInfo{Name: "go.std.net/IPNet",
		GoType: &GoType{T: &info_IPNet},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/IPNet from -:
	info_PtrTo_IPNet = GoTypeInfo{Name: "*go.std.net/IPNet",
		GoType: &GoType{T: &info_PtrTo_IPNet},
		Members: GoMembers{
			"Contains": MakeGoReceiver("Contains", __ptrTo_IPNet_Contains, "Contains reports whether the network includes ip.\n", "1.0", NewVectorFrom(MakeSymbol("ip"))),
			"Network": MakeGoReceiver("Network", __ptrTo_IPNet_Network, "Network returns the address's network name, \"ip+net\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_IPNet_String, "String returns the CIDR notation of n like \"192.0.2.1/24\"\nor \"2001:db8::/48\" as defined in RFC 4632 and RFC 4291.\nIf the mask is not in the canonical form, it returns the\nstring which consists of an IP address, followed by a slash\ncharacter and a mask expressed as hexadecimal form with no\npunctuation like \"198.51.100.1/c000ff00\".\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
	info_Interface = GoTypeInfo{Name: "go.std.net/Interface",
		GoType: &GoType{T: &info_Interface},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Interface from -:
	info_PtrTo_Interface = GoTypeInfo{Name: "*go.std.net/Interface",
		GoType: &GoType{T: &info_PtrTo_Interface},
		Members: GoMembers{
			"Addrs": MakeGoReceiver("Addrs", __ptrTo_Interface_Addrs, "Addrs returns a list of unicast interface addresses for a specific\ninterface.\n", "1.0", NewVectorFrom()),
			"MulticastAddrs": MakeGoReceiver("MulticastAddrs", __ptrTo_Interface_MulticastAddrs, "MulticastAddrs returns a list of multicast, joined group addresses\nfor a specific interface.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
	info_InvalidAddrError = GoTypeInfo{Name: "go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_InvalidAddrError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __invalidAddrError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __invalidAddrError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __invalidAddrError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/InvalidAddrError from -:
	info_PtrTo_InvalidAddrError = GoTypeInfo{Name: "*go.std.net/InvalidAddrError",
		GoType: &GoType{T: &info_PtrTo_InvalidAddrError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
	info_ListenConfig = GoTypeInfo{Name: "go.std.net/ListenConfig",
		GoType: &GoType{T: &info_ListenConfig},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/ListenConfig from -:
	info_PtrTo_ListenConfig = GoTypeInfo{Name: "*go.std.net/ListenConfig",
		GoType: &GoType{T: &info_PtrTo_ListenConfig},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
	info_Listener = GoTypeInfo{Name: "go.std.net/Listener",
		GoType: &GoType{T: &info_Listener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", __listener_Accept, "", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", __listener_Addr, "", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", __listener_Close, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
	info_MX = GoTypeInfo{Name: "go.std.net/MX",
		GoType: &GoType{T: &info_MX},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/MX from -:
	info_PtrTo_MX = GoTypeInfo{Name: "*go.std.net/MX",
		GoType: &GoType{T: &info_PtrTo_MX},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
	info_NS = GoTypeInfo{Name: "go.std.net/NS",
		GoType: &GoType{T: &info_NS},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/NS from -:
	info_PtrTo_NS = GoTypeInfo{Name: "*go.std.net/NS",
		GoType: &GoType{T: &info_PtrTo_NS},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
	info_OpError = GoTypeInfo{Name: "go.std.net/OpError",
		GoType: &GoType{T: &info_OpError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/OpError from -:
	info_PtrTo_OpError = GoTypeInfo{Name: "*go.std.net/OpError",
		GoType: &GoType{T: &info_PtrTo_OpError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_OpError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_OpError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_OpError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
	info_PacketConn = GoTypeInfo{Name: "go.std.net/PacketConn",
		GoType: &GoType{T: &info_PacketConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __packetConn_Close, "", "1.0", NewVectorFrom()),
			"LocalAddr": MakeGoReceiver("LocalAddr", __packetConn_LocalAddr, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
	info_ParseError = GoTypeInfo{Name: "go.std.net/ParseError",
		GoType: &GoType{T: &info_ParseError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/ParseError from -:
	info_PtrTo_ParseError = GoTypeInfo{Name: "*go.std.net/ParseError",
		GoType: &GoType{T: &info_PtrTo_ParseError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_ParseError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
	info_Resolver = GoTypeInfo{Name: "go.std.net/Resolver",
		GoType: &GoType{T: &info_Resolver},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/Resolver from -:
	info_PtrTo_Resolver = GoTypeInfo{Name: "*go.std.net/Resolver",
		GoType: &GoType{T: &info_PtrTo_Resolver},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
	info_SRV = GoTypeInfo{Name: "go.std.net/SRV",
		GoType: &GoType{T: &info_SRV},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/SRV from -:
	info_PtrTo_SRV = GoTypeInfo{Name: "*go.std.net/SRV",
		GoType: &GoType{T: &info_PtrTo_SRV},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	info_TCPAddr = GoTypeInfo{Name: "go.std.net/TCPAddr",
		GoType: &GoType{T: &info_TCPAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/TCPAddr from -:
	info_PtrTo_TCPAddr = GoTypeInfo{Name: "*go.std.net/TCPAddr",
		GoType: &GoType{T: &info_PtrTo_TCPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __ptrTo_TCPAddr_Network, "Network returns the address's network name, \"tcp\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_TCPAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
	info_TCPConn = GoTypeInfo{Name: "go.std.net/TCPConn",
		GoType: &GoType{T: &info_TCPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/TCPConn from -:
	info_PtrTo_TCPConn = GoTypeInfo{Name: "*go.std.net/TCPConn",
		GoType: &GoType{T: &info_PtrTo_TCPConn},
		Members: GoMembers{
			"CloseRead": MakeGoReceiver("CloseRead", __ptrTo_TCPConn_CloseRead, "CloseRead shuts down the reading side of the TCP connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"CloseWrite": MakeGoReceiver("CloseWrite", __ptrTo_TCPConn_CloseWrite, "CloseWrite shuts down the writing side of the TCP connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"SetKeepAlive": MakeGoReceiver("SetKeepAlive", __ptrTo_TCPConn_SetKeepAlive, "SetKeepAlive sets whether the operating system should send\nkeepalive messages on the connection.\n", "1.0", NewVectorFrom(MakeSymbol("keepalive"))),
			"SetLinger": MakeGoReceiver("SetLinger", __ptrTo_TCPConn_SetLinger, "SetLinger sets the behavior of Close on a connection which still\nhas data waiting to be sent or to be acknowledged.\n\nIf sec < 0 (the default), the operating system finishes sending the\ndata in the background.\n\nIf sec == 0, the operating system discards any unsent or\nunacknowledged data.\n\nIf sec > 0, the data is sent in the background as with sec < 0. On\nsome operating systems after sec seconds have elapsed any remaining\nunsent data may be discarded.\n", "1.0", NewVectorFrom(MakeSymbol("sec"))),
			"SetNoDelay": MakeGoReceiver("SetNoDelay", __ptrTo_TCPConn_SetNoDelay, "SetNoDelay controls whether the operating system should delay\npacket transmission in hopes of sending fewer packets (Nagle's\nalgorithm).  The default is true (no delay), meaning that data is\nsent as soon as possible after a Write.\n", "1.0", NewVectorFrom(MakeSymbol("noDelay"))),
		}}


GO INFO FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
	info_TCPListener = GoTypeInfo{Name: "go.std.net/TCPListener",
		GoType: &GoType{T: &info_TCPListener},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/TCPListener from -:
	info_PtrTo_TCPListener = GoTypeInfo{Name: "*go.std.net/TCPListener",
		GoType: &GoType{T: &info_PtrTo_TCPListener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", __ptrTo_TCPListener_Accept, "Accept implements the Accept method in the Listener interface; it\nwaits for the next call and returns a generic Conn.\n", "1.0", NewVectorFrom()),
			"AcceptTCP": MakeGoReceiver("AcceptTCP", __ptrTo_TCPListener_AcceptTCP, "AcceptTCP accepts the next incoming call and returns the new\nconnection.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", __ptrTo_TCPListener_Addr, "Addr returns the listener's network address, a *TCPAddr.\nThe Addr returned is shared by all invocations of Addr, so\ndo not modify it.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", __ptrTo_TCPListener_Close, "Close stops listening on the TCP address.\nAlready Accepted connections are not closed.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
	info_UDPAddr = GoTypeInfo{Name: "go.std.net/UDPAddr",
		GoType: &GoType{T: &info_UDPAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/UDPAddr from -:
	info_PtrTo_UDPAddr = GoTypeInfo{Name: "*go.std.net/UDPAddr",
		GoType: &GoType{T: &info_PtrTo_UDPAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __ptrTo_UDPAddr_Network, "Network returns the address's network name, \"udp\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_UDPAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
	info_UDPConn = GoTypeInfo{Name: "go.std.net/UDPConn",
		GoType: &GoType{T: &info_UDPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/UDPConn from -:
	info_PtrTo_UDPConn = GoTypeInfo{Name: "*go.std.net/UDPConn",
		GoType: &GoType{T: &info_PtrTo_UDPConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
	info_UnixAddr = GoTypeInfo{Name: "go.std.net/UnixAddr",
		GoType: &GoType{T: &info_UnixAddr},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/UnixAddr from -:
	info_PtrTo_UnixAddr = GoTypeInfo{Name: "*go.std.net/UnixAddr",
		GoType: &GoType{T: &info_PtrTo_UnixAddr},
		Members: GoMembers{
			"Network": MakeGoReceiver("Network", __ptrTo_UnixAddr_Network, "Network returns the address's network name, \"unix\", \"unixgram\" or\n\"unixpacket\".\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_UnixAddr_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
	info_UnixConn = GoTypeInfo{Name: "go.std.net/UnixConn",
		GoType: &GoType{T: &info_UnixConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/UnixConn from -:
	info_PtrTo_UnixConn = GoTypeInfo{Name: "*go.std.net/UnixConn",
		GoType: &GoType{T: &info_PtrTo_UnixConn},
		Members: GoMembers{
			"CloseRead": MakeGoReceiver("CloseRead", __ptrTo_UnixConn_CloseRead, "CloseRead shuts down the reading side of the Unix domain connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
			"CloseWrite": MakeGoReceiver("CloseWrite", __ptrTo_UnixConn_CloseWrite, "CloseWrite shuts down the writing side of the Unix domain connection.\nMost callers should just use Close.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
	info_UnixListener = GoTypeInfo{Name: "go.std.net/UnixListener",
		GoType: &GoType{T: &info_UnixListener},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net/UnixListener from -:
	info_PtrTo_UnixListener = GoTypeInfo{Name: "*go.std.net/UnixListener",
		GoType: &GoType{T: &info_PtrTo_UnixListener},
		Members: GoMembers{
			"Accept": MakeGoReceiver("Accept", __ptrTo_UnixListener_Accept, "Accept implements the Accept method in the Listener interface.\nReturned connections will be of type *UnixConn.\n", "1.0", NewVectorFrom()),
			"AcceptUnix": MakeGoReceiver("AcceptUnix", __ptrTo_UnixListener_AcceptUnix, "AcceptUnix accepts the next incoming call and returns the new\nconnection.\n", "1.0", NewVectorFrom()),
			"Addr": MakeGoReceiver("Addr", __ptrTo_UnixListener_Addr, "Addr returns the listener's network address.\nThe Addr returned is shared by all invocations of Addr, so\ndo not modify it.\n", "1.0", NewVectorFrom()),
			"Close": MakeGoReceiver("Close", __ptrTo_UnixListener_Close, "Close stops listening on the Unix address. Already accepted\nconnections are not closed.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
	info_UnknownNetworkError = GoTypeInfo{Name: "go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_UnknownNetworkError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __unknownNetworkError_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __unknownNetworkError_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __unknownNetworkError_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net/UnknownNetworkError from -:
	info_PtrTo_UnknownNetworkError = GoTypeInfo{Name: "*go.std.net/UnknownNetworkError",
		GoType: &GoType{T: &info_PtrTo_UnknownNetworkError},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net/Addr from _tests/big/src/net/net.go:105:6:
	GoTypesVec[176] = &info_Addr

GO VECSET FOR TYPE go.std.net/AddrError from _tests/big/src/net/net.go:520:6:
	GoTypesVec[134] = &info_AddrError

GO VECSET FOR TYPE *go.std.net/AddrError from -:
	GoTypesVec[52] = &info_PtrTo_AddrError

GO VECSET FOR TYPE go.std.net/Buffers from _tests/big/src/net/net.go:642:6:
	GoTypesVec[135] = &info_Buffers

GO VECSET FOR TYPE *go.std.net/Buffers from -:
	GoTypesVec[53] = &info_PtrTo_Buffers

GO VECSET FOR TYPE go.std.net/Conn from _tests/big/src/net/net.go:113:6:
	GoTypesVec[164] = &info_Conn

GO VECSET FOR TYPE go.std.net/DNSConfigError from _tests/big/src/net/net.go:553:6:
	GoTypesVec[136] = &info_DNSConfigError

GO VECSET FOR TYPE *go.std.net/DNSConfigError from -:
	GoTypesVec[54] = &info_PtrTo_DNSConfigError

GO VECSET FOR TYPE go.std.net/DNSError from _tests/big/src/net/net.go:567:6:
	GoTypesVec[137] = &info_DNSError

GO VECSET FOR TYPE *go.std.net/DNSError from -:
	GoTypesVec[55] = &info_PtrTo_DNSError

GO VECSET FOR TYPE go.std.net/Dialer from _tests/big/src/net/dial.go:20:6:
	GoTypesVec[138] = &info_Dialer

GO VECSET FOR TYPE *go.std.net/Dialer from -:
	GoTypesVec[56] = &info_PtrTo_Dialer

GO VECSET FOR TYPE go.std.net/Error from _tests/big/src/net/net.go:378:6:
	GoTypesVec[169] = &info_Error

GO VECSET FOR TYPE go.std.net/Flags from _tests/big/src/net/interface.go:38:6:
	GoTypesVec[139] = &info_Flags

GO VECSET FOR TYPE *go.std.net/Flags from -:
	GoTypesVec[57] = &info_PtrTo_Flags

GO VECSET FOR TYPE go.std.net/HardwareAddr from _tests/big/src/net/mac.go:10:6:
	GoTypesVec[140] = &info_HardwareAddr

GO VECSET FOR TYPE *go.std.net/HardwareAddr from -:
	GoTypesVec[58] = &info_PtrTo_HardwareAddr

GO VECSET FOR TYPE go.std.net/IP from _tests/big/src/net/ip.go:32:6:
	GoTypesVec[141] = &info_IP

GO VECSET FOR TYPE *go.std.net/IP from -:
	GoTypesVec[59] = &info_PtrTo_IP

GO VECSET FOR TYPE go.std.net/IPAddr from _tests/big/src/net/iprawsock.go:31:6:
	GoTypesVec[142] = &info_IPAddr

GO VECSET FOR TYPE *go.std.net/IPAddr from -:
	GoTypesVec[60] = &info_PtrTo_IPAddr

GO VECSET FOR TYPE go.std.net/IPConn from _tests/big/src/net/iprawsock.go:99:6:
	GoTypesVec[143] = &info_IPConn

GO VECSET FOR TYPE *go.std.net/IPConn from -:
	GoTypesVec[61] = &info_PtrTo_IPConn

GO VECSET FOR TYPE go.std.net/IPMask from _tests/big/src/net/ip.go:35:6:
	GoTypesVec[144] = &info_IPMask

GO VECSET FOR TYPE *go.std.net/IPMask from -:
	GoTypesVec[62] = &info_PtrTo_IPMask

GO VECSET FOR TYPE go.std.net/IPNet from _tests/big/src/net/ip.go:38:6:
	GoTypesVec[145] = &info_IPNet

GO VECSET FOR TYPE *go.std.net/IPNet from -:
	GoTypesVec[63] = &info_PtrTo_IPNet

GO VECSET FOR TYPE go.std.net/Interface from _tests/big/src/net/interface.go:30:6:
	GoTypesVec[146] = &info_Interface

GO VECSET FOR TYPE *go.std.net/Interface from -:
	GoTypesVec[64] = &info_PtrTo_Interface

GO VECSET FOR TYPE go.std.net/InvalidAddrError from _tests/big/src/net/net.go:545:6:
	GoTypesVec[147] = &info_InvalidAddrError

GO VECSET FOR TYPE *go.std.net/InvalidAddrError from -:
	GoTypesVec[65] = &info_PtrTo_InvalidAddrError

GO VECSET FOR TYPE go.std.net/ListenConfig from _tests/big/src/net/dial.go:576:6:
	GoTypesVec[148] = &info_ListenConfig

GO VECSET FOR TYPE *go.std.net/ListenConfig from -:
	GoTypesVec[66] = &info_PtrTo_ListenConfig

GO VECSET FOR TYPE go.std.net/Listener from _tests/big/src/net/net.go:365:6:
	GoTypesVec[170] = &info_Listener

GO VECSET FOR TYPE go.std.net/MX from _tests/big/src/net/dnsclient.go:193:6:
	GoTypesVec[149] = &info_MX

GO VECSET FOR TYPE *go.std.net/MX from -:
	GoTypesVec[67] = &info_PtrTo_MX

GO VECSET FOR TYPE go.std.net/NS from _tests/big/src/net/dnsclient.go:215:6:
	GoTypesVec[150] = &info_NS

GO VECSET FOR TYPE *go.std.net/NS from -:
	GoTypesVec[68] = &info_PtrTo_NS

GO VECSET FOR TYPE go.std.net/OpError from _tests/big/src/net/net.go:416:6:
	GoTypesVec[151] = &info_OpError

GO VECSET FOR TYPE *go.std.net/OpError from -:
	GoTypesVec[69] = &info_PtrTo_OpError

GO VECSET FOR TYPE go.std.net/PacketConn from _tests/big/src/net/net.go:303:6:
	GoTypesVec[165] = &info_PacketConn

GO VECSET FOR TYPE go.std.net/ParseError from _tests/big/src/net/net.go:509:6:
	GoTypesVec[152] = &info_ParseError

GO VECSET FOR TYPE *go.std.net/ParseError from -:
	GoTypesVec[70] = &info_PtrTo_ParseError

GO VECSET FOR TYPE go.std.net/Resolver from _tests/big/src/net/lookup.go:107:6:
	GoTypesVec[153] = &info_Resolver

GO VECSET FOR TYPE *go.std.net/Resolver from -:
	GoTypesVec[71] = &info_PtrTo_Resolver

GO VECSET FOR TYPE go.std.net/SRV from _tests/big/src/net/dnsclient.go:139:6:
	GoTypesVec[154] = &info_SRV

GO VECSET FOR TYPE *go.std.net/SRV from -:
	GoTypesVec[72] = &info_PtrTo_SRV

GO VECSET FOR TYPE go.std.net/TCPAddr from _tests/big/src/net/tcpsock.go:19:6:
	GoTypesVec[155] = &info_TCPAddr

GO VECSET FOR TYPE *go.std.net/TCPAddr from -:
	GoTypesVec[73] = &info_PtrTo_TCPAddr

GO VECSET FOR TYPE go.std.net/TCPConn from _tests/big/src/net/tcpsock.go:85:6:
	GoTypesVec[156] = &info_TCPConn

GO VECSET FOR TYPE *go.std.net/TCPConn from -:
	GoTypesVec[74] = &info_PtrTo_TCPConn

GO VECSET FOR TYPE go.std.net/TCPListener from _tests/big/src/net/tcpsock.go:225:6:
	GoTypesVec[157] = &info_TCPListener

GO VECSET FOR TYPE *go.std.net/TCPListener from -:
	GoTypesVec[75] = &info_PtrTo_TCPListener

GO VECSET FOR TYPE go.std.net/UDPAddr from _tests/big/src/net/udpsock.go:25:6:
	GoTypesVec[158] = &info_UDPAddr

GO VECSET FOR TYPE *go.std.net/UDPAddr from -:
	GoTypesVec[76] = &info_PtrTo_UDPAddr

GO VECSET FOR TYPE go.std.net/UDPConn from _tests/big/src/net/udpsock.go:91:6:
	GoTypesVec[159] = &info_UDPConn

GO VECSET FOR TYPE *go.std.net/UDPConn from -:
	GoTypesVec[77] = &info_PtrTo_UDPConn

GO VECSET FOR TYPE go.std.net/UnixAddr from _tests/big/src/net/unixsock.go:19:6:
	GoTypesVec[160] = &info_UnixAddr

GO VECSET FOR TYPE *go.std.net/UnixAddr from -:
	GoTypesVec[78] = &info_PtrTo_UnixAddr

GO VECSET FOR TYPE go.std.net/UnixConn from _tests/big/src/net/unixsock.go:65:6:
	GoTypesVec[161] = &info_UnixConn

GO VECSET FOR TYPE *go.std.net/UnixConn from -:
	GoTypesVec[79] = &info_PtrTo_UnixConn

GO VECSET FOR TYPE go.std.net/UnixListener from _tests/big/src/net/unixsock.go:217:6:
	GoTypesVec[162] = &info_UnixListener

GO VECSET FOR TYPE *go.std.net/UnixListener from -:
	GoTypesVec[80] = &info_PtrTo_UnixListener

GO VECSET FOR TYPE go.std.net/UnknownNetworkError from _tests/big/src/net/net.go:539:6:
	GoTypesVec[163] = &info_UnknownNetworkError

GO VECSET FOR TYPE *go.std.net/UnknownNetworkError from -:
	GoTypesVec[81] = &info_PtrTo_UnknownNetworkError

GO ENSURE-LOADED FOR net:
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/udpsock_posix.go:10:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:20:2
	EnsureLoaded("go.std.golang_org.x.net.dns.dnsmessage")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:27:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/parse.go:11:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:22:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/parse.go:12:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/sockoptip_posix.go:10:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/addrselect.go:11:8
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/dnsclient_unix.go:24:2
	EnsureLoaded("go.std.sync.atomic")  // E.g. from: _tests/big/src/net/dnsconfig_unix.go:13:2
	EnsureLoaded("go.std.syscall")  // E.g. from: _tests/big/src/net/sockopt_linux.go:9:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/parse.go:13:2
	EnsureLoaded("go.std.unsafe")  // E.g. from: _tests/big/src/net/parse.go:14:4

GO TYPE net/http.Client from net/http/client.go:
func ExtractGoObjectClient(args []Object, index int) *_http.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Client:
			return &r
		case *_http.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Client]"))
}

// func _mapToClient(o Map) *_http.Client {
// 	return &_http.Client{}
// }

// func _vectorToClient(o *Vector) *_http.Client {
// 	return &_http.Client{
// 		Transport: ABEND048(codegen.go: no conversion from Clojure for net/http.RoundTripper (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		CheckRedirect: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Jar: ABEND048(codegen.go: no conversion from Clojure for net/http.CookieJar (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		Timeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_http.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Client:
// 			return &_g
// 		case *_http.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Client] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Client(rcvr, arg string, args *ArraySeq, n int) (res _http.Client) {
	a := CheckGoNth(rcvr, "go.std.net.http/Client", arg, args, n).O
	res, ok := a.(_http.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.CloseNotifier from net/http/server.go:
func ExtractGoObjectCloseNotifier(args []Object, index int) *_http.CloseNotifier {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CloseNotifier:
			return &r
		case *_http.CloseNotifier:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CloseNotifier]"))
}

// func _ConstructCloseNotifier(_v Object) _http.CloseNotifier {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CloseNotifier:
// 			return _g
// 		case *_http.CloseNotifier:
// 			return *_g
// 		}
// 	default:
// 		return _http.CloseNotifier(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CloseNotifier))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CloseNotifier] or: whatever"))
// }

func ExtractGo_go_std_net_http__CloseNotifier(rcvr, arg string, args *ArraySeq, n int) (res _http.CloseNotifier) {
	a := CheckGoNth(rcvr, "go.std.net.http/CloseNotifier", arg, args, n).O
	res, ok := a.(_http.CloseNotifier)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/CloseNotifier], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.ConnState from net/http/server.go:
func ExtractGoObjectConnState(args []Object, index int) *_http.ConnState {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ConnState:
			return &r
		case *_http.ConnState:
			return r
		}
	case Int:
		v := _http.ConnState(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ConnState]"))
}

func _ConstructConnState(_v Object) _http.ConnState {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ConnState:
			return _g
		case *_http.ConnState:
			return *_g
		}
	case Number:
		return _http.ConnState(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ConnState] or: Number"))
}

func ExtractGo_go_std_net_http__ConnState(rcvr, arg string, args *ArraySeq, n int) (res _http.ConnState) {
	a := CheckGoNth(rcvr, "go.std.net.http/ConnState", arg, args, n).O
	res, ok := a.(_http.ConnState)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ConnState], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Cookie from net/http/cookie.go:
func ExtractGoObjectCookie(args []Object, index int) *_http.Cookie {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Cookie:
			return &r
		case *_http.Cookie:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Cookie]"))
}

// func _mapToCookie(o Map) *_http.Cookie {
// 	return &_http.Cookie{}
// }

// func _vectorToCookie(o *Vector) *_http.Cookie {
// 	return &_http.Cookie{
// 		Name: AssertString(o.Nth(0), "").S,
// 		Value: AssertString(o.Nth(1), "").S,
// 		Path: AssertString(o.Nth(2), "").S,
// 		Domain: AssertString(o.Nth(3), "").S,
// 		Expires: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		RawExpires: AssertString(o.Nth(5), "").S,
// 		MaxAge: AssertInt(o.Nth(6), "").I,
// 		Secure: ToBool(o.Nth(7)),
// 		HttpOnly: ToBool(o.Nth(8)),
// 		SameSite: _http.SameSite(AssertInt(o.Nth(9), "").I),
// 		Raw: AssertString(o.Nth(10), "").S,
// 		Unparsed: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructCookie(_v Object) *_http.Cookie {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Cookie:
// 			return &_g
// 		case *_http.Cookie:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCookie(_o.(Map))
// 	case *Vector:
// 		return _vectorToCookie(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Cookie] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Cookie(rcvr, arg string, args *ArraySeq, n int) (res _http.Cookie) {
	a := CheckGoNth(rcvr, "go.std.net.http/Cookie", arg, args, n).O
	res, ok := a.(_http.Cookie)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Cookie], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.CookieJar from net/http/jar.go:
func ExtractGoObjectCookieJar(args []Object, index int) *_http.CookieJar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.CookieJar:
			return &r
		case *_http.CookieJar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.CookieJar]"))
}

// func _ConstructCookieJar(_v Object) _http.CookieJar {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.CookieJar:
// 			return _g
// 		case *_http.CookieJar:
// 			return *_g
// 		}
// 	default:
// 		return _http.CookieJar(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for CookieJar))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.CookieJar] or: whatever"))
// }

func ExtractGo_go_std_net_http__CookieJar(rcvr, arg string, args *ArraySeq, n int) (res _http.CookieJar) {
	a := CheckGoNth(rcvr, "go.std.net.http/CookieJar", arg, args, n).O
	res, ok := a.(_http.CookieJar)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/CookieJar], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Dir from net/http/fs.go:
func ExtractGoObjectDir(args []Object, index int) *_http.Dir {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Dir:
			return &r
		case *_http.Dir:
			return r
		}
	case String:
		v := _http.Dir(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Dir]"))
}

func _ConstructDir(_v Object) _http.Dir {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.Dir:
			return _g
		case *_http.Dir:
			return *_g
		}
	case String:
		return _http.Dir(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Dir] or: String"))
}

func ExtractGo_go_std_net_http__Dir(rcvr, arg string, args *ArraySeq, n int) (res _http.Dir) {
	a := CheckGoNth(rcvr, "go.std.net.http/Dir", arg, args, n).O
	res, ok := a.(_http.Dir)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Dir], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.File from net/http/fs.go:
func ExtractGoObjectFile(args []Object, index int) *_http.File {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.File:
			return &r
		case *_http.File:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.File]"))
}

// func _ConstructFile(_v Object) _http.File {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.File:
// 			return _g
// 		case *_http.File:
// 			return *_g
// 		}
// 	default:
// 		return _http.File(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for File))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.File] or: whatever"))
// }

func ExtractGo_go_std_net_http__File(rcvr, arg string, args *ArraySeq, n int) (res _http.File) {
	a := CheckGoNth(rcvr, "go.std.net.http/File", arg, args, n).O
	res, ok := a.(_http.File)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/File], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.FileSystem from net/http/fs.go:
func ExtractGoObjectFileSystem(args []Object, index int) *_http.FileSystem {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.FileSystem:
			return &r
		case *_http.FileSystem:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.FileSystem]"))
}

// func _ConstructFileSystem(_v Object) _http.FileSystem {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.FileSystem:
// 			return _g
// 		case *_http.FileSystem:
// 			return *_g
// 		}
// 	default:
// 		return _http.FileSystem(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for FileSystem))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.FileSystem] or: whatever"))
// }

func ExtractGo_go_std_net_http__FileSystem(rcvr, arg string, args *ArraySeq, n int) (res _http.FileSystem) {
	a := CheckGoNth(rcvr, "go.std.net.http/FileSystem", arg, args, n).O
	res, ok := a.(_http.FileSystem)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/FileSystem], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Flusher from net/http/server.go:
func ExtractGoObjectFlusher(args []Object, index int) *_http.Flusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Flusher:
			return &r
		case *_http.Flusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Flusher]"))
}

// func _ConstructFlusher(_v Object) _http.Flusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Flusher:
// 			return _g
// 		case *_http.Flusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Flusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Flusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Flusher] or: whatever"))
// }

func ExtractGo_go_std_net_http__Flusher(rcvr, arg string, args *ArraySeq, n int) (res _http.Flusher) {
	a := CheckGoNth(rcvr, "go.std.net.http/Flusher", arg, args, n).O
	res, ok := a.(_http.Flusher)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Flusher], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Handler from net/http/server.go:
func ExtractGoObjectHandler(args []Object, index int) *_http.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Handler:
			return &r
		case *_http.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Handler]"))
}

// func _ConstructHandler(_v Object) _http.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Handler:
// 			return _g
// 		case *_http.Handler:
// 			return *_g
// 		}
// 	default:
// 		return _http.Handler(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Handler))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Handler] or: whatever"))
// }

func ExtractGo_go_std_net_http__Handler(rcvr, arg string, args *ArraySeq, n int) (res _http.Handler) {
	a := CheckGoNth(rcvr, "go.std.net.http/Handler", arg, args, n).O
	res, ok := a.(_http.Handler)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Handler], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.HandlerFunc from net/http/server.go:
func ExtractGoObjectHandlerFunc(args []Object, index int) *_http.HandlerFunc {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.HandlerFunc:
			return &r
		case *_http.HandlerFunc:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.HandlerFunc]"))
}

// func _ConstructHandlerFunc(_v Object) _http.HandlerFunc {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.HandlerFunc:
// 			return _g
// 		case *_http.HandlerFunc:
// 			return *_g
// 		}
// 	default:
// 		return _http.HandlerFunc(_o.ABEND674(codegen.go: unknown underlying type *ast.FuncType for HandlerFunc))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.HandlerFunc] or: whatever"))
// }

func ExtractGo_go_std_net_http__HandlerFunc(rcvr, arg string, args *ArraySeq, n int) (res _http.HandlerFunc) {
	a := CheckGoNth(rcvr, "go.std.net.http/HandlerFunc", arg, args, n).O
	res, ok := a.(_http.HandlerFunc)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/HandlerFunc], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Header from net/http/header.go:
func ExtractGoObjectHeader(args []Object, index int) *_http.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Header:
			return &r
		case *_http.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Header]"))
}

// func _ConstructHeader(_v Object) _http.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Header:
// 			return _g
// 		case *_http.Header:
// 			return *_g
// 		}
// 	default:
// 		return _http.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Header] or: whatever"))
// }

func ExtractGo_go_std_net_http__Header(rcvr, arg string, args *ArraySeq, n int) (res _http.Header) {
	a := CheckGoNth(rcvr, "go.std.net.http/Header", arg, args, n).O
	res, ok := a.(_http.Header)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Header], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Hijacker from net/http/server.go:
func ExtractGoObjectHijacker(args []Object, index int) *_http.Hijacker {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Hijacker:
			return &r
		case *_http.Hijacker:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Hijacker]"))
}

// func _ConstructHijacker(_v Object) _http.Hijacker {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Hijacker:
// 			return _g
// 		case *_http.Hijacker:
// 			return *_g
// 		}
// 	default:
// 		return _http.Hijacker(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Hijacker))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Hijacker] or: whatever"))
// }

func ExtractGo_go_std_net_http__Hijacker(rcvr, arg string, args *ArraySeq, n int) (res _http.Hijacker) {
	a := CheckGoNth(rcvr, "go.std.net.http/Hijacker", arg, args, n).O
	res, ok := a.(_http.Hijacker)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Hijacker], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.ProtocolError from net/http/request.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_http.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ProtocolError:
			return &r
		case *_http.ProtocolError:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ProtocolError]"))
}

func _mapToProtocolError(o Map) *_http.ProtocolError {
	return &_http.ProtocolError{}
}

func _vectorToProtocolError(o *Vector) *_http.ProtocolError {
	return &_http.ProtocolError{
		ErrorString: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructProtocolError(_v Object) *_http.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ProtocolError:
			return &_g
		case *_http.ProtocolError:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToProtocolError(_o.(Map))
	case *Vector:
		return _vectorToProtocolError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ProtocolError] or: Map or Vector"))
}

func ExtractGo_go_std_net_http__ProtocolError(rcvr, arg string, args *ArraySeq, n int) (res _http.ProtocolError) {
	a := CheckGoNth(rcvr, "go.std.net.http/ProtocolError", arg, args, n).O
	res, ok := a.(_http.ProtocolError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ProtocolError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.PushOptions from net/http/http.go:
func ExtractGoObjectPushOptions(args []Object, index int) *_http.PushOptions {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.PushOptions:
			return &r
		case *_http.PushOptions:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.PushOptions]"))
}

// func _mapToPushOptions(o Map) *_http.PushOptions {
// 	return &_http.PushOptions{}
// }

// func _vectorToPushOptions(o *Vector) *_http.PushOptions {
// 	return &_http.PushOptions{
// 		Method: AssertString(o.Nth(0), "").S,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 	}
// }

// func _ConstructPushOptions(_v Object) *_http.PushOptions {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.PushOptions:
// 			return &_g
// 		case *_http.PushOptions:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToPushOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToPushOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.PushOptions] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__PushOptions(rcvr, arg string, args *ArraySeq, n int) (res _http.PushOptions) {
	a := CheckGoNth(rcvr, "go.std.net.http/PushOptions", arg, args, n).O
	res, ok := a.(_http.PushOptions)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/PushOptions], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Pusher from net/http/http.go:
func ExtractGoObjectPusher(args []Object, index int) *_http.Pusher {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Pusher:
			return &r
		case *_http.Pusher:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Pusher]"))
}

// func _ConstructPusher(_v Object) _http.Pusher {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Pusher:
// 			return _g
// 		case *_http.Pusher:
// 			return *_g
// 		}
// 	default:
// 		return _http.Pusher(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Pusher))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Pusher] or: whatever"))
// }

func ExtractGo_go_std_net_http__Pusher(rcvr, arg string, args *ArraySeq, n int) (res _http.Pusher) {
	a := CheckGoNth(rcvr, "go.std.net.http/Pusher", arg, args, n).O
	res, ok := a.(_http.Pusher)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Pusher], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Request from net/http/request.go:
func ExtractGoObjectRequest(args []Object, index int) *_http.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Request:
			return &r
		case *_http.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Request]"))
}

// func _mapToRequest(o Map) *_http.Request {
// 	return &_http.Request{}
// }

// func _vectorToRequest(o *Vector) *_http.Request {
// 	return &_http.Request{
// 		Method: AssertString(o.Nth(0), "").S,
// 		URL: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		GetBody: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ContentLength: AssertNumber(o.Nth(8), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(10)),
// 		Host: AssertString(o.Nth(11), "").S,
// 		Form: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PostForm: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MultipartForm: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		RemoteAddr: AssertString(o.Nth(16), "").S,
// 		RequestURI: AssertString(o.Nth(17), "").S,
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Cancel: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 		Response: ABEND048(codegen.go: no conversion from Clojure for *net/http.Response (net/http.Response)),
// 	}
// }

// func _ConstructRequest(_v Object) *_http.Request {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Request:
// 			return &_g
// 		case *_http.Request:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToRequest(_o.(Map))
// 	case *Vector:
// 		return _vectorToRequest(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Request] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Request(rcvr, arg string, args *ArraySeq, n int) (res _http.Request) {
	a := CheckGoNth(rcvr, "go.std.net.http/Request", arg, args, n).O
	res, ok := a.(_http.Request)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Request], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Response from net/http/response.go:
func ExtractGoObjectResponse(args []Object, index int) *_http.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Response:
			return &r
		case *_http.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Response]"))
}

// func _mapToResponse(o Map) *_http.Response {
// 	return &_http.Response{}
// }

// func _vectorToResponse(o *Vector) *_http.Response {
// 	return &_http.Response{
// 		Status: AssertString(o.Nth(0), "").S,
// 		StatusCode: AssertInt(o.Nth(1), "").I,
// 		Proto: AssertString(o.Nth(2), "").S,
// 		ProtoMajor: AssertInt(o.Nth(3), "").I,
// 		ProtoMinor: AssertInt(o.Nth(4), "").I,
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ContentLength: AssertNumber(o.Nth(7), "").BigInt().Int64(),
// 		TransferEncoding: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Close: ToBool(o.Nth(9)),
// 		Uncompressed: ToBool(o.Nth(10)),
// 		Trailer: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Request: ABEND048(codegen.go: no conversion from Clojure for *net/http.Request (net/http.Request)),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructResponse(_v Object) *_http.Response {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Response:
// 			return &_g
// 		case *_http.Response:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponse(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponse(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Response] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Response(rcvr, arg string, args *ArraySeq, n int) (res _http.Response) {
	a := CheckGoNth(rcvr, "go.std.net.http/Response", arg, args, n).O
	res, ok := a.(_http.Response)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Response], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.ResponseWriter from net/http/server.go:
func ExtractGoObjectResponseWriter(args []Object, index int) *_http.ResponseWriter {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ResponseWriter:
			return &r
		case *_http.ResponseWriter:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ResponseWriter]"))
}

// func _ConstructResponseWriter(_v Object) _http.ResponseWriter {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.ResponseWriter:
// 			return _g
// 		case *_http.ResponseWriter:
// 			return *_g
// 		}
// 	default:
// 		return _http.ResponseWriter(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ResponseWriter))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ResponseWriter] or: whatever"))
// }

func ExtractGo_go_std_net_http__ResponseWriter(rcvr, arg string, args *ArraySeq, n int) (res _http.ResponseWriter) {
	a := CheckGoNth(rcvr, "go.std.net.http/ResponseWriter", arg, args, n).O
	res, ok := a.(_http.ResponseWriter)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ResponseWriter], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.RoundTripper from net/http/client.go:
func ExtractGoObjectRoundTripper(args []Object, index int) *_http.RoundTripper {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.RoundTripper:
			return &r
		case *_http.RoundTripper:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.RoundTripper]"))
}

// func _ConstructRoundTripper(_v Object) _http.RoundTripper {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.RoundTripper:
// 			return _g
// 		case *_http.RoundTripper:
// 			return *_g
// 		}
// 	default:
// 		return _http.RoundTripper(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for RoundTripper))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.RoundTripper] or: whatever"))
// }

func ExtractGo_go_std_net_http__RoundTripper(rcvr, arg string, args *ArraySeq, n int) (res _http.RoundTripper) {
	a := CheckGoNth(rcvr, "go.std.net.http/RoundTripper", arg, args, n).O
	res, ok := a.(_http.RoundTripper)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/RoundTripper], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.SameSite from net/http/cookie.go:
func ExtractGoObjectSameSite(args []Object, index int) *_http.SameSite {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.SameSite:
			return &r
		case *_http.SameSite:
			return r
		}
	case Int:
		v := _http.SameSite(ExtractInt(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.SameSite]"))
}

func _ConstructSameSite(_v Object) _http.SameSite {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.SameSite:
			return _g
		case *_http.SameSite:
			return *_g
		}
	case Number:
		return _http.SameSite(_o.Int().I)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.SameSite] or: Number"))
}

func ExtractGo_go_std_net_http__SameSite(rcvr, arg string, args *ArraySeq, n int) (res _http.SameSite) {
	a := CheckGoNth(rcvr, "go.std.net.http/SameSite", arg, args, n).O
	res, ok := a.(_http.SameSite)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/SameSite], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.ServeMux from net/http/server.go:
func ExtractGoObjectServeMux(args []Object, index int) *_http.ServeMux {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.ServeMux:
			return &r
		case *_http.ServeMux:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.ServeMux]"))
}

func _mapToServeMux(o Map) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _vectorToServeMux(o *Vector) *_http.ServeMux {
	return &_http.ServeMux{}
}

func _ConstructServeMux(_v Object) *_http.ServeMux {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _http.ServeMux:
			return &_g
		case *_http.ServeMux:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServeMux(_o.(Map))
	case *Vector:
		return _vectorToServeMux(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[http.ServeMux] or: Map or Vector"))
}

func ExtractGo_go_std_net_http__ServeMux(rcvr, arg string, args *ArraySeq, n int) (res _http.ServeMux) {
	a := CheckGoNth(rcvr, "go.std.net.http/ServeMux", arg, args, n).O
	res, ok := a.(_http.ServeMux)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/ServeMux], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Server from net/http/server.go:
func ExtractGoObjectServer(args []Object, index int) *_http.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Server:
			return &r
		case *_http.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Server]"))
}

// func _mapToServer(o Map) *_http.Server {
// 	return &_http.Server{}
// }

// func _vectorToServer(o *Vector) *_http.Server {
// 	return &_http.Server{
// 		Addr: AssertString(o.Nth(0), "").S,
// 		Handler: ABEND048(codegen.go: no conversion from Clojure for net/http.Handler (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		TLSConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ReadHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		WriteTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		IdleTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		MaxHeaderBytes: AssertInt(o.Nth(7), "").I,
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ConnState: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_http.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Server:
// 			return &_g
// 		case *_http.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Server] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Server(rcvr, arg string, args *ArraySeq, n int) (res _http.Server) {
	a := CheckGoNth(rcvr, "go.std.net.http/Server", arg, args, n).O
	res, ok := a.(_http.Server)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Server], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http.Transport from net/http/transport.go:
func ExtractGoObjectTransport(args []Object, index int) *_http.Transport {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _http.Transport:
			return &r
		case *_http.Transport:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http.Transport]"))
}

// func _mapToTransport(o Map) *_http.Transport {
// 	return &_http.Transport{}
// }

// func _vectorToTransport(o *Vector) *_http.Transport {
// 	return &_http.Transport{
// 		Proxy: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialContext: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Dial: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DialTLS: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSClientConfig: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSHandshakeTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		DisableKeepAlives: ToBool(o.Nth(6)),
// 		DisableCompression: ToBool(o.Nth(7)),
// 		MaxIdleConns: AssertInt(o.Nth(8), "").I,
// 		MaxIdleConnsPerHost: AssertInt(o.Nth(9), "").I,
// 		MaxConnsPerHost: AssertInt(o.Nth(10), "").I,
// 		IdleConnTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ResponseHeaderTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ExpectContinueTimeout: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLSNextProto: ABEND047(gotypes.go: unsupported type *ast.MapType),
// 		ProxyConnectHeader: ABEND048(codegen.go: no conversion from Clojure for net/http.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		MaxResponseHeaderBytes: AssertNumber(o.Nth(16), "").BigInt().Int64(),
// 	}
// }

// func _ConstructTransport(_v Object) *_http.Transport {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _http.Transport:
// 			return &_g
// 		case *_http.Transport:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToTransport(_o.(Map))
// 	case *Vector:
// 		return _vectorToTransport(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[http.Transport] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http__Transport(rcvr, arg string, args *ArraySeq, n int) (res _http.Transport) {
	a := CheckGoNth(rcvr, "go.std.net.http/Transport", arg, args, n).O
	res, ok := a.(_http.Transport)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http/Transport], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http.DetectContentType from net/http/sniff.go:
// func __detectContentType(__data []byte)  {
// 	_res := _http.DetectContentType(__data)
// 	return MakeString(_res)
// }

GO FUNC net/http.Error from net/http/server.go:
// func __error(__w _http.ResponseWriter, __error string, __code int) Object {
// 	_http.Error(__w, __error, __code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer from net/http/fs.go:
func __fileServer(__root _http.FileSystem) Object {
	_res := _http.FileServer(__root)
	return MakeGoObject(_res)
}

GO FUNC net/http.Get from net/http/client.go:
func __get(__url string) Object {
	resp, err := _http.Get(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Handle from net/http/server.go:
// func __handle(__pattern string, __handler _http.Handler) Object {
// 	_http.Handle(__pattern, __handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc from net/http/server.go:
// func __handleFunc(__pattern string, __handler func) Object {
// 	_http.HandleFunc(__pattern, __handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head from net/http/client.go:
func __head(__url string) Object {
	resp, err := _http.Head(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.MaxBytesReader from net/http/request.go:
// func __maxBytesReader(__w _http.ResponseWriter, __r ABEND987(genutils.go: imports not yet supported: io.ReadCloser), __n int64) Object {
// 	return _http.MaxBytesReader(__w, __r, __n)
// }

GO FUNC net/http.NewFileTransport from net/http/filetransport.go:
func __newFileTransport(__fs _http.FileSystem) Object {
	_res := _http.NewFileTransport(__fs)
	return MakeGoObject(_res)
}

GO FUNC net/http.NewRequest from net/http/request.go:
// func __newRequest(__method string, __url string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res1, _res2 := _http.NewRequest(__method, __url, __body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux from net/http/server.go:
func __newServeMux() Object {
	_res := _http.NewServeMux()
	return MakeGoObject(_res)
}

GO FUNC net/http.NotFound from net/http/server.go:
// func __notFound(__w _http.ResponseWriter, __r *_http.Request) Object {
// 	_http.NotFound(__w, __r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler from net/http/server.go:
func __notFoundHandler() Object {
	_res := _http.NotFoundHandler()
	return MakeGoObject(_res)
}

GO FUNC net/http.ParseHTTPVersion from net/http/request.go:
func __parseHTTPVersion(__vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(__vers)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.ParseTime from net/http/header.go:
// func __parseTime(__text string) Object {
// 	t, err := _http.ParseTime(__text)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(t)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Post from net/http/client.go:
// func __post(__url string, __contentType string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	resp, err := _http.Post(__url, __contentType, __body)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm from net/http/client.go:
// func __postForm(__url string, __data ABEND987(genutils.go: imports not yet supported: url.Values)) Object {
// 	resp, err := _http.PostForm(__url, __data)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(resp))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment from net/http/transport.go:
func __proxyFromEnvironment(__req *_http.Request) Object {
	_res1, _res2 := _http.ProxyFromEnvironment(__req)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.ProxyURL from net/http/transport.go:
// func __proxyURL(__fixedURL *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	return _http.ProxyURL(__fixedURL)
// }

GO FUNC net/http.ReadRequest from net/http/request.go:
// func __readRequest(__b *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res1, _res2 := _http.ReadRequest(__b)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse from net/http/response.go:
// func __readResponse(__r *ABEND987(genutils.go: imports not yet supported: bufio.Reader), __req *_http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(__r, __req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect from net/http/server.go:
// func __redirect(__w _http.ResponseWriter, __r *_http.Request, __url string, __code int) Object {
// 	_http.Redirect(__w, __r, __url, __code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler from net/http/server.go:
func __redirectHandler(__url string, __code int) Object {
	_res := _http.RedirectHandler(__url, __code)
	return MakeGoObject(_res)
}

GO FUNC net/http.Serve from net/http/server.go:
// func __serve(__l ABEND987(genutils.go: imports not yet supported: net.Listener), __handler _http.Handler)  {
// 	_res := _http.Serve(__l, __handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.ServeContent from net/http/fs.go:
// func __serveContent(__w _http.ResponseWriter, __req *_http.Request, __name string, __modtime ABEND987(genutils.go: imports not yet supported: time.Time), __content ABEND987(genutils.go: imports not yet supported: io.ReadSeeker)) Object {
// 	_http.ServeContent(__w, __req, __name, __modtime, __content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile from net/http/fs.go:
// func __serveFile(__w _http.ResponseWriter, __r *_http.Request, __name string) Object {
// 	_http.ServeFile(__w, __r, __name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeTLS from net/http/server.go:
// func __serveTLS(__l ABEND987(genutils.go: imports not yet supported: net.Listener), __handler _http.Handler, __certFile string, __keyFile string)  {
// 	_res := _http.ServeTLS(__l, __handler, __certFile, __keyFile)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.SetCookie from net/http/cookie.go:
// func __setCookie(__w _http.ResponseWriter, __cookie *_http.Cookie) Object {
// 	_http.SetCookie(__w, __cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix from net/http/server.go:
func __stripPrefix(__prefix string, __h _http.Handler) Object {
	_res := _http.StripPrefix(__prefix, __h)
	return MakeGoObject(_res)
}

GO FUNC net/http.TimeoutHandler from net/http/server.go:
// func __timeoutHandler(__h _http.Handler, __dt ABEND987(genutils.go: imports not yet supported: time.Duration), __msg string) Object {
// 	_res := _http.TimeoutHandler(__h, __dt, __msg)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http.__closeNotifier_CloseNotify from net/http/server.go:
// func __closeNotifier_CloseNotify(o GoObject, args Object) Object {
// ABEND883(post.go: unrecognized Expr type *ast.ChanType at: _tests/big/src/net/http/server.go:228:16)}

GO FUNC net/http.__connState_String from net/http/server.go:
func __connState_String(o GoObject, args Object) Object {
	CheckGoArity("(_net/http.ConnState)String()", args, 0, 0)
	_res := o.O.(_http.ConnState).String()
	return MakeString(_res)
}

GO FUNC net/http.__cookieJar_Cookies from net/http/jar.go:
// func __cookieJar_Cookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL)}

GO FUNC net/http.__cookieJar_SetCookies from net/http/jar.go:
// func __cookieJar_SetCookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL), __cookies []*_http.Cookie}

GO FUNC net/http.__dir_Open from net/http/fs.go:
func __dir_Open(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Dir)Open()", args, 1, 1)
	__name := ExtractGoString("(_net/http.Dir)Open()", "__name", _argList, 0)
	_res1, _res2 := o.O.(_http.Dir).Open(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__fileSystem_Open from net/http/fs.go:
func __fileSystem_Open(o GoObject, args Object) Object {
	_argList := CheckGoArity("(net/http.FileSystem)Open()", args, 1, 1)
	__name := ExtractGoString("(net/http.FileSystem)Open()", "__name", _argList, 0)
	_res1, _res2 := o.O.(_http.FileSystem).Open(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__flusher_Flush from net/http/server.go:
// func __flusher_Flush(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__handlerFunc_ServeHTTP from net/http/server.go:
// func __handlerFunc_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__handler_ServeHTTP from net/http/server.go:
// func __handler_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Add from net/http/header.go:
// func __header_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Del from net/http/header.go:
// func __header_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Get from net/http/header.go:
func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/http.Header)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/http.Header)Get()", "__key", _argList, 0)
	_res := o.O.(_http.Header).Get(__key)
	return MakeString(_res)
}

GO FUNC net/http.__header_Set from net/http/header.go:
// func __header_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__header_Write from net/http/header.go:
// func __header_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__header_WriteSubset from net/http/header.go:
// func __header_WriteSubset(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer), __exclude map[]}

GO FUNC net/http.__hijacker_Hijack from net/http/server.go:
// func __hijacker_Hijack(o GoObject, args Object) Object {
// [go.std.net/Conn (atom-of ABEND042(post.go: cannot find typename bufio.ReadWriter)) Error]}

GO FUNC net/http.__ptrTo_Client_Do from net/http/client.go:
// func __ptrTo_Client_Do(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Client)Do()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __req at: _tests/big/src/net/http/client.go:508:25)
// 	_res1, _res2 := o.O.(*_http.Client).Do(__req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.__ptrTo_Client_Get from net/http/client.go:
func __ptrTo_Client_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Get()", args, 1, 1)
	__url := ExtractGoString("(*_net/http.Client)Get()", "__url", _argList, 0)
	resp, err := o.O.(*_http.Client).Get(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Client_Head from net/http/client.go:
func __ptrTo_Client_Head(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Client)Head()", args, 1, 1)
	__url := ExtractGoString("(*_net/http.Client)Head()", "__url", _argList, 0)
	resp, err := o.O.(*_http.Client).Head(__url)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(resp))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Client_Post from net/http/client.go:
// func __ptrTo_Client_Post(o GoObject, args Object) Object {
// __url string, __contentType string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)}

GO FUNC net/http.__ptrTo_Client_PostForm from net/http/client.go:
// func __ptrTo_Client_PostForm(o GoObject, args Object) Object {
// __url string, __data ABEND987(genutils.go: imports not yet supported: url.Values)}

GO FUNC net/http.__ptrTo_Cookie_String from net/http/cookie.go:
func __ptrTo_Cookie_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Cookie)String()", args, 0, 0)
	_res := o.O.(*_http.Cookie).String()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_ProtocolError_Error from net/http/request.go:
func __ptrTo_ProtocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(*_http.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_AddCookie from net/http/request.go:
// func __ptrTo_Request_AddCookie(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Request_BasicAuth from net/http/request.go:
func __ptrTo_Request_BasicAuth(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)BasicAuth()", args, 0, 0)
	username, password, ok := o.O.(*_http.Request).BasicAuth()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(username))
	_res = _res.Conjoin(MakeString(password))
	_res = _res.Conjoin(MakeBoolean(ok))
	return _res
}

GO FUNC net/http.__ptrTo_Request_Context from net/http/request.go:
// func __ptrTo_Request_Context(o GoObject, args Object) Object {
// ABEND042(post.go: cannot find typename context.Context)}

GO FUNC net/http.__ptrTo_Request_Cookie from net/http/request.go:
func __ptrTo_Request_Cookie(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)Cookie()", args, 1, 1)
	__name := ExtractGoString("(*_net/http.Request)Cookie()", "__name", _argList, 0)
	_res1, _res2 := o.O.(*_http.Request).Cookie(__name)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Request_Cookies from net/http/request.go:
func __ptrTo_Request_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Request).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC net/http.__ptrTo_Request_FormFile from net/http/request.go:
// func __ptrTo_Request_FormFile(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename mime/multipart.File) (atom-of ABEND042(post.go: cannot find typename mime/multipart.FileHeader)) Error]}

GO FUNC net/http.__ptrTo_Request_FormValue from net/http/request.go:
func __ptrTo_Request_FormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)FormValue()", args, 1, 1)
	__key := ExtractGoString("(*_net/http.Request)FormValue()", "__key", _argList, 0)
	_res := o.O.(*_http.Request).FormValue(__key)
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_MultipartReader from net/http/request.go:
// func __ptrTo_Request_MultipartReader(o GoObject, args Object) Object {
// [(atom-of ABEND042(post.go: cannot find typename mime/multipart.Reader)) Error]}

GO FUNC net/http.__ptrTo_Request_ParseForm from net/http/request.go:
func __ptrTo_Request_ParseForm(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)ParseForm()", args, 0, 0)
	_res := o.O.(*_http.Request).ParseForm()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Request_ParseMultipartForm from net/http/request.go:
func __ptrTo_Request_ParseMultipartForm(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ParseMultipartForm()", args, 1, 1)
	__maxMemory := ExtractGoInt64("(*_net/http.Request)ParseMultipartForm()", "__maxMemory", _argList, 0)
	_res := o.O.(*_http.Request).ParseMultipartForm(__maxMemory)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Request_PostFormValue from net/http/request.go:
func __ptrTo_Request_PostFormValue(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)PostFormValue()", args, 1, 1)
	__key := ExtractGoString("(*_net/http.Request)PostFormValue()", "__key", _argList, 0)
	_res := o.O.(*_http.Request).PostFormValue(__key)
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_ProtoAtLeast from net/http/request.go:
func __ptrTo_Request_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Request)ProtoAtLeast()", args, 2, 2)
	__major := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "__major", _argList, 0)
	__minor := ExtractGoInt("(*_net/http.Request)ProtoAtLeast()", "__minor", _argList, 1)
	_res := o.O.(*_http.Request).ProtoAtLeast(__major, __minor)
	return MakeBoolean(_res)
}

GO FUNC net/http.__ptrTo_Request_Referer from net/http/request.go:
func __ptrTo_Request_Referer(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)Referer()", args, 0, 0)
	_res := o.O.(*_http.Request).Referer()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_SetBasicAuth from net/http/request.go:
// func __ptrTo_Request_SetBasicAuth(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Request_UserAgent from net/http/request.go:
func __ptrTo_Request_UserAgent(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Request)UserAgent()", args, 0, 0)
	_res := o.O.(*_http.Request).UserAgent()
	return MakeString(_res)
}

GO FUNC net/http.__ptrTo_Request_WithContext from net/http/request.go:
// func __ptrTo_Request_WithContext(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC net/http.__ptrTo_Request_Write from net/http/request.go:
// func __ptrTo_Request_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_Request_WriteProxy from net/http/request.go:
// func __ptrTo_Request_WriteProxy(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_Response_Cookies from net/http/response.go:
func __ptrTo_Response_Cookies(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Cookies()", args, 0, 0)
	_res := o.O.(*_http.Response).Cookies()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	return _vec1
}

GO FUNC net/http.__ptrTo_Response_Location from net/http/response.go:
func __ptrTo_Response_Location(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Response)Location()", args, 0, 0)
	_res1, _res2 := o.O.(*_http.Response).Location()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http.__ptrTo_Response_ProtoAtLeast from net/http/response.go:
func __ptrTo_Response_ProtoAtLeast(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Response)ProtoAtLeast()", args, 2, 2)
	__major := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "__major", _argList, 0)
	__minor := ExtractGoInt("(*_net/http.Response)ProtoAtLeast()", "__minor", _argList, 1)
	_res := o.O.(*_http.Response).ProtoAtLeast(__major, __minor)
	return MakeBoolean(_res)
}

GO FUNC net/http.__ptrTo_Response_Write from net/http/response.go:
// func __ptrTo_Response_Write(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: io.Writer)}

GO FUNC net/http.__ptrTo_ServeMux_Handle from net/http/server.go:
// func __ptrTo_ServeMux_Handle(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_ServeMux_HandleFunc from net/http/server.go:
// func __ptrTo_ServeMux_HandleFunc(o GoObject, args Object) Object {
// (__pattern, ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC net/http.__ptrTo_ServeMux_Handler from net/http/server.go:
// func __ptrTo_ServeMux_Handler(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.ServeMux)Handler()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __r at: _tests/big/src/net/http/server.go:2296:32)
// 	h, pattern := o.O.(*_http.ServeMux).Handler(__r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(h))
// 	_res = _res.Conjoin(MakeString(pattern))
// 	return _res
// }

GO FUNC net/http.__ptrTo_ServeMux_ServeHTTP from net/http/server.go:
// func __ptrTo_ServeMux_ServeHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Server_Close from net/http/server.go:
func __ptrTo_Server_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)Close()", args, 0, 0)
	_res := o.O.(*_http.Server).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_ListenAndServe from net/http/server.go:
func __ptrTo_Server_ListenAndServe(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http.Server)ListenAndServe()", args, 0, 0)
	_res := o.O.(*_http.Server).ListenAndServe()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_ListenAndServeTLS from net/http/server.go:
func __ptrTo_Server_ListenAndServeTLS(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http.Server)ListenAndServeTLS()", args, 2, 2)
	__certFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "__certFile", _argList, 0)
	__keyFile := ExtractGoString("(*_net/http.Server)ListenAndServeTLS()", "__keyFile", _argList, 1)
	_res := o.O.(*_http.Server).ListenAndServeTLS(__certFile, __keyFile)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http.__ptrTo_Server_RegisterOnShutdown from net/http/server.go:
// func __ptrTo_Server_RegisterOnShutdown(o GoObject, args Object) Object {
// (ABEND906(pre.go: custom-runtime routine not implemented: ConvertToFuncTypeHaHafunc()))}

GO FUNC net/http.__ptrTo_Server_Serve from net/http/server.go:
// func __ptrTo_Server_Serve(o GoObject, args Object) Object {
// __l ABEND987(genutils.go: imports not yet supported: net.Listener)}

GO FUNC net/http.__ptrTo_Server_ServeTLS from net/http/server.go:
// func __ptrTo_Server_ServeTLS(o GoObject, args Object) Object {
// __l ABEND987(genutils.go: imports not yet supported: net.Listener), __certFile string, __keyFile string}

GO FUNC net/http.__ptrTo_Server_SetKeepAlivesEnabled from net/http/server.go:
// func __ptrTo_Server_SetKeepAlivesEnabled(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Server_Shutdown from net/http/server.go:
// func __ptrTo_Server_Shutdown(o GoObject, args Object) Object {
// __ctx ABEND987(genutils.go: imports not yet supported: context.Context)}

GO FUNC net/http.__ptrTo_Transport_CancelRequest from net/http/transport.go:
// func __ptrTo_Transport_CancelRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_CloseIdleConnections from net/http/transport.go:
// func __ptrTo_Transport_CloseIdleConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_RegisterProtocol from net/http/transport.go:
// func __ptrTo_Transport_RegisterProtocol(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__ptrTo_Transport_RoundTrip from net/http/roundtrip.go:
// func __ptrTo_Transport_RoundTrip(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/http.Transport)RoundTrip()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __req at: _tests/big/src/net/http/roundtrip.go:16:35)
// 	_res1, _res2 := o.O.(*_http.Transport).RoundTrip(__req)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.__pusher_Push from net/http/http.go:
// func __pusher_Push(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(net/http.Pusher)Push()", args, 2, 2)
// 	__target := ExtractGoString("(net/http.Pusher)Push()", "__target", _argList, 0)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __opts at: _tests/big/src/net/http/http.go:140:27)
// 	_res := o.O.(_http.Pusher).Push(__target, __opts)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http.__responseWriter_Header from net/http/server.go:
func __responseWriter_Header(o GoObject, args Object) Object {
	CheckGoArity("(net/http.ResponseWriter)Header()", args, 0, 0)
	_res := o.O.(_http.ResponseWriter).Header()
	return MakeGoObject(_res)
}

GO FUNC net/http.__responseWriter_Write from net/http/server.go:
// func __responseWriter_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__arg1)))}

GO FUNC net/http.__responseWriter_WriteHeader from net/http/server.go:
// func __responseWriter_WriteHeader(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http.__roundTripper_RoundTrip from net/http/client.go:
// func __roundTripper_RoundTrip(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(net/http.RoundTripper)RoundTrip()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __arg1 at: _tests/big/src/net/http/client.go:140:12)
// 	_res1, _res2 := o.O.(_http.RoundTripper).RoundTrip(__arg1)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO VARDEF FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Client from -:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
var info_CloseNotifier GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
var info_ConnState GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/ConnState from -:
var info_PtrTo_ConnState GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
var info_Cookie GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Cookie from -:
var info_PtrTo_Cookie GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
var info_CookieJar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
var info_Dir GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Dir from -:
var info_PtrTo_Dir GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
var info_File GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
var info_FileSystem GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
var info_Flusher GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
var info_Handler GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
var info_HandlerFunc GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/HandlerFunc from -:
var info_PtrTo_HandlerFunc GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
var info_Header GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Header from -:
var info_PtrTo_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
var info_Hijacker GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
var info_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/ProtocolError from -:
var info_PtrTo_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
var info_PushOptions GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/PushOptions from -:
var info_PtrTo_PushOptions GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
var info_Pusher GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
var info_Request GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Request from -:
var info_PtrTo_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
var info_Response GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Response from -:
var info_PtrTo_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
var info_ResponseWriter GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
var info_RoundTripper GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
var info_SameSite GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/SameSite from -:
var info_PtrTo_SameSite GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
var info_ServeMux GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/ServeMux from -:
var info_PtrTo_ServeMux GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Server from -:
var info_PtrTo_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
var info_Transport GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http/Transport from -:
var info_PtrTo_Transport GoTypeInfo

GO INFO FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
	info_Client = GoTypeInfo{Name: "go.std.net.http/Client",
		GoType: &GoType{T: &info_Client},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Client from -:
	info_PtrTo_Client = GoTypeInfo{Name: "*go.std.net.http/Client",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", __ptrTo_Client_Get, "Get issues a GET to the specified URL. If the response is one of the\nfollowing redirect codes, Get follows the redirect after calling the\nClient's CheckRedirect function:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if the Client's CheckRedirect function fails\nor if there was an HTTP protocol error. A non-2xx response doesn't\ncause an error. Any returned error will be of type *url.Error. The\nurl.Error value's Timeout method will report true if request timed\nout or was canceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nTo make a request with custom headers, use NewRequest and Client.Do.\n", "1.0", NewVectorFrom(MakeSymbol("url"))),
			"Head": MakeGoReceiver("Head", __ptrTo_Client_Head, "Head issues a HEAD to the specified URL. If the response is one of the\nfollowing redirect codes, Head follows the redirect after calling the\nClient's CheckRedirect function:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n", "1.0", NewVectorFrom(MakeSymbol("url"))),
		}}


GO INFO FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
	info_CloseNotifier = GoTypeInfo{Name: "go.std.net.http/CloseNotifier",
		GoType: &GoType{T: &info_CloseNotifier},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
	info_ConnState = GoTypeInfo{Name: "go.std.net.http/ConnState",
		GoType: &GoType{T: &info_ConnState},
		Members: GoMembers{
			"String": MakeGoReceiver("String", __connState_String, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.http/ConnState from -:
	info_PtrTo_ConnState = GoTypeInfo{Name: "*go.std.net.http/ConnState",
		GoType: &GoType{T: &info_PtrTo_ConnState},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
	info_Cookie = GoTypeInfo{Name: "go.std.net.http/Cookie",
		GoType: &GoType{T: &info_Cookie},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Cookie from -:
	info_PtrTo_Cookie = GoTypeInfo{Name: "*go.std.net.http/Cookie",
		GoType: &GoType{T: &info_PtrTo_Cookie},
		Members: GoMembers{
			"String": MakeGoReceiver("String", __ptrTo_Cookie_String, "String returns the serialization of the cookie for use in a Cookie\nheader (if only Name and Value are set) or a Set-Cookie response\nheader (if other fields are set).\nIf c is nil or c.Name is invalid, the empty string is returned.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
	info_CookieJar = GoTypeInfo{Name: "go.std.net.http/CookieJar",
		GoType: &GoType{T: &info_CookieJar},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
	info_Dir = GoTypeInfo{Name: "go.std.net.http/Dir",
		GoType: &GoType{T: &info_Dir},
		Members: GoMembers{
			"Open": MakeGoReceiver("Open", __dir_Open, "", "1.0", NewVectorFrom(MakeSymbol("name"))),
		}}


GO INFO FOR TYPE *go.std.net.http/Dir from -:
	info_PtrTo_Dir = GoTypeInfo{Name: "*go.std.net.http/Dir",
		GoType: &GoType{T: &info_PtrTo_Dir},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
	info_File = GoTypeInfo{Name: "go.std.net.http/File",
		GoType: &GoType{T: &info_File},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
	info_FileSystem = GoTypeInfo{Name: "go.std.net.http/FileSystem",
		GoType: &GoType{T: &info_FileSystem},
		Members: GoMembers{
			"Open": MakeGoReceiver("Open", __fileSystem_Open, "", "1.0", NewVectorFrom(MakeSymbol("name"))),
		}}


GO INFO FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
	info_Flusher = GoTypeInfo{Name: "go.std.net.http/Flusher",
		GoType: &GoType{T: &info_Flusher},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
	info_Handler = GoTypeInfo{Name: "go.std.net.http/Handler",
		GoType: &GoType{T: &info_Handler},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	info_HandlerFunc = GoTypeInfo{Name: "go.std.net.http/HandlerFunc",
		GoType: &GoType{T: &info_HandlerFunc},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/HandlerFunc from -:
	info_PtrTo_HandlerFunc = GoTypeInfo{Name: "*go.std.net.http/HandlerFunc",
		GoType: &GoType{T: &info_PtrTo_HandlerFunc},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
	info_Header = GoTypeInfo{Name: "go.std.net.http/Header",
		GoType: &GoType{T: &info_Header},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", __header_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; textproto.CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		}}


GO INFO FOR TYPE *go.std.net.http/Header from -:
	info_PtrTo_Header = GoTypeInfo{Name: "*go.std.net.http/Header",
		GoType: &GoType{T: &info_PtrTo_Header},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
	info_Hijacker = GoTypeInfo{Name: "go.std.net.http/Hijacker",
		GoType: &GoType{T: &info_Hijacker},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
	info_ProtocolError = GoTypeInfo{Name: "go.std.net.http/ProtocolError",
		GoType: &GoType{T: &info_ProtocolError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/ProtocolError from -:
	info_PtrTo_ProtocolError = GoTypeInfo{Name: "*go.std.net.http/ProtocolError",
		GoType: &GoType{T: &info_PtrTo_ProtocolError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_ProtocolError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
	info_PushOptions = GoTypeInfo{Name: "go.std.net.http/PushOptions",
		GoType: &GoType{T: &info_PushOptions},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/PushOptions from -:
	info_PtrTo_PushOptions = GoTypeInfo{Name: "*go.std.net.http/PushOptions",
		GoType: &GoType{T: &info_PtrTo_PushOptions},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
	info_Pusher = GoTypeInfo{Name: "go.std.net.http/Pusher",
		GoType: &GoType{T: &info_Pusher},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
	info_Request = GoTypeInfo{Name: "go.std.net.http/Request",
		GoType: &GoType{T: &info_Request},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Request from -:
	info_PtrTo_Request = GoTypeInfo{Name: "*go.std.net.http/Request",
		GoType: &GoType{T: &info_PtrTo_Request},
		Members: GoMembers{
			"BasicAuth": MakeGoReceiver("BasicAuth", __ptrTo_Request_BasicAuth, "BasicAuth returns the username and password provided in the request's\nAuthorization header, if the request uses HTTP Basic Authentication.\nSee RFC 2617, Section 2.\n", "1.0", NewVectorFrom()),
			"Cookie": MakeGoReceiver("Cookie", __ptrTo_Request_Cookie, "Cookie returns the named cookie provided in the request or\nErrNoCookie if not found.\nIf multiple cookies match the given name, only one cookie will\nbe returned.\n", "1.0", NewVectorFrom(MakeSymbol("name"))),
			"Cookies": MakeGoReceiver("Cookies", __ptrTo_Request_Cookies, "Cookies parses and returns the HTTP cookies sent with the request.\n", "1.0", NewVectorFrom()),
			"FormValue": MakeGoReceiver("FormValue", __ptrTo_Request_FormValue, "FormValue returns the first value for the named component of the query.\nPOST and PUT body parameters take precedence over URL query string values.\nFormValue calls ParseMultipartForm and ParseForm if necessary and ignores\nany errors returned by these functions.\nIf key is not present, FormValue returns the empty string.\nTo access multiple values of the same key, call ParseForm and\nthen inspect Request.Form directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"ParseForm": MakeGoReceiver("ParseForm", __ptrTo_Request_ParseForm, "ParseForm populates r.Form and r.PostForm.\n\nFor all requests, ParseForm parses the raw query from the URL and updates\nr.Form.\n\nFor POST, PUT, and PATCH requests, it also parses the request body as a form\nand puts the results into both r.PostForm and r.Form. Request body parameters\ntake precedence over URL query string values in r.Form.\n\nFor other HTTP methods, or when the Content-Type is not\napplication/x-www-form-urlencoded, the request Body is not read, and\nr.PostForm is initialized to a non-nil, empty value.\n\nIf the request Body's size has not already been limited by MaxBytesReader,\nthe size is capped at 10MB.\n\nParseMultipartForm calls ParseForm automatically.\nParseForm is idempotent.\n", "1.0", NewVectorFrom()),
			"ParseMultipartForm": MakeGoReceiver("ParseMultipartForm", __ptrTo_Request_ParseMultipartForm, "ParseMultipartForm parses a request body as multipart/form-data.\nThe whole request body is parsed and up to a total of maxMemory bytes of\nits file parts are stored in memory, with the remainder stored on\ndisk in temporary files.\nParseMultipartForm calls ParseForm if necessary.\nAfter one call to ParseMultipartForm, subsequent calls have no effect.\n", "1.0", NewVectorFrom(MakeSymbol("maxMemory"))),
			"PostFormValue": MakeGoReceiver("PostFormValue", __ptrTo_Request_PostFormValue, "PostFormValue returns the first value for the named component of the POST,\nPATCH, or PUT request body. URL query parameters are ignored.\nPostFormValue calls ParseMultipartForm and ParseForm if necessary and ignores\nany errors returned by these functions.\nIf key is not present, PostFormValue returns the empty string.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"ProtoAtLeast": MakeGoReceiver("ProtoAtLeast", __ptrTo_Request_ProtoAtLeast, "ProtoAtLeast reports whether the HTTP protocol used\nin the request is at least major.minor.\n", "1.0", NewVectorFrom(MakeSymbol("major"), MakeSymbol("minor"))),
			"Referer": MakeGoReceiver("Referer", __ptrTo_Request_Referer, "Referer returns the referring URL, if sent in the request.\n\nReferer is misspelled as in the request itself, a mistake from the\nearliest days of HTTP.  This value can also be fetched from the\nHeader map as Header[\"Referer\"]; the benefit of making it available\nas a method is that the compiler can diagnose programs that use the\nalternate (correct English) spelling req.Referrer() but cannot\ndiagnose programs that use Header[\"Referrer\"].\n", "1.0", NewVectorFrom()),
			"UserAgent": MakeGoReceiver("UserAgent", __ptrTo_Request_UserAgent, "UserAgent returns the client's User-Agent, if sent in the request.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
	info_Response = GoTypeInfo{Name: "go.std.net.http/Response",
		GoType: &GoType{T: &info_Response},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Response from -:
	info_PtrTo_Response = GoTypeInfo{Name: "*go.std.net.http/Response",
		GoType: &GoType{T: &info_PtrTo_Response},
		Members: GoMembers{
			"Cookies": MakeGoReceiver("Cookies", __ptrTo_Response_Cookies, "Cookies parses and returns the cookies set in the Set-Cookie headers.\n", "1.0", NewVectorFrom()),
			"Location": MakeGoReceiver("Location", __ptrTo_Response_Location, "Location returns the URL of the response's \"Location\" header,\nif present. Relative redirects are resolved relative to\nthe Response's Request. ErrNoLocation is returned if no\nLocation header is present.\n", "1.0", NewVectorFrom()),
			"ProtoAtLeast": MakeGoReceiver("ProtoAtLeast", __ptrTo_Response_ProtoAtLeast, "ProtoAtLeast reports whether the HTTP protocol used\nin the response is at least major.minor.\n", "1.0", NewVectorFrom(MakeSymbol("major"), MakeSymbol("minor"))),
		}}


GO INFO FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
	info_ResponseWriter = GoTypeInfo{Name: "go.std.net.http/ResponseWriter",
		GoType: &GoType{T: &info_ResponseWriter},
		Members: GoMembers{
			"Header": MakeGoReceiver("Header", __responseWriter_Header, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
	info_RoundTripper = GoTypeInfo{Name: "go.std.net.http/RoundTripper",
		GoType: &GoType{T: &info_RoundTripper},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
	info_SameSite = GoTypeInfo{Name: "go.std.net.http/SameSite",
		GoType: &GoType{T: &info_SameSite},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/SameSite from -:
	info_PtrTo_SameSite = GoTypeInfo{Name: "*go.std.net.http/SameSite",
		GoType: &GoType{T: &info_PtrTo_SameSite},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
	info_ServeMux = GoTypeInfo{Name: "go.std.net.http/ServeMux",
		GoType: &GoType{T: &info_ServeMux},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/ServeMux from -:
	info_PtrTo_ServeMux = GoTypeInfo{Name: "*go.std.net.http/ServeMux",
		GoType: &GoType{T: &info_PtrTo_ServeMux},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
	info_Server = GoTypeInfo{Name: "go.std.net.http/Server",
		GoType: &GoType{T: &info_Server},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Server from -:
	info_PtrTo_Server = GoTypeInfo{Name: "*go.std.net.http/Server",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __ptrTo_Server_Close, "Close immediately closes all active net.Listeners and any\nconnections in state StateNew, StateActive, or StateIdle. For a\ngraceful shutdown, use Shutdown.\n\nClose does not attempt to close (and does not even know about)\nany hijacked connections, such as WebSockets.\n\nClose returns any error returned from closing the Server's\nunderlying Listener(s).\n", "1.0", NewVectorFrom()),
			"ListenAndServe": MakeGoReceiver("ListenAndServe", __ptrTo_Server_ListenAndServe, "ListenAndServe listens on the TCP network address srv.Addr and then\ncalls Serve to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nIf srv.Addr is blank, \":http\" is used.\n\nListenAndServe always returns a non-nil error. After Shutdown or Close,\nthe returned error is ErrServerClosed.\n", "1.0", NewVectorFrom()),
			"ListenAndServeTLS": MakeGoReceiver("ListenAndServeTLS", __ptrTo_Server_ListenAndServeTLS, "ListenAndServeTLS listens on the TCP network address srv.Addr and\nthen calls ServeTLS to handle requests on incoming TLS connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nFilenames containing a certificate and matching private key for the\nserver must be provided if neither the Server's TLSConfig.Certificates\nnor TLSConfig.GetCertificate are populated. If the certificate is\nsigned by a certificate authority, the certFile should be the\nconcatenation of the server's certificate, any intermediates, and\nthe CA's certificate.\n\nIf srv.Addr is blank, \":https\" is used.\n\nListenAndServeTLS always returns a non-nil error. After Shutdown or\nClose, the returned error is ErrServerClosed.\n", "1.0", NewVectorFrom(MakeSymbol("certFile"), MakeSymbol("keyFile"))),
		}}


GO INFO FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
	info_Transport = GoTypeInfo{Name: "go.std.net.http/Transport",
		GoType: &GoType{T: &info_Transport},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http/Transport from -:
	info_PtrTo_Transport = GoTypeInfo{Name: "*go.std.net.http/Transport",
		GoType: &GoType{T: &info_PtrTo_Transport},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.http/Client from _tests/big/src/net/http/client.go:56:6:
	GoTypesVec[95] = &info_Client

GO VECSET FOR TYPE *go.std.net.http/Client from -:
	GoTypesVec[13] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.http/CloseNotifier from _tests/big/src/net/http/server.go:209:6:
	GoTypesVec[177] = &info_CloseNotifier

GO VECSET FOR TYPE go.std.net.http/ConnState from _tests/big/src/net/http/server.go:2677:6:
	GoTypesVec[96] = &info_ConnState

GO VECSET FOR TYPE *go.std.net.http/ConnState from -:
	GoTypesVec[14] = &info_PtrTo_ConnState

GO VECSET FOR TYPE go.std.net.http/Cookie from _tests/big/src/net/http/cookie.go:19:6:
	GoTypesVec[97] = &info_Cookie

GO VECSET FOR TYPE *go.std.net.http/Cookie from -:
	GoTypesVec[15] = &info_PtrTo_Cookie

GO VECSET FOR TYPE go.std.net.http/CookieJar from _tests/big/src/net/http/jar.go:17:6:
	GoTypesVec[173] = &info_CookieJar

GO VECSET FOR TYPE go.std.net.http/Dir from _tests/big/src/net/http/fs.go:40:6:
	GoTypesVec[98] = &info_Dir

GO VECSET FOR TYPE *go.std.net.http/Dir from -:
	GoTypesVec[16] = &info_PtrTo_Dir

GO VECSET FOR TYPE go.std.net.http/File from _tests/big/src/net/http/fs.go:93:6:
	GoTypesVec[174] = &info_File

GO VECSET FOR TYPE go.std.net.http/FileSystem from _tests/big/src/net/http/fs.go:85:6:
	GoTypesVec[178] = &info_FileSystem

GO VECSET FOR TYPE go.std.net.http/Flusher from _tests/big/src/net/http/server.go:166:6:
	GoTypesVec[179] = &info_Flusher

GO VECSET FOR TYPE go.std.net.http/Handler from _tests/big/src/net/http/server.go:84:6:
	GoTypesVec[180] = &info_Handler

GO VECSET FOR TYPE go.std.net.http/HandlerFunc from _tests/big/src/net/http/server.go:1960:6:
	GoTypesVec[99] = &info_HandlerFunc

GO VECSET FOR TYPE *go.std.net.http/HandlerFunc from -:
	GoTypesVec[17] = &info_PtrTo_HandlerFunc

GO VECSET FOR TYPE go.std.net.http/Header from _tests/big/src/net/http/header.go:20:6:
	GoTypesVec[100] = &info_Header

GO VECSET FOR TYPE *go.std.net.http/Header from -:
	GoTypesVec[18] = &info_PtrTo_Header

GO VECSET FOR TYPE go.std.net.http/Hijacker from _tests/big/src/net/http/server.go:178:6:
	GoTypesVec[181] = &info_Hijacker

GO VECSET FOR TYPE go.std.net.http/ProtocolError from _tests/big/src/net/http/request.go:44:6:
	GoTypesVec[101] = &info_ProtocolError

GO VECSET FOR TYPE *go.std.net.http/ProtocolError from -:
	GoTypesVec[19] = &info_PtrTo_ProtocolError

GO VECSET FOR TYPE go.std.net.http/PushOptions from _tests/big/src/net/http/http.go:105:6:
	GoTypesVec[102] = &info_PushOptions

GO VECSET FOR TYPE *go.std.net.http/PushOptions from -:
	GoTypesVec[20] = &info_PtrTo_PushOptions

GO VECSET FOR TYPE go.std.net.http/Pusher from _tests/big/src/net/http/http.go:119:6:
	GoTypesVec[182] = &info_Pusher

GO VECSET FOR TYPE go.std.net.http/Request from _tests/big/src/net/http/request.go:106:6:
	GoTypesVec[103] = &info_Request

GO VECSET FOR TYPE *go.std.net.http/Request from -:
	GoTypesVec[21] = &info_PtrTo_Request

GO VECSET FOR TYPE go.std.net.http/Response from _tests/big/src/net/http/response.go:33:6:
	GoTypesVec[104] = &info_Response

GO VECSET FOR TYPE *go.std.net.http/Response from -:
	GoTypesVec[22] = &info_PtrTo_Response

GO VECSET FOR TYPE go.std.net.http/ResponseWriter from _tests/big/src/net/http/server.go:93:6:
	GoTypesVec[168] = &info_ResponseWriter

GO VECSET FOR TYPE go.std.net.http/RoundTripper from _tests/big/src/net/http/client.go:115:6:
	GoTypesVec[183] = &info_RoundTripper

GO VECSET FOR TYPE go.std.net.http/SameSite from _tests/big/src/net/http/cookie.go:45:6:
	GoTypesVec[105] = &info_SameSite

GO VECSET FOR TYPE *go.std.net.http/SameSite from -:
	GoTypesVec[23] = &info_PtrTo_SameSite

GO VECSET FOR TYPE go.std.net.http/ServeMux from _tests/big/src/net/http/server.go:2149:6:
	GoTypesVec[106] = &info_ServeMux

GO VECSET FOR TYPE *go.std.net.http/ServeMux from -:
	GoTypesVec[24] = &info_PtrTo_ServeMux

GO VECSET FOR TYPE go.std.net.http/Server from _tests/big/src/net/http/server.go:2445:6:
	GoTypesVec[107] = &info_Server

GO VECSET FOR TYPE *go.std.net.http/Server from -:
	GoTypesVec[25] = &info_PtrTo_Server

GO VECSET FOR TYPE go.std.net.http/Transport from _tests/big/src/net/http/transport.go:103:6:
	GoTypesVec[108] = &info_Transport

GO VECSET FOR TYPE *go.std.net.http/Transport from -:
	GoTypesVec[26] = &info_PtrTo_Transport

GO ENSURE-LOADED FOR http:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/response.go:10:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/response.go:11:2
	EnsureLoaded("go.std.compress.gzip")  // E.g. from: _tests/big/src/net/http/transport.go:14:2
	EnsureLoaded("go.std.container.list")  // E.g. from: _tests/big/src/net/http/transport.go:15:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/socks_bundle.go:14:2
	EnsureLoaded("go.std.crypto.rand")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:24:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/response.go:12:2
	EnsureLoaded("go.std.encoding.base64")  // E.g. from: _tests/big/src/net/http/request.go:14:2
	EnsureLoaded("go.std.encoding.binary")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:26:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/response.go:13:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/response.go:14:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpguts")  // E.g. from: _tests/big/src/net/http/http.go:14:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpproxy")  // E.g. from: _tests/big/src/net/http/transport.go:34:2
	EnsureLoaded("go.std.golang_org.x.net.http2.hpack")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:48:2
	EnsureLoaded("go.std.golang_org.x.net.idna")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:49:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/http.go:8:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:30:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/transport.go:21:2
	EnsureLoaded("go.std.math")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:32:2
	EnsureLoaded("go.std.math.rand")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:33:11
	EnsureLoaded("go.std.mime")  // E.g. from: _tests/big/src/net/http/fs.go:13:2
	EnsureLoaded("go.std.mime.multipart")  // E.g. from: _tests/big/src/net/http/fs.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/socks_bundle.go:17:2
	EnsureLoaded("go.std.net.http.httptrace")  // E.g. from: _tests/big/src/net/http/transport.go:23:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/response.go:16:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/response.go:17:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/transport.go:26:2
	EnsureLoaded("go.std.path")  // E.g. from: _tests/big/src/net/http/fs.go:18:2
	EnsureLoaded("go.std.path.filepath")  // E.g. from: _tests/big/src/net/http/fs.go:19:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/http/transport.go:27:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:40:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/h2_bundle.go:41:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/http.go:9:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/http.go:10:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/transport.go:29:2
	EnsureLoaded("go.std.sync.atomic")  // E.g. from: _tests/big/src/net/http/transport.go:30:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/http.go:11:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/http/http.go:12:2

GO TYPE net/http/cgi.Handler from net/http/cgi/host.go:
func ExtractGoObjectHandler(args []Object, index int) *_cgi.Handler {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cgi.Handler:
			return &r
		case *_cgi.Handler:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cgi.Handler]"))
}

// func _mapToHandler(o Map) *_cgi.Handler {
// 	return &_cgi.Handler{}
// }

// func _vectorToHandler(o *Vector) *_cgi.Handler {
// 	return &_cgi.Handler{
// 		Path: AssertString(o.Nth(0), "").S,
// 		Root: AssertString(o.Nth(1), "").S,
// 		Dir: AssertString(o.Nth(2), "").S,
// 		Env: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		InheritEnv: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Logger: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Args: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 		Stderr: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		PathLocationHandler: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructHandler(_v Object) *_cgi.Handler {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cgi.Handler:
// 			return &_g
// 		case *_cgi.Handler:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToHandler(_o.(Map))
// 	case *Vector:
// 		return _vectorToHandler(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cgi.Handler] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_cgi__Handler(rcvr, arg string, args *ArraySeq, n int) (res _cgi.Handler) {
	a := CheckGoNth(rcvr, "go.std.net.http.cgi/Handler", arg, args, n).O
	res, ok := a.(_cgi.Handler)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cgi/Handler], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http/cgi.Request from net/http/cgi/child.go:
func __request() Object {
	_res1, _res2 := _cgi.Request()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cgi.RequestFromMap from net/http/cgi/child.go:
// func __requestFromMap(__params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(__params)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.Serve from net/http/cgi/child.go:
// func __serve(__handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _cgi.Serve(__handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/http/cgi.__ptrTo_Handler_ServeHTTP from net/http/cgi/host.go:
// func __ptrTo_Handler_ServeHTTP(o GoObject, args Object) Object {
// __rw ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO VARDEF FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
var info_Handler GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.cgi/Handler from -:
var info_PtrTo_Handler GoTypeInfo

GO INFO FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
	info_Handler = GoTypeInfo{Name: "go.std.net.http.cgi/Handler",
		GoType: &GoType{T: &info_Handler},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.cgi/Handler from -:
	info_PtrTo_Handler = GoTypeInfo{Name: "*go.std.net.http.cgi/Handler",
		GoType: &GoType{T: &info_PtrTo_Handler},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.http.cgi/Handler from _tests/big/src/net/http/cgi/host.go:47:6:
	GoTypesVec[82] = &info_Handler

GO VECSET FOR TYPE *go.std.net.http.cgi/Handler from -:
	GoTypesVec[0] = &info_PtrTo_Handler

GO ENSURE-LOADED FOR cgi:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/cgi/child.go:11:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/cgi/child.go:12:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/cgi/child.go:13:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/cgi/child.go:14:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/cgi/child.go:15:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/cgi/child.go:16:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/cgi/host.go:21:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/cgi/child.go:17:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/cgi/child.go:18:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/cgi/child.go:19:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/cgi/child.go:20:2
	EnsureLoaded("go.std.os.exec")  // E.g. from: _tests/big/src/net/http/cgi/host.go:25:2
	EnsureLoaded("go.std.path.filepath")  // E.g. from: _tests/big/src/net/http/cgi/host.go:26:2
	EnsureLoaded("go.std.regexp")  // E.g. from: _tests/big/src/net/http/cgi/host.go:27:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/cgi/host.go:28:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/cgi/child.go:21:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/cgi/child.go:22:2

GO TYPE net/http/cookiejar.Jar from net/http/cookiejar/jar.go:
func ExtractGoObjectJar(args []Object, index int) *_cookiejar.Jar {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Jar:
			return &r
		case *_cookiejar.Jar:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Jar]"))
}

func _mapToJar(o Map) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _vectorToJar(o *Vector) *_cookiejar.Jar {
	return &_cookiejar.Jar{}
}

func _ConstructJar(_v Object) *_cookiejar.Jar {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _cookiejar.Jar:
			return &_g
		case *_cookiejar.Jar:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToJar(_o.(Map))
	case *Vector:
		return _vectorToJar(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Jar] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_cookiejar__Jar(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.Jar) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/Jar", arg, args, n).O
	res, ok := a.(_cookiejar.Jar)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/Jar], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/cookiejar.Options from net/http/cookiejar/jar.go:
func ExtractGoObjectOptions(args []Object, index int) *_cookiejar.Options {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.Options:
			return &r
		case *_cookiejar.Options:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.Options]"))
}

// func _mapToOptions(o Map) *_cookiejar.Options {
// 	return &_cookiejar.Options{}
// }

// func _vectorToOptions(o *Vector) *_cookiejar.Options {
// 	return &_cookiejar.Options{
// 		PublicSuffixList: ABEND048(codegen.go: no conversion from Clojure for net/http/cookiejar.PublicSuffixList (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 	}
// }

// func _ConstructOptions(_v Object) *_cookiejar.Options {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.Options:
// 			return &_g
// 		case *_cookiejar.Options:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToOptions(_o.(Map))
// 	case *Vector:
// 		return _vectorToOptions(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.Options] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_cookiejar__Options(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.Options) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/Options", arg, args, n).O
	res, ok := a.(_cookiejar.Options)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/Options], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/cookiejar.PublicSuffixList from net/http/cookiejar/jar.go:
func ExtractGoObjectPublicSuffixList(args []Object, index int) *_cookiejar.PublicSuffixList {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _cookiejar.PublicSuffixList:
			return &r
		case *_cookiejar.PublicSuffixList:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/cookiejar.PublicSuffixList]"))
}

// func _ConstructPublicSuffixList(_v Object) _cookiejar.PublicSuffixList {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _cookiejar.PublicSuffixList:
// 			return _g
// 		case *_cookiejar.PublicSuffixList:
// 			return *_g
// 		}
// 	default:
// 		return _cookiejar.PublicSuffixList(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for PublicSuffixList))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[cookiejar.PublicSuffixList] or: whatever"))
// }

func ExtractGo_go_std_net_http_cookiejar__PublicSuffixList(rcvr, arg string, args *ArraySeq, n int) (res _cookiejar.PublicSuffixList) {
	a := CheckGoNth(rcvr, "go.std.net.http.cookiejar/PublicSuffixList", arg, args, n).O
	res, ok := a.(_cookiejar.PublicSuffixList)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.cookiejar/PublicSuffixList], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http/cookiejar.New from net/http/cookiejar/jar.go:
func __new(__o *_cookiejar.Options) Object {
	_res1, _res2 := _cookiejar.New(__o)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/cookiejar.__ptrTo_Jar_Cookies from net/http/cookiejar/jar.go:
// func __ptrTo_Jar_Cookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL)}

GO FUNC net/http/cookiejar.__ptrTo_Jar_SetCookies from net/http/cookiejar/jar.go:
// func __ptrTo_Jar_SetCookies(o GoObject, args Object) Object {
// __u *ABEND987(genutils.go: imports not yet supported: url.URL), __cookies []*ABEND987(genutils.go: imports not yet supported: http.Cookie)}

GO FUNC net/http/cookiejar.__publicSuffixList_PublicSuffix from net/http/cookiejar/jar.go:
func __publicSuffixList_PublicSuffix(o GoObject, args Object) Object {
	_argList := CheckGoArity("(net/http/cookiejar.PublicSuffixList)PublicSuffix()", args, 1, 1)
	__domain := ExtractGoString("(net/http/cookiejar.PublicSuffixList)PublicSuffix()", "__domain", _argList, 0)
	_res := o.O.(_cookiejar.PublicSuffixList).PublicSuffix(__domain)
	return MakeString(_res)
}

GO FUNC net/http/cookiejar.__publicSuffixList_String from net/http/cookiejar/jar.go:
func __publicSuffixList_String(o GoObject, args Object) Object {
	CheckGoArity("(net/http/cookiejar.PublicSuffixList)String()", args, 0, 0)
	_res := o.O.(_cookiejar.PublicSuffixList).String()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
var info_Jar GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.cookiejar/Jar from -:
var info_PtrTo_Jar GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
var info_Options GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.cookiejar/Options from -:
var info_PtrTo_Options GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
var info_PublicSuffixList GoTypeInfo

GO INFO FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	info_Jar = GoTypeInfo{Name: "go.std.net.http.cookiejar/Jar",
		GoType: &GoType{T: &info_Jar},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.cookiejar/Jar from -:
	info_PtrTo_Jar = GoTypeInfo{Name: "*go.std.net.http.cookiejar/Jar",
		GoType: &GoType{T: &info_PtrTo_Jar},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	info_Options = GoTypeInfo{Name: "go.std.net.http.cookiejar/Options",
		GoType: &GoType{T: &info_Options},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.cookiejar/Options from -:
	info_PtrTo_Options = GoTypeInfo{Name: "*go.std.net.http.cookiejar/Options",
		GoType: &GoType{T: &info_PtrTo_Options},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
	info_PublicSuffixList = GoTypeInfo{Name: "go.std.net.http.cookiejar/PublicSuffixList",
		GoType: &GoType{T: &info_PublicSuffixList},
		Members: GoMembers{
			"PublicSuffix": MakeGoReceiver("PublicSuffix", __publicSuffixList_PublicSuffix, "", "1.0", NewVectorFrom(MakeSymbol("domain"))),
			"String": MakeGoReceiver("String", __publicSuffixList_String, "", "1.0", NewVectorFrom()),
		}}


GO VECSET FOR TYPE go.std.net.http.cookiejar/Jar from _tests/big/src/net/http/cookiejar/jar.go:60:6:
	GoTypesVec[83] = &info_Jar

GO VECSET FOR TYPE *go.std.net.http.cookiejar/Jar from -:
	GoTypesVec[1] = &info_PtrTo_Jar

GO VECSET FOR TYPE go.std.net.http.cookiejar/Options from _tests/big/src/net/http/cookiejar/jar.go:49:6:
	GoTypesVec[84] = &info_Options

GO VECSET FOR TYPE *go.std.net.http.cookiejar/Options from -:
	GoTypesVec[2] = &info_PtrTo_Options

GO VECSET FOR TYPE go.std.net.http.cookiejar/PublicSuffixList from _tests/big/src/net/http/cookiejar/jar.go:34:6:
	GoTypesVec[171] = &info_PublicSuffixList

GO ENSURE-LOADED FOR cookiejar:
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/cookiejar/punycode.go:10:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:11:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:12:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:13:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:14:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/cookiejar/punycode.go:11:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:16:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/cookiejar/jar.go:17:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/http/cookiejar/punycode.go:12:2

GO FUNC net/http/fcgi.ProcessEnv from net/http/fcgi/child.go:
// func __processEnv(__r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	return _fcgi.ProcessEnv(__r)
// }

GO FUNC net/http/fcgi.Serve from net/http/fcgi/child.go:
// func __serve(__l ABEND987(genutils.go: imports not yet supported: net.Listener), __handler ABEND987(genutils.go: imports not yet supported: http.Handler))  {
// 	_res := _fcgi.Serve(__l, __handler)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO ENSURE-LOADED FOR fcgi:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:17:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:18:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:10:2
	EnsureLoaded("go.std.encoding.binary")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:19:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:20:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:12:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:21:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:15:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:16:2
	EnsureLoaded("go.std.net.http.cgi")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:17:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:18:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:19:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/fcgi/fcgi.go:22:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/fcgi/child.go:21:2

GO TYPE net/http/httptest.ResponseRecorder from net/http/httptest/recorder.go:
func ExtractGoObjectResponseRecorder(args []Object, index int) *_httptest.ResponseRecorder {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.ResponseRecorder:
			return &r
		case *_httptest.ResponseRecorder:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.ResponseRecorder]"))
}

// func _mapToResponseRecorder(o Map) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{}
// }

// func _vectorToResponseRecorder(o *Vector) *_httptest.ResponseRecorder {
// 	return &_httptest.ResponseRecorder{
// 		Code: AssertInt(o.Nth(0), "").I,
// 		HeaderMap: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Body: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Flushed: ToBool(o.Nth(3)),
// 	}
// }

// func _ConstructResponseRecorder(_v Object) *_httptest.ResponseRecorder {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.ResponseRecorder:
// 			return &_g
// 		case *_httptest.ResponseRecorder:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToResponseRecorder(_o.(Map))
// 	case *Vector:
// 		return _vectorToResponseRecorder(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.ResponseRecorder] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httptest__ResponseRecorder(rcvr, arg string, args *ArraySeq, n int) (res _httptest.ResponseRecorder) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptest/ResponseRecorder", arg, args, n).O
	res, ok := a.(_httptest.ResponseRecorder)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptest/ResponseRecorder], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httptest.Server from net/http/httptest/server.go:
func ExtractGoObjectServer(args []Object, index int) *_httptest.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptest.Server:
			return &r
		case *_httptest.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptest.Server]"))
}

// func _mapToServer(o Map) *_httptest.Server {
// 	return &_httptest.Server{}
// }

// func _vectorToServer(o *Vector) *_httptest.Server {
// 	return &_httptest.Server{
// 		URL: AssertString(o.Nth(0), "").S,
// 		Listener: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		TLS: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Config: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructServer(_v Object) *_httptest.Server {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptest.Server:
// 			return &_g
// 		case *_httptest.Server:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServer(_o.(Map))
// 	case *Vector:
// 		return _vectorToServer(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptest.Server] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httptest__Server(rcvr, arg string, args *ArraySeq, n int) (res _httptest.Server) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptest/Server", arg, args, n).O
	res, ok := a.(_httptest.Server)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptest/Server], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http/httptest.NewRecorder from net/http/httptest/recorder.go:
func __newRecorder() Object {
	_res := _httptest.NewRecorder()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.NewRequest from net/http/httptest/httptest.go:
// func __newRequest(__method string, __target string, __body ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	_res := _httptest.NewRequest(__method, __target, __body)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewServer from net/http/httptest/server.go:
// func __newServer(__handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewServer(__handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewTLSServer from net/http/httptest/server.go:
// func __newTLSServer(__handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewTLSServer(__handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.NewUnstartedServer from net/http/httptest/server.go:
// func __newUnstartedServer(__handler ABEND987(genutils.go: imports not yet supported: http.Handler)) Object {
// 	_res := _httptest.NewUnstartedServer(__handler)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Flush from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_Flush(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Header from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_Header(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.ResponseRecorder)Header()", args, 0, 0)
	_res := o.O.(*_httptest.ResponseRecorder).Header()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Result from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_Result(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.ResponseRecorder)Result()", args, 0, 0)
	_res := o.O.(*_httptest.ResponseRecorder).Result()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_Write from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_Write(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__buf)))}

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_WriteHeader from net/http/httptest/recorder.go:
// func __ptrTo_ResponseRecorder_WriteHeader(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_ResponseRecorder_WriteString from net/http/httptest/recorder.go:
func __ptrTo_ResponseRecorder_WriteString(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/http/httptest.ResponseRecorder)WriteString()", args, 1, 1)
	__str := ExtractGoString("(*_net/http/httptest.ResponseRecorder)WriteString()", "__str", _argList, 0)
	_res1, _res2 := o.O.(*_httptest.ResponseRecorder).WriteString(__str)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httptest.__ptrTo_Server_Certificate from net/http/httptest/server.go:
// func __ptrTo_Server_Certificate(o GoObject, args Object) Object {
// (atom-of ABEND042(post.go: cannot find typename crypto/x509.Certificate))}

GO FUNC net/http/httptest.__ptrTo_Server_Client from net/http/httptest/server.go:
func __ptrTo_Server_Client(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httptest.Server)Client()", args, 0, 0)
	_res := o.O.(*_httptest.Server).Client()
	return MakeGoObject(_res)
}

GO FUNC net/http/httptest.__ptrTo_Server_Close from net/http/httptest/server.go:
// func __ptrTo_Server_Close(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_CloseClientConnections from net/http/httptest/server.go:
// func __ptrTo_Server_CloseClientConnections(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_Start from net/http/httptest/server.go:
// func __ptrTo_Server_Start(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/http/httptest.__ptrTo_Server_StartTLS from net/http/httptest/server.go:
// func __ptrTo_Server_StartTLS(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
var info_ResponseRecorder GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptest/ResponseRecorder from -:
var info_PtrTo_ResponseRecorder GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptest/Server from -:
var info_PtrTo_Server GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	info_ResponseRecorder = GoTypeInfo{Name: "go.std.net.http.httptest/ResponseRecorder",
		GoType: &GoType{T: &info_ResponseRecorder},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptest/ResponseRecorder from -:
	info_PtrTo_ResponseRecorder = GoTypeInfo{Name: "*go.std.net.http.httptest/ResponseRecorder",
		GoType: &GoType{T: &info_PtrTo_ResponseRecorder},
		Members: GoMembers{
			"Header": MakeGoReceiver("Header", __ptrTo_ResponseRecorder_Header, "Header returns the response headers.\n", "1.0", NewVectorFrom()),
			"Result": MakeGoReceiver("Result", __ptrTo_ResponseRecorder_Result, "Result returns the response generated by the handler.\n\nThe returned Response will have at least its StatusCode,\nHeader, Body, and optionally Trailer populated.\nMore fields may be populated in the future, so callers should\nnot DeepEqual the result in tests.\n\nThe Response.Header is a snapshot of the headers at the time of the\nfirst write call, or at the time of this call, if the handler never\ndid a write.\n\nThe Response.Body is guaranteed to be non-nil and Body.Read call is\nguaranteed to not return any error other than io.EOF.\n\nResult must only be called after the handler has finished running.\n", "1.0", NewVectorFrom()),
			"WriteString": MakeGoReceiver("WriteString", __ptrTo_ResponseRecorder_WriteString, "WriteString always succeeds and writes to rw.Body, if not nil.\n", "1.0", NewVectorFrom(MakeSymbol("str"))),
		}}


GO INFO FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
	info_Server = GoTypeInfo{Name: "go.std.net.http.httptest/Server",
		GoType: &GoType{T: &info_Server},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptest/Server from -:
	info_PtrTo_Server = GoTypeInfo{Name: "*go.std.net.http.httptest/Server",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"Client": MakeGoReceiver("Client", __ptrTo_Server_Client, "Client returns an HTTP client configured for making requests to the server.\nIt is configured to trust the server's TLS test certificate and will\nclose its idle connections on Server.Close.\n", "1.0", NewVectorFrom()),
		}}


GO VECSET FOR TYPE go.std.net.http.httptest/ResponseRecorder from _tests/big/src/net/http/httptest/recorder.go:20:6:
	GoTypesVec[85] = &info_ResponseRecorder

GO VECSET FOR TYPE *go.std.net.http.httptest/ResponseRecorder from -:
	GoTypesVec[3] = &info_PtrTo_ResponseRecorder

GO VECSET FOR TYPE go.std.net.http.httptest/Server from _tests/big/src/net/http/httptest/server.go:26:6:
	GoTypesVec[86] = &info_Server

GO VECSET FOR TYPE *go.std.net.http.httptest/Server from -:
	GoTypesVec[4] = &info_PtrTo_Server

GO ENSURE-LOADED FOR httptest:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:9:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:10:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:11:2
	EnsureLoaded("go.std.crypto.x509")  // E.g. from: _tests/big/src/net/http/httptest/server.go:11:2
	EnsureLoaded("go.std.flag")  // E.g. from: _tests/big/src/net/http/httptest/server.go:12:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/httptest/server.go:13:2
	EnsureLoaded("go.std.golang_org.x.net.http.httpguts")  // E.g. from: _tests/big/src/net/http/httptest/recorder.go:15:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:12:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:13:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/httptest/server.go:14:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httptest/server.go:15:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:14:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/httptest/server.go:18:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/httptest/recorder.go:12:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/httptest/httptest.go:15:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/httptest/server.go:20:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httptest/server.go:21:2

GO TYPE net/http/httptrace.ClientTrace from net/http/httptrace/trace.go:
func ExtractGoObjectClientTrace(args []Object, index int) *_httptrace.ClientTrace {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptrace.ClientTrace:
			return &r
		case *_httptrace.ClientTrace:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.ClientTrace]"))
}

// func _mapToClientTrace(o Map) *_httptrace.ClientTrace {
// 	return &_httptrace.ClientTrace{}
// }

// func _vectorToClientTrace(o *Vector) *_httptrace.ClientTrace {
// 	return &_httptrace.ClientTrace{
// 		GetConn: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		GotConn: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		PutIdleConn: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		GotFirstResponseByte: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Got100Continue: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Got1xxResponse: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DNSStart: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		DNSDone: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ConnectStart: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ConnectDone: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSHandshakeStart: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		TLSHandshakeDone: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		WroteHeaderField: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		WroteHeaders: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Wait100Continue: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		WroteRequest: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructClientTrace(_v Object) *_httptrace.ClientTrace {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptrace.ClientTrace:
// 			return &_g
// 		case *_httptrace.ClientTrace:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClientTrace(_o.(Map))
// 	case *Vector:
// 		return _vectorToClientTrace(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.ClientTrace] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httptrace__ClientTrace(rcvr, arg string, args *ArraySeq, n int) (res _httptrace.ClientTrace) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptrace/ClientTrace", arg, args, n).O
	res, ok := a.(_httptrace.ClientTrace)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptrace/ClientTrace], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httptrace.DNSDoneInfo from net/http/httptrace/trace.go:
func ExtractGoObjectDNSDoneInfo(args []Object, index int) *_httptrace.DNSDoneInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptrace.DNSDoneInfo:
			return &r
		case *_httptrace.DNSDoneInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.DNSDoneInfo]"))
}

// func _mapToDNSDoneInfo(o Map) *_httptrace.DNSDoneInfo {
// 	return &_httptrace.DNSDoneInfo{}
// }

// func _vectorToDNSDoneInfo(o *Vector) *_httptrace.DNSDoneInfo {
// 	return &_httptrace.DNSDoneInfo{
// 		Addrs: []ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Err: _errors.New(AssertString(o.Nth(1), "").S),
// 		Coalesced: ToBool(o.Nth(2)),
// 	}
// }

// func _ConstructDNSDoneInfo(_v Object) *_httptrace.DNSDoneInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptrace.DNSDoneInfo:
// 			return &_g
// 		case *_httptrace.DNSDoneInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToDNSDoneInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToDNSDoneInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.DNSDoneInfo] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httptrace__DNSDoneInfo(rcvr, arg string, args *ArraySeq, n int) (res _httptrace.DNSDoneInfo) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptrace/DNSDoneInfo", arg, args, n).O
	res, ok := a.(_httptrace.DNSDoneInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptrace/DNSDoneInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httptrace.DNSStartInfo from net/http/httptrace/trace.go:
func ExtractGoObjectDNSStartInfo(args []Object, index int) *_httptrace.DNSStartInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptrace.DNSStartInfo:
			return &r
		case *_httptrace.DNSStartInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.DNSStartInfo]"))
}

func _mapToDNSStartInfo(o Map) *_httptrace.DNSStartInfo {
	return &_httptrace.DNSStartInfo{}
}

func _vectorToDNSStartInfo(o *Vector) *_httptrace.DNSStartInfo {
	return &_httptrace.DNSStartInfo{
		Host: AssertString(o.Nth(0), "").S,
	}
}

func _ConstructDNSStartInfo(_v Object) *_httptrace.DNSStartInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httptrace.DNSStartInfo:
			return &_g
		case *_httptrace.DNSStartInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToDNSStartInfo(_o.(Map))
	case *Vector:
		return _vectorToDNSStartInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.DNSStartInfo] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httptrace__DNSStartInfo(rcvr, arg string, args *ArraySeq, n int) (res _httptrace.DNSStartInfo) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptrace/DNSStartInfo", arg, args, n).O
	res, ok := a.(_httptrace.DNSStartInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptrace/DNSStartInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httptrace.GotConnInfo from net/http/httptrace/trace.go:
func ExtractGoObjectGotConnInfo(args []Object, index int) *_httptrace.GotConnInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptrace.GotConnInfo:
			return &r
		case *_httptrace.GotConnInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.GotConnInfo]"))
}

// func _mapToGotConnInfo(o Map) *_httptrace.GotConnInfo {
// 	return &_httptrace.GotConnInfo{}
// }

// func _vectorToGotConnInfo(o *Vector) *_httptrace.GotConnInfo {
// 	return &_httptrace.GotConnInfo{
// 		Conn: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		Reused: ToBool(o.Nth(1)),
// 		WasIdle: ToBool(o.Nth(2)),
// 		IdleTime: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructGotConnInfo(_v Object) *_httptrace.GotConnInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httptrace.GotConnInfo:
// 			return &_g
// 		case *_httptrace.GotConnInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToGotConnInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToGotConnInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.GotConnInfo] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httptrace__GotConnInfo(rcvr, arg string, args *ArraySeq, n int) (res _httptrace.GotConnInfo) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptrace/GotConnInfo", arg, args, n).O
	res, ok := a.(_httptrace.GotConnInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptrace/GotConnInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httptrace.WroteRequestInfo from net/http/httptrace/trace.go:
func ExtractGoObjectWroteRequestInfo(args []Object, index int) *_httptrace.WroteRequestInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httptrace.WroteRequestInfo:
			return &r
		case *_httptrace.WroteRequestInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httptrace.WroteRequestInfo]"))
}

func _mapToWroteRequestInfo(o Map) *_httptrace.WroteRequestInfo {
	return &_httptrace.WroteRequestInfo{}
}

func _vectorToWroteRequestInfo(o *Vector) *_httptrace.WroteRequestInfo {
	return &_httptrace.WroteRequestInfo{
		Err: _errors.New(AssertString(o.Nth(0), "").S),
	}
}

func _ConstructWroteRequestInfo(_v Object) *_httptrace.WroteRequestInfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httptrace.WroteRequestInfo:
			return &_g
		case *_httptrace.WroteRequestInfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToWroteRequestInfo(_o.(Map))
	case *Vector:
		return _vectorToWroteRequestInfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httptrace.WroteRequestInfo] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httptrace__WroteRequestInfo(rcvr, arg string, args *ArraySeq, n int) (res _httptrace.WroteRequestInfo) {
	a := CheckGoNth(rcvr, "go.std.net.http.httptrace/WroteRequestInfo", arg, args, n).O
	res, ok := a.(_httptrace.WroteRequestInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httptrace/WroteRequestInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http/httptrace.ContextClientTrace from net/http/httptrace/trace.go:
// func __contextClientTrace(__ctx ABEND987(genutils.go: imports not yet supported: context.Context)) Object {
// 	_res := _httptrace.ContextClientTrace(__ctx)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httptrace.WithClientTrace from net/http/httptrace/trace.go:
// func __withClientTrace(__ctx ABEND987(genutils.go: imports not yet supported: context.Context), __trace *_httptrace.ClientTrace) Object {
// 	return _httptrace.WithClientTrace(__ctx, __trace)
// }

GO VARDEF FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
var info_ClientTrace GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptrace/ClientTrace from -:
var info_PtrTo_ClientTrace GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
var info_DNSDoneInfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptrace/DNSDoneInfo from -:
var info_PtrTo_DNSDoneInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
var info_DNSStartInfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptrace/DNSStartInfo from -:
var info_PtrTo_DNSStartInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
var info_GotConnInfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptrace/GotConnInfo from -:
var info_PtrTo_GotConnInfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
var info_WroteRequestInfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httptrace/WroteRequestInfo from -:
var info_PtrTo_WroteRequestInfo GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	info_ClientTrace = GoTypeInfo{Name: "go.std.net.http.httptrace/ClientTrace",
		GoType: &GoType{T: &info_ClientTrace},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptrace/ClientTrace from -:
	info_PtrTo_ClientTrace = GoTypeInfo{Name: "*go.std.net.http.httptrace/ClientTrace",
		GoType: &GoType{T: &info_PtrTo_ClientTrace},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	info_DNSDoneInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/DNSDoneInfo",
		GoType: &GoType{T: &info_DNSDoneInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptrace/DNSDoneInfo from -:
	info_PtrTo_DNSDoneInfo = GoTypeInfo{Name: "*go.std.net.http.httptrace/DNSDoneInfo",
		GoType: &GoType{T: &info_PtrTo_DNSDoneInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	info_DNSStartInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/DNSStartInfo",
		GoType: &GoType{T: &info_DNSStartInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptrace/DNSStartInfo from -:
	info_PtrTo_DNSStartInfo = GoTypeInfo{Name: "*go.std.net.http.httptrace/DNSStartInfo",
		GoType: &GoType{T: &info_PtrTo_DNSStartInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	info_GotConnInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/GotConnInfo",
		GoType: &GoType{T: &info_GotConnInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptrace/GotConnInfo from -:
	info_PtrTo_GotConnInfo = GoTypeInfo{Name: "*go.std.net.http.httptrace/GotConnInfo",
		GoType: &GoType{T: &info_PtrTo_GotConnInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	info_WroteRequestInfo = GoTypeInfo{Name: "go.std.net.http.httptrace/WroteRequestInfo",
		GoType: &GoType{T: &info_WroteRequestInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httptrace/WroteRequestInfo from -:
	info_PtrTo_WroteRequestInfo = GoTypeInfo{Name: "*go.std.net.http.httptrace/WroteRequestInfo",
		GoType: &GoType{T: &info_PtrTo_WroteRequestInfo},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.http.httptrace/ClientTrace from _tests/big/src/net/http/httptrace/trace.go:80:6:
	GoTypesVec[87] = &info_ClientTrace

GO VECSET FOR TYPE *go.std.net.http.httptrace/ClientTrace from -:
	GoTypesVec[5] = &info_PtrTo_ClientTrace

GO VECSET FOR TYPE go.std.net.http.httptrace/DNSDoneInfo from _tests/big/src/net/http/httptrace/trace.go:216:6:
	GoTypesVec[88] = &info_DNSDoneInfo

GO VECSET FOR TYPE *go.std.net.http.httptrace/DNSDoneInfo from -:
	GoTypesVec[6] = &info_PtrTo_DNSDoneInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/DNSStartInfo from _tests/big/src/net/http/httptrace/trace.go:211:6:
	GoTypesVec[89] = &info_DNSStartInfo

GO VECSET FOR TYPE *go.std.net.http.httptrace/DNSStartInfo from -:
	GoTypesVec[7] = &info_PtrTo_DNSStartInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/GotConnInfo from _tests/big/src/net/http/httptrace/trace.go:238:6:
	GoTypesVec[90] = &info_GotConnInfo

GO VECSET FOR TYPE *go.std.net.http.httptrace/GotConnInfo from -:
	GoTypesVec[8] = &info_PtrTo_GotConnInfo

GO VECSET FOR TYPE go.std.net.http.httptrace/WroteRequestInfo from _tests/big/src/net/http/httptrace/trace.go:168:6:
	GoTypesVec[91] = &info_WroteRequestInfo

GO VECSET FOR TYPE *go.std.net.http.httptrace/WroteRequestInfo from -:
	GoTypesVec[9] = &info_PtrTo_WroteRequestInfo

GO ENSURE-LOADED FOR httptrace:
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:10:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:11:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:13:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:14:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:15:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httptrace/trace.go:16:2

GO TYPE net/http/httputil.BufferPool from net/http/httputil/reverseproxy.go:
func ExtractGoObjectBufferPool(args []Object, index int) *_httputil.BufferPool {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.BufferPool:
			return &r
		case *_httputil.BufferPool:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.BufferPool]"))
}

// func _ConstructBufferPool(_v Object) _httputil.BufferPool {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.BufferPool:
// 			return _g
// 		case *_httputil.BufferPool:
// 			return *_g
// 		}
// 	default:
// 		return _httputil.BufferPool(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for BufferPool))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.BufferPool] or: whatever"))
// }

func ExtractGo_go_std_net_http_httputil__BufferPool(rcvr, arg string, args *ArraySeq, n int) (res _httputil.BufferPool) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/BufferPool", arg, args, n).O
	res, ok := a.(_httputil.BufferPool)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/BufferPool], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httputil.ClientConn from net/http/httputil/persist.go:
func ExtractGoObjectClientConn(args []Object, index int) *_httputil.ClientConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ClientConn:
			return &r
		case *_httputil.ClientConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ClientConn]"))
}

func _mapToClientConn(o Map) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _vectorToClientConn(o *Vector) *_httputil.ClientConn {
	return &_httputil.ClientConn{}
}

func _ConstructClientConn(_v Object) *_httputil.ClientConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ClientConn:
			return &_g
		case *_httputil.ClientConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClientConn(_o.(Map))
	case *Vector:
		return _vectorToClientConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ClientConn] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httputil__ClientConn(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ClientConn) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ClientConn", arg, args, n).O
	res, ok := a.(_httputil.ClientConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ClientConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httputil.ReverseProxy from net/http/httputil/reverseproxy.go:
func ExtractGoObjectReverseProxy(args []Object, index int) *_httputil.ReverseProxy {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ReverseProxy:
			return &r
		case *_httputil.ReverseProxy:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ReverseProxy]"))
}

// func _mapToReverseProxy(o Map) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{}
// }

// func _vectorToReverseProxy(o *Vector) *_httputil.ReverseProxy {
// 	return &_httputil.ReverseProxy{
// 		Director: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		Transport: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		FlushInterval: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		ErrorLog: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 		BufferPool: ABEND048(codegen.go: no conversion from Clojure for net/http/httputil.BufferPool (ABEND047(gotypes.go: unsupported type *ast.InterfaceType))),
// 		ModifyResponse: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 		ErrorHandler: ABEND047(gotypes.go: unsupported type *ast.FuncType),
// 	}
// }

// func _ConstructReverseProxy(_v Object) *_httputil.ReverseProxy {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _httputil.ReverseProxy:
// 			return &_g
// 		case *_httputil.ReverseProxy:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReverseProxy(_o.(Map))
// 	case *Vector:
// 		return _vectorToReverseProxy(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ReverseProxy] or: Map or Vector"))
// }

func ExtractGo_go_std_net_http_httputil__ReverseProxy(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ReverseProxy) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ReverseProxy", arg, args, n).O
	res, ok := a.(_httputil.ReverseProxy)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ReverseProxy], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/http/httputil.ServerConn from net/http/httputil/persist.go:
func ExtractGoObjectServerConn(args []Object, index int) *_httputil.ServerConn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _httputil.ServerConn:
			return &r
		case *_httputil.ServerConn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/http/httputil.ServerConn]"))
}

func _mapToServerConn(o Map) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _vectorToServerConn(o *Vector) *_httputil.ServerConn {
	return &_httputil.ServerConn{}
}

func _ConstructServerConn(_v Object) *_httputil.ServerConn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _httputil.ServerConn:
			return &_g
		case *_httputil.ServerConn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServerConn(_o.(Map))
	case *Vector:
		return _vectorToServerConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[httputil.ServerConn] or: Map or Vector"))
}

func ExtractGo_go_std_net_http_httputil__ServerConn(rcvr, arg string, args *ArraySeq, n int) (res _httputil.ServerConn) {
	a := CheckGoNth(rcvr, "go.std.net.http.httputil/ServerConn", arg, args, n).O
	res, ok := a.(_httputil.ServerConn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.http.httputil/ServerConn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/http/httputil.DumpRequest from net/http/httputil/dump.go:
// func __dumpRequest(__req *ABEND987(genutils.go: imports not yet supported: http.Request), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(__req, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut from net/http/httputil/dump.go:
// func __dumpRequestOut(__req *ABEND987(genutils.go: imports not yet supported: http.Request), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(__req, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse from net/http/httputil/dump.go:
// func __dumpResponse(__resp *ABEND987(genutils.go: imports not yet supported: http.Response), __body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(__resp, __body)
// 	_res := EmptyVector()
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader from net/http/httputil/httputil.go:
// func __newChunkedReader(__r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	return _httputil.NewChunkedReader(__r)
// }

GO FUNC net/http/httputil.NewChunkedWriter from net/http/httputil/httputil.go:
// func __newChunkedWriter(__w ABEND987(genutils.go: imports not yet supported: io.Writer)) Object {
// 	return _httputil.NewChunkedWriter(__w)
// }

GO FUNC net/http/httputil.NewClientConn from net/http/httputil/persist.go:
// func __newClientConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewClientConn(__c, __r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewProxyClientConn from net/http/httputil/persist.go:
// func __newProxyClientConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewProxyClientConn(__c, __r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewServerConn from net/http/httputil/persist.go:
// func __newServerConn(__c ABEND987(genutils.go: imports not yet supported: net.Conn), __r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _httputil.NewServerConn(__c, __r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy from net/http/httputil/reverseproxy.go:
// func __newSingleHostReverseProxy(__target *ABEND987(genutils.go: imports not yet supported: url.URL)) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(__target)
// 	return MakeGoObject(_res)
// }

GO FUNC net/http/httputil.__bufferPool_Get from net/http/httputil/reverseproxy.go:
func __bufferPool_Get(o GoObject, args Object) Object {
	CheckGoArity("(net/http/httputil.BufferPool)Get()", args, 0, 0)
	_res := o.O.(_httputil.BufferPool).Get()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net/http/httputil.__bufferPool_Put from net/http/httputil/reverseproxy.go:
// func __bufferPool_Put(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__arg1)))}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Close from net/http/httputil/persist.go:
func __ptrTo_ClientConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Do from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Do(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Hijack from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Hijack(o GoObject, args Object) Object {
// [go.std.net/Conn (atom-of ABEND042(post.go: cannot find typename bufio.Reader))]}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Pending from net/http/httputil/persist.go:
func __ptrTo_ClientConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ClientConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ClientConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Read from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Read(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ClientConn_Write from net/http/httputil/persist.go:
// func __ptrTo_ClientConn_Write(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ReverseProxy_ServeHTTP from net/http/httputil/reverseproxy.go:
// func __ptrTo_ReverseProxy_ServeHTTP(o GoObject, args Object) Object {
// __rw ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Close from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Close()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Hijack from net/http/httputil/persist.go:
// func __ptrTo_ServerConn_Hijack(o GoObject, args Object) Object {
// [go.std.net/Conn (atom-of ABEND042(post.go: cannot find typename bufio.Reader))]}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Pending from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Pending(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Pending()", args, 0, 0)
	_res := o.O.(*_httputil.ServerConn).Pending()
	return MakeInt(_res)
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Read from net/http/httputil/persist.go:
func __ptrTo_ServerConn_Read(o GoObject, args Object) Object {
	CheckGoArity("(*_net/http/httputil.ServerConn)Read()", args, 0, 0)
	_res1, _res2 := o.O.(*_httputil.ServerConn).Read()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/http/httputil.__ptrTo_ServerConn_Write from net/http/httputil/persist.go:
// func __ptrTo_ServerConn_Write(o GoObject, args Object) Object {
// __req *ABEND987(genutils.go: imports not yet supported: http.Request), __resp *ABEND987(genutils.go: imports not yet supported: http.Response)}

GO VARDEF FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
var info_BufferPool GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
var info_ClientConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httputil/ClientConn from -:
var info_PtrTo_ClientConn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
var info_ReverseProxy GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httputil/ReverseProxy from -:
var info_PtrTo_ReverseProxy GoTypeInfo

GO VARDEF FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
var info_ServerConn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.http.httputil/ServerConn from -:
var info_PtrTo_ServerConn GoTypeInfo

GO INFO FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
	info_BufferPool = GoTypeInfo{Name: "go.std.net.http.httputil/BufferPool",
		GoType: &GoType{T: &info_BufferPool},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", __bufferPool_Get, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	info_ClientConn = GoTypeInfo{Name: "go.std.net.http.httputil/ClientConn",
		GoType: &GoType{T: &info_ClientConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httputil/ClientConn from -:
	info_PtrTo_ClientConn = GoTypeInfo{Name: "*go.std.net.http.httputil/ClientConn",
		GoType: &GoType{T: &info_PtrTo_ClientConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __ptrTo_ClientConn_Close, "Close calls Hijack and then also closes the underlying connection.\n", "1.0", NewVectorFrom()),
			"Pending": MakeGoReceiver("Pending", __ptrTo_ClientConn_Pending, "Pending returns the number of unanswered requests\nthat have been sent on the connection.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	info_ReverseProxy = GoTypeInfo{Name: "go.std.net.http.httputil/ReverseProxy",
		GoType: &GoType{T: &info_ReverseProxy},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httputil/ReverseProxy from -:
	info_PtrTo_ReverseProxy = GoTypeInfo{Name: "*go.std.net.http.httputil/ReverseProxy",
		GoType: &GoType{T: &info_PtrTo_ReverseProxy},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	info_ServerConn = GoTypeInfo{Name: "go.std.net.http.httputil/ServerConn",
		GoType: &GoType{T: &info_ServerConn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.http.httputil/ServerConn from -:
	info_PtrTo_ServerConn = GoTypeInfo{Name: "*go.std.net.http.httputil/ServerConn",
		GoType: &GoType{T: &info_PtrTo_ServerConn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __ptrTo_ServerConn_Close, "Close calls Hijack and then also closes the underlying connection.\n", "1.0", NewVectorFrom()),
			"Pending": MakeGoReceiver("Pending", __ptrTo_ServerConn_Pending, "Pending returns the number of unanswered requests\nthat have been received on the connection.\n", "1.0", NewVectorFrom()),
			"Read": MakeGoReceiver("Read", __ptrTo_ServerConn_Read, "Read returns the next request on the wire. An ErrPersistEOF is returned if\nit is gracefully determined that there are no more requests (e.g. after the\nfirst request on an HTTP/1.0 connection, or after a Connection:close on a\nHTTP/1.1 connection).\n", "1.0", NewVectorFrom()),
		}}


GO VECSET FOR TYPE go.std.net.http.httputil/BufferPool from _tests/big/src/net/http/httputil/reverseproxy.go:79:6:
	GoTypesVec[172] = &info_BufferPool

GO VECSET FOR TYPE go.std.net.http.httputil/ClientConn from _tests/big/src/net/http/httputil/persist.go:230:6:
	GoTypesVec[92] = &info_ClientConn

GO VECSET FOR TYPE *go.std.net.http.httputil/ClientConn from -:
	GoTypesVec[10] = &info_PtrTo_ClientConn

GO VECSET FOR TYPE go.std.net.http.httputil/ReverseProxy from _tests/big/src/net/http/httputil/reverseproxy.go:28:6:
	GoTypesVec[93] = &info_ReverseProxy

GO VECSET FOR TYPE *go.std.net.http.httputil/ReverseProxy from -:
	GoTypesVec[11] = &info_PtrTo_ReverseProxy

GO VECSET FOR TYPE go.std.net.http.httputil/ServerConn from _tests/big/src/net/http/httputil/persist.go:37:6:
	GoTypesVec[94] = &info_ServerConn

GO VECSET FOR TYPE *go.std.net.http.httputil/ServerConn from -:
	GoTypesVec[12] = &info_PtrTo_ServerConn

GO ENSURE-LOADED FOR httputil:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:8:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:9:2
	EnsureLoaded("go.std.context")  // E.g. from: _tests/big/src/net/http/httputil/reverseproxy.go:10:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:10:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:11:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:12:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:13:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/httputil/reverseproxy.go:12:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:14:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:15:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/http/httputil/persist.go:13:2
	EnsureLoaded("go.std.net.url")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:16:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:17:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/http/httputil/reverseproxy.go:17:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/httputil/dump.go:18:2

GO FUNC net/http/pprof.Cmdline from net/http/pprof/pprof.go:
// func __cmdline(__w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Cmdline(__w, __r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler from net/http/pprof/pprof.go:
func __handler(__name string) Object {
	_res := _pprof.Handler(__name)
	return MakeGoObject(_res)
}

GO FUNC net/http/pprof.Index from net/http/pprof/pprof.go:
// func __index(__w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Index(__w, __r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile from net/http/pprof/pprof.go:
// func __profile(__w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Profile(__w, __r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol from net/http/pprof/pprof.go:
// func __symbol(__w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Symbol(__w, __r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace from net/http/pprof/pprof.go:
// func __trace(__w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __r *ABEND987(genutils.go: imports not yet supported: http.Request)) Object {
// 	_pprof.Trace(__w, __r)
// 	...ABEND675: TODO...
// }

GO ENSURE-LOADED FOR pprof:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:55:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:56:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:57:2
	EnsureLoaded("go.std.html.template")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:58:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:59:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:60:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:61:2
	EnsureLoaded("go.std.os")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:62:2
	EnsureLoaded("go.std.runtime")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:63:2
	EnsureLoaded("go.std.runtime.pprof")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:64:2
	EnsureLoaded("go.std.runtime.trace")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:65:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:66:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:67:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:68:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/http/pprof/pprof.go:69:2

GO TYPE net/mail.Address from net/mail/message.go:
func ExtractGoObjectAddress(args []Object, index int) *_mail.Address {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Address:
			return &r
		case *_mail.Address:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Address]"))
}

func _mapToAddress(o Map) *_mail.Address {
	return &_mail.Address{}
}

func _vectorToAddress(o *Vector) *_mail.Address {
	return &_mail.Address{
		Name: AssertString(o.Nth(0), "").S,
		Address: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructAddress(_v Object) *_mail.Address {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _mail.Address:
			return &_g
		case *_mail.Address:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToAddress(_o.(Map))
	case *Vector:
		return _vectorToAddress(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Address] or: Map or Vector"))
}

func ExtractGo_go_std_net_mail__Address(rcvr, arg string, args *ArraySeq, n int) (res _mail.Address) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Address", arg, args, n).O
	res, ok := a.(_mail.Address)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Address], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/mail.AddressParser from net/mail/message.go:
func ExtractGoObjectAddressParser(args []Object, index int) *_mail.AddressParser {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.AddressParser:
			return &r
		case *_mail.AddressParser:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.AddressParser]"))
}

// func _mapToAddressParser(o Map) *_mail.AddressParser {
// 	return &_mail.AddressParser{}
// }

// func _vectorToAddressParser(o *Vector) *_mail.AddressParser {
// 	return &_mail.AddressParser{
// 		WordDecoder: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructAddressParser(_v Object) *_mail.AddressParser {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.AddressParser:
// 			return &_g
// 		case *_mail.AddressParser:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToAddressParser(_o.(Map))
// 	case *Vector:
// 		return _vectorToAddressParser(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.AddressParser] or: Map or Vector"))
// }

func ExtractGo_go_std_net_mail__AddressParser(rcvr, arg string, args *ArraySeq, n int) (res _mail.AddressParser) {
	a := CheckGoNth(rcvr, "go.std.net.mail/AddressParser", arg, args, n).O
	res, ok := a.(_mail.AddressParser)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/AddressParser], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/mail.Header from net/mail/message.go:
func ExtractGoObjectHeader(args []Object, index int) *_mail.Header {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Header:
			return &r
		case *_mail.Header:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Header]"))
}

// func _ConstructHeader(_v Object) _mail.Header {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Header:
// 			return _g
// 		case *_mail.Header:
// 			return *_g
// 		}
// 	default:
// 		return _mail.Header(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Header))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Header] or: whatever"))
// }

func ExtractGo_go_std_net_mail__Header(rcvr, arg string, args *ArraySeq, n int) (res _mail.Header) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Header", arg, args, n).O
	res, ok := a.(_mail.Header)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Header], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/mail.Message from net/mail/message.go:
func ExtractGoObjectMessage(args []Object, index int) *_mail.Message {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _mail.Message:
			return &r
		case *_mail.Message:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/mail.Message]"))
}

// func _mapToMessage(o Map) *_mail.Message {
// 	return &_mail.Message{}
// }

// func _vectorToMessage(o *Vector) *_mail.Message {
// 	return &_mail.Message{
// 		Header: ABEND048(codegen.go: no conversion from Clojure for net/mail.Header (ABEND047(gotypes.go: unsupported type *ast.MapType))),
// 		Body: ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructMessage(_v Object) *_mail.Message {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _mail.Message:
// 			return &_g
// 		case *_mail.Message:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToMessage(_o.(Map))
// 	case *Vector:
// 		return _vectorToMessage(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[mail.Message] or: Map or Vector"))
// }

func ExtractGo_go_std_net_mail__Message(rcvr, arg string, args *ArraySeq, n int) (res _mail.Message) {
	a := CheckGoNth(rcvr, "go.std.net.mail/Message", arg, args, n).O
	res, ok := a.(_mail.Message)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.mail/Message], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/mail.ParseAddress from net/mail/message.go:
func __parseAddress(__address string) Object {
	_res1, _res2 := _mail.ParseAddress(__address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList from net/mail/message.go:
func __parseAddressList(__list string) Object {
	_res1, _res2 := _mail.ParseAddressList(__list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate from net/mail/message.go:
// func __parseDate(__date string) Object {
// 	_res1, _res2 := _mail.ParseDate(__date)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/mail.ReadMessage from net/mail/message.go:
// func __readMessage(__r ABEND987(genutils.go: imports not yet supported: io.Reader)) Object {
// 	msg, err := _mail.ReadMessage(__r)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(msg))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/mail.__header_AddressList from net/mail/message.go:
func __header_AddressList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)AddressList()", args, 1, 1)
	__key := ExtractGoString("(_net/mail.Header)AddressList()", "__key", _argList, 0)
	_res1, _res2 := o.O.(_mail.Header).AddressList(__key)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__header_Date from net/mail/message.go:
// func __header_Date(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename time.Time) Error]}

GO FUNC net/mail.__header_Get from net/mail/message.go:
func __header_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/mail.Header)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/mail.Header)Get()", "__key", _argList, 0)
	_res := o.O.(_mail.Header).Get(__key)
	return MakeString(_res)
}

GO FUNC net/mail.__ptrTo_AddressParser_Parse from net/mail/message.go:
func __ptrTo_AddressParser_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)Parse()", args, 1, 1)
	__address := ExtractGoString("(*_net/mail.AddressParser)Parse()", "__address", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).Parse(__address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__ptrTo_AddressParser_ParseList from net/mail/message.go:
func __ptrTo_AddressParser_ParseList(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/mail.AddressParser)ParseList()", args, 1, 1)
	__list := ExtractGoString("(*_net/mail.AddressParser)ParseList()", "__list", _argList, 0)
	_res1, _res2 := o.O.(*_mail.AddressParser).ParseList(__list)
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeGoObject(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.__ptrTo_Address_String from net/mail/message.go:
func __ptrTo_Address_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/mail.Address)String()", args, 0, 0)
	_res := o.O.(*_mail.Address).String()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
var info_Address GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.mail/Address from -:
var info_PtrTo_Address GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
var info_AddressParser GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.mail/AddressParser from -:
var info_PtrTo_AddressParser GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
var info_Header GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.mail/Header from -:
var info_PtrTo_Header GoTypeInfo

GO VARDEF FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
var info_Message GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.mail/Message from -:
var info_PtrTo_Message GoTypeInfo

GO INFO FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
	info_Address = GoTypeInfo{Name: "go.std.net.mail/Address",
		GoType: &GoType{T: &info_Address},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.mail/Address from -:
	info_PtrTo_Address = GoTypeInfo{Name: "*go.std.net.mail/Address",
		GoType: &GoType{T: &info_PtrTo_Address},
		Members: GoMembers{
			"String": MakeGoReceiver("String", __ptrTo_Address_String, "String formats the address as a valid RFC 5322 address.\nIf the address's name contains non-ASCII characters\nthe name will be rendered according to RFC 2047.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
	info_AddressParser = GoTypeInfo{Name: "go.std.net.mail/AddressParser",
		GoType: &GoType{T: &info_AddressParser},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.mail/AddressParser from -:
	info_PtrTo_AddressParser = GoTypeInfo{Name: "*go.std.net.mail/AddressParser",
		GoType: &GoType{T: &info_PtrTo_AddressParser},
		Members: GoMembers{
			"Parse": MakeGoReceiver("Parse", __ptrTo_AddressParser_Parse, "Parse parses a single RFC 5322 address of the\nform \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".\n", "1.0", NewVectorFrom(MakeSymbol("address"))),
			"ParseList": MakeGoReceiver("ParseList", __ptrTo_AddressParser_ParseList, "ParseList parses the given string as a list of comma-separated addresses\nof the form \"Gogh Fir <gf@example.com>\" or \"foo@example.com\".\n", "1.0", NewVectorFrom(MakeSymbol("list"))),
		}}


GO INFO FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
	info_Header = GoTypeInfo{Name: "go.std.net.mail/Header",
		GoType: &GoType{T: &info_Header},
		Members: GoMembers{
			"AddressList": MakeGoReceiver("AddressList", __header_AddressList, "AddressList parses the named header field as a list of addresses.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
			"Get": MakeGoReceiver("Get", __header_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		}}


GO INFO FOR TYPE *go.std.net.mail/Header from -:
	info_PtrTo_Header = GoTypeInfo{Name: "*go.std.net.mail/Header",
		GoType: &GoType{T: &info_PtrTo_Header},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
	info_Message = GoTypeInfo{Name: "go.std.net.mail/Message",
		GoType: &GoType{T: &info_Message},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.mail/Message from -:
	info_PtrTo_Message = GoTypeInfo{Name: "*go.std.net.mail/Message",
		GoType: &GoType{T: &info_PtrTo_Message},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.mail/Address from _tests/big/src/net/mail/message.go:141:6:
	GoTypesVec[109] = &info_Address

GO VECSET FOR TYPE *go.std.net.mail/Address from -:
	GoTypesVec[27] = &info_PtrTo_Address

GO VECSET FOR TYPE go.std.net.mail/AddressParser from _tests/big/src/net/mail/message.go:157:6:
	GoTypesVec[110] = &info_AddressParser

GO VECSET FOR TYPE *go.std.net.mail/AddressParser from -:
	GoTypesVec[28] = &info_PtrTo_AddressParser

GO VECSET FOR TYPE go.std.net.mail/Header from _tests/big/src/net/mail/message.go:106:6:
	GoTypesVec[111] = &info_Header

GO VECSET FOR TYPE *go.std.net.mail/Header from -:
	GoTypesVec[29] = &info_PtrTo_Header

GO VECSET FOR TYPE go.std.net.mail/Message from _tests/big/src/net/mail/message.go:44:6:
	GoTypesVec[112] = &info_Message

GO VECSET FOR TYPE *go.std.net.mail/Message from -:
	GoTypesVec[30] = &info_PtrTo_Message

GO ENSURE-LOADED FOR mail:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/mail/message.go:21:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/mail/message.go:22:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/mail/message.go:23:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/mail/message.go:24:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/mail/message.go:25:2
	EnsureLoaded("go.std.mime")  // E.g. from: _tests/big/src/net/mail/message.go:26:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/mail/message.go:27:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/mail/message.go:28:2
	EnsureLoaded("go.std.time")  // E.g. from: _tests/big/src/net/mail/message.go:29:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/mail/message.go:30:2

GO TYPE net/rpc.Call from net/rpc/client.go:
func ExtractGoObjectCall(args []Object, index int) *_rpc.Call {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Call:
			return &r
		case *_rpc.Call:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Call]"))
}

// func _mapToCall(o Map) *_rpc.Call {
// 	return &_rpc.Call{}
// }

// func _vectorToCall(o *Vector) *_rpc.Call {
// 	return &_rpc.Call{
// 		ServiceMethod: AssertString(o.Nth(0), "").S,
// 		Args: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Reply: ABEND047(gotypes.go: unsupported type *ast.InterfaceType),
// 		Error: _errors.New(AssertString(o.Nth(3), "").S),
// 		Done: ABEND047(gotypes.go: unsupported type *ast.ChanType),
// 	}
// }

// func _ConstructCall(_v Object) *_rpc.Call {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.Call:
// 			return &_g
// 		case *_rpc.Call:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToCall(_o.(Map))
// 	case *Vector:
// 		return _vectorToCall(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Call] or: Map or Vector"))
// }

func ExtractGo_go_std_net_rpc__Call(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Call) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Call", arg, args, n).O
	res, ok := a.(_rpc.Call)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Call], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.Client from net/rpc/client.go:
func ExtractGoObjectClient(args []Object, index int) *_rpc.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Client:
			return &r
		case *_rpc.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Client]"))
}

func _mapToClient(o Map) *_rpc.Client {
	return &_rpc.Client{}
}

func _vectorToClient(o *Vector) *_rpc.Client {
	return &_rpc.Client{}
}

func _ConstructClient(_v Object) *_rpc.Client {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Client:
			return &_g
		case *_rpc.Client:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToClient(_o.(Map))
	case *Vector:
		return _vectorToClient(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Client] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Client(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Client) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Client", arg, args, n).O
	res, ok := a.(_rpc.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.ClientCodec from net/rpc/client.go:
func ExtractGoObjectClientCodec(args []Object, index int) *_rpc.ClientCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ClientCodec:
			return &r
		case *_rpc.ClientCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ClientCodec]"))
}

// func _ConstructClientCodec(_v Object) _rpc.ClientCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ClientCodec:
// 			return _g
// 		case *_rpc.ClientCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ClientCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ClientCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ClientCodec] or: whatever"))
// }

func ExtractGo_go_std_net_rpc__ClientCodec(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ClientCodec) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ClientCodec", arg, args, n).O
	res, ok := a.(_rpc.ClientCodec)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ClientCodec], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.Request from net/rpc/server.go:
func ExtractGoObjectRequest(args []Object, index int) *_rpc.Request {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Request:
			return &r
		case *_rpc.Request:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Request]"))
}

func _mapToRequest(o Map) *_rpc.Request {
	return &_rpc.Request{}
}

func _vectorToRequest(o *Vector) *_rpc.Request {
	return &_rpc.Request{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
	}
}

func _ConstructRequest(_v Object) *_rpc.Request {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Request:
			return &_g
		case *_rpc.Request:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToRequest(_o.(Map))
	case *Vector:
		return _vectorToRequest(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Request] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Request(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Request) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Request", arg, args, n).O
	res, ok := a.(_rpc.Request)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Request], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.Response from net/rpc/server.go:
func ExtractGoObjectResponse(args []Object, index int) *_rpc.Response {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Response:
			return &r
		case *_rpc.Response:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Response]"))
}

func _mapToResponse(o Map) *_rpc.Response {
	return &_rpc.Response{}
}

func _vectorToResponse(o *Vector) *_rpc.Response {
	return &_rpc.Response{
		ServiceMethod: AssertString(o.Nth(0), "").S,
		Seq: AssertNumber(o.Nth(1), "").BigInt().Uint64(),
		Error: AssertString(o.Nth(2), "").S,
	}
}

func _ConstructResponse(_v Object) *_rpc.Response {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Response:
			return &_g
		case *_rpc.Response:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToResponse(_o.(Map))
	case *Vector:
		return _vectorToResponse(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Response] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Response(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Response) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Response", arg, args, n).O
	res, ok := a.(_rpc.Response)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Response], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.Server from net/rpc/server.go:
func ExtractGoObjectServer(args []Object, index int) *_rpc.Server {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.Server:
			return &r
		case *_rpc.Server:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.Server]"))
}

func _mapToServer(o Map) *_rpc.Server {
	return &_rpc.Server{}
}

func _vectorToServer(o *Vector) *_rpc.Server {
	return &_rpc.Server{}
}

func _ConstructServer(_v Object) *_rpc.Server {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.Server:
			return &_g
		case *_rpc.Server:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToServer(_o.(Map))
	case *Vector:
		return _vectorToServer(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.Server] or: Map or Vector"))
}

func ExtractGo_go_std_net_rpc__Server(rcvr, arg string, args *ArraySeq, n int) (res _rpc.Server) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/Server", arg, args, n).O
	res, ok := a.(_rpc.Server)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/Server], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.ServerCodec from net/rpc/server.go:
func ExtractGoObjectServerCodec(args []Object, index int) *_rpc.ServerCodec {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerCodec:
			return &r
		case *_rpc.ServerCodec:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerCodec]"))
}

// func _ConstructServerCodec(_v Object) _rpc.ServerCodec {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _rpc.ServerCodec:
// 			return _g
// 		case *_rpc.ServerCodec:
// 			return *_g
// 		}
// 	default:
// 		return _rpc.ServerCodec(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for ServerCodec))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerCodec] or: whatever"))
// }

func ExtractGo_go_std_net_rpc__ServerCodec(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ServerCodec) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ServerCodec", arg, args, n).O
	res, ok := a.(_rpc.ServerCodec)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ServerCodec], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/rpc.ServerError from net/rpc/client.go:
func ExtractGoObjectServerError(args []Object, index int) *_rpc.ServerError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _rpc.ServerError:
			return &r
		case *_rpc.ServerError:
			return r
		}
	case String:
		v := _rpc.ServerError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/rpc.ServerError]"))
}

func _ConstructServerError(_v Object) _rpc.ServerError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _rpc.ServerError:
			return _g
		case *_rpc.ServerError:
			return *_g
		}
	case String:
		return _rpc.ServerError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[rpc.ServerError] or: String"))
}

func ExtractGo_go_std_net_rpc__ServerError(rcvr, arg string, args *ArraySeq, n int) (res _rpc.ServerError) {
	a := CheckGoNth(rcvr, "go.std.net.rpc/ServerError", arg, args, n).O
	res, ok := a.(_rpc.ServerError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.rpc/ServerError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/rpc.Accept from net/rpc/server.go:
// func __accept(__lis ABEND987(genutils.go: imports not yet supported: net.Listener)) Object {
// 	_rpc.Accept(__lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial from net/rpc/client.go:
func __dial(__network string, __address string) Object {
	_res1, _res2 := _rpc.Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP from net/rpc/client.go:
func __dialHTTP(__network string, __address string) Object {
	_res1, _res2 := _rpc.DialHTTP(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath from net/rpc/client.go:
func __dialHTTPPath(__network string, __address string, __path string) Object {
	_res1, _res2 := _rpc.DialHTTPPath(__network, __address, __path)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP from net/rpc/server.go:
// func __handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient from net/rpc/client.go:
// func __newClient(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _rpc.NewClient(__conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc.NewClientWithCodec from net/rpc/client.go:
func __newClientWithCodec(__codec _rpc.ClientCodec) Object {
	_res := _rpc.NewClientWithCodec(__codec)
	return MakeGoObject(_res)
}

GO FUNC net/rpc.NewServer from net/rpc/server.go:
func __newServer() Object {
	_res := _rpc.NewServer()
	return MakeGoObject(_res)
}

GO FUNC net/rpc.Register from net/rpc/server.go:
// func __register(__rcvr interface {})  {
// 	_res := _rpc.Register(__rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.RegisterName from net/rpc/server.go:
// func __registerName(__name string, __rcvr interface {})  {
// 	_res := _rpc.RegisterName(__name, __rcvr)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.ServeCodec from net/rpc/server.go:
// func __serveCodec(__codec _rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(__codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn from net/rpc/server.go:
// func __serveConn(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_rpc.ServeConn(__conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.__clientCodec_Close from net/rpc/client.go:
func __clientCodec_Close(o GoObject, args Object) Object {
	CheckGoArity("(net/rpc.ClientCodec)Close()", args, 0, 0)
	_res := o.O.(_rpc.ClientCodec).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__clientCodec_ReadResponseBody from net/rpc/client.go:
// func __clientCodec_ReadResponseBody(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__clientCodec_ReadResponseHeader from net/rpc/client.go:
// func __clientCodec_ReadResponseHeader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(net/rpc.ClientCodec)ReadResponseHeader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __arg1 at: _tests/big/src/net/rpc/client.go:65:21)
// 	_res := o.O.(_rpc.ClientCodec).ReadResponseHeader(__arg1)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.__clientCodec_WriteRequest from net/rpc/client.go:
// func __clientCodec_WriteRequest(o GoObject, args Object) Object {
// (__arg1, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Client_Call from net/rpc/client.go:
// func __ptrTo_Client_Call(o GoObject, args Object) Object {
// (__serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Client_Close from net/rpc/client.go:
func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/rpc.Client)Close()", args, 0, 0)
	_res := o.O.(*_rpc.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__ptrTo_Client_Go from net/rpc/client.go:
// func __ptrTo_Client_Go(o GoObject, args Object) Object {
// (__serviceMethod, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND909(pre.go: custom-runtime routine not implemented: ConvertToChanTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_Accept from net/rpc/server.go:
// func __ptrTo_Server_Accept(o GoObject, args Object) Object {
// __lis ABEND987(genutils.go: imports not yet supported: net.Listener)}

GO FUNC net/rpc.__ptrTo_Server_HandleHTTP from net/rpc/server.go:
// func __ptrTo_Server_HandleHTTP(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc.__ptrTo_Server_Register from net/rpc/server.go:
// func __ptrTo_Server_Register(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_RegisterName from net/rpc/server.go:
// func __ptrTo_Server_RegisterName(o GoObject, args Object) Object {
// (__name, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__ptrTo_Server_ServeCodec from net/rpc/server.go:
// func __ptrTo_Server_ServeCodec(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/rpc.__ptrTo_Server_ServeConn from net/rpc/server.go:
// func __ptrTo_Server_ServeConn(o GoObject, args Object) Object {
// __conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)}

GO FUNC net/rpc.__ptrTo_Server_ServeHTTP from net/rpc/server.go:
// func __ptrTo_Server_ServeHTTP(o GoObject, args Object) Object {
// __w ABEND987(genutils.go: imports not yet supported: http.ResponseWriter), __req *ABEND987(genutils.go: imports not yet supported: http.Request)}

GO FUNC net/rpc.__ptrTo_Server_ServeRequest from net/rpc/server.go:
func __ptrTo_Server_ServeRequest(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/rpc.Server)ServeRequest()", args, 1, 1)
	__codec := ExtractGo_go_std_net_rpc__ServerCodec("(*_net/rpc.Server)ServeRequest()", "__codec", _argList, 0)
	_res := o.O.(*_rpc.Server).ServeRequest(__codec)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__serverCodec_Close from net/rpc/server.go:
func __serverCodec_Close(o GoObject, args Object) Object {
	CheckGoArity("(net/rpc.ServerCodec)Close()", args, 0, 0)
	_res := o.O.(_rpc.ServerCodec).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/rpc.__serverCodec_ReadRequestBody from net/rpc/server.go:
// func __serverCodec_ReadRequestBody(o GoObject, args Object) Object {
// (ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__serverCodec_ReadRequestHeader from net/rpc/server.go:
// func __serverCodec_ReadRequestHeader(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(net/rpc.ServerCodec)ReadRequestHeader()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __arg1 at: _tests/big/src/net/rpc/server.go:659:20)
// 	_res := o.O.(_rpc.ServerCodec).ReadRequestHeader(__arg1)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/rpc.__serverCodec_WriteResponse from net/rpc/server.go:
// func __serverCodec_WriteResponse(o GoObject, args Object) Object {
// (__arg1, ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))}

GO FUNC net/rpc.__serverError_Error from net/rpc/client.go:
func __serverError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/rpc.ServerError)Error()", args, 0, 0)
	_res := o.O.(_rpc.ServerError).Error()
	return MakeString(_res)
}

GO VARDEF FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
var info_Call GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/Call from -:
var info_PtrTo_Call GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/Client from -:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
var info_ClientCodec GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
var info_Request GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/Request from -:
var info_PtrTo_Request GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
var info_Response GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/Response from -:
var info_PtrTo_Response GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
var info_Server GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/Server from -:
var info_PtrTo_Server GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
var info_ServerCodec GoTypeInfo

GO VARDEF FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
var info_ServerError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.rpc/ServerError from -:
var info_PtrTo_ServerError GoTypeInfo

GO INFO FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
	info_Call = GoTypeInfo{Name: "go.std.net.rpc/Call",
		GoType: &GoType{T: &info_Call},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.rpc/Call from -:
	info_PtrTo_Call = GoTypeInfo{Name: "*go.std.net.rpc/Call",
		GoType: &GoType{T: &info_PtrTo_Call},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
	info_Client = GoTypeInfo{Name: "go.std.net.rpc/Client",
		GoType: &GoType{T: &info_Client},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.rpc/Client from -:
	info_PtrTo_Client = GoTypeInfo{Name: "*go.std.net.rpc/Client",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __ptrTo_Client_Close, "Close calls the underlying codec's Close method. If the connection is already\nshutting down, ErrShutdown is returned.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
	info_ClientCodec = GoTypeInfo{Name: "go.std.net.rpc/ClientCodec",
		GoType: &GoType{T: &info_ClientCodec},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __clientCodec_Close, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
	info_Request = GoTypeInfo{Name: "go.std.net.rpc/Request",
		GoType: &GoType{T: &info_Request},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.rpc/Request from -:
	info_PtrTo_Request = GoTypeInfo{Name: "*go.std.net.rpc/Request",
		GoType: &GoType{T: &info_PtrTo_Request},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
	info_Response = GoTypeInfo{Name: "go.std.net.rpc/Response",
		GoType: &GoType{T: &info_Response},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.rpc/Response from -:
	info_PtrTo_Response = GoTypeInfo{Name: "*go.std.net.rpc/Response",
		GoType: &GoType{T: &info_PtrTo_Response},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
	info_Server = GoTypeInfo{Name: "go.std.net.rpc/Server",
		GoType: &GoType{T: &info_Server},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.rpc/Server from -:
	info_PtrTo_Server = GoTypeInfo{Name: "*go.std.net.rpc/Server",
		GoType: &GoType{T: &info_PtrTo_Server},
		Members: GoMembers{
			"ServeRequest": MakeGoReceiver("ServeRequest", __ptrTo_Server_ServeRequest, "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n", "1.0", NewVectorFrom(MakeSymbol("codec"))),
		}}


GO INFO FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
	info_ServerCodec = GoTypeInfo{Name: "go.std.net.rpc/ServerCodec",
		GoType: &GoType{T: &info_ServerCodec},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __serverCodec_Close, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
	info_ServerError = GoTypeInfo{Name: "go.std.net.rpc/ServerError",
		GoType: &GoType{T: &info_ServerError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __serverError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.rpc/ServerError from -:
	info_PtrTo_ServerError = GoTypeInfo{Name: "*go.std.net.rpc/ServerError",
		GoType: &GoType{T: &info_PtrTo_ServerError},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.rpc/Call from _tests/big/src/net/rpc/client.go:29:6:
	GoTypesVec[113] = &info_Call

GO VECSET FOR TYPE *go.std.net.rpc/Call from -:
	GoTypesVec[31] = &info_PtrTo_Call

GO VECSET FOR TYPE go.std.net.rpc/Client from _tests/big/src/net/rpc/client.go:41:6:
	GoTypesVec[114] = &info_Client

GO VECSET FOR TYPE *go.std.net.rpc/Client from -:
	GoTypesVec[32] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.rpc/ClientCodec from _tests/big/src/net/rpc/client.go:63:6:
	GoTypesVec[166] = &info_ClientCodec

GO VECSET FOR TYPE go.std.net.rpc/Request from _tests/big/src/net/rpc/server.go:172:6:
	GoTypesVec[115] = &info_Request

GO VECSET FOR TYPE *go.std.net.rpc/Request from -:
	GoTypesVec[33] = &info_PtrTo_Request

GO VECSET FOR TYPE go.std.net.rpc/Response from _tests/big/src/net/rpc/server.go:181:6:
	GoTypesVec[116] = &info_Response

GO VECSET FOR TYPE *go.std.net.rpc/Response from -:
	GoTypesVec[34] = &info_PtrTo_Response

GO VECSET FOR TYPE go.std.net.rpc/Server from _tests/big/src/net/rpc/server.go:189:6:
	GoTypesVec[117] = &info_Server

GO VECSET FOR TYPE *go.std.net.rpc/Server from -:
	GoTypesVec[35] = &info_PtrTo_Server

GO VECSET FOR TYPE go.std.net.rpc/ServerCodec from _tests/big/src/net/rpc/server.go:658:6:
	GoTypesVec[167] = &info_ServerCodec

GO VECSET FOR TYPE go.std.net.rpc/ServerError from _tests/big/src/net/rpc/client.go:20:6:
	GoTypesVec[118] = &info_ServerError

GO VECSET FOR TYPE *go.std.net.rpc/ServerError from -:
	GoTypesVec[36] = &info_PtrTo_ServerError

GO ENSURE-LOADED FOR rpc:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/rpc/server.go:130:2
	EnsureLoaded("go.std.encoding.gob")  // E.g. from: _tests/big/src/net/rpc/server.go:131:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/rpc/server.go:132:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/rpc/debug.go:13:2
	EnsureLoaded("go.std.html.template")  // E.g. from: _tests/big/src/net/rpc/debug.go:14:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/rpc/server.go:133:2
	EnsureLoaded("go.std.log")  // E.g. from: _tests/big/src/net/rpc/server.go:134:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/rpc/server.go:135:2
	EnsureLoaded("go.std.net.http")  // E.g. from: _tests/big/src/net/rpc/server.go:136:2
	EnsureLoaded("go.std.reflect")  // E.g. from: _tests/big/src/net/rpc/server.go:137:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/rpc/debug.go:16:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/rpc/server.go:138:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/rpc/server.go:139:2
	EnsureLoaded("go.std.unicode")  // E.g. from: _tests/big/src/net/rpc/server.go:140:2
	EnsureLoaded("go.std.unicode.utf8")  // E.g. from: _tests/big/src/net/rpc/server.go:141:2

GO FUNC net/rpc/jsonrpc.Dial from net/rpc/jsonrpc/client.go:
func __dial(__network string, __address string) Object {
	_res1, _res2 := _jsonrpc.Dial(__network, __address)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient from net/rpc/jsonrpc/client.go:
// func __newClient(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClient(__conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec from net/rpc/jsonrpc/client.go:
// func __newClientCodec(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewClientCodec(__conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec from net/rpc/jsonrpc/server.go:
// func __newServerCodec(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _jsonrpc.NewServerCodec(__conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/rpc/jsonrpc.ServeConn from net/rpc/jsonrpc/server.go:
// func __serveConn(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_jsonrpc.ServeConn(__conn)
// 	...ABEND675: TODO...
// }

GO ENSURE-LOADED FOR jsonrpc:
	EnsureLoaded("go.std.encoding.json")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:8:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:12:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:10:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/client.go:14:2
	EnsureLoaded("go.std.net.rpc")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:11:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/rpc/jsonrpc/server.go:12:2

GO TYPE net/smtp.Auth from net/smtp/auth.go:
func ExtractGoObjectAuth(args []Object, index int) *_smtp.Auth {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Auth:
			return &r
		case *_smtp.Auth:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Auth]"))
}

// func _ConstructAuth(_v Object) _smtp.Auth {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Auth:
// 			return _g
// 		case *_smtp.Auth:
// 			return *_g
// 		}
// 	default:
// 		return _smtp.Auth(_o.ABEND674(codegen.go: unknown underlying type *ast.InterfaceType for Auth))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Auth] or: whatever"))
// }

func ExtractGo_go_std_net_smtp__Auth(rcvr, arg string, args *ArraySeq, n int) (res _smtp.Auth) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/Auth", arg, args, n).O
	res, ok := a.(_smtp.Auth)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/Auth], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/smtp.Client from net/smtp/smtp.go:
func ExtractGoObjectClient(args []Object, index int) *_smtp.Client {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.Client:
			return &r
		case *_smtp.Client:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.Client]"))
}

// func _mapToClient(o Map) *_smtp.Client {
// 	return &_smtp.Client{}
// }

// func _vectorToClient(o *Vector) *_smtp.Client {
// 	return &_smtp.Client{
// 		Text: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructClient(_v Object) *_smtp.Client {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.Client:
// 			return &_g
// 		case *_smtp.Client:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToClient(_o.(Map))
// 	case *Vector:
// 		return _vectorToClient(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.Client] or: Map or Vector"))
// }

func ExtractGo_go_std_net_smtp__Client(rcvr, arg string, args *ArraySeq, n int) (res _smtp.Client) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/Client", arg, args, n).O
	res, ok := a.(_smtp.Client)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/Client], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/smtp.ServerInfo from net/smtp/auth.go:
func ExtractGoObjectServerInfo(args []Object, index int) *_smtp.ServerInfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _smtp.ServerInfo:
			return &r
		case *_smtp.ServerInfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/smtp.ServerInfo]"))
}

// func _mapToServerInfo(o Map) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{}
// }

// func _vectorToServerInfo(o *Vector) *_smtp.ServerInfo {
// 	return &_smtp.ServerInfo{
// 		Name: AssertString(o.Nth(0), "").S,
// 		TLS: ToBool(o.Nth(1)),
// 		Auth: ABEND048(codegen.go: no conversion from Clojure for []string (string)),
// 	}
// }

// func _ConstructServerInfo(_v Object) *_smtp.ServerInfo {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _smtp.ServerInfo:
// 			return &_g
// 		case *_smtp.ServerInfo:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToServerInfo(_o.(Map))
// 	case *Vector:
// 		return _vectorToServerInfo(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[smtp.ServerInfo] or: Map or Vector"))
// }

func ExtractGo_go_std_net_smtp__ServerInfo(rcvr, arg string, args *ArraySeq, n int) (res _smtp.ServerInfo) {
	a := CheckGoNth(rcvr, "go.std.net.smtp/ServerInfo", arg, args, n).O
	res, ok := a.(_smtp.ServerInfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.smtp/ServerInfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/smtp.CRAMMD5Auth from net/smtp/auth.go:
func __cRAMMD5Auth(__username string, __secret string) Object {
	_res := _smtp.CRAMMD5Auth(__username, __secret)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.Dial from net/smtp/smtp.go:
func __dial(__addr string) Object {
	_res1, _res2 := _smtp.Dial(__addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient from net/smtp/smtp.go:
// func __newClient(__conn ABEND987(genutils.go: imports not yet supported: net.Conn), __host string) Object {
// 	_res1, _res2 := _smtp.NewClient(__conn, __host)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeGoObject(_res1))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth from net/smtp/auth.go:
func __plainAuth(__identity string, __username string, __password string, __host string) Object {
	_res := _smtp.PlainAuth(__identity, __username, __password, __host)
	return MakeGoObject(_res)
}

GO FUNC net/smtp.SendMail from net/smtp/smtp.go:
// func __sendMail(__addr string, __a _smtp.Auth, __from string, __to []string, __msg []byte)  {
// 	_res := _smtp.SendMail(__addr, __a, __from, __to, __msg)
// 	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
// }

GO FUNC net/smtp.__auth_Next from net/smtp/auth.go:
// func __auth_Next(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__fromServer)), __more)}

GO FUNC net/smtp.__auth_Start from net/smtp/auth.go:
// func __auth_Start(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(net/smtp.Auth)Start()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __server at: _tests/big/src/net/smtp/auth.go:23:15)
// 	proto, toServer, err := o.O.(_smtp.Auth).Start(__server)
// 	_res := EmptyVector()
// 	_res = _res.Conjoin(MakeString(proto))
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range toServer {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/smtp.__ptrTo_Client_Auth from net/smtp/smtp.go:
func __ptrTo_Client_Auth(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Auth()", args, 1, 1)
	__a := ExtractGo_go_std_net_smtp__Auth("(*_net/smtp.Client)Auth()", "__a", _argList, 0)
	_res := o.O.(*_smtp.Client).Auth(__a)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Close from net/smtp/smtp.go:
func __ptrTo_Client_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Close()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Data from net/smtp/smtp.go:
// func __ptrTo_Client_Data(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename io.WriteCloser) Error]}

GO FUNC net/smtp.__ptrTo_Client_Extension from net/smtp/smtp.go:
func __ptrTo_Client_Extension(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Extension()", args, 1, 1)
	__ext := ExtractGoString("(*_net/smtp.Client)Extension()", "__ext", _argList, 0)
	_res1, _res2 := o.O.(*_smtp.Client).Extension(__ext)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeBoolean(_res1))
	_res = _res.Conjoin(MakeString(_res2))
	return _res
}

GO FUNC net/smtp.__ptrTo_Client_Hello from net/smtp/smtp.go:
func __ptrTo_Client_Hello(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Hello()", args, 1, 1)
	__localName := ExtractGoString("(*_net/smtp.Client)Hello()", "__localName", _argList, 0)
	_res := o.O.(*_smtp.Client).Hello(__localName)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Mail from net/smtp/smtp.go:
func __ptrTo_Client_Mail(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Mail()", args, 1, 1)
	__from := ExtractGoString("(*_net/smtp.Client)Mail()", "__from", _argList, 0)
	_res := o.O.(*_smtp.Client).Mail(__from)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Noop from net/smtp/smtp.go:
func __ptrTo_Client_Noop(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Noop()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Noop()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Quit from net/smtp/smtp.go:
func __ptrTo_Client_Quit(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Quit()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Quit()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Rcpt from net/smtp/smtp.go:
func __ptrTo_Client_Rcpt(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Rcpt()", args, 1, 1)
	__to := ExtractGoString("(*_net/smtp.Client)Rcpt()", "__to", _argList, 0)
	_res := o.O.(*_smtp.Client).Rcpt(__to)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_Reset from net/smtp/smtp.go:
func __ptrTo_Client_Reset(o GoObject, args Object) Object {
	CheckGoArity("(*_net/smtp.Client)Reset()", args, 0, 0)
	_res := o.O.(*_smtp.Client).Reset()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/smtp.__ptrTo_Client_StartTLS from net/smtp/smtp.go:
// func __ptrTo_Client_StartTLS(o GoObject, args Object) Object {
// __config *ABEND987(genutils.go: imports not yet supported: tls.Config)}

GO FUNC net/smtp.__ptrTo_Client_TLSConnectionState from net/smtp/smtp.go:
// func __ptrTo_Client_TLSConnectionState(o GoObject, args Object) Object {
// [ABEND042(post.go: cannot find typename crypto/tls.ConnectionState) Boolean]}

GO FUNC net/smtp.__ptrTo_Client_Verify from net/smtp/smtp.go:
func __ptrTo_Client_Verify(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/smtp.Client)Verify()", args, 1, 1)
	__addr := ExtractGoString("(*_net/smtp.Client)Verify()", "__addr", _argList, 0)
	_res := o.O.(*_smtp.Client).Verify(__addr)
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO VARDEF FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
var info_Auth GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
var info_Client GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.smtp/Client from -:
var info_PtrTo_Client GoTypeInfo

GO VARDEF FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
var info_ServerInfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.smtp/ServerInfo from -:
var info_PtrTo_ServerInfo GoTypeInfo

GO INFO FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
	info_Auth = GoTypeInfo{Name: "go.std.net.smtp/Auth",
		GoType: &GoType{T: &info_Auth},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
	info_Client = GoTypeInfo{Name: "go.std.net.smtp/Client",
		GoType: &GoType{T: &info_Client},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.smtp/Client from -:
	info_PtrTo_Client = GoTypeInfo{Name: "*go.std.net.smtp/Client",
		GoType: &GoType{T: &info_PtrTo_Client},
		Members: GoMembers{
			"Auth": MakeGoReceiver("Auth", __ptrTo_Client_Auth, "Auth authenticates a client using the provided authentication mechanism.\nA failed authentication closes the connection.\nOnly servers that advertise the AUTH extension support this function.\n", "1.0", NewVectorFrom(MakeSymbol("a"))),
			"Close": MakeGoReceiver("Close", __ptrTo_Client_Close, "Close closes the connection.\n", "1.0", NewVectorFrom()),
			"Extension": MakeGoReceiver("Extension", __ptrTo_Client_Extension, "Extension reports whether an extension is support by the server.\nThe extension name is case-insensitive. If the extension is supported,\nExtension also returns a string that contains any parameters the\nserver specifies for the extension.\n", "1.0", NewVectorFrom(MakeSymbol("ext"))),
			"Hello": MakeGoReceiver("Hello", __ptrTo_Client_Hello, "Hello sends a HELO or EHLO to the server as the given host name.\nCalling this method is only necessary if the client needs control\nover the host name used. The client will introduce itself as \"localhost\"\nautomatically otherwise. If Hello is called, it must be called before\nany of the other methods.\n", "1.0", NewVectorFrom(MakeSymbol("localName"))),
			"Mail": MakeGoReceiver("Mail", __ptrTo_Client_Mail, "Mail issues a MAIL command to the server using the provided email address.\nIf the server supports the 8BITMIME extension, Mail adds the BODY=8BITMIME\nparameter.\nThis initiates a mail transaction and is followed by one or more Rcpt calls.\n", "1.0", NewVectorFrom(MakeSymbol("from"))),
			"Noop": MakeGoReceiver("Noop", __ptrTo_Client_Noop, "Noop sends the NOOP command to the server. It does nothing but check\nthat the connection to the server is okay.\n", "1.0", NewVectorFrom()),
			"Quit": MakeGoReceiver("Quit", __ptrTo_Client_Quit, "Quit sends the QUIT command and closes the connection to the server.\n", "1.0", NewVectorFrom()),
			"Rcpt": MakeGoReceiver("Rcpt", __ptrTo_Client_Rcpt, "Rcpt issues a RCPT command to the server using the provided email address.\nA call to Rcpt must be preceded by a call to Mail and may be followed by\na Data call or another Rcpt call.\n", "1.0", NewVectorFrom(MakeSymbol("to"))),
			"Reset": MakeGoReceiver("Reset", __ptrTo_Client_Reset, "Reset sends the RSET command to the server, aborting the current mail\ntransaction.\n", "1.0", NewVectorFrom()),
			"Verify": MakeGoReceiver("Verify", __ptrTo_Client_Verify, "Verify checks the validity of an email address on the server.\nIf Verify returns nil, the address is valid. A non-nil return\ndoes not necessarily indicate an invalid address. Many servers\nwill not verify addresses for security reasons.\n", "1.0", NewVectorFrom(MakeSymbol("addr"))),
		}}


GO INFO FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	info_ServerInfo = GoTypeInfo{Name: "go.std.net.smtp/ServerInfo",
		GoType: &GoType{T: &info_ServerInfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.smtp/ServerInfo from -:
	info_PtrTo_ServerInfo = GoTypeInfo{Name: "*go.std.net.smtp/ServerInfo",
		GoType: &GoType{T: &info_PtrTo_ServerInfo},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.smtp/Auth from _tests/big/src/net/smtp/auth.go:15:6:
	GoTypesVec[175] = &info_Auth

GO VECSET FOR TYPE go.std.net.smtp/Client from _tests/big/src/net/smtp/smtp.go:30:6:
	GoTypesVec[119] = &info_Client

GO VECSET FOR TYPE *go.std.net.smtp/Client from -:
	GoTypesVec[37] = &info_PtrTo_Client

GO VECSET FOR TYPE go.std.net.smtp/ServerInfo from _tests/big/src/net/smtp/auth.go:35:6:
	GoTypesVec[120] = &info_ServerInfo

GO VECSET FOR TYPE *go.std.net.smtp/ServerInfo from -:
	GoTypesVec[38] = &info_PtrTo_ServerInfo

GO ENSURE-LOADED FOR smtp:
	EnsureLoaded("go.std.crypto.hmac")  // E.g. from: _tests/big/src/net/smtp/auth.go:8:2
	EnsureLoaded("go.std.crypto.md5")  // E.g. from: _tests/big/src/net/smtp/auth.go:9:2
	EnsureLoaded("go.std.crypto.tls")  // E.g. from: _tests/big/src/net/smtp/smtp.go:19:2
	EnsureLoaded("go.std.encoding.base64")  // E.g. from: _tests/big/src/net/smtp/smtp.go:20:2
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/smtp/smtp.go:21:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/smtp/smtp.go:22:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/smtp/smtp.go:23:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/smtp/smtp.go:24:2
	EnsureLoaded("go.std.net.textproto")  // E.g. from: _tests/big/src/net/smtp/smtp.go:25:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/smtp/smtp.go:26:2

GO TYPE net/textproto.Conn from net/textproto/textproto.go:
func ExtractGoObjectConn(args []Object, index int) *_textproto.Conn {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Conn:
			return &r
		case *_textproto.Conn:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Conn]"))
}

func _mapToConn(o Map) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _vectorToConn(o *Vector) *_textproto.Conn {
	return &_textproto.Conn{}
}

func _ConstructConn(_v Object) *_textproto.Conn {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Conn:
			return &_g
		case *_textproto.Conn:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToConn(_o.(Map))
	case *Vector:
		return _vectorToConn(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Conn] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Conn(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Conn) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Conn", arg, args, n).O
	res, ok := a.(_textproto.Conn)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Conn], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.Error from net/textproto/textproto.go:
func ExtractGoObjectError(args []Object, index int) *_textproto.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Error:
			return &r
		case *_textproto.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Error]"))
}

func _mapToError(o Map) *_textproto.Error {
	return &_textproto.Error{}
}

func _vectorToError(o *Vector) *_textproto.Error {
	return &_textproto.Error{
		Code: AssertInt(o.Nth(0), "").I,
		Msg: AssertString(o.Nth(1), "").S,
	}
}

func _ConstructError(_v Object) *_textproto.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Error:
			return &_g
		case *_textproto.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Error] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Error(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Error) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Error", arg, args, n).O
	res, ok := a.(_textproto.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.MIMEHeader from net/textproto/header.go:
func ExtractGoObjectMIMEHeader(args []Object, index int) *_textproto.MIMEHeader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.MIMEHeader:
			return &r
		case *_textproto.MIMEHeader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.MIMEHeader]"))
}

// func _ConstructMIMEHeader(_v Object) _textproto.MIMEHeader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.MIMEHeader:
// 			return _g
// 		case *_textproto.MIMEHeader:
// 			return *_g
// 		}
// 	default:
// 		return _textproto.MIMEHeader(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for MIMEHeader))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.MIMEHeader] or: whatever"))
// }

func ExtractGo_go_std_net_textproto__MIMEHeader(rcvr, arg string, args *ArraySeq, n int) (res _textproto.MIMEHeader) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/MIMEHeader", arg, args, n).O
	res, ok := a.(_textproto.MIMEHeader)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/MIMEHeader], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.Pipeline from net/textproto/pipeline.go:
func ExtractGoObjectPipeline(args []Object, index int) *_textproto.Pipeline {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Pipeline:
			return &r
		case *_textproto.Pipeline:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Pipeline]"))
}

func _mapToPipeline(o Map) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _vectorToPipeline(o *Vector) *_textproto.Pipeline {
	return &_textproto.Pipeline{}
}

func _ConstructPipeline(_v Object) *_textproto.Pipeline {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.Pipeline:
			return &_g
		case *_textproto.Pipeline:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToPipeline(_o.(Map))
	case *Vector:
		return _vectorToPipeline(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Pipeline] or: Map or Vector"))
}

func ExtractGo_go_std_net_textproto__Pipeline(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Pipeline) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Pipeline", arg, args, n).O
	res, ok := a.(_textproto.Pipeline)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Pipeline], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.ProtocolError from net/textproto/textproto.go:
func ExtractGoObjectProtocolError(args []Object, index int) *_textproto.ProtocolError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.ProtocolError:
			return &r
		case *_textproto.ProtocolError:
			return r
		}
	case String:
		v := _textproto.ProtocolError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.ProtocolError]"))
}

func _ConstructProtocolError(_v Object) _textproto.ProtocolError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _textproto.ProtocolError:
			return _g
		case *_textproto.ProtocolError:
			return *_g
		}
	case String:
		return _textproto.ProtocolError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.ProtocolError] or: String"))
}

func ExtractGo_go_std_net_textproto__ProtocolError(rcvr, arg string, args *ArraySeq, n int) (res _textproto.ProtocolError) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/ProtocolError", arg, args, n).O
	res, ok := a.(_textproto.ProtocolError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/ProtocolError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.Reader from net/textproto/reader.go:
func ExtractGoObjectReader(args []Object, index int) *_textproto.Reader {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Reader:
			return &r
		case *_textproto.Reader:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Reader]"))
}

// func _mapToReader(o Map) *_textproto.Reader {
// 	return &_textproto.Reader{}
// }

// func _vectorToReader(o *Vector) *_textproto.Reader {
// 	return &_textproto.Reader{
// 		R: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructReader(_v Object) *_textproto.Reader {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Reader:
// 			return &_g
// 		case *_textproto.Reader:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToReader(_o.(Map))
// 	case *Vector:
// 		return _vectorToReader(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Reader] or: Map or Vector"))
// }

func ExtractGo_go_std_net_textproto__Reader(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Reader) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Reader", arg, args, n).O
	res, ok := a.(_textproto.Reader)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Reader], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/textproto.Writer from net/textproto/writer.go:
func ExtractGoObjectWriter(args []Object, index int) *_textproto.Writer {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _textproto.Writer:
			return &r
		case *_textproto.Writer:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/textproto.Writer]"))
}

// func _mapToWriter(o Map) *_textproto.Writer {
// 	return &_textproto.Writer{}
// }

// func _vectorToWriter(o *Vector) *_textproto.Writer {
// 	return &_textproto.Writer{
// 		W: *ABEND047(gotypes.go: unsupported type *ast.SelectorExpr),
// 	}
// }

// func _ConstructWriter(_v Object) *_textproto.Writer {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _textproto.Writer:
// 			return &_g
// 		case *_textproto.Writer:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToWriter(_o.(Map))
// 	case *Vector:
// 		return _vectorToWriter(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[textproto.Writer] or: Map or Vector"))
// }

func ExtractGo_go_std_net_textproto__Writer(rcvr, arg string, args *ArraySeq, n int) (res _textproto.Writer) {
	a := CheckGoNth(rcvr, "go.std.net.textproto/Writer", arg, args, n).O
	res, ok := a.(_textproto.Writer)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.textproto/Writer], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/textproto.Dial from net/textproto/textproto.go:
func __dial(__network string, __addr string) Object {
	_res1, _res2 := _textproto.Dial(__network, __addr)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn from net/textproto/textproto.go:
// func __newConn(__conn ABEND987(genutils.go: imports not yet supported: io.ReadWriteCloser)) Object {
// 	_res := _textproto.NewConn(__conn)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewReader from net/textproto/reader.go:
// func __newReader(__r *ABEND987(genutils.go: imports not yet supported: bufio.Reader)) Object {
// 	_res := _textproto.NewReader(__r)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.NewWriter from net/textproto/writer.go:
// func __newWriter(__w *ABEND987(genutils.go: imports not yet supported: bufio.Writer)) Object {
// 	_res := _textproto.NewWriter(__w)
// 	return MakeGoObject(_res)
// }

GO FUNC net/textproto.TrimBytes from net/textproto/textproto.go:
// func __trimBytes(__b []byte) Object {
// 	_res := _textproto.TrimBytes(__b)
// 	_vec1 := EmptyVector()
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC net/textproto.__mIMEHeader_Add from net/textproto/header.go:
// func __mIMEHeader_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__mIMEHeader_Del from net/textproto/header.go:
// func __mIMEHeader_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__mIMEHeader_Get from net/textproto/header.go:
func __mIMEHeader_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/textproto.MIMEHeader)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/textproto.MIMEHeader)Get()", "__key", _argList, 0)
	_res := o.O.(_textproto.MIMEHeader).Get(__key)
	return MakeString(_res)
}

GO FUNC net/textproto.__mIMEHeader_Set from net/textproto/header.go:
// func __mIMEHeader_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__protocolError_Error from net/textproto/textproto.go:
func __protocolError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/textproto.ProtocolError)Error()", args, 0, 0)
	_res := o.O.(_textproto.ProtocolError).Error()
	return MakeString(_res)
}

GO FUNC net/textproto.__ptrTo_Conn_Close from net/textproto/textproto.go:
func __ptrTo_Conn_Close(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Conn)Close()", args, 0, 0)
	_res := o.O.(*_textproto.Conn).Close()
	return func () Object { if (_res) == nil { return NIL } else { return MakeError(_res) } }()
}

GO FUNC net/textproto.__ptrTo_Conn_Cmd from net/textproto/textproto.go:
// func __ptrTo_Conn_Cmd(o GoObject, args Object) Object {
// (__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO FUNC net/textproto.__ptrTo_Error_Error from net/textproto/textproto.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Error)Error()", args, 0, 0)
	_res := o.O.(*_textproto.Error).Error()
	return MakeString(_res)
}

GO FUNC net/textproto.__ptrTo_Pipeline_EndRequest from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_EndRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_EndResponse from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_EndResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_Next from net/textproto/pipeline.go:
func __ptrTo_Pipeline_Next(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Pipeline)Next()", args, 0, 0)
	_res := o.O.(*_textproto.Pipeline).Next()
	return MakeBigIntU(uint64(_res))
}

GO FUNC net/textproto.__ptrTo_Pipeline_StartRequest from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_StartRequest(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Pipeline_StartResponse from net/textproto/pipeline.go:
// func __ptrTo_Pipeline_StartResponse(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/textproto.__ptrTo_Reader_DotReader from net/textproto/reader.go:
// func __ptrTo_Reader_DotReader(o GoObject, args Object) Object {
// ABEND042(post.go: cannot find typename io.Reader)}

GO FUNC net/textproto.__ptrTo_Reader_ReadCodeLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadCodeLine(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadCodeLine()", args, 1, 1)
	__expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadCodeLine()", "__expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadCodeLine(__expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadContinuedLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadContinuedLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadContinuedLineBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadContinuedLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadContinuedLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadContinuedLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadDotBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadDotBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadDotLines from net/textproto/reader.go:
func __ptrTo_Reader_ReadDotLines(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadDotLines()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadDotLines()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadLine from net/textproto/reader.go:
func __ptrTo_Reader_ReadLine(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLine()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLine()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadLineBytes from net/textproto/reader.go:
func __ptrTo_Reader_ReadLineBytes(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadLineBytes()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadLineBytes()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadMIMEHeader from net/textproto/reader.go:
func __ptrTo_Reader_ReadMIMEHeader(o GoObject, args Object) Object {
	CheckGoArity("(*_net/textproto.Reader)ReadMIMEHeader()", args, 0, 0)
	_res1, _res2 := o.O.(*_textproto.Reader).ReadMIMEHeader()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Reader_ReadResponse from net/textproto/reader.go:
func __ptrTo_Reader_ReadResponse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/textproto.Reader)ReadResponse()", args, 1, 1)
	__expectCode := ExtractGoInt("(*_net/textproto.Reader)ReadResponse()", "__expectCode", _argList, 0)
	code, message, err := o.O.(*_textproto.Reader).ReadResponse(__expectCode)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeInt(code))
	_res = _res.Conjoin(MakeString(message))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/textproto.__ptrTo_Writer_DotWriter from net/textproto/writer.go:
// func __ptrTo_Writer_DotWriter(o GoObject, args Object) Object {
// ABEND042(post.go: cannot find typename io.WriteCloser)}

GO FUNC net/textproto.__ptrTo_Writer_PrintfLine from net/textproto/writer.go:
// func __ptrTo_Writer_PrintfLine(o GoObject, args Object) Object {
// (__format, ConvertToEllipsisHaHainterface {}(ABEND907(pre.go: custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))}

GO VARDEF FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
var info_Conn GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/Conn from -:
var info_PtrTo_Conn GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/Error from -:
var info_PtrTo_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
var info_MIMEHeader GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/MIMEHeader from -:
var info_PtrTo_MIMEHeader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
var info_Pipeline GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/Pipeline from -:
var info_PtrTo_Pipeline GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
var info_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/ProtocolError from -:
var info_PtrTo_ProtocolError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
var info_Reader GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/Reader from -:
var info_PtrTo_Reader GoTypeInfo

GO VARDEF FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
var info_Writer GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.textproto/Writer from -:
var info_PtrTo_Writer GoTypeInfo

GO INFO FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
	info_Conn = GoTypeInfo{Name: "go.std.net.textproto/Conn",
		GoType: &GoType{T: &info_Conn},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.textproto/Conn from -:
	info_PtrTo_Conn = GoTypeInfo{Name: "*go.std.net.textproto/Conn",
		GoType: &GoType{T: &info_PtrTo_Conn},
		Members: GoMembers{
			"Close": MakeGoReceiver("Close", __ptrTo_Conn_Close, "Close closes the connection.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
	info_Error = GoTypeInfo{Name: "go.std.net.textproto/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.textproto/Error from -:
	info_PtrTo_Error = GoTypeInfo{Name: "*go.std.net.textproto/Error",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	info_MIMEHeader = GoTypeInfo{Name: "go.std.net.textproto/MIMEHeader",
		GoType: &GoType{T: &info_MIMEHeader},
		Members: GoMembers{
			"Get": MakeGoReceiver("Get", __mIMEHeader_Get, "Get gets the first value associated with the given key.\nIt is case insensitive; CanonicalMIMEHeaderKey is used\nto canonicalize the provided key.\nIf there are no values associated with the key, Get returns \"\".\nTo access multiple values of a key, or to use non-canonical keys,\naccess the map directly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		}}


GO INFO FOR TYPE *go.std.net.textproto/MIMEHeader from -:
	info_PtrTo_MIMEHeader = GoTypeInfo{Name: "*go.std.net.textproto/MIMEHeader",
		GoType: &GoType{T: &info_PtrTo_MIMEHeader},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	info_Pipeline = GoTypeInfo{Name: "go.std.net.textproto/Pipeline",
		GoType: &GoType{T: &info_Pipeline},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.textproto/Pipeline from -:
	info_PtrTo_Pipeline = GoTypeInfo{Name: "*go.std.net.textproto/Pipeline",
		GoType: &GoType{T: &info_PtrTo_Pipeline},
		Members: GoMembers{
			"Next": MakeGoReceiver("Next", __ptrTo_Pipeline_Next, "Next returns the next id for a request/response pair.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	info_ProtocolError = GoTypeInfo{Name: "go.std.net.textproto/ProtocolError",
		GoType: &GoType{T: &info_ProtocolError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __protocolError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.textproto/ProtocolError from -:
	info_PtrTo_ProtocolError = GoTypeInfo{Name: "*go.std.net.textproto/ProtocolError",
		GoType: &GoType{T: &info_PtrTo_ProtocolError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
	info_Reader = GoTypeInfo{Name: "go.std.net.textproto/Reader",
		GoType: &GoType{T: &info_Reader},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.textproto/Reader from -:
	info_PtrTo_Reader = GoTypeInfo{Name: "*go.std.net.textproto/Reader",
		GoType: &GoType{T: &info_PtrTo_Reader},
		Members: GoMembers{
			"ReadCodeLine": MakeGoReceiver("ReadCodeLine", __ptrTo_Reader_ReadCodeLine, "ReadCodeLine reads a response code line of the form\n\tcode message\nwhere code is a three-digit status code and the message\nextends to the rest of the line. An example of such a line is:\n\t220 plan9.bell-labs.com ESMTP\n\nIf the prefix of the status does not match the digits in expectCode,\nReadCodeLine returns with err set to &Error{code, message}.\nFor example, if expectCode is 31, an error will be returned if\nthe status is not in the range [310,319].\n\nIf the response is multi-line, ReadCodeLine returns an error.\n\nAn expectCode <= 0 disables the check of the status code.\n", "1.0", NewVectorFrom(MakeSymbol("expectCode"))),
			"ReadContinuedLine": MakeGoReceiver("ReadContinuedLine", __ptrTo_Reader_ReadContinuedLine, "ReadContinuedLine reads a possibly continued line from r,\neliding the final trailing ASCII white space.\nLines after the first are considered continuations if they\nbegin with a space or tab character. In the returned data,\ncontinuation lines are separated from the previous line\nonly by a single space: the newline and leading white space\nare removed.\n\nFor example, consider this input:\n\n\tLine 1\n\t  continued...\n\tLine 2\n\nThe first call to ReadContinuedLine will return \"Line 1 continued...\"\nand the second will return \"Line 2\".\n\nA line consisting of only white space is never continued.\n", "1.0", NewVectorFrom()),
			"ReadContinuedLineBytes": MakeGoReceiver("ReadContinuedLineBytes", __ptrTo_Reader_ReadContinuedLineBytes, "ReadContinuedLineBytes is like ReadContinuedLine but\nreturns a []byte instead of a string.\n", "1.0", NewVectorFrom()),
			"ReadDotBytes": MakeGoReceiver("ReadDotBytes", __ptrTo_Reader_ReadDotBytes, "ReadDotBytes reads a dot-encoding and returns the decoded data.\n\nSee the documentation for the DotReader method for details about dot-encoding.\n", "1.0", NewVectorFrom()),
			"ReadDotLines": MakeGoReceiver("ReadDotLines", __ptrTo_Reader_ReadDotLines, "ReadDotLines reads a dot-encoding and returns a slice\ncontaining the decoded lines, with the final \\r\\n or \\n elided from each.\n\nSee the documentation for the DotReader method for details about dot-encoding.\n", "1.0", NewVectorFrom()),
			"ReadLine": MakeGoReceiver("ReadLine", __ptrTo_Reader_ReadLine, "ReadLine reads a single line from r,\neliding the final \\n or \\r\\n from the returned string.\n", "1.0", NewVectorFrom()),
			"ReadLineBytes": MakeGoReceiver("ReadLineBytes", __ptrTo_Reader_ReadLineBytes, "ReadLineBytes is like ReadLine but returns a []byte instead of a string.\n", "1.0", NewVectorFrom()),
			"ReadMIMEHeader": MakeGoReceiver("ReadMIMEHeader", __ptrTo_Reader_ReadMIMEHeader, "ReadMIMEHeader reads a MIME-style header from r.\nThe header is a sequence of possibly continued Key: Value lines\nending in a blank line.\nThe returned map m maps CanonicalMIMEHeaderKey(key) to a\nsequence of values in the same order encountered in the input.\n\nFor example, consider this input:\n\n\tMy-Key: Value 1\n\tLong-Key: Even\n\t       Longer Value\n\tMy-Key: Value 2\n\nGiven that input, ReadMIMEHeader returns the map:\n\n\tmap[string][]string{\n\t\t\"My-Key\": {\"Value 1\", \"Value 2\"},\n\t\t\"Long-Key\": {\"Even Longer Value\"},\n\t}\n", "1.0", NewVectorFrom()),
			"ReadResponse": MakeGoReceiver("ReadResponse", __ptrTo_Reader_ReadResponse, "ReadResponse reads a multi-line response of the form:\n\n\tcode-message line 1\n\tcode-message line 2\n\t...\n\tcode message line n\n\nwhere code is a three-digit status code. The first line starts with the\ncode and a hyphen. The response is terminated by a line that starts\nwith the same code followed by a space. Each line in message is\nseparated by a newline (\\n).\n\nSee page 36 of RFC 959 (https://www.ietf.org/rfc/rfc959.txt) for\ndetails of another form of response accepted:\n\n code-message line 1\n message line 2\n ...\n code message line n\n\nIf the prefix of the status does not match the digits in expectCode,\nReadResponse returns with err set to &Error{code, message}.\nFor example, if expectCode is 31, an error will be returned if\nthe status is not in the range [310,319].\n\nAn expectCode <= 0 disables the check of the status code.\n", "1.0", NewVectorFrom(MakeSymbol("expectCode"))),
		}}


GO INFO FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
	info_Writer = GoTypeInfo{Name: "go.std.net.textproto/Writer",
		GoType: &GoType{T: &info_Writer},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.textproto/Writer from -:
	info_PtrTo_Writer = GoTypeInfo{Name: "*go.std.net.textproto/Writer",
		GoType: &GoType{T: &info_PtrTo_Writer},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.textproto/Conn from _tests/big/src/net/textproto/textproto.go:58:6:
	GoTypesVec[121] = &info_Conn

GO VECSET FOR TYPE *go.std.net.textproto/Conn from -:
	GoTypesVec[39] = &info_PtrTo_Conn

GO VECSET FOR TYPE go.std.net.textproto/Error from _tests/big/src/net/textproto/textproto.go:36:6:
	GoTypesVec[122] = &info_Error

GO VECSET FOR TYPE *go.std.net.textproto/Error from -:
	GoTypesVec[40] = &info_PtrTo_Error

GO VECSET FOR TYPE go.std.net.textproto/MIMEHeader from _tests/big/src/net/textproto/header.go:9:6:
	GoTypesVec[123] = &info_MIMEHeader

GO VECSET FOR TYPE *go.std.net.textproto/MIMEHeader from -:
	GoTypesVec[41] = &info_PtrTo_MIMEHeader

GO VECSET FOR TYPE go.std.net.textproto/Pipeline from _tests/big/src/net/textproto/pipeline.go:28:6:
	GoTypesVec[124] = &info_Pipeline

GO VECSET FOR TYPE *go.std.net.textproto/Pipeline from -:
	GoTypesVec[42] = &info_PtrTo_Pipeline

GO VECSET FOR TYPE go.std.net.textproto/ProtocolError from _tests/big/src/net/textproto/textproto.go:47:6:
	GoTypesVec[125] = &info_ProtocolError

GO VECSET FOR TYPE *go.std.net.textproto/ProtocolError from -:
	GoTypesVec[43] = &info_PtrTo_ProtocolError

GO VECSET FOR TYPE go.std.net.textproto/Reader from _tests/big/src/net/textproto/reader.go:18:6:
	GoTypesVec[126] = &info_Reader

GO VECSET FOR TYPE *go.std.net.textproto/Reader from -:
	GoTypesVec[44] = &info_PtrTo_Reader

GO VECSET FOR TYPE go.std.net.textproto/Writer from _tests/big/src/net/textproto/writer.go:15:6:
	GoTypesVec[127] = &info_Writer

GO VECSET FOR TYPE *go.std.net.textproto/Writer from -:
	GoTypesVec[45] = &info_PtrTo_Writer

GO ENSURE-LOADED FOR textproto:
	EnsureLoaded("go.std.bufio")  // E.g. from: _tests/big/src/net/textproto/writer.go:8:2
	EnsureLoaded("go.std.bytes")  // E.g. from: _tests/big/src/net/textproto/reader.go:9:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/textproto/writer.go:9:2
	EnsureLoaded("go.std.io")  // E.g. from: _tests/big/src/net/textproto/writer.go:10:2
	EnsureLoaded("go.std.io.ioutil")  // E.g. from: _tests/big/src/net/textproto/reader.go:11:2
	EnsureLoaded("go.std.net")  // E.g. from: _tests/big/src/net/textproto/textproto.go:32:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/textproto/reader.go:12:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/textproto/reader.go:13:2
	EnsureLoaded("go.std.sync")  // E.g. from: _tests/big/src/net/textproto/pipeline.go:8:2

GO TYPE net/url.Error from net/url/url.go:
func ExtractGoObjectError(args []Object, index int) *_url.Error {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Error:
			return &r
		case *_url.Error:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Error]"))
}

func _mapToError(o Map) *_url.Error {
	return &_url.Error{}
}

func _vectorToError(o *Vector) *_url.Error {
	return &_url.Error{
		Op: AssertString(o.Nth(0), "").S,
		URL: AssertString(o.Nth(1), "").S,
		Err: _errors.New(AssertString(o.Nth(2), "").S),
	}
}

func _ConstructError(_v Object) *_url.Error {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Error:
			return &_g
		case *_url.Error:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToError(_o.(Map))
	case *Vector:
		return _vectorToError(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Error] or: Map or Vector"))
}

func ExtractGo_go_std_net_url__Error(rcvr, arg string, args *ArraySeq, n int) (res _url.Error) {
	a := CheckGoNth(rcvr, "go.std.net.url/Error", arg, args, n).O
	res, ok := a.(_url.Error)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Error], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/url.EscapeError from net/url/url.go:
func ExtractGoObjectEscapeError(args []Object, index int) *_url.EscapeError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.EscapeError:
			return &r
		case *_url.EscapeError:
			return r
		}
	case String:
		v := _url.EscapeError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.EscapeError]"))
}

func _ConstructEscapeError(_v Object) _url.EscapeError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.EscapeError:
			return _g
		case *_url.EscapeError:
			return *_g
		}
	case String:
		return _url.EscapeError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.EscapeError] or: String"))
}

func ExtractGo_go_std_net_url__EscapeError(rcvr, arg string, args *ArraySeq, n int) (res _url.EscapeError) {
	a := CheckGoNth(rcvr, "go.std.net.url/EscapeError", arg, args, n).O
	res, ok := a.(_url.EscapeError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/EscapeError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/url.InvalidHostError from net/url/url.go:
func ExtractGoObjectInvalidHostError(args []Object, index int) *_url.InvalidHostError {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.InvalidHostError:
			return &r
		case *_url.InvalidHostError:
			return r
		}
	case String:
		v := _url.InvalidHostError(ExtractString(args, index))
		return &v
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.InvalidHostError]"))
}

func _ConstructInvalidHostError(_v Object) _url.InvalidHostError {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.InvalidHostError:
			return _g
		case *_url.InvalidHostError:
			return *_g
		}
	case String:
		return _url.InvalidHostError(_o.S)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.InvalidHostError] or: String"))
}

func ExtractGo_go_std_net_url__InvalidHostError(rcvr, arg string, args *ArraySeq, n int) (res _url.InvalidHostError) {
	a := CheckGoNth(rcvr, "go.std.net.url/InvalidHostError", arg, args, n).O
	res, ok := a.(_url.InvalidHostError)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/InvalidHostError], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/url.URL from net/url/url.go:
func ExtractGoObjectURL(args []Object, index int) *_url.URL {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.URL:
			return &r
		case *_url.URL:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.URL]"))
}

// func _mapToURL(o Map) *_url.URL {
// 	return &_url.URL{}
// }

// func _vectorToURL(o *Vector) *_url.URL {
// 	return &_url.URL{
// 		Scheme: AssertString(o.Nth(0), "").S,
// 		Opaque: AssertString(o.Nth(1), "").S,
// 		User: ABEND048(codegen.go: no conversion from Clojure for *net/url.Userinfo (net/url.Userinfo)),
// 		Host: AssertString(o.Nth(3), "").S,
// 		Path: AssertString(o.Nth(4), "").S,
// 		RawPath: AssertString(o.Nth(5), "").S,
// 		ForceQuery: ToBool(o.Nth(6)),
// 		RawQuery: AssertString(o.Nth(7), "").S,
// 		Fragment: AssertString(o.Nth(8), "").S,
// 	}
// }

// func _ConstructURL(_v Object) *_url.URL {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.URL:
// 			return &_g
// 		case *_url.URL:
// 			return _g
// 		}
// 	case *ArrayMap, *HashMap:
// 		return _mapToURL(_o.(Map))
// 	case *Vector:
// 		return _vectorToURL(_o)
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.URL] or: Map or Vector"))
// }

func ExtractGo_go_std_net_url__URL(rcvr, arg string, args *ArraySeq, n int) (res _url.URL) {
	a := CheckGoNth(rcvr, "go.std.net.url/URL", arg, args, n).O
	res, ok := a.(_url.URL)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/URL], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/url.Userinfo from net/url/url.go:
func ExtractGoObjectUserinfo(args []Object, index int) *_url.Userinfo {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Userinfo:
			return &r
		case *_url.Userinfo:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Userinfo]"))
}

func _mapToUserinfo(o Map) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _vectorToUserinfo(o *Vector) *_url.Userinfo {
	return &_url.Userinfo{}
}

func _ConstructUserinfo(_v Object) *_url.Userinfo {
	switch _o := _v.(type) {
	case GoObject:
		switch _g := _o.O.(type) {
		case _url.Userinfo:
			return &_g
		case *_url.Userinfo:
			return _g
		}
	case *ArrayMap, *HashMap:
		return _mapToUserinfo(_o.(Map))
	case *Vector:
		return _vectorToUserinfo(_o)
	}
	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Userinfo] or: Map or Vector"))
}

func ExtractGo_go_std_net_url__Userinfo(rcvr, arg string, args *ArraySeq, n int) (res _url.Userinfo) {
	a := CheckGoNth(rcvr, "go.std.net.url/Userinfo", arg, args, n).O
	res, ok := a.(_url.Userinfo)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Userinfo], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO TYPE net/url.Values from net/url/url.go:
func ExtractGoObjectValues(args []Object, index int) *_url.Values {
	a := args[index]
	switch o := a.(type) {
	case GoObject:
		switch r := o.O.(type) {
		case _url.Values:
			return &r
		case *_url.Values:
			return r
		}
	}
	panic(RT.NewArgTypeError(index, a, "GoObject[net/url.Values]"))
}

// func _ConstructValues(_v Object) _url.Values {
// 	switch _o := _v.(type) {
// 	case GoObject:
// 		switch _g := _o.O.(type) {
// 		case _url.Values:
// 			return _g
// 		case *_url.Values:
// 			return *_g
// 		}
// 	default:
// 		return _url.Values(_o.ABEND674(codegen.go: unknown underlying type *ast.MapType for Values))
// 	}
// 	panic(RT.NewArgTypeError(0, _v, "GoObject[url.Values] or: whatever"))
// }

func ExtractGo_go_std_net_url__Values(rcvr, arg string, args *ArraySeq, n int) (res _url.Values) {
	a := CheckGoNth(rcvr, "go.std.net.url/Values", arg, args, n).O
	res, ok := a.(_url.Values)
	if !ok {
		panic(RT.NewError(fmt.Sprintf("Argument %d passed to %s should be type GoObject[go.std.net.url/Values], but is GoObject[%s]",
			n, rcvr, GoTypeToString(_reflect.TypeOf(a)))))
	}
	return
}

GO FUNC net/url.Parse from net/url/url.go:
func __parse(__rawurl string) Object {
	_res1, _res2 := _url.Parse(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery from net/url/url.go:
func __parseQuery(__query string) Object {
	_res1, _res2 := _url.ParseQuery(__query)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseRequestURI from net/url/url.go:
func __parseRequestURI(__rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(__rawurl)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape from net/url/url.go:
func __pathUnescape(__s string) Object {
	_res1, _res2 := _url.PathUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape from net/url/url.go:
func __queryUnescape(__s string) Object {
	_res1, _res2 := _url.QueryUnescape(__s)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User from net/url/url.go:
func __user(__username string) Object {
	_res := _url.User(__username)
	return MakeGoObject(_res)
}

GO FUNC net/url.UserPassword from net/url/url.go:
func __userPassword(__username string, __password string) Object {
	_res := _url.UserPassword(__username, __password)
	return MakeGoObject(_res)
}

GO FUNC net/url.__escapeError_Error from net/url/url.go:
func __escapeError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.EscapeError)Error()", args, 0, 0)
	_res := o.O.(_url.EscapeError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__invalidHostError_Error from net/url/url.go:
func __invalidHostError_Error(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.InvalidHostError)Error()", args, 0, 0)
	_res := o.O.(_url.InvalidHostError).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Error from net/url/url.go:
func __ptrTo_Error_Error(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Error()", args, 0, 0)
	_res := o.O.(*_url.Error).Error()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Error_Temporary from net/url/url.go:
func __ptrTo_Error_Temporary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Temporary()", args, 0, 0)
	_res := o.O.(*_url.Error).Temporary()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_Error_Timeout from net/url/url.go:
func __ptrTo_Error_Timeout(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Error)Timeout()", args, 0, 0)
	_res := o.O.(*_url.Error).Timeout()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_EscapedPath from net/url/url.go:
func __ptrTo_URL_EscapedPath(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)EscapedPath()", args, 0, 0)
	_res := o.O.(*_url.URL).EscapedPath()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Hostname from net/url/url.go:
func __ptrTo_URL_Hostname(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Hostname()", args, 0, 0)
	_res := o.O.(*_url.URL).Hostname()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_IsAbs from net/url/url.go:
func __ptrTo_URL_IsAbs(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)IsAbs()", args, 0, 0)
	_res := o.O.(*_url.URL).IsAbs()
	return MakeBoolean(_res)
}

GO FUNC net/url.__ptrTo_URL_MarshalBinary from net/url/url.go:
func __ptrTo_URL_MarshalBinary(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)MarshalBinary()", args, 0, 0)
	text, err := o.O.(*_url.URL).MarshalBinary()
	_res := EmptyVector()
	_vec1 := EmptyVector()
	for _, _elem1 := range text {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Parse from net/url/url.go:
func __ptrTo_URL_Parse(o GoObject, args Object) Object {
	_argList := CheckGoArity("(*_net/url.URL)Parse()", args, 1, 1)
	__ref := ExtractGoString("(*_net/url.URL)Parse()", "__ref", _argList, 0)
	_res1, _res2 := o.O.(*_url.URL).Parse(__ref)
	_res := EmptyVector()
	_res = _res.Conjoin(MakeGoObject(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.__ptrTo_URL_Port from net/url/url.go:
func __ptrTo_URL_Port(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Port()", args, 0, 0)
	_res := o.O.(*_url.URL).Port()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_Query from net/url/url.go:
func __ptrTo_URL_Query(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)Query()", args, 0, 0)
	_res := o.O.(*_url.URL).Query()
	return MakeGoObject(_res)
}

GO FUNC net/url.__ptrTo_URL_RequestURI from net/url/url.go:
func __ptrTo_URL_RequestURI(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)RequestURI()", args, 0, 0)
	_res := o.O.(*_url.URL).RequestURI()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_ResolveReference from net/url/url.go:
// func __ptrTo_URL_ResolveReference(o GoObject, args Object) Object {
// 	_argList := CheckGoArity("(*_net/url.URL)ResolveReference()", args, 1, 1)
// 	ABEND644(pre.go: unsupported built-in type *ast.StarExpr for __ref at: _tests/big/src/net/url/url.go:973:36)
// 	_res := o.O.(*_url.URL).ResolveReference(__ref)
// 	return MakeGoObject(_res)
// }

GO FUNC net/url.__ptrTo_URL_String from net/url/url.go:
func __ptrTo_URL_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.URL)String()", args, 0, 0)
	_res := o.O.(*_url.URL).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_URL_UnmarshalBinary from net/url/url.go:
// func __ptrTo_URL_UnmarshalBinary(o GoObject, args Object) Object {
// (ABEND902(pre.go: custom-runtime routine not implemented: ConvertToArrayOfbyte(__text)))}

GO FUNC net/url.__ptrTo_Userinfo_Password from net/url/url.go:
func __ptrTo_Userinfo_Password(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Password()", args, 0, 0)
	_res1, _res2 := o.O.(*_url.Userinfo).Password()
	_res := EmptyVector()
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBoolean(_res2))
	return _res
}

GO FUNC net/url.__ptrTo_Userinfo_String from net/url/url.go:
func __ptrTo_Userinfo_String(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)String()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).String()
	return MakeString(_res)
}

GO FUNC net/url.__ptrTo_Userinfo_Username from net/url/url.go:
func __ptrTo_Userinfo_Username(o GoObject, args Object) Object {
	CheckGoArity("(*_net/url.Userinfo)Username()", args, 0, 0)
	_res := o.O.(*_url.Userinfo).Username()
	return MakeString(_res)
}

GO FUNC net/url.__values_Add from net/url/url.go:
// func __values_Add(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Del from net/url/url.go:
// func __values_Del(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO FUNC net/url.__values_Encode from net/url/url.go:
func __values_Encode(o GoObject, args Object) Object {
	CheckGoArity("(_net/url.Values)Encode()", args, 0, 0)
	_res := o.O.(_url.Values).Encode()
	return MakeString(_res)
}

GO FUNC net/url.__values_Get from net/url/url.go:
func __values_Get(o GoObject, args Object) Object {
	_argList := CheckGoArity("(_net/url.Values)Get()", args, 1, 1)
	__key := ExtractGoString("(_net/url.Values)Get()", "__key", _argList, 0)
	_res := o.O.(_url.Values).Get(__key)
	return MakeString(_res)
}

GO FUNC net/url.__values_Set from net/url/url.go:
// func __values_Set(o GoObject, args Object) Object {
// 	...ABEND275: TODO...
// }

GO VARDEF FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
var info_Error GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Error from -:
var info_PtrTo_Error GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
var info_EscapeError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/EscapeError from -:
var info_PtrTo_EscapeError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
var info_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/InvalidHostError from -:
var info_PtrTo_InvalidHostError GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
var info_URL GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/URL from -:
var info_PtrTo_URL GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
var info_Userinfo GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Userinfo from -:
var info_PtrTo_Userinfo GoTypeInfo

GO VARDEF FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
var info_Values GoTypeInfo

GO VARDEF FOR TYPE *go.std.net.url/Values from -:
var info_PtrTo_Values GoTypeInfo

GO INFO FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
	info_Error = GoTypeInfo{Name: "go.std.net.url/Error",
		GoType: &GoType{T: &info_Error},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/Error from -:
	info_PtrTo_Error = GoTypeInfo{Name: "*go.std.net.url/Error",
		GoType: &GoType{T: &info_PtrTo_Error},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __ptrTo_Error_Error, "", "1.0", NewVectorFrom()),
			"Temporary": MakeGoReceiver("Temporary", __ptrTo_Error_Temporary, "", "1.0", NewVectorFrom()),
			"Timeout": MakeGoReceiver("Timeout", __ptrTo_Error_Timeout, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
	info_EscapeError = GoTypeInfo{Name: "go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_EscapeError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __escapeError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.url/EscapeError from -:
	info_PtrTo_EscapeError = GoTypeInfo{Name: "*go.std.net.url/EscapeError",
		GoType: &GoType{T: &info_PtrTo_EscapeError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
	info_InvalidHostError = GoTypeInfo{Name: "go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_InvalidHostError},
		Members: GoMembers{
			"Error": MakeGoReceiver("Error", __invalidHostError_Error, "", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE *go.std.net.url/InvalidHostError from -:
	info_PtrTo_InvalidHostError = GoTypeInfo{Name: "*go.std.net.url/InvalidHostError",
		GoType: &GoType{T: &info_PtrTo_InvalidHostError},
		Members: GoMembers{
		}}


GO INFO FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
	info_URL = GoTypeInfo{Name: "go.std.net.url/URL",
		GoType: &GoType{T: &info_URL},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/URL from -:
	info_PtrTo_URL = GoTypeInfo{Name: "*go.std.net.url/URL",
		GoType: &GoType{T: &info_PtrTo_URL},
		Members: GoMembers{
			"EscapedPath": MakeGoReceiver("EscapedPath", __ptrTo_URL_EscapedPath, "EscapedPath returns the escaped form of u.Path.\nIn general there are multiple possible escaped forms of any path.\nEscapedPath returns u.RawPath when it is a valid escaping of u.Path.\nOtherwise EscapedPath ignores u.RawPath and computes an escaped\nform on its own.\nThe String and RequestURI methods use EscapedPath to construct\ntheir results.\nIn general, code should call EscapedPath instead of\nreading u.RawPath directly.\n", "1.0", NewVectorFrom()),
			"Hostname": MakeGoReceiver("Hostname", __ptrTo_URL_Hostname, "Hostname returns u.Host, without any port number.\n\nIf Host is an IPv6 literal with a port number, Hostname returns the\nIPv6 literal without the square brackets. IPv6 literals may include\na zone identifier.\n", "1.0", NewVectorFrom()),
			"IsAbs": MakeGoReceiver("IsAbs", __ptrTo_URL_IsAbs, "IsAbs reports whether the URL is absolute.\nAbsolute means that it has a non-empty scheme.\n", "1.0", NewVectorFrom()),
			"MarshalBinary": MakeGoReceiver("MarshalBinary", __ptrTo_URL_MarshalBinary, "", "1.0", NewVectorFrom()),
			"Parse": MakeGoReceiver("Parse", __ptrTo_URL_Parse, "Parse parses a URL in the context of the receiver. The provided URL\nmay be relative or absolute. Parse returns nil, err on parse\nfailure, otherwise its return value is the same as ResolveReference.\n", "1.0", NewVectorFrom(MakeSymbol("ref"))),
			"Port": MakeGoReceiver("Port", __ptrTo_URL_Port, "Port returns the port part of u.Host, without the leading colon.\nIf u.Host doesn't contain a port, Port returns an empty string.\n", "1.0", NewVectorFrom()),
			"Query": MakeGoReceiver("Query", __ptrTo_URL_Query, "Query parses RawQuery and returns the corresponding values.\nIt silently discards malformed value pairs.\nTo check errors use ParseQuery.\n", "1.0", NewVectorFrom()),
			"RequestURI": MakeGoReceiver("RequestURI", __ptrTo_URL_RequestURI, "RequestURI returns the encoded path?query or opaque?query\nstring that would be used in an HTTP request for u.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_URL_String, "String reassembles the URL into a valid URL string.\nThe general form of the result is one of:\n\n\tscheme:opaque?query#fragment\n\tscheme://userinfo@host/path?query#fragment\n\nIf u.Opaque is non-empty, String uses the first form;\notherwise it uses the second form.\nTo obtain the path, String uses u.EscapedPath().\n\nIn the second form, the following rules apply:\n\t- if u.Scheme is empty, scheme: is omitted.\n\t- if u.User is nil, userinfo@ is omitted.\n\t- if u.Host is empty, host/ is omitted.\n\t- if u.Scheme and u.Host are empty and u.User is nil,\n\t   the entire scheme://userinfo@host/ is omitted.\n\t- if u.Host is non-empty and u.Path begins with a /,\n\t   the form host/path does not add its own /.\n\t- if u.RawQuery is empty, ?query is omitted.\n\t- if u.Fragment is empty, #fragment is omitted.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
	info_Userinfo = GoTypeInfo{Name: "go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_Userinfo},
		Members: GoMembers{
		}}


GO INFO FOR TYPE *go.std.net.url/Userinfo from -:
	info_PtrTo_Userinfo = GoTypeInfo{Name: "*go.std.net.url/Userinfo",
		GoType: &GoType{T: &info_PtrTo_Userinfo},
		Members: GoMembers{
			"Password": MakeGoReceiver("Password", __ptrTo_Userinfo_Password, "Password returns the password in case it is set, and whether it is set.\n", "1.0", NewVectorFrom()),
			"String": MakeGoReceiver("String", __ptrTo_Userinfo_String, "String returns the encoded userinfo information in the standard form\nof \"username[:password]\".\n", "1.0", NewVectorFrom()),
			"Username": MakeGoReceiver("Username", __ptrTo_Userinfo_Username, "Username returns the username.\n", "1.0", NewVectorFrom()),
		}}


GO INFO FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
	info_Values = GoTypeInfo{Name: "go.std.net.url/Values",
		GoType: &GoType{T: &info_Values},
		Members: GoMembers{
			"Encode": MakeGoReceiver("Encode", __values_Encode, "Encode encodes the values into ``URL encoded'' form\n(\"bar=baz&foo=quux\") sorted by key.\n", "1.0", NewVectorFrom()),
			"Get": MakeGoReceiver("Get", __values_Get, "Get gets the first value associated with the given key.\nIf there are no values associated with the key, Get returns\nthe empty string. To access multiple values, use the map\ndirectly.\n", "1.0", NewVectorFrom(MakeSymbol("key"))),
		}}


GO INFO FOR TYPE *go.std.net.url/Values from -:
	info_PtrTo_Values = GoTypeInfo{Name: "*go.std.net.url/Values",
		GoType: &GoType{T: &info_PtrTo_Values},
		Members: GoMembers{
		}}


GO VECSET FOR TYPE go.std.net.url/Error from _tests/big/src/net/url/url.go:22:6:
	GoTypesVec[128] = &info_Error

GO VECSET FOR TYPE *go.std.net.url/Error from -:
	GoTypesVec[46] = &info_PtrTo_Error

GO VECSET FOR TYPE go.std.net.url/EscapeError from _tests/big/src/net/url/url.go:84:6:
	GoTypesVec[129] = &info_EscapeError

GO VECSET FOR TYPE *go.std.net.url/EscapeError from -:
	GoTypesVec[47] = &info_PtrTo_EscapeError

GO VECSET FOR TYPE go.std.net.url/InvalidHostError from _tests/big/src/net/url/url.go:90:6:
	GoTypesVec[130] = &info_InvalidHostError

GO VECSET FOR TYPE *go.std.net.url/InvalidHostError from -:
	GoTypesVec[48] = &info_PtrTo_InvalidHostError

GO VECSET FOR TYPE go.std.net.url/URL from _tests/big/src/net/url/url.go:344:6:
	GoTypesVec[131] = &info_URL

GO VECSET FOR TYPE *go.std.net.url/URL from -:
	GoTypesVec[49] = &info_PtrTo_URL

GO VECSET FOR TYPE go.std.net.url/Userinfo from _tests/big/src/net/url/url.go:378:6:
	GoTypesVec[132] = &info_Userinfo

GO VECSET FOR TYPE *go.std.net.url/Userinfo from -:
	GoTypesVec[50] = &info_PtrTo_Userinfo

GO VECSET FOR TYPE go.std.net.url/Values from _tests/big/src/net/url/url.go:804:6:
	GoTypesVec[133] = &info_Values

GO VECSET FOR TYPE *go.std.net.url/Values from -:
	GoTypesVec[51] = &info_PtrTo_Values

GO ENSURE-LOADED FOR url:
	EnsureLoaded("go.std.errors")  // E.g. from: _tests/big/src/net/url/url.go:14:2
	EnsureLoaded("go.std.fmt")  // E.g. from: _tests/big/src/net/url/url.go:15:2
	EnsureLoaded("go.std.sort")  // E.g. from: _tests/big/src/net/url/url.go:16:2
	EnsureLoaded("go.std.strconv")  // E.g. from: _tests/big/src/net/url/url.go:17:2
	EnsureLoaded("go.std.strings")  // E.g. from: _tests/big/src/net/url/url.go:18:2

Adding 15 custom imports to _tests/gold/amd64-linux/joker/custom.go
Adding 15 custom loaded libraries to _tests/gold/amd64-linux/joker/core/data/customlibs.joke
Adding 184 types to _tests/gold/amd64-linux/joker/core/goswitch.go
Generated file goswitch.go:
// Auto-modified by gostd at (omitted for testing)

package core

import (
	"net"
	"net/http"
	"net/http/cgi"
	"net/http/cookiejar"
	"net/http/httptest"
	"net/http/httptrace"
	"net/http/httputil"
	"net/mail"
	"net/rpc"
	"net/smtp"
	"net/textproto"
	"net/url"
)

var GoTypesVec [184]*GoTypeInfo

func SwitchGoType(g interface{}) int {
	switch g.(type) {
	case *cgi.Handler:
		return 0
	case *cookiejar.Jar:
		return 1
	case *cookiejar.Options:
		return 2
	case *httptest.ResponseRecorder:
		return 3
	case *httptest.Server:
		return 4
	case *httptrace.ClientTrace:
		return 5
	case *httptrace.DNSDoneInfo:
		return 6
	case *httptrace.DNSStartInfo:
		return 7
	case *httptrace.GotConnInfo:
		return 8
	case *httptrace.WroteRequestInfo:
		return 9
	case *httputil.ClientConn:
		return 10
	case *httputil.ReverseProxy:
		return 11
	case *httputil.ServerConn:
		return 12
	case *http.Client:
		return 13
	case *http.ConnState:
		return 14
	case *http.Cookie:
		return 15
	case *http.Dir:
		return 16
	case *http.HandlerFunc:
		return 17
	case *http.Header:
		return 18
	case *http.ProtocolError:
		return 19
	case *http.PushOptions:
		return 20
	case *http.Request:
		return 21
	case *http.Response:
		return 22
	case *http.SameSite:
		return 23
	case *http.ServeMux:
		return 24
	case *http.Server:
		return 25
	case *http.Transport:
		return 26
	case *mail.Address:
		return 27
	case *mail.AddressParser:
		return 28
	case *mail.Header:
		return 29
	case *mail.Message:
		return 30
	case *rpc.Call:
		return 31
	case *rpc.Client:
		return 32
	case *rpc.Request:
		return 33
	case *rpc.Response:
		return 34
	case *rpc.Server:
		return 35
	case *rpc.ServerError:
		return 36
	case *smtp.Client:
		return 37
	case *smtp.ServerInfo:
		return 38
	case *textproto.Conn:
		return 39
	case *textproto.Error:
		return 40
	case *textproto.MIMEHeader:
		return 41
	case *textproto.Pipeline:
		return 42
	case *textproto.ProtocolError:
		return 43
	case *textproto.Reader:
		return 44
	case *textproto.Writer:
		return 45
	case *url.Error:
		return 46
	case *url.EscapeError:
		return 47
	case *url.InvalidHostError:
		return 48
	case *url.URL:
		return 49
	case *url.Userinfo:
		return 50
	case *url.Values:
		return 51
	case *net.AddrError:
		return 52
	case *net.Buffers:
		return 53
	case *net.DNSConfigError:
		return 54
	case *net.DNSError:
		return 55
	case *net.Dialer:
		return 56
	case *net.Flags:
		return 57
	case *net.HardwareAddr:
		return 58
	case *net.IP:
		return 59
	case *net.IPAddr:
		return 60
	case *net.IPConn:
		return 61
	case *net.IPMask:
		return 62
	case *net.IPNet:
		return 63
	case *net.Interface:
		return 64
	case *net.InvalidAddrError:
		return 65
	case *net.ListenConfig:
		return 66
	case *net.MX:
		return 67
	case *net.NS:
		return 68
	case *net.OpError:
		return 69
	case *net.ParseError:
		return 70
	case *net.Resolver:
		return 71
	case *net.SRV:
		return 72
	case *net.TCPAddr:
		return 73
	case *net.TCPConn:
		return 74
	case *net.TCPListener:
		return 75
	case *net.UDPAddr:
		return 76
	case *net.UDPConn:
		return 77
	case *net.UnixAddr:
		return 78
	case *net.UnixConn:
		return 79
	case *net.UnixListener:
		return 80
	case *net.UnknownNetworkError:
		return 81
	case cgi.Handler:
		return 82
	case cookiejar.Jar:
		return 83
	case cookiejar.Options:
		return 84
	case httptest.ResponseRecorder:
		return 85
	case httptest.Server:
		return 86
	case httptrace.ClientTrace:
		return 87
	case httptrace.DNSDoneInfo:
		return 88
	case httptrace.DNSStartInfo:
		return 89
	case httptrace.GotConnInfo:
		return 90
	case httptrace.WroteRequestInfo:
		return 91
	case httputil.ClientConn:
		return 92
	case httputil.ReverseProxy:
		return 93
	case httputil.ServerConn:
		return 94
	case http.Client:
		return 95
	case http.ConnState:
		return 96
	case http.Cookie:
		return 97
	case http.Dir:
		return 98
	case http.HandlerFunc:
		return 99
	case http.Header:
		return 100
	case http.ProtocolError:
		return 101
	case http.PushOptions:
		return 102
	case http.Request:
		return 103
	case http.Response:
		return 104
	case http.SameSite:
		return 105
	case http.ServeMux:
		return 106
	case http.Server:
		return 107
	case http.Transport:
		return 108
	case mail.Address:
		return 109
	case mail.AddressParser:
		return 110
	case mail.Header:
		return 111
	case mail.Message:
		return 112
	case rpc.Call:
		return 113
	case rpc.Client:
		return 114
	case rpc.Request:
		return 115
	case rpc.Response:
		return 116
	case rpc.Server:
		return 117
	case rpc.ServerError:
		return 118
	case smtp.Client:
		return 119
	case smtp.ServerInfo:
		return 120
	case textproto.Conn:
		return 121
	case textproto.Error:
		return 122
	case textproto.MIMEHeader:
		return 123
	case textproto.Pipeline:
		return 124
	case textproto.ProtocolError:
		return 125
	case textproto.Reader:
		return 126
	case textproto.Writer:
		return 127
	case url.Error:
		return 128
	case url.EscapeError:
		return 129
	case url.InvalidHostError:
		return 130
	case url.URL:
		return 131
	case url.Userinfo:
		return 132
	case url.Values:
		return 133
	case net.AddrError:
		return 134
	case net.Buffers:
		return 135
	case net.DNSConfigError:
		return 136
	case net.DNSError:
		return 137
	case net.Dialer:
		return 138
	case net.Flags:
		return 139
	case net.HardwareAddr:
		return 140
	case net.IP:
		return 141
	case net.IPAddr:
		return 142
	case net.IPConn:
		return 143
	case net.IPMask:
		return 144
	case net.IPNet:
		return 145
	case net.Interface:
		return 146
	case net.InvalidAddrError:
		return 147
	case net.ListenConfig:
		return 148
	case net.MX:
		return 149
	case net.NS:
		return 150
	case net.OpError:
		return 151
	case net.ParseError:
		return 152
	case net.Resolver:
		return 153
	case net.SRV:
		return 154
	case net.TCPAddr:
		return 155
	case net.TCPConn:
		return 156
	case net.TCPListener:
		return 157
	case net.UDPAddr:
		return 158
	case net.UDPConn:
		return 159
	case net.UnixAddr:
		return 160
	case net.UnixConn:
		return 161
	case net.UnixListener:
		return 162
	case net.UnknownNetworkError:
		return 163
	case net.Conn:  // Specificity=8
		return 164
	case net.PacketConn:  // Specificity=7
		return 165
	case rpc.ClientCodec:  // Specificity=4
		return 166
	case rpc.ServerCodec:  // Specificity=4
		return 167
	case http.ResponseWriter:  // Specificity=3
		return 168
	case net.Error:  // Specificity=3
		return 169
	case net.Listener:  // Specificity=3
		return 170
	case cookiejar.PublicSuffixList:  // Specificity=2
		return 171
	case httputil.BufferPool:  // Specificity=2
		return 172
	case http.CookieJar:  // Specificity=2
		return 173
	case http.File:  // Specificity=2
		return 174
	case smtp.Auth:  // Specificity=2
		return 175
	case net.Addr:  // Specificity=2
		return 176
	case http.CloseNotifier:  // Specificity=1
		return 177
	case http.FileSystem:  // Specificity=1
		return 178
	case http.Flusher:  // Specificity=1
		return 179
	case http.Handler:  // Specificity=1
		return 180
	case http.Hijacker:  // Specificity=1
		return 181
	case http.Pusher:  // Specificity=1
		return 182
	case http.RoundTripper:  // Specificity=1
		return 183
	}
	return -1
}
ABENDs: 987(113) 047(95) 902(39) 275(34) 048(32) 674(29) 042(27) 675(18) 907(14) 644(9) 883(3) 906(3) 124(1) 908(1) 909(1)
Totals: functions=421 generated=249 (59.14%)
          non-receivers=148 (35.15%) generated=81 (54.73%)
          receivers=273 (64.85%) generated=149 (54.58%)
          methods=50 (11.88%) generated=19 (38.00%)
        types=102 generated=41 (40.20%)
          hits expr=0 alias=0 fullname=95
        constants=91 generated=91 (100.00%)
        variables=48 generated=48 (100.00%)
