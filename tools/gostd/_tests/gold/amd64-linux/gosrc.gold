Walking from GO.link/src to GO.link/src/archive
Processing archive:
Walking from GO.link/src to GO.link/src/archive/tar
Processing archive/tar:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/archive/tar/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/tar/common.go) => true <nil>
Ignoring test code in strconv_test.go
Matchfile(GO.link/src/archive/tar/stat_actime1.go) => true <nil>
Matchfile(GO.link/src/archive/tar/writer.go) => true <nil>
Matchfile(GO.link/src/archive/tar/strconv.go) => true <nil>
Ignoring test code in tar_test.go
Matchfile(GO.link/src/archive/tar/stat_actime2.go) => false <nil>
Matchfile(GO.link/src/archive/tar/format.go) => true <nil>
Matchfile(GO.link/src/archive/tar/stat_unix.go) => true <nil>
Processing package=archive/tar:
Excluding GO.link/src/archive/tar/testdata
Walking from GO.link/src to GO.link/src/archive/zip
Processing archive/zip:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/archive/zip/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/archive/zip/struct.go) => true <nil>
Ignoring test code in zip_test.go
Matchfile(GO.link/src/archive/zip/writer.go) => true <nil>
Matchfile(GO.link/src/archive/zip/register.go) => true <nil>
Processing package=archive/zip:
Excluding GO.link/src/archive/zip/testdata
Walking from GO.link/src to GO.link/src/bufio
Processing bufio:
Ignoring test code in example_test.go
Ignoring test code in scan_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/bufio/bufio.go) => true <nil>
Matchfile(GO.link/src/bufio/scan.go) => true <nil>
Ignoring test code in bufio_test.go
Processing package=bufio:
Excluding GO.link/src/builtin
Walking from GO.link/src to GO.link/src/bytes
Processing bytes:
Ignoring test code in example_test.go
Matchfile(GO.link/src/bytes/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in buffer_test.go
Ignoring test code in compare_test.go
Matchfile(GO.link/src/bytes/buffer.go) => true <nil>
Matchfile(GO.link/src/bytes/bytes_decl.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in boundary_test.go
Ignoring test code in bytes_test.go
Matchfile(GO.link/src/bytes/bytes.go) => true <nil>
Processing package=bytes:
Excluding GO.link/src/cmd
Walking from GO.link/src to GO.link/src/compress
Processing compress:
Walking from GO.link/src to GO.link/src/compress/bzip2
Processing compress/bzip2:
Ignoring test code in bzip2_test.go
Matchfile(GO.link/src/compress/bzip2/bzip2.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/huffman.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/move_to_front.go) => true <nil>
Matchfile(GO.link/src/compress/bzip2/bit_reader.go) => true <nil>
Processing package=compress/bzip2:
Excluding GO.link/src/compress/bzip2/testdata
Walking from GO.link/src to GO.link/src/compress/flate
Processing compress/flate:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Ignoring test code in reader_test.go
Matchfile(GO.link/src/compress/flate/dict_decoder.go) => true <nil>
Matchfile(GO.link/src/compress/flate/deflate.go) => true <nil>
Matchfile(GO.link/src/compress/flate/huffman_code.go) => true <nil>
Matchfile(GO.link/src/compress/flate/inflate.go) => true <nil>
Ignoring test code in huffman_bit_writer_test.go
Ignoring test code in inflate_test.go
Matchfile(GO.link/src/compress/flate/token.go) => true <nil>
Matchfile(GO.link/src/compress/flate/huffman_bit_writer.go) => true <nil>
Matchfile(GO.link/src/compress/flate/deflatefast.go) => true <nil>
Ignoring test code in deflate_test.go
Ignoring test code in dict_decoder_test.go
Ignoring test code in flate_test.go
Processing package=compress/flate:
Excluding GO.link/src/compress/flate/testdata
Walking from GO.link/src to GO.link/src/compress/gzip
Processing compress/gzip:
Ignoring test code in example_test.go
Ignoring test code in gunzip_test.go
Matchfile(GO.link/src/compress/gzip/gunzip.go) => true <nil>
Ignoring test code in gzip_test.go
Ignoring test code in issue14937_test.go
Matchfile(GO.link/src/compress/gzip/gzip.go) => true <nil>
Processing package=compress/gzip:
Excluding GO.link/src/compress/gzip/testdata
Walking from GO.link/src to GO.link/src/compress/lzw
Processing compress/lzw:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/lzw/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/compress/lzw/writer.go) => true <nil>
Processing package=compress/lzw:
Excluding GO.link/src/compress/testdata
Walking from GO.link/src to GO.link/src/compress/zlib
Processing compress/zlib:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/compress/zlib/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/compress/zlib/writer.go) => true <nil>
Processing package=compress/zlib:
Walking from GO.link/src to GO.link/src/container
Processing container:
Walking from GO.link/src to GO.link/src/container/heap
Processing container/heap:
Ignoring test code in example_pq_test.go
Matchfile(GO.link/src/container/heap/heap.go) => true <nil>
Ignoring test code in example_intheap_test.go
Ignoring test code in heap_test.go
Processing package=container/heap:
Walking from GO.link/src to GO.link/src/container/list
Processing container/list:
Ignoring test code in example_test.go
Matchfile(GO.link/src/container/list/list.go) => true <nil>
Ignoring test code in list_test.go
Processing package=container/list:
Walking from GO.link/src to GO.link/src/container/ring
Processing container/ring:
Ignoring test code in ring_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/container/ring/ring.go) => true <nil>
Processing package=container/ring:
Walking from GO.link/src to GO.link/src/context
Processing context:
Ignoring test code in example_test.go
Ignoring test code in net_test.go
Ignoring test code in x_test.go
Ignoring test code in context_test.go
Ignoring test code in benchmark_test.go
Matchfile(GO.link/src/context/context.go) => true <nil>
Processing package=context:
Walking from GO.link/src to GO.link/src/crypto
Processing crypto:
Ignoring test code in issue21104_test.go
Matchfile(GO.link/src/crypto/crypto.go) => true <nil>
Processing package=crypto:
Walking from GO.link/src to GO.link/src/crypto/aes
Processing crypto/aes:
Matchfile(GO.link/src/crypto/aes/cipher_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/gcm_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/modes.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_ppc64le.go) => false <nil>
Ignoring test code in aes_test.go
Matchfile(GO.link/src/crypto/aes/cipher_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cbc_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/cipher.go) => true <nil>
Ignoring test code in modes_test.go
Matchfile(GO.link/src/crypto/aes/ctr_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/aes/aes_gcm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/cipher_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/const.go) => true <nil>
Matchfile(GO.link/src/crypto/aes/block.go) => true <nil>
Processing package=crypto/aes:
Walking from GO.link/src to GO.link/src/crypto/cipher
Processing crypto/cipher:
Ignoring test code in ctr_test.go
Ignoring test code in xor_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/cipher/cbc.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/xor.go) => true <nil>
Ignoring test code in cipher_test.go
Matchfile(GO.link/src/crypto/cipher/cfb.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/io.go) => true <nil>
Ignoring test code in ctr_aes_test.go
Ignoring test code in gcm_test.go
Ignoring test code in cfb_test.go
Ignoring test code in cbc_aes_test.go
Matchfile(GO.link/src/crypto/cipher/ctr.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/ofb.go) => true <nil>
Matchfile(GO.link/src/crypto/cipher/cipher.go) => true <nil>
Ignoring test code in benchmark_test.go
Ignoring test code in common_test.go
Matchfile(GO.link/src/crypto/cipher/gcm.go) => true <nil>
Ignoring test code in ofb_test.go
Processing package=crypto/cipher:
Walking from GO.link/src to GO.link/src/crypto/des
Processing crypto/des:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/des/cipher.go) => true <nil>
Ignoring test code in des_test.go
Matchfile(GO.link/src/crypto/des/const.go) => true <nil>
Matchfile(GO.link/src/crypto/des/block.go) => true <nil>
Processing package=crypto/des:
Walking from GO.link/src to GO.link/src/crypto/dsa
Processing crypto/dsa:
Matchfile(GO.link/src/crypto/dsa/dsa.go) => true <nil>
Ignoring test code in dsa_test.go
Processing package=crypto/dsa:
Walking from GO.link/src to GO.link/src/crypto/ecdsa
Processing crypto/ecdsa:
Ignoring test code in example_test.go
Ignoring test code in ecdsa_test.go
Matchfile(GO.link/src/crypto/ecdsa/ecdsa.go) => true <nil>
Processing package=crypto/ecdsa:
Excluding GO.link/src/crypto/ecdsa/testdata
Walking from GO.link/src to GO.link/src/crypto/elliptic
Processing crypto/elliptic:
Matchfile(GO.link/src/crypto/elliptic/p256.go) => false <nil>
Ignoring test code in p224_test.go
Ignoring test code in fuzz_test.go
Matchfile(GO.link/src/crypto/elliptic/p256_generic.go) => false <nil>
Ignoring test code in elliptic_test.go
Matchfile(GO.link/src/crypto/elliptic/elliptic.go) => true <nil>
Matchfile(GO.link/src/crypto/elliptic/p224.go) => true <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/elliptic/p256_s390x.go) => false <nil>
Processing package=crypto/elliptic:
Walking from GO.link/src to GO.link/src/crypto/hmac
Processing crypto/hmac:
Matchfile(GO.link/src/crypto/hmac/hmac.go) => true <nil>
Ignoring test code in hmac_test.go
Processing package=crypto/hmac:
Excluding GO.link/src/crypto/internal
Walking from GO.link/src to GO.link/src/crypto/md5
Processing crypto/md5:
Matchfile(GO.link/src/crypto/md5/md5block.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in md5_test.go
Matchfile(GO.link/src/crypto/md5/md5block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/md5/md5block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/md5/gen.go) => false <nil>
Matchfile(GO.link/src/crypto/md5/md5.go) => true <nil>
Processing package=crypto/md5:
Walking from GO.link/src to GO.link/src/crypto/rand
Processing crypto/rand:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/rand/util.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_unix.go) => true <nil>
Ignoring test code in rand_linux_test.go
Matchfile(GO.link/src/crypto/rand/rand_windows.go) => false <nil>
Ignoring test code in rand_test.go
Matchfile(GO.link/src/crypto/rand/eagain.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_linux.go) => true <nil>
Matchfile(GO.link/src/crypto/rand/rand_openbsd.go) => false <nil>
Matchfile(GO.link/src/crypto/rand/rand_js.go) => false <nil>
Ignoring test code in util_test.go
Processing package=crypto/rand:
Walking from GO.link/src to GO.link/src/crypto/rc4
Processing crypto/rc4:
Matchfile(GO.link/src/crypto/rc4/rc4.go) => true <nil>
Matchfile(GO.link/src/crypto/rc4/rc4_asm.go) => true <nil>
Matchfile(GO.link/src/crypto/rc4/rc4_ref.go) => false <nil>
Ignoring test code in rc4_test.go
Processing package=crypto/rc4:
Walking from GO.link/src to GO.link/src/crypto/rsa
Processing crypto/rsa:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/rsa/rsa.go) => true <nil>
Ignoring test code in pkcs1v15_test.go
Matchfile(GO.link/src/crypto/rsa/pss.go) => true <nil>
Matchfile(GO.link/src/crypto/rsa/pkcs1v15.go) => true <nil>
Ignoring test code in rsa_test.go
Ignoring test code in pss_test.go
Processing package=crypto/rsa:
Excluding GO.link/src/crypto/rsa/testdata
Walking from GO.link/src to GO.link/src/crypto/sha1
Processing crypto/sha1:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block_arm64.go) => false <nil>
Ignoring test code in sha1_test.go
Ignoring test code in issue15617_test.go
Matchfile(GO.link/src/crypto/sha1/sha1block.go) => true <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_generic.go) => false <nil>
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha1/sha1.go) => true <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_amd64.go) => true <nil>
Matchfile(GO.link/src/crypto/sha1/sha1block_decl.go) => false <nil>
Processing package=crypto/sha1:
Walking from GO.link/src to GO.link/src/crypto/sha256
Processing crypto/sha256:
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_amd64.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_decl.go) => true <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_arm64.go) => false <nil>
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha256/sha256block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha256/sha256.go) => true <nil>
Ignoring test code in sha256_test.go
Processing package=crypto/sha256:
Walking from GO.link/src to GO.link/src/crypto/sha512
Processing crypto/sha512:
Matchfile(GO.link/src/crypto/sha512/sha512block_s390x.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_amd64.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512.go) => true <nil>
Ignoring test code in sha512_test.go
Ignoring test code in fallback_test.go
Matchfile(GO.link/src/crypto/sha512/sha512block_generic.go) => false <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block.go) => true <nil>
Matchfile(GO.link/src/crypto/sha512/sha512block_decl.go) => false <nil>
Processing package=crypto/sha512:
Walking from GO.link/src to GO.link/src/crypto/subtle
Processing crypto/subtle:
Matchfile(GO.link/src/crypto/subtle/constant_time.go) => true <nil>
Ignoring test code in constant_time_test.go
Processing package=crypto/subtle:
Walking from GO.link/src to GO.link/src/crypto/tls
Processing crypto/tls:
Matchfile(GO.link/src/crypto/tls/prf.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/tls/generate_cert.go) => false <nil>
Ignoring test code in handshake_messages_test.go
Matchfile(GO.link/src/crypto/tls/conn.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/key_agreement.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/cipher_suites.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/common.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/handshake_server.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/tls.go) => true <nil>
Ignoring test code in auth_test.go
Matchfile(GO.link/src/crypto/tls/handshake_client.go) => true <nil>
Ignoring test code in handshake_client_test.go
Matchfile(GO.link/src/crypto/tls/alert.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/auth.go) => true <nil>
Ignoring test code in prf_test.go
Matchfile(GO.link/src/crypto/tls/handshake_messages.go) => true <nil>
Matchfile(GO.link/src/crypto/tls/ticket.go) => true <nil>
Ignoring test code in tls_test.go
Ignoring test code in handshake_test.go
Ignoring test code in conn_test.go
Ignoring test code in handshake_server_test.go
Processing package=crypto/tls:
Excluding GO.link/src/crypto/tls/testdata
Walking from GO.link/src to GO.link/src/crypto/x509
Processing crypto/x509:
Ignoring test code in root_darwin_test.go
Matchfile(GO.link/src/crypto/x509/root_nocgo_darwin.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/crypto/x509/root_nacl.go) => false <nil>
Ignoring test code in sec1_test.go
Ignoring test code in pem_decrypt_test.go
Matchfile(GO.link/src/crypto/x509/root_plan9.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/x509_test_import.go) => false <nil>
Ignoring test code in pkcs8_test.go
Matchfile(GO.link/src/crypto/x509/sec1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/cert_pool.go) => true <nil>
Ignoring test code in name_constraints_test.go
Matchfile(GO.link/src/crypto/x509/root_windows.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_bsd.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/pkcs1.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/x509.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_cgo_darwin.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/verify.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_js.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_solaris.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_armx.go) => false <nil>
Ignoring test code in root_unix_test.go
Matchfile(GO.link/src/crypto/x509/root_linux.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_unix.go) => true <nil>
Ignoring test code in verify_test.go
Matchfile(GO.link/src/crypto/x509/pkcs8.go) => true <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/root_darwin_arm_gen.go) => false <nil>
Matchfile(GO.link/src/crypto/x509/pem_decrypt.go) => true <nil>
Ignoring test code in x509_test.go
Processing package=crypto/x509:
Walking from GO.link/src to GO.link/src/crypto/x509/pkix
Processing crypto/x509/pkix:
Matchfile(GO.link/src/crypto/x509/pkix/pkix.go) => true <nil>
Processing package=crypto/x509/pkix:
Excluding GO.link/src/crypto/x509/testdata
Walking from GO.link/src to GO.link/src/database
Processing database:
Walking from GO.link/src to GO.link/src/database/sql
Processing database/sql:
Ignoring test code in example_test.go
Matchfile(GO.link/src/database/sql/sql.go) => true <nil>
Matchfile(GO.link/src/database/sql/convert.go) => true <nil>
Ignoring test code in sql_test.go
Ignoring test code in convert_test.go
Ignoring test code in fakedb_test.go
Matchfile(GO.link/src/database/sql/ctxutil.go) => true <nil>
Processing package=database/sql:
Walking from GO.link/src to GO.link/src/database/sql/driver
Processing database/sql/driver:
Matchfile(GO.link/src/database/sql/driver/types.go) => true <nil>
Matchfile(GO.link/src/database/sql/driver/driver.go) => true <nil>
Ignoring test code in types_test.go
Processing package=database/sql/driver:
Walking from GO.link/src to GO.link/src/debug
Processing debug:
Walking from GO.link/src to GO.link/src/debug/dwarf
Processing debug/dwarf:
Matchfile(GO.link/src/debug/dwarf/type.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/buf.go) => true <nil>
Ignoring test code in line_test.go
Ignoring test code in type_test.go
Matchfile(GO.link/src/debug/dwarf/class_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/tag_string.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in entry_test.go
Matchfile(GO.link/src/debug/dwarf/unit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/entry.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/typeunit.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/attr_string.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/line.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/open.go) => true <nil>
Matchfile(GO.link/src/debug/dwarf/const.go) => true <nil>
Processing package=debug/dwarf:
Excluding GO.link/src/debug/dwarf/testdata
Walking from GO.link/src to GO.link/src/debug/elf
Processing debug/elf:
Matchfile(GO.link/src/debug/elf/reader.go) => true <nil>
Matchfile(GO.link/src/debug/elf/elf.go) => true <nil>
Ignoring test code in symbols_test.go
Ignoring test code in elf_test.go
Matchfile(GO.link/src/debug/elf/file.go) => true <nil>
Ignoring test code in file_test.go
Processing package=debug/elf:
Excluding GO.link/src/debug/elf/testdata
Walking from GO.link/src to GO.link/src/debug/gosym
Processing debug/gosym:
Ignoring test code in symtab_test.go
Matchfile(GO.link/src/debug/gosym/pclntab.go) => true <nil>
Ignoring test code in pclntab_test.go
Matchfile(GO.link/src/debug/gosym/symtab.go) => true <nil>
Processing package=debug/gosym:
Walking from GO.link/src to GO.link/src/debug/macho
Processing debug/macho:
Matchfile(GO.link/src/debug/macho/macho.go) => true <nil>
Matchfile(GO.link/src/debug/macho/fat.go) => true <nil>
Matchfile(GO.link/src/debug/macho/reloctype_string.go) => true <nil>
Matchfile(GO.link/src/debug/macho/file.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/macho/reloctype.go) => true <nil>
Processing package=debug/macho:
Excluding GO.link/src/debug/macho/testdata
Walking from GO.link/src to GO.link/src/debug/pe
Processing debug/pe:
Matchfile(GO.link/src/debug/pe/section.go) => true <nil>
Matchfile(GO.link/src/debug/pe/file.go) => true <nil>
Ignoring test code in file_cgo_test.go
Ignoring test code in file_test.go
Matchfile(GO.link/src/debug/pe/string.go) => true <nil>
Matchfile(GO.link/src/debug/pe/symbol.go) => true <nil>
Matchfile(GO.link/src/debug/pe/pe.go) => true <nil>
Processing package=debug/pe:
Excluding GO.link/src/debug/pe/testdata
Walking from GO.link/src to GO.link/src/debug/plan9obj
Processing debug/plan9obj:
Matchfile(GO.link/src/debug/plan9obj/plan9obj.go) => true <nil>
Matchfile(GO.link/src/debug/plan9obj/file.go) => true <nil>
Ignoring test code in file_test.go
Processing package=debug/plan9obj:
Excluding GO.link/src/debug/plan9obj/testdata
Walking from GO.link/src to GO.link/src/encoding
Processing encoding:
Matchfile(GO.link/src/encoding/encoding.go) => true <nil>
Processing package=encoding:
Walking from GO.link/src to GO.link/src/encoding/ascii85
Processing encoding/ascii85:
Matchfile(GO.link/src/encoding/ascii85/ascii85.go) => true <nil>
Ignoring test code in ascii85_test.go
Processing package=encoding/ascii85:
Walking from GO.link/src to GO.link/src/encoding/asn1
Processing encoding/asn1:
Ignoring test code in marshal_test.go
Matchfile(GO.link/src/encoding/asn1/common.go) => true <nil>
Matchfile(GO.link/src/encoding/asn1/asn1.go) => true <nil>
Ignoring test code in asn1_test.go
Matchfile(GO.link/src/encoding/asn1/marshal.go) => true <nil>
Processing package=encoding/asn1:
Walking from GO.link/src to GO.link/src/encoding/base32
Processing encoding/base32:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/base32/base32.go) => true <nil>
Ignoring test code in base32_test.go
Processing package=encoding/base32:
Walking from GO.link/src to GO.link/src/encoding/base64
Processing encoding/base64:
Ignoring test code in example_test.go
Ignoring test code in base64_test.go
Matchfile(GO.link/src/encoding/base64/base64.go) => true <nil>
Processing package=encoding/base64:
Walking from GO.link/src to GO.link/src/encoding/binary
Processing encoding/binary:
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/binary/varint.go) => true <nil>
Matchfile(GO.link/src/encoding/binary/binary.go) => true <nil>
Ignoring test code in binary_test.go
Ignoring test code in varint_test.go
Processing package=encoding/binary:
Walking from GO.link/src to GO.link/src/encoding/csv
Processing encoding/csv:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/encoding/csv/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/encoding/csv/writer.go) => true <nil>
Processing package=encoding/csv:
Walking from GO.link/src to GO.link/src/encoding/gob
Processing encoding/gob:
Matchfile(GO.link/src/encoding/gob/type.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/gob/debug.go) => false <nil>
Ignoring test code in type_test.go
Matchfile(GO.link/src/encoding/gob/encode.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/dump.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/decoder.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/decgen.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/enc_helpers.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/decode.go) => true <nil>
Ignoring test code in timing_test.go
Ignoring test code in codec_test.go
Ignoring test code in gobencdec_test.go
Ignoring test code in encoder_test.go
Ignoring test code in example_encdec_test.go
Matchfile(GO.link/src/encoding/gob/encgen.go) => false <nil>
Matchfile(GO.link/src/encoding/gob/doc.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/error.go) => true <nil>
Matchfile(GO.link/src/encoding/gob/dec_helpers.go) => true <nil>
Ignoring test code in example_interface_test.go
Matchfile(GO.link/src/encoding/gob/encoder.go) => true <nil>
Processing package=encoding/gob:
Walking from GO.link/src to GO.link/src/encoding/hex
Processing encoding/hex:
Ignoring test code in example_test.go
Ignoring test code in hex_test.go
Matchfile(GO.link/src/encoding/hex/hex.go) => true <nil>
Processing package=encoding/hex:
Walking from GO.link/src to GO.link/src/encoding/json
Processing encoding/json:
Ignoring test code in example_test.go
Ignoring test code in fold_test.go
Matchfile(GO.link/src/encoding/json/encode.go) => true <nil>
Ignoring test code in bench_test.go
Matchfile(GO.link/src/encoding/json/tags.go) => true <nil>
Matchfile(GO.link/src/encoding/json/decode.go) => true <nil>
Ignoring test code in tagkey_test.go
Ignoring test code in tags_test.go
Matchfile(GO.link/src/encoding/json/tables.go) => true <nil>
Ignoring test code in number_test.go
Ignoring test code in decode_test.go
Matchfile(GO.link/src/encoding/json/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Matchfile(GO.link/src/encoding/json/fold.go) => true <nil>
Ignoring test code in example_marshaling_test.go
Ignoring test code in stream_test.go
Matchfile(GO.link/src/encoding/json/stream.go) => true <nil>
Matchfile(GO.link/src/encoding/json/indent.go) => true <nil>
Ignoring test code in encode_test.go
Processing package=encoding/json:
Excluding GO.link/src/encoding/json/testdata
Walking from GO.link/src to GO.link/src/encoding/pem
Processing encoding/pem:
Ignoring test code in pem_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/encoding/pem/pem.go) => true <nil>
Processing package=encoding/pem:
Walking from GO.link/src to GO.link/src/encoding/xml
Processing encoding/xml:
Ignoring test code in example_test.go
Ignoring test code in marshal_test.go
Matchfile(GO.link/src/encoding/xml/read.go) => true <nil>
Ignoring test code in atom_test.go
Matchfile(GO.link/src/encoding/xml/typeinfo.go) => true <nil>
Ignoring test code in xml_test.go
Ignoring test code in read_test.go
Matchfile(GO.link/src/encoding/xml/xml.go) => true <nil>
Matchfile(GO.link/src/encoding/xml/marshal.go) => true <nil>
Processing package=encoding/xml:
Walking from GO.link/src to GO.link/src/errors
Processing errors:
Ignoring test code in example_test.go
Matchfile(GO.link/src/errors/errors.go) => true <nil>
Ignoring test code in errors_test.go
Processing package=errors:
Walking from GO.link/src to GO.link/src/expvar
Processing expvar:
Ignoring test code in expvar_test.go
Matchfile(GO.link/src/expvar/expvar.go) => true <nil>
Processing package=expvar:
Walking from GO.link/src to GO.link/src/flag
Processing flag:
Ignoring test code in flag_test.go
Ignoring test code in example_test.go
Ignoring test code in example_value_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/flag/flag.go) => true <nil>
Processing package=flag:
Walking from GO.link/src to GO.link/src/fmt
Processing fmt:
Ignoring test code in example_test.go
Matchfile(GO.link/src/fmt/print.go) => true <nil>
Ignoring test code in scan_test.go
Ignoring test code in stringer_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/fmt/scan.go) => true <nil>
Matchfile(GO.link/src/fmt/doc.go) => true <nil>
Matchfile(GO.link/src/fmt/format.go) => true <nil>
Ignoring test code in fmt_test.go
Processing package=fmt:
Walking from GO.link/src to GO.link/src/go
Processing go:
Walking from GO.link/src to GO.link/src/go/ast
Processing go/ast:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/ast/import.go) => true <nil>
Matchfile(GO.link/src/go/ast/print.go) => true <nil>
Matchfile(GO.link/src/go/ast/commentmap.go) => true <nil>
Ignoring test code in commentmap_test.go
Ignoring test code in filter_test.go
Ignoring test code in print_test.go
Matchfile(GO.link/src/go/ast/walk.go) => true <nil>
Matchfile(GO.link/src/go/ast/filter.go) => true <nil>
Matchfile(GO.link/src/go/ast/resolve.go) => true <nil>
Matchfile(GO.link/src/go/ast/scope.go) => true <nil>
Ignoring test code in ast_test.go
Matchfile(GO.link/src/go/ast/ast.go) => true <nil>
Processing package=go/ast:
Walking from GO.link/src to GO.link/src/go/build
Processing go/build:
Matchfile(GO.link/src/go/build/build.go) => true <nil>
Matchfile(GO.link/src/go/build/read.go) => true <nil>
Ignoring test code in deps_test.go
Ignoring test code in read_test.go
Matchfile(GO.link/src/go/build/zcgo.go) => true <nil>
Ignoring test code in syslist_test.go
Matchfile(GO.link/src/go/build/syslist.go) => true <nil>
Matchfile(GO.link/src/go/build/gccgo.go) => false <nil>
Matchfile(GO.link/src/go/build/gc.go) => true <nil>
Matchfile(GO.link/src/go/build/doc.go) => true <nil>
Ignoring test code in build_test.go
Processing package=go/build:
Excluding GO.link/src/go/build/testdata
Walking from GO.link/src to GO.link/src/go/constant
Processing go/constant:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/constant/value.go) => true <nil>
Ignoring test code in value_test.go
Processing package=go/constant:
Walking from GO.link/src to GO.link/src/go/doc
Processing go/doc:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/doc/synopsis.go) => true <nil>
Matchfile(GO.link/src/go/doc/reader.go) => true <nil>
Ignoring test code in comment_test.go
Matchfile(GO.link/src/go/doc/example.go) => true <nil>
Matchfile(GO.link/src/go/doc/filter.go) => true <nil>
Matchfile(GO.link/src/go/doc/comment.go) => true <nil>
Ignoring test code in doc_test.go
Matchfile(GO.link/src/go/doc/exports.go) => true <nil>
Matchfile(GO.link/src/go/doc/headscan.go) => false <nil>
Matchfile(GO.link/src/go/doc/doc.go) => true <nil>
Ignoring test code in synopsis_test.go
Processing package=go/doc:
Excluding GO.link/src/go/doc/testdata
Walking from GO.link/src to GO.link/src/go/format
Processing go/format:
Ignoring test code in example_test.go
Ignoring test code in format_test.go
Matchfile(GO.link/src/go/format/internal.go) => true <nil>
Matchfile(GO.link/src/go/format/format.go) => true <nil>
Processing package=go/format:
Walking from GO.link/src to GO.link/src/go/importer
Processing go/importer:
Ignoring test code in importer_test.go
Matchfile(GO.link/src/go/importer/importer.go) => true <nil>
Processing package=go/importer:
Excluding GO.link/src/go/internal
Walking from GO.link/src to GO.link/src/go/parser
Processing go/parser:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/parser/parser.go) => true <nil>
Matchfile(GO.link/src/go/parser/interface.go) => true <nil>
Ignoring test code in performance_test.go
Ignoring test code in short_test.go
Ignoring test code in parser_test.go
Ignoring test code in error_test.go
Processing package=go/parser:
Excluding GO.link/src/go/parser/testdata
Walking from GO.link/src to GO.link/src/go/printer
Processing go/printer:
Ignoring test code in example_test.go
Ignoring test code in printer_test.go
Matchfile(GO.link/src/go/printer/nodes.go) => true <nil>
Ignoring test code in performance_test.go
Matchfile(GO.link/src/go/printer/printer.go) => true <nil>
Processing package=go/printer:
Excluding GO.link/src/go/printer/testdata
Walking from GO.link/src to GO.link/src/go/scanner
Processing go/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/go/scanner/errors.go) => true <nil>
Matchfile(GO.link/src/go/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=go/scanner:
Walking from GO.link/src to GO.link/src/go/token
Processing go/token:
Ignoring test code in example_test.go
Ignoring test code in position_test.go
Matchfile(GO.link/src/go/token/position.go) => true <nil>
Matchfile(GO.link/src/go/token/token.go) => true <nil>
Matchfile(GO.link/src/go/token/serialize.go) => true <nil>
Ignoring test code in serialize_test.go
Processing package=go/token:
Walking from GO.link/src to GO.link/src/go/types
Processing go/types:
Matchfile(GO.link/src/go/types/type.go) => true <nil>
Matchfile(GO.link/src/go/types/builtins.go) => true <nil>
Matchfile(GO.link/src/go/types/eval.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in resolver_test.go
Ignoring test code in hilbert_test.go
Matchfile(GO.link/src/go/types/api.go) => true <nil>
Matchfile(GO.link/src/go/types/methodset.go) => true <nil>
Matchfile(GO.link/src/go/types/return.go) => true <nil>
Matchfile(GO.link/src/go/types/interfaces.go) => true <nil>
Matchfile(GO.link/src/go/types/decl.go) => true <nil>
Ignoring test code in eval_test.go
Matchfile(GO.link/src/go/types/resolver.go) => true <nil>
Matchfile(GO.link/src/go/types/predicates.go) => true <nil>
Matchfile(GO.link/src/go/types/objset.go) => true <nil>
Matchfile(GO.link/src/go/types/operand.go) => true <nil>
Matchfile(GO.link/src/go/types/expr.go) => true <nil>
Matchfile(GO.link/src/go/types/errors.go) => true <nil>
Matchfile(GO.link/src/go/types/package.go) => true <nil>
Matchfile(GO.link/src/go/types/typestring.go) => true <nil>
Matchfile(GO.link/src/go/types/call.go) => true <nil>
Ignoring test code in check_test.go
Matchfile(GO.link/src/go/types/assignments.go) => true <nil>
Ignoring test code in object_test.go
Matchfile(GO.link/src/go/types/gotype.go) => false <nil>
Matchfile(GO.link/src/go/types/sizes.go) => true <nil>
Matchfile(GO.link/src/go/types/universe.go) => true <nil>
Ignoring test code in typestring_test.go
Ignoring test code in token_test.go
Matchfile(GO.link/src/go/types/object.go) => true <nil>
Ignoring test code in sizes_test.go
Matchfile(GO.link/src/go/types/lookup.go) => true <nil>
Matchfile(GO.link/src/go/types/typexpr.go) => true <nil>
Ignoring test code in self_test.go
Matchfile(GO.link/src/go/types/stmt.go) => true <nil>
Ignoring test code in issues_test.go
Matchfile(GO.link/src/go/types/check.go) => true <nil>
Ignoring test code in exprstring_test.go
Matchfile(GO.link/src/go/types/conversions.go) => true <nil>
Matchfile(GO.link/src/go/types/selection.go) => true <nil>
Ignoring test code in builtins_test.go
Ignoring test code in stdlib_test.go
Ignoring test code in api_test.go
Matchfile(GO.link/src/go/types/scope.go) => true <nil>
Matchfile(GO.link/src/go/types/exprstring.go) => true <nil>
Matchfile(GO.link/src/go/types/labels.go) => true <nil>
Matchfile(GO.link/src/go/types/initorder.go) => true <nil>
Processing package=go/types:
Excluding GO.link/src/go/types/testdata
Walking from GO.link/src to GO.link/src/hash
Processing hash:
Ignoring test code in example_test.go
Ignoring test code in marshal_test.go
Matchfile(GO.link/src/hash/hash.go) => true <nil>
Processing package=hash:
Walking from GO.link/src to GO.link/src/hash/adler32
Processing hash/adler32:
Ignoring test code in adler32_test.go
Matchfile(GO.link/src/hash/adler32/adler32.go) => true <nil>
Processing package=hash/adler32:
Walking from GO.link/src to GO.link/src/hash/crc32
Processing hash/crc32:
Ignoring test code in example_test.go
Matchfile(GO.link/src/hash/crc32/crc32_otherarch.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_generic.go) => true <nil>
Ignoring test code in crc32_test.go
Matchfile(GO.link/src/hash/crc32/crc32_amd64.go) => true <nil>
Matchfile(GO.link/src/hash/crc32/gen_const_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32.go) => true <nil>
Matchfile(GO.link/src/hash/crc32/crc32_ppc64le.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_arm64.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_amd64p32.go) => false <nil>
Matchfile(GO.link/src/hash/crc32/crc32_s390x.go) => false <nil>
Processing package=hash/crc32:
Walking from GO.link/src to GO.link/src/hash/crc64
Processing hash/crc64:
Ignoring test code in crc64_test.go
Matchfile(GO.link/src/hash/crc64/crc64.go) => true <nil>
Processing package=hash/crc64:
Walking from GO.link/src to GO.link/src/hash/fnv
Processing hash/fnv:
Ignoring test code in fnv_test.go
Matchfile(GO.link/src/hash/fnv/fnv.go) => true <nil>
Processing package=hash/fnv:
Walking from GO.link/src to GO.link/src/html
Processing html:
Ignoring test code in example_test.go
Matchfile(GO.link/src/html/escape.go) => true <nil>
Ignoring test code in entity_test.go
Ignoring test code in escape_test.go
Matchfile(GO.link/src/html/entity.go) => true <nil>
Processing package=html:
Walking from GO.link/src to GO.link/src/html/template
Processing html/template:
Ignoring test code in example_test.go
Ignoring test code in url_test.go
Ignoring test code in template_test.go
Ignoring test code in js_test.go
Matchfile(GO.link/src/html/template/url.go) => true <nil>
Matchfile(GO.link/src/html/template/urlpart_string.go) => true <nil>
Matchfile(GO.link/src/html/template/escape.go) => true <nil>
Ignoring test code in content_test.go
Matchfile(GO.link/src/html/template/js.go) => true <nil>
Matchfile(GO.link/src/html/template/html.go) => true <nil>
Matchfile(GO.link/src/html/template/jsctx_string.go) => true <nil>
Ignoring test code in transition_test.go
Ignoring test code in escape_test.go
Matchfile(GO.link/src/html/template/delim_string.go) => true <nil>
Ignoring test code in html_test.go
Matchfile(GO.link/src/html/template/attr.go) => true <nil>
Ignoring test code in examplefiles_test.go
Matchfile(GO.link/src/html/template/element_string.go) => true <nil>
Matchfile(GO.link/src/html/template/state_string.go) => true <nil>
Matchfile(GO.link/src/html/template/css.go) => true <nil>
Matchfile(GO.link/src/html/template/attr_string.go) => true <nil>
Ignoring test code in css_test.go
Matchfile(GO.link/src/html/template/doc.go) => true <nil>
Matchfile(GO.link/src/html/template/transition.go) => true <nil>
Matchfile(GO.link/src/html/template/error.go) => true <nil>
Matchfile(GO.link/src/html/template/content.go) => true <nil>
Matchfile(GO.link/src/html/template/context.go) => true <nil>
Matchfile(GO.link/src/html/template/template.go) => true <nil>
Ignoring test code in clone_test.go
Processing package=html/template:
Walking from GO.link/src to GO.link/src/image
Processing image:
Matchfile(GO.link/src/image/ycbcr.go) => true <nil>
Ignoring test code in geom_test.go
Ignoring test code in ycbcr_test.go
Matchfile(GO.link/src/image/names.go) => true <nil>
Ignoring test code in decode_example_test.go
Ignoring test code in decode_test.go
Ignoring test code in image_test.go
Matchfile(GO.link/src/image/format.go) => true <nil>
Matchfile(GO.link/src/image/image.go) => true <nil>
Matchfile(GO.link/src/image/geom.go) => true <nil>
Processing package=image:
Walking from GO.link/src to GO.link/src/image/color
Processing image/color:
Matchfile(GO.link/src/image/color/ycbcr.go) => true <nil>
Matchfile(GO.link/src/image/color/color.go) => true <nil>
Ignoring test code in ycbcr_test.go
Ignoring test code in color_test.go
Processing package=image/color:
Walking from GO.link/src to GO.link/src/image/color/palette
Processing image/color/palette:
Matchfile(GO.link/src/image/color/palette/generate.go) => true <nil>
Matchfile(GO.link/src/image/color/palette/gen.go) => false <nil>
Matchfile(GO.link/src/image/color/palette/palette.go) => true <nil>
Processing package=image/color/palette:
Walking from GO.link/src to GO.link/src/image/draw
Processing image/draw:
Ignoring test code in example_test.go
Ignoring test code in bench_test.go
Matchfile(GO.link/src/image/draw/draw.go) => true <nil>
Ignoring test code in clip_test.go
Ignoring test code in draw_test.go
Processing package=image/draw:
Walking from GO.link/src to GO.link/src/image/gif
Processing image/gif:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/gif/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/image/gif/writer.go) => true <nil>
Processing package=image/gif:
Excluding GO.link/src/image/internal
Walking from GO.link/src to GO.link/src/image/jpeg
Processing image/jpeg:
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/jpeg/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in dct_test.go
Matchfile(GO.link/src/image/jpeg/scan.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/writer.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/huffman.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/idct.go) => true <nil>
Matchfile(GO.link/src/image/jpeg/fdct.go) => true <nil>
Processing package=image/jpeg:
Walking from GO.link/src to GO.link/src/image/png
Processing image/png:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/image/png/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in paeth_test.go
Matchfile(GO.link/src/image/png/writer.go) => true <nil>
Matchfile(GO.link/src/image/png/paeth.go) => true <nil>
Processing package=image/png:
Excluding GO.link/src/image/png/testdata
Excluding GO.link/src/image/testdata
Walking from GO.link/src to GO.link/src/index
Processing index:
Walking from GO.link/src to GO.link/src/index/suffixarray
Processing index/suffixarray:
Matchfile(GO.link/src/index/suffixarray/qsufsort.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in suffixarray_test.go
Matchfile(GO.link/src/index/suffixarray/suffixarray.go) => true <nil>
Processing package=index/suffixarray:
Excluding GO.link/src/internal
Walking from GO.link/src to GO.link/src/io
Processing io:
Ignoring test code in example_test.go
Matchfile(GO.link/src/io/io.go) => true <nil>
Ignoring test code in io_test.go
Matchfile(GO.link/src/io/pipe.go) => true <nil>
Ignoring test code in multi_test.go
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/io/multi.go) => true <nil>
Processing package=io:
Walking from GO.link/src to GO.link/src/io/ioutil
Processing io/ioutil:
Ignoring test code in example_test.go
Ignoring test code in tempfile_test.go
Matchfile(GO.link/src/io/ioutil/tempfile.go) => true <nil>
Matchfile(GO.link/src/io/ioutil/ioutil.go) => true <nil>
Ignoring test code in ioutil_test.go
Processing package=io/ioutil:
Excluding GO.link/src/io/ioutil/testdata
Walking from GO.link/src to GO.link/src/log
Processing log:
Ignoring test code in example_test.go
Ignoring test code in log_test.go
Matchfile(GO.link/src/log/log.go) => true <nil>
Processing package=log:
Walking from GO.link/src to GO.link/src/log/syslog
Processing log/syslog:
Ignoring test code in example_test.go
Matchfile(GO.link/src/log/syslog/syslog.go) => true <nil>
Ignoring test code in syslog_test.go
Matchfile(GO.link/src/log/syslog/doc.go) => true <nil>
Matchfile(GO.link/src/log/syslog/syslog_unix.go) => true <nil>
Processing package=log/syslog:
Walking from GO.link/src to GO.link/src/math
Processing math:
Matchfile(GO.link/src/math/log1p.go) => true <nil>
Matchfile(GO.link/src/math/modf.go) => true <nil>
Matchfile(GO.link/src/math/erf.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/tanh.go) => true <nil>
Matchfile(GO.link/src/math/hypot.go) => true <nil>
Matchfile(GO.link/src/math/jn.go) => true <nil>
Matchfile(GO.link/src/math/expm1.go) => true <nil>
Matchfile(GO.link/src/math/pow.go) => true <nil>
Matchfile(GO.link/src/math/signbit.go) => true <nil>
Matchfile(GO.link/src/math/copysign.go) => true <nil>
Matchfile(GO.link/src/math/sincos_386.go) => false <nil>
Matchfile(GO.link/src/math/atanh.go) => true <nil>
Matchfile(GO.link/src/math/asinh.go) => true <nil>
Matchfile(GO.link/src/math/cbrt.go) => true <nil>
Matchfile(GO.link/src/math/unsafe.go) => true <nil>
Matchfile(GO.link/src/math/log10.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/math/j0.go) => true <nil>
Ignoring test code in export_s390x_test.go
Matchfile(GO.link/src/math/ldexp.go) => true <nil>
Matchfile(GO.link/src/math/j1.go) => true <nil>
Matchfile(GO.link/src/math/exp.go) => true <nil>
Matchfile(GO.link/src/math/mod.go) => true <nil>
Matchfile(GO.link/src/math/remainder.go) => true <nil>
Matchfile(GO.link/src/math/nextafter.go) => true <nil>
Matchfile(GO.link/src/math/arith_s390x.go) => false <nil>
Matchfile(GO.link/src/math/floor.go) => true <nil>
Matchfile(GO.link/src/math/acosh.go) => true <nil>
Matchfile(GO.link/src/math/sincos.go) => true <nil>
Matchfile(GO.link/src/math/log.go) => true <nil>
Matchfile(GO.link/src/math/atan2.go) => true <nil>
Matchfile(GO.link/src/math/lgamma.go) => true <nil>
Matchfile(GO.link/src/math/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/bits.go) => true <nil>
Matchfile(GO.link/src/math/atan.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Matchfile(GO.link/src/math/tan.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/math/sin.go) => true <nil>
Matchfile(GO.link/src/math/frexp.go) => true <nil>
Matchfile(GO.link/src/math/pow10.go) => true <nil>
Matchfile(GO.link/src/math/dim.go) => true <nil>
Matchfile(GO.link/src/math/exp_asm.go) => true <nil>
Matchfile(GO.link/src/math/sinh.go) => true <nil>
Matchfile(GO.link/src/math/logb.go) => true <nil>
Matchfile(GO.link/src/math/asin.go) => true <nil>
Matchfile(GO.link/src/math/erfinv.go) => true <nil>
Matchfile(GO.link/src/math/const.go) => true <nil>
Matchfile(GO.link/src/math/gamma.go) => true <nil>
Matchfile(GO.link/src/math/abs.go) => true <nil>
Processing package=math:
Walking from GO.link/src to GO.link/src/math/big
Processing math/big:
Matchfile(GO.link/src/math/big/ftoa.go) => true <nil>
Matchfile(GO.link/src/math/big/prime.go) => true <nil>
Matchfile(GO.link/src/math/big/natconv.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/big/roundingmode_string.go) => true <nil>
Ignoring test code in hilbert_test.go
Ignoring test code in gcd_test.go
Ignoring test code in calibrate_test.go
Ignoring test code in int_test.go
Ignoring test code in arith_test.go
Ignoring test code in intconv_test.go
Matchfile(GO.link/src/math/big/ratmarsh.go) => true <nil>
Ignoring test code in floatexample_test.go
Matchfile(GO.link/src/math/big/arith_decl_pure.go) => false <nil>
Ignoring test code in prime_test.go
Ignoring test code in nat_test.go
Ignoring test code in example_rat_test.go
Ignoring test code in bits_test.go
Matchfile(GO.link/src/math/big/arith.go) => true <nil>
Ignoring test code in floatmarsh_test.go
Matchfile(GO.link/src/math/big/floatmarsh.go) => true <nil>
Ignoring test code in ratmarsh_test.go
Matchfile(GO.link/src/math/big/sqrt.go) => true <nil>
Ignoring test code in ratconv_test.go
Matchfile(GO.link/src/math/big/nat.go) => true <nil>
Matchfile(GO.link/src/math/big/arith_decl.go) => true <nil>
Matchfile(GO.link/src/math/big/decimal.go) => true <nil>
Ignoring test code in arith_s390x_test.go
Ignoring test code in rat_test.go
Ignoring test code in floatconv_test.go
Ignoring test code in sqrt_test.go
Matchfile(GO.link/src/math/big/accuracy_string.go) => true <nil>
Matchfile(GO.link/src/math/big/float.go) => true <nil>
Matchfile(GO.link/src/math/big/arith_amd64.go) => true <nil>
Matchfile(GO.link/src/math/big/doc.go) => true <nil>
Matchfile(GO.link/src/math/big/ratconv.go) => true <nil>
Matchfile(GO.link/src/math/big/arith_decl_s390x.go) => false <nil>
Ignoring test code in intmarsh_test.go
Ignoring test code in natconv_test.go
Matchfile(GO.link/src/math/big/intmarsh.go) => true <nil>
Matchfile(GO.link/src/math/big/floatconv.go) => true <nil>
Matchfile(GO.link/src/math/big/rat.go) => true <nil>
Ignoring test code in float_test.go
Matchfile(GO.link/src/math/big/intconv.go) => true <nil>
Ignoring test code in decimal_test.go
Matchfile(GO.link/src/math/big/int.go) => true <nil>
Processing package=math/big:
Walking from GO.link/src to GO.link/src/math/bits
Processing math/bits:
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/bits/bits_tables.go) => true <nil>
Ignoring test code in export_test.go
Ignoring test code in bits_test.go
Matchfile(GO.link/src/math/bits/make_tables.go) => false <nil>
Matchfile(GO.link/src/math/bits/bits.go) => true <nil>
Matchfile(GO.link/src/math/bits/make_examples.go) => false <nil>
Processing package=math/bits:
Walking from GO.link/src to GO.link/src/math/cmplx
Processing math/cmplx:
Ignoring test code in cmath_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/cmplx/phase.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/pow.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/exp.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isinf.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/polar.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/log.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/sqrt.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/tan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/sin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/rect.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/conj.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/asin.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/isnan.go) => true <nil>
Matchfile(GO.link/src/math/cmplx/abs.go) => true <nil>
Processing package=math/cmplx:
Walking from GO.link/src to GO.link/src/math/rand
Processing math/rand:
Ignoring test code in example_test.go
Matchfile(GO.link/src/math/rand/zipf.go) => true <nil>
Matchfile(GO.link/src/math/rand/rng.go) => true <nil>
Matchfile(GO.link/src/math/rand/exp.go) => true <nil>
Matchfile(GO.link/src/math/rand/normal.go) => true <nil>
Ignoring test code in race_test.go
Ignoring test code in rand_test.go
Matchfile(GO.link/src/math/rand/rand.go) => true <nil>
Matchfile(GO.link/src/math/rand/gen_cooked.go) => false <nil>
Ignoring test code in regress_test.go
Processing package=math/rand:
Walking from GO.link/src to GO.link/src/mime
Processing mime:
Matchfile(GO.link/src/mime/type.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in type_test.go
Matchfile(GO.link/src/mime/type_freebsd.go) => false <nil>
Matchfile(GO.link/src/mime/type_dragonfly.go) => false <nil>
Matchfile(GO.link/src/mime/mediatype.go) => true <nil>
Matchfile(GO.link/src/mime/type_windows.go) => false <nil>
Matchfile(GO.link/src/mime/grammar.go) => true <nil>
Matchfile(GO.link/src/mime/type_plan9.go) => false <nil>
Matchfile(GO.link/src/mime/encodedword.go) => true <nil>
Matchfile(GO.link/src/mime/type_openbsd.go) => false <nil>
Ignoring test code in encodedword_test.go
Ignoring test code in mediatype_test.go
Matchfile(GO.link/src/mime/type_unix.go) => true <nil>
Processing package=mime:
Walking from GO.link/src to GO.link/src/mime/multipart
Processing mime/multipart:
Ignoring test code in example_test.go
Ignoring test code in formdata_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/multipart/writer.go) => true <nil>
Matchfile(GO.link/src/mime/multipart/formdata.go) => true <nil>
Ignoring test code in multipart_test.go
Matchfile(GO.link/src/mime/multipart/multipart.go) => true <nil>
Processing package=mime/multipart:
Excluding GO.link/src/mime/multipart/testdata
Walking from GO.link/src to GO.link/src/mime/quotedprintable
Processing mime/quotedprintable:
Ignoring test code in example_test.go
Ignoring test code in writer_test.go
Matchfile(GO.link/src/mime/quotedprintable/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/mime/quotedprintable/writer.go) => true <nil>
Processing package=mime/quotedprintable:
Excluding GO.link/src/mime/testdata
Walking from GO.link/src to GO.link/src/net
Processing net:
Matchfile(GO.link/src/net/conf_netcgo.go) => false <nil>
Ignoring test code in main_cloexec_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/sockopt_bsd.go) => false <nil>
Matchfile(GO.link/src/net/sock_bsd.go) => false <nil>
Matchfile(GO.link/src/net/error_windows.go) => false <nil>
Ignoring test code in unixsock_test.go
Matchfile(GO.link/src/net/interface_darwin.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_windows.go) => false <nil>
Matchfile(GO.link/src/net/iprawsock.go) => true <nil>
Matchfile(GO.link/src/net/tcpsockopt_darwin.go) => false <nil>
Ignoring test code in main_test.go
Matchfile(GO.link/src/net/tcpsockopt_dragonfly.go) => false <nil>
Matchfile(GO.link/src/net/file_plan9.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/net.go) => true <nil>
Matchfile(GO.link/src/net/sendfile_linux.go) => true <nil>
Ignoring test code in udpsock_plan9_test.go
Matchfile(GO.link/src/net/cgo_resnew.go) => true <nil>
Matchfile(GO.link/src/net/splice_stub.go) => false <nil>
Ignoring test code in error_plan9_test.go
Ignoring test code in iprawsock_test.go
Matchfile(GO.link/src/net/sockaddr_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_openbsd.go) => false <nil>
Matchfile(GO.link/src/net/dnsclient_unix.go) => true <nil>
Matchfile(GO.link/src/net/sock_cloexec.go) => true <nil>
Ignoring test code in timeout_test.go
Ignoring test code in lookup_windows_test.go
Ignoring test code in udpsock_test.go
Ignoring test code in rawconn_unix_test.go
Matchfile(GO.link/src/net/sockopt_linux.go) => true <nil>
Matchfile(GO.link/src/net/sock_linux.go) => true <nil>
Ignoring test code in hosts_test.go
Matchfile(GO.link/src/net/lookup_fake.go) => false <nil>
Matchfile(GO.link/src/net/lookup_windows.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_openbsd.go) => false <nil>
Matchfile(GO.link/src/net/unixsock.go) => true <nil>
Matchfile(GO.link/src/net/sockopt_posix.go) => true <nil>
Matchfile(GO.link/src/net/cgo_bsd.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_solaris.go) => false <nil>
Matchfile(GO.link/src/net/interface_stub.go) => false <nil>
Matchfile(GO.link/src/net/hook.go) => true <nil>
Matchfile(GO.link/src/net/cgo_linux.go) => true <nil>
Matchfile(GO.link/src/net/addrselect.go) => true <nil>
Matchfile(GO.link/src/net/mac.go) => true <nil>
Ignoring test code in dnsclient_unix_test.go
Matchfile(GO.link/src/net/iprawsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_unix.go) => true <nil>
Ignoring test code in dnsname_test.go
Ignoring test code in conf_test.go
Matchfile(GO.link/src/net/sockopt_plan9.go) => false <nil>
Ignoring test code in interface_test.go
Ignoring test code in sendfile_test.go
Matchfile(GO.link/src/net/sockoptip_windows.go) => false <nil>
Matchfile(GO.link/src/net/error_unix.go) => true <nil>
Matchfile(GO.link/src/net/fd_windows.go) => false <nil>
Matchfile(GO.link/src/net/error_nacl.go) => false <nil>
Ignoring test code in dnsclient_test.go
Matchfile(GO.link/src/net/tcpsockopt_solaris.go) => false <nil>
Ignoring test code in net_windows_test.go
Matchfile(GO.link/src/net/sockoptip_linux.go) => true <nil>
Matchfile(GO.link/src/net/lookup_unix.go) => true <nil>
Matchfile(GO.link/src/net/interface_solaris.go) => false <nil>
Matchfile(GO.link/src/net/net_fake.go) => false <nil>
Matchfile(GO.link/src/net/tcpsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/parse.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in lookup_test.go
Ignoring test code in main_windows_test.go
Matchfile(GO.link/src/net/interface_bsdvar.go) => false <nil>
Matchfile(GO.link/src/net/interface.go) => true <nil>
Ignoring test code in ipsock_test.go
Matchfile(GO.link/src/net/tcpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/file.go) => true <nil>
Ignoring test code in net_test.go
Ignoring test code in server_test.go
Matchfile(GO.link/src/net/cgo_solaris.go) => false <nil>
Ignoring test code in splice_test.go
Ignoring test code in error_unix_test.go
Ignoring test code in platform_test.go
Ignoring test code in dnsconfig_unix_test.go
Matchfile(GO.link/src/net/cgo_android.go) => false <nil>
Matchfile(GO.link/src/net/sockoptip_bsdvar.go) => false <nil>
Ignoring test code in rawconn_windows_test.go
Matchfile(GO.link/src/net/unixsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/lookup_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sockopt_stub.go) => false <nil>
Matchfile(GO.link/src/net/rawconn.go) => true <nil>
Matchfile(GO.link/src/net/sock_posix.go) => true <nil>
Matchfile(GO.link/src/net/sockoptip_posix.go) => true <nil>
Ignoring test code in write_unix_test.go
Matchfile(GO.link/src/net/splice_linux.go) => true <nil>
Ignoring test code in unixsock_linux_test.go
Ignoring test code in error_posix_test.go
Ignoring test code in listen_test.go
Matchfile(GO.link/src/net/dnsclient.go) => true <nil>
Matchfile(GO.link/src/net/fd_plan9.go) => false <nil>
Matchfile(GO.link/src/net/sendfile_stub.go) => false <nil>
Ignoring test code in dial_test.go
Ignoring test code in interface_linux_test.go
Ignoring test code in tcpsock_test.go
Matchfile(GO.link/src/net/hook_windows.go) => false <nil>
Ignoring test code in ip_test.go
Matchfile(GO.link/src/net/file_stub.go) => false <nil>
Matchfile(GO.link/src/net/fd_unix.go) => true <nil>
Matchfile(GO.link/src/net/ipsock.go) => true <nil>
Ignoring test code in netgo_unix_test.go
Ignoring test code in addrselect_test.go
Matchfile(GO.link/src/net/lookup.go) => true <nil>
Matchfile(GO.link/src/net/tcpsock.go) => true <nil>
Matchfile(GO.link/src/net/pipe.go) => true <nil>
Matchfile(GO.link/src/net/cgo_resold.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_stub.go) => false <nil>
Matchfile(GO.link/src/net/dial.go) => true <nil>
Matchfile(GO.link/src/net/interface_bsd.go) => false <nil>
Ignoring test code in main_unix_test.go
Matchfile(GO.link/src/net/hosts.go) => true <nil>
Ignoring test code in file_test.go
Matchfile(GO.link/src/net/dnsconfig_unix.go) => true <nil>
Matchfile(GO.link/src/net/interface_plan9.go) => false <nil>
Matchfile(GO.link/src/net/interface_windows.go) => false <nil>
Ignoring test code in packetconn_test.go
Matchfile(GO.link/src/net/writev_unix.go) => true <nil>
Matchfile(GO.link/src/net/interface_freebsd.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_windows.go) => false <nil>
Ignoring test code in protoconn_test.go
Ignoring test code in nss_test.go
Ignoring test code in rawconn_test.go
Matchfile(GO.link/src/net/sys_cloexec.go) => false <nil>
Matchfile(GO.link/src/net/tcpsockopt_posix.go) => true <nil>
Matchfile(GO.link/src/net/ip.go) => true <nil>
Matchfile(GO.link/src/net/sendfile_unix_alt.go) => false <nil>
Ignoring test code in dial_unix_test.go
Ignoring test code in main_conf_test.go
Matchfile(GO.link/src/net/interface_linux.go) => true <nil>
Matchfile(GO.link/src/net/error_posix.go) => true <nil>
Matchfile(GO.link/src/net/hook_plan9.go) => false <nil>
Ignoring test code in main_posix_test.go
Matchfile(GO.link/src/net/cgo_sockold.go) => false <nil>
Ignoring test code in cgo_unix_test.go
Matchfile(GO.link/src/net/file_unix.go) => true <nil>
Ignoring test code in mac_test.go
Matchfile(GO.link/src/net/udpsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/file_windows.go) => false <nil>
Matchfile(GO.link/src/net/udpsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_windows.go) => false <nil>
Matchfile(GO.link/src/net/sock_windows.go) => false <nil>
Ignoring test code in pipe_test.go
Ignoring test code in main_plan9_test.go
Matchfile(GO.link/src/net/udpsock.go) => true <nil>
Matchfile(GO.link/src/net/nss.go) => true <nil>
Matchfile(GO.link/src/net/conf.go) => true <nil>
Matchfile(GO.link/src/net/iprawsock_posix.go) => true <nil>
Ignoring test code in interface_unix_test.go
Matchfile(GO.link/src/net/sockopt_windows.go) => false <nil>
Matchfile(GO.link/src/net/ipsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_socknew.go) => true <nil>
Matchfile(GO.link/src/net/port_unix.go) => true <nil>
Matchfile(GO.link/src/net/sock_stub.go) => false <nil>
Ignoring test code in error_test.go
Matchfile(GO.link/src/net/port.go) => true <nil>
Ignoring test code in rawconn_stub_test.go
Ignoring test code in mockserver_test.go
Matchfile(GO.link/src/net/unixsock_plan9.go) => false <nil>
Matchfile(GO.link/src/net/cgo_netbsd.go) => false <nil>
Ignoring test code in port_test.go
Ignoring test code in conn_test.go
Ignoring test code in external_test.go
Matchfile(GO.link/src/net/cgo_stub.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(GO.link/src/net/ipsock_posix.go) => true <nil>
Matchfile(GO.link/src/net/hook_unix.go) => true <nil>
Ignoring test code in tcpsock_unix_test.go
Matchfile(GO.link/src/net/sockoptip_stub.go) => false <nil>
Ignoring test code in main_noconf_test.go
Matchfile(GO.link/src/net/tcpsockopt_unix.go) => true <nil>
Matchfile(GO.link/src/net/error_plan9.go) => false <nil>
Ignoring test code in writev_test.go
Ignoring test code in interface_bsd_test.go
Processing package=net:
Walking from GO.link/src to GO.link/src/net/http
Processing net/http:
Matchfile(GO.link/src/net/http/header.go) => true <nil>
Ignoring test code in response_test.go
Ignoring test code in transport_internal_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/request.go) => true <nil>
Ignoring test code in main_test.go
Ignoring test code in request_test.go
Ignoring test code in cookie_test.go
Ignoring test code in header_test.go
Matchfile(GO.link/src/net/http/roundtrip.go) => true <nil>
Ignoring test code in responsewrite_test.go
Ignoring test code in export_test.go
Ignoring test code in fs_test.go
Matchfile(GO.link/src/net/http/client.go) => true <nil>
Matchfile(GO.link/src/net/http/transport.go) => true <nil>
Matchfile(GO.link/src/net/http/fs.go) => true <nil>
Matchfile(GO.link/src/net/http/triv.go) => false <nil>
Ignoring test code in requestwrite_test.go
Matchfile(GO.link/src/net/http/method.go) => true <nil>
Ignoring test code in sniff_test.go
Ignoring test code in npn_test.go
Matchfile(GO.link/src/net/http/cookie.go) => true <nil>
Ignoring test code in transport_test.go
Matchfile(GO.link/src/net/http/filetransport.go) => true <nil>
Matchfile(GO.link/src/net/http/race.go) => false <nil>
Ignoring test code in filetransport_test.go
Ignoring test code in range_test.go
Matchfile(GO.link/src/net/http/status.go) => true <nil>
Matchfile(GO.link/src/net/http/socks_bundle.go) => true <nil>
Ignoring test code in client_test.go
Matchfile(GO.link/src/net/http/jar.go) => true <nil>
Matchfile(GO.link/src/net/http/sniff.go) => true <nil>
Ignoring test code in transfer_test.go
Matchfile(GO.link/src/net/http/doc.go) => true <nil>
Matchfile(GO.link/src/net/http/h2_bundle.go) => true <nil>
Ignoring test code in http_test.go
Matchfile(GO.link/src/net/http/http.go) => true <nil>
Matchfile(GO.link/src/net/http/transfer.go) => true <nil>
Ignoring test code in clientserver_test.go
Ignoring test code in readrequest_test.go
Ignoring test code in serve_test.go
Matchfile(GO.link/src/net/http/roundtrip_js.go) => false <nil>
Ignoring test code in proxy_test.go
Matchfile(GO.link/src/net/http/server.go) => true <nil>
Matchfile(GO.link/src/net/http/response.go) => true <nil>
Processing package=net/http:
Walking from GO.link/src to GO.link/src/net/http/cgi
Processing net/http/cgi:
Ignoring test code in child_test.go
Ignoring test code in host_test.go
Ignoring test code in matryoshka_test.go
Ignoring test code in posix_test.go
Ignoring test code in plan9_test.go
Matchfile(GO.link/src/net/http/cgi/host.go) => true <nil>
Matchfile(GO.link/src/net/http/cgi/child.go) => true <nil>
Processing package=net/http/cgi:
Excluding GO.link/src/net/http/cgi/testdata
Walking from GO.link/src to GO.link/src/net/http/cookiejar
Processing net/http/cookiejar:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/cookiejar/punycode.go) => true <nil>
Ignoring test code in punycode_test.go
Ignoring test code in jar_test.go
Ignoring test code in dummy_publicsuffix_test.go
Matchfile(GO.link/src/net/http/cookiejar/jar.go) => true <nil>
Processing package=net/http/cookiejar:
Walking from GO.link/src to GO.link/src/net/http/fcgi
Processing net/http/fcgi:
Matchfile(GO.link/src/net/http/fcgi/fcgi.go) => true <nil>
Ignoring test code in fcgi_test.go
Matchfile(GO.link/src/net/http/fcgi/child.go) => true <nil>
Processing package=net/http/fcgi:
Walking from GO.link/src to GO.link/src/net/http/httptest
Processing net/http/httptest:
Matchfile(GO.link/src/net/http/httptest/recorder.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in server_test.go
Matchfile(GO.link/src/net/http/httptest/httptest.go) => true <nil>
Ignoring test code in httptest_test.go
Ignoring test code in recorder_test.go
Matchfile(GO.link/src/net/http/httptest/server.go) => true <nil>
Processing package=net/http/httptest:
Walking from GO.link/src to GO.link/src/net/http/httptrace
Processing net/http/httptrace:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httptrace/trace.go) => true <nil>
Ignoring test code in trace_test.go
Processing package=net/http/httptrace:
Walking from GO.link/src to GO.link/src/net/http/httputil
Processing net/http/httputil:
Ignoring test code in example_test.go
Matchfile(GO.link/src/net/http/httputil/httputil.go) => true <nil>
Matchfile(GO.link/src/net/http/httputil/dump.go) => true <nil>
Ignoring test code in dump_test.go
Matchfile(GO.link/src/net/http/httputil/reverseproxy.go) => true <nil>
Ignoring test code in reverseproxy_test.go
Matchfile(GO.link/src/net/http/httputil/persist.go) => true <nil>
Processing package=net/http/httputil:
Excluding GO.link/src/net/http/internal
Walking from GO.link/src to GO.link/src/net/http/pprof
Processing net/http/pprof:
Ignoring test code in pprof_test.go
Matchfile(GO.link/src/net/http/pprof/pprof.go) => true <nil>
Processing package=net/http/pprof:
Excluding GO.link/src/net/http/testdata
Excluding GO.link/src/net/internal
Walking from GO.link/src to GO.link/src/net/mail
Processing net/mail:
Ignoring test code in example_test.go
Ignoring test code in message_test.go
Matchfile(GO.link/src/net/mail/message.go) => true <nil>
Processing package=net/mail:
Walking from GO.link/src to GO.link/src/net/rpc
Processing net/rpc:
Matchfile(GO.link/src/net/rpc/debug.go) => true <nil>
Matchfile(GO.link/src/net/rpc/client.go) => true <nil>
Ignoring test code in server_test.go
Ignoring test code in client_test.go
Matchfile(GO.link/src/net/rpc/server.go) => true <nil>
Processing package=net/rpc:
Walking from GO.link/src to GO.link/src/net/rpc/jsonrpc
Processing net/rpc/jsonrpc:
Matchfile(GO.link/src/net/rpc/jsonrpc/client.go) => true <nil>
Ignoring test code in all_test.go
Matchfile(GO.link/src/net/rpc/jsonrpc/server.go) => true <nil>
Processing package=net/rpc/jsonrpc:
Walking from GO.link/src to GO.link/src/net/smtp
Processing net/smtp:
Ignoring test code in example_test.go
Ignoring test code in smtp_test.go
Matchfile(GO.link/src/net/smtp/auth.go) => true <nil>
Matchfile(GO.link/src/net/smtp/smtp.go) => true <nil>
Processing package=net/smtp:
Excluding GO.link/src/net/testdata
Walking from GO.link/src to GO.link/src/net/textproto
Processing net/textproto:
Matchfile(GO.link/src/net/textproto/header.go) => true <nil>
Ignoring test code in writer_test.go
Matchfile(GO.link/src/net/textproto/reader.go) => true <nil>
Ignoring test code in reader_test.go
Matchfile(GO.link/src/net/textproto/pipeline.go) => true <nil>
Matchfile(GO.link/src/net/textproto/writer.go) => true <nil>
Matchfile(GO.link/src/net/textproto/textproto.go) => true <nil>
Processing package=net/textproto:
Walking from GO.link/src to GO.link/src/net/url
Processing net/url:
Ignoring test code in example_test.go
Ignoring test code in url_test.go
Matchfile(GO.link/src/net/url/url.go) => true <nil>
Processing package=net/url:
Walking from GO.link/src to GO.link/src/os
Processing os:
Matchfile(GO.link/src/os/exec.go) => true <nil>
Matchfile(GO.link/src/os/exec_posix.go) => true <nil>
Matchfile(GO.link/src/os/path.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/os/error_windows.go) => false <nil>
Matchfile(GO.link/src/os/sticky_bsd.go) => false <nil>
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/os/sys_js.go) => false <nil>
Ignoring test code in path_test.go
Ignoring test code in os_unix_test.go
Matchfile(GO.link/src/os/file_plan9.go) => false <nil>
Matchfile(GO.link/src/os/getwd_darwin.go) => false <nil>
Matchfile(GO.link/src/os/sys_plan9.go) => false <nil>
Ignoring test code in executable_test.go
Ignoring test code in timeout_test.go
Matchfile(GO.link/src/os/sys_linux.go) => true <nil>
Matchfile(GO.link/src/os/sys_solaris.go) => false <nil>
Matchfile(GO.link/src/os/stat_nacljs.go) => false <nil>
Matchfile(GO.link/src/os/dir_windows.go) => false <nil>
Matchfile(GO.link/src/os/str.go) => true <nil>
Matchfile(GO.link/src/os/stat.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/os/wait_unimp.go) => false <nil>
Ignoring test code in env_unix_test.go
Matchfile(GO.link/src/os/types.go) => true <nil>
Matchfile(GO.link/src/os/stat_dragonfly.go) => false <nil>
Matchfile(GO.link/src/os/error_unix.go) => true <nil>
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/os/sys_windows.go) => false <nil>
Ignoring test code in os_test.go
Matchfile(GO.link/src/os/path_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/executable_windows.go) => false <nil>
Matchfile(GO.link/src/os/file.go) => true <nil>
Matchfile(GO.link/src/os/executable_path.go) => false <nil>
Ignoring test code in error_unix_test.go
Matchfile(GO.link/src/os/sticky_notbsd.go) => true <nil>
Matchfile(GO.link/src/os/dir_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_plan9.go) => false <nil>
Ignoring test code in fifo_test.go
Matchfile(GO.link/src/os/pipe_linux.go) => true <nil>
Matchfile(GO.link/src/os/types_unix.go) => true <nil>
Matchfile(GO.link/src/os/dir.go) => true <nil>
Matchfile(GO.link/src/os/sys_nacl.go) => false <nil>
Matchfile(GO.link/src/os/sys_bsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_netbsd.go) => false <nil>
Matchfile(GO.link/src/os/pipe2_bsd.go) => false <nil>
Matchfile(GO.link/src/os/stat_solaris.go) => false <nil>
Matchfile(GO.link/src/os/executable_plan9.go) => false <nil>
Matchfile(GO.link/src/os/stat_openbsd.go) => false <nil>
Matchfile(GO.link/src/os/exec_windows.go) => false <nil>
Matchfile(GO.link/src/os/stat_darwin.go) => false <nil>
Matchfile(GO.link/src/os/executable_solaris.go) => false <nil>
Matchfile(GO.link/src/os/executable_darwin.go) => false <nil>
Matchfile(GO.link/src/os/sys.go) => true <nil>
Matchfile(GO.link/src/os/dir_unix.go) => true <nil>
Matchfile(GO.link/src/os/proc.go) => true <nil>
Ignoring test code in os_windows_test.go
Matchfile(GO.link/src/os/types_windows.go) => false <nil>
Matchfile(GO.link/src/os/executable_freebsd.go) => false <nil>
Matchfile(GO.link/src/os/executable_procfs.go) => true <nil>
Matchfile(GO.link/src/os/error_posix.go) => true <nil>
Matchfile(GO.link/src/os/path_windows.go) => false <nil>
Matchfile(GO.link/src/os/stat_windows.go) => false <nil>
Matchfile(GO.link/src/os/file_unix.go) => true <nil>
Matchfile(GO.link/src/os/getwd.go) => true <nil>
Matchfile(GO.link/src/os/pipe_bsd.go) => false <nil>
Matchfile(GO.link/src/os/wait_wait6.go) => false <nil>
Matchfile(GO.link/src/os/file_windows.go) => false <nil>
Matchfile(GO.link/src/os/error.go) => true <nil>
Ignoring test code in pipe_test.go
Matchfile(GO.link/src/os/wait_waitid.go) => true <nil>
Matchfile(GO.link/src/os/path_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec_plan9.go) => false <nil>
Ignoring test code in env_test.go
Ignoring test code in error_test.go
Matchfile(GO.link/src/os/sys_unix.go) => true <nil>
Matchfile(GO.link/src/os/executable.go) => true <nil>
Matchfile(GO.link/src/os/exec_unix.go) => true <nil>
Matchfile(GO.link/src/os/stat_unix.go) => true <nil>
Matchfile(GO.link/src/os/env.go) => true <nil>
Matchfile(GO.link/src/os/types_plan9.go) => false <nil>
Ignoring test code in error_windows_test.go
Matchfile(GO.link/src/os/file_posix.go) => true <nil>
Matchfile(GO.link/src/os/stat_linux.go) => true <nil>
Matchfile(GO.link/src/os/error_plan9.go) => false <nil>
Processing package=os:
Walking from GO.link/src to GO.link/src/os/exec
Processing os/exec:
Matchfile(GO.link/src/os/exec/exec.go) => true <nil>
Ignoring test code in internal_test.go
Ignoring test code in example_test.go
Ignoring test code in lp_windows_test.go
Ignoring test code in lp_unix_test.go
Matchfile(GO.link/src/os/exec/lp_plan9.go) => false <nil>
Matchfile(GO.link/src/os/exec/exec_windows.go) => false <nil>
Matchfile(GO.link/src/os/exec/lp_js.go) => false <nil>
Matchfile(GO.link/src/os/exec/lp_unix.go) => true <nil>
Ignoring test code in exec_test.go
Matchfile(GO.link/src/os/exec/lp_windows.go) => false <nil>
Ignoring test code in exec_posix_test.go
Ignoring test code in env_test.go
Matchfile(GO.link/src/os/exec/exec_unix.go) => true <nil>
Ignoring test code in lp_test.go
Processing package=os/exec:
Walking from GO.link/src to GO.link/src/os/signal
Processing os/signal:
Ignoring test code in example_test.go
Ignoring test code in signal_plan9_test.go
Matchfile(GO.link/src/os/signal/signal_unix.go) => true <nil>
Matchfile(GO.link/src/os/signal/signal.go) => true <nil>
Ignoring test code in signal_test.go
Ignoring test code in signal_windows_test.go
Matchfile(GO.link/src/os/signal/signal_plan9.go) => false <nil>
Ignoring test code in signal_cgo_test.go
Matchfile(GO.link/src/os/signal/doc.go) => true <nil>
Processing package=os/signal:
Excluding GO.link/src/os/signal/internal
Walking from GO.link/src to GO.link/src/os/user
Processing os/user:
Matchfile(GO.link/src/os/user/lookup_android.go) => false <nil>
Matchfile(GO.link/src/os/user/listgroups_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/lookup_windows.go) => false <nil>
Matchfile(GO.link/src/os/user/listgroups_solaris.go) => false <nil>
Matchfile(GO.link/src/os/user/cgo_lookup_unix.go) => true <nil>
Matchfile(GO.link/src/os/user/user.go) => true <nil>
Matchfile(GO.link/src/os/user/lookup_unix.go) => false <nil>
Ignoring test code in user_test.go
Matchfile(GO.link/src/os/user/lookup_stubs.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup_plan9.go) => false <nil>
Matchfile(GO.link/src/os/user/lookup.go) => true <nil>
Ignoring test code in cgo_unix_test.go
Ignoring test code in lookup_unix_test.go
Matchfile(GO.link/src/os/user/getgrouplist_darwin.go) => false <nil>
Matchfile(GO.link/src/os/user/getgrouplist_unix.go) => true <nil>
Processing package=os/user:
Walking from GO.link/src to GO.link/src/path
Processing path:
Matchfile(GO.link/src/path/path.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in path_test.go
Ignoring test code in match_test.go
Matchfile(GO.link/src/path/match.go) => true <nil>
Processing package=path:
Walking from GO.link/src to GO.link/src/path/filepath
Processing path/filepath:
Matchfile(GO.link/src/path/filepath/path.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_windows_test.go
Ignoring test code in path_test.go
Matchfile(GO.link/src/path/filepath/symlink_unix.go) => true <nil>
Ignoring test code in match_test.go
Ignoring test code in export_test.go
Ignoring test code in path_windows_test.go
Matchfile(GO.link/src/path/filepath/path_unix.go) => true <nil>
Matchfile(GO.link/src/path/filepath/symlink_windows.go) => false <nil>
Ignoring test code in example_unix_test.go
Matchfile(GO.link/src/path/filepath/symlink.go) => true <nil>
Ignoring test code in example_unix_walk_test.go
Matchfile(GO.link/src/path/filepath/path_windows.go) => false <nil>
Matchfile(GO.link/src/path/filepath/path_plan9.go) => false <nil>
Matchfile(GO.link/src/path/filepath/match.go) => true <nil>
Processing package=path/filepath:
Walking from GO.link/src to GO.link/src/plugin
Processing plugin:
Matchfile(GO.link/src/plugin/plugin.go) => true <nil>
Matchfile(GO.link/src/plugin/plugin_stubs.go) => false <nil>
Matchfile(GO.link/src/plugin/plugin_dlopen.go) => true <nil>
Processing package=plugin:
Walking from GO.link/src to GO.link/src/reflect
Processing reflect:
Matchfile(GO.link/src/reflect/type.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/reflect/swapper.go) => true <nil>
Matchfile(GO.link/src/reflect/makefunc.go) => true <nil>
Matchfile(GO.link/src/reflect/value.go) => true <nil>
Matchfile(GO.link/src/reflect/deepequal.go) => true <nil>
Ignoring test code in tostring_test.go
Ignoring test code in set_test.go
Ignoring test code in all_test.go
Processing package=reflect:
Walking from GO.link/src to GO.link/src/regexp
Processing regexp:
Ignoring test code in exec2_test.go
Matchfile(GO.link/src/regexp/exec.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/regexp/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/onepass.go) => true <nil>
Matchfile(GO.link/src/regexp/backtrack.go) => true <nil>
Ignoring test code in find_test.go
Ignoring test code in all_test.go
Ignoring test code in exec_test.go
Ignoring test code in onepass_test.go
Processing package=regexp:
Walking from GO.link/src to GO.link/src/regexp/syntax
Processing regexp/syntax:
Ignoring test code in simplify_test.go
Matchfile(GO.link/src/regexp/syntax/compile.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/regexp.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/parse.go) => true <nil>
Ignoring test code in parse_test.go
Ignoring test code in prog_test.go
Matchfile(GO.link/src/regexp/syntax/simplify.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/prog.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/doc.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/perl_groups.go) => true <nil>
Matchfile(GO.link/src/regexp/syntax/op_string.go) => true <nil>
Processing package=regexp/syntax:
Excluding GO.link/src/regexp/testdata
Walking from GO.link/src to GO.link/src/runtime
Processing runtime:
Matchfile(GO.link/src/runtime/defs_linux_mips64x.go) => false <nil>
Ignoring test code in softfloat64_test.go
Matchfile(GO.link/src/runtime/lock_futex.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/syscall2_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/write_err.go) => true <nil>
Matchfile(GO.link/src/runtime/os2_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/hash32.go) => false <nil>
Matchfile(GO.link/src/runtime/type.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_be64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/write_err_android.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux.go) => true <nil>
Ignoring test code in chan_test.go
Ignoring test code in export_debug_test.go
Ignoring test code in sizeof_test.go
Matchfile(GO.link/src/runtime/vdso_freebsd.go) => false <nil>
Ignoring test code in debug_test.go
Matchfile(GO.link/src/runtime/signal_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/mstats.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_arm.go) => false <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/runtime/msan.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_mips64x.go) => false <nil>
Ignoring test code in map_benchmark_test.go
Matchfile(GO.link/src/runtime/defs_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs3_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_generic.go) => true <nil>
Ignoring test code in export_windows_test.go
Ignoring test code in export_arm_test.go
Matchfile(GO.link/src/runtime/mgcwork.go) => true <nil>
Ignoring test code in norace_linux_test.go
Matchfile(GO.link/src/runtime/print.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/debug.go) => true <nil>
Matchfile(GO.link/src/runtime/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mips64x.go) => false <nil>
Ignoring test code in string_test.go
Matchfile(GO.link/src/runtime/os_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/rwmutex.go) => true <nil>
Matchfile(GO.link/src/runtime/sema.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_ppc64x.go) => false <nil>
Ignoring test code in runtime-gdb_test.go
Matchfile(GO.link/src/runtime/os3_plan9.go) => false <nil>
Ignoring test code in fastlog2_test.go
Matchfile(GO.link/src/runtime/vdso_elf32.go) => false <nil>
Matchfile(GO.link/src/runtime/cputicks.go) => true <nil>
Matchfile(GO.link/src/runtime/os2_plan9.go) => false <nil>
Ignoring test code in rwmutex_test.go
Ignoring test code in chanbarrier_test.go
Ignoring test code in runtime_mmap_test.go
Matchfile(GO.link/src/runtime/mbitmap.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_kqueue.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_nacl_arm.go) => false <nil>
Ignoring test code in gc_test.go
Matchfile(GO.link/src/runtime/os_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs2.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_stub.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/mkfastlog2table.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs32.go) => false <nil>
Matchfile(GO.link/src/runtime/unaligned1.go) => true <nil>
Matchfile(GO.link/src/runtime/time.go) => true <nil>
Ignoring test code in numcpu_freebsd_test.go
Ignoring test code in closure_test.go
Matchfile(GO.link/src/runtime/map.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_amd64.go) => false <nil>
Ignoring test code in memmove_linux_amd64_test.go
Matchfile(GO.link/src/runtime/stack.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_unix.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_linux.go) => true <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm64.go) => false <nil>
Ignoring test code in stack_test.go
Matchfile(GO.link/src/runtime/signal_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/race0.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/atomic_pointer.go) => true <nil>
Ignoring test code in iface_test.go
Matchfile(GO.link/src/runtime/os2_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_386.go) => false <nil>
Ignoring test code in runtime_linux_test.go
Matchfile(GO.link/src/runtime/os_freebsd_noauxv.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/runtime/signal_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/wincallback.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_mmap.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_nacl_arm.go) => false <nil>
Ignoring test code in slice_test.go
Matchfile(GO.link/src/runtime/sigqueue.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_freebsd_arm.go) => false <nil>
Ignoring test code in symtab_test.go
Matchfile(GO.link/src/runtime/mwbbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/os_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/utf8.go) => true <nil>
Matchfile(GO.link/src/runtime/panic.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/cpuflags_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs_nonlinux.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_js.go) => false <nil>
Ignoring test code in futex_test.go
Matchfile(GO.link/src/runtime/os_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/plugin.go) => true <nil>
Matchfile(GO.link/src/runtime/malloc.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/sigaction.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_s390x.go) => false <nil>
Ignoring test code in mfinal_test.go
Matchfile(GO.link/src/runtime/os_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/mgcsweep.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_arm.go) => false <nil>
Ignoring test code in profbuf_test.go
Matchfile(GO.link/src/runtime/timestub2.go) => true <nil>
Ignoring test code in proc_test.go
Matchfile(GO.link/src/runtime/os3_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_amd64.go) => true <nil>
Ignoring test code in map_test.go
Matchfile(GO.link/src/runtime/signal_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_freebsd.go) => false <nil>
Ignoring test code in proc_runtime_test.go
Matchfile(GO.link/src/runtime/os_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/trace.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/cgocall.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs2_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_linux_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_in_none.go) => false <nil>
Matchfile(GO.link/src/runtime/softfloat64.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_wasm.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/mgclarge.go) => true <nil>
Matchfile(GO.link/src/runtime/map_fast32.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/runtime/zcallback_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/env_posix.go) => true <nil>
Matchfile(GO.link/src/runtime/select.go) => true <nil>
Matchfile(GO.link/src/runtime/os_linux_novdso.go) => false <nil>
Matchfile(GO.link/src/runtime/symtab.go) => true <nil>
Matchfile(GO.link/src/runtime/mprof.go) => true <nil>
Matchfile(GO.link/src/runtime/mcache.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/unaligned2.go) => false <nil>
Matchfile(GO.link/src/runtime/map_fast64.go) => true <nil>
Matchfile(GO.link/src/runtime/lfstack.go) => true <nil>
Matchfile(GO.link/src/runtime/os_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/alg.go) => true <nil>
Matchfile(GO.link/src/runtime/proflabel.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/compiler.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_dragonfly.go) => false <nil>
Ignoring test code in runtime-lldb_test.go
Matchfile(GO.link/src/runtime/mem_bsd.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_darwin.go) => false <nil>
Ignoring test code in complex_test.go
Matchfile(GO.link/src/runtime/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/sigtab_linux_generic.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_amd64.go) => false <nil>
Ignoring test code in runtime_test.go
Matchfile(GO.link/src/runtime/complex.go) => true <nil>
Ignoring test code in rand_test.go
Matchfile(GO.link/src/runtime/rdebug.go) => true <nil>
Matchfile(GO.link/src/runtime/typekind.go) => true <nil>
Matchfile(GO.link/src/runtime/runtime1.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/vdso_elf64.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs_linux.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/extern.go) => true <nil>
Matchfile(GO.link/src/runtime/heapdump.go) => true <nil>
Matchfile(GO.link/src/runtime/os_nonopenbsd.go) => true <nil>
Matchfile(GO.link/src/runtime/mgcmark.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd_386.go) => false <nil>
Ignoring test code in export_linux_test.go
Matchfile(GO.link/src/runtime/fastlog2table.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin.go) => false <nil>
Matchfile(GO.link/src/runtime/mheap.go) => true <nil>
Matchfile(GO.link/src/runtime/os_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/lfstack_64bit.go) => true <nil>
Matchfile(GO.link/src/runtime/race.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/auxv_none.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs3.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll.go) => true <nil>
Ignoring test code in runtime_unix_test.go
Matchfile(GO.link/src/runtime/defs_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/runtime/sigqueue_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo_sigaction.go) => true <nil>
Matchfile(GO.link/src/runtime/string.go) => true <nil>
Matchfile(GO.link/src/runtime/os_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/mmap.go) => false <nil>
Matchfile(GO.link/src/runtime/mem_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/os2_freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/traceback.go) => true <nil>
Ignoring test code in export_futex_test.go
Matchfile(GO.link/src/runtime/lfstack_32bit.go) => false <nil>
Matchfile(GO.link/src/runtime/netpoll_epoll.go) => true <nil>
Matchfile(GO.link/src/runtime/net_plan9.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_js.go) => false <nil>
Matchfile(GO.link/src/runtime/proc.go) => true <nil>
Matchfile(GO.link/src/runtime/chan.go) => true <nil>
Matchfile(GO.link/src/runtime/mkduff.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/mgc.go) => true <nil>
Matchfile(GO.link/src/runtime/os_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/env_plan9.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/runtime/netpoll_solaris.go) => false <nil>
Ignoring test code in norace_test.go
Matchfile(GO.link/src/runtime/signal_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/mksizeclasses.go) => false <nil>
Ignoring test code in crash_test.go
Matchfile(GO.link/src/runtime/defs_arm_linux.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_windows.go) => false <nil>
Ignoring test code in crash_nonunix_test.go
Matchfile(GO.link/src/runtime/float.go) => true <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/runtime/signal_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/profbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/vdso_freebsd_x86.go) => false <nil>
Matchfile(GO.link/src/runtime/os_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_ppc64x.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_mipsx.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_netbsd_amd64.go) => false <nil>
Ignoring test code in lfstack_test.go
Matchfile(GO.link/src/runtime/debugcall.go) => true <nil>
Matchfile(GO.link/src/runtime/cgocheck.go) => true <nil>
Matchfile(GO.link/src/runtime/mbarrier.go) => true <nil>
Ignoring test code in malloc_test.go
Matchfile(GO.link/src/runtime/os_android.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_js.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/stubs_android.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_openbsd.go) => false <nil>
Ignoring test code in callers_test.go
Matchfile(GO.link/src/runtime/error.go) => true <nil>
Matchfile(GO.link/src/runtime/iface.go) => true <nil>
Matchfile(GO.link/src/runtime/mgcsweepbuf.go) => true <nil>
Matchfile(GO.link/src/runtime/mem_windows.go) => false <nil>
Matchfile(GO.link/src/runtime/os_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/os_linux_noauxv.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/map_faststr.go) => true <nil>
Matchfile(GO.link/src/runtime/runtime2.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/netpoll_fake.go) => false <nil>
Matchfile(GO.link/src/runtime/runtime.go) => true <nil>
Matchfile(GO.link/src/runtime/mcentral.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_solaris.go) => false <nil>
Matchfile(GO.link/src/runtime/slice.go) => true <nil>
Ignoring test code in export_mmap_test.go
Ignoring test code in crash_cgo_test.go
Matchfile(GO.link/src/runtime/signal_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/os_freebsd2.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_nacl_amd64p32.go) => false <nil>
Ignoring test code in vlop_arm_test.go
Matchfile(GO.link/src/runtime/signal_nacl.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_sighandler.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_nacl_386.go) => false <nil>
Matchfile(GO.link/src/runtime/hash64.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_darwin_arm.go) => false <nil>
Ignoring test code in env_test.go
Matchfile(GO.link/src/runtime/fastlog2.go) => true <nil>
Matchfile(GO.link/src/runtime/os_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/relax_stub.go) => true <nil>
Matchfile(GO.link/src/runtime/cgocallback.go) => true <nil>
Matchfile(GO.link/src/runtime/signal_nacl_386.go) => false <nil>
Ignoring test code in memmove_test.go
Matchfile(GO.link/src/runtime/sizeclasses.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/runtime/msize.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_darwin_386.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_x86.go) => true <nil>
Matchfile(GO.link/src/runtime/vlrt.go) => false <nil>
Matchfile(GO.link/src/runtime/defs1_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/lock_sema.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/msan0.go) => true <nil>
Ignoring test code in hash_test.go
Matchfile(GO.link/src/runtime/vdso_linux.go) => true <nil>
Matchfile(GO.link/src/runtime/mfinal.go) => true <nil>
Matchfile(GO.link/src/runtime/sys_arm64.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_s390x.go) => false <nil>
Matchfile(GO.link/src/runtime/signal_amd64x.go) => true <nil>
Matchfile(GO.link/src/runtime/defs1_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_386.go) => false <nil>
Matchfile(GO.link/src/runtime/os_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/timeasm.go) => false <nil>
Matchfile(GO.link/src/runtime/defs_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/runtime/sys_nonppc64x.go) => true <nil>
Matchfile(GO.link/src/runtime/stubs.go) => true <nil>
Ignoring test code in crash_unix_test.go
Ignoring test code in gcinfo_test.go
Ignoring test code in vdso_linux_test.go
Matchfile(GO.link/src/runtime/defs_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/runtime/timestub.go) => true <nil>
Matchfile(GO.link/src/runtime/mfixalloc.go) => true <nil>
Matchfile(GO.link/src/runtime/cpuprof.go) => true <nil>
Matchfile(GO.link/src/runtime/defs_windows_386.go) => false <nil>
Processing package=runtime:
Walking from GO.link/src to GO.link/src/runtime/cgo
Processing runtime/cgo:
Matchfile(GO.link/src/runtime/cgo/cgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/iscgo.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/netbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/setenv.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/sigaction.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/mmap.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/dragonfly.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/openbsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/signal_darwin_armx.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks.go) => true <nil>
Matchfile(GO.link/src/runtime/cgo/freebsd.go) => false <nil>
Matchfile(GO.link/src/runtime/cgo/callbacks_traceback.go) => true <nil>
Processing package=runtime/cgo:
Walking from GO.link/src to GO.link/src/runtime/debug
Processing runtime/debug:
Matchfile(GO.link/src/runtime/debug/stack.go) => true <nil>
Ignoring test code in stack_test.go
Ignoring test code in garbage_test.go
Matchfile(GO.link/src/runtime/debug/garbage.go) => true <nil>
Ignoring test code in heapdump_test.go
Matchfile(GO.link/src/runtime/debug/stubs.go) => true <nil>
Processing package=runtime/debug:
Excluding GO.link/src/runtime/internal
Walking from GO.link/src to GO.link/src/runtime/msan
Processing runtime/msan:
Matchfile(GO.link/src/runtime/msan/msan.go) => false <nil>
Walking from GO.link/src to GO.link/src/runtime/pprof
Processing runtime/pprof:
Matchfile(GO.link/src/runtime/pprof/elf.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/map.go) => true <nil>
Ignoring test code in pprof_test.go
Matchfile(GO.link/src/runtime/pprof/protomem.go) => true <nil>
Ignoring test code in runtime_test.go
Ignoring test code in mprof_test.go
Matchfile(GO.link/src/runtime/pprof/pprof.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/label.go) => true <nil>
Ignoring test code in proto_test.go
Matchfile(GO.link/src/runtime/pprof/protobuf.go) => true <nil>
Matchfile(GO.link/src/runtime/pprof/runtime.go) => true <nil>
Ignoring test code in label_test.go
Matchfile(GO.link/src/runtime/pprof/proto.go) => true <nil>
Ignoring test code in protomem_test.go
Processing package=runtime/pprof:
Excluding GO.link/src/runtime/pprof/internal
Excluding GO.link/src/runtime/pprof/testdata
Walking from GO.link/src to GO.link/src/runtime/race
Processing runtime/race:
Ignoring test code in race_linux_test.go
Ignoring test code in sched_test.go
Ignoring test code in race_test.go
Matchfile(GO.link/src/runtime/race/race.go) => false <nil>
Matchfile(GO.link/src/runtime/race/doc.go) => true <nil>
Ignoring test code in output_test.go
Ignoring test code in race_unix_test.go
Ignoring test code in race_windows_test.go
Processing package=runtime/race:
Excluding GO.link/src/runtime/race/testdata
Excluding GO.link/src/runtime/testdata
Walking from GO.link/src to GO.link/src/runtime/trace
Processing runtime/trace:
Ignoring test code in annotation_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/runtime/trace/trace.go) => true <nil>
Ignoring test code in trace_stack_test.go
Matchfile(GO.link/src/runtime/trace/annotation.go) => true <nil>
Ignoring test code in trace_test.go
Processing package=runtime/trace:
Walking from GO.link/src to GO.link/src/sort
Processing sort:
Ignoring test code in sort_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/sort/sort.go) => true <nil>
Ignoring test code in example_search_test.go
Ignoring test code in export_test.go
Ignoring test code in example_keys_test.go
Matchfile(GO.link/src/sort/search.go) => true <nil>
Ignoring test code in example_multi_test.go
Matchfile(GO.link/src/sort/slice.go) => true <nil>
Matchfile(GO.link/src/sort/genzfunc.go) => false <nil>
Ignoring test code in example_interface_test.go
Ignoring test code in example_wrapper_test.go
Ignoring test code in search_test.go
Matchfile(GO.link/src/sort/zfuncversion.go) => true <nil>
Processing package=sort:
Walking from GO.link/src to GO.link/src/strconv
Processing strconv:
Matchfile(GO.link/src/strconv/isprint.go) => true <nil>
Matchfile(GO.link/src/strconv/atof.go) => true <nil>
Matchfile(GO.link/src/strconv/ftoa.go) => true <nil>
Ignoring test code in internal_test.go
Ignoring test code in example_test.go
Matchfile(GO.link/src/strconv/atob.go) => true <nil>
Ignoring test code in quote_test.go
Ignoring test code in itoa_test.go
Ignoring test code in atoi_test.go
Matchfile(GO.link/src/strconv/quote.go) => true <nil>
Ignoring test code in atob_test.go
Ignoring test code in strconv_test.go
Matchfile(GO.link/src/strconv/itoa.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/strconv/extfloat.go) => true <nil>
Ignoring test code in ftoa_test.go
Matchfile(GO.link/src/strconv/atoi.go) => true <nil>
Matchfile(GO.link/src/strconv/decimal.go) => true <nil>
Ignoring test code in fp_test.go
Matchfile(GO.link/src/strconv/doc.go) => true <nil>
Ignoring test code in atof_test.go
Matchfile(GO.link/src/strconv/makeisprint.go) => false <nil>
Ignoring test code in decimal_test.go
Processing package=strconv:
Excluding GO.link/src/strconv/testdata
Walking from GO.link/src to GO.link/src/strings
Processing strings:
Ignoring test code in example_test.go
Matchfile(GO.link/src/strings/reader.go) => true <nil>
Ignoring test code in reader_test.go
Ignoring test code in compare_test.go
Ignoring test code in export_test.go
Matchfile(GO.link/src/strings/replace.go) => true <nil>
Matchfile(GO.link/src/strings/search.go) => true <nil>
Ignoring test code in strings_test.go
Ignoring test code in replace_test.go
Matchfile(GO.link/src/strings/strings_decl.go) => true <nil>
Ignoring test code in builder_test.go
Matchfile(GO.link/src/strings/strings.go) => true <nil>
Matchfile(GO.link/src/strings/builder.go) => true <nil>
Ignoring test code in search_test.go
Matchfile(GO.link/src/strings/compare.go) => true <nil>
Processing package=strings:
Walking from GO.link/src to GO.link/src/sync
Processing sync:
Ignoring test code in example_test.go
Ignoring test code in pool_test.go
Matchfile(GO.link/src/sync/rwmutex.go) => true <nil>
Ignoring test code in rwmutex_test.go
Ignoring test code in mutex_test.go
Matchfile(GO.link/src/sync/map.go) => true <nil>
Ignoring test code in runtime_sema_test.go
Ignoring test code in example_pool_test.go
Ignoring test code in export_test.go
Ignoring test code in map_bench_test.go
Ignoring test code in cond_test.go
Matchfile(GO.link/src/sync/cond.go) => true <nil>
Ignoring test code in map_test.go
Ignoring test code in once_test.go
Ignoring test code in map_reference_test.go
Ignoring test code in waitgroup_test.go
Matchfile(GO.link/src/sync/once.go) => true <nil>
Matchfile(GO.link/src/sync/pool.go) => true <nil>
Matchfile(GO.link/src/sync/mutex.go) => true <nil>
Matchfile(GO.link/src/sync/waitgroup.go) => true <nil>
Matchfile(GO.link/src/sync/runtime.go) => true <nil>
Processing package=sync:
Walking from GO.link/src to GO.link/src/sync/atomic
Processing sync/atomic:
Ignoring test code in example_test.go
Matchfile(GO.link/src/sync/atomic/value.go) => true <nil>
Ignoring test code in atomic_test.go
Matchfile(GO.link/src/sync/atomic/doc.go) => true <nil>
Ignoring test code in value_test.go
Processing package=sync/atomic:
Walking from GO.link/src to GO.link/src/syscall
Processing syscall:
Matchfile(GO.link/src/syscall/syscall.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/const_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/pwd_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/msan.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd_64bit.go) => false <nil>
Matchfile(GO.link/src/syscall/forkpipe2.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/route_bsd.go) => false <nil>
Ignoring test code in syscall_linux_test.go
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64le.go) => false <nil>
Ignoring test code in mmap_unix_test.go
Matchfile(GO.link/src/syscall/syscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/lsf_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/net.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/net_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysctl_openbsd.go) => false <nil>
Ignoring test code in exec_solaris_test.go
Matchfile(GO.link/src/syscall/zsysnum_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/forkpipe.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/types_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/str.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/dirent.go) => true <nil>
Matchfile(GO.link/src/syscall/setuidgid_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_386.go) => false <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/syscall/zerrors_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/bpf_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_freebsd_amd64.go) => false <nil>
Ignoring test code in syscall_plan9_test.go
Matchfile(GO.link/src/syscall/zsysnum_darwin_386.go) => false <nil>
Ignoring test code in syscall_unix_test.go
Matchfile(GO.link/src/syscall/ztypes_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_ppc64x.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/security_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/dll_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/types_darwin.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/netlink_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_freebsd_arm.go) => false <nil>
Ignoring test code in exec_linux_test.go
Matchfile(GO.link/src/syscall/env_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/route_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/types_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/dir_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_big.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/route_freebsd_32bit.go) => false <nil>
Matchfile(GO.link/src/syscall/env_unix.go) => true <nil>
Ignoring test code in syscall_bsd_test.go
Ignoring test code in exec_unix_test.go
Matchfile(GO.link/src/syscall/ztypes_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/flock_linux_32bit.go) => false <nil>
Matchfile(GO.link/src/syscall/types_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/types_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/route_darwin.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_amd64.go) => true <nil>
Ignoring test code in export_linux_test.go
Matchfile(GO.link/src/syscall/types_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/mkpost.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/tables_nacljs.go) => false <nil>
Matchfile(GO.link/src/syscall/net_js.go) => false <nil>
Ignoring test code in syscall_test.go
Matchfile(GO.link/src/syscall/ztypes_freebsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_darwin_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_getwd_bsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_amd64.go) => true <nil>
Matchfile(GO.link/src/syscall/types_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/env_plan9.go) => false <nil>
Ignoring test code in export_unix_test.go
Matchfile(GO.link/src/syscall/types_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/timestruct.go) => true <nil>
Matchfile(GO.link/src/syscall/route_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_arm.go) => false <nil>
Ignoring test code in syscall_windows_test.go
Matchfile(GO.link/src/syscall/fs_js.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_plan9_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_386.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_windows_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_windows_386.go) => false <nil>
Matchfile(GO.link/src/syscall/errors_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/route_dragonfly.go) => false <nil>
Matchfile(GO.link/src/syscall/types_freebsd.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_linux_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/sockcmsg_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/flock.go) => true <nil>
Matchfile(GO.link/src/syscall/fd_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_386.go) => false <nil>
Matchfile(GO.link/src/syscall/mksyscall_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_solaris_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_plan9.go) => false <nil>
Matchfile(GO.link/src/syscall/route_netbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_linux.go) => true <nil>
Matchfile(GO.link/src/syscall/syscall_linux_mips64x.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_freebsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mipsle.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_darwin_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_darwin_arm64.go) => false <nil>
Matchfile(GO.link/src/syscall/ztypes_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/endian_little.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_linux_mips.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_mipsx.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_netbsd_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_mips64.go) => false <nil>
Matchfile(GO.link/src/syscall/setuidgid_32_linux.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_nacl_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/msan0.go) => true <nil>
Matchfile(GO.link/src/syscall/zerrors_dragonfly_amd64.go) => false <nil>
Matchfile(GO.link/src/syscall/fs_nacl.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_solaris.go) => false <nil>
Matchfile(GO.link/src/syscall/exec_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/ztypes_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_linux_s390x.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_nacl_amd64p32.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64le.go) => false <nil>
Matchfile(GO.link/src/syscall/zsyscall_netbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_unix.go) => true <nil>
Matchfile(GO.link/src/syscall/zsysnum_netbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_js.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_openbsd_386.go) => false <nil>
Matchfile(GO.link/src/syscall/zsysnum_linux_ppc64.go) => false <nil>
Matchfile(GO.link/src/syscall/syscall_openbsd_arm.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_windows.go) => false <nil>
Matchfile(GO.link/src/syscall/zerrors_darwin_arm64.go) => false <nil>
Ignoring test code in creds_test.go
Matchfile(GO.link/src/syscall/unzip_nacl.go) => false <nil>
Processing package=syscall:
Walking from GO.link/src to GO.link/src/syscall/js
Processing syscall/js:
Ignoring test code in js_test.go
Matchfile(GO.link/src/syscall/js/js.go) => false <nil>
Matchfile(GO.link/src/syscall/js/typedarray.go) => false <nil>
Matchfile(GO.link/src/syscall/js/callback.go) => false <nil>
Walking from GO.link/src to GO.link/src/testing
Processing testing:
Matchfile(GO.link/src/testing/allocs.go) => true <nil>
Matchfile(GO.link/src/testing/benchmark.go) => true <nil>
Ignoring test code in allocs_test.go
Ignoring test code in match_test.go
Ignoring test code in export_test.go
Ignoring test code in helperfuncs_test.go
Matchfile(GO.link/src/testing/example.go) => true <nil>
Ignoring test code in helper_test.go
Ignoring test code in benchmark_test.go
Matchfile(GO.link/src/testing/cover.go) => true <nil>
Matchfile(GO.link/src/testing/testing.go) => true <nil>
Matchfile(GO.link/src/testing/match.go) => true <nil>
Ignoring test code in testing_test.go
Ignoring test code in sub_test.go
Processing package=testing:
Excluding GO.link/src/testing/internal
Walking from GO.link/src to GO.link/src/testing/iotest
Processing testing/iotest:
Matchfile(GO.link/src/testing/iotest/reader.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/logger.go) => true <nil>
Matchfile(GO.link/src/testing/iotest/writer.go) => true <nil>
Processing package=testing/iotest:
Walking from GO.link/src to GO.link/src/testing/quick
Processing testing/quick:
Ignoring test code in quick_test.go
Matchfile(GO.link/src/testing/quick/quick.go) => true <nil>
Processing package=testing/quick:
Walking from GO.link/src to GO.link/src/text
Processing text:
Walking from GO.link/src to GO.link/src/text/scanner
Processing text/scanner:
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/scanner/scanner.go) => true <nil>
Ignoring test code in scanner_test.go
Processing package=text/scanner:
Walking from GO.link/src to GO.link/src/text/tabwriter
Processing text/tabwriter:
Ignoring test code in example_test.go
Ignoring test code in tabwriter_test.go
Matchfile(GO.link/src/text/tabwriter/tabwriter.go) => true <nil>
Processing package=text/tabwriter:
Walking from GO.link/src to GO.link/src/text/template
Processing text/template:
Matchfile(GO.link/src/text/template/exec.go) => true <nil>
Ignoring test code in example_test.go
Matchfile(GO.link/src/text/template/option.go) => true <nil>
Matchfile(GO.link/src/text/template/funcs.go) => true <nil>
Ignoring test code in examplefiles_test.go
Ignoring test code in multi_test.go
Ignoring test code in exec_test.go
Matchfile(GO.link/src/text/template/doc.go) => true <nil>
Ignoring test code in examplefunc_test.go
Matchfile(GO.link/src/text/template/template.go) => true <nil>
Matchfile(GO.link/src/text/template/helper.go) => true <nil>
Processing package=text/template:
Walking from GO.link/src to GO.link/src/text/template/parse
Processing text/template/parse:
Matchfile(GO.link/src/text/template/parse/parse.go) => true <nil>
Ignoring test code in parse_test.go
Matchfile(GO.link/src/text/template/parse/node.go) => true <nil>
Matchfile(GO.link/src/text/template/parse/lex.go) => true <nil>
Ignoring test code in lex_test.go
Processing package=text/template/parse:
Excluding GO.link/src/text/template/testdata
Walking from GO.link/src to GO.link/src/time
Processing time:
Matchfile(GO.link/src/time/zoneinfo.go) => true <nil>
Ignoring test code in internal_test.go
Ignoring test code in example_test.go
Ignoring test code in export_windows_test.go
Matchfile(GO.link/src/time/sys_plan9.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_plan9.go) => false <nil>
Ignoring test code in sleep_test.go
Ignoring test code in zoneinfo_test.go
Matchfile(GO.link/src/time/time.go) => true <nil>
Ignoring test code in export_test.go
Matchfile(GO.link/src/time/genzabbrs.go) => false <nil>
Ignoring test code in mono_test.go
Matchfile(GO.link/src/time/zoneinfo_unix.go) => true <nil>
Matchfile(GO.link/src/time/sys_windows.go) => false <nil>
Matchfile(GO.link/src/time/tick.go) => true <nil>
Ignoring test code in zoneinfo_windows_test.go
Ignoring test code in format_test.go
Matchfile(GO.link/src/time/zoneinfo_windows.go) => false <nil>
Matchfile(GO.link/src/time/sleep.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_android.go) => false <nil>
Ignoring test code in time_test.go
Ignoring test code in export_android_test.go
Matchfile(GO.link/src/time/zoneinfo_ios.go) => false <nil>
Matchfile(GO.link/src/time/zoneinfo_read.go) => true <nil>
Matchfile(GO.link/src/time/zoneinfo_abbrs_windows.go) => false <nil>
Matchfile(GO.link/src/time/format.go) => true <nil>
Ignoring test code in zoneinfo_android_test.go
Matchfile(GO.link/src/time/sys_unix.go) => true <nil>
Ignoring test code in tick_test.go
Processing package=time:
Walking from GO.link/src to GO.link/src/unicode
Processing unicode:
Matchfile(GO.link/src/unicode/digit.go) => true <nil>
Ignoring test code in example_test.go
Ignoring test code in letter_test.go
Ignoring test code in digit_test.go
Ignoring test code in graphic_test.go
Matchfile(GO.link/src/unicode/casetables.go) => true <nil>
Matchfile(GO.link/src/unicode/tables.go) => true <nil>
Matchfile(GO.link/src/unicode/graphic.go) => true <nil>
Matchfile(GO.link/src/unicode/maketables.go) => false <nil>
Matchfile(GO.link/src/unicode/letter.go) => true <nil>
Ignoring test code in script_test.go
Processing package=unicode:
Walking from GO.link/src to GO.link/src/unicode/utf16
Processing unicode/utf16:
Ignoring test code in export_test.go
Matchfile(GO.link/src/unicode/utf16/utf16.go) => true <nil>
Ignoring test code in utf16_test.go
Processing package=unicode/utf16:
Walking from GO.link/src to GO.link/src/unicode/utf8
Processing unicode/utf8:
Ignoring test code in example_test.go
Ignoring test code in utf8_test.go
Matchfile(GO.link/src/unicode/utf8/utf8.go) => true <nil>
Processing package=unicode/utf8:
Walking from GO.link/src to GO.link/src/unsafe
Processing unsafe:
Matchfile(GO.link/src/unsafe/unsafe.go) => true <nil>
Processing package=unsafe:
Excluding GO.link/src/vendor
TYPE archive/tar.Format:
  GO.link/src/archive/tar/format.go
TYPE archive/tar.Header:
  GO.link/src/archive/tar/common.go
TYPE archive/tar.Reader:
  GO.link/src/archive/tar/reader.go
TYPE archive/tar.Writer:
  GO.link/src/archive/tar/writer.go
TYPE archive/zip.Compressor:
  GO.link/src/archive/zip/register.go
TYPE archive/zip.Decompressor:
  GO.link/src/archive/zip/register.go
TYPE archive/zip.File:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.FileHeader:
  GO.link/src/archive/zip/struct.go
TYPE archive/zip.ReadCloser:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.Reader:
  GO.link/src/archive/zip/reader.go
TYPE archive/zip.Writer:
  GO.link/src/archive/zip/writer.go
TYPE bufio.ReadWriter:
  GO.link/src/bufio/bufio.go
TYPE bufio.Reader:
  GO.link/src/bufio/bufio.go
TYPE bufio.Scanner:
  GO.link/src/bufio/scan.go
TYPE bufio.SplitFunc:
  GO.link/src/bufio/scan.go
TYPE bufio.Writer:
  GO.link/src/bufio/bufio.go
TYPE bytes.Buffer:
  GO.link/src/bytes/buffer.go
TYPE bytes.Reader:
  GO.link/src/bytes/reader.go
TYPE compress/bzip2.StructuralError:
  GO.link/src/compress/bzip2/bzip2.go
TYPE compress/flate.CorruptInputError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.InternalError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.ReadError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Reader:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Resetter:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.WriteError:
  GO.link/src/compress/flate/inflate.go
TYPE compress/flate.Writer:
  GO.link/src/compress/flate/deflate.go
TYPE compress/gzip.Header:
  GO.link/src/compress/gzip/gunzip.go
TYPE compress/gzip.Reader:
  GO.link/src/compress/gzip/gunzip.go
TYPE compress/gzip.Writer:
  GO.link/src/compress/gzip/gzip.go
TYPE compress/lzw.Order:
  GO.link/src/compress/lzw/reader.go
TYPE compress/zlib.Resetter:
  GO.link/src/compress/zlib/reader.go
TYPE compress/zlib.Writer:
  GO.link/src/compress/zlib/writer.go
TYPE container/heap.Interface:
  GO.link/src/container/heap/heap.go
TYPE container/list.Element:
  GO.link/src/container/list/list.go
TYPE container/list.List:
  GO.link/src/container/list/list.go
TYPE container/ring.Ring:
  GO.link/src/container/ring/ring.go
TYPE context.CancelFunc:
  GO.link/src/context/context.go
TYPE context.Context:
  GO.link/src/context/context.go
TYPE crypto.Decrypter:
  GO.link/src/crypto/crypto.go
TYPE crypto.DecrypterOpts:
  GO.link/src/crypto/crypto.go
TYPE crypto.Hash:
  GO.link/src/crypto/crypto.go
TYPE crypto.PrivateKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.PublicKey:
  GO.link/src/crypto/crypto.go
TYPE crypto.Signer:
  GO.link/src/crypto/crypto.go
TYPE crypto.SignerOpts:
  GO.link/src/crypto/crypto.go
TYPE crypto/aes.KeySizeError:
  GO.link/src/crypto/aes/cipher.go
TYPE crypto/cipher.AEAD:
  GO.link/src/crypto/cipher/gcm.go
TYPE crypto/cipher.Block:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.BlockMode:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.Stream:
  GO.link/src/crypto/cipher/cipher.go
TYPE crypto/cipher.StreamReader:
  GO.link/src/crypto/cipher/io.go
TYPE crypto/cipher.StreamWriter:
  GO.link/src/crypto/cipher/io.go
TYPE crypto/des.KeySizeError:
  GO.link/src/crypto/des/cipher.go
TYPE crypto/dsa.ParameterSizes:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.Parameters:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.PrivateKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/dsa.PublicKey:
  GO.link/src/crypto/dsa/dsa.go
TYPE crypto/ecdsa.PrivateKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE crypto/ecdsa.PublicKey:
  GO.link/src/crypto/ecdsa/ecdsa.go
TYPE crypto/elliptic.Curve:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE crypto/elliptic.CurveParams:
  GO.link/src/crypto/elliptic/elliptic.go
TYPE crypto/rc4.Cipher:
  GO.link/src/crypto/rc4/rc4.go
TYPE crypto/rc4.KeySizeError:
  GO.link/src/crypto/rc4/rc4.go
TYPE crypto/rsa.CRTValue:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.OAEPOptions:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PKCS1v15DecryptOptions:
  GO.link/src/crypto/rsa/pkcs1v15.go
TYPE crypto/rsa.PSSOptions:
  GO.link/src/crypto/rsa/pss.go
TYPE crypto/rsa.PrecomputedValues:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PrivateKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/rsa.PublicKey:
  GO.link/src/crypto/rsa/rsa.go
TYPE crypto/tls.Certificate:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.CertificateRequestInfo:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientAuthType:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientHelloInfo:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientSessionCache:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.ClientSessionState:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.Config:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.Conn:
  GO.link/src/crypto/tls/conn.go
TYPE crypto/tls.ConnectionState:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.CurveID:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.RecordHeaderError:
  GO.link/src/crypto/tls/conn.go
TYPE crypto/tls.RenegotiationSupport:
  GO.link/src/crypto/tls/common.go
TYPE crypto/tls.SignatureScheme:
  GO.link/src/crypto/tls/common.go
TYPE crypto/x509.CertPool:
  GO.link/src/crypto/x509/cert_pool.go
TYPE crypto/x509.Certificate:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.CertificateInvalidError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.CertificateRequest:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.ConstraintViolationError:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.ExtKeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.HostnameError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.InsecureAlgorithmError:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.InvalidReason:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.KeyUsage:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.PEMCipher:
  GO.link/src/crypto/x509/pem_decrypt.go
TYPE crypto/x509.PublicKeyAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.SignatureAlgorithm:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.SystemRootsError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.UnhandledCriticalExtension:
  GO.link/src/crypto/x509/x509.go
TYPE crypto/x509.UnknownAuthorityError:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509.VerifyOptions:
  GO.link/src/crypto/x509/verify.go
TYPE crypto/x509/pkix.AlgorithmIdentifier:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.AttributeTypeAndValue:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.AttributeTypeAndValueSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.CertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.Extension:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.Name:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RDNSequence:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RelativeDistinguishedNameSET:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.RevokedCertificate:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE crypto/x509/pkix.TBSCertificateList:
  GO.link/src/crypto/x509/pkix/pkix.go
TYPE database/sql.ColumnType:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Conn:
  GO.link/src/database/sql/sql.go
TYPE database/sql.DB:
  GO.link/src/database/sql/sql.go
TYPE database/sql.DBStats:
  GO.link/src/database/sql/sql.go
TYPE database/sql.IsolationLevel:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NamedArg:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullBool:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullFloat64:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullInt64:
  GO.link/src/database/sql/sql.go
TYPE database/sql.NullString:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Out:
  GO.link/src/database/sql/sql.go
TYPE database/sql.RawBytes:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Result:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Row:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Rows:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Scanner:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Stmt:
  GO.link/src/database/sql/sql.go
TYPE database/sql.Tx:
  GO.link/src/database/sql/sql.go
TYPE database/sql.TxOptions:
  GO.link/src/database/sql/sql.go
TYPE database/sql/driver.ColumnConverter:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Conn:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ConnBeginTx:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ConnPrepareContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Connector:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Driver:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.DriverContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Execer:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ExecerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.IsolationLevel:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NamedValue:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NamedValueChecker:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.NotNull:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Null:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Pinger:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Queryer:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.QueryerContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Result:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Rows:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsAffected:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeDatabaseTypeName:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeLength:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeNullable:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypePrecisionScale:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsColumnTypeScanType:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.RowsNextResultSet:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.SessionResetter:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Stmt:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.StmtExecContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.StmtQueryContext:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Tx:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.TxOptions:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.Value:
  GO.link/src/database/sql/driver/driver.go
TYPE database/sql/driver.ValueConverter:
  GO.link/src/database/sql/driver/types.go
TYPE database/sql/driver.Valuer:
  GO.link/src/database/sql/driver/types.go
TYPE debug/dwarf.AddrType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.ArrayType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Attr:
  GO.link/src/debug/dwarf/const.go
TYPE debug/dwarf.BasicType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.BoolType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.CharType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Class:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.CommonType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.ComplexType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Data:
  GO.link/src/debug/dwarf/open.go
TYPE debug/dwarf.DecodeError:
  GO.link/src/debug/dwarf/buf.go
TYPE debug/dwarf.DotDotDotType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Entry:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.EnumType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.EnumValue:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Field:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.FloatType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.FuncType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.IntType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.LineEntry:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineFile:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineReader:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.LineReaderPos:
  GO.link/src/debug/dwarf/line.go
TYPE debug/dwarf.Offset:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.PtrType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.QualType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Reader:
  GO.link/src/debug/dwarf/entry.go
TYPE debug/dwarf.StructField:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.StructType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.Tag:
  GO.link/src/debug/dwarf/const.go
TYPE debug/dwarf.Type:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.TypedefType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UcharType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UintType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.UnspecifiedType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/dwarf.VoidType:
  GO.link/src/debug/dwarf/type.go
TYPE debug/elf.Chdr32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Chdr64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Class:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.CompressionType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Data:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Dyn32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Dyn64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.DynFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.DynTag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.File:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.FileHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.FormatError:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Header32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Header64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ImportedSymbol:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Machine:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.NType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.OSABI:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Prog:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Prog32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Prog64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ProgFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.ProgHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.ProgType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_386:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_390:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_AARCH64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_ALPHA:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_ARM:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_MIPS:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_PPC:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_PPC64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_RISCV:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_SPARC:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.R_X86_64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rel32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rel64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rela32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Rela64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Section:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Section32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Section64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionFlag:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionHeader:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.SectionIndex:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SectionType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Sym32:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Sym64:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymBind:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymType:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.SymVis:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Symbol:
  GO.link/src/debug/elf/file.go
TYPE debug/elf.Type:
  GO.link/src/debug/elf/elf.go
TYPE debug/elf.Version:
  GO.link/src/debug/elf/elf.go
TYPE debug/gosym.DecodingError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Func:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.LineTable:
  GO.link/src/debug/gosym/pclntab.go
TYPE debug/gosym.Obj:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Sym:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.Table:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.UnknownFileError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/gosym.UnknownLineError:
  GO.link/src/debug/gosym/symtab.go
TYPE debug/macho.Cpu:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Dylib:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.DylibCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Dysymtab:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.DysymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.FatArch:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.FatArchHeader:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.FatFile:
  GO.link/src/debug/macho/fat.go
TYPE debug/macho.File:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.FileHeader:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.FormatError:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Load:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.LoadBytes:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.LoadCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Nlist32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Nlist64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Regs386:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.RegsAMD64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Reloc:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.RelocTypeARM:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeARM64:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeGeneric:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.RelocTypeX86_64:
  GO.link/src/debug/macho/reloctype.go
TYPE debug/macho.Rpath:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.RpathCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Section:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Section32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Section64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.SectionHeader:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Segment:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Segment32:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Segment64:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.SegmentHeader:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Symbol:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.Symtab:
  GO.link/src/debug/macho/file.go
TYPE debug/macho.SymtabCmd:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Thread:
  GO.link/src/debug/macho/macho.go
TYPE debug/macho.Type:
  GO.link/src/debug/macho/macho.go
TYPE debug/pe.COFFSymbol:
  GO.link/src/debug/pe/symbol.go
TYPE debug/pe.DataDirectory:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.File:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.FileHeader:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.FormatError:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.ImportDirectory:
  GO.link/src/debug/pe/file.go
TYPE debug/pe.OptionalHeader32:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.OptionalHeader64:
  GO.link/src/debug/pe/pe.go
TYPE debug/pe.Reloc:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.Section:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.SectionHeader:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.SectionHeader32:
  GO.link/src/debug/pe/section.go
TYPE debug/pe.StringTable:
  GO.link/src/debug/pe/string.go
TYPE debug/pe.Symbol:
  GO.link/src/debug/pe/symbol.go
TYPE debug/plan9obj.File:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.FileHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.Section:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.SectionHeader:
  GO.link/src/debug/plan9obj/file.go
TYPE debug/plan9obj.Sym:
  GO.link/src/debug/plan9obj/file.go
TYPE encoding.BinaryMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.BinaryUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextMarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding.TextUnmarshaler:
  GO.link/src/encoding/encoding.go
TYPE encoding/ascii85.CorruptInputError:
  GO.link/src/encoding/ascii85/ascii85.go
TYPE encoding/asn1.BitString:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.Enumerated:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.Flag:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.ObjectIdentifier:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.RawContent:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.RawValue:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.StructuralError:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/asn1.SyntaxError:
  GO.link/src/encoding/asn1/asn1.go
TYPE encoding/base32.CorruptInputError:
  GO.link/src/encoding/base32/base32.go
TYPE encoding/base32.Encoding:
  GO.link/src/encoding/base32/base32.go
TYPE encoding/base64.CorruptInputError:
  GO.link/src/encoding/base64/base64.go
TYPE encoding/base64.Encoding:
  GO.link/src/encoding/base64/base64.go
TYPE encoding/binary.ByteOrder:
  GO.link/src/encoding/binary/binary.go
TYPE encoding/csv.ParseError:
  GO.link/src/encoding/csv/reader.go
TYPE encoding/csv.Reader:
  GO.link/src/encoding/csv/reader.go
TYPE encoding/csv.Writer:
  GO.link/src/encoding/csv/writer.go
TYPE encoding/gob.CommonType:
  GO.link/src/encoding/gob/type.go
TYPE encoding/gob.Decoder:
  GO.link/src/encoding/gob/decoder.go
TYPE encoding/gob.Encoder:
  GO.link/src/encoding/gob/encoder.go
TYPE encoding/gob.GobDecoder:
  GO.link/src/encoding/gob/type.go
TYPE encoding/gob.GobEncoder:
  GO.link/src/encoding/gob/type.go
TYPE encoding/hex.InvalidByteError:
  GO.link/src/encoding/hex/hex.go
TYPE encoding/json.Decoder:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.Delim:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.Encoder:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.InvalidUTF8Error:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.InvalidUnmarshalError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.Marshaler:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.MarshalerError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.Number:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.RawMessage:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.SyntaxError:
  GO.link/src/encoding/json/scanner.go
TYPE encoding/json.Token:
  GO.link/src/encoding/json/stream.go
TYPE encoding/json.UnmarshalFieldError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.UnmarshalTypeError:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.Unmarshaler:
  GO.link/src/encoding/json/decode.go
TYPE encoding/json.UnsupportedTypeError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/json.UnsupportedValueError:
  GO.link/src/encoding/json/encode.go
TYPE encoding/pem.Block:
  GO.link/src/encoding/pem/pem.go
TYPE encoding/xml.Attr:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.CharData:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Comment:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Decoder:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Directive:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Encoder:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.EndElement:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.Marshaler:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.MarshalerAttr:
  GO.link/src/encoding/xml/marshal.go
TYPE encoding/xml.Name:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.ProcInst:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.StartElement:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.SyntaxError:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.TagPathError:
  GO.link/src/encoding/xml/typeinfo.go
TYPE encoding/xml.Token:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.TokenReader:
  GO.link/src/encoding/xml/xml.go
TYPE encoding/xml.UnmarshalError:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.Unmarshaler:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.UnmarshalerAttr:
  GO.link/src/encoding/xml/read.go
TYPE encoding/xml.UnsupportedTypeError:
  GO.link/src/encoding/xml/marshal.go
TYPE expvar.Float:
  GO.link/src/expvar/expvar.go
TYPE expvar.Func:
  GO.link/src/expvar/expvar.go
TYPE expvar.Int:
  GO.link/src/expvar/expvar.go
TYPE expvar.KeyValue:
  GO.link/src/expvar/expvar.go
TYPE expvar.Map:
  GO.link/src/expvar/expvar.go
TYPE expvar.String:
  GO.link/src/expvar/expvar.go
TYPE expvar.Var:
  GO.link/src/expvar/expvar.go
TYPE flag.ErrorHandling:
  GO.link/src/flag/flag.go
TYPE flag.Flag:
  GO.link/src/flag/flag.go
TYPE flag.FlagSet:
  GO.link/src/flag/flag.go
TYPE flag.Getter:
  GO.link/src/flag/flag.go
TYPE flag.Value:
  GO.link/src/flag/flag.go
TYPE fmt.Formatter:
  GO.link/src/fmt/print.go
TYPE fmt.GoStringer:
  GO.link/src/fmt/print.go
TYPE fmt.ScanState:
  GO.link/src/fmt/scan.go
TYPE fmt.Scanner:
  GO.link/src/fmt/scan.go
TYPE fmt.State:
  GO.link/src/fmt/print.go
TYPE fmt.Stringer:
  GO.link/src/fmt/print.go
TYPE go/ast.ArrayType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.AssignStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BadStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BasicLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BinaryExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BlockStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.BranchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CallExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CaseClause:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ChanDir:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ChanType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommClause:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Comment:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommentGroup:
  GO.link/src/go/ast/ast.go
TYPE go/ast.CommentMap:
  GO.link/src/go/ast/commentmap.go
TYPE go/ast.CompositeLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Decl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.DeclStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.DeferStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Ellipsis:
  GO.link/src/go/ast/ast.go
TYPE go/ast.EmptyStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Expr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ExprStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Field:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FieldFilter:
  GO.link/src/go/ast/print.go
TYPE go/ast.FieldList:
  GO.link/src/go/ast/ast.go
TYPE go/ast.File:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Filter:
  GO.link/src/go/ast/filter.go
TYPE go/ast.ForStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncLit:
  GO.link/src/go/ast/ast.go
TYPE go/ast.FuncType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.GenDecl:
  GO.link/src/go/ast/ast.go
TYPE go/ast.GoStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Ident:
  GO.link/src/go/ast/ast.go
TYPE go/ast.IfStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ImportSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Importer:
  GO.link/src/go/ast/resolve.go
TYPE go/ast.IncDecStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.IndexExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.InterfaceType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.KeyValueExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.LabeledStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.MapType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.MergeMode:
  GO.link/src/go/ast/filter.go
TYPE go/ast.Node:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ObjKind:
  GO.link/src/go/ast/scope.go
TYPE go/ast.Object:
  GO.link/src/go/ast/scope.go
TYPE go/ast.Package:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ParenExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.RangeStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ReturnStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Scope:
  GO.link/src/go/ast/scope.go
TYPE go/ast.SelectStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SelectorExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SendStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SliceExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Spec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.StarExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Stmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.StructType:
  GO.link/src/go/ast/ast.go
TYPE go/ast.SwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeAssertExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.TypeSwitchStmt:
  GO.link/src/go/ast/ast.go
TYPE go/ast.UnaryExpr:
  GO.link/src/go/ast/ast.go
TYPE go/ast.ValueSpec:
  GO.link/src/go/ast/ast.go
TYPE go/ast.Visitor:
  GO.link/src/go/ast/walk.go
TYPE go/build.Context:
  GO.link/src/go/build/build.go
TYPE go/build.ImportMode:
  GO.link/src/go/build/build.go
TYPE go/build.MultiplePackageError:
  GO.link/src/go/build/build.go
TYPE go/build.NoGoError:
  GO.link/src/go/build/build.go
TYPE go/build.Package:
  GO.link/src/go/build/build.go
TYPE go/constant.Kind:
  GO.link/src/go/constant/value.go
TYPE go/constant.Value:
  GO.link/src/go/constant/value.go
TYPE go/doc.Example:
  GO.link/src/go/doc/example.go
TYPE go/doc.Filter:
  GO.link/src/go/doc/filter.go
TYPE go/doc.Func:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Mode:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Note:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Package:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Type:
  GO.link/src/go/doc/doc.go
TYPE go/doc.Value:
  GO.link/src/go/doc/doc.go
TYPE go/importer.Lookup:
  GO.link/src/go/importer/importer.go
TYPE go/parser.Mode:
  GO.link/src/go/parser/interface.go
TYPE go/printer.CommentedNode:
  GO.link/src/go/printer/printer.go
TYPE go/printer.Config:
  GO.link/src/go/printer/printer.go
TYPE go/printer.Mode:
  GO.link/src/go/printer/printer.go
TYPE go/scanner.Error:
  GO.link/src/go/scanner/errors.go
TYPE go/scanner.ErrorHandler:
  GO.link/src/go/scanner/scanner.go
TYPE go/scanner.ErrorList:
  GO.link/src/go/scanner/errors.go
TYPE go/scanner.Mode:
  GO.link/src/go/scanner/scanner.go
TYPE go/scanner.Scanner:
  GO.link/src/go/scanner/scanner.go
TYPE go/token.File:
  GO.link/src/go/token/position.go
TYPE go/token.FileSet:
  GO.link/src/go/token/position.go
TYPE go/token.Pos:
  GO.link/src/go/token/position.go
TYPE go/token.Position:
  GO.link/src/go/token/position.go
TYPE go/token.Token:
  GO.link/src/go/token/token.go
TYPE go/types.Array:
  GO.link/src/go/types/type.go
TYPE go/types.Basic:
  GO.link/src/go/types/type.go
TYPE go/types.BasicInfo:
  GO.link/src/go/types/type.go
TYPE go/types.BasicKind:
  GO.link/src/go/types/type.go
TYPE go/types.Builtin:
  GO.link/src/go/types/object.go
TYPE go/types.Chan:
  GO.link/src/go/types/type.go
TYPE go/types.ChanDir:
  GO.link/src/go/types/type.go
TYPE go/types.Checker:
  GO.link/src/go/types/check.go
TYPE go/types.Config:
  GO.link/src/go/types/api.go
TYPE go/types.Const:
  GO.link/src/go/types/object.go
TYPE go/types.Error:
  GO.link/src/go/types/api.go
TYPE go/types.Func:
  GO.link/src/go/types/object.go
TYPE go/types.ImportMode:
  GO.link/src/go/types/api.go
TYPE go/types.Importer:
  GO.link/src/go/types/api.go
TYPE go/types.ImporterFrom:
  GO.link/src/go/types/api.go
TYPE go/types.Info:
  GO.link/src/go/types/api.go
TYPE go/types.Initializer:
  GO.link/src/go/types/api.go
TYPE go/types.Interface:
  GO.link/src/go/types/type.go
TYPE go/types.Label:
  GO.link/src/go/types/object.go
TYPE go/types.Map:
  GO.link/src/go/types/type.go
TYPE go/types.MethodSet:
  GO.link/src/go/types/methodset.go
TYPE go/types.Named:
  GO.link/src/go/types/type.go
TYPE go/types.Nil:
  GO.link/src/go/types/object.go
TYPE go/types.Object:
  GO.link/src/go/types/object.go
TYPE go/types.Package:
  GO.link/src/go/types/package.go
TYPE go/types.PkgName:
  GO.link/src/go/types/object.go
TYPE go/types.Pointer:
  GO.link/src/go/types/type.go
TYPE go/types.Qualifier:
  GO.link/src/go/types/typestring.go
TYPE go/types.Scope:
  GO.link/src/go/types/scope.go
TYPE go/types.Selection:
  GO.link/src/go/types/selection.go
TYPE go/types.SelectionKind:
  GO.link/src/go/types/selection.go
TYPE go/types.Signature:
  GO.link/src/go/types/type.go
TYPE go/types.Sizes:
  GO.link/src/go/types/sizes.go
TYPE go/types.Slice:
  GO.link/src/go/types/type.go
TYPE go/types.StdSizes:
  GO.link/src/go/types/sizes.go
TYPE go/types.Struct:
  GO.link/src/go/types/type.go
TYPE go/types.Tuple:
  GO.link/src/go/types/type.go
TYPE go/types.Type:
  GO.link/src/go/types/type.go
TYPE go/types.TypeAndValue:
  GO.link/src/go/types/api.go
TYPE go/types.TypeName:
  GO.link/src/go/types/object.go
TYPE go/types.Var:
  GO.link/src/go/types/object.go
TYPE hash.Hash:
  GO.link/src/hash/hash.go
TYPE hash.Hash32:
  GO.link/src/hash/hash.go
TYPE hash.Hash64:
  GO.link/src/hash/hash.go
TYPE hash/crc32.Table:
  GO.link/src/hash/crc32/crc32.go
TYPE hash/crc64.Table:
  GO.link/src/hash/crc64/crc64.go
TYPE html/template.CSS:
  GO.link/src/html/template/content.go
TYPE html/template.Error:
  GO.link/src/html/template/error.go
TYPE html/template.ErrorCode:
  GO.link/src/html/template/error.go
TYPE html/template.FuncMap:
  GO.link/src/html/template/template.go
TYPE html/template.HTML:
  GO.link/src/html/template/content.go
TYPE html/template.HTMLAttr:
  GO.link/src/html/template/content.go
TYPE html/template.JS:
  GO.link/src/html/template/content.go
TYPE html/template.JSStr:
  GO.link/src/html/template/content.go
TYPE html/template.Srcset:
  GO.link/src/html/template/content.go
TYPE html/template.Template:
  GO.link/src/html/template/template.go
TYPE html/template.URL:
  GO.link/src/html/template/content.go
TYPE image.Alpha:
  GO.link/src/image/image.go
TYPE image.Alpha16:
  GO.link/src/image/image.go
TYPE image.CMYK:
  GO.link/src/image/image.go
TYPE image.Config:
  GO.link/src/image/image.go
TYPE image.Gray:
  GO.link/src/image/image.go
TYPE image.Gray16:
  GO.link/src/image/image.go
TYPE image.Image:
  GO.link/src/image/image.go
TYPE image.NRGBA:
  GO.link/src/image/image.go
TYPE image.NRGBA64:
  GO.link/src/image/image.go
TYPE image.NYCbCrA:
  GO.link/src/image/ycbcr.go
TYPE image.Paletted:
  GO.link/src/image/image.go
TYPE image.PalettedImage:
  GO.link/src/image/image.go
TYPE image.Point:
  GO.link/src/image/geom.go
TYPE image.RGBA:
  GO.link/src/image/image.go
TYPE image.RGBA64:
  GO.link/src/image/image.go
TYPE image.Rectangle:
  GO.link/src/image/geom.go
TYPE image.Uniform:
  GO.link/src/image/names.go
TYPE image.YCbCr:
  GO.link/src/image/ycbcr.go
TYPE image.YCbCrSubsampleRatio:
  GO.link/src/image/ycbcr.go
TYPE image/color.Alpha:
  GO.link/src/image/color/color.go
TYPE image/color.Alpha16:
  GO.link/src/image/color/color.go
TYPE image/color.CMYK:
  GO.link/src/image/color/ycbcr.go
TYPE image/color.Color:
  GO.link/src/image/color/color.go
TYPE image/color.Gray:
  GO.link/src/image/color/color.go
TYPE image/color.Gray16:
  GO.link/src/image/color/color.go
TYPE image/color.Model:
  GO.link/src/image/color/color.go
TYPE image/color.NRGBA:
  GO.link/src/image/color/color.go
TYPE image/color.NRGBA64:
  GO.link/src/image/color/color.go
TYPE image/color.NYCbCrA:
  GO.link/src/image/color/ycbcr.go
TYPE image/color.Palette:
  GO.link/src/image/color/color.go
TYPE image/color.RGBA:
  GO.link/src/image/color/color.go
TYPE image/color.RGBA64:
  GO.link/src/image/color/color.go
TYPE image/color.YCbCr:
  GO.link/src/image/color/ycbcr.go
TYPE image/draw.Drawer:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Image:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Op:
  GO.link/src/image/draw/draw.go
TYPE image/draw.Quantizer:
  GO.link/src/image/draw/draw.go
TYPE image/gif.GIF:
  GO.link/src/image/gif/reader.go
TYPE image/gif.Options:
  GO.link/src/image/gif/writer.go
TYPE image/jpeg.FormatError:
  GO.link/src/image/jpeg/reader.go
TYPE image/jpeg.Options:
  GO.link/src/image/jpeg/writer.go
TYPE image/jpeg.Reader:
  GO.link/src/image/jpeg/reader.go
TYPE image/jpeg.UnsupportedError:
  GO.link/src/image/jpeg/reader.go
TYPE image/png.CompressionLevel:
  GO.link/src/image/png/writer.go
TYPE image/png.Encoder:
  GO.link/src/image/png/writer.go
TYPE image/png.EncoderBuffer:
  GO.link/src/image/png/writer.go
TYPE image/png.EncoderBufferPool:
  GO.link/src/image/png/writer.go
TYPE image/png.FormatError:
  GO.link/src/image/png/reader.go
TYPE image/png.UnsupportedError:
  GO.link/src/image/png/reader.go
TYPE index/suffixarray.Index:
  GO.link/src/index/suffixarray/suffixarray.go
TYPE io.ByteReader:
  GO.link/src/io/io.go
TYPE io.ByteScanner:
  GO.link/src/io/io.go
TYPE io.ByteWriter:
  GO.link/src/io/io.go
TYPE io.Closer:
  GO.link/src/io/io.go
TYPE io.LimitedReader:
  GO.link/src/io/io.go
TYPE io.PipeReader:
  GO.link/src/io/pipe.go
TYPE io.PipeWriter:
  GO.link/src/io/pipe.go
TYPE io.ReadCloser:
  GO.link/src/io/io.go
TYPE io.ReadSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriteCloser:
  GO.link/src/io/io.go
TYPE io.ReadWriteSeeker:
  GO.link/src/io/io.go
TYPE io.ReadWriter:
  GO.link/src/io/io.go
TYPE io.Reader:
  GO.link/src/io/io.go
TYPE io.ReaderAt:
  GO.link/src/io/io.go
TYPE io.ReaderFrom:
  GO.link/src/io/io.go
TYPE io.RuneReader:
  GO.link/src/io/io.go
TYPE io.RuneScanner:
  GO.link/src/io/io.go
TYPE io.SectionReader:
  GO.link/src/io/io.go
TYPE io.Seeker:
  GO.link/src/io/io.go
TYPE io.WriteCloser:
  GO.link/src/io/io.go
TYPE io.WriteSeeker:
  GO.link/src/io/io.go
TYPE io.Writer:
  GO.link/src/io/io.go
TYPE io.WriterAt:
  GO.link/src/io/io.go
TYPE io.WriterTo:
  GO.link/src/io/io.go
TYPE log.Logger:
  GO.link/src/log/log.go
TYPE log/syslog.Priority:
  GO.link/src/log/syslog/syslog.go
TYPE log/syslog.Writer:
  GO.link/src/log/syslog/syslog.go
TYPE math/big.Accuracy:
  GO.link/src/math/big/float.go
TYPE math/big.ErrNaN:
  GO.link/src/math/big/float.go
TYPE math/big.Float:
  GO.link/src/math/big/float.go
TYPE math/big.Int:
  GO.link/src/math/big/int.go
TYPE math/big.Rat:
  GO.link/src/math/big/rat.go
TYPE math/big.RoundingMode:
  GO.link/src/math/big/float.go
TYPE math/big.Word:
  GO.link/src/math/big/arith.go
TYPE math/rand.Rand:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Source:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Source64:
  GO.link/src/math/rand/rand.go
TYPE math/rand.Zipf:
  GO.link/src/math/rand/zipf.go
TYPE mime.WordDecoder:
  GO.link/src/mime/encodedword.go
TYPE mime.WordEncoder:
  GO.link/src/mime/encodedword.go
TYPE mime/multipart.File:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.FileHeader:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.Form:
  GO.link/src/mime/multipart/formdata.go
TYPE mime/multipart.Part:
  GO.link/src/mime/multipart/multipart.go
TYPE mime/multipart.Reader:
  GO.link/src/mime/multipart/multipart.go
TYPE mime/multipart.Writer:
  GO.link/src/mime/multipart/writer.go
TYPE mime/quotedprintable.Reader:
  GO.link/src/mime/quotedprintable/reader.go
TYPE mime/quotedprintable.Writer:
  GO.link/src/mime/quotedprintable/writer.go
TYPE net.Addr:
  GO.link/src/net/net.go
TYPE net.AddrError:
  GO.link/src/net/net.go
TYPE net.Buffers:
  GO.link/src/net/net.go
TYPE net.Conn:
  GO.link/src/net/net.go
TYPE net.DNSConfigError:
  GO.link/src/net/net.go
TYPE net.DNSError:
  GO.link/src/net/net.go
TYPE net.Dialer:
  GO.link/src/net/dial.go
TYPE net.Error:
  GO.link/src/net/net.go
TYPE net.Flags:
  GO.link/src/net/interface.go
TYPE net.HardwareAddr:
  GO.link/src/net/mac.go
TYPE net.IP:
  GO.link/src/net/ip.go
TYPE net.IPAddr:
  GO.link/src/net/iprawsock.go
TYPE net.IPConn:
  GO.link/src/net/iprawsock.go
TYPE net.IPMask:
  GO.link/src/net/ip.go
TYPE net.IPNet:
  GO.link/src/net/ip.go
TYPE net.Interface:
  GO.link/src/net/interface.go
TYPE net.InvalidAddrError:
  GO.link/src/net/net.go
TYPE net.ListenConfig:
  GO.link/src/net/dial.go
TYPE net.Listener:
  GO.link/src/net/net.go
TYPE net.MX:
  GO.link/src/net/dnsclient.go
TYPE net.NS:
  GO.link/src/net/dnsclient.go
TYPE net.OpError:
  GO.link/src/net/net.go
TYPE net.PacketConn:
  GO.link/src/net/net.go
TYPE net.ParseError:
  GO.link/src/net/net.go
TYPE net.Resolver:
  GO.link/src/net/lookup.go
TYPE net.SRV:
  GO.link/src/net/dnsclient.go
TYPE net.TCPAddr:
  GO.link/src/net/tcpsock.go
TYPE net.TCPConn:
  GO.link/src/net/tcpsock.go
TYPE net.TCPListener:
  GO.link/src/net/tcpsock.go
TYPE net.UDPAddr:
  GO.link/src/net/udpsock.go
TYPE net.UDPConn:
  GO.link/src/net/udpsock.go
TYPE net.UnixAddr:
  GO.link/src/net/unixsock.go
TYPE net.UnixConn:
  GO.link/src/net/unixsock.go
TYPE net.UnixListener:
  GO.link/src/net/unixsock.go
TYPE net.UnknownNetworkError:
  GO.link/src/net/net.go
TYPE net/http.Client:
  GO.link/src/net/http/client.go
TYPE net/http.CloseNotifier:
  GO.link/src/net/http/server.go
TYPE net/http.ConnState:
  GO.link/src/net/http/server.go
TYPE net/http.Cookie:
  GO.link/src/net/http/cookie.go
TYPE net/http.CookieJar:
  GO.link/src/net/http/jar.go
TYPE net/http.Dir:
  GO.link/src/net/http/fs.go
TYPE net/http.File:
  GO.link/src/net/http/fs.go
TYPE net/http.FileSystem:
  GO.link/src/net/http/fs.go
TYPE net/http.Flusher:
  GO.link/src/net/http/server.go
TYPE net/http.Handler:
  GO.link/src/net/http/server.go
TYPE net/http.HandlerFunc:
  GO.link/src/net/http/server.go
TYPE net/http.Header:
  GO.link/src/net/http/header.go
TYPE net/http.Hijacker:
  GO.link/src/net/http/server.go
TYPE net/http.ProtocolError:
  GO.link/src/net/http/request.go
TYPE net/http.PushOptions:
  GO.link/src/net/http/http.go
TYPE net/http.Pusher:
  GO.link/src/net/http/http.go
TYPE net/http.Request:
  GO.link/src/net/http/request.go
TYPE net/http.Response:
  GO.link/src/net/http/response.go
TYPE net/http.ResponseWriter:
  GO.link/src/net/http/server.go
TYPE net/http.RoundTripper:
  GO.link/src/net/http/client.go
TYPE net/http.SameSite:
  GO.link/src/net/http/cookie.go
TYPE net/http.ServeMux:
  GO.link/src/net/http/server.go
TYPE net/http.Server:
  GO.link/src/net/http/server.go
TYPE net/http.Transport:
  GO.link/src/net/http/transport.go
TYPE net/http/cgi.Handler:
  GO.link/src/net/http/cgi/host.go
TYPE net/http/cookiejar.Jar:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.Options:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/cookiejar.PublicSuffixList:
  GO.link/src/net/http/cookiejar/jar.go
TYPE net/http/httptest.ResponseRecorder:
  GO.link/src/net/http/httptest/recorder.go
TYPE net/http/httptest.Server:
  GO.link/src/net/http/httptest/server.go
TYPE net/http/httptrace.ClientTrace:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSDoneInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.DNSStartInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.GotConnInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httptrace.WroteRequestInfo:
  GO.link/src/net/http/httptrace/trace.go
TYPE net/http/httputil.BufferPool:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ClientConn:
  GO.link/src/net/http/httputil/persist.go
TYPE net/http/httputil.ReverseProxy:
  GO.link/src/net/http/httputil/reverseproxy.go
TYPE net/http/httputil.ServerConn:
  GO.link/src/net/http/httputil/persist.go
TYPE net/mail.Address:
  GO.link/src/net/mail/message.go
TYPE net/mail.AddressParser:
  GO.link/src/net/mail/message.go
TYPE net/mail.Header:
  GO.link/src/net/mail/message.go
TYPE net/mail.Message:
  GO.link/src/net/mail/message.go
TYPE net/rpc.Call:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.Client:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.ClientCodec:
  GO.link/src/net/rpc/client.go
TYPE net/rpc.Request:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.Response:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.Server:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.ServerCodec:
  GO.link/src/net/rpc/server.go
TYPE net/rpc.ServerError:
  GO.link/src/net/rpc/client.go
TYPE net/smtp.Auth:
  GO.link/src/net/smtp/auth.go
TYPE net/smtp.Client:
  GO.link/src/net/smtp/smtp.go
TYPE net/smtp.ServerInfo:
  GO.link/src/net/smtp/auth.go
TYPE net/textproto.Conn:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.Error:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.MIMEHeader:
  GO.link/src/net/textproto/header.go
TYPE net/textproto.Pipeline:
  GO.link/src/net/textproto/pipeline.go
TYPE net/textproto.ProtocolError:
  GO.link/src/net/textproto/textproto.go
TYPE net/textproto.Reader:
  GO.link/src/net/textproto/reader.go
TYPE net/textproto.Writer:
  GO.link/src/net/textproto/writer.go
TYPE net/url.Error:
  GO.link/src/net/url/url.go
TYPE net/url.EscapeError:
  GO.link/src/net/url/url.go
TYPE net/url.InvalidHostError:
  GO.link/src/net/url/url.go
TYPE net/url.URL:
  GO.link/src/net/url/url.go
TYPE net/url.Userinfo:
  GO.link/src/net/url/url.go
TYPE net/url.Values:
  GO.link/src/net/url/url.go
TYPE os.File:
  GO.link/src/os/types.go
TYPE os.FileInfo:
  GO.link/src/os/types.go
TYPE os.FileMode:
  GO.link/src/os/types.go
TYPE os.LinkError:
  GO.link/src/os/file.go
TYPE os.PathError:
  GO.link/src/os/error.go
TYPE os.ProcAttr:
  GO.link/src/os/exec.go
TYPE os.Process:
  GO.link/src/os/exec.go
TYPE os.ProcessState:
  GO.link/src/os/exec_posix.go
TYPE os.Signal:
  GO.link/src/os/exec.go
TYPE os.SyscallError:
  GO.link/src/os/error.go
TYPE os/exec.Cmd:
  GO.link/src/os/exec/exec.go
TYPE os/exec.Error:
  GO.link/src/os/exec/exec.go
TYPE os/exec.ExitError:
  GO.link/src/os/exec/exec.go
TYPE os/user.Group:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownGroupError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownGroupIdError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownUserError:
  GO.link/src/os/user/user.go
TYPE os/user.UnknownUserIdError:
  GO.link/src/os/user/user.go
TYPE os/user.User:
  GO.link/src/os/user/user.go
TYPE path/filepath.WalkFunc:
  GO.link/src/path/filepath/path.go
TYPE plugin.Plugin:
  GO.link/src/plugin/plugin.go
TYPE plugin.Symbol:
  GO.link/src/plugin/plugin.go
TYPE reflect.ChanDir:
  GO.link/src/reflect/type.go
TYPE reflect.Kind:
  GO.link/src/reflect/type.go
TYPE reflect.Method:
  GO.link/src/reflect/type.go
TYPE reflect.SelectCase:
  GO.link/src/reflect/value.go
TYPE reflect.SelectDir:
  GO.link/src/reflect/value.go
TYPE reflect.SliceHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StringHeader:
  GO.link/src/reflect/value.go
TYPE reflect.StructField:
  GO.link/src/reflect/type.go
TYPE reflect.StructTag:
  GO.link/src/reflect/type.go
TYPE reflect.Type:
  GO.link/src/reflect/type.go
TYPE reflect.Value:
  GO.link/src/reflect/value.go
TYPE reflect.ValueError:
  GO.link/src/reflect/value.go
TYPE regexp.Regexp:
  GO.link/src/regexp/regexp.go
TYPE regexp/syntax.EmptyOp:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Error:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.ErrorCode:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.Flags:
  GO.link/src/regexp/syntax/parse.go
TYPE regexp/syntax.Inst:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.InstOp:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Op:
  GO.link/src/regexp/syntax/regexp.go
TYPE regexp/syntax.Prog:
  GO.link/src/regexp/syntax/prog.go
TYPE regexp/syntax.Regexp:
  GO.link/src/regexp/syntax/regexp.go
TYPE runtime.BlockProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.Error:
  GO.link/src/runtime/error.go
TYPE runtime.Frame:
  GO.link/src/runtime/symtab.go
TYPE runtime.Frames:
  GO.link/src/runtime/symtab.go
TYPE runtime.Func:
  GO.link/src/runtime/symtab.go
TYPE runtime.MemProfileRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.MemStats:
  GO.link/src/runtime/mstats.go
TYPE runtime.StackRecord:
  GO.link/src/runtime/mprof.go
TYPE runtime.TypeAssertionError:
  GO.link/src/runtime/error.go
TYPE runtime/debug.GCStats:
  GO.link/src/runtime/debug/garbage.go
TYPE runtime/pprof.LabelSet:
  GO.link/src/runtime/pprof/label.go
TYPE runtime/pprof.Profile:
  GO.link/src/runtime/pprof/pprof.go
TYPE runtime/trace.Region:
  GO.link/src/runtime/trace/annotation.go
TYPE runtime/trace.Task:
  GO.link/src/runtime/trace/annotation.go
TYPE sort.Float64Slice:
  GO.link/src/sort/sort.go
TYPE sort.IntSlice:
  GO.link/src/sort/sort.go
TYPE sort.Interface:
  GO.link/src/sort/sort.go
TYPE sort.StringSlice:
  GO.link/src/sort/sort.go
TYPE strconv.NumError:
  GO.link/src/strconv/atoi.go
TYPE strings.Builder:
  GO.link/src/strings/builder.go
TYPE strings.Reader:
  GO.link/src/strings/reader.go
TYPE strings.Replacer:
  GO.link/src/strings/replace.go
TYPE sync.Cond:
  GO.link/src/sync/cond.go
TYPE sync.Locker:
  GO.link/src/sync/mutex.go
TYPE sync.Map:
  GO.link/src/sync/map.go
TYPE sync.Mutex:
  GO.link/src/sync/mutex.go
TYPE sync.Once:
  GO.link/src/sync/once.go
TYPE sync.Pool:
  GO.link/src/sync/pool.go
TYPE sync.RWMutex:
  GO.link/src/sync/rwmutex.go
TYPE sync.WaitGroup:
  GO.link/src/sync/waitgroup.go
TYPE sync/atomic.Value:
  GO.link/src/sync/atomic/value.go
TYPE syscall.Cmsghdr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Conn:
  GO.link/src/syscall/net.go
TYPE syscall.Credential:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.Dirent:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.EpollEvent:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Errno:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.FdSet:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Flock_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Fsid:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.ICMPv6Filter:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPMreq:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPMreqn:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPv6MTUInfo:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IPv6Mreq:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IfAddrmsg:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.IfInfomsg:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Inet4Pktinfo:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Inet6Pktinfo:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.InotifyEvent:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Iovec:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Linger:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Msghdr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NetlinkMessage:
  GO.link/src/syscall/netlink_linux.go
TYPE syscall.NetlinkRouteAttr:
  GO.link/src/syscall/netlink_linux.go
TYPE syscall.NetlinkRouteRequest:
  GO.link/src/syscall/netlink_linux.go
TYPE syscall.NlAttr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NlMsgerr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.NlMsghdr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.ProcAttr:
  GO.link/src/syscall/exec_unix.go
TYPE syscall.PtraceRegs:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawConn:
  GO.link/src/syscall/net.go
TYPE syscall.RawSockaddr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrAny:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrInet4:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrInet6:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrLinklayer:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrNetlink:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RawSockaddrUnix:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Rlimit:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtAttr:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtGenmsg:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtMsg:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.RtNexthop:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Rusage:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Signal:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockFilter:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.SockFprog:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Sockaddr:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet4:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrInet6:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SockaddrLinklayer:
  GO.link/src/syscall/syscall_linux.go
TYPE syscall.SockaddrNetlink:
  GO.link/src/syscall/syscall_linux.go
TYPE syscall.SockaddrUnix:
  GO.link/src/syscall/syscall_unix.go
TYPE syscall.SocketControlMessage:
  GO.link/src/syscall/sockcmsg_unix.go
TYPE syscall.Stat_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Statfs_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.SysProcAttr:
  GO.link/src/syscall/exec_linux.go
TYPE syscall.SysProcIDMap:
  GO.link/src/syscall/exec_linux.go
TYPE syscall.Sysinfo_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.TCPInfo:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Termios:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Time_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timespec:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timeval:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Timex:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Tms:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Ucred:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Ustat_t:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Utimbuf:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.Utsname:
  GO.link/src/syscall/ztypes_linux_amd64.go
TYPE syscall.WaitStatus:
  GO.link/src/syscall/syscall_linux.go
TYPE testing.B:
  GO.link/src/testing/benchmark.go
TYPE testing.BenchmarkResult:
  GO.link/src/testing/benchmark.go
TYPE testing.Cover:
  GO.link/src/testing/cover.go
TYPE testing.CoverBlock:
  GO.link/src/testing/cover.go
TYPE testing.InternalBenchmark:
  GO.link/src/testing/benchmark.go
TYPE testing.InternalExample:
  GO.link/src/testing/example.go
TYPE testing.InternalTest:
  GO.link/src/testing/testing.go
TYPE testing.M:
  GO.link/src/testing/testing.go
TYPE testing.PB:
  GO.link/src/testing/benchmark.go
TYPE testing.T:
  GO.link/src/testing/testing.go
TYPE testing.TB:
  GO.link/src/testing/testing.go
TYPE testing/quick.CheckEqualError:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.CheckError:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.Config:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.Generator:
  GO.link/src/testing/quick/quick.go
TYPE testing/quick.SetupError:
  GO.link/src/testing/quick/quick.go
TYPE text/scanner.Position:
  GO.link/src/text/scanner/scanner.go
TYPE text/scanner.Scanner:
  GO.link/src/text/scanner/scanner.go
TYPE text/tabwriter.Writer:
  GO.link/src/text/tabwriter/tabwriter.go
TYPE text/template.ExecError:
  GO.link/src/text/template/exec.go
TYPE text/template.FuncMap:
  GO.link/src/text/template/funcs.go
TYPE text/template.Template:
  GO.link/src/text/template/template.go
TYPE text/template/parse.ActionNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.BoolNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.BranchNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.ChainNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.CommandNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.DotNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.FieldNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.IdentifierNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.IfNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.ListNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NilNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Node:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NodeType:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.NumberNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.PipeNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Pos:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.RangeNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.StringNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.TemplateNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.TextNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.Tree:
  GO.link/src/text/template/parse/parse.go
TYPE text/template/parse.VariableNode:
  GO.link/src/text/template/parse/node.go
TYPE text/template/parse.WithNode:
  GO.link/src/text/template/parse/node.go
TYPE time.Duration:
  GO.link/src/time/time.go
TYPE time.Location:
  GO.link/src/time/zoneinfo.go
TYPE time.Month:
  GO.link/src/time/time.go
TYPE time.ParseError:
  GO.link/src/time/format.go
TYPE time.Ticker:
  GO.link/src/time/tick.go
TYPE time.Time:
  GO.link/src/time/time.go
TYPE time.Timer:
  GO.link/src/time/sleep.go
TYPE time.Weekday:
  GO.link/src/time/time.go
TYPE unicode.CaseRange:
  GO.link/src/unicode/letter.go
TYPE unicode.Range16:
  GO.link/src/unicode/letter.go
TYPE unicode.Range32:
  GO.link/src/unicode/letter.go
TYPE unicode.RangeTable:
  GO.link/src/unicode/letter.go
TYPE unicode.SpecialCase:
  GO.link/src/unicode/letter.go
TYPE unsafe.ArbitraryType:
  GO.link/src/unsafe/unsafe.go
TYPE unsafe.Pointer:
  GO.link/src/unsafe/unsafe.go
JOKER FUNC archive/tar.FileInfoHeader:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated Header from fi.\nIf fi describes a symlink, FileInfoHeader records link as the link target.\nIf fi describes a directory, a slash is appended to the name.\n\nSince os.FileInfo's Name method only returns the base name of\nthe file it describes, it may be necessary to modify Header.Name\nto provide the full path name of the file.\n\nGo input arguments: (fi os.FileInfo, link string)\n\nGo return type: (*Header, error)\n\nJoker input arguments: [^os.FileInfo fi, ^String link]\n\nJoker return type: [{:Typeflag ^Int, :Name ^String, :Linkname ^String, :Size ^Int, :Mode ^Int, :Uid ^Int, :Gid ^Int, :Uname ^String, :Gname ^String, :ModTime ^{}, :AccessTime ^{}, :ChangeTime ^{}, :Devmajor ^Int, :Devminor ^Int, :Xattrs ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/archive/tar/common.go:179:9), :PAXRecords ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/archive/tar/common.go:191:13), :Format ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(ABEND904(custom-runtime routine not implemented: os.FileInfo(_fi)), _link)"}
;;   [^os.FileInfo _fi, ^String _link])

JOKER FUNC archive/tar.NewReader:
;; (defn NewReader
;;   "NewReader creates a new Reader reading from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC archive/tar.NewWriter:
;; (defn NewWriter
;;   "NewWriter creates a new Writer writing to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC archive/zip.FileInfoHeader:
;; (defn FileInfoHeader
;;   "FileInfoHeader creates a partially-populated FileHeader from an\nos.FileInfo.\nBecause os.FileInfo's Name method returns only the base name of\nthe file it describes, it may be necessary to modify the Name field\nof the returned header to provide the full path name of the file.\nIf compression is desired, callers should set the FileHeader.Method\nfield; it is unset by default.\n\nGo input arguments: (fi os.FileInfo)\n\nGo return type: (*FileHeader, error)\n\nJoker input arguments: [^os.FileInfo fi]\n\nJoker return type: [{:Name ^String, :Comment ^String, :NonUTF8 ^Bool, :CreatorVersion ^Int, :ReaderVersion ^Int, :Flags ^Int, :Method ^Int, :Modified ^{}, :ModifiedTime ^Int, :ModifiedDate ^Int, :CRC32 ^Int, :CompressedSize ^Int, :UncompressedSize ^Int, :CompressedSize64 ^ABEND043(unsupported built-in type uint64), :UncompressedSize64 ^ABEND043(unsupported built-in type uint64), :Extra ^(vector-of Int), :ExternalAttrs ^Int} Error]"
;;   {:added "1.0"
;;    :go "fileInfoHeader(ABEND904(custom-runtime routine not implemented: os.FileInfo(_fi)))"}
;;   [^os.FileInfo _fi])

JOKER FUNC archive/zip.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r, which is assumed to\nhave the given size in bytes.\n\nGo input arguments: (r io.ReaderAt, size int64)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^io.ReaderAt r, ^Int64 size]\n\nJoker return type: [{:File ^(vector-of {}), :Comment ^String} Error]"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)), _size)"}
;;   [^io.ReaderAt _r, ^Int64 _size])

JOKER FUNC archive/zip.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing a zip file to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC archive/zip.OpenReader:
(defn OpenReader
  "OpenReader will open the Zip file specified by name and return a ReadCloser.\n\nGo input arguments: (name string)\n\nGo return type: (*ReadCloser, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "openReader(_name)"}
  [^String _name])

JOKER FUNC archive/zip.RegisterCompressor:
;; (defn RegisterCompressor
;;   "RegisterCompressor registers custom compressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, comp archive/zip.Compressor)\n\nJoker input arguments: [^UInt16 method, ^archive/zip.Compressor comp]"
;;   {:added "1.0"
;;    :go "registerCompressor(_method, ABEND904(custom-runtime routine not implemented: archive/zip.Compressor(_comp)))"}
;;   [^UInt16 _method, ^archive/zip.Compressor _comp])

JOKER FUNC archive/zip.RegisterDecompressor:
;; (defn RegisterDecompressor
;;   "RegisterDecompressor allows custom decompressors for a specified method ID.\nThe common methods Store and Deflate are built in.\n\nGo input arguments: (method uint16, dcomp archive/zip.Decompressor)\n\nJoker input arguments: [^UInt16 method, ^archive/zip.Decompressor dcomp]"
;;   {:added "1.0"
;;    :go "registerDecompressor(_method, ABEND904(custom-runtime routine not implemented: archive/zip.Decompressor(_dcomp)))"}
;;   [^UInt16 _method, ^archive/zip.Decompressor _dcomp])

JOKER FUNC bufio.NewReadWriter:
;; (defn NewReadWriter
;;   "NewReadWriter allocates a new ReadWriter that dispatches to r and w.\n\nGo input arguments: (r *bufio.Reader, w *bufio.Writer)\n\nGo return type: *ReadWriter\n\nJoker input arguments: [^(atom-of bufio.Reader) r, ^(atom-of bufio.Writer) w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReadWriter(ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r))), ConvertToIndirectOfbufio.Writer(ABEND904(custom-runtime routine not implemented: bufio.Writer(_w)))))"}
;;   [^Object _r, ^Object _w])

JOKER FUNC bufio.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader whose buffer has the default size.\n\nGo input arguments: (rd io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader rd]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_rd))))"}
;;   [^io.Reader _rd])

JOKER FUNC bufio.NewReaderSize:
;; (defn NewReaderSize
;;   "NewReaderSize returns a new Reader whose buffer has at least the specified\nsize. If the argument io.Reader is already a Reader with large enough\nsize, it returns the underlying Reader.\n\nGo input arguments: (rd io.Reader, size int)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader rd, ^Int size]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReaderSize(ABEND904(custom-runtime routine not implemented: io.Reader(_rd)), _size))"}
;;   [^io.Reader _rd, ^Int _size])

JOKER FUNC bufio.NewScanner:
;; (defn NewScanner
;;   "NewScanner returns a new Scanner to read from r.\nThe split function defaults to ScanLines.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Scanner\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newScanner(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC bufio.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer whose buffer has the default size.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC bufio.NewWriterSize:
;; (defn NewWriterSize
;;   "NewWriterSize returns a new Writer whose buffer has at least the specified\nsize. If the argument io.Writer is already a Writer with large enough\nsize, it returns the underlying Writer.\n\nGo input arguments: (w io.Writer, size int)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w, ^Int size]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriterSize(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _size))"}
;;   [^io.Writer _w, ^Int _size])

JOKER FUNC bufio.ScanBytes:
(defn ScanBytes
  "ScanBytes is a split function for a Scanner that returns each byte as a token.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []int, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
  {:added "1.0"
   :go "scanBytes(ConvertToArrayOfByte(_data), _atEOF)"}
  [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanLines:
(defn ScanLines
  "ScanLines is a split function for a Scanner that returns each line of\ntext, stripped of any trailing end-of-line marker. The returned line may\nbe empty. The end-of-line marker is one optional carriage return followed\nby one mandatory newline. In regular expression notation, it is `\\r?\\n`.\nThe last non-empty line of input will be returned even if it has no\nnewline.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []int, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
  {:added "1.0"
   :go "scanLines(ConvertToArrayOfByte(_data), _atEOF)"}
  [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanRunes:
(defn ScanRunes
  "ScanRunes is a split function for a Scanner that returns each\nUTF-8-encoded rune as a token. The sequence of runes returned is\nequivalent to that from a range loop over the input as a string, which\nmeans that erroneous UTF-8 encodings translate to U+FFFD = \"\\xef\\xbf\\xbd\".\nBecause of the Scan interface, this makes it impossible for the client to\ndistinguish correctly encoded replacement runes from encoding errors.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []int, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
  {:added "1.0"
   :go "scanRunes(ConvertToArrayOfByte(_data), _atEOF)"}
  [^Object _data, ^Bool _atEOF])

JOKER FUNC bufio.ScanWords:
(defn ScanWords
  "ScanWords is a split function for a Scanner that returns each\nspace-separated word of text, with surrounding spaces deleted. It will\nnever return an empty string. The definition of space is set by\nunicode.IsSpace.\n\nGo input arguments: (data []byte, atEOF bool)\n\nGo return type: (advance int, token []int, err error)\n\nJoker input arguments: [^(vector-of Byte) data, ^Bool atEOF]\n\nJoker return type: [Int (vector-of Int) Error]"
  {:added "1.0"
   :go "scanWords(ConvertToArrayOfByte(_data), _atEOF)"}
  [^Object _data, ^Bool _atEOF])

JOKER FUNC bytes.Compare:
(defn ^"Int" Compare
  "Compare returns an integer comparing two byte slices lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.Compare(ConvertToArrayOfByte(_a), ConvertToArrayOfByte(_b))"}
  [^Object _a, ^Object _b])

JOKER FUNC bytes.Contains:
(defn ^"Bool" Contains
  "Contains reports whether subslice is within b.\n\nGo input arguments: (b []byte, subslice []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^(vector-of Byte) subslice]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.Contains(ConvertToArrayOfByte(_b), ConvertToArrayOfByte(_subslice))"}
  [^Object _b, ^Object _subslice])

JOKER FUNC bytes.ContainsAny:
(defn ^"Bool" ContainsAny
  "ContainsAny reports whether any of the UTF-8-encoded code points in chars are within b.\n\nGo input arguments: (b []byte, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^String chars]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.ContainsAny(ConvertToArrayOfByte(_b), _chars)"}
  [^Object _b, ^String _chars])

JOKER FUNC bytes.ContainsRune:
;; (defn ^"Bool" ContainsRune
;;   "ContainsRune reports whether the rune is contained in the UTF-8-encoded byte slice b.\n\nGo input arguments: (b []byte, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) b, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "bytes.ContainsRune(ConvertToArrayOfByte(_b), _r)"}
;;   [^Object _b, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC bytes.Count:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of sep in s.\nIf sep is an empty slice, Count returns 1 + the number of UTF-8-encoded code points in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.Count(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep))"}
  [^Object _s, ^Object _sep])

JOKER FUNC bytes.Equal:
(defn ^"Bool" Equal
  "Equal returns a boolean reporting whether a and b\nare the same length and contain the same bytes.\nA nil argument is equivalent to an empty slice.\n\nGo input arguments: (a []byte, b []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) a, ^(vector-of Byte) b]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.Equal(ConvertToArrayOfByte(_a), ConvertToArrayOfByte(_b))"}
  [^Object _a, ^Object _b])

JOKER FUNC bytes.EqualFold:
(defn ^"Bool" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s []byte, t []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) t]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.EqualFold(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_t))"}
  [^Object _s, ^Object _t])

JOKER FUNC bytes.Fields:
(defn Fields
  "Fields interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of subslices of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s []byte)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of (vector-of Int))"
  {:added "1.0"
   :go "fields(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.FieldsFunc:
;; (defn FieldsFunc
;;   "FieldsFunc interprets s as a sequence of UTF-8-encoded code points.\nIt splits the slice s at each run of code points c satisfying f(c) and\nreturns a slice of subslices of s. If all code points in s satisfy f(c), or\nlen(s) == 0, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of (vector-of Int))"
;;   {:added "1.0"
;;    :go "fieldsFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.HasPrefix:
(defn ^"Bool" HasPrefix
  "HasPrefix tests whether the byte slice s begins with prefix.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.HasPrefix(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_prefix))"}
  [^Object _s, ^Object _prefix])

JOKER FUNC bytes.HasSuffix:
(defn ^"Bool" HasSuffix
  "HasSuffix tests whether the byte slice s ends with suffix.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "bytes.HasSuffix(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_suffix))"}
  [^Object _s, ^Object _suffix])

JOKER FUNC bytes.Index:
(defn ^"Int" Index
  "Index returns the index of the first instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.Index(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep))"}
  [^Object _s, ^Object _sep])

JOKER FUNC bytes.IndexAny:
(defn ^"Int" IndexAny
  "IndexAny interprets s as a sequence of UTF-8-encoded Unicode code points.\nIt returns the byte index of the first occurrence in s of any of the Unicode\ncode points in chars. It returns -1 if chars is empty or if there is no code\npoint in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.IndexAny(ConvertToArrayOfByte(_s), _chars)"}
  [^Object _s, ^String _chars])

JOKER FUNC bytes.IndexByte:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in b, or -1 if c is not present in b.\n\nGo input arguments: (b []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) b, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.IndexByte(ConvertToArrayOfByte(_b), _c)"}
  [^Object _b, ^Byte _c])

JOKER FUNC bytes.IndexFunc:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.IndexRune:
;; (defn ^"Int" IndexRune
;;   "IndexRune interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index of the first occurrence in s of the given rune.\nIt returns -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.IndexRune(ConvertToArrayOfByte(_s), _r)"}
;;   [^Object _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC bytes.Join:
;; (defn Join
;;   "Join concatenates the elements of s to create a new byte slice. The separator\nsep is placed between elements in the resulting slice.\n\nGo input arguments: (s [][]byte, sep []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of (vector-of Byte)) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "join(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfObject(ConvertToArrayOfByte(_s))), ConvertToArrayOfByte(_sep))"}
;;   [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndex:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of sep in s, or -1 if sep is not present in s.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.LastIndex(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep))"}
  [^Object _s, ^Object _sep])

JOKER FUNC bytes.LastIndexAny:
(defn ^"Int" LastIndexAny
  "LastIndexAny interprets s as a sequence of UTF-8-encoded Unicode code\npoints. It returns the byte index of the last occurrence in s of any of\nthe Unicode code points in chars. It returns -1 if chars is empty or if\nthere is no code point in common.\n\nGo input arguments: (s []byte, chars string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.LastIndexAny(ConvertToArrayOfByte(_s), _chars)"}
  [^Object _s, ^String _chars])

JOKER FUNC bytes.LastIndexByte:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s []byte, c byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bytes.LastIndexByte(ConvertToArrayOfByte(_s), _c)"}
  [^Object _s, ^Byte _c])

JOKER FUNC bytes.LastIndexFunc:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc interprets s as a sequence of UTF-8-encoded code points.\nIt returns the byte index in s of the last Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s []byte, f func)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bytes.LastIndexFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.Map:
;; (defn Map
;;   "Map returns a copy of the byte slice s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the byte slice with no replacement. The characters in s and the\noutput are interpreted as UTF-8-encoded code points.\n\nGo input arguments: (mapping func, s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^fn mapping, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "map(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOfByte(_s))"}
;;   [^fn _mapping, ^Object _s])

JOKER FUNC bytes.NewBuffer:
;; (defn NewBuffer
;;   "NewBuffer creates and initializes a new Buffer using buf as its\ninitial contents. The new Buffer takes ownership of buf, and the\ncaller should not use buf after this call. NewBuffer is intended to\nprepare a Buffer to read existing data. It can also be used to size\nthe internal buffer for writing. To do that, buf should have the\ndesired capacity but a length of zero.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (buf []byte)\n\nGo return type: *Buffer\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newBuffer(ConvertToArrayOfByte(_buf)))"}
;;   [^Object _buf])

JOKER FUNC bytes.NewBufferString:
;; (defn NewBufferString
;;   "NewBufferString creates and initializes a new Buffer using string s as its\ninitial contents. It is intended to prepare a buffer to read an existing\nstring.\n\nIn most cases, new(Buffer) (or just declaring a Buffer variable) is\nsufficient to initialize a Buffer.\n\nGo input arguments: (s string)\n\nGo return type: *Buffer\n\nJoker input arguments: [^String s]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newBufferString(_s))"}
;;   [^String _s])

JOKER FUNC bytes.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from b.\n\nGo input arguments: (b []byte)\n\nGo return type: *Reader\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ConvertToArrayOfByte(_b)))"}
;;   [^Object _b])

JOKER FUNC bytes.Repeat:
(defn Repeat
  "Repeat returns a new byte slice consisting of count copies of b.\n\nIt panics if count is negative or if\nthe result of (len(b) * count) overflows.\n\nGo input arguments: (b []byte, count int)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) b, ^Int count]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "repeat(ConvertToArrayOfByte(_b), _count)"}
  [^Object _b, ^Int _count])

JOKER FUNC bytes.Replace:
(defn Replace
  "Replace returns a copy of the slice s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the slice\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune slice.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s []byte, old []byte, new []byte, n int)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) old, ^(vector-of Byte) new, ^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "replace(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_old), ConvertToArrayOfByte(_new), _n)"}
  [^Object _s, ^Object _old, ^Object _new, ^Int _n])

JOKER FUNC bytes.Runes:
;; (defn Runes
;;   "Runes interprets s as a sequence of UTF-8-encoded code points.\nIt returns a slice of runes (Unicode code points) equivalent to s.\n\nGo input arguments: (s []byte)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of ABEND043(unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "runes(ConvertToArrayOfByte(_s))"}
;;   [^Object _s])

JOKER FUNC bytes.Split:
(defn Split
  "Split slices s into all subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, Split splits after each UTF-8 sequence.\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of Int))"
  {:added "1.0"
   :go "split(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep))"}
  [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfter:
(defn SplitAfter
  "SplitAfter slices s into all subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfter splits after each UTF-8 sequence.\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s []byte, sep []byte)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep]\n\nJoker return type: (vector-of (vector-of Int))"
  {:added "1.0"
   :go "splitAfter(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep))"}
  [^Object _s, ^Object _sep])

JOKER FUNC bytes.SplitAfterN:
(defn SplitAfterN
  "SplitAfterN slices s into subslices after each instance of sep and\nreturns a slice of those subslices.\nIf sep is empty, SplitAfterN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
  {:added "1.0"
   :go "splitAfterN(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep), _n)"}
  [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.SplitN:
(defn SplitN
  "SplitN slices s into subslices separated by sep and returns a slice of\nthe subslices between those separators.\nIf sep is empty, SplitN splits after each UTF-8 sequence.\nThe count determines the number of subslices to return:\n  n > 0: at most n subslices; the last subslice will be the unsplit remainder.\n  n == 0: the result is nil (zero subslices)\n  n < 0: all subslices\n\nGo input arguments: (s []byte, sep []byte, n int)\n\nGo return type: [][]int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) sep, ^Int n]\n\nJoker return type: (vector-of (vector-of Int))"
  {:added "1.0"
   :go "splitN(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_sep), _n)"}
  [^Object _s, ^Object _sep, ^Int _n])

JOKER FUNC bytes.Title:
(defn Title
  "Title treats s as UTF-8-encoded bytes and returns a copy with all Unicode letters that begin\nwords mapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "title(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.ToLower:
(defn ToLower
  "ToLower treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their lower case.\n\nGo input arguments: (s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "toLower(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.ToLowerSpecial:
;; (defn ToLowerSpecial
;;   "ToLowerSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^unicode.SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toLowerSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), ConvertToArrayOfByte(_s))"}
;;   [^unicode.SpecialCase _c, ^Object _s])

JOKER FUNC bytes.ToTitle:
(defn ToTitle
  "ToTitle treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their title case.\n\nGo input arguments: (s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "toTitle(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.ToTitleSpecial:
;; (defn ToTitleSpecial
;;   "ToTitleSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^unicode.SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toTitleSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), ConvertToArrayOfByte(_s))"}
;;   [^unicode.SpecialCase _c, ^Object _s])

JOKER FUNC bytes.ToUpper:
(defn ToUpper
  "ToUpper treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters within it mapped to their upper case.\n\nGo input arguments: (s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "toUpper(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.ToUpperSpecial:
;; (defn ToUpperSpecial
;;   "ToUpperSpecial treats s as UTF-8-encoded bytes and returns a copy with all the Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^unicode.SpecialCase c, ^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "toUpperSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), ConvertToArrayOfByte(_s))"}
;;   [^unicode.SpecialCase _c, ^Object _s])

JOKER FUNC bytes.Trim:
(defn Trim
  "Trim returns a subslice of s by slicing off all leading and\ntrailing UTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trim(ConvertToArrayOfByte(_s), _cutset)"}
  [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimFunc:
;; (defn TrimFunc
;;   "TrimFunc returns a subslice of s by slicing off all leading and trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimLeft:
(defn TrimLeft
  "TrimLeft returns a subslice of s by slicing off all leading\nUTF-8-encoded code points contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimLeft(ConvertToArrayOfByte(_s), _cutset)"}
  [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimLeftFunc:
;; (defn TrimLeftFunc
;;   "TrimLeftFunc treats s as UTF-8-encoded bytes and returns a subslice of s by slicing off\nall leading UTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimLeftFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimPrefix:
(defn TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s []byte, prefix []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) prefix]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimPrefix(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_prefix))"}
  [^Object _s, ^Object _prefix])

JOKER FUNC bytes.TrimRight:
(defn TrimRight
  "TrimRight returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points that are contained in cutset.\n\nGo input arguments: (s []byte, cutset string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^String cutset]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimRight(ConvertToArrayOfByte(_s), _cutset)"}
  [^Object _s, ^String _cutset])

JOKER FUNC bytes.TrimRightFunc:
;; (defn TrimRightFunc
;;   "TrimRightFunc returns a subslice of s by slicing off all trailing\nUTF-8-encoded code points c that satisfy f(c).\n\nGo input arguments: (s []byte, f func)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^fn f]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "trimRightFunc(ConvertToArrayOfByte(_s), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Object _s, ^fn _f])

JOKER FUNC bytes.TrimSpace:
(defn TrimSpace
  "TrimSpace returns a subslice of s by slicing off all leading and\ntrailing white space, as defined by Unicode.\n\nGo input arguments: (s []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimSpace(ConvertToArrayOfByte(_s))"}
  [^Object _s])

JOKER FUNC bytes.TrimSuffix:
(defn TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s []byte, suffix []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) s, ^(vector-of Byte) suffix]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimSuffix(ConvertToArrayOfByte(_s), ConvertToArrayOfByte(_suffix))"}
  [^Object _s, ^Object _suffix])

JOKER FUNC compress/bzip2.NewReader:
;; (defn NewReader
;;   "NewReader returns an io.Reader which decompresses bzip2 data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC compress/flate.NewReader:
;; (defn NewReader
;;   "NewReader returns a new ReadCloser that can be used\nto read the uncompressed version of r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser\nwhen finished reading.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17)"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC compress/flate.NewReaderDict:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but initializes the reader\nwith a preset dictionary. The returned Reader behaves as if\nthe uncompressed data stream started with the given dictionary,\nwhich has already been read. NewReaderDict is typically used\nto read data compressed by NewWriterDict.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r, ^(vector-of Byte) dict]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17)"
;;   {:added "1.0"
;;    :go "newReaderDict(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToArrayOfByte(_dict))"}
;;   [^io.Reader _r, ^Object _dict])

JOKER FUNC compress/flate.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer compressing data at the given level.\nFollowing zlib, levels range from 1 (BestSpeed) to 9 (BestCompression);\nhigher levels typically run slower but compress more. Level 0\n(NoCompression) does not attempt any compression; it only adds the\nnecessary DEFLATE framing.\nLevel -1 (DefaultCompression) uses the default compression level.\nLevel -2 (HuffmanOnly) will use Huffman compression only, giving\na very fast compression for all types of input, but sacrificing considerable\ncompression efficiency.\n\nIf level is in the range [-2, 9] then the error returned will be nil.\nOtherwise the error returned will be non-nil.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^io.Writer w, ^Int level]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _level)"}
;;   [^io.Writer _w, ^Int _level])

JOKER FUNC compress/flate.NewWriterDict:
;; (defn NewWriterDict
;;   "NewWriterDict is like NewWriter but initializes the new\nWriter with a preset dictionary. The returned Writer behaves\nas if the dictionary had been written to it without producing\nany compressed output. The compressed data written to w\ncan only be decompressed by a Reader initialized with the\nsame dictionary.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^io.Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterDict(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _level, ConvertToArrayOfByte(_dict))"}
;;   [^io.Writer _w, ^Int _level, ^Object _dict])

JOKER FUNC compress/gzip.NewReader:
;; (defn NewReader
;;   "NewReader creates a new Reader reading the given reader.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\n\nIt is the caller's responsibility to call Close on the Reader when done.\n\nThe Reader.Header fields will be valid in the Reader returned.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*Reader, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC compress/gzip.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer.\nWrites to the returned writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nCallers that wish to set the fields in Writer.Header must do so before\nthe first call to Write, Flush, or Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC compress/gzip.NewWriterLevel:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^io.Writer w, ^Int level]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _level)"}
;;   [^io.Writer _w, ^Int _level])

JOKER FUNC compress/lzw.NewReader:
;; (defn NewReader
;;   "NewReader creates a new io.ReadCloser.\nReads from the returned io.ReadCloser read and decompress data from r.\nIf r does not also implement io.ByteReader,\nthe decompressor may read more data than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when\nfinished reading.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. It must equal the litWidth\nused during compression.\n\nGo input arguments: (r io.Reader, order compress/lzw.Order, litWidth int)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r, ^compress/lzw.Order order, ^Int litWidth]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17)"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ABEND904(custom-runtime routine not implemented: compress/lzw.Order(_order)), _litWidth)"}
;;   [^io.Reader _r, ^compress/lzw.Order _order, ^Int _litWidth])

JOKER FUNC compress/lzw.NewWriter:
;; (defn NewWriter
;;   "NewWriter creates a new io.WriteCloser.\nWrites to the returned io.WriteCloser are compressed and written to w.\nIt is the caller's responsibility to call Close on the WriteCloser when\nfinished writing.\nThe number of bits to use for literal codes, litWidth, must be in the\nrange [2,8] and is typically 8. Input bytes must be less than 1<<litWidth.\n\nGo input arguments: (w io.Writer, order compress/lzw.Order, litWidth int)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w, ^compress/lzw.Order order, ^Int litWidth]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ABEND904(custom-runtime routine not implemented: compress/lzw.Order(_order)), _litWidth)"}
;;   [^io.Writer _w, ^compress/lzw.Order _order, ^Int _litWidth])

JOKER FUNC compress/zlib.NewReader:
;; (defn NewReader
;;   "NewReader creates a new ReadCloser.\nReads from the returned ReadCloser read and decompress data from r.\nIf r does not implement io.ByteReader, the decompressor may read more\ndata than necessary from r.\nIt is the caller's responsibility to call Close on the ReadCloser when done.\n\nThe ReadCloser returned by NewReader also implements Resetter.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17) Error]"
;;   {:added "1.0"
;;    :go "newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC compress/zlib.NewReaderDict:
;; (defn NewReaderDict
;;   "NewReaderDict is like NewReader but uses a preset dictionary.\nNewReaderDict ignores the dictionary if the compressed data does not refer to it.\nIf the compressed data refers to a different dictionary, NewReaderDict returns ErrDictionary.\n\nThe ReadCloser returned by NewReaderDict also implements Resetter.\n\nGo input arguments: (r io.Reader, dict []byte)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.Reader r, ^(vector-of Byte) dict]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17) Error]"
;;   {:added "1.0"
;;    :go "newReaderDict(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToArrayOfByte(_dict))"}
;;   [^io.Reader _r, ^Object _dict])

JOKER FUNC compress/zlib.NewWriter:
;; (defn NewWriter
;;   "NewWriter creates a new Writer.\nWrites to the returned Writer are compressed and written to w.\n\nIt is the caller's responsibility to call Close on the Writer when done.\nWrites may be buffered and not flushed until Close.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC compress/zlib.NewWriterLevel:
;; (defn NewWriterLevel
;;   "NewWriterLevel is like NewWriter but specifies the compression level instead\nof assuming DefaultCompression.\n\nThe compression level can be DefaultCompression, NoCompression, HuffmanOnly\nor any integer value between BestSpeed and BestCompression inclusive.\nThe error returned will be nil if the level is valid.\n\nGo input arguments: (w io.Writer, level int)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^io.Writer w, ^Int level]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevel(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _level)"}
;;   [^io.Writer _w, ^Int _level])

JOKER FUNC compress/zlib.NewWriterLevelDict:
;; (defn NewWriterLevelDict
;;   "NewWriterLevelDict is like NewWriterLevel but specifies a dictionary to\ncompress with.\n\nThe dictionary may be nil. If not, its contents should not be modified until\nthe Writer is closed.\n\nGo input arguments: (w io.Writer, level int, dict []byte)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^io.Writer w, ^Int level, ^(vector-of Byte) dict]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newWriterLevelDict(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _level, ConvertToArrayOfByte(_dict))"}
;;   [^io.Writer _w, ^Int _level, ^Object _dict])

JOKER FUNC container/heap.Fix:
;; (defn Fix
;;   "Fix re-establishes the heap ordering after the element at index i has changed its value.\nChanging the value of the element at index i and then calling Fix is equivalent to,\nbut less expensive than, calling Remove(h, i) followed by a Push of the new value.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h container/heap.Interface, i int)\n\nJoker input arguments: [^container/heap.Interface h, ^Int i]"
;;   {:added "1.0"
;;    :go "fix(ABEND904(custom-runtime routine not implemented: container/heap.Interface(_h)), _i)"}
;;   [^container/heap.Interface _h, ^Int _i])

JOKER FUNC container/heap.Init:
;; (defn Init
;;   "Init establishes the heap invariants required by the other routines in this package.\nInit is idempotent with respect to the heap invariants\nand may be called whenever the heap invariants may have been invalidated.\nIts complexity is O(n) where n = h.Len().\n\nGo input arguments: (h container/heap.Interface)\n\nJoker input arguments: [^container/heap.Interface h]"
;;   {:added "1.0"
;;    :go "init(ABEND904(custom-runtime routine not implemented: container/heap.Interface(_h)))"}
;;   [^container/heap.Interface _h])

JOKER FUNC container/heap.Pop:
;; (defn Pop
;;   "Pop removes the minimum element (according to Less) from the heap\nand returns it. The complexity is O(log(n)) where n = h.Len().\nIt is equivalent to Remove(h, 0).\n\nGo input arguments: (h container/heap.Interface)\n\nGo return type: ...\n\nJoker input arguments: [^container/heap.Interface h]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:62:23)"
;;   {:added "1.0"
;;    :go "pop(ABEND904(custom-runtime routine not implemented: container/heap.Interface(_h)))"}
;;   [^container/heap.Interface _h])

JOKER FUNC container/heap.Push:
;; (defn Push
;;   "Push pushes the element x onto the heap. The complexity is\nO(log(n)) where n = h.Len().\n\nGo input arguments: (h container/heap.Interface, x interface {})\n\nJoker input arguments: [^container/heap.Interface h, ^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "push(ABEND904(custom-runtime routine not implemented: container/heap.Interface(_h)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^container/heap.Interface _h, ^<protocol-or-something> _x])

JOKER FUNC container/heap.Remove:
;; (defn Remove
;;   "Remove removes the element at index i from the heap.\nThe complexity is O(log(n)) where n = h.Len().\n\nGo input arguments: (h container/heap.Interface, i int)\n\nGo return type: ...\n\nJoker input arguments: [^container/heap.Interface h, ^Int i]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/heap/heap.go:72:33)"
;;   {:added "1.0"
;;    :go "remove(ABEND904(custom-runtime routine not implemented: container/heap.Interface(_h)), _i)"}
;;   [^container/heap.Interface _h, ^Int _i])

JOKER FUNC container/list.New:
;; (defn New
;;   "New returns an initialized list.\n\nGo return type: *List\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new())"}
;;   [])

JOKER FUNC container/ring.New:
;; (defn New
;;   "New creates a ring of n elements.\n\nGo input arguments: (n int)\n\nGo return type: *Ring\n\nJoker input arguments: [^Int n]\n\nJoker return type: {:Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/container/ring/ring.go:16:13)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(_n))"}
;;   [^Int _n])

JOKER FUNC context.Background:
;; (defn Background
;;   "Background returns a non-nil, empty Context. It is never canceled, has no\nvalues, and has no deadline. It is typically used by the main function,\ninitialization, and tests, and as the top-level Context for incoming\nrequests.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "background()"}
;;   [])

JOKER FUNC context.TODO:
;; (defn TODO
;;   "TODO returns a non-nil, empty Context. Code should use context.TODO when\nit's unclear which Context to use or it is not yet available (because the\nsurrounding function has not yet been extended to accept a Context\nparameter). TODO is recognized by static analysis tools that determine\nwhether Contexts are propagated correctly in a program.\n\nGo return type: Context\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "tODO()"}
;;   [])

JOKER FUNC context.WithCancel:
;; (defn WithCancel
;;   "WithCancel returns a copy of parent with a new Done channel. The returned\ncontext's Done channel is closed when the returned cancel function is called\nor when the parent context's Done channel is closed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent context.Context)\n\nGo return type: (ctx Context, cancel CancelFunc)\n\nJoker input arguments: [^context.Context parent]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withCancel(ABEND904(custom-runtime routine not implemented: context.Context(_parent)))"}
;;   [^context.Context _parent])

JOKER FUNC context.WithDeadline:
;; (defn WithDeadline
;;   "WithDeadline returns a copy of the parent context with the deadline adjusted\nto be no later than d. If the parent's deadline is already earlier than d,\nWithDeadline(parent, d) is semantically equivalent to parent. The returned\ncontext's Done channel is closed when the deadline expires, when the returned\ncancel function is called, or when the parent context's Done channel is\nclosed, whichever happens first.\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete.\n\nGo input arguments: (parent context.Context, d time.Time)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^context.Context parent, ^time.Time d]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withDeadline(ABEND904(custom-runtime routine not implemented: context.Context(_parent)), ABEND904(custom-runtime routine not implemented: time.Time(_d)))"}
;;   [^context.Context _parent, ^time.Time _d])

JOKER FUNC context.WithTimeout:
;; (defn WithTimeout
;;   "WithTimeout returns WithDeadline(parent, time.Now().Add(timeout)).\n\nCanceling this context releases resources associated with it, so code should\ncall cancel as soon as the operations running in this Context complete:\n\n\tfunc slowOperationWithTimeout(ctx context.Context) (Result, error) {\n\t\tctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)\n\t\tdefer cancel()  // releases resources if slowOperation completes before timeout elapses\n\t\treturn slowOperation(ctx)\n\t}\n\nGo input arguments: (parent context.Context, timeout time.Duration)\n\nGo return type: (Context, CancelFunc)\n\nJoker input arguments: [^context.Context parent, ^time.Duration timeout]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/context/context.go:222:17)]"
;;   {:added "1.0"
;;    :go "withTimeout(ABEND904(custom-runtime routine not implemented: context.Context(_parent)), ABEND904(custom-runtime routine not implemented: time.Duration(_timeout)))"}
;;   [^context.Context _parent, ^time.Duration _timeout])

JOKER FUNC context.WithValue:
;; (defn WithValue
;;   "WithValue returns a copy of parent in which the value associated with key is\nval.\n\nUse context Values only for request-scoped data that transits processes and\nAPIs, not for passing optional parameters to functions.\n\nThe provided key must be comparable and should not be of type\nstring or any other built-in type to avoid collisions between\npackages using context. Users of WithValue should define their own\ntypes for keys. To avoid allocating when assigning to an\ninterface{}, context keys often have concrete type\nstruct{}. Alternatively, exported context key variables' static\ntype should be a pointer or interface.\n\nGo input arguments: (parent context.Context, key interface {}, val interface {})\n\nGo return type: Context\n\nJoker input arguments: [^context.Context parent, ^<protocol-or-something> key, ^<protocol-or-something> val]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "withValue(ABEND904(custom-runtime routine not implemented: context.Context(_parent)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^context.Context _parent, ^<protocol-or-something> _key, ^<protocol-or-something> _val])

JOKER FUNC crypto.RegisterHash:
;; (defn RegisterHash
;;   "RegisterHash registers a function that returns a new instance of the given\nhash function. This is intended to be called from the init function in\npackages that implement hash functions.\n\nGo input arguments: (h crypto.Hash, f func)\n\nJoker input arguments: [^crypto.Hash h, ^fn f]"
;;   {:added "1.0"
;;    :go "registerHash(ABEND904(custom-runtime routine not implemented: crypto.Hash(_h)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^crypto.Hash _h, ^fn _f])

JOKER FUNC crypto/aes.NewCipher:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\nThe key argument should be the AES key,\neither 16, 24, or 32 bytes to select\nAES-128, AES-192, or AES-256.\n\nGo input arguments: (key []byte)\n\nGo return type: (..., error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:15:12) Error]"
;;   {:added "1.0"
;;    :go "newCipher(ConvertToArrayOfByte(_key))"}
;;   [^Object _key])

JOKER FUNC crypto/cipher.NewCBCDecrypter:
;; (defn NewCBCDecrypter
;;   "NewCBCDecrypter returns a BlockMode which decrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size and must match the iv used to encrypt the data.\n\nGo input arguments: (b crypto/cipher.Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^crypto/cipher.Block b, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCDecrypter(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_b)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCBCEncrypter:
;; (defn NewCBCEncrypter
;;   "NewCBCEncrypter returns a BlockMode which encrypts in cipher block chaining\nmode, using the given Block. The length of iv must be the same as the\nBlock's block size.\n\nGo input arguments: (b crypto/cipher.Block, iv []byte)\n\nGo return type: BlockMode\n\nJoker input arguments: [^crypto/cipher.Block b, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:45:16)"
;;   {:added "1.0"
;;    :go "newCBCEncrypter(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_b)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _b, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBDecrypter:
;; (defn NewCFBDecrypter
;;   "NewCFBDecrypter returns a Stream which decrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block crypto/cipher.Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^crypto/cipher.Block block, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBDecrypter(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_block)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCFBEncrypter:
;; (defn NewCFBEncrypter
;;   "NewCFBEncrypter returns a Stream which encrypts with cipher feedback mode,\nusing the given Block. The iv must be the same length as the Block's block\nsize.\n\nGo input arguments: (block crypto/cipher.Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^crypto/cipher.Block block, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCFBEncrypter(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_block)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewCTR:
;; (defn NewCTR
;;   "NewCTR returns a Stream which encrypts/decrypts using the given Block in\ncounter mode. The length of iv must be the same as the Block's block size.\n\nGo input arguments: (block crypto/cipher.Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^crypto/cipher.Block block, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newCTR(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_block)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _block, ^Object _iv])

JOKER FUNC crypto/cipher.NewGCM:
;; (defn NewGCM
;;   "NewGCM returns the given 128-bit, block cipher wrapped in Galois Counter Mode\nwith the standard nonce length.\n\nIn general, the GHASH operation performed by this implementation of GCM is not constant-time.\nAn exception is when the underlying Block was created by aes.NewCipher\non systems with hardware support for AES. See the crypto/aes package documentation for details.\n\nGo input arguments: (cipher crypto/cipher.Block)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^crypto/cipher.Block cipher]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCM(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_cipher)))"}
;;   [^crypto/cipher.Block _cipher])

JOKER FUNC crypto/cipher.NewGCMWithNonceSize:
;; (defn NewGCMWithNonceSize
;;   "NewGCMWithNonceSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which accepts nonces of the given length.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard nonce lengths. All other users should use\nNewGCM, which is faster and more resistant to misuse.\n\nGo input arguments: (cipher crypto/cipher.Block, size int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^crypto/cipher.Block cipher, ^Int size]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithNonceSize(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_cipher)), _size)"}
;;   [^crypto/cipher.Block _cipher, ^Int _size])

JOKER FUNC crypto/cipher.NewGCMWithTagSize:
;; (defn NewGCMWithTagSize
;;   "NewGCMWithTagSize returns the given 128-bit, block cipher wrapped in Galois\nCounter Mode, which generates tags with the given length.\n\nTag sizes between 12 and 16 bytes are allowed.\n\nOnly use this function if you require compatibility with an existing\ncryptosystem that uses non-standard tag lengths. All other users should use\nNewGCM, which is more resistant to misuse.\n\nGo input arguments: (cipher crypto/cipher.Block, tagSize int)\n\nGo return type: (AEAD, error)\n\nJoker input arguments: [^crypto/cipher.Block cipher, ^Int tagSize]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/gcm.go:16:11) Error]"
;;   {:added "1.0"
;;    :go "newGCMWithTagSize(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_cipher)), _tagSize)"}
;;   [^crypto/cipher.Block _cipher, ^Int _tagSize])

JOKER FUNC crypto/cipher.NewOFB:
;; (defn NewOFB
;;   "NewOFB returns a Stream that encrypts or decrypts using the block cipher b\nin output feedback mode. The initialization vector iv's length must be equal\nto b's block size.\n\nGo input arguments: (b crypto/cipher.Block, iv []byte)\n\nGo return type: Stream\n\nJoker input arguments: [^crypto/cipher.Block b, ^(vector-of Byte) iv]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:29:13)"
;;   {:added "1.0"
;;    :go "newOFB(ABEND904(custom-runtime routine not implemented: crypto/cipher.Block(_b)), ConvertToArrayOfByte(_iv))"}
;;   [^crypto/cipher.Block _b, ^Object _iv])

JOKER FUNC crypto/des.NewCipher:
;; (defn NewCipher
;;   "NewCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (..., error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:15:12) Error]"
;;   {:added "1.0"
;;    :go "newCipher(ConvertToArrayOfByte(_key))"}
;;   [^Object _key])

JOKER FUNC crypto/des.NewTripleDESCipher:
;; (defn NewTripleDESCipher
;;   "NewTripleDESCipher creates and returns a new cipher.Block.\n\nGo input arguments: (key []byte)\n\nGo return type: (..., error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/cipher/cipher.go:15:12) Error]"
;;   {:added "1.0"
;;    :go "newTripleDESCipher(ConvertToArrayOfByte(_key))"}
;;   [^Object _key])

JOKER FUNC crypto/dsa.GenerateKey:
;; (defn ^"Error" GenerateKey
;;   "GenerateKey generates a public&private key pair. The Parameters of the\nPrivateKey must already be valid (see GenerateParameters).\n\nGo input arguments: (priv *crypto/dsa.PrivateKey, rand io.Reader)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of crypto/dsa.PrivateKey) priv, ^io.Reader rand]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateKey(ConvertToIndirectOfcrypto/dsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/dsa.PrivateKey(_priv))), ABEND904(custom-runtime routine not implemented: io.Reader(_rand)))"}
;;   [^Object _priv, ^io.Reader _rand])

JOKER FUNC crypto/dsa.GenerateParameters:
;; (defn ^"Error" GenerateParameters
;;   "GenerateParameters puts a random, valid set of DSA parameters into params.\nThis function can take many seconds, even on fast machines.\n\nGo input arguments: (params *crypto/dsa.Parameters, rand io.Reader, sizes crypto/dsa.ParameterSizes)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of crypto/dsa.Parameters) params, ^io.Reader rand, ^crypto/dsa.ParameterSizes sizes]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "dsa.GenerateParameters(ConvertToIndirectOfcrypto/dsa.Parameters(ABEND904(custom-runtime routine not implemented: crypto/dsa.Parameters(_params))), ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ABEND904(custom-runtime routine not implemented: crypto/dsa.ParameterSizes(_sizes)))"}
;;   [^Object _params, ^io.Reader _rand, ^crypto/dsa.ParameterSizes _sizes])

JOKER FUNC crypto/dsa.Sign:
;; (defn Sign
;;   "Sign signs an arbitrary length hash (which should be the result of hashing a\nlarger message) using the private key, priv. It returns the signature as a\npair of integers. The security of the private key depends on the entropy of\nrand.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nBe aware that calling Sign with an attacker-controlled PrivateKey may\nrequire an arbitrary amount of CPU.\n\nGo input arguments: (rand io.Reader, priv *crypto/dsa.PrivateKey, hash []byte)\n\nGo return type: (r *struct {}, s *struct {}, err error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/dsa.PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [{} {} Error]"
;;   {:added "1.0"
;;    :go "sign(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/dsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/dsa.PrivateKey(_priv))), ConvertToArrayOfByte(_hash))"}
;;   [^io.Reader _rand, ^Object _priv, ^Object _hash])

JOKER FUNC crypto/dsa.Verify:
;; (defn ^"Bool" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. It\nreports whether the signature is valid.\n\nNote that FIPS 186-3 section 4.6 specifies that the hash should be truncated\nto the byte-length of the subgroup. This function does not perform that\ntruncation itself.\n\nGo input arguments: (pub *crypto/dsa.PublicKey, hash []byte, r *math/big.Int, s *math/big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of crypto/dsa.PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of math/big.Int) r, ^(atom-of math/big.Int) s]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "dsa.Verify(ConvertToIndirectOfcrypto/dsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/dsa.PublicKey(_pub))), ConvertToArrayOfByte(_hash), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_r))), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_s))))"}
;;   [^Object _pub, ^Object _hash, ^Object _r, ^Object _s])

JOKER FUNC crypto/ecdsa.GenerateKey:
;; (defn GenerateKey
;;   "GenerateKey generates a public and private key pair.\n\nGo input arguments: (c crypto/elliptic.Curve, rand io.Reader)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^crypto/elliptic.Curve c, ^io.Reader rand]\n\nJoker return type: [{:D ^{}} Error]"
;;   {:added "1.0"
;;    :go "generateKey(ABEND904(custom-runtime routine not implemented: crypto/elliptic.Curve(_c)), ABEND904(custom-runtime routine not implemented: io.Reader(_rand)))"}
;;   [^crypto/elliptic.Curve _c, ^io.Reader _rand])

JOKER FUNC crypto/ecdsa.Sign:
;; (defn Sign
;;   "Sign signs a hash (which should be the result of hashing a larger message)\nusing the private key, priv. If the hash is longer than the bit-length of the\nprivate key's curve order, the hash will be truncated to that length.  It\nreturns the signature as a pair of integers. The security of the private key\ndepends on the entropy of rand.\n\nGo input arguments: (rand io.Reader, priv *crypto/ecdsa.PrivateKey, hash []byte)\n\nGo return type: (r *struct {}, s *struct {}, err error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/ecdsa.PrivateKey) priv, ^(vector-of Byte) hash]\n\nJoker return type: [{} {} Error]"
;;   {:added "1.0"
;;    :go "sign(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/ecdsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/ecdsa.PrivateKey(_priv))), ConvertToArrayOfByte(_hash))"}
;;   [^io.Reader _rand, ^Object _priv, ^Object _hash])

JOKER FUNC crypto/ecdsa.Verify:
;; (defn ^"Bool" Verify
;;   "Verify verifies the signature in r, s of hash using the public key, pub. Its\nreturn value records whether the signature is valid.\n\nGo input arguments: (pub *crypto/ecdsa.PublicKey, hash []byte, r *math/big.Int, s *math/big.Int)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of crypto/ecdsa.PublicKey) pub, ^(vector-of Byte) hash, ^(atom-of math/big.Int) r, ^(atom-of math/big.Int) s]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ecdsa.Verify(ConvertToIndirectOfcrypto/ecdsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/ecdsa.PublicKey(_pub))), ConvertToArrayOfByte(_hash), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_r))), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_s))))"}
;;   [^Object _pub, ^Object _hash, ^Object _r, ^Object _s])

JOKER FUNC crypto/elliptic.GenerateKey:
;; (defn GenerateKey
;;   "GenerateKey returns a public/private key pair. The private key is\ngenerated using the given reader, which must return random data.\n\nGo input arguments: (curve crypto/elliptic.Curve, rand io.Reader)\n\nGo return type: (priv []int, x *struct {}, y *struct {}, err error)\n\nJoker input arguments: [^crypto/elliptic.Curve curve, ^io.Reader rand]\n\nJoker return type: [(vector-of Int) {} {} Error]"
;;   {:added "1.0"
;;    :go "generateKey(ABEND904(custom-runtime routine not implemented: crypto/elliptic.Curve(_curve)), ABEND904(custom-runtime routine not implemented: io.Reader(_rand)))"}
;;   [^crypto/elliptic.Curve _curve, ^io.Reader _rand])

JOKER FUNC crypto/elliptic.Marshal:
;; (defn Marshal
;;   "Marshal converts a point into the uncompressed form specified in section 4.3.6 of ANSI X9.62.\n\nGo input arguments: (curve crypto/elliptic.Curve, x *math/big.Int, y *math/big.Int)\n\nGo return type: []int\n\nJoker input arguments: [^crypto/elliptic.Curve curve, ^(atom-of math/big.Int) x, ^(atom-of math/big.Int) y]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshal(ABEND904(custom-runtime routine not implemented: crypto/elliptic.Curve(_curve)), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_x))), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_y))))"}
;;   [^crypto/elliptic.Curve _curve, ^Object _x, ^Object _y])

JOKER FUNC crypto/elliptic.P224:
;; (defn P224
;;   "P224 returns a Curve which implements P-224 (see FIPS 186-3, section D.2.2).\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p224()"}
;;   [])

JOKER FUNC crypto/elliptic.P256:
;; (defn P256
;;   "P256 returns a Curve which implements P-256 (see FIPS 186-3, section D.2.3)\n\nThe cryptographic operations are implemented using constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p256()"}
;;   [])

JOKER FUNC crypto/elliptic.P384:
;; (defn P384
;;   "P384 returns a Curve which implements P-384 (see FIPS 186-3, section D.2.4)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p384()"}
;;   [])

JOKER FUNC crypto/elliptic.P521:
;; (defn P521
;;   "P521 returns a Curve which implements P-521 (see FIPS 186-3, section D.2.5)\n\nThe cryptographic operations do not use constant-time algorithms.\n\nGo return type: Curve\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/elliptic/elliptic.go:24:12)"
;;   {:added "1.0"
;;    :go "p521()"}
;;   [])

JOKER FUNC crypto/elliptic.Unmarshal:
;; (defn Unmarshal
;;   "Unmarshal converts a point, serialized by Marshal, into an x, y pair.\nIt is an error if the point is not in uncompressed form or is not on the curve.\nOn error, x = nil.\n\nGo input arguments: (curve crypto/elliptic.Curve, data []byte)\n\nGo return type: (x *struct {}, y *struct {})\n\nJoker input arguments: [^crypto/elliptic.Curve curve, ^(vector-of Byte) data]\n\nJoker return type: [{} {}]"
;;   {:added "1.0"
;;    :go "unmarshal(ABEND904(custom-runtime routine not implemented: crypto/elliptic.Curve(_curve)), ConvertToArrayOfByte(_data))"}
;;   [^crypto/elliptic.Curve _curve, ^Object _data])

JOKER FUNC crypto/hmac.Equal:
(defn ^"Bool" Equal
  "Equal compares two MACs for equality without leaking timing information.\n\nGo input arguments: (mac1 []byte, mac2 []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) mac1, ^(vector-of Byte) mac2]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "hmac.Equal(ConvertToArrayOfByte(_mac1), ConvertToArrayOfByte(_mac2))"}
  [^Object _mac1, ^Object _mac2])

JOKER FUNC crypto/hmac.New:
;; (defn New
;;   "New returns a new HMAC hash using the given hash.Hash type and key.\nNote that unlike other hash implementations in the standard library,\nthe returned Hash does not implement encoding.BinaryMarshaler\nor encoding.BinaryUnmarshaler.\n\nGo input arguments: (h func, key []byte)\n\nGo return type: ...\n\nJoker input arguments: [^fn h, ^(vector-of Byte) key]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOfByte(_key))"}
;;   [^fn _h, ^Object _key])

JOKER FUNC crypto/md5.New:
;; (defn New
;;   "New returns a new hash.Hash computing the MD5 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC crypto/md5.Sum:
(defn Sum
  "Sum returns the MD5 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/rand.Int:
;; (defn Int
;;   "Int returns a uniform random value in [0, max). It panics if max <= 0.\n\nGo input arguments: (rand io.Reader, max *math/big.Int)\n\nGo return type: (n *struct {}, err error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of math/big.Int) max]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "int(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_max))))"}
;;   [^io.Reader _rand, ^Object _max])

JOKER FUNC crypto/rand.Prime:
;; (defn Prime
;;   "Prime returns a number, p, of the given size, such that p is prime\nwith high probability.\nPrime will return error for any error returned by rand.Read or if bits < 2.\n\nGo input arguments: (rand io.Reader, bits int)\n\nGo return type: (p *struct {}, err error)\n\nJoker input arguments: [^io.Reader rand, ^Int bits]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "prime(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), _bits)"}
;;   [^io.Reader _rand, ^Int _bits])

JOKER FUNC crypto/rand.Read:
(defn Read
  "Read is a helper function that calls Reader.Read using io.ReadFull.\nOn return, n == len(b) if and only if err == nil.\n\nGo input arguments: (b []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "read(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC crypto/rc4.NewCipher:
(defn NewCipher
  "NewCipher creates and returns a new Cipher. The key argument should be the\nRC4 key, at least 1 byte and at most 256 bytes.\n\nGo input arguments: (key []byte)\n\nGo return type: (*Cipher, error)\n\nJoker input arguments: [^(vector-of Byte) key]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "newCipher(ConvertToArrayOfByte(_key))"}
  [^Object _key])

JOKER FUNC crypto/rsa.DecryptOAEP:
;; (defn DecryptOAEP
;;   "OAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter, if not nil, is used to blind the private-key operation\nand avoid timing side-channel attacks. Blinding is purely internal to this\nfunction  the random data need not match that used when encrypting.\n\nThe label parameter must match the value given when encrypting. See\nEncryptOAEP for details.\n\nGo input arguments: (hash hash.Hash, random io.Reader, priv *crypto/rsa.PrivateKey, ciphertext []byte, label []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^hash.Hash hash, ^io.Reader random, ^(atom-of crypto/rsa.PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptOAEP(ABEND904(custom-runtime routine not implemented: hash.Hash(_hash)), ABEND904(custom-runtime routine not implemented: io.Reader(_random)), ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_priv))), ConvertToArrayOfByte(_ciphertext), ConvertToArrayOfByte(_label))"}
;;   [^hash.Hash _hash, ^io.Reader _random, ^Object _priv, ^Object _ciphertext, ^Object _label])

JOKER FUNC crypto/rsa.DecryptPKCS1v15:
;; (defn DecryptPKCS1v15
;;   "DecryptPKCS1v15 decrypts a plaintext using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\n\nNote that whether this function returns an error or not discloses secret\ninformation. If an attacker can cause this function to run repeatedly and\nlearn whether each instance returned an error then they can decrypt and\nforge signatures as if they had the private key. See\nDecryptPKCS1v15SessionKey for a way of solving this problem.\n\nGo input arguments: (rand io.Reader, priv *crypto/rsa.PrivateKey, ciphertext []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/rsa.PrivateKey) priv, ^(vector-of Byte) ciphertext]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPKCS1v15(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_priv))), ConvertToArrayOfByte(_ciphertext))"}
;;   [^io.Reader _rand, ^Object _priv, ^Object _ciphertext])

JOKER FUNC crypto/rsa.DecryptPKCS1v15SessionKey:
;; (defn ^"Error" DecryptPKCS1v15SessionKey
;;   "DecryptPKCS1v15SessionKey decrypts a session key using RSA and the padding scheme from PKCS#1 v1.5.\nIf rand != nil, it uses RSA blinding to avoid timing side-channel attacks.\nIt returns an error if the ciphertext is the wrong length or if the\nciphertext is greater than the public modulus. Otherwise, no error is\nreturned. If the padding is valid, the resulting plaintext message is copied\ninto key. Otherwise, key is unchanged. These alternatives occur in constant\ntime. It is intended that the user of this function generate a random\nsession key beforehand and continue the protocol with the resulting value.\nThis will remove any possibility that an attacker can learn any information\nabout the plaintext.\nSee ``Chosen Ciphertext Attacks Against Protocols Based on the RSA\nEncryption Standard PKCS #1'', Daniel Bleichenbacher, Advances in Cryptology\n(Crypto '98).\n\nNote that if the session key is too small then it may be possible for an\nattacker to brute-force it. If they can do that then they can learn whether\na random value was used (because it'll be different for the same ciphertext)\nand thus whether the padding was correct. This defeats the point of this\nfunction. Using at least a 16-byte key will protect against this attack.\n\nGo input arguments: (rand io.Reader, priv *crypto/rsa.PrivateKey, ciphertext []byte, key []byte)\n\nGo return type: error\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/rsa.PrivateKey) priv, ^(vector-of Byte) ciphertext, ^(vector-of Byte) key]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.DecryptPKCS1v15SessionKey(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_priv))), ConvertToArrayOfByte(_ciphertext), ConvertToArrayOfByte(_key))"}
;;   [^io.Reader _rand, ^Object _priv, ^Object _ciphertext, ^Object _key])

JOKER FUNC crypto/rsa.EncryptOAEP:
;; (defn EncryptOAEP
;;   "EncryptOAEP encrypts the given message with RSA-OAEP.\n\nOAEP is parameterised by a hash function that is used as a random oracle.\nEncryption and decryption of a given message must use the same hash function\nand sha256.New() is a reasonable choice.\n\nThe random parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same ciphertext.\n\nThe label parameter may contain arbitrary data that will not be encrypted,\nbut which gives important context to the message. For example, if a given\npublic key is used to decrypt two types of messages then distinct label\nvalues could be used to ensure that a ciphertext for one purpose cannot be\nused for another by an attacker. If not required it can be empty.\n\nThe message must be no longer than the length of the public modulus minus\ntwice the hash length, minus a further 2.\n\nGo input arguments: (hash hash.Hash, random io.Reader, pub *crypto/rsa.PublicKey, msg []byte, label []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^hash.Hash hash, ^io.Reader random, ^(atom-of crypto/rsa.PublicKey) pub, ^(vector-of Byte) msg, ^(vector-of Byte) label]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptOAEP(ABEND904(custom-runtime routine not implemented: hash.Hash(_hash)), ABEND904(custom-runtime routine not implemented: io.Reader(_random)), ConvertToIndirectOfcrypto/rsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PublicKey(_pub))), ConvertToArrayOfByte(_msg), ConvertToArrayOfByte(_label))"}
;;   [^hash.Hash _hash, ^io.Reader _random, ^Object _pub, ^Object _msg, ^Object _label])

JOKER FUNC crypto/rsa.EncryptPKCS1v15:
;; (defn EncryptPKCS1v15
;;   "EncryptPKCS1v15 encrypts the given message with RSA and the padding\nscheme from PKCS#1 v1.5.  The message must be no longer than the\nlength of the public modulus minus 11 bytes.\n\nThe rand parameter is used as a source of entropy to ensure that\nencrypting the same message twice doesn't result in the same\nciphertext.\n\nWARNING: use of this function to encrypt plaintexts other than\nsession keys is dangerous. Use RSA OAEP in new protocols.\n\nGo input arguments: (rand io.Reader, pub *crypto/rsa.PublicKey, msg []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/rsa.PublicKey) pub, ^(vector-of Byte) msg]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "encryptPKCS1v15(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/rsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PublicKey(_pub))), ConvertToArrayOfByte(_msg))"}
;;   [^io.Reader _rand, ^Object _pub, ^Object _msg])

JOKER FUNC crypto/rsa.GenerateKey:
;; (defn GenerateKey
;;   "GenerateKey generates an RSA keypair of the given bit size using the\nrandom source random (for example, crypto/rand.Reader).\n\nGo input arguments: (random io.Reader, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^io.Reader random, ^Int bits]\n\nJoker return type: [{:D ^{}, :Primes ^(vector-of {}), :Precomputed ^{:Dp ^{}, :Dq ^{}, :Qinv ^{}, :CRTValues ^(vector-of {:Exp ^{}, :Coeff ^{}, :R ^{}})}} Error]"
;;   {:added "1.0"
;;    :go "generateKey(ABEND904(custom-runtime routine not implemented: io.Reader(_random)), _bits)"}
;;   [^io.Reader _random, ^Int _bits])

JOKER FUNC crypto/rsa.GenerateMultiPrimeKey:
;; (defn GenerateMultiPrimeKey
;;   "GenerateMultiPrimeKey generates a multi-prime RSA keypair of the given bit\nsize and the given random source, as suggested in [1]. Although the public\nkeys are compatible (actually, indistinguishable) from the 2-prime case,\nthe private keys are not. Thus it may not be possible to export multi-prime\nprivate keys in certain formats or to subsequently import them into other\ncode.\n\nTable 1 in [2] suggests maximum numbers of primes for a given size.\n\n[1] US patent 4405829 (1972, expired)\n[2] http://www.cacr.math.uwaterloo.ca/techreports/2006/cacr2006-16.pdf\n\nGo input arguments: (random io.Reader, nprimes int, bits int)\n\nGo return type: (*PrivateKey, error)\n\nJoker input arguments: [^io.Reader random, ^Int nprimes, ^Int bits]\n\nJoker return type: [{:D ^{}, :Primes ^(vector-of {}), :Precomputed ^{:Dp ^{}, :Dq ^{}, :Qinv ^{}, :CRTValues ^(vector-of {:Exp ^{}, :Coeff ^{}, :R ^{}})}} Error]"
;;   {:added "1.0"
;;    :go "generateMultiPrimeKey(ABEND904(custom-runtime routine not implemented: io.Reader(_random)), _nprimes, _bits)"}
;;   [^io.Reader _random, ^Int _nprimes, ^Int _bits])

JOKER FUNC crypto/rsa.SignPKCS1v15:
;; (defn SignPKCS1v15
;;   "SignPKCS1v15 calculates the signature of hashed using\nRSASSA-PKCS1-V1_5-SIGN from RSA PKCS#1 v1.5.  Note that hashed must\nbe the result of hashing the input message using the given hash\nfunction. If hash is zero, hashed is signed directly. This isn't\nadvisable except for interoperability.\n\nIf rand is not nil then RSA blinding will be used to avoid timing\nside-channel attacks.\n\nThis function is deterministic. Thus, if the set of possible\nmessages is small, an attacker may be able to build a map from\nmessages to signatures and identify the signed messages. As ever,\nsignatures provide authenticity, not confidentiality.\n\nGo input arguments: (rand io.Reader, priv *crypto/rsa.PrivateKey, hash crypto.Hash, hashed []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/rsa.PrivateKey) priv, ^crypto.Hash hash, ^(vector-of Byte) hashed]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPKCS1v15(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_priv))), ABEND904(custom-runtime routine not implemented: crypto.Hash(_hash)), ConvertToArrayOfByte(_hashed))"}
;;   [^io.Reader _rand, ^Object _priv, ^crypto.Hash _hash, ^Object _hashed])

JOKER FUNC crypto/rsa.SignPSS:
;; (defn SignPSS
;;   "SignPSS calculates the signature of hashed using RSASSA-PSS [1].\nNote that hashed must be the result of hashing the input message using the\ngiven hash function. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (rand io.Reader, priv *crypto/rsa.PrivateKey, hash crypto.Hash, hashed []byte, opts *crypto/rsa.PSSOptions)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/rsa.PrivateKey) priv, ^crypto.Hash hash, ^(vector-of Byte) hashed, ^(atom-of crypto/rsa.PSSOptions) opts]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "signPSS(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_priv))), ABEND904(custom-runtime routine not implemented: crypto.Hash(_hash)), ConvertToArrayOfByte(_hashed), ConvertToIndirectOfcrypto/rsa.PSSOptions(ABEND904(custom-runtime routine not implemented: crypto/rsa.PSSOptions(_opts))))"}
;;   [^io.Reader _rand, ^Object _priv, ^crypto.Hash _hash, ^Object _hashed, ^Object _opts])

JOKER FUNC crypto/rsa.VerifyPKCS1v15:
;; (defn ^"Error" VerifyPKCS1v15
;;   "VerifyPKCS1v15 verifies an RSA PKCS#1 v1.5 signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. If hash is zero then hashed is used directly. This\nisn't advisable except for interoperability.\n\nGo input arguments: (pub *crypto/rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of crypto/rsa.PublicKey) pub, ^crypto.Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPKCS1v15(ConvertToIndirectOfcrypto/rsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PublicKey(_pub))), ABEND904(custom-runtime routine not implemented: crypto.Hash(_hash)), ConvertToArrayOfByte(_hashed), ConvertToArrayOfByte(_sig))"}
;;   [^Object _pub, ^crypto.Hash _hash, ^Object _hashed, ^Object _sig])

JOKER FUNC crypto/rsa.VerifyPSS:
;; (defn ^"Error" VerifyPSS
;;   "VerifyPSS verifies a PSS signature.\nhashed is the result of hashing the input message using the given hash\nfunction and sig is the signature. A valid signature is indicated by\nreturning a nil error. The opts argument may be nil, in which case sensible\ndefaults are used.\n\nGo input arguments: (pub *crypto/rsa.PublicKey, hash crypto.Hash, hashed []byte, sig []byte, opts *crypto/rsa.PSSOptions)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of crypto/rsa.PublicKey) pub, ^crypto.Hash hash, ^(vector-of Byte) hashed, ^(vector-of Byte) sig, ^(atom-of crypto/rsa.PSSOptions) opts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rsa.VerifyPSS(ConvertToIndirectOfcrypto/rsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PublicKey(_pub))), ABEND904(custom-runtime routine not implemented: crypto.Hash(_hash)), ConvertToArrayOfByte(_hashed), ConvertToArrayOfByte(_sig), ConvertToIndirectOfcrypto/rsa.PSSOptions(ABEND904(custom-runtime routine not implemented: crypto/rsa.PSSOptions(_opts))))"}
;;   [^Object _pub, ^crypto.Hash _hash, ^Object _hashed, ^Object _sig, ^Object _opts])

JOKER FUNC crypto/sha1.New:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA1 checksum. The Hash also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC crypto/sha1.Sum:
(defn Sum
  "Sum returns the SHA-1 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha256.New:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA256 checksum. The Hash\nalso implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC crypto/sha256.New224:
;; (defn New224
;;   "New224 returns a new hash.Hash computing the SHA224 checksum.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new224()"}
;;   [])

JOKER FUNC crypto/sha256.Sum224:
(defn Sum224
  "Sum224 returns the SHA224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum224(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha256.Sum256:
(defn Sum256
  "Sum256 returns the SHA256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum256(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha512.New:
;; (defn New
;;   "New returns a new hash.Hash computing the SHA-512 checksum.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC crypto/sha512.New384:
;; (defn New384
;;   "New384 returns a new hash.Hash computing the SHA-384 checksum.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new384()"}
;;   [])

JOKER FUNC crypto/sha512.New512_224:
;; (defn New512_224
;;   "New512_224 returns a new hash.Hash computing the SHA-512/224 checksum.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new512_224()"}
;;   [])

JOKER FUNC crypto/sha512.New512_256:
;; (defn New512_256
;;   "New512_256 returns a new hash.Hash computing the SHA-512/256 checksum.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new512_256()"}
;;   [])

JOKER FUNC crypto/sha512.Sum384:
(defn Sum384
  "Sum384 returns the SHA384 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum384(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha512.Sum512:
(defn Sum512
  "Sum512 returns the SHA512 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum512(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha512.Sum512_224:
(defn Sum512_224
  "Sum512_224 returns the Sum512/224 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum512_224(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/sha512.Sum512_256:
(defn Sum512_256
  "Sum512_256 returns the Sum512/256 checksum of the data.\n\nGo input arguments: (data []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "sum512_256(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC crypto/subtle.ConstantTimeByteEq:
;; (defn ^"Int" ConstantTimeByteEq
;;   "ConstantTimeByteEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x uint8, y uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x, ^uint8 y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "subtle.ConstantTimeByteEq(_x, _y)"}
;;   [^ABEND044(unsupported built-in type uint8) _x, ^ABEND044(unsupported built-in type uint8) _y])

JOKER FUNC crypto/subtle.ConstantTimeCompare:
(defn ^"Int" ConstantTimeCompare
  "ConstantTimeCompare returns 1 if and only if the two slices, x\nand y, have equal contents. The time taken is a function of the length of\nthe slices and is independent of the contents.\n\nGo input arguments: (x []byte, y []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) x, ^(vector-of Byte) y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeCompare(ConvertToArrayOfByte(_x), ConvertToArrayOfByte(_y))"}
  [^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeCopy:
;; (defn ConstantTimeCopy
;;   "ConstantTimeCopy copies the contents of y into x (a slice of equal length)\nif v == 1. If v == 0, x is left unchanged. Its behavior is undefined if v\ntakes any other value.\n\nGo input arguments: (v int, x []byte, y []byte)\n\nJoker input arguments: [^Int v, ^(vector-of Byte) x, ^(vector-of Byte) y]"
;;   {:added "1.0"
;;    :go "constantTimeCopy(_v, ConvertToArrayOfByte(_x), ConvertToArrayOfByte(_y))"}
;;   [^Int _v, ^Object _x, ^Object _y])

JOKER FUNC crypto/subtle.ConstantTimeEq:
(defn ^"Int" ConstantTimeEq
  "ConstantTimeEq returns 1 if x == y and 0 otherwise.\n\nGo input arguments: (x int32, y int32)\n\nGo return type: int\n\nJoker input arguments: [^Int32 x, ^Int32 y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeEq(_x, _y)"}
  [^Int32 _x, ^Int32 _y])

JOKER FUNC crypto/subtle.ConstantTimeLessOrEq:
(defn ^"Int" ConstantTimeLessOrEq
  "ConstantTimeLessOrEq returns 1 if x <= y and 0 otherwise.\nIts behavior is undefined if x or y are negative or > 2**31 - 1.\n\nGo input arguments: (x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeLessOrEq(_x, _y)"}
  [^Int _x, ^Int _y])

JOKER FUNC crypto/subtle.ConstantTimeSelect:
(defn ^"Int" ConstantTimeSelect
  "ConstantTimeSelect returns x if v is 1 and y if v is 0.\nIts behavior is undefined if v takes any other value.\n\nGo input arguments: (v int, x int, y int)\n\nGo return type: int\n\nJoker input arguments: [^Int v, ^Int x, ^Int y]\n\nJoker return type: Int"
  {:added "1.0"
   :go "subtle.ConstantTimeSelect(_v, _x, _y)"}
  [^Int _v, ^Int _x, ^Int _y])

JOKER FUNC crypto/tls.Client:
;; (defn Client
;;   "Client returns a new TLS client side connection\nusing conn as the underlying transport.\nThe config cannot be nil: users must set either ServerName or\nInsecureSkipVerify in the config.\n\nGo input arguments: (conn net.Conn, config *crypto/tls.Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^net.Conn conn, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: client(ABEND904(custom-runtime routine not implemented: net.Conn(_conn)), ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config)))))"}
;;   [^net.Conn _conn, ^Object _config])

JOKER FUNC crypto/tls.Dial:
;; (defn Dial
;;   "Dial connects to the given network address using net.Dial\nand then initiates a TLS handshake, returning the resulting\nTLS connection.\nDial interprets a nil configuration as equivalent to\nthe zero configuration; see the documentation of Config\nfor the defaults.\n\nGo input arguments: (network string, addr string, config *crypto/tls.Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _addr, ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config))))"}
;;   [^String _network, ^String _addr, ^Object _config])

JOKER FUNC crypto/tls.DialWithDialer:
;; (defn DialWithDialer
;;   "DialWithDialer connects to the given network address using dialer.Dial and\nthen initiates a TLS handshake, returning the resulting TLS connection. Any\ntimeout or deadline given in the dialer apply to connection and TLS\nhandshake as a whole.\n\nDialWithDialer interprets a nil configuration as equivalent to the zero\nconfiguration; see the documentation of Config for the defaults.\n\nGo input arguments: (dialer *net.Dialer, network string, addr string, config *crypto/tls.Config)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^(atom-of net.Dialer) dialer, ^String network, ^String addr, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialWithDialer(ConvertToIndirectOfnet.Dialer(ABEND904(custom-runtime routine not implemented: net.Dialer(_dialer))), _network, _addr, ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config))))"}
;;   [^Object _dialer, ^String _network, ^String _addr, ^Object _config])

JOKER FUNC crypto/tls.Listen:
;; (defn Listen
;;   "Listen creates a TLS listener accepting connections on the\ngiven network address using net.Listen.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (network string, laddr string, config *crypto/tls.Config)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String network, ^String laddr, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(_network, _laddr, ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config))))"}
;;   [^String _network, ^String _laddr, ^Object _config])

JOKER FUNC crypto/tls.LoadX509KeyPair:
;; (defn LoadX509KeyPair
;;   "LoadX509KeyPair reads and parses a public/private key pair from a pair\nof files. The files must contain PEM encoded data. The certificate file\nmay contain intermediate certificates following the leaf certificate to\nform a certificate chain. On successful return, Certificate.Leaf will\nbe nil because the parsed form of the certificate is not retained.\n\nGo input arguments: (certFile string, keyFile string)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^String certFile, ^String keyFile]\n\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/crypto.go:111:17), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^{:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename crypto/tls.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename crypto/tls.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename crypto/tls.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename crypto/tls.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename crypto/tls.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/tls.IP), :Mask ^ABEND042(cannot find typename crypto/tls.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/tls.IP), :Mask ^ABEND042(cannot find typename crypto/tls.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}} Error]"
;;   {:added "1.0"
;;    :go "loadX509KeyPair(_certFile, _keyFile)"}
;;   [^String _certFile, ^String _keyFile])

JOKER FUNC crypto/tls.NewLRUClientSessionCache:
;; (defn NewLRUClientSessionCache
;;   "NewLRUClientSessionCache returns a ClientSessionCache with the given\ncapacity that uses an LRU strategy. If capacity is < 1, a default capacity\nis used instead.\n\nGo input arguments: (capacity int)\n\nGo return type: ClientSessionCache\n\nJoker input arguments: [^Int capacity]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/tls/common.go:215:25)"
;;   {:added "1.0"
;;    :go "newLRUClientSessionCache(_capacity)"}
;;   [^Int _capacity])

JOKER FUNC crypto/tls.NewListener:
;; (defn NewListener
;;   "NewListener creates a Listener which accepts connections from an inner\nListener and wraps each connection with Server.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (inner net.Listener, config *crypto/tls.Config)\n\nGo return type: ...\n\nJoker input arguments: [^net.Listener inner, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15)"
;;   {:added "1.0"
;;    :go "newListener(ABEND904(custom-runtime routine not implemented: net.Listener(_inner)), ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config))))"}
;;   [^net.Listener _inner, ^Object _config])

JOKER FUNC crypto/tls.Server:
;; (defn Server
;;   "Server returns a new TLS server side connection\nusing conn as the underlying transport.\nThe configuration config must be non-nil and must include\nat least one certificate or else set GetCertificate.\n\nGo input arguments: (conn net.Conn, config *crypto/tls.Config)\n\nGo return type: *Conn\n\nJoker input arguments: [^net.Conn conn, ^(atom-of crypto/tls.Config) config]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: server(ABEND904(custom-runtime routine not implemented: net.Conn(_conn)), ConvertToIndirectOfcrypto/tls.Config(ABEND904(custom-runtime routine not implemented: crypto/tls.Config(_config)))))"}
;;   [^net.Conn _conn, ^Object _config])

JOKER FUNC crypto/tls.X509KeyPair:
;; (defn X509KeyPair
;;   "X509KeyPair parses a public/private key pair from a pair of\nPEM encoded data. On successful return, Certificate.Leaf will be nil because\nthe parsed form of the certificate is not retained.\n\nGo input arguments: (certPEMBlock []byte, keyPEMBlock []byte)\n\nGo return type: (Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) certPEMBlock, ^(vector-of Byte) keyPEMBlock]\n\nJoker return type: [{:Certificate ^(vector-of (vector-of Int)), :PrivateKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/crypto.go:111:17), :OCSPStaple ^(vector-of Int), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :Leaf ^{:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename crypto/tls.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename crypto/tls.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/tls.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename crypto/tls.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename crypto/tls.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename crypto/tls.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/tls.IP), :Mask ^ABEND042(cannot find typename crypto/tls.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/tls.IP), :Mask ^ABEND042(cannot find typename crypto/tls.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}} Error]"
;;   {:added "1.0"
;;    :go "x509KeyPair(ConvertToArrayOfByte(_certPEMBlock), ConvertToArrayOfByte(_keyPEMBlock))"}
;;   [^Object _certPEMBlock, ^Object _keyPEMBlock])

JOKER FUNC crypto/x509.CreateCertificate:
;; (defn CreateCertificate
;;   "CreateCertificate creates a new X.509v3 certificate based on a template.\nThe following members of template are used:\n\n - AuthorityKeyId\n - BasicConstraintsValid\n - CRLDistributionPoints\n - DNSNames\n - EmailAddresses\n - ExcludedDNSDomains\n - ExcludedEmailAddresses\n - ExcludedIPRanges\n - ExcludedURIDomains\n - ExtKeyUsage\n - ExtraExtensions\n - IsCA\n - IssuingCertificateURL\n - KeyUsage\n - MaxPathLen\n - MaxPathLenZero\n - NotAfter\n - NotBefore\n - OCSPServer\n - PermittedDNSDomains\n - PermittedDNSDomainsCritical\n - PermittedEmailAddresses\n - PermittedIPRanges\n - PermittedURIDomains\n - PolicyIdentifiers\n - SerialNumber\n - SignatureAlgorithm\n - Subject\n - SubjectKeyId\n - URIs\n - UnknownExtKeyUsage\n\nThe certificate is signed by parent. If parent is equal to template then the\ncertificate is self-signed. The parameter pub is the public key of the\nsignee and priv is the private key of the signer.\n\nThe returned slice is the certificate in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nThe AuthorityKeyId will be taken from the SubjectKeyId of parent, if any,\nunless the resulting certificate is self-signed. Otherwise the value from\ntemplate will be used.\n\nGo input arguments: (rand io.Reader, template *crypto/x509.Certificate, parent *crypto/x509.Certificate, pub interface {}, priv interface {})\n\nGo return type: (cert []int, err error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/x509.Certificate) template, ^(atom-of crypto/x509.Certificate) parent, ^<protocol-or-something> pub, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "createCertificate(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/x509.Certificate(ABEND904(custom-runtime routine not implemented: crypto/x509.Certificate(_template))), ConvertToIndirectOfcrypto/x509.Certificate(ABEND904(custom-runtime routine not implemented: crypto/x509.Certificate(_parent))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Reader _rand, ^Object _template, ^Object _parent, ^<protocol-or-something> _pub, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.CreateCertificateRequest:
;; (defn CreateCertificateRequest
;;   "CreateCertificateRequest creates a new certificate request based on a\ntemplate. The following members of template are used:\n\n - Attributes\n - DNSNames\n - EmailAddresses\n - ExtraExtensions\n - IPAddresses\n - URIs\n - SignatureAlgorithm\n - Subject\n\nThe private key is the private key of the signer.\n\nThe returned slice is the certificate request in DER encoding.\n\nAll keys types that are implemented via crypto.Signer are supported (This\nincludes *rsa.PublicKey and *ecdsa.PublicKey.)\n\nGo input arguments: (rand io.Reader, template *crypto/x509.CertificateRequest, priv interface {})\n\nGo return type: (csr []int, err error)\n\nJoker input arguments: [^io.Reader rand, ^(atom-of crypto/x509.CertificateRequest) template, ^<protocol-or-something> priv]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "createCertificateRequest(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), ConvertToIndirectOfcrypto/x509.CertificateRequest(ABEND904(custom-runtime routine not implemented: crypto/x509.CertificateRequest(_template))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Reader _rand, ^Object _template, ^<protocol-or-something> _priv])

JOKER FUNC crypto/x509.DecryptPEMBlock:
;; (defn DecryptPEMBlock
;;   "DecryptPEMBlock takes a password encrypted PEM block and the password used to\nencrypt it and returns a slice of decrypted DER encoded bytes. It inspects\nthe DEK-Info header to determine the algorithm used for decryption. If no\nDEK-Info header is present, an error is returned. If an incorrect password\nis detected an IncorrectPasswordError is returned. Because of deficiencies\nin the encrypted-PEM format, it's not always possible to detect an incorrect\npassword. In these cases no error will be returned but the decrypted DER\nbytes will be random noise.\n\nGo input arguments: (b *encoding/pem.Block, password []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of encoding/pem.Block) b, ^(vector-of Byte) password]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "decryptPEMBlock(ConvertToIndirectOfencoding/pem.Block(ABEND904(custom-runtime routine not implemented: encoding/pem.Block(_b))), ConvertToArrayOfByte(_password))"}
;;   [^Object _b, ^Object _password])

JOKER FUNC crypto/x509.EncryptPEMBlock:
;; (defn EncryptPEMBlock
;;   "EncryptPEMBlock returns a PEM block of the specified type holding the\ngiven DER-encoded data encrypted with the specified algorithm and\npassword.\n\nGo input arguments: (rand io.Reader, blockType string, data []byte, password []byte, alg crypto/x509.PEMCipher)\n\nGo return type: (*struct {Type string; Headers ...; Bytes []int}, error)\n\nJoker input arguments: [^io.Reader rand, ^String blockType, ^(vector-of Byte) data, ^(vector-of Byte) password, ^crypto/x509.PEMCipher alg]\n\nJoker return type: [{:Type ^String, :Headers ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/pem/pem.go:29:10), :Bytes ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "encryptPEMBlock(ABEND904(custom-runtime routine not implemented: io.Reader(_rand)), _blockType, ConvertToArrayOfByte(_data), ConvertToArrayOfByte(_password), ABEND904(custom-runtime routine not implemented: crypto/x509.PEMCipher(_alg)))"}
;;   [^io.Reader _rand, ^String _blockType, ^Object _data, ^Object _password, ^crypto/x509.PEMCipher _alg])

JOKER FUNC crypto/x509.IsEncryptedPEMBlock:
;; (defn ^"Bool" IsEncryptedPEMBlock
;;   "IsEncryptedPEMBlock returns if the PEM block is password encrypted.\n\nGo input arguments: (b *encoding/pem.Block)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of encoding/pem.Block) b]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "x509.IsEncryptedPEMBlock(ConvertToIndirectOfencoding/pem.Block(ABEND904(custom-runtime routine not implemented: encoding/pem.Block(_b))))"}
;;   [^Object _b])

JOKER FUNC crypto/x509.MarshalECPrivateKey:
;; (defn MarshalECPrivateKey
;;   "MarshalECPrivateKey marshals an EC private key into ASN.1, DER format.\n\nGo input arguments: (key *crypto/ecdsa.PrivateKey)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of crypto/ecdsa.PrivateKey) key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalECPrivateKey(ConvertToIndirectOfcrypto/ecdsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/ecdsa.PrivateKey(_key))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS1PrivateKey:
;; (defn MarshalPKCS1PrivateKey
;;   "MarshalPKCS1PrivateKey converts a private key to ASN.1 DER encoded form.\n\nGo input arguments: (key *crypto/rsa.PrivateKey)\n\nGo return type: []int\n\nJoker input arguments: [^(atom-of crypto/rsa.PrivateKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PrivateKey(ConvertToIndirectOfcrypto/rsa.PrivateKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PrivateKey(_key))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS1PublicKey:
;; (defn MarshalPKCS1PublicKey
;;   "MarshalPKCS1PublicKey converts an RSA public key to PKCS#1, ASN.1 DER form.\n\nGo input arguments: (key *crypto/rsa.PublicKey)\n\nGo return type: []int\n\nJoker input arguments: [^(atom-of crypto/rsa.PublicKey) key]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "marshalPKCS1PublicKey(ConvertToIndirectOfcrypto/rsa.PublicKey(ABEND904(custom-runtime routine not implemented: crypto/rsa.PublicKey(_key))))"}
;;   [^Object _key])

JOKER FUNC crypto/x509.MarshalPKCS8PrivateKey:
;; (defn MarshalPKCS8PrivateKey
;;   "MarshalPKCS8PrivateKey converts a private key to PKCS#8 encoded form.\nThe following key types are supported: *rsa.PrivateKey, *ecdsa.PrivateKey.\nUnsupported key types result in an error.\n\nSee RFC 5208.\n\nGo input arguments: (key interface {})\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> key]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKCS8PrivateKey(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _key])

JOKER FUNC crypto/x509.MarshalPKIXPublicKey:
;; (defn MarshalPKIXPublicKey
;;   "MarshalPKIXPublicKey serialises a public key to DER-encoded PKIX format.\n\nGo input arguments: (pub interface {})\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> pub]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalPKIXPublicKey(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _pub])

JOKER FUNC crypto/x509.NewCertPool:
;; (defn NewCertPool
;;   "NewCertPool returns a new, empty CertPool.\n\nGo return type: *CertPool\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newCertPool())"}
;;   [])

JOKER FUNC crypto/x509.ParseCRL:
;; (defn ParseCRL
;;   "ParseCRL parses a CRL from the given bytes. It's often the case that PEM\nencoded CRLs will appear where they should be DER encoded, so this function\nwill transparently handle PEM encoding as long as there isn't any leading\ngarbage.\n\nGo input arguments: (crlBytes []byte)\n\nGo return type: (*struct {TBSCertList TBSCertificateList; SignatureAlgorithm AlgorithmIdentifier; SignatureValue struct {Bytes []int; BitLength int}}, error)\n\nJoker input arguments: [^(vector-of Byte) crlBytes]\n\nJoker return type: [{:TBSCertList ^ABEND042(cannot find typename crypto/x509.TBSCertificateList), :SignatureAlgorithm ^ABEND042(cannot find typename crypto/x509.AlgorithmIdentifier), :SignatureValue ^{:Bytes ^(vector-of Int), :BitLength ^Int}} Error]"
;;   {:added "1.0"
;;    :go "parseCRL(ConvertToArrayOfByte(_crlBytes))"}
;;   [^Object _crlBytes])

JOKER FUNC crypto/x509.ParseCertificate:
;; (defn ParseCertificate
;;   "ParseCertificate parses a single certificate from the given ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^Int, :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename crypto/x509.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/x509.IP), :Mask ^ABEND042(cannot find typename crypto/x509.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/x509.IP), :Mask ^ABEND042(cannot find typename crypto/x509.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))} Error]"
;;   {:added "1.0"
;;    :go "parseCertificate(ConvertToArrayOfByte(_asn1Data))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificateRequest:
;; (defn ParseCertificateRequest
;;   "ParseCertificateRequest parses a single certificate request from the\ngiven ASN.1 DER data.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: (*CertificateRequest, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [{:Raw ^(vector-of Int), :RawTBSCertificateRequest ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :Version ^Int, :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:2274:21), :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue))}, :Attributes ^(vector-of {:Type ^(vector-of Int), :Value ^(vector-of (vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)))}), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename crypto/x509.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String})} Error]"
;;   {:added "1.0"
;;    :go "parseCertificateRequest(ConvertToArrayOfByte(_asn1Data))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseCertificates:
;; (defn ParseCertificates
;;   "ParseCertificates parses one or more certificates from the given ASN.1 DER\ndata. The certificates must be concatenated with no intermediate padding.\n\nGo input arguments: (asn1Data []byte)\n\nGo return type: ([]*Certificate, error)\n\nJoker input arguments: [^(vector-of Byte) asn1Data]\n\nJoker return type: [(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^Int, :PublicKeyAlgorithm ^Int, :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename crypto/x509.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^Int, :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of Int), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename crypto/x509.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/x509.IP), :Mask ^ABEND042(cannot find typename crypto/x509.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename crypto/x509.IP), :Mask ^ABEND042(cannot find typename crypto/x509.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}) Error]"
;;   {:added "1.0"
;;    :go "parseCertificates(ConvertToArrayOfByte(_asn1Data))"}
;;   [^Object _asn1Data])

JOKER FUNC crypto/x509.ParseDERCRL:
;; (defn ParseDERCRL
;;   "ParseDERCRL parses a DER encoded CRL from the given bytes.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (*struct {TBSCertList TBSCertificateList; SignatureAlgorithm AlgorithmIdentifier; SignatureValue struct {Bytes []int; BitLength int}}, error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [{:TBSCertList ^ABEND042(cannot find typename crypto/x509.TBSCertificateList), :SignatureAlgorithm ^ABEND042(cannot find typename crypto/x509.AlgorithmIdentifier), :SignatureValue ^{:Bytes ^(vector-of Int), :BitLength ^Int}} Error]"
;;   {:added "1.0"
;;    :go "parseDERCRL(ConvertToArrayOfByte(_derBytes))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.ParseECPrivateKey:
(defn ParseECPrivateKey
  "ParseECPrivateKey parses an ASN.1 Elliptic Curve Private Key Structure.\n\nGo input arguments: (der []byte)\n\nGo return type: (*struct {D *struct {}}, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [{:D ^{}} Error]"
  {:added "1.0"
   :go "parseECPrivateKey(ConvertToArrayOfByte(_der))"}
  [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PrivateKey:
;; (defn ParsePKCS1PrivateKey
;;   "ParsePKCS1PrivateKey returns an RSA private key from its ASN.1 PKCS#1 DER encoded form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*struct {D *struct {}; Primes []*struct {}; Precomputed PrecomputedValues}, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [{:D ^{}, :Primes ^(vector-of {}), :Precomputed ^ABEND042(cannot find typename crypto/x509.PrecomputedValues)} Error]"
;;   {:added "1.0"
;;    :go "parsePKCS1PrivateKey(ConvertToArrayOfByte(_der))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS1PublicKey:
(defn ParsePKCS1PublicKey
  "ParsePKCS1PublicKey parses a PKCS#1 public key in ASN.1 DER form.\n\nGo input arguments: (der []byte)\n\nGo return type: (*struct {N *struct {}; E int}, error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [{:N ^{}, :E ^Int} Error]"
  {:added "1.0"
   :go "parsePKCS1PublicKey(ConvertToArrayOfByte(_der))"}
  [^Object _der])

JOKER FUNC crypto/x509.ParsePKCS8PrivateKey:
;; (defn ParsePKCS8PrivateKey
;;   "ParsePKCS8PrivateKey parses an unencrypted, PKCS#8 private key.\nSee RFC 5208.\n\nGo input arguments: (der []byte)\n\nGo return type: (key ..., err error)\n\nJoker input arguments: [^(vector-of Byte) der]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/pkcs8.go:28:44) Error]"
;;   {:added "1.0"
;;    :go "parsePKCS8PrivateKey(ConvertToArrayOfByte(_der))"}
;;   [^Object _der])

JOKER FUNC crypto/x509.ParsePKIXPublicKey:
;; (defn ParsePKIXPublicKey
;;   "ParsePKIXPublicKey parses a DER encoded public key. These values are\ntypically found in PEM blocks with \"BEGIN PUBLIC KEY\".\n\nSupported key types include RSA, DSA, and ECDSA. Unknown key\ntypes result in an error.\n\nOn success, pub will be of type *rsa.PublicKey, *dsa.PublicKey,\nor *ecdsa.PublicKey.\n\nGo input arguments: (derBytes []byte)\n\nGo return type: (pub ..., err error)\n\nJoker input arguments: [^(vector-of Byte) derBytes]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:55:47) Error]"
;;   {:added "1.0"
;;    :go "parsePKIXPublicKey(ConvertToArrayOfByte(_derBytes))"}
;;   [^Object _derBytes])

JOKER FUNC crypto/x509.SystemCertPool:
(defn SystemCertPool
  "SystemCertPool returns a copy of the system cert pool.\n\nAny mutations to the returned pool are not written to disk and do\nnot affect any other pool.\n\nNew changes in the the system cert pool might not be reflected\nin subsequent calls.\n\nGo return type: (*CertPool, error)\n\nJoker input arguments: []\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "systemCertPool()"}
  [])

JOKER FUNC database/sql.Drivers:
(defn Drivers
  "Drivers returns a sorted list of the names of the registered drivers.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "drivers()"}
  [])

JOKER FUNC database/sql.Named:
;; (defn Named
;;   "Named provides a more concise way to create NamedArg values.\n\nExample usage:\n\n    db.ExecContext(ctx, `\n        delete from Invoice\n        where\n            TimeCreated < @end\n            and TimeCreated >= @start;`,\n        sql.Named(\"start\", startTime),\n        sql.Named(\"end\", endTime),\n    )\n\nGo input arguments: (name string, value interface {})\n\nGo return type: NamedArg\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]\n\nJoker return type: {:Name ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/database/sql/sql.go:95:8)}"
;;   {:added "1.0"
;;    :go "named(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER FUNC database/sql.Open:
(defn Open
  "Open opens a database specified by its database driver name and a\ndriver-specific data source name, usually consisting of at least a\ndatabase name and connection information.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpen may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the Open\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (driverName string, dataSourceName string)\n\nGo return type: (*DB, error)\n\nJoker input arguments: [^String driverName, ^String dataSourceName]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(_driverName, _dataSourceName)"}
  [^String _driverName, ^String _dataSourceName])

JOKER FUNC database/sql.OpenDB:
;; (defn OpenDB
;;   "OpenDB opens a database using a Connector, allowing drivers to\nbypass a string based data source name.\n\nMost users will open a database via a driver-specific connection\nhelper function that returns a *DB. No database drivers are included\nin the Go standard library. See https://golang.org/s/sqldrivers for\na list of third-party drivers.\n\nOpenDB may just validate its arguments without creating a connection\nto the database. To verify that the data source name is valid, call\nPing.\n\nThe returned DB is safe for concurrent use by multiple goroutines\nand maintains its own pool of idle connections. Thus, the OpenDB\nfunction should be called just once. It is rarely necessary to\nclose a DB.\n\nGo input arguments: (c database/sql/driver.Connector)\n\nGo return type: *DB\n\nJoker input arguments: [^database/sql/driver.Connector c]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: openDB(ABEND904(custom-runtime routine not implemented: database/sql/driver.Connector(_c))))"}
;;   [^database/sql/driver.Connector _c])

JOKER FUNC database/sql.Register:
;; (defn Register
;;   "Register makes a database driver available by the provided name.\nIf Register is called twice with the same name or if driver is nil,\nit panics.\n\nGo input arguments: (name string, driver database/sql/driver.Driver)\n\nJoker input arguments: [^String name, ^database/sql/driver.Driver driver]"
;;   {:added "1.0"
;;    :go "register(_name, ABEND904(custom-runtime routine not implemented: database/sql/driver.Driver(_driver)))"}
;;   [^String _name, ^database/sql/driver.Driver _driver])

JOKER FUNC database/sql/driver.IsScanValue:
;; (defn ^"Bool" IsScanValue
;;   "IsScanValue is equivalent to IsValue.\nIt exists for compatibility.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsScanValue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC database/sql/driver.IsValue:
;; (defn ^"Bool" IsValue
;;   "IsValue reports whether v is a valid Value parameter type.\n\nGo input arguments: (v interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "driver.IsValue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC debug/dwarf.New:
(defn New
  "New returns a new Data object initialized from the given parameters.\nRather than calling this function directly, clients should typically use\nthe DWARF method of the File type of the appropriate package debug/elf,\ndebug/macho, or debug/pe.\n\nThe []byte arguments are the data from the corresponding debug section\nin the object file; for example, for an ELF object, abbrev is the contents of\nthe \".debug_abbrev\" section.\n\nGo input arguments: (abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte)\n\nGo return type: (*Data, error)\n\nJoker input arguments: [^(vector-of Byte) abbrev, ^(vector-of Byte) aranges, ^(vector-of Byte) frame, ^(vector-of Byte) info, ^(vector-of Byte) line, ^(vector-of Byte) pubnames, ^(vector-of Byte) ranges, ^(vector-of Byte) str]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "new(ConvertToArrayOfByte(_abbrev), ConvertToArrayOfByte(_aranges), ConvertToArrayOfByte(_frame), ConvertToArrayOfByte(_info), ConvertToArrayOfByte(_line), ConvertToArrayOfByte(_pubnames), ConvertToArrayOfByte(_ranges), ConvertToArrayOfByte(_str))"}
  [^Object _abbrev, ^Object _aranges, ^Object _frame, ^Object _info, ^Object _line, ^Object _pubnames, ^Object _ranges, ^Object _str])

JOKER FUNC debug/elf.NewFile:
;; (defn NewFile
;;   "NewFile creates a new File for accessing an ELF binary in an underlying reader.\nThe ELF binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^io.ReaderAt r]\n\nJoker return type: [{:Sections ^(vector-of {}), :Progs ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFile(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)))"}
;;   [^io.ReaderAt _r])

JOKER FUNC debug/elf.Open:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as an ELF binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Sections ^(vector-of {}), :Progs ^(vector-of {})} Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC debug/elf.R_INFO:
;; (defn R_INFO
;;   "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: ...\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "r_INFO(_sym, _typ)"}
;;   [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_INFO32:
(defn ^"Int" R_INFO32
  "Go input arguments: (sym uint32, typ uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 sym, ^UInt32 typ]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(elf.R_INFO32(_sym, _typ))"}
  [^UInt32 _sym, ^UInt32 _typ])

JOKER FUNC debug/elf.R_SYM32:
(defn ^"Int" R_SYM32
  "Go input arguments: (info uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 info]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(elf.R_SYM32(_info))"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_SYM64:
;; (defn ^"Int" R_SYM64
;;   "Go input arguments: (info uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(elf.R_SYM64(_info))"}
;;   [^ABEND044(unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.R_TYPE32:
(defn ^"Int" R_TYPE32
  "Go input arguments: (info uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 info]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(elf.R_TYPE32(_info))"}
  [^UInt32 _info])

JOKER FUNC debug/elf.R_TYPE64:
;; (defn ^"Int" R_TYPE64
;;   "Go input arguments: (info uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(elf.R_TYPE64(_info))"}
;;   [^ABEND044(unsupported built-in type uint64) _info])

JOKER FUNC debug/elf.ST_BIND:
;; (defn ^"Int" ST_BIND
;;   "Go input arguments: (info uint8)\n\nGo return type: SymBind\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(elf.ST_BIND(_info))"}
;;   [^ABEND044(unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_INFO:
;; (defn ST_INFO
;;   "Go input arguments: (bind debug/elf.SymBind, typ debug/elf.SymType)\n\nGo return type: ...\n\nJoker input arguments: [^debug/elf.SymBind bind, ^debug/elf.SymType typ]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "sT_INFO(ABEND904(custom-runtime routine not implemented: debug/elf.SymBind(_bind)), ABEND904(custom-runtime routine not implemented: debug/elf.SymType(_typ)))"}
;;   [^debug/elf.SymBind _bind, ^debug/elf.SymType _typ])

JOKER FUNC debug/elf.ST_TYPE:
;; (defn ^"Int" ST_TYPE
;;   "Go input arguments: (info uint8)\n\nGo return type: SymType\n\nJoker input arguments: [^uint8 info]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(elf.ST_TYPE(_info))"}
;;   [^ABEND044(unsupported built-in type uint8) _info])

JOKER FUNC debug/elf.ST_VISIBILITY:
;; (defn ^"Int" ST_VISIBILITY
;;   "Go input arguments: (other uint8)\n\nGo return type: SymVis\n\nJoker input arguments: [^uint8 other]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(elf.ST_VISIBILITY(_other))"}
;;   [^ABEND044(unsupported built-in type uint8) _other])

JOKER FUNC debug/gosym.NewLineTable:
;; (defn NewLineTable
;;   "NewLineTable returns a new PC/line table\ncorresponding to the encoded data.\nText must be the start address of the\ncorresponding text segment.\n\nGo input arguments: (data []byte, text uint64)\n\nGo return type: *LineTable\n\nJoker input arguments: [^(vector-of Byte) data, ^uint64 text]\n\nJoker return type: {:Data ^(vector-of Int), :PC ^ABEND043(unsupported built-in type uint64), :Line ^Int}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newLineTable(ConvertToArrayOfByte(_data), _text))"}
;;   [^Object _data, ^ABEND044(unsupported built-in type uint64) _text])

JOKER FUNC debug/gosym.NewTable:
;; (defn NewTable
;;   "NewTable decodes the Go symbol table (the \".gosymtab\" section in ELF),\nreturning an in-memory representation.\nStarting with Go 1.3, the Go symbol table no longer includes symbol data.\n\nGo input arguments: (symtab []byte, pcln *debug/gosym.LineTable)\n\nGo return type: (*Table, error)\n\nJoker input arguments: [^(vector-of Byte) symtab, ^(atom-of debug/gosym.LineTable) pcln]\n\nJoker return type: [{:Syms ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^{:Entry ^ABEND043(unsupported built-in type uint64), :End ^ABEND043(unsupported built-in type uint64), :Params ^(vector-of ABEND947(recursive type reference involving debug/gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving debug/gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND043(unsupported built-in type uint64), :Line ^Int}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving debug/gosym.Func)), :Paths ^(vector-of ABEND947(recursive type reference involving debug/gosym.Sym))}}}), :Funcs ^(vector-of {:Entry ^ABEND043(unsupported built-in type uint64), :End ^ABEND043(unsupported built-in type uint64), :Params ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^ABEND947(recursive type reference involving debug/gosym.Func)}), :Locals ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^ABEND947(recursive type reference involving debug/gosym.Func)}), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND043(unsupported built-in type uint64), :Line ^Int}, :Obj ^{:Funcs ^(vector-of ABEND947(recursive type reference involving debug/gosym.Func)), :Paths ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^ABEND947(recursive type reference involving debug/gosym.Func)})}}), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/debug/gosym/symtab.go:121:8), :Objs ^(vector-of {:Funcs ^(vector-of {:Entry ^ABEND043(unsupported built-in type uint64), :End ^ABEND043(unsupported built-in type uint64), :Params ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^ABEND947(recursive type reference involving debug/gosym.Func)}), :Locals ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^ABEND947(recursive type reference involving debug/gosym.Func)}), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND043(unsupported built-in type uint64), :Line ^Int}, :Obj ^ABEND947(recursive type reference involving debug/gosym.Obj)}), :Paths ^(vector-of {:Value ^ABEND043(unsupported built-in type uint64), :Type ^Int, :Name ^String, :GoType ^ABEND043(unsupported built-in type uint64), :Func ^{:Entry ^ABEND043(unsupported built-in type uint64), :End ^ABEND043(unsupported built-in type uint64), :Params ^(vector-of ABEND947(recursive type reference involving debug/gosym.Sym)), :Locals ^(vector-of ABEND947(recursive type reference involving debug/gosym.Sym)), :FrameSize ^Int, :LineTable ^{:Data ^(vector-of Int), :PC ^ABEND043(unsupported built-in type uint64), :Line ^Int}, :Obj ^ABEND947(recursive type reference involving debug/gosym.Obj)}})})} Error]"
;;   {:added "1.0"
;;    :go "newTable(ConvertToArrayOfByte(_symtab), ConvertToIndirectOfdebug/gosym.LineTable(ABEND904(custom-runtime routine not implemented: debug/gosym.LineTable(_pcln))))"}
;;   [^Object _symtab, ^Object _pcln])

JOKER FUNC debug/macho.NewFatFile:
;; (defn NewFatFile
;;   "NewFatFile creates a new FatFile for accessing all the Mach-O images in a\nuniversal binary. The Mach-O binary is expected to start at position 0 in\nthe ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^io.ReaderAt r]\n\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFatFile(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)))"}
;;   [^io.ReaderAt _r])

JOKER FUNC debug/macho.NewFile:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Mach-O binary in an underlying reader.\nThe Mach-O binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^io.ReaderAt r]\n\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/binary/binary.go:33:16), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND043(unsupported built-in type uint8), :Len ^ABEND043(unsupported built-in type uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool})}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND043(unsupported built-in type uint8), :Sect ^ABEND043(unsupported built-in type uint8), :Desc ^Int, :Value ^ABEND043(unsupported built-in type uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "newFile(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)))"}
;;   [^io.ReaderAt _r])

JOKER FUNC debug/macho.Open:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a Mach-O binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:ByteOrder ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/binary/binary.go:33:16), :Loads ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/macho/file.go:35:11)), :Sections ^(vector-of {:Relocs ^(vector-of {:Addr ^Int, :Value ^Int, :Type ^ABEND043(unsupported built-in type uint8), :Len ^ABEND043(unsupported built-in type uint8), :Pcrel ^Bool, :Extern ^Bool, :Scattered ^Bool})}), :Symtab ^{:Syms ^(vector-of {:Name ^String, :Type ^ABEND043(unsupported built-in type uint8), :Sect ^ABEND043(unsupported built-in type uint8), :Desc ^Int, :Value ^ABEND043(unsupported built-in type uint64)})}, :Dysymtab ^{:IndirectSyms ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "open(_name)"}
;;   [^String _name])

JOKER FUNC debug/macho.OpenFat:
(defn OpenFat
  "OpenFat opens the named file using os.Open and prepares it for use as a Mach-O\nuniversal binary.\n\nGo input arguments: (name string)\n\nGo return type: (*FatFile, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Magic ^Int, :Arches ^(vector-of {})} Error]"
  {:added "1.0"
   :go "openFat(_name)"}
  [^String _name])

JOKER FUNC debug/pe.NewFile:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a PE binary in an underlying reader.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^io.ReaderAt r]\n\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int})}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND043(unsupported built-in type uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND043(unsupported built-in type uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND043(unsupported built-in type uint8), :NumberOfAuxSymbols ^ABEND043(unsupported built-in type uint8)}), :StringTable ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "newFile(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)))"}
;;   [^io.ReaderAt _r])

JOKER FUNC debug/pe.Open:
;; (defn Open
;;   "Open opens the named file using os.Open and prepares it for use as a PE binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:OptionalHeader ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/debug/pe/file.go:25:17), :Sections ^(vector-of {:Relocs ^(vector-of {:VirtualAddress ^Int, :SymbolTableIndex ^Int, :Type ^Int})}), :Symbols ^(vector-of {:Name ^String, :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND043(unsupported built-in type uint8)}), :COFFSymbols ^(vector-of {:Name ^(vector-of ABEND043(unsupported built-in type uint8)), :Value ^Int, :SectionNumber ^Int, :Type ^Int, :StorageClass ^ABEND043(unsupported built-in type uint8), :NumberOfAuxSymbols ^ABEND043(unsupported built-in type uint8)}), :StringTable ^(vector-of Int)} Error]"
;;   {:added "1.0"
;;    :go "open(_name)"}
;;   [^String _name])

JOKER FUNC debug/plan9obj.NewFile:
;; (defn NewFile
;;   "NewFile creates a new File for accessing a Plan 9 binary in an underlying reader.\nThe Plan 9 binary is expected to start at position 0 in the ReaderAt.\n\nGo input arguments: (r io.ReaderAt)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^io.ReaderAt r]\n\nJoker return type: [{:Sections ^(vector-of {})} Error]"
;;   {:added "1.0"
;;    :go "newFile(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)))"}
;;   [^io.ReaderAt _r])

JOKER FUNC debug/plan9obj.Open:
(defn Open
  "Open opens the named file using os.Open and prepares it for use as a Plan 9 a.out binary.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Sections ^(vector-of {})} Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC encoding/ascii85.Decode:
(defn Decode
  "Decode decodes src into dst, returning both the number\nof bytes written to dst and the number consumed from src.\nIf src contains invalid ascii85 data, Decode will return the\nnumber of bytes successfully written and a CorruptInputError.\nDecode ignores space and control characters in src.\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nDecode expects these to have been stripped by the caller.\n\nIf flush is true, Decode assumes that src represents the\nend of the input stream and processes it completely rather\nthan wait for the completion of another 32-bit block.\n\nNewDecoder wraps an io.Reader interface around Decode.\n\nGo input arguments: (dst []byte, src []byte, flush bool)\n\nGo return type: (ndst int, nsrc int, err error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src, ^Bool flush]\n\nJoker return type: [Int Int Error]"
  {:added "1.0"
   :go "decode(ConvertToArrayOfByte(_dst), ConvertToArrayOfByte(_src), _flush)"}
  [^Object _dst, ^Object _src, ^Bool _flush])

JOKER FUNC encoding/ascii85.Encode:
(defn ^"Int" Encode
  "Encode encodes src into at most MaxEncodedLen(len(src))\nbytes of dst, returning the actual number of bytes written.\n\nThe encoding handles 4-byte chunks, using a special encoding\nfor the last fragment, so Encode is not appropriate for use on\nindividual blocks of a large data stream. Use NewEncoder() instead.\n\nOften, ascii85-encoded data is wrapped in <~ and ~> symbols.\nEncode does not add these.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.Encode(ConvertToArrayOfByte(_dst), ConvertToArrayOfByte(_src))"}
  [^Object _dst, ^Object _src])

JOKER FUNC encoding/ascii85.MaxEncodedLen:
(defn ^"Int" MaxEncodedLen
  "MaxEncodedLen returns the maximum length of an encoding of n source bytes.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "ascii85.MaxEncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/ascii85.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder constructs a new ascii85 stream decoder.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newDecoder(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/ascii85.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new ascii85 stream encoder. Data written to\nthe returned writer will be encoded and then written to w.\nAscii85 encodings operate in 32-bit blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\ntrailing partial block.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "newEncoder(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/asn1.Marshal:
;; (defn Marshal
;;   "Marshal returns the ASN.1 encoding of val.\n\nIn addition to the struct tags recognised by Unmarshal, the following can be\nused:\n\n\tia5:         causes strings to be marshaled as ASN.1, IA5String values\n\tomitempty:   causes empty slices to be skipped\n\tprintable:   causes strings to be marshaled as ASN.1, PrintableString values\n\tutf8:        causes strings to be marshaled as ASN.1, UTF8String values\n\tutc:         causes time.Time to be marshaled as ASN.1, UTCTime values\n\tgeneralized: causes time.Time to be marshaled as ASN.1, GeneralizedTime values\n\nGo input arguments: (val interface {})\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.MarshalWithParams:
;; (defn MarshalWithParams
;;   "MarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (val interface {}, params string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalWithParams(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^<protocol-or-something> _val, ^String _params])

JOKER FUNC encoding/asn1.Unmarshal:
;; (defn Unmarshal
;;   "Unmarshal parses the DER-encoded ASN.1 data structure b\nand uses the reflect package to fill in an arbitrary value pointed at by val.\nBecause Unmarshal uses the reflect package, the structs\nbeing written to must use upper case field names.\n\nAn ASN.1 INTEGER can be written to an int, int32, int64,\nor *big.Int (from the math/big package).\nIf the encoded value does not fit in the Go type,\nUnmarshal returns a parse error.\n\nAn ASN.1 BIT STRING can be written to a BitString.\n\nAn ASN.1 OCTET STRING can be written to a []byte.\n\nAn ASN.1 OBJECT IDENTIFIER can be written to an\nObjectIdentifier.\n\nAn ASN.1 ENUMERATED can be written to an Enumerated.\n\nAn ASN.1 UTCTIME or GENERALIZEDTIME can be written to a time.Time.\n\nAn ASN.1 PrintableString, IA5String, or NumericString can be written to a string.\n\nAny of the above ASN.1 values can be written to an interface{}.\nThe value stored in the interface has the corresponding Go type.\nFor integers, that type is int64.\n\nAn ASN.1 SEQUENCE OF x or SET OF x can be written\nto a slice if an x can be written to the slice's element type.\n\nAn ASN.1 SEQUENCE or SET can be written to a struct\nif each of the elements in the sequence can be\nwritten to the corresponding element in the struct.\n\nThe following tags on struct fields have special meaning to Unmarshal:\n\n\tapplication specifies that an APPLICATION tag is used\n\tprivate     specifies that a PRIVATE tag is used\n\tdefault:x   sets the default value for optional integer fields (only used if optional is also present)\n\texplicit    specifies that an additional, explicit tag wraps the implicit one\n\toptional    marks the field as ASN.1 OPTIONAL\n\tset         causes a SET, rather than a SEQUENCE type to be expected\n\ttag:x       specifies the ASN.1 tag number; implies ASN.1 CONTEXT SPECIFIC\n\nIf the type of the first field of a structure is RawContent then the raw\nASN1 contents of the struct will be stored in it.\n\nIf the type name of a slice element ends with \"SET\" then it's treated as if\nthe \"set\" tag was set on it. This can be used with nested slices where a\nstruct tag cannot be given.\n\nOther ASN.1 types are not supported; if it encounters them,\nUnmarshal returns a parse error.\n\nGo input arguments: (b []byte, val interface {})\n\nGo return type: (rest []int, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "unmarshal(ConvertToArrayOfByte(_b), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _b, ^<protocol-or-something> _val])

JOKER FUNC encoding/asn1.UnmarshalWithParams:
;; (defn UnmarshalWithParams
;;   "UnmarshalWithParams allows field parameters to be specified for the\ntop-level element. The form of the params is the same as the field tags.\n\nGo input arguments: (b []byte, val interface {}, params string)\n\nGo return type: (rest []int, err error)\n\nJoker input arguments: [^(vector-of Byte) b, ^<protocol-or-something> val, ^String params]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "unmarshalWithParams(ConvertToArrayOfByte(_b), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _params)"}
;;   [^Object _b, ^<protocol-or-something> _val, ^String _params])

JOKER FUNC encoding/base32.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base32 stream decoder.\n\nGo input arguments: (enc *encoding/base32.Encoding, r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of encoding/base32.Encoding) enc, ^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newDecoder(ConvertToIndirectOfencoding/base32.Encoding(ABEND904(custom-runtime routine not implemented: encoding/base32.Encoding(_enc))), ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^Object _enc, ^io.Reader _r])

JOKER FUNC encoding/base32.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new base32 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase32 encodings operate in 5-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *encoding/base32.Encoding, w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of encoding/base32.Encoding) enc, ^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "newEncoder(ConvertToIndirectOfencoding/base32.Encoding(ABEND904(custom-runtime routine not implemented: encoding/base32.Encoding(_enc))), ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^Object _enc, ^io.Writer _w])

JOKER FUNC encoding/base32.NewEncoding:
;; (defn NewEncoding
;;   "NewEncoding returns a new Encoding defined by the given alphabet,\nwhich must be a 32-byte string.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newEncoding(_encoder))"}
;;   [^String _encoder])

JOKER FUNC encoding/base64.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder constructs a new base64 stream decoder.\n\nGo input arguments: (enc *encoding/base64.Encoding, r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of encoding/base64.Encoding) enc, ^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newDecoder(ConvertToIndirectOfencoding/base64.Encoding(ABEND904(custom-runtime routine not implemented: encoding/base64.Encoding(_enc))), ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^Object _enc, ^io.Reader _r])

JOKER FUNC encoding/base64.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new base64 stream encoder. Data written to\nthe returned writer will be encoded using enc and then written to w.\nBase64 encodings operate in 4-byte blocks; when finished\nwriting, the caller must Close the returned encoder to flush any\npartially written blocks.\n\nGo input arguments: (enc *encoding/base64.Encoding, w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of encoding/base64.Encoding) enc, ^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "newEncoder(ConvertToIndirectOfencoding/base64.Encoding(ABEND904(custom-runtime routine not implemented: encoding/base64.Encoding(_enc))), ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^Object _enc, ^io.Writer _w])

JOKER FUNC encoding/base64.NewEncoding:
;; (defn NewEncoding
;;   "NewEncoding returns a new padded Encoding defined by the given alphabet,\nwhich must be a 64-byte string that does not contain the padding character\nor CR / LF ('\\r', '\\n').\nThe resulting Encoding uses the default padding character ('='),\nwhich may be changed or disabled via WithPadding.\n\nGo input arguments: (encoder string)\n\nGo return type: *Encoding\n\nJoker input arguments: [^String encoder]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newEncoding(_encoder))"}
;;   [^String _encoder])

JOKER FUNC encoding/binary.PutUvarint:
;; (defn ^"Int" PutUvarint
;;   "PutUvarint encodes a uint64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutUvarint will panic.\n\nGo input arguments: (buf []byte, x uint64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.PutUvarint(ConvertToArrayOfByte(_buf), _x)"}
;;   [^Object _buf, ^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC encoding/binary.PutVarint:
(defn ^"Int" PutVarint
  "PutVarint encodes an int64 into buf and returns the number of bytes written.\nIf the buffer is too small, PutVarint will panic.\n\nGo input arguments: (buf []byte, x int64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int64 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "binary.PutVarint(ConvertToArrayOfByte(_buf), _x)"}
  [^Object _buf, ^Int64 _x])

JOKER FUNC encoding/binary.Read:
;; (defn ^"Error" Read
;;   "Read reads structured binary data from r into data.\nData must be a pointer to a fixed-size value or a slice\nof fixed-size values.\nBytes read from r are decoded using the specified byte order\nand written to successive fields of the data.\nWhen decoding boolean values, a zero byte is decoded as false, and\nany other non-zero byte is decoded as true.\nWhen reading into structs, the field data for fields with\nblank (_) field names is skipped; i.e., blank field names\nmay be used for padding.\nWhen reading into a struct, all non-blank fields must be exported\nor Read may panic.\n\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nRead returns ErrUnexpectedEOF.\n\nGo input arguments: (r io.Reader, order encoding/binary.ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^io.Reader r, ^encoding/binary.ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Read(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ABEND904(custom-runtime routine not implemented: encoding/binary.ByteOrder(_order)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Reader _r, ^encoding/binary.ByteOrder _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/binary.ReadUvarint:
;; (defn ReadUvarint
;;   "ReadUvarint reads an encoded unsigned integer from r and returns it as a uint64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.ByteReader r]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Error]"
;;   {:added "1.0"
;;    :go "readUvarint(ABEND904(custom-runtime routine not implemented: io.ByteReader(_r)))"}
;;   [^io.ByteReader _r])

JOKER FUNC encoding/binary.ReadVarint:
;; (defn ReadVarint
;;   "ReadVarint reads an encoded signed integer from r and returns it as an int64.\n\nGo input arguments: (r io.ByteReader)\n\nGo return type: (int, error)\n\nJoker input arguments: [^io.ByteReader r]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readVarint(ABEND904(custom-runtime routine not implemented: io.ByteReader(_r)))"}
;;   [^io.ByteReader _r])

JOKER FUNC encoding/binary.Size:
;; (defn ^"Int" Size
;;   "Size returns how many bytes Write would generate to encode the value v, which\nmust be a fixed-size value or a slice of fixed-size values, or a pointer to such data.\nIf v is neither of these, Size returns -1.\n\nGo input arguments: (v interface {})\n\nGo return type: int\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "binary.Size(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/binary.Uvarint:
;; (defn Uvarint
;;   "Uvarint decodes a uint64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (..., int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Int]"
;;   {:added "1.0"
;;    :go "uvarint(ConvertToArrayOfByte(_buf))"}
;;   [^Object _buf])

JOKER FUNC encoding/binary.Varint:
(defn Varint
  "Varint decodes an int64 from buf and returns that value and the\nnumber of bytes read (> 0). If an error occurred, the value is 0\nand the number of bytes n is <= 0 with the following meaning:\n\n\tn == 0: buf too small\n\tn  < 0: value larger than 64 bits (overflow)\n\t        and -n is the number of bytes read\n\nGo input arguments: (buf []byte)\n\nGo return type: (int, int)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [Int Int]"
  {:added "1.0"
   :go "varint(ConvertToArrayOfByte(_buf))"}
  [^Object _buf])

JOKER FUNC encoding/binary.Write:
;; (defn ^"Error" Write
;;   "Write writes the binary representation of data into w.\nData must be a fixed-size value or a slice of fixed-size\nvalues, or a pointer to such data.\nBoolean values encode as one byte: 1 for true, and 0 for false.\nBytes written to w are encoded using the specified byte order\nand read from successive fields of the data.\nWhen writing structs, zero values are written for fields\nwith blank (_) field names.\n\nGo input arguments: (w io.Writer, order encoding/binary.ByteOrder, data interface {})\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^encoding/binary.ByteOrder order, ^<protocol-or-something> data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "binary.Write(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ABEND904(custom-runtime routine not implemented: encoding/binary.ByteOrder(_order)), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Writer _w, ^encoding/binary.ByteOrder _order, ^<protocol-or-something> _data])

JOKER FUNC encoding/csv.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader that reads from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {:Comma ^ABEND043(unsupported built-in type rune), :Comment ^ABEND043(unsupported built-in type rune), :FieldsPerRecord ^Int, :LazyQuotes ^Bool, :TrimLeadingSpace ^Bool, :ReuseRecord ^Bool, :TrailingComma ^Bool}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/csv.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {:Comma ^ABEND043(unsupported built-in type rune), :UseCRLF ^Bool}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/gob.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from the io.Reader.\nIf r does not also implement io.ByteReader, it will be wrapped in a\nbufio.Reader.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newDecoder(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/gob.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that will transmit on the io.Writer.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newEncoder(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/gob.Register:
;; (defn Register
;;   "Register records a type, identified by a value for that type, under its\ninternal type name. That name will identify the concrete type of a value\nsent or received as an interface variable. Only types that will be\ntransferred as implementations of interface values need to be registered.\nExpecting to be used only during initialization, it panics if the mapping\nbetween types and names is not a bijection.\n\nGo input arguments: (value interface {})\n\nJoker input arguments: [^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _value])

JOKER FUNC encoding/gob.RegisterName:
;; (defn RegisterName
;;   "RegisterName is like Register but uses the provided name rather than the\ntype's default.\n\nGo input arguments: (name string, value interface {})\n\nJoker input arguments: [^String name, ^<protocol-or-something> value]"
;;   {:added "1.0"
;;    :go "registerName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _value])

JOKER FUNC encoding/hex.Decode:
(defn Decode
  "Decode decodes src into DecodedLen(len(src)) bytes,\nreturning the actual number of bytes written to dst.\n\nDecode expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, Decode returns the number\nof bytes decoded before the error.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: (int, error)\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "decode(ConvertToArrayOfByte(_dst), ConvertToArrayOfByte(_src))"}
  [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.DecodeString:
(defn DecodeString
  "DecodeString returns the bytes represented by the hexadecimal string s.\n\nDecodeString expects that src contains only hexadecimal\ncharacters and that src has even length.\nIf the input is malformed, DecodeString returns\nthe bytes decoded before the error.\n\nGo input arguments: (s string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "decodeString(_s)"}
  [^String _s])

JOKER FUNC encoding/hex.DecodedLen:
(defn ^"Int" DecodedLen
  "DecodedLen returns the length of a decoding of x source bytes.\nSpecifically, it returns x / 2.\n\nGo input arguments: (x int)\n\nGo return type: int\n\nJoker input arguments: [^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.DecodedLen(_x)"}
  [^Int _x])

JOKER FUNC encoding/hex.Dump:
(defn ^"String" Dump
  "Dump returns a string that contains a hex dump of the given data. The format\nof the hex dump matches the output of `hexdump -C` on the command line.\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
  {:added "1.0"
   :go "hex.Dump(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC encoding/hex.Dumper:
;; (defn Dumper
;;   "Dumper returns a WriteCloser that writes a hex dump of all written data to\nw. The format of the dump matches the output of `hexdump -C` on the command\nline.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "dumper(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/hex.Encode:
(defn ^"Int" Encode
  "Encode encodes src into EncodedLen(len(src))\nbytes of dst. As a convenience, it returns the number\nof bytes written to dst, but this value is always EncodedLen(len(src)).\nEncode implements hexadecimal encoding.\n\nGo input arguments: (dst []byte, src []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) dst, ^(vector-of Byte) src]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.Encode(ConvertToArrayOfByte(_dst), ConvertToArrayOfByte(_src))"}
  [^Object _dst, ^Object _src])

JOKER FUNC encoding/hex.EncodeToString:
(defn ^"String" EncodeToString
  "EncodeToString returns the hexadecimal encoding of src.\n\nGo input arguments: (src []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: String"
  {:added "1.0"
   :go "hex.EncodeToString(ConvertToArrayOfByte(_src))"}
  [^Object _src])

JOKER FUNC encoding/hex.EncodedLen:
(defn ^"Int" EncodedLen
  "EncodedLen returns the length of an encoding of n source bytes.\nSpecifically, it returns n * 2.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "hex.EncodedLen(_n)"}
  [^Int _n])

JOKER FUNC encoding/hex.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder returns an io.Reader that decodes hexadecimal characters from r.\nNewDecoder expects that r contain only an even number of hexadecimal characters.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newDecoder(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/hex.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns an io.Writer that writes lowercase hexadecimal characters to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "newEncoder(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/json.Compact:
;; (defn ^"Error" Compact
;;   "Compact appends to dst the JSON-encoded src with\ninsignificant space characters elided.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of bytes.Buffer) dst, ^(vector-of Byte) src]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Compact(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_dst))), ConvertToArrayOfByte(_src))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/json.HTMLEscape:
;; (defn HTMLEscape
;;   "HTMLEscape appends to dst the JSON-encoded src with <, >, &, U+2028 and U+2029\ncharacters inside string literals changed to \\u003c, \\u003e, \\u0026, \\u2028, \\u2029\nso that the JSON will be safe to embed inside HTML <script> tags.\nFor historical reasons, web browsers don't honor standard HTML\nescaping within <script> tags, so an alternative JSON encoding must\nbe used.\n\nGo input arguments: (dst *bytes.Buffer, src []byte)\n\nJoker input arguments: [^(atom-of bytes.Buffer) dst, ^(vector-of Byte) src]"
;;   {:added "1.0"
;;    :go "hTMLEscape(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_dst))), ConvertToArrayOfByte(_src))"}
;;   [^Object _dst, ^Object _src])

JOKER FUNC encoding/json.Indent:
;; (defn ^"Error" Indent
;;   "Indent appends to dst an indented form of the JSON-encoded src.\nEach element in a JSON object or array begins on a new,\nindented line beginning with prefix followed by one or more\ncopies of indent according to the indentation nesting.\nThe data appended to dst does not begin with the prefix nor\nany indentation, to make it easier to embed inside other formatted JSON data.\nAlthough leading space characters (space, tab, carriage return, newline)\nat the beginning of src are dropped, trailing space characters\nat the end of src are preserved and copied to dst.\nFor example, if src has no trailing spaces, neither will dst;\nif src ends in a trailing newline, so will dst.\n\nGo input arguments: (dst *bytes.Buffer, src []byte, prefix string, indent string)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of bytes.Buffer) dst, ^(vector-of Byte) src, ^String prefix, ^String indent]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Indent(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_dst))), ConvertToArrayOfByte(_src), _prefix, _indent)"}
;;   [^Object _dst, ^Object _src, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.Marshal:
;; (defn Marshal
;;   "Marshal returns the JSON encoding of v.\n\nMarshal traverses the value v recursively.\nIf an encountered value implements the Marshaler interface\nand is not a nil pointer, Marshal calls its MarshalJSON method\nto produce JSON. If no MarshalJSON method is present but the\nvalue implements encoding.TextMarshaler instead, Marshal calls\nits MarshalText method and encodes the result as a JSON string.\nThe nil pointer exception is not strictly necessary\nbut mimics a similar, necessary exception in the behavior of\nUnmarshalJSON.\n\nOtherwise, Marshal uses the following type-dependent default encodings:\n\nBoolean values encode as JSON booleans.\n\nFloating point, integer, and Number values encode as JSON numbers.\n\nString values encode as JSON strings coerced to valid UTF-8,\nreplacing invalid bytes with the Unicode replacement rune.\nThe angle brackets \"<\" and \">\" are escaped to \"\\u003c\" and \"\\u003e\"\nto keep some browsers from misinterpreting JSON output as HTML.\nAmpersand \"&\" is also escaped to \"\\u0026\" for the same reason.\nThis escaping can be disabled using an Encoder that had SetEscapeHTML(false)\ncalled on it.\n\nArray and slice values encode as JSON arrays, except that\n[]byte encodes as a base64-encoded string, and a nil slice\nencodes as the null JSON value.\n\nStruct values encode as JSON objects.\nEach exported struct field becomes a member of the object, using the\nfield name as the object key, unless the field is omitted for one of the\nreasons given below.\n\nThe encoding of each struct field can be customized by the format string\nstored under the \"json\" key in the struct field's tag.\nThe format string gives the name of the field, possibly followed by a\ncomma-separated list of options. The name may be empty in order to\nspecify options without overriding the default field name.\n\nThe \"omitempty\" option specifies that the field should be omitted\nfrom the encoding if the field has an empty value, defined as\nfalse, 0, a nil pointer, a nil interface value, and any empty array,\nslice, map, or string.\n\nAs a special case, if the field tag is \"-\", the field is always omitted.\nNote that a field with name \"-\" can still be generated using the tag \"-,\".\n\nExamples of struct field tags and their meanings:\n\n  // Field appears in JSON as key \"myName\".\n  Field int `json:\"myName\"`\n\n  // Field appears in JSON as key \"myName\" and\n  // the field is omitted from the object if its value is empty,\n  // as defined above.\n  Field int `json:\"myName,omitempty\"`\n\n  // Field appears in JSON as key \"Field\" (the default), but\n  // the field is skipped if empty.\n  // Note the leading comma.\n  Field int `json:\",omitempty\"`\n\n  // Field is ignored by this package.\n  Field int `json:\"-\"`\n\n  // Field appears in JSON as key \"-\".\n  Field int `json:\"-,\"`\n\nThe \"string\" option signals that a field is stored as JSON inside a\nJSON-encoded string. It applies only to fields of string, floating point,\ninteger, or boolean types. This extra level of encoding is sometimes used\nwhen communicating with JavaScript programs:\n\n   Int64String int64 `json:\",string\"`\n\nThe key name will be used if it's a non-empty string consisting of\nonly Unicode letters, digits, and ASCII punctuation except quotation\nmarks, backslash, and comma.\n\nAnonymous struct fields are usually marshaled as if their inner exported fields\nwere fields in the outer struct, subject to the usual Go visibility rules amended\nas described in the next paragraph.\nAn anonymous struct field with a name given in its JSON tag is treated as\nhaving that name, rather than being anonymous.\nAn anonymous struct field of interface type is treated the same as having\nthat type as its name, rather than being anonymous.\n\nThe Go visibility rules for struct fields are amended for JSON when\ndeciding which field to marshal or unmarshal. If there are\nmultiple fields at the same level, and that level is the least\nnested (and would therefore be the nesting level selected by the\nusual Go rules), the following extra rules apply:\n\n1) Of those fields, if any are JSON-tagged, only tagged fields are considered,\neven if there are multiple untagged fields that would otherwise conflict.\n\n2) If there is exactly one field (tagged or not according to the first rule), that is selected.\n\n3) Otherwise there are multiple fields, and all are ignored; no error occurs.\n\nHandling of anonymous struct fields is new in Go 1.1.\nPrior to Go 1.1, anonymous struct fields were ignored. To force ignoring of\nan anonymous struct field in both current and earlier versions, give the field\na JSON tag of \"-\".\n\nMap values encode as JSON objects. The map's key type must either be a\nstring, an integer type, or implement encoding.TextMarshaler. The map keys\nare sorted and used as JSON object keys by applying the following rules,\nsubject to the UTF-8 coercion described for string values above:\n  - string keys are used directly\n  - encoding.TextMarshalers are marshaled\n  - integer keys are converted to strings\n\nPointer values encode as the value pointed to.\nA nil pointer encodes as the null JSON value.\n\nInterface values encode as the value contained in the interface.\nA nil interface value encodes as the null JSON value.\n\nChannel, complex, and function values cannot be encoded in JSON.\nAttempting to encode such a value causes Marshal to return\nan UnsupportedTypeError.\n\nJSON cannot represent cyclic data structures and Marshal does not\nhandle them. Passing cyclic structures to Marshal will result in\nan infinite recursion.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/json.MarshalIndent:
;; (defn MarshalIndent
;;   "MarshalIndent is like Marshal but applies Indent to format the output.\nEach JSON element in the output will begin on a new line beginning with prefix\nfollowed by one or more copies of indent according to the indentation nesting.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/json.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder returns a new decoder that reads from r.\n\nThe decoder introduces its own buffering and may\nread data from r beyond the JSON values requested.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newDecoder(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/json.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newEncoder(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/json.Unmarshal:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the JSON-encoded data and stores the result\nin the value pointed to by v. If v is nil or not a pointer,\nUnmarshal returns an InvalidUnmarshalError.\n\nUnmarshal uses the inverse of the encodings that\nMarshal uses, allocating maps, slices, and pointers as necessary,\nwith the following additional rules:\n\nTo unmarshal JSON into a pointer, Unmarshal first handles the case of\nthe JSON being the JSON literal null. In that case, Unmarshal sets\nthe pointer to nil. Otherwise, Unmarshal unmarshals the JSON into\nthe value pointed at by the pointer. If the pointer is nil, Unmarshal\nallocates a new value for it to point to.\n\nTo unmarshal JSON into a value implementing the Unmarshaler interface,\nUnmarshal calls that value's UnmarshalJSON method, including\nwhen the input is a JSON null.\nOtherwise, if the value implements encoding.TextUnmarshaler\nand the input is a JSON quoted string, Unmarshal calls that value's\nUnmarshalText method with the unquoted form of the string.\n\nTo unmarshal JSON into a struct, Unmarshal matches incoming object\nkeys to the keys used by Marshal (either the struct field name or its tag),\npreferring an exact match but also accepting a case-insensitive match. By\ndefault, object keys which don't have a corresponding struct field are\nignored (see Decoder.DisallowUnknownFields for an alternative).\n\nTo unmarshal JSON into an interface value,\nUnmarshal stores one of these in the interface value:\n\n\tbool, for JSON booleans\n\tfloat64, for JSON numbers\n\tstring, for JSON strings\n\t[]interface{}, for JSON arrays\n\tmap[string]interface{}, for JSON objects\n\tnil for JSON null\n\nTo unmarshal a JSON array into a slice, Unmarshal resets the slice length\nto zero and then appends each element to the slice.\nAs a special case, to unmarshal an empty JSON array into a slice,\nUnmarshal replaces the slice with a new empty slice.\n\nTo unmarshal a JSON array into a Go array, Unmarshal decodes\nJSON array elements into corresponding Go array elements.\nIf the Go array is smaller than the JSON array,\nthe additional JSON array elements are discarded.\nIf the JSON array is smaller than the Go array,\nthe additional Go array elements are set to zero values.\n\nTo unmarshal a JSON object into a map, Unmarshal first establishes a map to\nuse. If the map is nil, Unmarshal allocates a new map. Otherwise Unmarshal\nreuses the existing map, keeping existing entries. Unmarshal then stores\nkey-value pairs from the JSON object into the map. The map's key type must\neither be a string, an integer, or implement encoding.TextUnmarshaler.\n\nIf a JSON value is not appropriate for a given target type,\nor if a JSON number overflows the target type, Unmarshal\nskips that field and completes the unmarshaling as best it can.\nIf no more serious errors are encountered, Unmarshal returns\nan UnmarshalTypeError describing the earliest such error. In any\ncase, it's not guaranteed that all the remaining fields following\nthe problematic one will be unmarshaled into the target object.\n\nThe JSON null value unmarshals into an interface, map, pointer, or slice\nby setting that Go value to nil. Because null is often used in JSON to mean\n``not present,'' unmarshaling a JSON null into any other Go type has no effect\non the value and produces no error.\n\nWhen unmarshaling quoted strings, invalid UTF-8 or\ninvalid UTF-16 surrogate pairs are not treated as an error.\nInstead, they are replaced by the Unicode replacement\ncharacter U+FFFD.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "json.Unmarshal(ConvertToArrayOfByte(_data), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

JOKER FUNC encoding/json.Valid:
(defn ^"Bool" Valid
  "Valid reports whether data is a valid JSON encoding.\n\nGo input arguments: (data []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "json.Valid(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC encoding/pem.Decode:
;; (defn Decode
;;   "Decode will find the next PEM formatted block (certificate, private key\netc) in the input. It returns that block and the remainder of the input. If\nno PEM data is found, p is nil and the whole of the input is returned in\nrest.\n\nGo input arguments: (data []byte)\n\nGo return type: (p *Block, rest []int)\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: [{:Type ^String, :Headers ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/pem/pem.go:29:10), :Bytes ^(vector-of Int)} (vector-of Int)]"
;;   {:added "1.0"
;;    :go "decode(ConvertToArrayOfByte(_data))"}
;;   [^Object _data])

JOKER FUNC encoding/pem.Encode:
;; (defn ^"Error" Encode
;;   "Encode writes the PEM encoding of b to out.\n\nGo input arguments: (out io.Writer, b *encoding/pem.Block)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer out, ^(atom-of encoding/pem.Block) b]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pem.Encode(ABEND904(custom-runtime routine not implemented: io.Writer(_out)), ConvertToIndirectOfencoding/pem.Block(ABEND904(custom-runtime routine not implemented: encoding/pem.Block(_b))))"}
;;   [^io.Writer _out, ^Object _b])

JOKER FUNC encoding/pem.EncodeToMemory:
;; (defn EncodeToMemory
;;   "EncodeToMemory returns the PEM encoding of b.\n\nIf b has invalid headers and cannot be encoded,\nEncodeToMemory returns nil. If it is important to\nreport details about this error case, use Encode instead.\n\nGo input arguments: (b *encoding/pem.Block)\n\nGo return type: []int\n\nJoker input arguments: [^(atom-of encoding/pem.Block) b]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encodeToMemory(ConvertToIndirectOfencoding/pem.Block(ABEND904(custom-runtime routine not implemented: encoding/pem.Block(_b))))"}
;;   [^Object _b])

JOKER FUNC encoding/xml.CopyToken:
;; (defn CopyToken
;;   "CopyToken returns a copy of a Token.\n\nGo input arguments: (t encoding/xml.Token)\n\nGo return type: Token\n\nJoker input arguments: [^encoding/xml.Token t]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/encoding/xml/xml.go:55:12)"
;;   {:added "1.0"
;;    :go "copyToken(ABEND904(custom-runtime routine not implemented: encoding/xml.Token(_t)))"}
;;   [^encoding/xml.Token _t])

JOKER FUNC encoding/xml.Escape:
;; (defn Escape
;;   "Escape is like EscapeText but omits the error return value.\nIt is provided for backwards compatibility with Go 1.0.\nCode targeting Go 1.1 or later should use EscapeText.\n\nGo input arguments: (w io.Writer, s []byte)\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) s]"
;;   {:added "1.0"
;;    :go "escape(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_s))"}
;;   [^io.Writer _w, ^Object _s])

JOKER FUNC encoding/xml.EscapeText:
;; (defn ^"Error" EscapeText
;;   "EscapeText writes to w the properly escaped XML equivalent\nof the plain text data s.\n\nGo input arguments: (w io.Writer, s []byte)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) s]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.EscapeText(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_s))"}
;;   [^io.Writer _w, ^Object _s])

JOKER FUNC encoding/xml.Marshal:
;; (defn Marshal
;;   "Marshal returns the XML encoding of v.\n\nMarshal handles an array or slice by marshaling each of the elements.\nMarshal handles a pointer by marshaling the value it points at or, if the\npointer is nil, by writing nothing. Marshal handles an interface value by\nmarshaling the value it contains or, if the interface value is nil, by\nwriting nothing. Marshal handles all other data by writing one or more XML\nelements containing the data.\n\nThe name for the XML elements is taken from, in order of preference:\n    - the tag on the XMLName field, if the data is a struct\n    - the value of the XMLName field of type Name\n    - the tag of the struct field used to obtain the data\n    - the name of the struct field used to obtain the data\n    - the name of the marshaled type\n\nThe XML element for a struct contains marshaled elements for each of the\nexported fields of the struct, with these exceptions:\n    - the XMLName field, described above, is omitted.\n    - a field with tag \"-\" is omitted.\n    - a field with tag \"name,attr\" becomes an attribute with\n      the given name in the XML element.\n    - a field with tag \",attr\" becomes an attribute with the\n      field name in the XML element.\n    - a field with tag \",chardata\" is written as character data,\n      not as an XML element.\n    - a field with tag \",cdata\" is written as character data\n      wrapped in one or more <![CDATA[ ... ]]> tags, not as an XML element.\n    - a field with tag \",innerxml\" is written verbatim, not subject\n      to the usual marshaling procedure.\n    - a field with tag \",comment\" is written as an XML comment, not\n      subject to the usual marshaling procedure. It must not contain\n      the \"--\" string within it.\n    - a field with a tag including the \"omitempty\" option is omitted\n      if the field value is empty. The empty values are false, 0, any\n      nil pointer or interface value, and any array, slice, map, or\n      string of length zero.\n    - an anonymous struct field is handled as if the fields of its\n      value were part of the outer struct.\n\nIf a field uses a tag \"a>b>c\", then the element c will be nested inside\nparent elements a and b. Fields that appear next to each other that name\nthe same parent will be enclosed in one XML element.\n\nIf the XML name for a struct field is defined by both the field tag and the\nstruct's XMLName field, the names must match.\n\nSee MarshalIndent for an example.\n\nMarshal will return an error if asked to marshal a channel, function, or map.\n\nGo input arguments: (v interface {})\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> v]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshal(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC encoding/xml.MarshalIndent:
;; (defn MarshalIndent
;;   "MarshalIndent works like Marshal, but each XML element begins on a new\nindented line that starts with prefix and is followed by one or more\ncopies of indent according to the nesting depth.\n\nGo input arguments: (v interface {}, prefix string, indent string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^<protocol-or-something> v, ^String prefix, ^String indent]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "marshalIndent(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), _prefix, _indent)"}
;;   [^<protocol-or-something> _v, ^String _prefix, ^String _indent])

JOKER FUNC encoding/xml.NewDecoder:
;; (defn NewDecoder
;;   "NewDecoder creates a new XML parser reading from r.\nIf r does not implement io.ByteReader, NewDecoder will\ndo its own buffering.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/encoding/xml/xml.go:202:16), :DefaultSpace ^String}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newDecoder(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC encoding/xml.NewEncoder:
;; (defn NewEncoder
;;   "NewEncoder returns a new encoder that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Encoder\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newEncoder(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC encoding/xml.NewTokenDecoder:
;; (defn NewTokenDecoder
;;   "NewTokenDecoder creates a new XML parser using an underlying token stream.\n\nGo input arguments: (t encoding/xml.TokenReader)\n\nGo return type: *Decoder\n\nJoker input arguments: [^encoding/xml.TokenReader t]\n\nJoker return type: {:Strict ^Bool, :AutoClose ^(vector-of String), :Entity ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/encoding/xml/xml.go:195:9), :CharsetReader ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/encoding/xml/xml.go:202:16), :DefaultSpace ^String}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTokenDecoder(ABEND904(custom-runtime routine not implemented: encoding/xml.TokenReader(_t))))"}
;;   [^encoding/xml.TokenReader _t])

JOKER FUNC encoding/xml.Unmarshal:
;; (defn ^"Error" Unmarshal
;;   "Unmarshal parses the XML-encoded data and stores the result in\nthe value pointed to by v, which must be an arbitrary struct,\nslice, or string. Well-formed data that does not fit into v is\ndiscarded.\n\nBecause Unmarshal uses the reflect package, it can only assign\nto exported (upper case) fields. Unmarshal uses a case-sensitive\ncomparison to match XML element names to tag values and struct\nfield names.\n\nUnmarshal maps an XML element to a struct using the following rules.\nIn the rules, the tag of a field refers to the value associated with the\nkey 'xml' in the struct field's tag (see the example above).\n\n  * If the struct has a field of type []byte or string with tag\n     \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n     element in that field. The rest of the rules still apply.\n\n  * If the struct has a field named XMLName of type Name,\n     Unmarshal records the element name in that field.\n\n  * If the XMLName field has an associated tag of the form\n     \"name\" or \"namespace-URL name\", the XML element must have\n     the given name (and, optionally, name space) or else Unmarshal\n     returns an error.\n\n  * If the XML element has an attribute whose name matches a\n     struct field name with an associated tag containing \",attr\" or\n     the explicit name in a struct field tag of the form \"name,attr\",\n     Unmarshal records the attribute value in that field.\n\n  * If the XML element has an attribute not handled by the previous\n     rule and the struct has a field with an associated tag containing\n     \",any,attr\", Unmarshal records the attribute value in the first\n     such field.\n\n  * If the XML element contains character data, that data is\n     accumulated in the first struct field that has tag \",chardata\".\n     The struct field may have type []byte or string.\n     If there is no such field, the character data is discarded.\n\n  * If the XML element contains comments, they are accumulated in\n     the first struct field that has tag \",comment\".  The struct\n     field may have type []byte or string. If there is no such\n     field, the comments are discarded.\n\n  * If the XML element contains a sub-element whose name matches\n     the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n     will descend into the XML structure looking for elements with the\n     given names, and will map the innermost elements to that struct\n     field. A tag starting with \">\" is equivalent to one starting\n     with the field name followed by \">\".\n\n  * If the XML element contains a sub-element whose name matches\n     a struct field's XMLName tag and the struct field has no\n     explicit name tag as per the previous rule, unmarshal maps\n     the sub-element to that struct field.\n\n  * If the XML element contains a sub-element whose name matches a\n     field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n     maps the sub-element to that struct field.\n\n  * If the XML element contains a sub-element that hasn't matched any\n     of the above rules and the struct has a field with tag \",any\",\n     unmarshal maps the sub-element to that struct field.\n\n  * An anonymous struct field is handled as if the fields of its\n     value were part of the outer struct.\n\n  * A struct field with tag \"-\" is never unmarshaled into.\n\nUnmarshal maps an XML element to a string or []byte by saving the\nconcatenation of that element's character data in the string or\n[]byte. The saved []byte is never nil.\n\nUnmarshal maps an attribute value to a string or []byte by saving\nthe value in the string or slice.\n\nUnmarshal maps an attribute value to an Attr by saving the attribute,\nincluding its name, in the Attr.\n\nUnmarshal maps an XML element or attribute value to a slice by\nextending the length of the slice and mapping the element or attribute\nto the newly created value.\n\nUnmarshal maps an XML element or attribute value to a bool by\nsetting it to the boolean value represented by the string. Whitespace\nis trimmed and ignored.\n\nUnmarshal maps an XML element or attribute value to an integer or\nfloating-point field by setting the field to the result of\ninterpreting the string value in decimal. There is no check for\noverflow. Whitespace is trimmed and ignored.\n\nUnmarshal maps an XML element to a Name by recording the element\nname.\n\nUnmarshal maps an XML element to a pointer by setting the pointer\nto a freshly allocated value and then mapping the element to that value.\n\nA missing element or empty attribute value will be unmarshaled as a zero value.\nIf the field is a slice, a zero value will be appended to the field. Otherwise, the\nfield will be set to its zero value.\n\nGo input arguments: (data []byte, v interface {})\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) data, ^<protocol-or-something> v]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "xml.Unmarshal(ConvertToArrayOfByte(_data), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _data, ^<protocol-or-something> _v])

JOKER FUNC errors.New:
(defn ^"Error" New
  "New returns an error that formats as the given text.\n\nGo input arguments: (text string)\n\nGo return type: error\n\nJoker input arguments: [^String text]\n\nJoker return type: Error"
  {:added "1.0"
   :go "errors.New(_text)"}
  [^String _text])

JOKER FUNC expvar.Do:
;; (defn Do
;;   "Do calls f for each exported variable.\nThe global variable map is locked during the iteration,\nbut existing entries may be concurrently updated.\n\nGo input arguments: (f func)\n\nJoker input arguments: [^fn f]"
;;   {:added "1.0"
;;    :go "do(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^fn _f])

JOKER FUNC expvar.Get:
;; (defn Get
;;   "Get retrieves a named exported variable. It returns nil if the name has\nnot been registered.\n\nGo input arguments: (name string)\n\nGo return type: Var\n\nJoker input arguments: [^String name]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/expvar/expvar.go:40:10)"
;;   {:added "1.0"
;;    :go "get(_name)"}
;;   [^String _name])

JOKER FUNC expvar.Handler:
;; (defn Handler
;;   "Handler returns the expvar HTTP Handler.\n\nThis is only needed to install the handler in a non-standard location.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "handler()"}
;;   [])

JOKER FUNC expvar.NewFloat:
;; (defn NewFloat
;;   "Go input arguments: (name string)\n\nGo return type: *Float\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFloat(_name))"}
;;   [^String _name])

JOKER FUNC expvar.NewInt:
;; (defn NewInt
;;   "Go input arguments: (name string)\n\nGo return type: *Int\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newInt(_name))"}
;;   [^String _name])

JOKER FUNC expvar.NewMap:
;; (defn NewMap
;;   "Go input arguments: (name string)\n\nGo return type: *Map\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newMap(_name))"}
;;   [^String _name])

JOKER FUNC expvar.NewString:
;; (defn NewString
;;   "Go input arguments: (name string)\n\nGo return type: *String\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newString(_name))"}
;;   [^String _name])

JOKER FUNC expvar.Publish:
;; (defn Publish
;;   "Publish declares a named exported variable. This should be called from a\npackage's init function when it creates its Vars. If the name is already\nregistered then this will log.Panic.\n\nGo input arguments: (name string, v expvar.Var)\n\nJoker input arguments: [^String name, ^expvar.Var v]"
;;   {:added "1.0"
;;    :go "publish(_name, ABEND904(custom-runtime routine not implemented: expvar.Var(_v)))"}
;;   [^String _name, ^expvar.Var _v])

JOKER FUNC flag.Arg:
(defn ^"String" Arg
  "Arg returns the i'th command-line argument. Arg(0) is the first remaining argument\nafter flags have been processed. Arg returns an empty string if the\nrequested element does not exist.\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "flag.Arg(_i)"}
  [^Int _i])

JOKER FUNC flag.Args:
(defn Args
  "Args returns the non-flag command-line arguments.\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "args()"}
  [])

JOKER FUNC flag.Bool:
;; (defn ^"Bool" Bool
;;   "Bool defines a bool flag with specified name, default value, and usage string.\nThe return value is the address of a bool variable that stores the value of the flag.\n\nGo input arguments: (name string, value bool, usage string)\n\nGo return type: *bool\n\nJoker input arguments: [^String name, ^Bool value, ^String usage]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.Bool(_name, _value, _usage))"}
;;   [^String _name, ^Bool _value, ^String _usage])

JOKER FUNC flag.BoolVar:
;; (defn BoolVar
;;   "BoolVar defines a bool flag with specified name, default value, and usage string.\nThe argument p points to a bool variable in which to store the value of the flag.\n\nGo input arguments: (p *bool, name string, value bool, usage string)\n\nJoker input arguments: [^(atom-of Bool) p, ^String name, ^Bool value, ^String usage]"
;;   {:added "1.0"
;;    :go "boolVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfBool(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Bool _value, ^String _usage])

JOKER FUNC flag.Duration:
;; (defn ^"Int" Duration
;;   "Duration defines a time.Duration flag with specified name, default value, and usage string.\nThe return value is the address of a time.Duration variable that stores the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (name string, value time.Duration, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^time.Duration value, ^String usage]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.Duration(_name, ABEND904(custom-runtime routine not implemented: time.Duration(_value)), _usage))"}
;;   [^String _name, ^time.Duration _value, ^String _usage])

JOKER FUNC flag.DurationVar:
;; (defn DurationVar
;;   "DurationVar defines a time.Duration flag with specified name, default value, and usage string.\nThe argument p points to a time.Duration variable in which to store the value of the flag.\nThe flag accepts a value acceptable to time.ParseDuration.\n\nGo input arguments: (p *time.Duration, name string, value time.Duration, usage string)\n\nJoker input arguments: [^(atom-of time.Duration) p, ^String name, ^time.Duration value, ^String usage]"
;;   {:added "1.0"
;;    :go "durationVar(ConvertToIndirectOftime.Duration(ABEND904(custom-runtime routine not implemented: time.Duration(_p))), _name, ABEND904(custom-runtime routine not implemented: time.Duration(_value)), _usage)"}
;;   [^Object _p, ^String _name, ^time.Duration _value, ^String _usage])

JOKER FUNC flag.Float64:
;; (defn Float64
;;   "Float64 defines a float64 flag with specified name, default value, and usage string.\nThe return value is the address of a float64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value float64, usage string)\n\nGo return type: *...\n\nJoker input arguments: [^String name, ^float64 value, ^String usage]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: float64(_name, _value, _usage))"}
;;   [^String _name, ^ABEND044(unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Float64Var:
;; (defn Float64Var
;;   "Float64Var defines a float64 flag with specified name, default value, and usage string.\nThe argument p points to a float64 variable in which to store the value of the flag.\n\nGo input arguments: (p *float64, name string, value float64, usage string)\n\nJoker input arguments: [^(atom-of float64) p, ^String name, ^float64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "float64Var(ConvertToIndirectOfABEND044(unsupported built-in type float64)(_p), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(unsupported built-in type float64) _value, ^String _usage])

JOKER FUNC flag.Int:
;; (defn ^"Int" Int
;;   "Int defines an int flag with specified name, default value, and usage string.\nThe return value is the address of an int variable that stores the value of the flag.\n\nGo input arguments: (name string, value int, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int value, ^String usage]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.Int(_name, _value, _usage))"}
;;   [^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Int64:
;; (defn ^"Int" Int64
;;   "Int64 defines an int64 flag with specified name, default value, and usage string.\nThe return value is the address of an int64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value int64, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^Int64 value, ^String usage]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.Int64(_name, _value, _usage))"}
;;   [^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.Int64Var:
;; (defn Int64Var
;;   "Int64Var defines an int64 flag with specified name, default value, and usage string.\nThe argument p points to an int64 variable in which to store the value of the flag.\n\nGo input arguments: (p *int64, name string, value int64, usage string)\n\nJoker input arguments: [^(atom-of Int64) p, ^String name, ^Int64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "int64Var(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int64 _value, ^String _usage])

JOKER FUNC flag.IntVar:
;; (defn IntVar
;;   "IntVar defines an int flag with specified name, default value, and usage string.\nThe argument p points to an int variable in which to store the value of the flag.\n\nGo input arguments: (p *int, name string, value int, usage string)\n\nJoker input arguments: [^(atom-of Int) p, ^String name, ^Int value, ^String usage]"
;;   {:added "1.0"
;;    :go "intVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^Int _value, ^String _usage])

JOKER FUNC flag.Lookup:
;; (defn Lookup
;;   "Lookup returns the Flag structure of the named command-line flag,\nreturning nil if none exists.\n\nGo input arguments: (name string)\n\nGo return type: *Flag\n\nJoker input arguments: [^String name]\n\nJoker return type: {:Name ^String, :Usage ^String, :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/flag/flag.go:248:12), :DefValue ^String}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: lookup(_name))"}
;;   [^String _name])

JOKER FUNC flag.NArg:
(defn ^"Int" NArg
  "NArg is the number of arguments remaining after flags have been processed.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NArg()"}
  [])

JOKER FUNC flag.NFlag:
(defn ^"Int" NFlag
  "NFlag returns the number of command-line flags that have been set.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "flag.NFlag()"}
  [])

JOKER FUNC flag.NewFlagSet:
;; (defn NewFlagSet
;;   "NewFlagSet returns a new, empty flag set with the specified name and\nerror handling property. If the name is not empty, it will be printed\nin the default usage message and in error messages.\n\nGo input arguments: (name string, errorHandling flag.ErrorHandling)\n\nGo return type: *FlagSet\n\nJoker input arguments: [^String name, ^flag.ErrorHandling errorHandling]\n\nJoker return type: {:Usage ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/flag/flag.go:280:8)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFlagSet(_name, ABEND904(custom-runtime routine not implemented: flag.ErrorHandling(_errorHandling))))"}
;;   [^String _name, ^flag.ErrorHandling _errorHandling])

JOKER FUNC flag.Parse:
;; (defn Parse
;;   "Parse parses the command-line flags from os.Args[1:]. Must be called\nafter all flags are defined and before flags are accessed by the program.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "parse()"}
;;   [])

JOKER FUNC flag.Parsed:
(defn ^"Bool" Parsed
  "Parsed reports whether the command-line flags have been parsed.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "flag.Parsed()"}
  [])

JOKER FUNC flag.PrintDefaults:
;; (defn PrintDefaults
;;   "PrintDefaults prints, to standard error unless configured otherwise,\na usage message showing the default settings of all defined\ncommand-line flags.\nFor an integer valued flag x, the default output has the form\n\t-x int\n\t\tusage-message-for-x (default 7)\nThe usage message will appear on a separate line for anything but\na bool flag with a one-byte name. For bool flags, the type is\nomitted and if the flag name is one byte the usage message appears\non the same line. The parenthetical default is omitted if the\ndefault is the zero value for the type. The listed type, here int,\ncan be changed by placing a back-quoted name in the flag's usage\nstring; the first such item in the message is taken to be a parameter\nname to show in the message and the back quotes are stripped from\nthe message when displayed. For instance, given\n\tflag.String(\"I\", \"\", \"search `directory` for include files\")\nthe output will be\n\t-I directory\n\t\tsearch directory for include files.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "printDefaults()"}
;;   [])

JOKER FUNC flag.Set:
(defn ^"Error" Set
  "Set sets the value of the named command-line flag.\n\nGo input arguments: (name string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "flag.Set(_name, _value)"}
  [^String _name, ^String _value])

JOKER FUNC flag.String:
;; (defn ^"String" String
;;   "String defines a string flag with specified name, default value, and usage string.\nThe return value is the address of a string variable that stores the value of the flag.\n\nGo input arguments: (name string, value string, usage string)\n\nGo return type: *string\n\nJoker input arguments: [^String name, ^String value, ^String usage]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.String(_name, _value, _usage))"}
;;   [^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.StringVar:
;; (defn StringVar
;;   "StringVar defines a string flag with specified name, default value, and usage string.\nThe argument p points to a string variable in which to store the value of the flag.\n\nGo input arguments: (p *string, name string, value string, usage string)\n\nJoker input arguments: [^(atom-of String) p, ^String name, ^String value, ^String usage]"
;;   {:added "1.0"
;;    :go "stringVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfString(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^String _value, ^String _usage])

JOKER FUNC flag.Uint:
;; (defn ^"Int" Uint
;;   "Uint defines a uint flag with specified name, default value, and usage string.\nThe return value is the address of a uint variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint, usage string)\n\nGo return type: *int\n\nJoker input arguments: [^String name, ^UInt value, ^String usage]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: flag.Uint(_name, _value, _usage))"}
;;   [^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.Uint64:
;; (defn Uint64
;;   "Uint64 defines a uint64 flag with specified name, default value, and usage string.\nThe return value is the address of a uint64 variable that stores the value of the flag.\n\nGo input arguments: (name string, value uint64, usage string)\n\nGo return type: *...\n\nJoker input arguments: [^String name, ^uint64 value, ^String usage]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: uint64(_name, _value, _usage))"}
;;   [^String _name, ^ABEND044(unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.Uint64Var:
;; (defn Uint64Var
;;   "Uint64Var defines a uint64 flag with specified name, default value, and usage string.\nThe argument p points to a uint64 variable in which to store the value of the flag.\n\nGo input arguments: (p *uint64, name string, value uint64, usage string)\n\nJoker input arguments: [^(atom-of uint64) p, ^String name, ^uint64 value, ^String usage]"
;;   {:added "1.0"
;;    :go "uint64Var(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_p), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^ABEND044(unsupported built-in type uint64) _value, ^String _usage])

JOKER FUNC flag.UintVar:
;; (defn UintVar
;;   "UintVar defines a uint flag with specified name, default value, and usage string.\nThe argument p points to a uint variable in which to store the value of the flag.\n\nGo input arguments: (p *uint, name string, value uint, usage string)\n\nJoker input arguments: [^(atom-of UInt) p, ^String name, ^UInt value, ^String usage]"
;;   {:added "1.0"
;;    :go "uintVar(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt(_p)), _name, _value, _usage)"}
;;   [^Object _p, ^String _name, ^UInt _value, ^String _usage])

JOKER FUNC flag.UnquoteUsage:
;; (defn UnquoteUsage
;;   "UnquoteUsage extracts a back-quoted name from the usage\nstring for a flag and returns it and the un-quoted usage.\nGiven \"a `name` to show\" it returns (\"name\", \"a name to show\").\nIf there are no back quotes, the name is an educated guess of the\ntype of the flag's value, or the empty string if the flag is boolean.\n\nGo input arguments: (flag *flag.Flag)\n\nGo return type: (name string, usage string)\n\nJoker input arguments: [^(atom-of flag.Flag) flag]\n\nJoker return type: [String String]"
;;   {:added "1.0"
;;    :go "unquoteUsage(ConvertToIndirectOfflag.Flag(ABEND904(custom-runtime routine not implemented: flag.Flag(_flag))))"}
;;   [^Object _flag])

JOKER FUNC flag.Var:
;; (defn Var
;;   "Var defines a flag with the specified name and usage string. The type and\nvalue of the flag are represented by the first argument, of type Value, which\ntypically holds a user-defined implementation of Value. For instance, the\ncaller could create a flag that turns a comma-separated string into a slice\nof strings by giving the slice the methods of Value; in particular, Set would\ndecompose the comma-separated string into the slice.\n\nGo input arguments: (value flag.Value, name string, usage string)\n\nJoker input arguments: [^flag.Value value, ^String name, ^String usage]"
;;   {:added "1.0"
;;    :go "var(ABEND904(custom-runtime routine not implemented: flag.Value(_value)), _name, _usage)"}
;;   [^flag.Value _value, ^String _name, ^String _usage])

JOKER FUNC flag.Visit:
;; (defn Visit
;;   "Visit visits the command-line flags in lexicographical order, calling fn\nfor each. It visits only those flags that have been set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "visit(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^fn _fn])

JOKER FUNC flag.VisitAll:
;; (defn VisitAll
;;   "VisitAll visits the command-line flags in lexicographical order, calling\nfn for each. It visits all flags, even those not set.\n\nGo input arguments: (fn func)\n\nJoker input arguments: [^fn fn]"
;;   {:added "1.0"
;;    :go "visitAll(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^fn _fn])

JOKER FUNC fmt.Errorf:
;; (defn ^"Error" Errorf
;;   "Errorf formats according to a format specifier and returns the string\nas a value that satisfies error.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: error\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fmt.Errorf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprint:
;; (defn Fprint
;;   "Fprint formats using the default formats for its operands and writes to w.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprint(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Writer _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintf:
;; (defn Fprintf
;;   "Fprintf formats according to a format specifier and writes to w.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Writer w, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintf(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Writer _w, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fprintln:
;; (defn Fprintln
;;   "Fprintln formats using the default formats for its operands and writes to w.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (w io.Writer, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Writer w, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fprintln(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Writer _w, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscan:
;; (defn Fscan
;;   "Fscan scans text read from r, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscan(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Reader _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanf:
;; (defn Fscanf
;;   "Fscanf scans text read from r, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (r io.Reader, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Reader r, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanf(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), _format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Reader _r, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Fscanln:
;; (defn Fscanln
;;   "Fscanln is similar to Fscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (r io.Reader, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Reader r, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "fscanln(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^io.Reader _r, ^<protocol-or-something> _a])

JOKER FUNC fmt.Print:
;; (defn Print
;;   "Print formats using the default formats for its operands and writes to standard output.\nSpaces are added between operands when neither is a string.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "print(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Printf:
;; (defn Printf
;;   "Printf formats according to a format specifier and writes to standard output.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "printf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Println:
;; (defn Println
;;   "Println formats using the default formats for its operands and writes to standard output.\nSpaces are always added between operands and a newline is appended.\nIt returns the number of bytes written and any write error encountered.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "println(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scan:
;; (defn Scan
;;   "Scan scans text read from standard input, storing successive\nspace-separated values into successive arguments. Newlines count\nas space. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scan(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Scanf:
;; (defn Scanf
;;   "Scanf scans text read from standard input, storing successive\nspace-separated values into successive arguments as determined by\nthe format. It returns the number of items successfully scanned.\nIf that is less than the number of arguments, err will report why.\nNewlines in the input must match newlines in the format.\nThe one exception: the verb %c always scans the next rune in the\ninput, even if it is a space (or tab etc.) or newline.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Scanln:
;; (defn Scanln
;;   "Scanln is similar to Scan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "scanln(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprint:
;; (defn ^"String" Sprint
;;   "Sprint formats using the default formats for its operands and returns the resulting string.\nSpaces are added between operands when neither is a string.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprint(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintf:
;; (defn ^"String" Sprintf
;;   "Sprintf formats according to a format specifier and returns the resulting string.\n\nGo input arguments: (format string, a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sprintln:
;; (defn ^"String" Sprintln
;;   "Sprintln formats using the default formats for its operands and returns the resulting string.\nSpaces are always added between operands and a newline is appended.\n\nGo input arguments: (a ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "fmt.Sprintln(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _a])

JOKER FUNC fmt.Sscan:
;; (defn Sscan
;;   "Sscan scans the argument string, storing successive space-separated\nvalues into successive arguments. Newlines count as space. It\nreturns the number of items successfully scanned. If that is less\nthan the number of arguments, err will report why.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscan(_str, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanf:
;; (defn Sscanf
;;   "Sscanf scans the argument string, storing successive space-separated\nvalues into successive arguments as determined by the format. It\nreturns the number of items successfully parsed.\nNewlines in the input must match newlines in the format.\n\nGo input arguments: (str string, format string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^String format, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanf(_str, _format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^String _format, ^<protocol-or-something> _a])

JOKER FUNC fmt.Sscanln:
;; (defn Sscanln
;;   "Sscanln is similar to Sscan, but stops scanning at a newline and\nafter the final item there must be a newline or EOF.\n\nGo input arguments: (str string, a ...interface {})\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String str, ^(ellipsis-somehow <protocol-or-something>) a]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sscanln(_str, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _str, ^<protocol-or-something> _a])

JOKER FUNC go/ast.FileExports:
;; (defn ^"Bool" FileExports
;;   "FileExports trims the AST for a Go source file in place such that\nonly exported nodes remain: all top-level identifiers which are not exported\nand their associated information (such as type, initial value, or function\nbody) are removed. Non-exported fields and methods of exported types are\nstripped. The File.Comments list is not changed.\n\nFileExports reports whether there are exported declarations.\n\nGo input arguments: (src *go/ast.File)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go/ast.File) src]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FileExports(ConvertToIndirectOfgo/ast.File(ABEND904(custom-runtime routine not implemented: go/ast.File(_src))))"}
;;   [^Object _src])

JOKER FUNC go/ast.FilterDecl:
;; (defn ^"Bool" FilterDecl
;;   "FilterDecl trims the AST for a Go declaration in place by removing\nall names (including struct field and interface method names, but\nnot from parameter lists) that don't pass through the filter f.\n\nFilterDecl reports whether there are any declared names left after\nfiltering.\n\nGo input arguments: (decl go/ast.Decl, f go/ast.Filter)\n\nGo return type: bool\n\nJoker input arguments: [^go/ast.Decl decl, ^go/ast.Filter f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterDecl(ABEND904(custom-runtime routine not implemented: go/ast.Decl(_decl)), ABEND904(custom-runtime routine not implemented: go/ast.Filter(_f)))"}
;;   [^go/ast.Decl _decl, ^go/ast.Filter _f])

JOKER FUNC go/ast.FilterFile:
;; (defn ^"Bool" FilterFile
;;   "FilterFile trims the AST for a Go file in place by removing all\nnames from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. Import declarations are\nalways removed. The File.Comments list is not changed.\n\nFilterFile reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (src *go/ast.File, f go/ast.Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go/ast.File) src, ^go/ast.Filter f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterFile(ConvertToIndirectOfgo/ast.File(ABEND904(custom-runtime routine not implemented: go/ast.File(_src))), ABEND904(custom-runtime routine not implemented: go/ast.Filter(_f)))"}
;;   [^Object _src, ^go/ast.Filter _f])

JOKER FUNC go/ast.FilterPackage:
;; (defn ^"Bool" FilterPackage
;;   "FilterPackage trims the AST for a Go package in place by removing\nall names from top-level declarations (including struct field and\ninterface method names, but not from parameter lists) that don't\npass through the filter f. If the declaration is empty afterwards,\nthe declaration is removed from the AST. The pkg.Files list is not\nchanged, so that file names and top-level package comments don't get\nlost.\n\nFilterPackage reports whether there are any top-level declarations\nleft after filtering.\n\nGo input arguments: (pkg *go/ast.Package, f go/ast.Filter)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go/ast.Package) pkg, ^go/ast.Filter f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.FilterPackage(ConvertToIndirectOfgo/ast.Package(ABEND904(custom-runtime routine not implemented: go/ast.Package(_pkg))), ABEND904(custom-runtime routine not implemented: go/ast.Filter(_f)))"}
;;   [^Object _pkg, ^go/ast.Filter _f])

JOKER FUNC go/ast.Fprint:
;; (defn ^"Error" Fprint
;;   "Fprint prints the (sub-)tree starting at AST node x to w.\nIf fset != nil, position information is interpreted relative\nto that file set. Otherwise positions are printed as integer\nvalues (file set specific offsets).\n\nA non-nil FieldFilter f may be provided to control the output:\nstruct fields for which f(fieldname, fieldvalue) is true are\nprinted; all others are filtered from the output. Unexported\nstruct fields are never printed.\n\nGo input arguments: (w io.Writer, fset *go/token.FileSet, x interface {}, f go/ast.FieldFilter)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^(atom-of go/token.FileSet) fset, ^<protocol-or-something> x, ^go/ast.FieldFilter f]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Fprint(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND904(custom-runtime routine not implemented: go/ast.FieldFilter(_f)))"}
;;   [^io.Writer _w, ^Object _fset, ^<protocol-or-something> _x, ^go/ast.FieldFilter _f])

JOKER FUNC go/ast.Inspect:
;; (defn Inspect
;;   "Inspect traverses an AST in depth-first order: It starts by calling\nf(node); node must not be nil. If f returns true, Inspect invokes f\nrecursively for each of the non-nil children of node, followed by a\ncall of f(nil).\n\nGo input arguments: (node go/ast.Node, f func)\n\nJoker input arguments: [^go/ast.Node node, ^fn f]"
;;   {:added "1.0"
;;    :go "inspect(ABEND904(custom-runtime routine not implemented: go/ast.Node(_node)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^go/ast.Node _node, ^fn _f])

JOKER FUNC go/ast.IsExported:
(defn ^"Bool" IsExported
  "IsExported reports whether name is an exported Go symbol\n(that is, whether it begins with an upper-case letter).\n\nGo input arguments: (name string)\n\nGo return type: bool\n\nJoker input arguments: [^String name]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "ast.IsExported(_name)"}
  [^String _name])

JOKER FUNC go/ast.MergePackageFiles:
;; (defn MergePackageFiles
;;   "MergePackageFiles creates a file AST by merging the ASTs of the\nfiles belonging to a package. The mode flags control merging behavior.\n\nGo input arguments: (pkg *go/ast.Package, mode go/ast.MergeMode)\n\nGo return type: *File\n\nJoker input arguments: [^(atom-of go/ast.Package) pkg, ^go/ast.MergeMode mode]\n\nJoker return type: {:Doc ^{:List ^(vector-of {:Slash ^Int, :Text ^String})}, :Package ^Int, :Name ^{:NamePos ^Int, :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}, :Decls ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/ast.go:53:11)), :Scope ^{:Outer ^ABEND947(recursive type reference involving go/ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}, :Imports ^(vector-of {:Doc ^{:List ^(vector-of {:Slash ^Int, :Text ^String})}, :Name ^{:NamePos ^Int, :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}, :Path ^{:ValuePos ^Int, :Kind ^Int, :Value ^String}, :Comment ^{:List ^(vector-of {:Slash ^Int, :Text ^String})}, :EndPos ^Int}), :Unresolved ^(vector-of {:NamePos ^Int, :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}), :Comments ^(vector-of {:List ^(vector-of {:Slash ^Int, :Text ^String})})}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: mergePackageFiles(ConvertToIndirectOfgo/ast.Package(ABEND904(custom-runtime routine not implemented: go/ast.Package(_pkg))), ABEND904(custom-runtime routine not implemented: go/ast.MergeMode(_mode))))"}
;;   [^Object _pkg, ^go/ast.MergeMode _mode])

JOKER FUNC go/ast.NewCommentMap:
;; (defn NewCommentMap
;;   "NewCommentMap creates a new comment map by associating comment groups\nof the comments list with the nodes of the AST specified by node.\n\nA comment group g is associated with a node n if:\n\n  - g starts on the same line as n ends\n  - g starts on the line immediately following n, and there is\n    at least one empty line after g and before the next node\n  - g starts before n and is not associated to the node before n\n    via the previous rules\n\nNewCommentMap tries to associate a comment group to the \"largest\"\nnode possible: For instance, if the comment is a line comment\ntrailing an assignment, the comment is associated with the entire\nassignment rather than just the last operand in the assignment.\n\nGo input arguments: (fset *go/token.FileSet, node go/ast.Node, comments []*go/ast.CommentGroup)\n\nGo return type: CommentMap\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^go/ast.Node node, ^(vector-of (atom-of go/ast.CommentGroup)) comments]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/commentmap.go:35:17)"
;;   {:added "1.0"
;;    :go "newCommentMap(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND904(custom-runtime routine not implemented: go/ast.Node(_node)), ConvertToArrayOfObject(ConvertToIndirectOfgo/ast.CommentGroup(ABEND904(custom-runtime routine not implemented: go/ast.CommentGroup(_comments)))))"}
;;   [^Object _fset, ^go/ast.Node _node, ^Object _comments])

JOKER FUNC go/ast.NewIdent:
;; (defn NewIdent
;;   "NewIdent creates a new Ident without position.\nUseful for ASTs generated by code other than the Go parser.\n\nGo input arguments: (name string)\n\nGo return type: *Ident\n\nJoker input arguments: [^String name]\n\nJoker return type: {:NamePos ^Int, :Name ^String, :Obj ^{:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newIdent(_name))"}
;;   [^String _name])

JOKER FUNC go/ast.NewObj:
;; (defn NewObj
;;   "NewObj creates a new object of a given kind and name.\n\nGo input arguments: (kind go/ast.ObjKind, name string)\n\nGo return type: *Object\n\nJoker input arguments: [^go/ast.ObjKind kind, ^String name]\n\nJoker return type: {:Kind ^Int, :Name ^String, :Decl ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:79:7), :Data ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:80:7), :Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/scope.go:81:7)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newObj(ABEND904(custom-runtime routine not implemented: go/ast.ObjKind(_kind)), _name))"}
;;   [^go/ast.ObjKind _kind, ^String _name])

JOKER FUNC go/ast.NewPackage:
;; (defn NewPackage
;;   "NewPackage creates a new Package node from a set of File nodes. It resolves\nunresolved identifiers across files and updates each file's Unresolved list\naccordingly. If a non-nil importer and universe scope are provided, they are\nused to resolve identifiers not declared in any of the package files. Any\nremaining unresolved identifiers are reported as undeclared. If the files\nbelong to different packages, one package name is selected and files with\ndifferent package names are reported and then ignored.\nThe result is a package node and a scanner.ErrorList if there were errors.\n\nGo input arguments: (fset *go/token.FileSet, files map[], importer go/ast.Importer, universe *go/ast.Scope)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^{} files, ^go/ast.Importer importer, ^(atom-of go/ast.Scope) universe]\n\nJoker return type: [{:Name ^String, :Scope ^{:Outer ^ABEND947(recursive type reference involving go/ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}, :Imports ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/ast.go:1011:10), :Files ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/ast.go:1012:10)} Error]"
;;   {:added "1.0"
;;    :go "newPackage(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()), ABEND904(custom-runtime routine not implemented: go/ast.Importer(_importer)), ConvertToIndirectOfgo/ast.Scope(ABEND904(custom-runtime routine not implemented: go/ast.Scope(_universe))))"}
;;   [^Object _fset, ^{} _files, ^go/ast.Importer _importer, ^Object _universe])

JOKER FUNC go/ast.NewScope:
;; (defn NewScope
;;   "NewScope creates a new scope nested in the outer scope.\n\nGo input arguments: (outer *go/ast.Scope)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go/ast.Scope) outer]\n\nJoker return type: {:Outer ^ABEND947(recursive type reference involving go/ast.Scope), :Objects ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/ast/scope.go:21:10)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newScope(ConvertToIndirectOfgo/ast.Scope(ABEND904(custom-runtime routine not implemented: go/ast.Scope(_outer)))))"}
;;   [^Object _outer])

JOKER FUNC go/ast.NotNilFilter:
;; (defn ^"Bool" NotNilFilter
;;   "NotNilFilter returns true for field values that are not nil;\nit returns false otherwise.\n\nGo input arguments: (_ string, v reflect.Value)\n\nGo return type: bool\n\nJoker input arguments: [^String _, ^reflect.Value v]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.NotNilFilter(__, ABEND904(custom-runtime routine not implemented: reflect.Value(_v)))"}
;;   [^String __, ^reflect.Value _v])

JOKER FUNC go/ast.PackageExports:
;; (defn ^"Bool" PackageExports
;;   "PackageExports trims the AST for a Go package in place such that\nonly exported nodes remain. The pkg.Files list is not changed, so that\nfile names and top-level package comments don't get lost.\n\nPackageExports reports whether there are exported declarations;\nit returns false otherwise.\n\nGo input arguments: (pkg *go/ast.Package)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go/ast.Package) pkg]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "ast.PackageExports(ConvertToIndirectOfgo/ast.Package(ABEND904(custom-runtime routine not implemented: go/ast.Package(_pkg))))"}
;;   [^Object _pkg])

JOKER FUNC go/ast.Print:
;; (defn ^"Error" Print
;;   "Print prints x to standard output, skipping nil fields.\nPrint(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n\nGo input arguments: (fset *go/token.FileSet, x interface {})\n\nGo return type: error\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^<protocol-or-something> x]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ast.Print(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^Object _fset, ^<protocol-or-something> _x])

JOKER FUNC go/ast.SortImports:
;; (defn SortImports
;;   "SortImports sorts runs of consecutive import lines in import blocks in f.\nIt also removes duplicate imports when it is possible to do so without data loss.\n\nGo input arguments: (fset *go/token.FileSet, f *go/ast.File)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^(atom-of go/ast.File) f]"
;;   {:added "1.0"
;;    :go "sortImports(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ConvertToIndirectOfgo/ast.File(ABEND904(custom-runtime routine not implemented: go/ast.File(_f))))"}
;;   [^Object _fset, ^Object _f])

JOKER FUNC go/ast.Walk:
;; (defn Walk
;;   "Walk traverses an AST in depth-first order: It starts by calling\nv.Visit(node); node must not be nil. If the visitor w returned by\nv.Visit(node) is not nil, Walk is invoked recursively with visitor\nw for each of the non-nil children of node, followed by a call of\nw.Visit(nil).\n\nGo input arguments: (v go/ast.Visitor, node go/ast.Node)\n\nJoker input arguments: [^go/ast.Visitor v, ^go/ast.Node node]"
;;   {:added "1.0"
;;    :go "walk(ABEND904(custom-runtime routine not implemented: go/ast.Visitor(_v)), ABEND904(custom-runtime routine not implemented: go/ast.Node(_node)))"}
;;   [^go/ast.Visitor _v, ^go/ast.Node _node])

JOKER FUNC go/build.ArchChar:
(defn ArchChar
  "ArchChar returns \"?\" and an error.\nIn earlier versions of Go, the returned string was used to derive\nthe compiler and linker tool names, the default object file suffix,\nand the default linker output name. As of Go 1.5, those strings\nno longer vary by architecture; they are compile, link, .o, and a.out, respectively.\n\nGo input arguments: (goarch string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String goarch]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "archChar(_goarch)"}
  [^String _goarch])

JOKER FUNC go/build.Import:
;; (defn Import
;;   "Import is shorthand for Default.Import.\n\nGo input arguments: (path string, srcDir string, mode go/build.ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String path, ^String srcDir, ^go/build.ImportMode mode]\n\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "import(_path, _srcDir, ABEND904(custom-runtime routine not implemented: go/build.ImportMode(_mode)))"}
;;   [^String _path, ^String _srcDir, ^go/build.ImportMode _mode])

JOKER FUNC go/build.ImportDir:
;; (defn ImportDir
;;   "ImportDir is shorthand for Default.ImportDir.\n\nGo input arguments: (dir string, mode go/build.ImportMode)\n\nGo return type: (*Package, error)\n\nJoker input arguments: [^String dir, ^go/build.ImportMode mode]\n\nJoker return type: [{:Dir ^String, :Name ^String, :ImportComment ^String, :Doc ^String, :ImportPath ^String, :Root ^String, :SrcRoot ^String, :PkgRoot ^String, :PkgTargetRoot ^String, :BinDir ^String, :Goroot ^Bool, :PkgObj ^String, :AllTags ^(vector-of String), :ConflictDir ^String, :BinaryOnly ^Bool, :GoFiles ^(vector-of String), :CgoFiles ^(vector-of String), :IgnoredGoFiles ^(vector-of String), :InvalidGoFiles ^(vector-of String), :CFiles ^(vector-of String), :CXXFiles ^(vector-of String), :MFiles ^(vector-of String), :HFiles ^(vector-of String), :FFiles ^(vector-of String), :SFiles ^(vector-of String), :SwigFiles ^(vector-of String), :SwigCXXFiles ^(vector-of String), :SysoFiles ^(vector-of String), :CgoCFLAGS ^(vector-of String), :CgoCPPFLAGS ^(vector-of String), :CgoCXXFLAGS ^(vector-of String), :CgoFFLAGS ^(vector-of String), :CgoLDFLAGS ^(vector-of String), :CgoPkgConfig ^(vector-of String), :Imports ^(vector-of String), :ImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:424:12), :TestGoFiles ^(vector-of String), :TestImports ^(vector-of String), :TestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:429:17), :XTestGoFiles ^(vector-of String), :XTestImports ^(vector-of String), :XTestImportPos ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/build/build.go:432:17)} Error]"
;;   {:added "1.0"
;;    :go "importDir(_dir, ABEND904(custom-runtime routine not implemented: go/build.ImportMode(_mode)))"}
;;   [^String _dir, ^go/build.ImportMode _mode])

JOKER FUNC go/build.IsLocalImport:
(defn ^"Bool" IsLocalImport
  "IsLocalImport reports whether the import path is\na local import path, like \".\", \"..\", \"./foo\", or \"../foo\".\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "build.IsLocalImport(_path)"}
  [^String _path])

JOKER FUNC go/constant.BinaryOp:
;; (defn BinaryOp
;;   "BinaryOp returns the result of the binary expression x op y.\nThe operation must be defined for the operands. If one of the\noperands is Unknown, the result is Unknown.\nBinaryOp doesn't handle comparisons or shifts; use Compare\nor Shift instead.\n\nTo force integer division of Int operands, use op == token.QUO_ASSIGN\ninstead of token.QUO; the result is guaranteed to be Int in this case.\nDivision by zero leads to a run-time panic.\n\nGo input arguments: (x_ go/constant.Value, op go/token.Token, y_ go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x_, ^go/token.Token op, ^go/constant.Value y_]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "binaryOp(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x_)), ABEND904(custom-runtime routine not implemented: go/token.Token(_op)), ABEND904(custom-runtime routine not implemented: go/constant.Value(_y_)))"}
;;   [^go/constant.Value _x_, ^go/token.Token _op, ^go/constant.Value _y_])

JOKER FUNC go/constant.BitLen:
;; (defn ^"Int" BitLen
;;   "BitLen returns the number of bits required to represent\nthe absolute value x in binary representation; x must be an Int or an Unknown.\nIf x is Unknown, the result is 0.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: int\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "constant.BitLen(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.BoolVal:
;; (defn ^"Bool" BoolVal
;;   "BoolVal returns the Go boolean value of x, which must be a Bool or an Unknown.\nIf x is Unknown, the result is false.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: bool\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "constant.BoolVal(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Bytes:
;; (defn Bytes
;;   "Bytes returns the bytes for the absolute value of x in little-\nendian binary representation; x must be an Int.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: []int\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "bytes(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Compare:
;; (defn ^"Bool" Compare
;;   "Compare returns the result of the comparison x op y.\nThe comparison must be defined for the operands.\nIf one of the operands is Unknown, the result is\nfalse.\n\nGo input arguments: (x_ go/constant.Value, op go/token.Token, y_ go/constant.Value)\n\nGo return type: bool\n\nJoker input arguments: [^go/constant.Value x_, ^go/token.Token op, ^go/constant.Value y_]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "constant.Compare(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x_)), ABEND904(custom-runtime routine not implemented: go/token.Token(_op)), ABEND904(custom-runtime routine not implemented: go/constant.Value(_y_)))"}
;;   [^go/constant.Value _x_, ^go/token.Token _op, ^go/constant.Value _y_])

JOKER FUNC go/constant.Denom:
;; (defn Denom
;;   "Denom returns the denominator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int >= 1.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "denom(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Float32Val:
;; (defn Float32Val
;;   "Float32Val is like Float64Val but for float32 instead of float64.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: [ABEND043(unsupported built-in type float32) Bool]"
;;   {:added "1.0"
;;    :go "float32Val(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Float64Val:
;; (defn Float64Val
;;   "Float64Val returns the nearest Go float64 value of x and whether the result is exact;\nx must be numeric or an Unknown, but not Complex. For values too small (too close to 0)\nto represent as float64, Float64Val silently underflows to 0. The result sign always\nmatches the sign of x, even for 0.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Bool]"
;;   {:added "1.0"
;;    :go "float64Val(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Imag:
;; (defn Imag
;;   "Imag returns the imaginary part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "imag(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Int64Val:
;; (defn Int64Val
;;   "Int64Val returns the Go int64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: (int, bool)\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "int64Val(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.MakeBool:
;; (defn MakeBool
;;   "MakeBool returns the Bool value for b.\n\nGo input arguments: (b bool)\n\nGo return type: Value\n\nJoker input arguments: [^Bool b]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeBool(_b)"}
;;   [^Bool _b])

JOKER FUNC go/constant.MakeFloat64:
;; (defn MakeFloat64
;;   "MakeFloat64 returns the Float value for x.\nIf x is not finite, the result is an Unknown.\n\nGo input arguments: (x float64)\n\nGo return type: Value\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFloat64(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC go/constant.MakeFromBytes:
;; (defn MakeFromBytes
;;   "MakeFromBytes returns the Int value given the bytes of its little-endian\nbinary representation. An empty byte slice argument represents 0.\n\nGo input arguments: (bytes []byte)\n\nGo return type: Value\n\nJoker input arguments: [^(vector-of Byte) bytes]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromBytes(ConvertToArrayOfByte(_bytes))"}
;;   [^Object _bytes])

JOKER FUNC go/constant.MakeFromLiteral:
;; (defn MakeFromLiteral
;;   "MakeFromLiteral returns the corresponding integer, floating-point,\nimaginary, character, or string value for a Go literal string. The\ntok value must be one of token.INT, token.FLOAT, token.IMAG,\ntoken.CHAR, or token.STRING. The final argument must be zero.\nIf the literal string syntax is invalid, the result is an Unknown.\n\nGo input arguments: (lit string, tok go/token.Token, zero uint)\n\nGo return type: Value\n\nJoker input arguments: [^String lit, ^go/token.Token tok, ^UInt zero]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeFromLiteral(_lit, ABEND904(custom-runtime routine not implemented: go/token.Token(_tok)), _zero)"}
;;   [^String _lit, ^go/token.Token _tok, ^UInt _zero])

JOKER FUNC go/constant.MakeImag:
;; (defn MakeImag
;;   "MakeImag returns the Complex value x*i;\nx must be Int, Float, or Unknown.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeImag(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.MakeInt64:
;; (defn MakeInt64
;;   "MakeInt64 returns the Int value for x.\n\nGo input arguments: (x int64)\n\nGo return type: Value\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeInt64(_x)"}
;;   [^Int64 _x])

JOKER FUNC go/constant.MakeString:
;; (defn MakeString
;;   "MakeString returns the String value for s.\n\nGo input arguments: (s string)\n\nGo return type: Value\n\nJoker input arguments: [^String s]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeString(_s)"}
;;   [^String _s])

JOKER FUNC go/constant.MakeUint64:
;; (defn MakeUint64
;;   "MakeUint64 returns the Int value for x.\n\nGo input arguments: (x uint64)\n\nGo return type: Value\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUint64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC go/constant.MakeUnknown:
;; (defn MakeUnknown
;;   "MakeUnknown returns the Unknown value.\n\nGo return type: Value\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "makeUnknown()"}
;;   [])

JOKER FUNC go/constant.Num:
;; (defn Num
;;   "Num returns the numerator of x; x must be Int, Float, or Unknown.\nIf x is Unknown, or if it is too large or small to represent as a\nfraction, the result is Unknown. Otherwise the result is an Int\nwith the same sign as x.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "num(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Real:
;; (defn Real
;;   "Real returns the real part of x, which must be a numeric or unknown value.\nIf x is Unknown, the result is Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "real(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Shift:
;; (defn Shift
;;   "Shift returns the result of the shift expression x op s\nwith op == token.SHL or token.SHR (<< or >>). x must be\nan Int or an Unknown. If x is Unknown, the result is x.\n\nGo input arguments: (x go/constant.Value, op go/token.Token, s uint)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x, ^go/token.Token op, ^UInt s]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "shift(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)), ABEND904(custom-runtime routine not implemented: go/token.Token(_op)), _s)"}
;;   [^go/constant.Value _x, ^go/token.Token _op, ^UInt _s])

JOKER FUNC go/constant.Sign:
;; (defn ^"Int" Sign
;;   "Sign returns -1, 0, or 1 depending on whether x < 0, x == 0, or x > 0;\nx must be numeric or Unknown. For complex values x, the sign is 0 if x == 0,\notherwise it is != 0. If x is Unknown, the result is 1.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: int\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "constant.Sign(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.StringVal:
;; (defn ^"String" StringVal
;;   "StringVal returns the Go string value of x, which must be a String or an Unknown.\nIf x is Unknown, the result is \"\".\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: string\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "constant.StringVal(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.ToComplex:
;; (defn ToComplex
;;   "ToComplex converts x to a Complex value if x is representable as a Complex.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toComplex(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.ToFloat:
;; (defn ToFloat
;;   "ToFloat converts x to a Float value if x is representable as a Float.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toFloat(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.ToInt:
;; (defn ToInt
;;   "ToInt converts x to an Int value if x is representable as an Int.\nOtherwise it returns an Unknown.\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: Value\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "toInt(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.Uint64Val:
;; (defn Uint64Val
;;   "Uint64Val returns the Go uint64 value of x and whether the result is exact;\nx must be an Int or an Unknown. If the result is not exact, its value is undefined.\nIf x is Unknown, the result is (0, false).\n\nGo input arguments: (x go/constant.Value)\n\nGo return type: (..., bool)\n\nJoker input arguments: [^go/constant.Value x]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Bool]"
;;   {:added "1.0"
;;    :go "uint64Val(ABEND904(custom-runtime routine not implemented: go/constant.Value(_x)))"}
;;   [^go/constant.Value _x])

JOKER FUNC go/constant.UnaryOp:
;; (defn UnaryOp
;;   "UnaryOp returns the result of the unary expression op y.\nThe operation must be defined for the operand.\nIf prec > 0 it specifies the ^ (xor) result size in bits.\nIf y is Unknown, the result is Unknown.\n\nGo input arguments: (op go/token.Token, y go/constant.Value, prec uint)\n\nGo return type: Value\n\nJoker input arguments: [^go/token.Token op, ^go/constant.Value y, ^UInt prec]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)"
;;   {:added "1.0"
;;    :go "unaryOp(ABEND904(custom-runtime routine not implemented: go/token.Token(_op)), ABEND904(custom-runtime routine not implemented: go/constant.Value(_y)), _prec)"}
;;   [^go/token.Token _op, ^go/constant.Value _y, ^UInt _prec])

JOKER FUNC go/doc.Examples:
;; (defn Examples
;;   "Examples returns the examples found in the files, sorted by Name field.\nThe Order fields record the order in which the examples were encountered.\n\nPlayable Examples must be in a package whose name ends in \"_test\".\nAn Example is \"playable\" (the Play field is non-nil) in either of these\ncircumstances:\n  - The example function is self-contained: the function references only\n    identifiers from other packages (or predeclared identifiers, such as\n    \"int\") and the test file does not include a dot import.\n  - The entire test file is the example: the file contains exactly one\n    example function, zero test or benchmark functions, and at least one\n    top-level function, type, variable, or constant declaration other\n    than the example function.\n\nGo input arguments: (files ...*go/ast.File)\n\nGo return type: []*Example\n\nJoker input arguments: [^(ellipsis-somehow Object) files]\n\nJoker return type: (vector-of {:Name ^String, :Doc ^String, :Code ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/ast.go:35:11), :Play ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :Package ^Int, :Name ^ABEND042(cannot find typename go/doc.Ident), :Decls ^(vector-of ABEND042(cannot find typename go/doc.Decl)), :Scope ^ABEND042(cannot find typename go/doc.Scope), :Imports ^(vector-of ABEND042(cannot find typename go/doc.ImportSpec)), :Unresolved ^(vector-of ABEND042(cannot find typename go/doc.Ident)), :Comments ^(vector-of ABEND042(cannot find typename go/doc.CommentGroup))}, :Comments ^(vector-of {:List ^(vector-of ABEND042(cannot find typename go/doc.Comment))}), :Output ^String, :Unordered ^Bool, :EmptyOutput ^Bool, :Order ^Int})"
;;   {:added "1.0"
;;    :go "examples(ConvertToEllipsisHaHaObject(ConvertToIndirectOfgo/ast.File(ABEND904(custom-runtime routine not implemented: go/ast.File(_files)))))"}
;;   [^Object _files])

JOKER FUNC go/doc.IsPredeclared:
(defn ^"Bool" IsPredeclared
  "IsPredeclared reports whether s is a predeclared identifier.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "doc.IsPredeclared(_s)"}
  [^String _s])

JOKER FUNC go/doc.New:
;; (defn New
;;   "New computes the package documentation for the given package AST.\nNew takes ownership of the AST pkg and may edit or overwrite it.\n\nGo input arguments: (pkg *go/ast.Package, importPath string, mode go/doc.Mode)\n\nGo return type: *Package\n\nJoker input arguments: [^(atom-of go/ast.Package) pkg, ^String importPath, ^go/doc.Mode mode]\n\nJoker return type: {:Doc ^String, :Name ^String, :ImportPath ^String, :Imports ^(vector-of String), :Filenames ^(vector-of String), :Notes ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/doc/doc.go:20:13), :Bugs ^(vector-of String), :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :TokPos ^Int, :Tok ^Int, :Lparen ^Int, :Specs ^(vector-of ABEND042(cannot find typename go/doc.Spec)), :Rparen ^Int}}), :Types ^(vector-of {:Doc ^String, :Name ^String, :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :TokPos ^Int, :Tok ^Int, :Lparen ^Int, :Specs ^(vector-of ABEND042(cannot find typename go/doc.Spec)), :Rparen ^Int}, :Consts ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :TokPos ^Int, :Tok ^Int, :Lparen ^Int, :Specs ^(vector-of ABEND042(cannot find typename go/doc.Spec)), :Rparen ^Int}}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :TokPos ^Int, :Tok ^Int, :Lparen ^Int, :Specs ^(vector-of ABEND042(cannot find typename go/doc.Spec)), :Rparen ^Int}}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :Recv ^ABEND042(cannot find typename go/doc.FieldList), :Name ^ABEND042(cannot find typename go/doc.Ident), :Type ^ABEND042(cannot find typename go/doc.FuncType), :Body ^ABEND042(cannot find typename go/doc.BlockStmt)}, :Recv ^String, :Orig ^String, :Level ^Int}), :Methods ^(vector-of {:Doc ^String, :Name ^String, :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :Recv ^ABEND042(cannot find typename go/doc.FieldList), :Name ^ABEND042(cannot find typename go/doc.Ident), :Type ^ABEND042(cannot find typename go/doc.FuncType), :Body ^ABEND042(cannot find typename go/doc.BlockStmt)}, :Recv ^String, :Orig ^String, :Level ^Int})}), :Vars ^(vector-of {:Doc ^String, :Names ^(vector-of String), :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :TokPos ^Int, :Tok ^Int, :Lparen ^Int, :Specs ^(vector-of ABEND042(cannot find typename go/doc.Spec)), :Rparen ^Int}}), :Funcs ^(vector-of {:Doc ^String, :Name ^String, :Decl ^{:Doc ^ABEND042(cannot find typename go/doc.CommentGroup), :Recv ^ABEND042(cannot find typename go/doc.FieldList), :Name ^ABEND042(cannot find typename go/doc.Ident), :Type ^ABEND042(cannot find typename go/doc.FuncType), :Body ^ABEND042(cannot find typename go/doc.BlockStmt)}, :Recv ^String, :Orig ^String, :Level ^Int})}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(ConvertToIndirectOfgo/ast.Package(ABEND904(custom-runtime routine not implemented: go/ast.Package(_pkg))), _importPath, ABEND904(custom-runtime routine not implemented: go/doc.Mode(_mode))))"}
;;   [^Object _pkg, ^String _importPath, ^go/doc.Mode _mode])

JOKER FUNC go/doc.Synopsis:
(defn ^"String" Synopsis
  "Synopsis returns a cleaned version of the first sentence in s.\nThat sentence ends after the first period followed by space and\nnot preceded by exactly one uppercase letter. The result string\nhas no \\n, \\r, or \\t characters and uses only single spaces between\nwords. If s starts with any of the IllegalPrefixes, the result\nis the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "doc.Synopsis(_s)"}
  [^String _s])

JOKER FUNC go/doc.ToHTML:
;; (defn ToHTML
;;   "ToHTML converts comment text to formatted HTML.\nThe comment was prepared by DocReader,\nso it is known not to have leading, trailing blank lines\nnor to have trailing spaces at the end of lines.\nThe comment markers have already been removed.\n\nEach span of unindented non-blank lines is converted into\na single paragraph. There is one exception to the rule: a span that\nconsists of a single line, is followed by another paragraph span,\nbegins with a capital letter, and contains no punctuation\nother than parentheses and commas is formatted as a heading.\n\nA span of indented lines is converted into a <pre> block,\nwith the common indent prefix removed.\n\nURLs in the comment text are converted into links; if the URL also appears\nin the words map, the link is taken from the map (if the corresponding map\nvalue is the empty string, the URL is not converted into a link).\n\nGo identifiers that appear in the words map are italicized; if the corresponding\nmap value is not the empty string, it is considered a URL and the word is converted\ninto a link.\n\nGo input arguments: (w io.Writer, text string, words map[])\n\nJoker input arguments: [^io.Writer w, ^String text, ^{} words]"
;;   {:added "1.0"
;;    :go "toHTML(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _text, ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^io.Writer _w, ^String _text, ^{} _words])

JOKER FUNC go/doc.ToText:
;; (defn ToText
;;   "ToText prepares comment text for presentation in textual output.\nIt wraps paragraphs of text to width or fewer Unicode code points\nand then prefixes each line with the indent. In preformatted sections\n(such as program text), it prefixes each non-blank line with preIndent.\n\nGo input arguments: (w io.Writer, text string, indent string, preIndent string, width int)\n\nJoker input arguments: [^io.Writer w, ^String text, ^String indent, ^String preIndent, ^Int width]"
;;   {:added "1.0"
;;    :go "toText(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _text, _indent, _preIndent, _width)"}
;;   [^io.Writer _w, ^String _text, ^String _indent, ^String _preIndent, ^Int _width])

JOKER FUNC go/format.Node:
;; (defn ^"Error" Node
;;   "Node formats node in canonical gofmt style and writes the result to dst.\n\nThe node type must be *ast.File, *printer.CommentedNode, []ast.Decl,\n[]ast.Stmt, or assignment-compatible to ast.Expr, ast.Decl, ast.Spec,\nor ast.Stmt. Node does not modify node. Imports are not sorted for\nnodes representing partial source files (for instance, if the node is\nnot an *ast.File or a *printer.CommentedNode not wrapping an *ast.File).\n\nThe function may return early (before the entire result is written)\nand return a formatting error, for instance due to an incorrect AST.\n\nGo input arguments: (dst io.Writer, fset *go/token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^io.Writer dst, ^(atom-of go/token.FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "format.Node(ABEND904(custom-runtime routine not implemented: io.Writer(_dst)), ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Writer _dst, ^Object _fset, ^<protocol-or-something> _node])

JOKER FUNC go/format.Source:
(defn Source
  "Source formats src in canonical gofmt style and returns the result\nor an (I/O or syntax) error. src is expected to be a syntactically\ncorrect Go source file, or a list of Go declarations or statements.\n\nIf src is a partial source file, the leading and trailing space of src\nis applied to the result (such that it has the same leading and trailing\nspace as src), and the result is indented by the same amount as the first\nline of src containing code. Imports are not sorted for partial source files.\n\nGo input arguments: (src []byte)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(vector-of Byte) src]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "source(ConvertToArrayOfByte(_src))"}
  [^Object _src])

JOKER FUNC go/importer.Default:
;; (defn Default
;;   "Default returns an Importer for the compiler that built the running binary.\nIf available, the result implements types.ImporterFrom.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/api.go:59:15)"
;;   {:added "1.0"
;;    :go "default()"}
;;   [])

JOKER FUNC go/importer.For:
;; (defn For
;;   "For returns an Importer for importing from installed packages\nfor the compilers \"gc\" and \"gccgo\", or for importing directly\nfrom the source if the compiler argument is \"source\". In this\nlatter case, importing may fail under circumstances where the\nexported API is not entirely defined in pure Go source code\n(if the package API depends on cgo-defined entities, the type\nchecker won't have access to those).\n\nIf lookup is nil, the default package lookup mechanism for the\ngiven compiler is used, and the resulting importer attempts\nto resolve relative and absolute import paths to canonical\nimport path IDs before finding the imported file.\n\nIf lookup is non-nil, then the returned importer calls lookup\neach time it needs to resolve an import path. In this mode\nthe importer can only be invoked with canonical import paths\n(not relative or absolute ones); it is assumed that the translation\nto canonical import paths is being done by the client of the\nimporter.\n\nGo input arguments: (compiler string, lookup go/importer.Lookup)\n\nGo return type: ...\n\nJoker input arguments: [^String compiler, ^go/importer.Lookup lookup]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/api.go:59:15)"
;;   {:added "1.0"
;;    :go "for(_compiler, ABEND904(custom-runtime routine not implemented: go/importer.Lookup(_lookup)))"}
;;   [^String _compiler, ^go/importer.Lookup _lookup])

JOKER FUNC go/parser.ParseDir:
;; (defn ParseDir
;;   "ParseDir calls ParseFile for all files with names ending in \".go\" in the\ndirectory specified by path and returns a map of package name -> package\nAST with all the packages found.\n\nIf filter != nil, only the files with os.FileInfo entries passing through\nthe filter (and ending in \".go\") are considered. The mode bits are passed\nto ParseFile unchanged. Position information is recorded in fset, which\nmust not be nil.\n\nIf the directory couldn't be read, a nil map and the respective error are\nreturned. If a parse error occurred, a non-nil but incomplete map and the\nfirst error encountered are returned.\n\nGo input arguments: (fset *go/token.FileSet, path string, filter func, mode go/parser.Mode)\n\nGo return type: (pkgs ..., first error)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^String path, ^fn filter, ^go/parser.Mode mode]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/go/parser/interface.go:135:97) Error]"
;;   {:added "1.0"
;;    :go "parseDir(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), _path, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ABEND904(custom-runtime routine not implemented: go/parser.Mode(_mode)))"}
;;   [^Object _fset, ^String _path, ^fn _filter, ^go/parser.Mode _mode])

JOKER FUNC go/parser.ParseExpr:
;; (defn ParseExpr
;;   "ParseExpr is a convenience function for obtaining the AST of an expression x.\nThe position information recorded in the AST is undefined. The filename used\nin error messages is the empty string.\n\nGo input arguments: (x string)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String x]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/ast.go:41:11) Error]"
;;   {:added "1.0"
;;    :go "parseExpr(_x)"}
;;   [^String _x])

JOKER FUNC go/parser.ParseExprFrom:
;; (defn ParseExprFrom
;;   "ParseExprFrom is a convenience function for parsing an expression.\nThe arguments have the same meaning as for ParseFile, but the source must\nbe a valid Go (type or value) expression. Specifically, fset must not\nbe nil.\n\nGo input arguments: (fset *go/token.FileSet, filename string, src interface {}, mode go/parser.Mode)\n\nGo return type: (..., error)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go/parser.Mode mode]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/ast/ast.go:41:11) Error]"
;;   {:added "1.0"
;;    :go "parseExprFrom(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), _filename, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND904(custom-runtime routine not implemented: go/parser.Mode(_mode)))"}
;;   [^Object _fset, ^String _filename, ^<protocol-or-something> _src, ^go/parser.Mode _mode])

JOKER FUNC go/parser.ParseFile:
;; (defn ParseFile
;;   "ParseFile parses the source code of a single Go source file and returns\nthe corresponding ast.File node. The source code may be provided via\nthe filename of the source file, or via the src parameter.\n\nIf src != nil, ParseFile parses the source from src and the filename is\nonly used when recording position information. The type of the argument\nfor the src parameter must be string, []byte, or io.Reader.\nIf src == nil, ParseFile parses the file specified by filename.\n\nThe mode parameter controls the amount of source text parsed and other\noptional parser functionality. Position information is recorded in the\nfile set fset, which must not be nil.\n\nIf the source couldn't be read, the returned AST is nil and the error\nindicates the specific failure. If the source was read but syntax\nerrors were found, the result is a partial AST (with ast.Bad* nodes\nrepresenting the fragments of erroneous source code). Multiple errors\nare returned via a scanner.ErrorList which is sorted by file position.\n\nGo input arguments: (fset *go/token.FileSet, filename string, src interface {}, mode go/parser.Mode)\n\nGo return type: (f *struct {Doc *CommentGroup; Package int; Name *Ident; Decls []Decl; Scope *Scope; Imports []*ImportSpec; Unresolved []*Ident; Comments []*CommentGroup}, err error)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^String filename, ^<protocol-or-something> src, ^go/parser.Mode mode]\n\nJoker return type: [{:Doc ^ABEND042(cannot find typename go/parser.CommentGroup), :Package ^Int, :Name ^ABEND042(cannot find typename go/parser.Ident), :Decls ^(vector-of ABEND042(cannot find typename go/parser.Decl)), :Scope ^ABEND042(cannot find typename go/parser.Scope), :Imports ^(vector-of ABEND042(cannot find typename go/parser.ImportSpec)), :Unresolved ^(vector-of ABEND042(cannot find typename go/parser.Ident)), :Comments ^(vector-of ABEND042(cannot find typename go/parser.CommentGroup))} Error]"
;;   {:added "1.0"
;;    :go "parseFile(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), _filename, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND904(custom-runtime routine not implemented: go/parser.Mode(_mode)))"}
;;   [^Object _fset, ^String _filename, ^<protocol-or-something> _src, ^go/parser.Mode _mode])

JOKER FUNC go/printer.Fprint:
;; (defn ^"Error" Fprint
;;   "Fprint \"pretty-prints\" an AST node to output.\nIt calls Config.Fprint with default settings.\nNote that gofmt uses tabs for indentation but spaces for alignment;\nuse format.Node (package go/format) for output that matches gofmt.\n\nGo input arguments: (output io.Writer, fset *go/token.FileSet, node interface {})\n\nGo return type: error\n\nJoker input arguments: [^io.Writer output, ^(atom-of go/token.FileSet) fset, ^<protocol-or-something> node]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "printer.Fprint(ABEND904(custom-runtime routine not implemented: io.Writer(_output)), ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^io.Writer _output, ^Object _fset, ^<protocol-or-something> _node])

JOKER FUNC go/scanner.PrintError:
;; (defn PrintError
;;   "PrintError is a utility function that prints a list of errors to w,\none error per line, if the err parameter is an ErrorList. Otherwise\nit prints the err string.\n\nGo input arguments: (w io.Writer, err error)\n\nJoker input arguments: [^io.Writer w, ^ABEND885(unrecognized type error at: GO.link/src/go/scanner/errors.go:116:34) err]"
;;   {:added "1.0"
;;    :go "printError(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _err)"}
;;   [^io.Writer _w, ^ABEND885(unrecognized type error at: GO.link/src/go/scanner/errors.go:116:34) _err])

JOKER FUNC go/token.Lookup:
(defn ^"Int" Lookup
  "Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n\nGo input arguments: (ident string)\n\nGo return type: Token\n\nJoker input arguments: [^String ident]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(token.Lookup(_ident))"}
  [^String _ident])

JOKER FUNC go/token.NewFileSet:
;; (defn NewFileSet
;;   "NewFileSet creates a new file set.\n\nGo return type: *FileSet\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFileSet())"}
;;   [])

JOKER FUNC go/types.AssertableTo:
;; (defn ^"Bool" AssertableTo
;;   "AssertableTo reports whether a value of type V can be asserted to have type T.\n\nGo input arguments: (V *go/types.Interface, T go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of go/types.Interface) V, ^go/types.Type T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.AssertableTo(ConvertToIndirectOfgo/types.Interface(ABEND904(custom-runtime routine not implemented: go/types.Interface(_V))), ABEND904(custom-runtime routine not implemented: go/types.Type(_T)))"}
;;   [^Object _V, ^go/types.Type _T])

JOKER FUNC go/types.AssignableTo:
;; (defn ^"Bool" AssignableTo
;;   "AssignableTo reports whether a value of type V is assignable to a variable of type T.\n\nGo input arguments: (V go/types.Type, T go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type V, ^go/types.Type T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.AssignableTo(ABEND904(custom-runtime routine not implemented: go/types.Type(_V)), ABEND904(custom-runtime routine not implemented: go/types.Type(_T)))"}
;;   [^go/types.Type _V, ^go/types.Type _T])

JOKER FUNC go/types.Comparable:
;; (defn ^"Bool" Comparable
;;   "Comparable reports whether values of type T are comparable.\n\nGo input arguments: (T go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Comparable(ABEND904(custom-runtime routine not implemented: go/types.Type(_T)))"}
;;   [^go/types.Type _T])

JOKER FUNC go/types.ConvertibleTo:
;; (defn ^"Bool" ConvertibleTo
;;   "ConvertibleTo reports whether a value of type V is convertible to a value of type T.\n\nGo input arguments: (V go/types.Type, T go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type V, ^go/types.Type T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.ConvertibleTo(ABEND904(custom-runtime routine not implemented: go/types.Type(_V)), ABEND904(custom-runtime routine not implemented: go/types.Type(_T)))"}
;;   [^go/types.Type _V, ^go/types.Type _T])

JOKER FUNC go/types.DefPredeclaredTestFuncs:
;; (defn DefPredeclaredTestFuncs
;;   "DefPredeclaredTestFuncs defines the assert and trace built-ins.\nThese built-ins are intended for debugging and testing of this\npackage only.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "defPredeclaredTestFuncs()"}
;;   [])

JOKER FUNC go/types.Default:
;; (defn Default
;;   "Default returns the default \"typed\" type for an \"untyped\" type;\nit returns the incoming type for all other types. The default type\nfor untyped nil is untyped nil.\n\nGo input arguments: (typ go/types.Type)\n\nGo return type: Type\n\nJoker input arguments: [^go/types.Type typ]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/type.go:11:11)"
;;   {:added "1.0"
;;    :go "default(ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)))"}
;;   [^go/types.Type _typ])

JOKER FUNC go/types.Eval:
;; (defn Eval
;;   "Eval returns the type and, if constant, the value for the\nexpression expr, evaluated at position pos of package pkg,\nwhich must have been derived from type-checking an AST with\ncomplete position information relative to the provided file\nset.\n\nIf pkg == nil, the Universe scope is used and the provided\nposition pos is ignored. If pkg != nil, and pos is invalid,\nthe package scope is used. Otherwise, pos must belong to the\npackage.\n\nAn error is returned if pos is not within the package or\nif the node cannot be evaluated.\n\nNote: Eval should not be used instead of running Check to compute\ntypes and values, but in addition to Check. Eval will re-evaluate\nits argument each time, and it also does not know about the context\nin which an expression is used (e.g., an assignment). Thus, top-\nlevel untyped constants will return an untyped type rather then the\nrespective context-specific type.\n\nGo input arguments: (fset *go/token.FileSet, pkg *go/types.Package, pos go/token.Pos, expr string)\n\nGo return type: (_ TypeAndValue, err error)\n\nJoker input arguments: [^(atom-of go/token.FileSet) fset, ^(atom-of go/types.Package) pkg, ^go/token.Pos pos, ^String expr]\n\nJoker return type: [{:Type ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/type.go:11:11), :Value ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/constant/value.go:44:12)} Error]"
;;   {:added "1.0"
;;    :go "eval(ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), _expr)"}
;;   [^Object _fset, ^Object _pkg, ^go/token.Pos _pos, ^String _expr])

JOKER FUNC go/types.ExprString:
;; (defn ^"String" ExprString
;;   "ExprString returns the (possibly shortened) string representation for x.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (x go/ast.Expr)\n\nGo return type: string\n\nJoker input arguments: [^go/ast.Expr x]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ExprString(ABEND904(custom-runtime routine not implemented: go/ast.Expr(_x)))"}
;;   [^go/ast.Expr _x])

JOKER FUNC go/types.Id:
;; (defn ^"String" Id
;;   "Id returns name if it is exported, otherwise it\nreturns the name qualified with the package path.\n\nGo input arguments: (pkg *go/types.Package, name string)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go/types.Package) pkg, ^String name]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.Id(ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name)"}
;;   [^Object _pkg, ^String _name])

JOKER FUNC go/types.Identical:
;; (defn ^"Bool" Identical
;;   "Identical reports whether x and y are identical types.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x go/types.Type, y go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type x, ^go/types.Type y]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Identical(ABEND904(custom-runtime routine not implemented: go/types.Type(_x)), ABEND904(custom-runtime routine not implemented: go/types.Type(_y)))"}
;;   [^go/types.Type _x, ^go/types.Type _y])

JOKER FUNC go/types.IdenticalIgnoreTags:
;; (defn ^"Bool" IdenticalIgnoreTags
;;   "IdenticalIgnoreTags reports whether x and y are identical types if tags are ignored.\nReceivers of Signature types are ignored.\n\nGo input arguments: (x go/types.Type, y go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type x, ^go/types.Type y]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.IdenticalIgnoreTags(ABEND904(custom-runtime routine not implemented: go/types.Type(_x)), ABEND904(custom-runtime routine not implemented: go/types.Type(_y)))"}
;;   [^go/types.Type _x, ^go/types.Type _y])

JOKER FUNC go/types.Implements:
;; (defn ^"Bool" Implements
;;   "Implements reports whether type V implements interface T.\n\nGo input arguments: (V go/types.Type, T *go/types.Interface)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type V, ^(atom-of go/types.Interface) T]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.Implements(ABEND904(custom-runtime routine not implemented: go/types.Type(_V)), ConvertToIndirectOfgo/types.Interface(ABEND904(custom-runtime routine not implemented: go/types.Interface(_T))))"}
;;   [^go/types.Type _V, ^Object _T])

JOKER FUNC go/types.IsInterface:
;; (defn ^"Bool" IsInterface
;;   "IsInterface reports whether typ is an interface type.\n\nGo input arguments: (typ go/types.Type)\n\nGo return type: bool\n\nJoker input arguments: [^go/types.Type typ]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "types.IsInterface(ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)))"}
;;   [^go/types.Type _typ])

JOKER FUNC go/types.LookupFieldOrMethod:
;; (defn LookupFieldOrMethod
;;   "LookupFieldOrMethod looks up a field or method with given package and name\nin T and returns the corresponding *Var or *Func, an index sequence, and a\nbool indicating if there were any pointer indirections on the path to the\nfield or method. If addressable is set, T is the type of an addressable\nvariable (only matters for method lookups).\n\nThe last index entry is the field or method index in the (possibly embedded)\ntype where the entry was found, either:\n\n\t1) the list of declared methods of a named type; or\n\t2) the list of all methods (method set) of an interface type; or\n\t3) the list of fields of a struct type.\n\nThe earlier index entries are the indices of the embedded struct fields\ntraversed to get to the found entry, starting at depth 0.\n\nIf no entry is found, a nil object is returned. In this case, the returned\nindex and indirect values have the following meaning:\n\n\t- If index != nil, the index sequence points to an ambiguous entry\n\t(the same name appeared more than once at the same embedding level).\n\n\t- If indirect is set, a method with a pointer receiver type was found\n     but there was no pointer on the path from the actual receiver type to\n\tthe method's formal receiver base type, nor was the receiver addressable.\n\nGo input arguments: (T go/types.Type, addressable bool, pkg *go/types.Package, name string)\n\nGo return type: (obj Object, index []int, indirect bool)\n\nJoker input arguments: [^go/types.Type T, ^Bool addressable, ^(atom-of go/types.Package) pkg, ^String name]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/object.go:19:13) (vector-of Int) Bool]"
;;   {:added "1.0"
;;    :go "lookupFieldOrMethod(ABEND904(custom-runtime routine not implemented: go/types.Type(_T)), _addressable, ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name)"}
;;   [^go/types.Type _T, ^Bool _addressable, ^Object _pkg, ^String _name])

JOKER FUNC go/types.MissingMethod:
;; (defn MissingMethod
;;   "MissingMethod returns (nil, false) if V implements T, otherwise it\nreturns a missing method required by T and whether it is missing or\njust has the wrong type.\n\nFor non-interface types V, or if static is set, V implements T if all\nmethods of T are present in V. Otherwise (V is an interface and static\nis not set), MissingMethod only checks that methods of T which are also\npresent in V have matching types (e.g., for a type assertion x.(T) where\nx is of interface type V).\n\nGo input arguments: (V go/types.Type, T *go/types.Interface, static bool)\n\nGo return type: (method *Func, wrongType bool)\n\nJoker input arguments: [^go/types.Type V, ^(atom-of go/types.Interface) T, ^Bool static]\n\nJoker return type: [{} Bool]"
;;   {:added "1.0"
;;    :go "missingMethod(ABEND904(custom-runtime routine not implemented: go/types.Type(_V)), ConvertToIndirectOfgo/types.Interface(ABEND904(custom-runtime routine not implemented: go/types.Interface(_T))), _static)"}
;;   [^go/types.Type _V, ^Object _T, ^Bool _static])

JOKER FUNC go/types.NewArray:
;; (defn NewArray
;;   "NewArray returns a new array type for the given element type and length.\nA negative length indicates an unknown length.\n\nGo input arguments: (elem go/types.Type, len int64)\n\nGo return type: *Array\n\nJoker input arguments: [^go/types.Type elem, ^Int64 len]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newArray(ABEND904(custom-runtime routine not implemented: go/types.Type(_elem)), _len))"}
;;   [^go/types.Type _elem, ^Int64 _len])

JOKER FUNC go/types.NewChan:
;; (defn NewChan
;;   "NewChan returns a new channel type for the given direction and element type.\n\nGo input arguments: (dir go/types.ChanDir, elem go/types.Type)\n\nGo return type: *Chan\n\nJoker input arguments: [^go/types.ChanDir dir, ^go/types.Type elem]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newChan(ABEND904(custom-runtime routine not implemented: go/types.ChanDir(_dir)), ABEND904(custom-runtime routine not implemented: go/types.Type(_elem))))"}
;;   [^go/types.ChanDir _dir, ^go/types.Type _elem])

JOKER FUNC go/types.NewChecker:
;; (defn NewChecker
;;   "NewChecker returns a new Checker instance for a given package.\nPackage files may be added incrementally via checker.Files.\n\nGo input arguments: (conf *go/types.Config, fset *go/token.FileSet, pkg *go/types.Package, info *go/types.Info)\n\nGo return type: *Checker\n\nJoker input arguments: [^(atom-of go/types.Config) conf, ^(atom-of go/token.FileSet) fset, ^(atom-of go/types.Package) pkg, ^(atom-of go/types.Info) info]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newChecker(ConvertToIndirectOfgo/types.Config(ABEND904(custom-runtime routine not implemented: go/types.Config(_conf))), ConvertToIndirectOfgo/token.FileSet(ABEND904(custom-runtime routine not implemented: go/token.FileSet(_fset))), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), ConvertToIndirectOfgo/types.Info(ABEND904(custom-runtime routine not implemented: go/types.Info(_info)))))"}
;;   [^Object _conf, ^Object _fset, ^Object _pkg, ^Object _info])

JOKER FUNC go/types.NewConst:
;; (defn NewConst
;;   "NewConst returns a new constant with value val.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type, val go/constant.Value)\n\nGo return type: *Const\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^go/types.Type typ, ^go/constant.Value val]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newConst(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)), ABEND904(custom-runtime routine not implemented: go/constant.Value(_val))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^go/types.Type _typ, ^go/constant.Value _val])

JOKER FUNC go/types.NewField:
;; (defn NewField
;;   "NewField returns a new variable representing a struct field.\nFor embedded fields, the name is the unqualified type name\n/ under which the field is accessible.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type, embedded bool)\n\nGo return type: *Var\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^go/types.Type typ, ^Bool embedded]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newField(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)), _embedded))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^go/types.Type _typ, ^Bool _embedded])

JOKER FUNC go/types.NewFunc:
;; (defn NewFunc
;;   "NewFunc returns a new function with the given signature, representing\nthe function's type.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, sig *go/types.Signature)\n\nGo return type: *Func\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^(atom-of go/types.Signature) sig]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFunc(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ConvertToIndirectOfgo/types.Signature(ABEND904(custom-runtime routine not implemented: go/types.Signature(_sig)))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^Object _sig])

JOKER FUNC go/types.NewInterface:
;; (defn NewInterface
;;   "NewInterface returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type.\nNewInterface takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nDeprecated: Use NewInterfaceType instead which allows any (even non-defined) interface types\nto be embedded. This is necessary for interfaces that embed alias type names referring to\nnon-defined (literal) interface types.\n\nGo input arguments: (methods []*go/types.Func, embeddeds []*go/types.Named)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go/types.Func)) methods, ^(vector-of (atom-of go/types.Named)) embeddeds]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newInterface(ConvertToArrayOfObject(ConvertToIndirectOfgo/types.Func(ABEND904(custom-runtime routine not implemented: go/types.Func(_methods)))), ConvertToArrayOfObject(ConvertToIndirectOfgo/types.Named(ABEND904(custom-runtime routine not implemented: go/types.Named(_embeddeds))))))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewInterfaceType:
;; (defn NewInterfaceType
;;   "NewInterfaceType returns a new (incomplete) interface for the given methods and embedded types.\nEach embedded type must have an underlying type of interface type (this property is not\nverified for defined types, which may be in the process of being set up and which don't\nhave a valid underlying type yet).\nNewInterfaceType takes ownership of the provided methods and may modify their types by setting\nmissing receivers. To compute the method set of the interface, Complete must be called.\n\nGo input arguments: (methods []*go/types.Func, embeddeds []go/types.Type)\n\nGo return type: *Interface\n\nJoker input arguments: [^(vector-of (atom-of go/types.Func)) methods, ^(vector-of go/types.Type) embeddeds]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newInterfaceType(ConvertToArrayOfObject(ConvertToIndirectOfgo/types.Func(ABEND904(custom-runtime routine not implemented: go/types.Func(_methods)))), ConvertToArrayOfgo/types.Type(ABEND904(custom-runtime routine not implemented: go/types.Type(_embeddeds)))))"}
;;   [^Object _methods, ^Object _embeddeds])

JOKER FUNC go/types.NewLabel:
;; (defn NewLabel
;;   "NewLabel returns a new label.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string)\n\nGo return type: *Label\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newLabel(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name])

JOKER FUNC go/types.NewMap:
;; (defn NewMap
;;   "NewMap returns a new map for the given key and element types.\n\nGo input arguments: (key go/types.Type, elem go/types.Type)\n\nGo return type: *Map\n\nJoker input arguments: [^go/types.Type key, ^go/types.Type elem]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newMap(ABEND904(custom-runtime routine not implemented: go/types.Type(_key)), ABEND904(custom-runtime routine not implemented: go/types.Type(_elem))))"}
;;   [^go/types.Type _key, ^go/types.Type _elem])

JOKER FUNC go/types.NewMethodSet:
;; (defn NewMethodSet
;;   "NewMethodSet returns the method set for the given type T.\nIt always returns a non-nil method set, even if it is empty.\n\nGo input arguments: (T go/types.Type)\n\nGo return type: *MethodSet\n\nJoker input arguments: [^go/types.Type T]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newMethodSet(ABEND904(custom-runtime routine not implemented: go/types.Type(_T))))"}
;;   [^go/types.Type _T])

JOKER FUNC go/types.NewNamed:
;; (defn NewNamed
;;   "NewNamed returns a new named type for the given type name, underlying type, and associated methods.\nIf the given type name obj doesn't have a type yet, its type is set to the returned named type.\nThe underlying type must not be a *Named.\n\nGo input arguments: (obj *go/types.TypeName, underlying go/types.Type, methods []*go/types.Func)\n\nGo return type: *Named\n\nJoker input arguments: [^(atom-of go/types.TypeName) obj, ^go/types.Type underlying, ^(vector-of (atom-of go/types.Func)) methods]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newNamed(ConvertToIndirectOfgo/types.TypeName(ABEND904(custom-runtime routine not implemented: go/types.TypeName(_obj))), ABEND904(custom-runtime routine not implemented: go/types.Type(_underlying)), ConvertToArrayOfObject(ConvertToIndirectOfgo/types.Func(ABEND904(custom-runtime routine not implemented: go/types.Func(_methods))))))"}
;;   [^Object _obj, ^go/types.Type _underlying, ^Object _methods])

JOKER FUNC go/types.NewPackage:
;; (defn NewPackage
;;   "NewPackage returns a new Package for the given package path and name.\nThe package is not complete and contains no explicit imports.\n\nGo input arguments: (path string, name string)\n\nGo return type: *Package\n\nJoker input arguments: [^String path, ^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newPackage(_path, _name))"}
;;   [^String _path, ^String _name])

JOKER FUNC go/types.NewParam:
;; (defn NewParam
;;   "NewParam returns a new variable representing a function parameter.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^go/types.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newParam(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ABEND904(custom-runtime routine not implemented: go/types.Type(_typ))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^go/types.Type _typ])

JOKER FUNC go/types.NewPkgName:
;; (defn NewPkgName
;;   "NewPkgName returns a new PkgName object representing an imported package.\nThe remaining arguments set the attributes found with all Objects.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, imported *go/types.Package)\n\nGo return type: *PkgName\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^(atom-of go/types.Package) imported]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newPkgName(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_imported)))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^Object _imported])

JOKER FUNC go/types.NewPointer:
;; (defn NewPointer
;;   "NewPointer returns a new pointer type for the given element (base) type.\n\nGo input arguments: (elem go/types.Type)\n\nGo return type: *Pointer\n\nJoker input arguments: [^go/types.Type elem]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newPointer(ABEND904(custom-runtime routine not implemented: go/types.Type(_elem))))"}
;;   [^go/types.Type _elem])

JOKER FUNC go/types.NewScope:
;; (defn NewScope
;;   "NewScope returns a new, empty scope contained in the given parent\nscope, if any. The comment is for debugging only.\n\nGo input arguments: (parent *go/types.Scope, pos go/token.Pos, end go/token.Pos, comment string)\n\nGo return type: *Scope\n\nJoker input arguments: [^(atom-of go/types.Scope) parent, ^go/token.Pos pos, ^go/token.Pos end, ^String comment]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newScope(ConvertToIndirectOfgo/types.Scope(ABEND904(custom-runtime routine not implemented: go/types.Scope(_parent))), ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ABEND904(custom-runtime routine not implemented: go/token.Pos(_end)), _comment))"}
;;   [^Object _parent, ^go/token.Pos _pos, ^go/token.Pos _end, ^String _comment])

JOKER FUNC go/types.NewSignature:
;; (defn NewSignature
;;   "NewSignature returns a new function type for the given receiver, parameters,\nand results, either of which may be nil. If variadic is set, the function\nis variadic, it must have at least one parameter, and the last parameter\nmust be of unnamed slice type.\n\nGo input arguments: (recv *go/types.Var, params *go/types.Tuple, results *go/types.Tuple, variadic bool)\n\nGo return type: *Signature\n\nJoker input arguments: [^(atom-of go/types.Var) recv, ^(atom-of go/types.Tuple) params, ^(atom-of go/types.Tuple) results, ^Bool variadic]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSignature(ConvertToIndirectOfgo/types.Var(ABEND904(custom-runtime routine not implemented: go/types.Var(_recv))), ConvertToIndirectOfgo/types.Tuple(ABEND904(custom-runtime routine not implemented: go/types.Tuple(_params))), ConvertToIndirectOfgo/types.Tuple(ABEND904(custom-runtime routine not implemented: go/types.Tuple(_results))), _variadic))"}
;;   [^Object _recv, ^Object _params, ^Object _results, ^Bool _variadic])

JOKER FUNC go/types.NewSlice:
;; (defn NewSlice
;;   "NewSlice returns a new slice type for the given element type.\n\nGo input arguments: (elem go/types.Type)\n\nGo return type: *Slice\n\nJoker input arguments: [^go/types.Type elem]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSlice(ABEND904(custom-runtime routine not implemented: go/types.Type(_elem))))"}
;;   [^go/types.Type _elem])

JOKER FUNC go/types.NewStruct:
;; (defn NewStruct
;;   "NewStruct returns a new struct with the given fields and corresponding field tags.\nIf a field with index i has a tag, tags[i] must be that tag, but len(tags) may be\nonly as long as required to hold the tag with the largest index i. Consequently,\nif no field has a tag, tags may be nil.\n\nGo input arguments: (fields []*go/types.Var, tags []string)\n\nGo return type: *Struct\n\nJoker input arguments: [^(vector-of (atom-of go/types.Var)) fields, ^(vector-of String) tags]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newStruct(ConvertToArrayOfObject(ConvertToIndirectOfgo/types.Var(ABEND904(custom-runtime routine not implemented: go/types.Var(_fields)))), ConvertToArrayOfString(_tags)))"}
;;   [^Object _fields, ^Object _tags])

JOKER FUNC go/types.NewTuple:
;; (defn NewTuple
;;   "NewTuple returns a new tuple for the given variables.\n\nGo input arguments: (x ...*go/types.Var)\n\nGo return type: *Tuple\n\nJoker input arguments: [^(ellipsis-somehow Object) x]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTuple(ConvertToEllipsisHaHaObject(ConvertToIndirectOfgo/types.Var(ABEND904(custom-runtime routine not implemented: go/types.Var(_x))))))"}
;;   [^Object _x])

JOKER FUNC go/types.NewTypeName:
;; (defn NewTypeName
;;   "NewTypeName returns a new type name denoting the given typ.\nThe remaining arguments set the attributes found with all Objects.\n\nThe typ argument may be a defined (Named) type or an alias type.\nIt may also be nil such that the returned TypeName can be used as\nargument for NewNamed, which will set the TypeName's type as a side-\neffect.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type)\n\nGo return type: *TypeName\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^go/types.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTypeName(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ABEND904(custom-runtime routine not implemented: go/types.Type(_typ))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^go/types.Type _typ])

JOKER FUNC go/types.NewVar:
;; (defn NewVar
;;   "NewVar returns a new variable.\nThe arguments set the attributes found with all Objects.\n\nGo input arguments: (pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type)\n\nGo return type: *Var\n\nJoker input arguments: [^go/token.Pos pos, ^(atom-of go/types.Package) pkg, ^String name, ^go/types.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newVar(ABEND904(custom-runtime routine not implemented: go/token.Pos(_pos)), ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))), _name, ABEND904(custom-runtime routine not implemented: go/types.Type(_typ))))"}
;;   [^go/token.Pos _pos, ^Object _pkg, ^String _name, ^go/types.Type _typ])

JOKER FUNC go/types.ObjectString:
;; (defn ^"String" ObjectString
;;   "ObjectString returns the string form of obj.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (obj go/types.Object, qf go/types.Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go/types.Object obj, ^go/types.Qualifier qf]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.ObjectString(ABEND904(custom-runtime routine not implemented: go/types.Object(_obj)), ABEND904(custom-runtime routine not implemented: go/types.Qualifier(_qf)))"}
;;   [^go/types.Object _obj, ^go/types.Qualifier _qf])

JOKER FUNC go/types.RelativeTo:
;; (defn RelativeTo
;;   "RelativeTo(pkg) returns a Qualifier that fully qualifies members of\nall packages other than pkg.\n\nGo input arguments: (pkg *go/types.Package)\n\nGo return type: Qualifier\n\nJoker input arguments: [^(atom-of go/types.Package) pkg]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/go/types/typestring.go:25:16)"
;;   {:added "1.0"
;;    :go "relativeTo(ConvertToIndirectOfgo/types.Package(ABEND904(custom-runtime routine not implemented: go/types.Package(_pkg))))"}
;;   [^Object _pkg])

JOKER FUNC go/types.SelectionString:
;; (defn ^"String" SelectionString
;;   "SelectionString returns the string form of s.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nExamples:\n\t\"field (T) f int\"\n\t\"method (T) f(X) Y\"\n\t\"method expr (T) f(X) Y\"\n\nGo input arguments: (s *go/types.Selection, qf go/types.Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^(atom-of go/types.Selection) s, ^go/types.Qualifier qf]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.SelectionString(ConvertToIndirectOfgo/types.Selection(ABEND904(custom-runtime routine not implemented: go/types.Selection(_s))), ABEND904(custom-runtime routine not implemented: go/types.Qualifier(_qf)))"}
;;   [^Object _s, ^go/types.Qualifier _qf])

JOKER FUNC go/types.SizesFor:
;; (defn SizesFor
;;   "SizesFor returns the Sizes used by a compiler for an architecture.\nThe result is nil if a compiler/architecture pair is not known.\n\nSupported architectures for compiler \"gc\":\n\"386\", \"arm\", \"arm64\", \"amd64\", \"amd64p32\", \"mips\", \"mipsle\",\n\"mips64\", \"mips64le\", \"ppc64\", \"ppc64le\", \"riscv64\", \"s390x\", \"wasm\".\n\nGo input arguments: (compiler string, arch string)\n\nGo return type: Sizes\n\nJoker input arguments: [^String compiler, ^String arch]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/go/types/sizes.go:10:12)"
;;   {:added "1.0"
;;    :go "sizesFor(_compiler, _arch)"}
;;   [^String _compiler, ^String _arch])

JOKER FUNC go/types.TypeString:
;; (defn ^"String" TypeString
;;   "TypeString returns the string representation of typ.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (typ go/types.Type, qf go/types.Qualifier)\n\nGo return type: string\n\nJoker input arguments: [^go/types.Type typ, ^go/types.Qualifier qf]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "types.TypeString(ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)), ABEND904(custom-runtime routine not implemented: go/types.Qualifier(_qf)))"}
;;   [^go/types.Type _typ, ^go/types.Qualifier _qf])

JOKER FUNC go/types.WriteExpr:
;; (defn WriteExpr
;;   "WriteExpr writes the (possibly shortened) string representation for x to buf.\nShortened representations are suitable for user interfaces but may not\nnecessarily follow Go syntax.\n\nGo input arguments: (buf *bytes.Buffer, x go/ast.Expr)\n\nJoker input arguments: [^(atom-of bytes.Buffer) buf, ^go/ast.Expr x]"
;;   {:added "1.0"
;;    :go "writeExpr(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_buf))), ABEND904(custom-runtime routine not implemented: go/ast.Expr(_x)))"}
;;   [^Object _buf, ^go/ast.Expr _x])

JOKER FUNC go/types.WriteSignature:
;; (defn WriteSignature
;;   "WriteSignature writes the representation of the signature sig to buf,\nwithout a leading \"func\" keyword.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, sig *go/types.Signature, qf go/types.Qualifier)\n\nJoker input arguments: [^(atom-of bytes.Buffer) buf, ^(atom-of go/types.Signature) sig, ^go/types.Qualifier qf]"
;;   {:added "1.0"
;;    :go "writeSignature(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_buf))), ConvertToIndirectOfgo/types.Signature(ABEND904(custom-runtime routine not implemented: go/types.Signature(_sig))), ABEND904(custom-runtime routine not implemented: go/types.Qualifier(_qf)))"}
;;   [^Object _buf, ^Object _sig, ^go/types.Qualifier _qf])

JOKER FUNC go/types.WriteType:
;; (defn WriteType
;;   "WriteType writes the string representation of typ to buf.\nThe Qualifier controls the printing of\npackage-level objects, and may be nil.\n\nGo input arguments: (buf *bytes.Buffer, typ go/types.Type, qf go/types.Qualifier)\n\nJoker input arguments: [^(atom-of bytes.Buffer) buf, ^go/types.Type typ, ^go/types.Qualifier qf]"
;;   {:added "1.0"
;;    :go "writeType(ConvertToIndirectOfbytes.Buffer(ABEND904(custom-runtime routine not implemented: bytes.Buffer(_buf))), ABEND904(custom-runtime routine not implemented: go/types.Type(_typ)), ABEND904(custom-runtime routine not implemented: go/types.Qualifier(_qf)))"}
;;   [^Object _buf, ^go/types.Type _typ, ^go/types.Qualifier _qf])

JOKER FUNC hash/adler32.Checksum:
(defn ^"Int" Checksum
  "Checksum returns the Adler-32 checksum of data.\n\nGo input arguments: (data []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(adler32.Checksum(ConvertToArrayOfByte(_data)))"}
  [^Object _data])

JOKER FUNC hash/adler32.New:
;; (defn New
;;   "New returns a new hash.Hash32 computing the Adler-32 checksum. Its\nSum method will lay the value out in big-endian byte order. The\nreturned Hash32 also implements encoding.BinaryMarshaler and\nencoding.BinaryUnmarshaler to marshal and unmarshal the internal\nstate of the hash.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:49:13)"
;;   {:added "1.0"
;;    :go "new()"}
;;   [])

JOKER FUNC hash/crc32.Checksum:
;; (defn ^"Int" Checksum
;;   "Checksum returns the CRC-32 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *hash/crc32.Table)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of hash/crc32.Table) tab]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(crc32.Checksum(ConvertToArrayOfByte(_data), ConvertToIndirectOfhash/crc32.Table(ABEND904(custom-runtime routine not implemented: hash/crc32.Table(_tab)))))"}
;;   [^Object _data, ^Object _tab])

JOKER FUNC hash/crc32.ChecksumIEEE:
(defn ^"Int" ChecksumIEEE
  "ChecksumIEEE returns the CRC-32 checksum of data\nusing the IEEE polynomial.\n\nGo input arguments: (data []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(crc32.ChecksumIEEE(ConvertToArrayOfByte(_data)))"}
  [^Object _data])

JOKER FUNC hash/crc32.MakeTable:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint32)\n\nGo return type: *Table\n\nJoker input arguments: [^UInt32 poly]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: makeTable(_poly))"}
;;   [^UInt32 _poly])

JOKER FUNC hash/crc32.New:
;; (defn New
;;   "New creates a new hash.Hash32 computing the CRC-32 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash32 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *hash/crc32.Table)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of hash/crc32.Table) tab]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:49:13)"
;;   {:added "1.0"
;;    :go "new(ConvertToIndirectOfhash/crc32.Table(ABEND904(custom-runtime routine not implemented: hash/crc32.Table(_tab))))"}
;;   [^Object _tab])

JOKER FUNC hash/crc32.NewIEEE:
;; (defn NewIEEE
;;   "NewIEEE creates a new hash.Hash32 computing the CRC-32 checksum using\nthe IEEE polynomial. Its Sum method will lay the value out in\nbig-endian byte order. The returned Hash32 also implements\nencoding.BinaryMarshaler and encoding.BinaryUnmarshaler to marshal\nand unmarshal the internal state of the hash.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:49:13)"
;;   {:added "1.0"
;;    :go "newIEEE()"}
;;   [])

JOKER FUNC hash/crc32.Update:
;; (defn ^"Int" Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint32, tab *hash/crc32.Table, p []byte)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 crc, ^(atom-of hash/crc32.Table) tab, ^(vector-of Byte) p]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(crc32.Update(_crc, ConvertToIndirectOfhash/crc32.Table(ABEND904(custom-runtime routine not implemented: hash/crc32.Table(_tab))), ConvertToArrayOfByte(_p)))"}
;;   [^UInt32 _crc, ^Object _tab, ^Object _p])

JOKER FUNC hash/crc64.Checksum:
;; (defn Checksum
;;   "Checksum returns the CRC-64 checksum of data\nusing the polynomial represented by the Table.\n\nGo input arguments: (data []byte, tab *hash/crc64.Table)\n\nGo return type: ...\n\nJoker input arguments: [^(vector-of Byte) data, ^(atom-of hash/crc64.Table) tab]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "checksum(ConvertToArrayOfByte(_data), ConvertToIndirectOfhash/crc64.Table(ABEND904(custom-runtime routine not implemented: hash/crc64.Table(_tab))))"}
;;   [^Object _data, ^Object _tab])

JOKER FUNC hash/crc64.MakeTable:
;; (defn MakeTable
;;   "MakeTable returns a Table constructed from the specified polynomial.\nThe contents of this Table must not be modified.\n\nGo input arguments: (poly uint64)\n\nGo return type: *Table\n\nJoker input arguments: [^uint64 poly]\n\nJoker return type: (vector-of ABEND043(unsupported built-in type uint64))"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: makeTable(_poly))"}
;;   [^ABEND044(unsupported built-in type uint64) _poly])

JOKER FUNC hash/crc64.New:
;; (defn New
;;   "New creates a new hash.Hash64 computing the CRC-64 checksum using the\npolynomial represented by the Table. Its Sum method will lay the\nvalue out in big-endian byte order. The returned Hash64 also\nimplements encoding.BinaryMarshaler and encoding.BinaryUnmarshaler to\nmarshal and unmarshal the internal state of the hash.\n\nGo input arguments: (tab *hash/crc64.Table)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of hash/crc64.Table) tab]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:55:13)"
;;   {:added "1.0"
;;    :go "new(ConvertToIndirectOfhash/crc64.Table(ABEND904(custom-runtime routine not implemented: hash/crc64.Table(_tab))))"}
;;   [^Object _tab])

JOKER FUNC hash/crc64.Update:
;; (defn Update
;;   "Update returns the result of adding the bytes in p to the crc.\n\nGo input arguments: (crc uint64, tab *hash/crc64.Table, p []byte)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 crc, ^(atom-of hash/crc64.Table) tab, ^(vector-of Byte) p]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "update(_crc, ConvertToIndirectOfhash/crc64.Table(ABEND904(custom-runtime routine not implemented: hash/crc64.Table(_tab))), ConvertToArrayOfByte(_p))"}
;;   [^ABEND044(unsupported built-in type uint64) _crc, ^Object _tab, ^Object _p])

JOKER FUNC hash/fnv.New128:
;; (defn New128
;;   "New128 returns a new 128-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new128()"}
;;   [])

JOKER FUNC hash/fnv.New128a:
;; (defn New128a
;;   "New128a returns a new 128-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:26:11)"
;;   {:added "1.0"
;;    :go "new128a()"}
;;   [])

JOKER FUNC hash/fnv.New32:
;; (defn New32
;;   "New32 returns a new 32-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:49:13)"
;;   {:added "1.0"
;;    :go "new32()"}
;;   [])

JOKER FUNC hash/fnv.New32a:
;; (defn New32a
;;   "New32a returns a new 32-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:49:13)"
;;   {:added "1.0"
;;    :go "new32a()"}
;;   [])

JOKER FUNC hash/fnv.New64:
;; (defn New64
;;   "New64 returns a new 64-bit FNV-1 hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:55:13)"
;;   {:added "1.0"
;;    :go "new64()"}
;;   [])

JOKER FUNC hash/fnv.New64a:
;; (defn New64a
;;   "New64a returns a new 64-bit FNV-1a hash.Hash.\nIts Sum method will lay the value out in big-endian byte order.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/hash/hash.go:55:13)"
;;   {:added "1.0"
;;    :go "new64a()"}
;;   [])

JOKER FUNC html.EscapeString:
(defn ^"String" EscapeString
  "EscapeString escapes special characters like \"<\" to become \"&lt;\". It\nescapes only five such characters: <, >, &, ' and \".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.EscapeString(_s)"}
  [^String _s])

JOKER FUNC html.UnescapeString:
(defn ^"String" UnescapeString
  "UnescapeString unescapes entities like \"&lt;\" to become \"<\". It unescapes a\nlarger range of entities than EscapeString escapes. For example, \"&aacute;\"\nunescapes to \"\", as does \"&#225;\" and \"&#xE1;\".\nUnescapeString(EscapeString(s)) == s always holds, but the converse isn't\nalways true.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "html.UnescapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.HTMLEscape:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "hTMLEscape(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_b))"}
;;   [^io.Writer _w, ^Object _b])

JOKER FUNC html/template.HTMLEscapeString:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.HTMLEscaper:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.IsTrue:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC html/template.JSEscape:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "jSEscape(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_b))"}
;;   [^io.Writer _w, ^Object _b])

JOKER FUNC html/template.JSEscapeString:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC html/template.JSEscaper:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC html/template.Must:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable initializations\nsuch as\n\tvar t = template.Must(template.New(\"name\").Parse(\"html\"))\n\nGo input arguments: (t *html/template.Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of html/template.Template) t, ^ABEND885(unrecognized type error at: GO.link/src/html/template/template.go:370:28) err]\n\nJoker return type: {:Tree ^{:Name ^String, :ParseName ^String, :Root ^ABEND042(cannot find typename html/template.ListNode)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: must(ConvertToIndirectOfhtml/template.Template(ABEND904(custom-runtime routine not implemented: html/template.Template(_t))), _err))"}
;;   [^Object _t, ^ABEND885(unrecognized type error at: GO.link/src/html/template/template.go:370:28) _err])

JOKER FUNC html/template.New:
;; (defn New
;;   "New allocates a new HTML template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: {:Tree ^{:Name ^String, :ParseName ^String, :Root ^ABEND042(cannot find typename html/template.ListNode)}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(_name))"}
;;   [^String _name])

JOKER FUNC html/template.ParseFiles:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the (base) name and\n(parsed) contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [{:Tree ^{:Name ^String, :ParseName ^String, :Root ^ABEND042(cannot find typename html/template.ListNode)}} Error]"
;;   {:added "1.0"
;;    :go "parseFiles(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC html/template.ParseGlob:
;; (defn ParseGlob
;;   "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [{:Tree ^{:Name ^String, :ParseName ^String, :Root ^ABEND042(cannot find typename html/template.ListNode)}} Error]"
;;   {:added "1.0"
;;    :go "parseGlob(_pattern)"}
;;   [^String _pattern])

JOKER FUNC html/template.URLQueryEscaper:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC image.Decode:
;; (defn Decode
;;   "Decode decodes an image that has been encoded in a registered format.\nThe string returned is the format name used during format registration.\nFormat registration is typically done by an init function in the codec-\nspecific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Image, string, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/image.go:36:12) String Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image.DecodeConfig:
;; (defn DecodeConfig
;;   "DecodeConfig decodes the color model and dimensions of an image that has\nbeen encoded in a registered format. The string returned is the format name\nused during format registration. Format registration is typically done by\nan init function in the codec-specific package.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (Config, string, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12), :Width ^Int, :Height ^Int} String Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image.NewAlpha:
;; (defn NewAlpha
;;   "NewAlpha returns a new Alpha image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *Alpha\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newAlpha(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewAlpha16:
;; (defn NewAlpha16
;;   "NewAlpha16 returns a new Alpha16 image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *Alpha16\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newAlpha16(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewCMYK:
;; (defn NewCMYK
;;   "NewCMYK returns a new CMYK image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *CMYK\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newCMYK(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewGray:
;; (defn NewGray
;;   "NewGray returns a new Gray image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *Gray\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newGray(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewGray16:
;; (defn NewGray16
;;   "NewGray16 returns a new Gray16 image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *Gray16\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newGray16(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewNRGBA:
;; (defn NewNRGBA
;;   "NewNRGBA returns a new NRGBA image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *NRGBA\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newNRGBA(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewNRGBA64:
;; (defn NewNRGBA64
;;   "NewNRGBA64 returns a new NRGBA64 image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *NRGBA64\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newNRGBA64(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewNYCbCrA:
;; (defn NewNYCbCrA
;;   "NewNYCbCrA returns a new NYCbCrA image with the given bounds and subsample\nratio.\n\nGo input arguments: (r image.Rectangle, subsampleRatio image.YCbCrSubsampleRatio)\n\nGo return type: *NYCbCrA\n\nJoker input arguments: [^image.Rectangle r, ^image.YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: {:A ^(vector-of ABEND043(unsupported built-in type uint8)), :AStride ^Int}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newNYCbCrA(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r)), ABEND904(custom-runtime routine not implemented: image.YCbCrSubsampleRatio(_subsampleRatio))))"}
;;   [^image.Rectangle _r, ^image.YCbCrSubsampleRatio _subsampleRatio])

JOKER FUNC image.NewPaletted:
;; (defn NewPaletted
;;   "NewPaletted returns a new Paletted image with the given width, height and\npalette.\n\nGo input arguments: (r image.Rectangle, p image/color.Palette)\n\nGo return type: *Paletted\n\nJoker input arguments: [^image.Rectangle r, ^image/color.Palette p]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}, :Palette ^(vector-of ABEND042(cannot find typename image.Color))}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newPaletted(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r)), ABEND904(custom-runtime routine not implemented: image/color.Palette(_p))))"}
;;   [^image.Rectangle _r, ^image/color.Palette _p])

JOKER FUNC image.NewRGBA:
;; (defn NewRGBA
;;   "NewRGBA returns a new RGBA image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *RGBA\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRGBA(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewRGBA64:
;; (defn NewRGBA64
;;   "NewRGBA64 returns a new RGBA64 image with the given bounds.\n\nGo input arguments: (r image.Rectangle)\n\nGo return type: *RGBA64\n\nJoker input arguments: [^image.Rectangle r]\n\nJoker return type: {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRGBA64(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r))))"}
;;   [^image.Rectangle _r])

JOKER FUNC image.NewUniform:
;; (defn NewUniform
;;   "Go input arguments: (c image/color.Color)\n\nGo return type: *Uniform\n\nJoker input arguments: [^image/color.Color c]\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:10:12)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newUniform(ABEND904(custom-runtime routine not implemented: image/color.Color(_c))))"}
;;   [^image/color.Color _c])

JOKER FUNC image.NewYCbCr:
;; (defn NewYCbCr
;;   "NewYCbCr returns a new YCbCr image with the given bounds and subsample\nratio.\n\nGo input arguments: (r image.Rectangle, subsampleRatio image.YCbCrSubsampleRatio)\n\nGo return type: *YCbCr\n\nJoker input arguments: [^image.Rectangle r, ^image.YCbCrSubsampleRatio subsampleRatio]\n\nJoker return type: {:Y ^(vector-of ABEND043(unsupported built-in type uint8)), :Cb ^(vector-of ABEND043(unsupported built-in type uint8)), :Cr ^(vector-of ABEND043(unsupported built-in type uint8)), :YStride ^Int, :CStride ^Int, :SubsampleRatio ^Int, :Rect ^{:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newYCbCr(ABEND904(custom-runtime routine not implemented: image.Rectangle(_r)), ABEND904(custom-runtime routine not implemented: image.YCbCrSubsampleRatio(_subsampleRatio))))"}
;;   [^image.Rectangle _r, ^image.YCbCrSubsampleRatio _subsampleRatio])

JOKER FUNC image.Pt:
(defn Pt
  "Pt is shorthand for Point{X, Y}.\n\nGo input arguments: (X int, Y int)\n\nGo return type: Point\n\nJoker input arguments: [^Int X, ^Int Y]\n\nJoker return type: {:X ^Int, :Y ^Int}"
  {:added "1.0"
   :go "pt(_X, _Y)"}
  [^Int _X, ^Int _Y])

JOKER FUNC image.Rect:
(defn Rect
  "Rect is shorthand for Rectangle{Pt(x0, y0), Pt(x1, y1)}. The returned\nrectangle has minimum and maximum coordinates swapped if necessary so that\nit is well-formed.\n\nGo input arguments: (x0 int, y0 int, x1 int, y1 int)\n\nGo return type: Rectangle\n\nJoker input arguments: [^Int x0, ^Int y0, ^Int x1, ^Int y1]\n\nJoker return type: {:Min ^{:X ^Int, :Y ^Int}, :Max ^{:X ^Int, :Y ^Int}}"
  {:added "1.0"
   :go "rect(_x0, _y0, _x1, _y1)"}
  [^Int _x0, ^Int _y0, ^Int _x1, ^Int _y1])

JOKER FUNC image.RegisterFormat:
;; (defn RegisterFormat
;;   "RegisterFormat registers an image format for use by Decode.\nName is the name of the format, like \"jpeg\" or \"png\".\nMagic is the magic prefix that identifies the format's encoding. The magic\nstring can contain \"?\" wildcards that each match any one byte.\nDecode is the function that decodes the encoded image.\nDecodeConfig is the function that decodes just its configuration.\n\nGo input arguments: (name string, magic string, decode func, decodeConfig func)\n\nJoker input arguments: [^String name, ^String magic, ^fn decode, ^fn decodeConfig]"
;;   {:added "1.0"
;;    :go "registerFormat(_name, _magic, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _name, ^String _magic, ^fn _decode, ^fn _decodeConfig])

JOKER FUNC image/color.CMYKToRGB:
;; (defn CMYKToRGB
;;   "CMYKToRGB converts a CMYK quadruple to an RGB triple.\n\nGo input arguments: (c uint8, m uint8, y uint8, k uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 c, ^uint8 m, ^uint8 y, ^uint8 k]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "cMYKToRGB(_c, _m, _y, _k)"}
;;   [^ABEND044(unsupported built-in type uint8) _c, ^ABEND044(unsupported built-in type uint8) _m, ^ABEND044(unsupported built-in type uint8) _y, ^ABEND044(unsupported built-in type uint8) _k])

JOKER FUNC image/color.ModelFunc:
;; (defn ModelFunc
;;   "ModelFunc returns a Model that invokes f to implement the conversion.\n\nGo input arguments: (f func)\n\nGo return type: Model\n\nJoker input arguments: [^fn f]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12)"
;;   {:added "1.0"
;;    :go "modelFunc(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^fn _f])

JOKER FUNC image/color.RGBToCMYK:
;; (defn RGBToCMYK
;;   "RGBToCMYK converts an RGB triple to a CMYK quadruple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "rGBToCMYK(_r, _g, _b)"}
;;   [^ABEND044(unsupported built-in type uint8) _r, ^ABEND044(unsupported built-in type uint8) _g, ^ABEND044(unsupported built-in type uint8) _b])

JOKER FUNC image/color.RGBToYCbCr:
;; (defn RGBToYCbCr
;;   "RGBToYCbCr converts an RGB triple to a Y'CbCr triple.\n\nGo input arguments: (r uint8, g uint8, b uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 r, ^uint8 g, ^uint8 b]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "rGBToYCbCr(_r, _g, _b)"}
;;   [^ABEND044(unsupported built-in type uint8) _r, ^ABEND044(unsupported built-in type uint8) _g, ^ABEND044(unsupported built-in type uint8) _b])

JOKER FUNC image/color.YCbCrToRGB:
;; (defn YCbCrToRGB
;;   "YCbCrToRGB converts a Y'CbCr triple to an RGB triple.\n\nGo input arguments: (y uint8, cb uint8, cr uint8)\n\nGo return type: (..., ..., ...)\n\nJoker input arguments: [^uint8 y, ^uint8 cb, ^uint8 cr]\n\nJoker return type: [ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8) ABEND043(unsupported built-in type uint8)]"
;;   {:added "1.0"
;;    :go "yCbCrToRGB(_y, _cb, _cr)"}
;;   [^ABEND044(unsupported built-in type uint8) _y, ^ABEND044(unsupported built-in type uint8) _cb, ^ABEND044(unsupported built-in type uint8) _cr])

JOKER FUNC image/draw.Draw:
;; (defn Draw
;;   "Draw calls DrawMask with a nil mask.\n\nGo input arguments: (dst image/draw.Image, r image.Rectangle, src image.Image, sp image.Point, op image/draw.Op)\n\nJoker input arguments: [^image/draw.Image dst, ^image.Rectangle r, ^image.Image src, ^image.Point sp, ^image/draw.Op op]"
;;   {:added "1.0"
;;    :go "draw(ABEND904(custom-runtime routine not implemented: image/draw.Image(_dst)), ABEND904(custom-runtime routine not implemented: image.Rectangle(_r)), ABEND904(custom-runtime routine not implemented: image.Image(_src)), ABEND904(custom-runtime routine not implemented: image.Point(_sp)), ABEND904(custom-runtime routine not implemented: image/draw.Op(_op)))"}
;;   [^image/draw.Image _dst, ^image.Rectangle _r, ^image.Image _src, ^image.Point _sp, ^image/draw.Op _op])

JOKER FUNC image/draw.DrawMask:
;; (defn DrawMask
;;   "DrawMask aligns r.Min in dst with sp in src and mp in mask and then replaces the rectangle r\nin dst with the result of a Porter-Duff composition. A nil mask is treated as opaque.\n\nGo input arguments: (dst image/draw.Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op image/draw.Op)\n\nJoker input arguments: [^image/draw.Image dst, ^image.Rectangle r, ^image.Image src, ^image.Point sp, ^image.Image mask, ^image.Point mp, ^image/draw.Op op]"
;;   {:added "1.0"
;;    :go "drawMask(ABEND904(custom-runtime routine not implemented: image/draw.Image(_dst)), ABEND904(custom-runtime routine not implemented: image.Rectangle(_r)), ABEND904(custom-runtime routine not implemented: image.Image(_src)), ABEND904(custom-runtime routine not implemented: image.Point(_sp)), ABEND904(custom-runtime routine not implemented: image.Image(_mask)), ABEND904(custom-runtime routine not implemented: image.Point(_mp)), ABEND904(custom-runtime routine not implemented: image/draw.Op(_op)))"}
;;   [^image/draw.Image _dst, ^image.Rectangle _r, ^image.Image _src, ^image.Point _sp, ^image.Image _mask, ^image.Point _mp, ^image/draw.Op _op])

JOKER FUNC image/gif.Decode:
;; (defn Decode
;;   "Decode reads a GIF image from r and returns the first embedded\nimage as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/image.go:36:12) Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/gif.DecodeAll:
;; (defn DecodeAll
;;   "DecodeAll reads a GIF image from r and returns the sequential frames\nand timing information.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (*GIF, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:Image ^(vector-of {:Pix ^(vector-of ABEND043(unsupported built-in type uint8)), :Stride ^Int, :Rect ^ABEND042(cannot find typename image/gif.Rectangle), :Palette ^(vector-of ABEND042(cannot find typename image/gif.Color))}), :Delay ^(vector-of Int), :LoopCount ^Int, :Disposal ^(vector-of Int), :Config ^{:ColorModel ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12), :Width ^Int, :Height ^Int}, :BackgroundIndex ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeAll(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/gif.DecodeConfig:
;; (defn DecodeConfig
;;   "DecodeConfig returns the global color model and dimensions of a GIF image\nwithout decoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (struct {ColorModel ...; Width int; Height int}, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12), :Width ^Int, :Height ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/gif.Encode:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in GIF format.\n\nGo input arguments: (w io.Writer, m image.Image, o *image/gif.Options)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^image.Image m, ^(atom-of image/gif.Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.Encode(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ABEND904(custom-runtime routine not implemented: image.Image(_m)), ConvertToIndirectOfimage/gif.Options(ABEND904(custom-runtime routine not implemented: image/gif.Options(_o))))"}
;;   [^io.Writer _w, ^image.Image _m, ^Object _o])

JOKER FUNC image/gif.EncodeAll:
;; (defn ^"Error" EncodeAll
;;   "EncodeAll writes the images in g to w in GIF format with the\ngiven loop count and delay between frames.\n\nGo input arguments: (w io.Writer, g *image/gif.GIF)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^(atom-of image/gif.GIF) g]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "gif.EncodeAll(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToIndirectOfimage/gif.GIF(ABEND904(custom-runtime routine not implemented: image/gif.GIF(_g))))"}
;;   [^io.Writer _w, ^Object _g])

JOKER FUNC image/jpeg.Decode:
;; (defn Decode
;;   "Decode reads a JPEG image from r and returns it as an image.Image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/image.go:36:12) Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/jpeg.DecodeConfig:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a JPEG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (struct {ColorModel ...; Width int; Height int}, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12), :Width ^Int, :Height ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/jpeg.Encode:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in JPEG 4:2:0 baseline format with the given\noptions. Default parameters are used if a nil *Options is passed.\n\nGo input arguments: (w io.Writer, m image.Image, o *image/jpeg.Options)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^image.Image m, ^(atom-of image/jpeg.Options) o]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "jpeg.Encode(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ABEND904(custom-runtime routine not implemented: image.Image(_m)), ConvertToIndirectOfimage/jpeg.Options(ABEND904(custom-runtime routine not implemented: image/jpeg.Options(_o))))"}
;;   [^io.Writer _w, ^image.Image _m, ^Object _o])

JOKER FUNC image/png.Decode:
;; (defn Decode
;;   "Decode reads a PNG image from r and returns it as an image.Image.\nThe type of Image returned depends on the PNG contents.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (..., error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/image.go:36:12) Error]"
;;   {:added "1.0"
;;    :go "decode(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/png.DecodeConfig:
;; (defn DecodeConfig
;;   "DecodeConfig returns the color model and dimensions of a PNG image without\ndecoding the entire image.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (struct {ColorModel ...; Width int; Height int}, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:ColorModel ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/image/color/color.go:142:12), :Width ^Int, :Height ^Int} Error]"
;;   {:added "1.0"
;;    :go "decodeConfig(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC image/png.Encode:
;; (defn ^"Error" Encode
;;   "Encode writes the Image m to w in PNG format. Any Image may be\nencoded, but images that are not image.NRGBA might be encoded lossily.\n\nGo input arguments: (w io.Writer, m image.Image)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w, ^image.Image m]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "png.Encode(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ABEND904(custom-runtime routine not implemented: image.Image(_m)))"}
;;   [^io.Writer _w, ^image.Image _m])

JOKER FUNC index/suffixarray.New:
;; (defn New
;;   "New creates a new Index for data.\nIndex creation time is O(N*log(N)) for N = len(data).\n\nGo input arguments: (data []byte)\n\nGo return type: *Index\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(ConvertToArrayOfByte(_data)))"}
;;   [^Object _data])

JOKER FUNC io.Copy:
;; (defn Copy
;;   "Copy copies from src to dst until either EOF is reached\non src or an error occurs. It returns the number of bytes\ncopied and the first error encountered while copying, if any.\n\nA successful Copy returns err == nil, not err == EOF.\nBecause Copy is defined to read from src until EOF, it does\nnot treat an EOF from Read as an error to be reported.\n\nIf src implements the WriterTo interface,\nthe copy is implemented by calling src.WriteTo(dst).\nOtherwise, if dst implements the ReaderFrom interface,\nthe copy is implemented by calling dst.ReadFrom(src).\n\nGo input arguments: (dst io.Writer, src io.Reader)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^io.Writer dst, ^io.Reader src]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copy(ABEND904(custom-runtime routine not implemented: io.Writer(_dst)), ABEND904(custom-runtime routine not implemented: io.Reader(_src)))"}
;;   [^io.Writer _dst, ^io.Reader _src])

JOKER FUNC io.CopyBuffer:
;; (defn CopyBuffer
;;   "CopyBuffer is identical to Copy except that it stages through the\nprovided buffer (if one is required) rather than allocating a\ntemporary one. If buf is nil, one is allocated; otherwise if it has\nzero length, CopyBuffer panics.\n\nGo input arguments: (dst io.Writer, src io.Reader, buf []byte)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^io.Writer dst, ^io.Reader src, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copyBuffer(ABEND904(custom-runtime routine not implemented: io.Writer(_dst)), ABEND904(custom-runtime routine not implemented: io.Reader(_src)), ConvertToArrayOfByte(_buf))"}
;;   [^io.Writer _dst, ^io.Reader _src, ^Object _buf])

JOKER FUNC io.CopyN:
;; (defn CopyN
;;   "CopyN copies n bytes (or until an error) from src to dst.\nIt returns the number of bytes copied and the earliest\nerror encountered while copying.\nOn return, written == n if and only if err == nil.\n\nIf dst implements the ReaderFrom interface,\nthe copy is implemented using it.\n\nGo input arguments: (dst io.Writer, src io.Reader, n int64)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^io.Writer dst, ^io.Reader src, ^Int64 n]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "copyN(ABEND904(custom-runtime routine not implemented: io.Writer(_dst)), ABEND904(custom-runtime routine not implemented: io.Reader(_src)), _n)"}
;;   [^io.Writer _dst, ^io.Reader _src, ^Int64 _n])

JOKER FUNC io.LimitReader:
;; (defn LimitReader
;;   "LimitReader returns a Reader that reads from r\nbut stops with EOF after n bytes.\nThe underlying implementation is a *LimitedReader.\n\nGo input arguments: (r io.Reader, n int64)\n\nGo return type: Reader\n\nJoker input arguments: [^io.Reader r, ^Int64 n]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "limitReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), _n)"}
;;   [^io.Reader _r, ^Int64 _n])

JOKER FUNC io.MultiReader:
;; (defn MultiReader
;;   "MultiReader returns a Reader that's the logical concatenation of\nthe provided input readers. They're read sequentially. Once all\ninputs have returned EOF, Read will return EOF.  If any of the readers\nreturn a non-nil, non-EOF error, Read will return that error.\n\nGo input arguments: (readers ...io.Reader)\n\nGo return type: Reader\n\nJoker input arguments: [^(ellipsis-somehow io.Reader) readers]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "multiReader(ConvertToEllipsisHaHaio.Reader(ABEND904(custom-runtime routine not implemented: io.Reader(_readers))))"}
;;   [^io.Reader _readers])

JOKER FUNC io.MultiWriter:
;; (defn MultiWriter
;;   "MultiWriter creates a writer that duplicates its writes to all the\nprovided writers, similar to the Unix tee(1) command.\n\nEach write is written to each listed writer, one at a time.\nIf a listed writer returns an error, that overall write operation\nstops and returns the error; it does not continue down the list.\n\nGo input arguments: (writers ...io.Writer)\n\nGo return type: Writer\n\nJoker input arguments: [^(ellipsis-somehow io.Writer) writers]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "multiWriter(ConvertToEllipsisHaHaio.Writer(ABEND904(custom-runtime routine not implemented: io.Writer(_writers))))"}
;;   [^io.Writer _writers])

JOKER FUNC io.NewSectionReader:
;; (defn NewSectionReader
;;   "NewSectionReader returns a SectionReader that reads from r\nstarting at offset off and stops with EOF after n bytes.\n\nGo input arguments: (r io.ReaderAt, off int64, n int64)\n\nGo return type: *SectionReader\n\nJoker input arguments: [^io.ReaderAt r, ^Int64 off, ^Int64 n]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSectionReader(ABEND904(custom-runtime routine not implemented: io.ReaderAt(_r)), _off, _n))"}
;;   [^io.ReaderAt _r, ^Int64 _off, ^Int64 _n])

JOKER FUNC io.Pipe:
;; (defn Pipe
;;   "Pipe creates a synchronous in-memory pipe.\nIt can be used to connect code expecting an io.Reader\nwith code expecting an io.Writer.\n\nReads and Writes on the pipe are matched one to one\nexcept when multiple Reads are needed to consume a single Write.\nThat is, each Write to the PipeWriter blocks until it has satisfied\none or more Reads from the PipeReader that fully consume\nthe written data.\nThe data is copied directly from the Write to the corresponding\nRead (or Reads); there is no internal buffering.\n\nIt is safe to call Read and Write in parallel with each other or with Close.\nParallel calls to Read and parallel calls to Write are also safe:\nthe individual calls will be gated sequentially.\n\nGo return type: (*PipeReader, *PipeWriter)\n\nJoker input arguments: []\n\nJoker return type: [{} {}]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC io.ReadAtLeast:
;; (defn ReadAtLeast
;;   "ReadAtLeast reads from r into buf until it has read at least min bytes.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading fewer than min bytes,\nReadAtLeast returns ErrUnexpectedEOF.\nIf min is greater than the length of buf, ReadAtLeast returns ErrShortBuffer.\nOn return, n >= min if and only if err == nil.\nIf r returns an error having read at least min bytes, the error is dropped.\n\nGo input arguments: (r io.Reader, buf []byte, min int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Reader r, ^(vector-of Byte) buf, ^Int min]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readAtLeast(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToArrayOfByte(_buf), _min)"}
;;   [^io.Reader _r, ^Object _buf, ^Int _min])

JOKER FUNC io.ReadFull:
;; (defn ReadFull
;;   "ReadFull reads exactly len(buf) bytes from r into buf.\nIt returns the number of bytes copied and an error if fewer bytes were read.\nThe error is EOF only if no bytes were read.\nIf an EOF happens after reading some but not all the bytes,\nReadFull returns ErrUnexpectedEOF.\nOn return, n == len(buf) if and only if err == nil.\nIf r returns an error having read at least len(buf) bytes, the error is dropped.\n\nGo input arguments: (r io.Reader, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Reader r, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "readFull(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ConvertToArrayOfByte(_buf))"}
;;   [^io.Reader _r, ^Object _buf])

JOKER FUNC io.TeeReader:
;; (defn TeeReader
;;   "TeeReader returns a Reader that writes to w what it reads from r.\nAll reads from r performed through it are matched with\ncorresponding writes to w. There is no internal buffering -\nthe write must complete before the read completes.\nAny error encountered while writing is reported as a read error.\n\nGo input arguments: (r io.Reader, w io.Writer)\n\nGo return type: Reader\n\nJoker input arguments: [^io.Reader r, ^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "teeReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Reader _r, ^io.Writer _w])

JOKER FUNC io.WriteString:
;; (defn WriteString
;;   "WriteString writes the contents of the string s to w, which accepts a slice of bytes.\nIf w implements a WriteString method, it is invoked directly.\nOtherwise, w.Write is called exactly once.\n\nGo input arguments: (w io.Writer, s string)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^io.Writer w, ^String s]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "writeString(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _s)"}
;;   [^io.Writer _w, ^String _s])

JOKER FUNC io/ioutil.NopCloser:
;; (defn NopCloser
;;   "NopCloser returns a ReadCloser with a no-op Close method wrapping\nthe provided Reader r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17)"
;;   {:added "1.0"
;;    :go "nopCloser(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC io/ioutil.ReadAll:
;; (defn ReadAll
;;   "ReadAll reads from r until an error or EOF and returns the data it read.\nA successful call returns err == nil, not err == EOF. Because ReadAll is\ndefined to read from src until EOF, it does not treat an EOF from Read\nas an error to be reported.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "readAll(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC io/ioutil.ReadDir:
;; (defn ReadDir
;;   "ReadDir reads the directory named by dirname and returns\na list of directory entries sorted by filename.\n\nGo input arguments: (dirname string)\n\nGo return type: ([]..., error)\n\nJoker input arguments: [^String dirname]\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/os/types.go:21:15)) Error]"
;;   {:added "1.0"
;;    :go "readDir(_dirname)"}
;;   [^String _dirname])

JOKER FUNC io/ioutil.ReadFile:
(defn ReadFile
  "ReadFile reads the file named by filename and returns the contents.\nA successful call returns err == nil, not err == EOF. Because ReadFile\nreads the whole file, it does not treat an EOF from Read as an error\nto be reported.\n\nGo input arguments: (filename string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^String filename]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "readFile(_filename)"}
  [^String _filename])

JOKER FUNC io/ioutil.TempDir:
(defn TempDir
  "TempDir creates a new temporary directory in the directory dir\nwith a name beginning with prefix and returns the path of the\nnew directory. If dir is the empty string, TempDir uses the\ndefault directory for temporary files (see os.TempDir).\nMultiple programs calling TempDir simultaneously\nwill not choose the same directory. It is the caller's responsibility\nto remove the directory when no longer needed.\n\nGo input arguments: (dir string, prefix string)\n\nGo return type: (name string, err error)\n\nJoker input arguments: [^String dir, ^String prefix]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "tempDir(_dir, _prefix)"}
  [^String _dir, ^String _prefix])

JOKER FUNC io/ioutil.TempFile:
(defn TempFile
  "TempFile creates a new temporary file in the directory dir,\nopens the file for reading and writing, and returns the resulting *os.File.\nThe filename is generated by taking pattern and adding a random\nstring to the end. If pattern includes a \"*\", the random string\nreplaces the last \"*\".\nIf dir is the empty string, TempFile uses the default directory\nfor temporary files (see os.TempDir).\nMultiple programs calling TempFile simultaneously\nwill not choose the same file. The caller can use f.Name()\nto find the pathname of the file. It is the caller's responsibility\nto remove the file when no longer needed.\n\nGo input arguments: (dir string, pattern string)\n\nGo return type: (f *struct {}, err error)\n\nJoker input arguments: [^String dir, ^String pattern]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "tempFile(_dir, _pattern)"}
  [^String _dir, ^String _pattern])

JOKER FUNC io/ioutil.WriteFile:
;; (defn ^"Error" WriteFile
;;   "WriteFile writes data to a file named by filename.\nIf the file does not exist, WriteFile creates it with permissions perm;\notherwise WriteFile truncates it before writing.\n\nGo input arguments: (filename string, data []byte, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String filename, ^(vector-of Byte) data, ^os.FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "ioutil.WriteFile(_filename, ConvertToArrayOfByte(_data), ABEND904(custom-runtime routine not implemented: os.FileMode(_perm)))"}
;;   [^String _filename, ^Object _data, ^os.FileMode _perm])

JOKER FUNC log.Fatal:
;; (defn Fatal
;;   "Fatal is equivalent to Print() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatal(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Fatalf:
;; (defn Fatalf
;;   "Fatalf is equivalent to Printf() followed by a call to os.Exit(1).\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatalf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Fatalln:
;; (defn Fatalln
;;   "Fatalln is equivalent to Println() followed by a call to os.Exit(1).\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "fatalln(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Flags:
(defn ^"Int" Flags
  "Flags returns the output flags for the standard logger.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "log.Flags()"}
  [])

JOKER FUNC log.New:
;; (defn New
;;   "New creates a new Logger. The out variable sets the\ndestination to which log data will be written.\nThe prefix appears at the beginning of each generated log line.\nThe flag argument defines the logging properties.\n\nGo input arguments: (out io.Writer, prefix string, flag int)\n\nGo return type: *Logger\n\nJoker input arguments: [^io.Writer out, ^String prefix, ^Int flag]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(ABEND904(custom-runtime routine not implemented: io.Writer(_out)), _prefix, _flag))"}
;;   [^io.Writer _out, ^String _prefix, ^Int _flag])

JOKER FUNC log.Output:
(defn ^"Error" Output
  "Output writes the output for a logging event. The string s contains\nthe text to print after the prefix specified by the flags of the\nLogger. A newline is appended if the last character of s is not\nalready a newline. Calldepth is the count of the number of\nframes to skip when computing the file name and line number\nif Llongfile or Lshortfile is set; a value of 1 will print the details\nfor the caller of Output.\n\nGo input arguments: (calldepth int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int calldepth, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "log.Output(_calldepth, _s)"}
  [^Int _calldepth, ^String _s])

JOKER FUNC log.Panic:
;; (defn Panic
;;   "Panic is equivalent to Print() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "panic(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Panicf:
;; (defn Panicf
;;   "Panicf is equivalent to Printf() followed by a call to panic().\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "panicf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Panicln:
;; (defn Panicln
;;   "Panicln is equivalent to Println() followed by a call to panic().\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "panicln(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Prefix:
(defn ^"String" Prefix
  "Prefix returns the output prefix for the standard logger.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "log.Prefix()"}
  [])

JOKER FUNC log.Print:
;; (defn Print
;;   "Print calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Print.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "print(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.Printf:
;; (defn Printf
;;   "Printf calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Printf.\n\nGo input arguments: (format string, v ...interface {})\n\nJoker input arguments: [^String format, ^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "printf(_format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^String _format, ^<protocol-or-something> _v])

JOKER FUNC log.Println:
;; (defn Println
;;   "Println calls Output to print to the standard logger.\nArguments are handled in the manner of fmt.Println.\n\nGo input arguments: (v ...interface {})\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) v]"
;;   {:added "1.0"
;;    :go "println(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _v])

JOKER FUNC log.SetFlags:
;; (defn SetFlags
;;   "SetFlags sets the output flags for the standard logger.\n\nGo input arguments: (flag int)\n\nJoker input arguments: [^Int flag]"
;;   {:added "1.0"
;;    :go "setFlags(_flag)"}
;;   [^Int _flag])

JOKER FUNC log.SetOutput:
;; (defn SetOutput
;;   "SetOutput sets the output destination for the standard logger.\n\nGo input arguments: (w io.Writer)\n\nJoker input arguments: [^io.Writer w]"
;;   {:added "1.0"
;;    :go "setOutput(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC log.SetPrefix:
;; (defn SetPrefix
;;   "SetPrefix sets the output prefix for the standard logger.\n\nGo input arguments: (prefix string)\n\nJoker input arguments: [^String prefix]"
;;   {:added "1.0"
;;    :go "setPrefix(_prefix)"}
;;   [^String _prefix])

JOKER FUNC log/syslog.Dial:
;; (defn Dial
;;   "Dial establishes a connection to a log daemon by connecting to\naddress raddr on the specified network. Each write to the returned\nwriter sends a log message with the facility and severity\n(from priority) and tag. If tag is empty, the os.Args[0] is used.\nIf network is empty, Dial will connect to the local syslog server.\nOtherwise, see the documentation for net.Dial for valid values\nof network and raddr.\n\nGo input arguments: (network string, raddr string, priority log/syslog.Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^String network, ^String raddr, ^log/syslog.Priority priority, ^String tag]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _raddr, ABEND904(custom-runtime routine not implemented: log/syslog.Priority(_priority)), _tag)"}
;;   [^String _network, ^String _raddr, ^log/syslog.Priority _priority, ^String _tag])

JOKER FUNC log/syslog.New:
;; (defn New
;;   "New establishes a new connection to the system log daemon. Each\nwrite to the returned writer sends a log message with the given\npriority (a combination of the syslog facility and severity) and\nprefix tag. If tag is empty, the os.Args[0] is used.\n\nGo input arguments: (priority log/syslog.Priority, tag string)\n\nGo return type: (*Writer, error)\n\nJoker input arguments: [^log/syslog.Priority priority, ^String tag]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(ABEND904(custom-runtime routine not implemented: log/syslog.Priority(_priority)), _tag)"}
;;   [^log/syslog.Priority _priority, ^String _tag])

JOKER FUNC log/syslog.NewLogger:
;; (defn NewLogger
;;   "NewLogger creates a log.Logger whose output is written to the\nsystem log service with the specified priority, a combination of\nthe syslog facility and severity. The logFlag argument is the flag\nset passed through to log.New to create the Logger.\n\nGo input arguments: (p log/syslog.Priority, logFlag int)\n\nGo return type: (*struct {}, error)\n\nJoker input arguments: [^log/syslog.Priority p, ^Int logFlag]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "newLogger(ABEND904(custom-runtime routine not implemented: log/syslog.Priority(_p)), _logFlag)"}
;;   [^log/syslog.Priority _p, ^Int _logFlag])

JOKER FUNC math.Abs:
;; (defn Abs
;;   "Abs returns the absolute value of x.\n\nSpecial cases are:\n\tAbs(Inf) = +Inf\n\tAbs(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "abs(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Acos:
;; (defn Acos
;;   "Acos returns the arccosine, in radians, of x.\n\nSpecial case is:\n\tAcos(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "acos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Acosh:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nSpecial cases are:\n\tAcosh(+Inf) = +Inf\n\tAcosh(x) = NaN if x < 1\n\tAcosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "acosh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Asin:
;; (defn Asin
;;   "Asin returns the arcsine, in radians, of x.\n\nSpecial cases are:\n\tAsin(0) = 0\n\tAsin(x) = NaN if x < -1 or x > 1\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "asin(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Asinh:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nSpecial cases are:\n\tAsinh(0) = 0\n\tAsinh(Inf) = Inf\n\tAsinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "asinh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atan:
;; (defn Atan
;;   "Atan returns the arctangent, in radians, of x.\n\nSpecial cases are:\n     Atan(0) = 0\n     Atan(Inf) = Pi/2\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atan(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atan2:
;; (defn Atan2
;;   "Atan2 returns the arc tangent of y/x, using\nthe signs of the two to determine the quadrant\nof the return value.\n\nSpecial cases are (in order):\n\tAtan2(y, NaN) = NaN\n\tAtan2(NaN, x) = NaN\n\tAtan2(+0, x>=0) = +0\n\tAtan2(-0, x>=0) = -0\n\tAtan2(+0, x<=-0) = +Pi\n\tAtan2(-0, x<=-0) = -Pi\n\tAtan2(y>0, 0) = +Pi/2\n\tAtan2(y<0, 0) = -Pi/2\n\tAtan2(+Inf, +Inf) = +Pi/4\n\tAtan2(-Inf, +Inf) = -Pi/4\n\tAtan2(+Inf, -Inf) = 3Pi/4\n\tAtan2(-Inf, -Inf) = -3Pi/4\n\tAtan2(y, +Inf) = 0\n\tAtan2(y>0, -Inf) = +Pi\n\tAtan2(y<0, -Inf) = -Pi\n\tAtan2(+Inf, x) = +Pi/2\n\tAtan2(-Inf, x) = -Pi/2\n\nGo input arguments: (y float64, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 y, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atan2(_y, _x)"}
;;   [^ABEND044(unsupported built-in type float64) _y, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Atanh:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nSpecial cases are:\n\tAtanh(1) = +Inf\n\tAtanh(0) = 0\n\tAtanh(-1) = -Inf\n\tAtanh(x) = NaN if x < -1 or x > 1\n\tAtanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "atanh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Cbrt:
;; (defn Cbrt
;;   "Cbrt returns the cube root of x.\n\nSpecial cases are:\n\tCbrt(0) = 0\n\tCbrt(Inf) = Inf\n\tCbrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cbrt(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Ceil:
;; (defn Ceil
;;   "Ceil returns the least integer value greater than or equal to x.\n\nSpecial cases are:\n\tCeil(0) = 0\n\tCeil(Inf) = Inf\n\tCeil(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "ceil(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Copysign:
;; (defn Copysign
;;   "Copysign returns a value with the magnitude\nof x and the sign of y.\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "copysign(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Cos:
;; (defn Cos
;;   "Cos returns the cosine of the radian argument x.\n\nSpecial cases are:\n\tCos(Inf) = NaN\n\tCos(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Cosh:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nSpecial cases are:\n\tCosh(0) = 1\n\tCosh(Inf) = +Inf\n\tCosh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "cosh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Dim:
;; (defn Dim
;;   "Dim returns the maximum of x-y or 0.\n\nSpecial cases are:\n\tDim(+Inf, +Inf) = NaN\n\tDim(-Inf, -Inf) = NaN\n\tDim(x, NaN) = Dim(NaN, x) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "dim(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Erf:
;; (defn Erf
;;   "Erf returns the error function of x.\n\nSpecial cases are:\n\tErf(+Inf) = 1\n\tErf(-Inf) = -1\n\tErf(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erf(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfc:
;; (defn Erfc
;;   "Erfc returns the complementary error function of x.\n\nSpecial cases are:\n\tErfc(+Inf) = 0\n\tErfc(-Inf) = 2\n\tErfc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfc(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfcinv:
;; (defn Erfcinv
;;   "Erfcinv returns the inverse of Erfc(x).\n\nSpecial cases are:\n\tErfcinv(0) = +Inf\n\tErfcinv(2) = -Inf\n\tErfcinv(x) = NaN if x < 0 or x > 2\n\tErfcinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfcinv(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Erfinv:
;; (defn Erfinv
;;   "Erfinv returns the inverse error function of x.\n\nSpecial cases are:\n\tErfinv(1) = +Inf\n\tErfinv(-1) = -Inf\n\tErfinv(x) = NaN if x < -1 or x > 1\n\tErfinv(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "erfinv(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Exp:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nSpecial cases are:\n\tExp(+Inf) = +Inf\n\tExp(NaN) = NaN\nVery large values overflow to 0 or +Inf.\nVery small values underflow to 1.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "exp(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Exp2:
;; (defn Exp2
;;   "Exp2 returns 2**x, the base-2 exponential of x.\n\nSpecial cases are the same as Exp.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "exp2(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Expm1:
;; (defn Expm1
;;   "Expm1 returns e**x - 1, the base-e exponential of x minus 1.\nIt is more accurate than Exp(x) - 1 when x is near zero.\n\nSpecial cases are:\n\tExpm1(+Inf) = +Inf\n\tExpm1(-Inf) = -1\n\tExpm1(NaN) = NaN\nVery large values overflow to -1 or +Inf.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "expm1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Float32bits:
;; (defn ^"Int" Float32bits
;;   "Float32bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float32)\n\nGo return type: int\n\nJoker input arguments: [^float32 f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(math.Float32bits(_f))"}
;;   [^ABEND044(unsupported built-in type float32) _f])

JOKER FUNC math.Float32frombits:
;; (defn Float32frombits
;;   "Float32frombits returns the floating point number corresponding\nto the IEEE 754 binary representation b.\n\nGo input arguments: (b uint32)\n\nGo return type: ...\n\nJoker input arguments: [^UInt32 b]\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "float32frombits(_b)"}
;;   [^UInt32 _b])

JOKER FUNC math.Float64bits:
;; (defn Float64bits
;;   "Float64bits returns the IEEE 754 binary representation of f.\n\nGo input arguments: (f float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 f]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "float64bits(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.Float64frombits:
;; (defn Float64frombits
;;   "Float64frombits returns the floating point number corresponding\nthe IEEE 754 binary representation b.\n\nGo input arguments: (b uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 b]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "float64frombits(_b)"}
;;   [^ABEND044(unsupported built-in type uint64) _b])

JOKER FUNC math.Floor:
;; (defn Floor
;;   "Floor returns the greatest integer value less than or equal to x.\n\nSpecial cases are:\n\tFloor(0) = 0\n\tFloor(Inf) = Inf\n\tFloor(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "floor(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Frexp:
;; (defn Frexp
;;   "Frexp breaks f into a normalized fraction\nand an integral power of two.\nIt returns frac and exp satisfying f == frac  2**exp,\nwith the absolute value of frac in the interval [, 1).\n\nSpecial cases are:\n\tFrexp(0) = 0, 0\n\tFrexp(Inf) = Inf, 0\n\tFrexp(NaN) = NaN, 0\n\nGo input arguments: (f float64)\n\nGo return type: (frac ..., exp int)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "frexp(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.Gamma:
;; (defn Gamma
;;   "Gamma returns the Gamma function of x.\n\nSpecial cases are:\n\tGamma(+Inf) = +Inf\n\tGamma(+0) = +Inf\n\tGamma(-0) = -Inf\n\tGamma(x) = NaN for integer x < 0\n\tGamma(-Inf) = NaN\n\tGamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "gamma(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Hypot:
;; (defn Hypot
;;   "Hypot returns Sqrt(p*p + q*q), taking care to avoid\nunnecessary overflow and underflow.\n\nSpecial cases are:\n\tHypot(Inf, q) = +Inf\n\tHypot(p, Inf) = +Inf\n\tHypot(NaN, q) = NaN\n\tHypot(p, NaN) = NaN\n\nGo input arguments: (p float64, q float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 p, ^float64 q]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "hypot(_p, _q)"}
;;   [^ABEND044(unsupported built-in type float64) _p, ^ABEND044(unsupported built-in type float64) _q])

JOKER FUNC math.Ilogb:
;; (defn ^"Int" Ilogb
;;   "Ilogb returns the binary exponent of x as an integer.\n\nSpecial cases are:\n\tIlogb(Inf) = MaxInt32\n\tIlogb(0) = MinInt32\n\tIlogb(NaN) = MaxInt32\n\nGo input arguments: (x float64)\n\nGo return type: int\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "math.Ilogb(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Inf:
;; (defn Inf
;;   "Inf returns positive infinity if sign >= 0, negative infinity if sign < 0.\n\nGo input arguments: (sign int)\n\nGo return type: ...\n\nJoker input arguments: [^Int sign]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "inf(_sign)"}
;;   [^Int _sign])

JOKER FUNC math.IsInf:
;; (defn ^"Bool" IsInf
;;   "IsInf reports whether f is an infinity, according to sign.\nIf sign > 0, IsInf reports whether f is positive infinity.\nIf sign < 0, IsInf reports whether f is negative infinity.\nIf sign == 0, IsInf reports whether f is either infinity.\n\nGo input arguments: (f float64, sign int)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f, ^Int sign]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsInf(_f, _sign)"}
;;   [^ABEND044(unsupported built-in type float64) _f, ^Int _sign])

JOKER FUNC math.IsNaN:
;; (defn ^"Bool" IsNaN
;;   "IsNaN reports whether f is an IEEE 754 ``not-a-number'' value.\n\nGo input arguments: (f float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 f]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.IsNaN(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.J0:
;; (defn J0
;;   "J0 returns the order-zero Bessel function of the first kind.\n\nSpecial cases are:\n\tJ0(Inf) = 0\n\tJ0(0) = 1\n\tJ0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "j0(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.J1:
;; (defn J1
;;   "J1 returns the order-one Bessel function of the first kind.\n\nSpecial cases are:\n\tJ1(Inf) = 0\n\tJ1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "j1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Jn:
;; (defn Jn
;;   "Jn returns the order-n Bessel function of the first kind.\n\nSpecial cases are:\n\tJn(n, Inf) = 0\n\tJn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "jn(_n, _x)"}
;;   [^Int _n, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Ldexp:
;; (defn Ldexp
;;   "Ldexp is the inverse of Frexp.\nIt returns frac  2**exp.\n\nSpecial cases are:\n\tLdexp(0, exp) = 0\n\tLdexp(Inf, exp) = Inf\n\tLdexp(NaN, exp) = NaN\n\nGo input arguments: (frac float64, exp int)\n\nGo return type: ...\n\nJoker input arguments: [^float64 frac, ^Int exp]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "ldexp(_frac, _exp)"}
;;   [^ABEND044(unsupported built-in type float64) _frac, ^Int _exp])

JOKER FUNC math.Lgamma:
;; (defn Lgamma
;;   "Lgamma returns the natural logarithm and sign (-1 or +1) of Gamma(x).\n\nSpecial cases are:\n\tLgamma(+Inf) = +Inf\n\tLgamma(0) = +Inf\n\tLgamma(-integer) = +Inf\n\tLgamma(-Inf) = -Inf\n\tLgamma(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: (lgamma ..., sign int)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Int]"
;;   {:added "1.0"
;;    :go "lgamma(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nSpecial cases are:\n\tLog(+Inf) = +Inf\n\tLog(0) = -Inf\n\tLog(x < 0) = NaN\n\tLog(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log10:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log10(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log1p:
;; (defn Log1p
;;   "Log1p returns the natural logarithm of 1 plus its argument x.\nIt is more accurate than Log(1 + x) when x is near zero.\n\nSpecial cases are:\n\tLog1p(+Inf) = +Inf\n\tLog1p(0) = 0\n\tLog1p(-1) = -Inf\n\tLog1p(x < -1) = NaN\n\tLog1p(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log1p(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Log2:
;; (defn Log2
;;   "Log2 returns the binary logarithm of x.\nThe special cases are the same as for Log.\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "log2(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Logb:
;; (defn Logb
;;   "Logb returns the binary exponent of x.\n\nSpecial cases are:\n\tLogb(Inf) = +Inf\n\tLogb(0) = -Inf\n\tLogb(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "logb(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Max:
;; (defn Max
;;   "Max returns the larger of x or y.\n\nSpecial cases are:\n\tMax(x, +Inf) = Max(+Inf, x) = +Inf\n\tMax(x, NaN) = Max(NaN, x) = NaN\n\tMax(+0, 0) = Max(0, +0) = +0\n\tMax(-0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "max(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Min:
;; (defn Min
;;   "Min returns the smaller of x or y.\n\nSpecial cases are:\n\tMin(x, -Inf) = Min(-Inf, x) = -Inf\n\tMin(x, NaN) = Min(NaN, x) = NaN\n\tMin(-0, 0) = Min(0, -0) = -0\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "min(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Mod:
;; (defn Mod
;;   "Mod returns the floating-point remainder of x/y.\nThe magnitude of the result is less than y and its\nsign agrees with that of x.\n\nSpecial cases are:\n\tMod(Inf, y) = NaN\n\tMod(NaN, y) = NaN\n\tMod(x, 0) = NaN\n\tMod(x, Inf) = x\n\tMod(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "mod(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Modf:
;; (defn Modf
;;   "Modf returns integer and fractional floating-point numbers\nthat sum to f. Both values have the same sign as f.\n\nSpecial cases are:\n\tModf(Inf) = Inf, NaN\n\tModf(NaN) = NaN, NaN\n\nGo input arguments: (f float64)\n\nGo return type: (int ..., frac ...)\n\nJoker input arguments: [^float64 f]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "modf(_f)"}
;;   [^ABEND044(unsupported built-in type float64) _f])

JOKER FUNC math.NaN:
;; (defn NaN
;;   "NaN returns an IEEE 754 ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math.Nextafter:
;; (defn Nextafter
;;   "Nextafter returns the next representable float64 value after x towards y.\n\nSpecial cases are:\n\tNextafter(x, x)   = x\n\tNextafter(NaN, y) = NaN\n\tNextafter(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "nextafter(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Nextafter32:
;; (defn Nextafter32
;;   "Nextafter32 returns the next representable float32 value after x towards y.\n\nSpecial cases are:\n\tNextafter32(x, x)   = x\n\tNextafter32(NaN, y) = NaN\n\tNextafter32(x, NaN) = NaN\n\nGo input arguments: (x float32, y float32)\n\nGo return type: ...\n\nJoker input arguments: [^float32 x, ^float32 y]\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "nextafter32(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float32) _x, ^ABEND044(unsupported built-in type float32) _y])

JOKER FUNC math.Pow:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\n\nSpecial cases are (in order):\n\tPow(x, 0) = 1 for any x\n\tPow(1, y) = 1 for any y\n\tPow(x, 1) = x for any x\n\tPow(NaN, y) = NaN\n\tPow(x, NaN) = NaN\n\tPow(0, y) = Inf for y an odd integer < 0\n\tPow(0, -Inf) = +Inf\n\tPow(0, +Inf) = +0\n\tPow(0, y) = +Inf for finite y < 0 and not an odd integer\n\tPow(0, y) = 0 for y an odd integer > 0\n\tPow(0, y) = +0 for finite y > 0 and not an odd integer\n\tPow(-1, Inf) = 1\n\tPow(x, +Inf) = +Inf for |x| > 1\n\tPow(x, -Inf) = +0 for |x| > 1\n\tPow(x, +Inf) = +0 for |x| < 1\n\tPow(x, -Inf) = +Inf for |x| < 1\n\tPow(+Inf, y) = +Inf for y > 0\n\tPow(+Inf, y) = +0 for y < 0\n\tPow(-Inf, y) = Pow(-0, -y)\n\tPow(x, y) = NaN for finite x < 0 and finite non-integer y\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "pow(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Pow10:
;; (defn Pow10
;;   "Pow10 returns 10**n, the base-10 exponential of n.\n\nSpecial cases are:\n\tPow10(n) =    0 for n < -323\n\tPow10(n) = +Inf for n > 308\n\nGo input arguments: (n int)\n\nGo return type: ...\n\nJoker input arguments: [^Int n]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "pow10(_n)"}
;;   [^Int _n])

JOKER FUNC math.Remainder:
;; (defn Remainder
;;   "Remainder returns the IEEE 754 floating-point remainder of x/y.\n\nSpecial cases are:\n\tRemainder(Inf, y) = NaN\n\tRemainder(NaN, y) = NaN\n\tRemainder(x, 0) = NaN\n\tRemainder(x, Inf) = x\n\tRemainder(x, NaN) = NaN\n\nGo input arguments: (x float64, y float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x, ^float64 y]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "remainder(_x, _y)"}
;;   [^ABEND044(unsupported built-in type float64) _x, ^ABEND044(unsupported built-in type float64) _y])

JOKER FUNC math.Round:
;; (defn Round
;;   "Round returns the nearest integer, rounding half away from zero.\n\nSpecial cases are:\n\tRound(0) = 0\n\tRound(Inf) = Inf\n\tRound(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "round(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.RoundToEven:
;; (defn RoundToEven
;;   "RoundToEven returns the nearest integer, rounding ties to even.\n\nSpecial cases are:\n\tRoundToEven(0) = 0\n\tRoundToEven(Inf) = Inf\n\tRoundToEven(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "roundToEven(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Signbit:
;; (defn ^"Bool" Signbit
;;   "Signbit returns true if x is negative or negative zero.\n\nGo input arguments: (x float64)\n\nGo return type: bool\n\nJoker input arguments: [^float64 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "math.Signbit(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sin:
;; (defn Sin
;;   "Sin returns the sine of the radian argument x.\n\nSpecial cases are:\n\tSin(0) = 0\n\tSin(Inf) = NaN\n\tSin(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sin(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sincos:
;; (defn Sincos
;;   "Sincos returns Sin(x), Cos(x).\n\nSpecial cases are:\n\tSincos(0) = 0, 1\n\tSincos(Inf) = NaN, NaN\n\tSincos(NaN) = NaN, NaN\n\nGo input arguments: (x float64)\n\nGo return type: (sin ..., cos ...)\n\nJoker input arguments: [^float64 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "sincos(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sinh:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nSpecial cases are:\n\tSinh(0) = 0\n\tSinh(Inf) = Inf\n\tSinh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sinh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Sqrt:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\n\nSpecial cases are:\n\tSqrt(+Inf) = +Inf\n\tSqrt(0) = 0\n\tSqrt(x < 0) = NaN\n\tSqrt(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "sqrt(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Tan:
;; (defn Tan
;;   "Tan returns the tangent of the radian argument x.\n\nSpecial cases are:\n\tTan(0) = 0\n\tTan(Inf) = NaN\n\tTan(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "tan(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Tanh:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nSpecial cases are:\n\tTanh(0) = 0\n\tTanh(Inf) = 1\n\tTanh(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "tanh(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Trunc:
;; (defn Trunc
;;   "Trunc returns the integer value of x.\n\nSpecial cases are:\n\tTrunc(0) = 0\n\tTrunc(Inf) = Inf\n\tTrunc(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "trunc(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Y0:
;; (defn Y0
;;   "Y0 returns the order-zero Bessel function of the second kind.\n\nSpecial cases are:\n\tY0(+Inf) = 0\n\tY0(0) = -Inf\n\tY0(x < 0) = NaN\n\tY0(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "y0(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Y1:
;; (defn Y1
;;   "Y1 returns the order-one Bessel function of the second kind.\n\nSpecial cases are:\n\tY1(+Inf) = 0\n\tY1(0) = -Inf\n\tY1(x < 0) = NaN\n\tY1(NaN) = NaN\n\nGo input arguments: (x float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "y1(_x)"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math.Yn:
;; (defn Yn
;;   "Yn returns the order-n Bessel function of the second kind.\n\nSpecial cases are:\n\tYn(n, +Inf) = 0\n\tYn(n  0, 0) = -Inf\n\tYn(n < 0, 0) = +Inf if n is odd, -Inf if n is even\n\tYn(n, x < 0) = NaN\n\tYn(n, NaN) = NaN\n\nGo input arguments: (n int, x float64)\n\nGo return type: ...\n\nJoker input arguments: [^Int n, ^float64 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "yn(_n, _x)"}
;;   [^Int _n, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math/big.Jacobi:
;; (defn ^"Int" Jacobi
;;   "Jacobi returns the Jacobi symbol (x/y), either +1, -1, or 0.\nThe y argument must be an odd integer.\n\nGo input arguments: (x *math/big.Int, y *math/big.Int)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of math/big.Int) x, ^(atom-of math/big.Int) y]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "big.Jacobi(ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_x))), ConvertToIndirectOfmath/big.Int(ABEND904(custom-runtime routine not implemented: math/big.Int(_y))))"}
;;   [^Object _x, ^Object _y])

JOKER FUNC math/big.NewFloat:
;; (defn NewFloat
;;   "NewFloat allocates and returns a new Float set to x,\nwith precision 53 and rounding mode ToNearestEven.\nNewFloat panics with ErrNaN if x is a NaN.\n\nGo input arguments: (x float64)\n\nGo return type: *Float\n\nJoker input arguments: [^float64 x]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFloat(_x))"}
;;   [^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC math/big.NewInt:
;; (defn NewInt
;;   "NewInt allocates and returns a new Int set to x.\n\nGo input arguments: (x int64)\n\nGo return type: *Int\n\nJoker input arguments: [^Int64 x]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newInt(_x))"}
;;   [^Int64 _x])

JOKER FUNC math/big.NewRat:
;; (defn NewRat
;;   "NewRat creates a new Rat with numerator a and denominator b.\n\nGo input arguments: (a int64, b int64)\n\nGo return type: *Rat\n\nJoker input arguments: [^Int64 a, ^Int64 b]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRat(_a, _b))"}
;;   [^Int64 _a, ^Int64 _b])

JOKER FUNC math/big.ParseFloat:
;; (defn ParseFloat
;;   "ParseFloat is like f.Parse(s, base) with f set to the given precision\nand rounding mode.\n\nGo input arguments: (s string, base int, prec uint, mode math/big.RoundingMode)\n\nGo return type: (f *Float, b int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^UInt prec, ^math/big.RoundingMode mode]\n\nJoker return type: [{} Int Error]"
;;   {:added "1.0"
;;    :go "parseFloat(_s, _base, _prec, ABEND904(custom-runtime routine not implemented: math/big.RoundingMode(_mode)))"}
;;   [^String _s, ^Int _base, ^UInt _prec, ^math/big.RoundingMode _mode])

JOKER FUNC math/bits.LeadingZeros:
(defn ^"Int" LeadingZeros
  "LeadingZeros returns the number of leading zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.LeadingZeros16:
(defn ^"Int" LeadingZeros16
  "LeadingZeros16 returns the number of leading zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.LeadingZeros32:
(defn ^"Int" LeadingZeros32
  "LeadingZeros32 returns the number of leading zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.LeadingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.LeadingZeros64:
;; (defn ^"Int" LeadingZeros64
;;   "LeadingZeros64 returns the number of leading zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.LeadingZeros8:
;; (defn ^"Int" LeadingZeros8
;;   "LeadingZeros8 returns the number of leading zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.LeadingZeros8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Len:
(defn ^"Int" Len
  "Len returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.Len16:
(defn ^"Int" Len16
  "Len16 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.Len32:
(defn ^"Int" Len32
  "Len32 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.Len32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.Len64:
;; (defn ^"Int" Len64
;;   "Len64 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Len8:
;; (defn ^"Int" Len8
;;   "Len8 returns the minimum number of bits required to represent x; the result is 0 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.Len8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.OnesCount:
(defn ^"Int" OnesCount
  "OnesCount returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.OnesCount16:
(defn ^"Int" OnesCount16
  "OnesCount16 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.OnesCount32:
(defn ^"Int" OnesCount32
  "OnesCount32 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.OnesCount32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.OnesCount64:
;; (defn ^"Int" OnesCount64
;;   "OnesCount64 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.OnesCount8:
;; (defn ^"Int" OnesCount8
;;   "OnesCount8 returns the number of one bits (\"population count\") in x.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.OnesCount8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.Reverse:
(defn ^"Int" Reverse
  "Reverse returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.Reverse(_x))"}
  [^UInt _x])

JOKER FUNC math/bits.Reverse16:
(defn ^"Int" Reverse16
  "Reverse16 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.Reverse16(_x))"}
  [^UInt16 _x])

JOKER FUNC math/bits.Reverse32:
(defn ^"Int" Reverse32
  "Reverse32 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.Reverse32(_x))"}
  [^UInt32 _x])

JOKER FUNC math/bits.Reverse64:
;; (defn Reverse64
;;   "Reverse64 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "reverse64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.Reverse8:
;; (defn Reverse8
;;   "Reverse8 returns the value of x with its bits in reversed order.\n\nGo input arguments: (x uint8)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "reverse8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/bits.ReverseBytes:
(defn ^"Int" ReverseBytes
  "ReverseBytes returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.ReverseBytes(_x))"}
  [^UInt _x])

JOKER FUNC math/bits.ReverseBytes16:
(defn ^"Int" ReverseBytes16
  "ReverseBytes16 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.ReverseBytes16(_x))"}
  [^UInt16 _x])

JOKER FUNC math/bits.ReverseBytes32:
(defn ^"Int" ReverseBytes32
  "ReverseBytes32 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.ReverseBytes32(_x))"}
  [^UInt32 _x])

JOKER FUNC math/bits.ReverseBytes64:
;; (defn ReverseBytes64
;;   "ReverseBytes64 returns the value of x with its bytes in reversed order.\n\nGo input arguments: (x uint64)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "reverseBytes64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.RotateLeft:
(defn ^"Int" RotateLeft
  "RotateLeft returns the value of x rotated left by (k mod UintSize) bits.\nTo rotate x right by k bits, call RotateLeft(x, -k).\n\nGo input arguments: (x uint, k int)\n\nGo return type: int\n\nJoker input arguments: [^UInt x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.RotateLeft(_x, _k))"}
  [^UInt _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft16:
(defn ^"Int" RotateLeft16
  "RotateLeft16 returns the value of x rotated left by (k mod 16) bits.\nTo rotate x right by k bits, call RotateLeft16(x, -k).\n\nGo input arguments: (x uint16, k int)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.RotateLeft16(_x, _k))"}
  [^UInt16 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft32:
(defn ^"Int" RotateLeft32
  "RotateLeft32 returns the value of x rotated left by (k mod 32) bits.\nTo rotate x right by k bits, call RotateLeft32(x, -k).\n\nGo input arguments: (x uint32, k int)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x, ^Int k]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(bits.RotateLeft32(_x, _k))"}
  [^UInt32 _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft64:
;; (defn RotateLeft64
;;   "RotateLeft64 returns the value of x rotated left by (k mod 64) bits.\nTo rotate x right by k bits, call RotateLeft64(x, -k).\n\nGo input arguments: (x uint64, k int)\n\nGo return type: ...\n\nJoker input arguments: [^uint64 x, ^Int k]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "rotateLeft64(_x, _k)"}
;;   [^ABEND044(unsupported built-in type uint64) _x, ^Int _k])

JOKER FUNC math/bits.RotateLeft8:
;; (defn RotateLeft8
;;   "RotateLeft8 returns the value of x rotated left by (k mod 8) bits.\nTo rotate x right by k bits, call RotateLeft8(x, -k).\n\nGo input arguments: (x uint8, k int)\n\nGo return type: ...\n\nJoker input arguments: [^uint8 x, ^Int k]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "rotateLeft8(_x, _k)"}
;;   [^ABEND044(unsupported built-in type uint8) _x, ^Int _k])

JOKER FUNC math/bits.TrailingZeros:
(defn ^"Int" TrailingZeros
  "TrailingZeros returns the number of trailing zero bits in x; the result is UintSize for x == 0.\n\nGo input arguments: (x uint)\n\nGo return type: int\n\nJoker input arguments: [^UInt x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros(_x)"}
  [^UInt _x])

JOKER FUNC math/bits.TrailingZeros16:
(defn ^"Int" TrailingZeros16
  "TrailingZeros16 returns the number of trailing zero bits in x; the result is 16 for x == 0.\n\nGo input arguments: (x uint16)\n\nGo return type: int\n\nJoker input arguments: [^UInt16 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros16(_x)"}
  [^UInt16 _x])

JOKER FUNC math/bits.TrailingZeros32:
(defn ^"Int" TrailingZeros32
  "TrailingZeros32 returns the number of trailing zero bits in x; the result is 32 for x == 0.\n\nGo input arguments: (x uint32)\n\nGo return type: int\n\nJoker input arguments: [^UInt32 x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "bits.TrailingZeros32(_x)"}
  [^UInt32 _x])

JOKER FUNC math/bits.TrailingZeros64:
;; (defn ^"Int" TrailingZeros64
;;   "TrailingZeros64 returns the number of trailing zero bits in x; the result is 64 for x == 0.\n\nGo input arguments: (x uint64)\n\nGo return type: int\n\nJoker input arguments: [^uint64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros64(_x)"}
;;   [^ABEND044(unsupported built-in type uint64) _x])

JOKER FUNC math/bits.TrailingZeros8:
;; (defn ^"Int" TrailingZeros8
;;   "TrailingZeros8 returns the number of trailing zero bits in x; the result is 8 for x == 0.\n\nGo input arguments: (x uint8)\n\nGo return type: int\n\nJoker input arguments: [^uint8 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "bits.TrailingZeros8(_x)"}
;;   [^ABEND044(unsupported built-in type uint8) _x])

JOKER FUNC math/cmplx.Abs:
;; (defn Abs
;;   "Abs returns the absolute value (also called the modulus) of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "abs(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acos:
;; (defn Acos
;;   "Acos returns the inverse cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "acos(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Acosh:
;; (defn Acosh
;;   "Acosh returns the inverse hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "acosh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asin:
;; (defn Asin
;;   "Asin returns the inverse sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "asin(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Asinh:
;; (defn Asinh
;;   "Asinh returns the inverse hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "asinh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atan:
;; (defn Atan
;;   "Atan returns the inverse tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "atan(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Atanh:
;; (defn Atanh
;;   "Atanh returns the inverse hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "atanh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Conj:
;; (defn Conj
;;   "Conj returns the complex conjugate of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "conj(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cos:
;; (defn Cos
;;   "Cos returns the cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cos(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cosh:
;; (defn Cosh
;;   "Cosh returns the hyperbolic cosine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cosh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Cot:
;; (defn Cot
;;   "Cot returns the cotangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "cot(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Exp:
;; (defn Exp
;;   "Exp returns e**x, the base-e exponential of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "exp(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Inf:
;; (defn Inf
;;   "Inf returns a complex infinity, complex(+Inf, +Inf).\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "inf()"}
;;   [])

JOKER FUNC math/cmplx.IsInf:
;; (defn ^"Bool" IsInf
;;   "IsInf returns true if either real(x) or imag(x) is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsInf(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.IsNaN:
;; (defn ^"Bool" IsNaN
;;   "IsNaN returns true if either real(x) or imag(x) is NaN\nand neither is an infinity.\n\nGo input arguments: (x complex128)\n\nGo return type: bool\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "cmplx.IsNaN(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log:
;; (defn Log
;;   "Log returns the natural logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "log(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Log10:
;; (defn Log10
;;   "Log10 returns the decimal logarithm of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "log10(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.NaN:
;; (defn NaN
;;   "NaN returns a complex ``not-a-number'' value.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "naN()"}
;;   [])

JOKER FUNC math/cmplx.Phase:
;; (defn Phase
;;   "Phase returns the phase (also called the argument) of x.\nThe returned value is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "phase(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Polar:
;; (defn Polar
;;   "Polar returns the absolute value r and phase  of x,\nsuch that x = r * e**i.\nThe phase is in the range [-Pi, Pi].\n\nGo input arguments: (x complex128)\n\nGo return type: (r ...,  ...)\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: [ABEND043(unsupported built-in type float64) ABEND043(unsupported built-in type float64)]"
;;   {:added "1.0"
;;    :go "polar(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Pow:
;; (defn Pow
;;   "Pow returns x**y, the base-x exponential of y.\nFor generalized compatibility with math.Pow:\n\tPow(0, 0) returns 1+0i\n\tPow(0, c) for real(c)<0 returns Inf+0i if imag(c) is zero, otherwise Inf+Inf i.\n\nGo input arguments: (x complex128, y complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x, ^complex128 y]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "pow(_x, _y)"}
;;   [^ABEND044(unsupported built-in type complex128) _x, ^ABEND044(unsupported built-in type complex128) _y])

JOKER FUNC math/cmplx.Rect:
;; (defn Rect
;;   "Rect returns the complex number x with polar coordinates r, .\n\nGo input arguments: (r float64,  float64)\n\nGo return type: ...\n\nJoker input arguments: [^float64 r, ^float64 ]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "rect(_r, _)"}
;;   [^ABEND044(unsupported built-in type float64) _r, ^ABEND044(unsupported built-in type float64) _])

JOKER FUNC math/cmplx.Sin:
;; (defn Sin
;;   "Sin returns the sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sin(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sinh:
;; (defn Sinh
;;   "Sinh returns the hyperbolic sine of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sinh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Sqrt:
;; (defn Sqrt
;;   "Sqrt returns the square root of x.\nThe result r is chosen so that real(r)  0 and imag(r) has the same sign as imag(x).\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "sqrt(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tan:
;; (defn Tan
;;   "Tan returns the tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "tan(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/cmplx.Tanh:
;; (defn Tanh
;;   "Tanh returns the hyperbolic tangent of x.\n\nGo input arguments: (x complex128)\n\nGo return type: ...\n\nJoker input arguments: [^complex128 x]\n\nJoker return type: ABEND043(unsupported built-in type complex128)"
;;   {:added "1.0"
;;    :go "tanh(_x)"}
;;   [^ABEND044(unsupported built-in type complex128) _x])

JOKER FUNC math/rand.ExpFloat64:
;; (defn ExpFloat64
;;   "ExpFloat64 returns an exponentially distributed float64 in the range\n(0, +math.MaxFloat64] with an exponential distribution whose rate parameter\n(lambda) is 1 and whose mean is 1/lambda (1) from the default Source.\nTo produce a distribution with a different rate parameter,\ncallers can adjust the output using:\n\n sample = ExpFloat64() / desiredRateParameter\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "expFloat64()"}
;;   [])

JOKER FUNC math/rand.Float32:
;; (defn Float32
;;   "Float32 returns, as a float32, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float32)"
;;   {:added "1.0"
;;    :go "float32()"}
;;   [])

JOKER FUNC math/rand.Float64:
;; (defn Float64
;;   "Float64 returns, as a float64, a pseudo-random number in [0.0,1.0)\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "float64()"}
;;   [])

JOKER FUNC math/rand.Int:
(defn ^"Int" Int
  "Int returns a non-negative pseudo-random int from the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Int()"}
  [])

JOKER FUNC math/rand.Int31:
(defn ^"Int" Int31
  "Int31 returns a non-negative pseudo-random 31-bit integer as an int32\nfrom the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(rand.Int31())"}
  [])

JOKER FUNC math/rand.Int31n:
(defn ^"Int" Int31n
  "Int31n returns, as an int32, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int32)\n\nGo return type: int\n\nJoker input arguments: [^Int32 n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(rand.Int31n(_n))"}
  [^Int32 _n])

JOKER FUNC math/rand.Int63:
(defn ^"Int" Int63
  "Int63 returns a non-negative pseudo-random 63-bit integer as an int64\nfrom the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(rand.Int63())"}
  [])

JOKER FUNC math/rand.Int63n:
(defn ^"Int" Int63n
  "Int63n returns, as an int64, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int64)\n\nGo return type: int\n\nJoker input arguments: [^Int64 n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(rand.Int63n(_n))"}
  [^Int64 _n])

JOKER FUNC math/rand.Intn:
(defn ^"Int" Intn
  "Intn returns, as an int, a non-negative pseudo-random number in [0,n)\nfrom the default Source.\nIt panics if n <= 0.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "rand.Intn(_n)"}
  [^Int _n])

JOKER FUNC math/rand.New:
;; (defn New
;;   "New returns a new Rand that uses random values from src\nto generate other random values.\n\nGo input arguments: (src math/rand.Source)\n\nGo return type: *Rand\n\nJoker input arguments: [^math/rand.Source src]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(ABEND904(custom-runtime routine not implemented: math/rand.Source(_src))))"}
;;   [^math/rand.Source _src])

JOKER FUNC math/rand.NewSource:
;; (defn NewSource
;;   "NewSource returns a new pseudo-random Source seeded with the given value.\nUnlike the default Source used by top-level functions, this source is not\nsafe for concurrent use by multiple goroutines.\n\nGo input arguments: (seed int64)\n\nGo return type: Source\n\nJoker input arguments: [^Int64 seed]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/math/rand/rand.go:25:13)"
;;   {:added "1.0"
;;    :go "newSource(_seed)"}
;;   [^Int64 _seed])

JOKER FUNC math/rand.NewZipf:
;; (defn NewZipf
;;   "NewZipf returns a Zipf variate generator.\nThe generator generates values k  [0, imax]\nsuch that P(k) is proportional to (v + k) ** (-s).\nRequirements: s > 1 and v >= 1.\n\nGo input arguments: (r *math/rand.Rand, s float64, v float64, imax uint64)\n\nGo return type: *Zipf\n\nJoker input arguments: [^(atom-of math/rand.Rand) r, ^float64 s, ^float64 v, ^uint64 imax]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newZipf(ConvertToIndirectOfmath/rand.Rand(ABEND904(custom-runtime routine not implemented: math/rand.Rand(_r))), _s, _v, _imax))"}
;;   [^Object _r, ^ABEND044(unsupported built-in type float64) _s, ^ABEND044(unsupported built-in type float64) _v, ^ABEND044(unsupported built-in type uint64) _imax])

JOKER FUNC math/rand.NormFloat64:
;; (defn NormFloat64
;;   "NormFloat64 returns a normally distributed float64 in the range\n[-math.MaxFloat64, +math.MaxFloat64] with\nstandard normal distribution (mean = 0, stddev = 1)\nfrom the default Source.\nTo produce a different normal distribution, callers can\nadjust the output using:\n\n sample = NormFloat64() * desiredStdDev + desiredMean\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "normFloat64()"}
;;   [])

JOKER FUNC math/rand.Perm:
(defn Perm
  "Perm returns, as a slice of n ints, a pseudo-random permutation of the integers [0,n)\nfrom the default Source.\n\nGo input arguments: (n int)\n\nGo return type: []int\n\nJoker input arguments: [^Int n]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "perm(_n)"}
  [^Int _n])

JOKER FUNC math/rand.Read:
(defn Read
  "Read generates len(p) random bytes from the default Source and\nwrites them into p. It always returns len(p) and a nil error.\nRead, unlike the Rand.Read method, is safe for concurrent use.\n\nGo input arguments: (p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "read(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC math/rand.Seed:
;; (defn Seed
;;   "Seed uses the provided seed value to initialize the default Source to a\ndeterministic state. If Seed is not called, the generator behaves as\nif seeded by Seed(1). Seed values that have the same remainder when\ndivided by 2^31-1 generate the same pseudo-random sequence.\nSeed, unlike the Rand.Seed method, is safe for concurrent use.\n\nGo input arguments: (seed int64)\n\nJoker input arguments: [^Int64 seed]"
;;   {:added "1.0"
;;    :go "seed(_seed)"}
;;   [^Int64 _seed])

JOKER FUNC math/rand.Shuffle:
;; (defn Shuffle
;;   "Shuffle pseudo-randomizes the order of elements using the default Source.\nn is the number of elements. Shuffle panics if n < 0.\nswap swaps the elements with indexes i and j.\n\nGo input arguments: (n int, swap func)\n\nJoker input arguments: [^Int n, ^fn swap]"
;;   {:added "1.0"
;;    :go "shuffle(_n, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Int _n, ^fn _swap])

JOKER FUNC math/rand.Uint32:
(defn ^"Int" Uint32
  "Uint32 returns a pseudo-random 32-bit value as a uint32\nfrom the default Source.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(rand.Uint32())"}
  [])

JOKER FUNC math/rand.Uint64:
;; (defn Uint64
;;   "Uint64 returns a pseudo-random 64-bit value as a uint64\nfrom the default Source.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "uint64()"}
;;   [])

JOKER FUNC mime.AddExtensionType:
(defn ^"Error" AddExtensionType
  "AddExtensionType sets the MIME type associated with\nthe extension ext to typ. The extension should begin with\na leading dot, as in \".html\".\n\nGo input arguments: (ext string, typ string)\n\nGo return type: error\n\nJoker input arguments: [^String ext, ^String typ]\n\nJoker return type: Error"
  {:added "1.0"
   :go "mime.AddExtensionType(_ext, _typ)"}
  [^String _ext, ^String _typ])

JOKER FUNC mime.ExtensionsByType:
(defn ExtensionsByType
  "ExtensionsByType returns the extensions known to be associated with the MIME\ntype typ. The returned extensions will each begin with a leading dot, as in\n\".html\". When typ has no associated extensions, ExtensionsByType returns an\nnil slice.\n\nGo input arguments: (typ string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String typ]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "extensionsByType(_typ)"}
  [^String _typ])

JOKER FUNC mime.FormatMediaType:
;; (defn ^"String" FormatMediaType
;;   "FormatMediaType serializes mediatype t and the parameters\nparam as a media type conforming to RFC 2045 and RFC 2616.\nThe type and parameter names are written in lower-case.\nWhen any of the arguments result in a standard violation then\nFormatMediaType returns the empty string.\n\nGo input arguments: (t string, param map[])\n\nGo return type: string\n\nJoker input arguments: [^String t, ^{} param]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "mime.FormatMediaType(_t, ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^String _t, ^{} _param])

JOKER FUNC mime.ParseMediaType:
;; (defn ParseMediaType
;;   "ParseMediaType parses a media type value and any optional\nparameters, per RFC 1521.  Media types are the values in\nContent-Type and Content-Disposition headers (RFC 2183).\nOn success, ParseMediaType returns the media type converted\nto lowercase and trimmed of white space and a non-nil map.\nIf there is an error parsing the optional parameter,\nthe media type will be returned along with the error\nErrInvalidMediaParameter.\nThe returned map, params, maps from the lowercase\nattribute to the attribute value with its case preserved.\n\nGo input arguments: (v string)\n\nGo return type: (mediatype string, params ..., err error)\n\nJoker input arguments: [^String v]\n\nJoker return type: [String ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/mediatype.go:111:57) Error]"
;;   {:added "1.0"
;;    :go "parseMediaType(_v)"}
;;   [^String _v])

JOKER FUNC mime.TypeByExtension:
(defn ^"String" TypeByExtension
  "TypeByExtension returns the MIME type associated with the file extension ext.\nThe extension ext should begin with a leading dot, as in \".html\".\nWhen ext has no associated type, TypeByExtension returns \"\".\n\nExtensions are looked up first case-sensitively, then case-insensitively.\n\nThe built-in table is small but on unix it is augmented by the local\nsystem's mime.types file(s) if available under one or more of these\nnames:\n\n  /etc/mime.types\n  /etc/apache2/mime.types\n  /etc/apache/mime.types\n\nOn Windows, MIME types are extracted from the registry.\n\nText types have the charset parameter set to \"utf-8\" by default.\n\nGo input arguments: (ext string)\n\nGo return type: string\n\nJoker input arguments: [^String ext]\n\nJoker return type: String"
  {:added "1.0"
   :go "mime.TypeByExtension(_ext)"}
  [^String _ext])

JOKER FUNC mime/multipart.NewReader:
;; (defn NewReader
;;   "NewReader creates a new multipart Reader reading from r using the\ngiven MIME boundary.\n\nThe boundary is usually obtained from the \"boundary\" parameter of\nthe message's \"Content-Type\" header. Use mime.ParseMediaType to\nparse such headers.\n\nGo input arguments: (r io.Reader, boundary string)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader r, ^String boundary]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)), _boundary))"}
;;   [^io.Reader _r, ^String _boundary])

JOKER FUNC mime/multipart.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new multipart Writer with a random boundary,\nwriting to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC mime/quotedprintable.NewReader:
;; (defn NewReader
;;   "NewReader returns a quoted-printable reader, decoding from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r))))"}
;;   [^io.Reader _r])

JOKER FUNC mime/quotedprintable.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer that writes to w.\n\nGo input arguments: (w io.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: {:Binary ^Bool}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w))))"}
;;   [^io.Writer _w])

JOKER FUNC net.CIDRMask:
(defn CIDRMask
  "CIDRMask returns an IPMask consisting of `ones' 1 bits\nfollowed by 0s up to a total length of `bits' bits.\nFor a mask of this form, CIDRMask is the inverse of IPMask.Size.\n\nGo input arguments: (ones int, bits int)\n\nGo return type: IPMask\n\nJoker input arguments: [^Int ones, ^Int bits]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "cIDRMask(_ones, _bits)"}
  [^Int _ones, ^Int _bits])

JOKER FUNC net.Dial:
;; (defn Dial
;;   "Dial connects to the address on the named network.\n\nKnown networks are \"tcp\", \"tcp4\" (IPv4-only), \"tcp6\" (IPv6-only),\n\"udp\", \"udp4\" (IPv4-only), \"udp6\" (IPv6-only), \"ip\", \"ip4\"\n(IPv4-only), \"ip6\" (IPv6-only), \"unix\", \"unixgram\" and\n\"unixpacket\".\n\nFor TCP and UDP networks, the address has the form \"host:port\".\nThe host must be a literal IP address, or a host name that can be\nresolved to IP addresses.\nThe port must be a literal port number or a service name.\nIf the host is a literal IPv6 address it must be enclosed in square\nbrackets, as in \"[2001:db8::1]:80\" or \"[fe80::1%zone]:80\".\nThe zone specifies the scope of the literal IPv6 address as defined\nin RFC 4007.\nThe functions JoinHostPort and SplitHostPort manipulate a pair of\nhost and port in this form.\nWhen using TCP, and the host resolves to multiple IP addresses,\nDial will try each IP address in order until one succeeds.\n\nExamples:\n\tDial(\"tcp\", \"golang.org:http\")\n\tDial(\"tcp\", \"192.0.2.1:http\")\n\tDial(\"tcp\", \"198.51.100.1:80\")\n\tDial(\"udp\", \"[2001:db8::1]:domain\")\n\tDial(\"udp\", \"[fe80::1%lo0]:53\")\n\tDial(\"tcp\", \":80\")\n\nFor IP networks, the network must be \"ip\", \"ip4\" or \"ip6\" followed\nby a colon and a literal protocol number or a protocol name, and\nthe address has the form \"host\". The host must be a literal IP\naddress or a literal IPv6 address with zone.\nIt depends on each operating system how the operating system\nbehaves with a non-well known protocol number such as \"0\" or \"255\".\n\nExamples:\n\tDial(\"ip4:1\", \"192.0.2.1\")\n\tDial(\"ip6:ipv6-icmp\", \"2001:db8::1\")\n\tDial(\"ip6:58\", \"fe80::1%lo0\")\n\nFor TCP, UDP and IP networks, if the host is empty or a literal\nunspecified IP address, as in \":80\", \"0.0.0.0:80\" or \"[::]:80\" for\nTCP and UDP, \"\", \"0.0.0.0\" or \"::\" for IP, the local system is\nassumed.\n\nFor Unix networks, the address must be a file system path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dial(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.DialIP:
;; (defn DialIP
;;   "DialIP acts like Dial for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *net.IPAddr, raddr *net.IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.IPAddr) laddr, ^(atom-of net.IPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialIP(_network, ConvertToIndirectOfnet.IPAddr(ABEND904(custom-runtime routine not implemented: net.IPAddr(_laddr))), ConvertToIndirectOfnet.IPAddr(ABEND904(custom-runtime routine not implemented: net.IPAddr(_raddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTCP:
;; (defn DialTCP
;;   "DialTCP acts like Dial for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *net.TCPAddr, raddr *net.TCPAddr)\n\nGo return type: (*TCPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.TCPAddr) laddr, ^(atom-of net.TCPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialTCP(_network, ConvertToIndirectOfnet.TCPAddr(ABEND904(custom-runtime routine not implemented: net.TCPAddr(_laddr))), ConvertToIndirectOfnet.TCPAddr(ABEND904(custom-runtime routine not implemented: net.TCPAddr(_raddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialTimeout:
;; (defn DialTimeout
;;   "DialTimeout acts like Dial but takes a timeout.\n\nThe timeout includes name resolution, if required.\nWhen using TCP, and the host in the address parameter resolves to\nmultiple IP addresses, the timeout is spread over each consecutive\ndial, such that each is given an appropriate fraction of the time\nto connect.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string, timeout time.Duration)\n\nGo return type: (Conn, error)\n\nJoker input arguments: [^String network, ^String address, ^time.Duration timeout]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "dialTimeout(_network, _address, ABEND904(custom-runtime routine not implemented: time.Duration(_timeout)))"}
;;   [^String _network, ^String _address, ^time.Duration _timeout])

JOKER FUNC net.DialUDP:
;; (defn DialUDP
;;   "DialUDP acts like Dial for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf laddr is nil, a local address is automatically chosen.\nIf the IP field of raddr is nil or an unspecified IP address, the\nlocal system is assumed.\n\nGo input arguments: (network string, laddr *net.UDPAddr, raddr *net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.UDPAddr) laddr, ^(atom-of net.UDPAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUDP(_network, ConvertToIndirectOfnet.UDPAddr(ABEND904(custom-runtime routine not implemented: net.UDPAddr(_laddr))), ConvertToIndirectOfnet.UDPAddr(ABEND904(custom-runtime routine not implemented: net.UDPAddr(_raddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.DialUnix:
;; (defn DialUnix
;;   "DialUnix acts like Dial for Unix networks.\n\nThe network must be a Unix network name; see func Dial for details.\n\nIf laddr is non-nil, it is used as the local address for the\nconnection.\n\nGo input arguments: (network string, laddr *net.UnixAddr, raddr *net.UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.UnixAddr) laddr, ^(atom-of net.UnixAddr) raddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "dialUnix(_network, ConvertToIndirectOfnet.UnixAddr(ABEND904(custom-runtime routine not implemented: net.UnixAddr(_laddr))), ConvertToIndirectOfnet.UnixAddr(ABEND904(custom-runtime routine not implemented: net.UnixAddr(_raddr))))"}
;;   [^String _network, ^Object _laddr, ^Object _raddr])

JOKER FUNC net.FileConn:
;; (defn FileConn
;;   "FileConn returns a copy of the network connection corresponding to\nthe open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c Conn, err error)\n\nJoker input arguments: [^(atom-of os.File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) Error]"
;;   {:added "1.0"
;;    :go "fileConn(ConvertToIndirectOfos.File(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.FileListener:
;; (defn FileListener
;;   "FileListener returns a copy of the network listener corresponding\nto the open file f.\nIt is the caller's responsibility to close ln when finished.\nClosing ln does not affect f, and closing f does not affect ln.\n\nGo input arguments: (f *os.File)\n\nGo return type: (ln Listener, err error)\n\nJoker input arguments: [^(atom-of os.File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "fileListener(ConvertToIndirectOfos.File(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.FilePacketConn:
;; (defn FilePacketConn
;;   "FilePacketConn returns a copy of the packet network connection\ncorresponding to the open file f.\nIt is the caller's responsibility to close f when finished.\nClosing c does not affect f, and closing f does not affect c.\n\nGo input arguments: (f *os.File)\n\nGo return type: (c PacketConn, err error)\n\nJoker input arguments: [^(atom-of os.File) f]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "filePacketConn(ConvertToIndirectOfos.File(ABEND904(custom-runtime routine not implemented: os.File(_f))))"}
;;   [^Object _f])

JOKER FUNC net.IPv4:
(defn IPv4
  "IPv4 returns the IP address (in 16-byte form) of the\nIPv4 address a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IP\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.IPv4Mask:
(defn IPv4Mask
  "IPv4Mask returns the IP mask (in 4-byte form) of the\nIPv4 mask a.b.c.d.\n\nGo input arguments: (a byte, b byte, c byte, d byte)\n\nGo return type: IPMask\n\nJoker input arguments: [^Byte a, ^Byte b, ^Byte c, ^Byte d]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "iPv4Mask(_a, _b, _c, _d)"}
  [^Byte _a, ^Byte _b, ^Byte _c, ^Byte _d])

JOKER FUNC net.InterfaceAddrs:
;; (defn InterfaceAddrs
;;   "InterfaceAddrs returns a list of the system's unicast interface\naddresses.\n\nThe returned list does not identify the associated interface; use\nInterfaces and Interface.Addrs for more detail.\n\nGo return type: ([]Addr, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:105:11)) Error]"
;;   {:added "1.0"
;;    :go "interfaceAddrs()"}
;;   [])

JOKER FUNC net.InterfaceByIndex:
(defn InterfaceByIndex
  "InterfaceByIndex returns the interface specified by index.\n\nOn Solaris, it returns one of the logical network interfaces\nsharing the logical data link; for more precision use\nInterfaceByName.\n\nGo input arguments: (index int)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^Int index]\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByIndex(_index)"}
  [^Int _index])

JOKER FUNC net.InterfaceByName:
(defn InterfaceByName
  "InterfaceByName returns the interface specified by name.\n\nGo input arguments: (name string)\n\nGo return type: (*Interface, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int} Error]"
  {:added "1.0"
   :go "interfaceByName(_name)"}
  [^String _name])

JOKER FUNC net.Interfaces:
(defn Interfaces
  "Interfaces returns a list of the system's network interfaces.\n\nGo return type: ([]Interface, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of {:Index ^Int, :MTU ^Int, :Name ^String, :HardwareAddr ^(vector-of Int), :Flags ^Int}) Error]"
  {:added "1.0"
   :go "interfaces()"}
  [])

JOKER FUNC net.JoinHostPort:
(defn ^"String" JoinHostPort
  "JoinHostPort combines host and port into a network address of the\nform \"host:port\". If host contains a colon, as found in literal\nIPv6 addresses, then JoinHostPort returns \"[host]:port\".\n\nSee func Dial for a description of the host and port parameters.\n\nGo input arguments: (host string, port string)\n\nGo return type: string\n\nJoker input arguments: [^String host, ^String port]\n\nJoker return type: String"
  {:added "1.0"
   :go "net.JoinHostPort(_host, _port)"}
  [^String _host, ^String _port])

JOKER FUNC net.Listen:
;; (defn Listen
;;   "Listen announces on the local network address.\n\nThe network must be \"tcp\", \"tcp4\", \"tcp6\", \"unix\" or \"unixpacket\".\n\nFor TCP networks, if the host in the address parameter is empty or\na literal unspecified IP address, Listen listens on all available\nunicast and anycast IP addresses of the local system.\nTo only use IPv4, use network \"tcp4\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe Addr method of Listener can be used to discover the chosen\nport.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (Listener, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15) Error]"
;;   {:added "1.0"
;;    :go "listen(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenIP:
;; (defn ListenIP
;;   "ListenIP acts like ListenPacket for IP networks.\n\nThe network must be an IP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenIP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\n\nGo input arguments: (network string, laddr *net.IPAddr)\n\nGo return type: (*IPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.IPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenIP(_network, ConvertToIndirectOfnet.IPAddr(ABEND904(custom-runtime routine not implemented: net.IPAddr(_laddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenMulticastUDP:
;; (defn ListenMulticastUDP
;;   "ListenMulticastUDP acts like ListenPacket for UDP networks but\ntakes a group address on a specific network interface.\n\nThe network must be a UDP network name; see func Dial for details.\n\nListenMulticastUDP listens on all available IP addresses of the\nlocal system including the group, multicast IP address.\nIf ifi is nil, ListenMulticastUDP uses the system-assigned\nmulticast interface, although this is not recommended because the\nassignment depends on platforms and sometimes it might require\nrouting configuration.\nIf the Port field of gaddr is 0, a port number is automatically\nchosen.\n\nListenMulticastUDP is just for convenience of simple, small\napplications. There are golang.org/x/net/ipv4 and\ngolang.org/x/net/ipv6 packages for general purpose uses.\n\nGo input arguments: (network string, ifi *net.Interface, gaddr *net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.Interface) ifi, ^(atom-of net.UDPAddr) gaddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenMulticastUDP(_network, ConvertToIndirectOfnet.Interface(ABEND904(custom-runtime routine not implemented: net.Interface(_ifi))), ConvertToIndirectOfnet.UDPAddr(ABEND904(custom-runtime routine not implemented: net.UDPAddr(_gaddr))))"}
;;   [^String _network, ^Object _ifi, ^Object _gaddr])

JOKER FUNC net.ListenPacket:
;; (defn ListenPacket
;;   "ListenPacket announces on the local network address.\n\nThe network must be \"udp\", \"udp4\", \"udp6\", \"unixgram\", or an IP\ntransport. The IP transports are \"ip\", \"ip4\", or \"ip6\" followed by\na colon and a literal protocol number or a protocol name, as in\n\"ip:1\" or \"ip:icmp\".\n\nFor UDP and IP networks, if the host in the address parameter is\nempty or a literal unspecified IP address, ListenPacket listens on\nall available IP addresses of the local system except multicast IP\naddresses.\nTo only use IPv4, use network \"udp4\" or \"ip4:proto\".\nThe address can use a host name, but this is not recommended,\nbecause it will create a listener for at most one of the host's IP\naddresses.\nIf the port in the address parameter is empty or \"0\", as in\n\"127.0.0.1:\" or \"[::1]:0\", a port number is automatically chosen.\nThe LocalAddr method of PacketConn can be used to discover the\nchosen port.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (PacketConn, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:303:17) Error]"
;;   {:added "1.0"
;;    :go "listenPacket(_network, _address)"}
;;   [^String _network, ^String _address])

JOKER FUNC net.ListenTCP:
;; (defn ListenTCP
;;   "ListenTCP acts like Listen for TCP networks.\n\nThe network must be a TCP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenTCP listens on all available unicast and anycast IP addresses\nof the local system.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *net.TCPAddr)\n\nGo return type: (*TCPListener, error)\n\nJoker input arguments: [^String network, ^(atom-of net.TCPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenTCP(_network, ConvertToIndirectOfnet.TCPAddr(ABEND904(custom-runtime routine not implemented: net.TCPAddr(_laddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUDP:
;; (defn ListenUDP
;;   "ListenUDP acts like ListenPacket for UDP networks.\n\nThe network must be a UDP network name; see func Dial for details.\n\nIf the IP field of laddr is nil or an unspecified IP address,\nListenUDP listens on all available IP addresses of the local system\nexcept multicast IP addresses.\nIf the Port field of laddr is 0, a port number is automatically\nchosen.\n\nGo input arguments: (network string, laddr *net.UDPAddr)\n\nGo return type: (*UDPConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.UDPAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUDP(_network, ConvertToIndirectOfnet.UDPAddr(ABEND904(custom-runtime routine not implemented: net.UDPAddr(_laddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnix:
;; (defn ListenUnix
;;   "ListenUnix acts like Listen for Unix networks.\n\nThe network must be \"unix\" or \"unixpacket\".\n\nGo input arguments: (network string, laddr *net.UnixAddr)\n\nGo return type: (*UnixListener, error)\n\nJoker input arguments: [^String network, ^(atom-of net.UnixAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnix(_network, ConvertToIndirectOfnet.UnixAddr(ABEND904(custom-runtime routine not implemented: net.UnixAddr(_laddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.ListenUnixgram:
;; (defn ListenUnixgram
;;   "ListenUnixgram acts like ListenPacket for Unix networks.\n\nThe network must be \"unixgram\".\n\nGo input arguments: (network string, laddr *net.UnixAddr)\n\nGo return type: (*UnixConn, error)\n\nJoker input arguments: [^String network, ^(atom-of net.UnixAddr) laddr]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "listenUnixgram(_network, ConvertToIndirectOfnet.UnixAddr(ABEND904(custom-runtime routine not implemented: net.UnixAddr(_laddr))))"}
;;   [^String _network, ^Object _laddr])

JOKER FUNC net.LookupAddr:
(defn LookupAddr
  "LookupAddr performs a reverse lookup for the given address, returning a list\nof names mapping to that address.\n\nWhen using the host C library resolver, at most one result will be\nreturned. To bypass the host resolver, use a custom Resolver.\n\nGo input arguments: (addr string)\n\nGo return type: (names []string, err error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupAddr(_addr)"}
  [^String _addr])

JOKER FUNC net.LookupCNAME:
(defn LookupCNAME
  "LookupCNAME returns the canonical name for the given host.\nCallers that do not care about the canonical name can call\nLookupHost or LookupIP directly; both take care of resolving\nthe canonical name as part of the lookup.\n\nA canonical name is the final name after following zero\nor more CNAME records.\nLookupCNAME does not return an error if host does not\ncontain DNS \"CNAME\" records, as long as host resolves to\naddress records.\n\nGo input arguments: (host string)\n\nGo return type: (cname string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookupCNAME(_host)"}
  [^String _host])

JOKER FUNC net.LookupHost:
(defn LookupHost
  "LookupHost looks up the given host using the local resolver.\nIt returns a slice of that host's addresses.\n\nGo input arguments: (host string)\n\nGo return type: (addrs []string, err error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupHost(_host)"}
  [^String _host])

JOKER FUNC net.LookupIP:
(defn LookupIP
  "LookupIP looks up host using the local resolver.\nIt returns a slice of that host's IPv4 and IPv6 addresses.\n\nGo input arguments: (host string)\n\nGo return type: ([]IP, error)\n\nJoker input arguments: [^String host]\n\nJoker return type: [(vector-of (vector-of Int)) Error]"
  {:added "1.0"
   :go "lookupIP(_host)"}
  [^String _host])

JOKER FUNC net.LookupMX:
(defn LookupMX
  "LookupMX returns the DNS MX records for the given domain name sorted by preference.\n\nGo input arguments: (name string)\n\nGo return type: ([]*MX, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of {:Host ^String, :Pref ^Int}) Error]"
  {:added "1.0"
   :go "lookupMX(_name)"}
  [^String _name])

JOKER FUNC net.LookupNS:
(defn LookupNS
  "LookupNS returns the DNS NS records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]*NS, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of {:Host ^String}) Error]"
  {:added "1.0"
   :go "lookupNS(_name)"}
  [^String _name])

JOKER FUNC net.LookupPort:
(defn LookupPort
  "LookupPort looks up the port for the given network and service.\n\nGo input arguments: (network string, service string)\n\nGo return type: (port int, err error)\n\nJoker input arguments: [^String network, ^String service]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lookupPort(_network, _service)"}
  [^String _network, ^String _service])

JOKER FUNC net.LookupSRV:
(defn LookupSRV
  "LookupSRV tries to resolve an SRV query of the given service,\nprotocol, and domain name. The proto is \"tcp\" or \"udp\".\nThe returned records are sorted by priority and randomized\nby weight within a priority.\n\nLookupSRV constructs the DNS name to look up following RFC 2782.\nThat is, it looks up _service._proto.name. To accommodate services\npublishing SRV records under non-standard names, if both service\nand proto are empty strings, LookupSRV looks up name directly.\n\nGo input arguments: (service string, proto string, name string)\n\nGo return type: (cname string, addrs []*SRV, err error)\n\nJoker input arguments: [^String service, ^String proto, ^String name]\n\nJoker return type: [String (vector-of {:Target ^String, :Port ^Int, :Priority ^Int, :Weight ^Int}) Error]"
  {:added "1.0"
   :go "lookupSRV(_service, _proto, _name)"}
  [^String _service, ^String _proto, ^String _name])

JOKER FUNC net.LookupTXT:
(defn LookupTXT
  "LookupTXT returns the DNS TXT records for the given domain name.\n\nGo input arguments: (name string)\n\nGo return type: ([]string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "lookupTXT(_name)"}
  [^String _name])

JOKER FUNC net.ParseCIDR:
(defn ParseCIDR
  "ParseCIDR parses s as a CIDR notation IP address and prefix length,\nlike \"192.0.2.0/24\" or \"2001:db8::/32\", as defined in\nRFC 4632 and RFC 4291.\n\nIt returns the IP address and the network implied by the IP and\nprefix length.\nFor example, ParseCIDR(\"192.0.2.1/24\") returns the IP address\n192.0.2.1 and the network 192.0.2.0/24.\n\nGo input arguments: (s string)\n\nGo return type: (IP, *IPNet, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) {:IP ^(vector-of Int), :Mask ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "parseCIDR(_s)"}
  [^String _s])

JOKER FUNC net.ParseIP:
(defn ParseIP
  "ParseIP parses s as an IP address, returning the result.\nThe string s can be in dotted decimal (\"192.0.2.1\")\nor IPv6 (\"2001:db8::68\") form.\nIf s is not a valid textual representation of an IP address,\nParseIP returns nil.\n\nGo input arguments: (s string)\n\nGo return type: IP\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "parseIP(_s)"}
  [^String _s])

JOKER FUNC net.ParseMAC:
(defn ParseMAC
  "ParseMAC parses s as an IEEE 802 MAC-48, EUI-48, EUI-64, or a 20-octet\nIP over InfiniBand link-layer address using one of the following formats:\n  01:23:45:67:89:ab\n  01:23:45:67:89:ab:cd:ef\n  01:23:45:67:89:ab:cd:ef:00:00:01:23:45:67:89:ab:cd:ef:00:00\n  01-23-45-67-89-ab\n  01-23-45-67-89-ab-cd-ef\n  01-23-45-67-89-ab-cd-ef-00-00-01-23-45-67-89-ab-cd-ef-00-00\n  0123.4567.89ab\n  0123.4567.89ab.cdef\n  0123.4567.89ab.cdef.0000.0123.4567.89ab.cdef.0000\n\nGo input arguments: (s string)\n\nGo return type: (hw HardwareAddr, err error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "parseMAC(_s)"}
  [^String _s])

JOKER FUNC net.Pipe:
;; (defn Pipe
;;   "Pipe creates a synchronous, in-memory, full duplex\nnetwork connection; both ends implement the Conn interface.\nReads on one end are matched with writes on the other,\ncopying data directly between the two; there is no internal\nbuffering.\n\nGo return type: (Conn, Conn)\n\nJoker input arguments: []\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11) ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:113:11)]"
;;   {:added "1.0"
;;    :go "pipe()"}
;;   [])

JOKER FUNC net.ResolveIPAddr:
(defn ResolveIPAddr
  "ResolveIPAddr returns an address of IP end point.\n\nThe network must be an IP network name.\n\nIf the host in the address parameter is not a literal IP address,\nResolveIPAddr resolves the address to an address of IP end point.\nOtherwise, it parses the address as a literal IP address.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*IPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveIPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveTCPAddr:
(defn ResolveTCPAddr
  "ResolveTCPAddr returns an address of TCP end point.\n\nThe network must be a TCP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveTCPAddr resolves the\naddress to an address of TCP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*TCPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveTCPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUDPAddr:
(defn ResolveUDPAddr
  "ResolveUDPAddr returns an address of UDP end point.\n\nThe network must be a UDP network name.\n\nIf the host in the address parameter is not a literal IP address or\nthe port is not a literal port number, ResolveUDPAddr resolves the\naddress to an address of UDP end point.\nOtherwise, it parses the address as a pair of literal IP address\nand port number.\nThe address parameter can use a host name, but this is not\nrecommended, because it will return at most one of the host name's\nIP addresses.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UDPAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:IP ^(vector-of Int), :Port ^Int, :Zone ^String} Error]"
  {:added "1.0"
   :go "resolveUDPAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.ResolveUnixAddr:
(defn ResolveUnixAddr
  "ResolveUnixAddr returns an address of Unix domain socket end point.\n\nThe network must be a Unix network name.\n\nSee func Dial for a description of the network and address\nparameters.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*UnixAddr, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{:Name ^String, :Net ^String} Error]"
  {:added "1.0"
   :go "resolveUnixAddr(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net.SplitHostPort:
(defn SplitHostPort
  "SplitHostPort splits a network address of the form \"host:port\",\n\"host%zone:port\", \"[host]:port\" or \"[host%zone]:port\" into host or\nhost%zone and port.\n\nA literal IPv6 address in hostport must be enclosed in square\nbrackets, as in \"[::1]:80\", \"[::1%lo0]:80\".\n\nSee func Dial for a description of the hostport parameter, and host\nand port results.\n\nGo input arguments: (hostport string)\n\nGo return type: (host string, port string, err error)\n\nJoker input arguments: [^String hostport]\n\nJoker return type: [String String Error]"
  {:added "1.0"
   :go "splitHostPort(_hostport)"}
  [^String _hostport])

JOKER FUNC net/http.CanonicalHeaderKey:
(defn ^"String" CanonicalHeaderKey
  "CanonicalHeaderKey returns the canonical format of the\nheader key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.CanonicalHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/http.DetectContentType:
(defn ^"String" DetectContentType
  "DetectContentType implements the algorithm described\nat https://mimesniff.spec.whatwg.org/ to determine the\nContent-Type of the given data. It considers at most the\nfirst 512 bytes of data. DetectContentType always returns\na valid MIME type: if it cannot determine a more specific one, it\nreturns \"application/octet-stream\".\n\nGo input arguments: (data []byte)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of Byte) data]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.DetectContentType(ConvertToArrayOfByte(_data))"}
  [^Object _data])

JOKER FUNC net/http.Error:
;; (defn Error
;;   "Error replies to the request with the specified error message and HTTP code.\nIt does not otherwise end the request; the caller should ensure no further\nwrites are done to w.\nThe error message should be plain text.\n\nGo input arguments: (w net/http.ResponseWriter, error string, code int)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^String error, ^Int code]"
;;   {:added "1.0"
;;    :go "error(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), _error, _code)"}
;;   [^net/http.ResponseWriter _w, ^String _error, ^Int _code])

JOKER FUNC net/http.FileServer:
;; (defn FileServer
;;   "FileServer returns a handler that serves HTTP requests\nwith the contents of the file system rooted at root.\n\nTo use the operating system's file system implementation,\nuse http.Dir:\n\n    http.Handle(\"/\", http.FileServer(http.Dir(\"/tmp\")))\n\nAs a special case, the returned file server redirects any request\nending in \"/index.html\" to the same path, without the final\n\"index.html\".\n\nGo input arguments: (root net/http.FileSystem)\n\nGo return type: Handler\n\nJoker input arguments: [^net/http.FileSystem root]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "fileServer(ABEND904(custom-runtime routine not implemented: net/http.FileSystem(_root)))"}
;;   [^net/http.FileSystem _root])

JOKER FUNC net/http.Get:
;; (defn Get
;;   "Get issues a GET to the specified URL. If the response is one of\nthe following redirect codes, Get follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nAn error is returned if there were too many redirects or if there\nwas an HTTP protocol error. A non-2xx response doesn't cause an\nerror. Any returned error will be of type *url.Error. The url.Error\nvalue's Timeout method will report true if request timed out or was\ncanceled.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nGet is a wrapper around DefaultClient.Get.\n\nTo make a request with custom headers, use NewRequest and\nDefaultClient.Do.\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "get(_url)"}
;;   [^String _url])

JOKER FUNC net/http.Handle:
;; (defn Handle
;;   "Handle registers the handler for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler net/http.Handler)\n\nJoker input arguments: [^String pattern, ^net/http.Handler handler]"
;;   {:added "1.0"
;;    :go "handle(_pattern, ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^String _pattern, ^net/http.Handler _handler])

JOKER FUNC net/http.HandleFunc:
;; (defn HandleFunc
;;   "HandleFunc registers the handler function for the given pattern\nin the DefaultServeMux.\nThe documentation for ServeMux explains how patterns are matched.\n\nGo input arguments: (pattern string, handler func)\n\nJoker input arguments: [^String pattern, ^fn handler]"
;;   {:added "1.0"
;;    :go "handleFunc(_pattern, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _pattern, ^fn _handler])

JOKER FUNC net/http.Head:
;; (defn Head
;;   "Head issues a HEAD to the specified URL. If the response is one of\nthe following redirect codes, Head follows the redirect, up to a\nmaximum of 10 redirects:\n\n   301 (Moved Permanently)\n   302 (Found)\n   303 (See Other)\n   307 (Temporary Redirect)\n   308 (Permanent Redirect)\n\nHead is a wrapper around DefaultClient.Head\n\nGo input arguments: (url string)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "head(_url)"}
;;   [^String _url])

JOKER FUNC net/http.ListenAndServe:
;; (defn ^"Error" ListenAndServe
;;   "ListenAndServe listens on the TCP network address addr and then calls\nServe with handler to handle requests on incoming connections.\nAccepted connections are configured to enable TCP keep-alives.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nListenAndServe always returns a non-nil error.\n\nGo input arguments: (addr string, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^net/http.Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ListenAndServe(_addr, ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^String _addr, ^net/http.Handler _handler])

JOKER FUNC net/http.ListenAndServeTLS:
;; (defn ^"Error" ListenAndServeTLS
;;   "ListenAndServeTLS acts identically to ListenAndServe, except that it\nexpects HTTPS connections. Additionally, files containing a certificate and\nmatching private key for the server must be provided. If the certificate\nis signed by a certificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nGo input arguments: (addr string, certFile string, keyFile string, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^String certFile, ^String keyFile, ^net/http.Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ListenAndServeTLS(_addr, _certFile, _keyFile, ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^String _addr, ^String _certFile, ^String _keyFile, ^net/http.Handler _handler])

JOKER FUNC net/http.MaxBytesReader:
;; (defn MaxBytesReader
;;   "MaxBytesReader is similar to io.LimitReader but is intended for\nlimiting the size of incoming request bodies. In contrast to\nio.LimitReader, MaxBytesReader's result is a ReadCloser, returns a\nnon-EOF error for a Read beyond the limit, and closes the\nunderlying reader when its Close method is called.\n\nMaxBytesReader prevents clients from accidentally or maliciously\nsending a large request and wasting server resources.\n\nGo input arguments: (w net/http.ResponseWriter, r io.ReadCloser, n int64)\n\nGo return type: ...\n\nJoker input arguments: [^net/http.ResponseWriter w, ^io.ReadCloser r, ^Int64 n]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17)"
;;   {:added "1.0"
;;    :go "maxBytesReader(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ABEND904(custom-runtime routine not implemented: io.ReadCloser(_r)), _n)"}
;;   [^net/http.ResponseWriter _w, ^io.ReadCloser _r, ^Int64 _n])

JOKER FUNC net/http.NewFileTransport:
;; (defn NewFileTransport
;;   "NewFileTransport returns a new RoundTripper, serving the provided\nFileSystem. The returned RoundTripper ignores the URL host in its\nincoming requests, as well as most other properties of the\nrequest.\n\nThe typical use case for NewFileTransport is to register the \"file\"\nprotocol with a Transport, as in:\n\n  t := &http.Transport{}\n  t.RegisterProtocol(\"file\", http.NewFileTransport(http.Dir(\"/\")))\n  c := &http.Client{Transport: t}\n  res, err := c.Get(\"file:///etc/passwd\")\n  ...\n\nGo input arguments: (fs net/http.FileSystem)\n\nGo return type: RoundTripper\n\nJoker input arguments: [^net/http.FileSystem fs]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/client.go:115:19)"
;;   {:added "1.0"
;;    :go "newFileTransport(ABEND904(custom-runtime routine not implemented: net/http.FileSystem(_fs)))"}
;;   [^net/http.FileSystem _fs])

JOKER FUNC net/http.NewRequest:
;; (defn NewRequest
;;   "NewRequest returns a new Request given a method, URL, and optional body.\n\nIf the provided body is also an io.Closer, the returned\nRequest.Body is set to body and will be closed by the Client\nmethods Do, Post, and PostForm, and Transport.RoundTrip.\n\nNewRequest returns a Request suitable for use with Client.Do or\nTransport.RoundTrip. To create a request for use with testing a\nServer Handler, either use the NewRequest function in the\nnet/http/httptest package, use ReadRequest, or manually update the\nRequest fields. See the Request type's documentation for the\ndifference between inbound and outbound request fields.\n\nIf body is of type *bytes.Buffer, *bytes.Reader, or\n*strings.Reader, the returned request's ContentLength is set to its\nexact value (instead of -1), GetBody is populated (so 307 and 308\nredirects can replay the body), and Body is set to NoBody if the\nContentLength is 0.\n\nGo input arguments: (method string, url string, body io.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^String method, ^String url, ^io.Reader body]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving net/http.Request), :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}}} Error]"
;;   {:added "1.0"
;;    :go "newRequest(_method, _url, ABEND904(custom-runtime routine not implemented: io.Reader(_body)))"}
;;   [^String _method, ^String _url, ^io.Reader _body])

JOKER FUNC net/http.NewServeMux:
;; (defn NewServeMux
;;   "NewServeMux allocates and returns a new ServeMux.\n\nGo return type: *ServeMux\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServeMux())"}
;;   [])

JOKER FUNC net/http.NotFound:
;; (defn NotFound
;;   "NotFound replies to the request with an HTTP 404 not found error.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "notFound(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/http.NotFoundHandler:
;; (defn NotFoundHandler
;;   "NotFoundHandler returns a simple request handler\nthat replies to each request with a ``404 page not found'' reply.\n\nGo return type: Handler\n\nJoker input arguments: []\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "notFoundHandler()"}
;;   [])

JOKER FUNC net/http.ParseHTTPVersion:
(defn ParseHTTPVersion
  "ParseHTTPVersion parses a HTTP version string.\n\"HTTP/1.0\" returns (1, 0, true).\n\nGo input arguments: (vers string)\n\nGo return type: (major int, minor int, ok bool)\n\nJoker input arguments: [^String vers]\n\nJoker return type: [Int Int Bool]"
  {:added "1.0"
   :go "parseHTTPVersion(_vers)"}
  [^String _vers])

JOKER FUNC net/http.ParseTime:
(defn ParseTime
  "ParseTime parses a time header (such as the Date: header),\ntrying each of the three formats allowed by HTTP/1.1:\nTimeFormat, time.RFC850, and time.ANSIC.\n\nGo input arguments: (text string)\n\nGo return type: (t struct {}, err error)\n\nJoker input arguments: [^String text]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parseTime(_text)"}
  [^String _text])

JOKER FUNC net/http.Post:
;; (defn Post
;;   "Post issues a POST to the specified URL.\n\nCaller should close resp.Body when done reading from it.\n\nIf the provided body is an io.Closer, it is closed after the\nrequest.\n\nPost is a wrapper around DefaultClient.Post.\n\nTo set custom headers, use NewRequest and DefaultClient.Do.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, contentType string, body io.Reader)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^String contentType, ^io.Reader body]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "post(_url, _contentType, ABEND904(custom-runtime routine not implemented: io.Reader(_body)))"}
;;   [^String _url, ^String _contentType, ^io.Reader _body])

JOKER FUNC net/http.PostForm:
;; (defn PostForm
;;   "PostForm issues a POST to the specified URL, with data's keys and\nvalues URL-encoded as the request body.\n\nThe Content-Type header is set to application/x-www-form-urlencoded.\nTo set other headers, use NewRequest and DefaultClient.Do.\n\nWhen err is nil, resp always contains a non-nil resp.Body.\nCaller should close resp.Body when done reading from it.\n\nPostForm is a wrapper around DefaultClient.PostForm.\n\nSee the Client.Do method documentation for details on how redirects\nare handled.\n\nGo input arguments: (url string, data net/url.Values)\n\nGo return type: (resp *Response, err error)\n\nJoker input arguments: [^String url, ^net/url.Values data]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "postForm(_url, ABEND904(custom-runtime routine not implemented: net/url.Values(_data)))"}
;;   [^String _url, ^net/url.Values _data])

JOKER FUNC net/http.ProxyFromEnvironment:
;; (defn ProxyFromEnvironment
;;   "ProxyFromEnvironment returns the URL of the proxy to use for a\ngiven request, as indicated by the environment variables\nHTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions\nthereof). HTTPS_PROXY takes precedence over HTTP_PROXY for https\nrequests.\n\nThe environment values may be either a complete URL or a\n\"host[:port]\", in which case the \"http\" scheme is assumed.\nAn error is returned if the value is a different form.\n\nA nil URL and nil error are returned if no proxy is defined in the\nenvironment, or a proxy should not be used for the given request,\nas defined by NO_PROXY.\n\nAs a special case, if req.URL.Host is \"localhost\" (with or without\na port number), then a nil URL and nil error will be returned.\n\nGo input arguments: (req *net/http.Request)\n\nGo return type: (*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}, error)\n\nJoker input arguments: [^(atom-of net/http.Request) req]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
;;   {:added "1.0"
;;    :go "proxyFromEnvironment(ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_req))))"}
;;   [^Object _req])

JOKER FUNC net/http.ProxyURL:
;; (defn ProxyURL
;;   "ProxyURL returns a proxy function (for use in a Transport)\nthat always returns the same URL.\n\nGo input arguments: (fixedURL *net/url.URL)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of net/url.URL) fixedURL]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/transport.go:351:34)"
;;   {:added "1.0"
;;    :go "proxyURL(ConvertToIndirectOfnet/url.URL(ABEND904(custom-runtime routine not implemented: net/url.URL(_fixedURL))))"}
;;   [^Object _fixedURL])

JOKER FUNC net/http.ReadRequest:
;; (defn ReadRequest
;;   "ReadRequest reads and parses an incoming request from b.\n\nReadRequest is a low-level function and should only be used for\nspecialized applications; most code should use the Server to read\nrequests and handle them via the Handler interface. ReadRequest\nonly supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.\n\nGo input arguments: (b *bufio.Reader)\n\nGo return type: (*Request, error)\n\nJoker input arguments: [^(atom-of bufio.Reader) b]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^ABEND947(recursive type reference involving net/http.Request), :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}}} Error]"
;;   {:added "1.0"
;;    :go "readRequest(ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_b))))"}
;;   [^Object _b])

JOKER FUNC net/http.ReadResponse:
;; (defn ReadResponse
;;   "ReadResponse reads and returns an HTTP response from r.\nThe req parameter optionally specifies the Request that corresponds\nto this Response. If nil, a GET request is assumed.\nClients must call resp.Body.Close when finished reading resp.Body.\nAfter that call, clients can inspect resp.Trailer to find key/value\npairs included in the response trailer.\n\nGo input arguments: (r *bufio.Reader, req *net/http.Request)\n\nGo return type: (*Response, error)\n\nJoker input arguments: [^(atom-of bufio.Reader) r, ^(atom-of net/http.Request) req]\n\nJoker return type: [{:Status ^String, :StatusCode ^Int, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Uncompressed ^Bool, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Request ^{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND947(recursive type reference involving net/http.Response)}, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http.IP), :Mask ^ABEND042(cannot find typename net/http.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}} Error]"
;;   {:added "1.0"
;;    :go "readResponse(ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r))), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_req))))"}
;;   [^Object _r, ^Object _req])

JOKER FUNC net/http.Redirect:
;; (defn Redirect
;;   "Redirect replies to the request with a redirect to url,\nwhich may be a path relative to the request path.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nIf the Content-Type header has not been set, Redirect sets it\nto \"text/html; charset=utf-8\" and writes a small HTML body.\nSetting the Content-Type header to any value, including nil,\ndisables that behavior.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request, url string, code int)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r, ^String url, ^Int code]"
;;   {:added "1.0"
;;    :go "redirect(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))), _url, _code)"}
;;   [^net/http.ResponseWriter _w, ^Object _r, ^String _url, ^Int _code])

JOKER FUNC net/http.RedirectHandler:
;; (defn RedirectHandler
;;   "RedirectHandler returns a request handler that redirects\neach request it receives to the given url using the given\nstatus code.\n\nThe provided code should be in the 3xx range and is usually\nStatusMovedPermanently, StatusFound or StatusSeeOther.\n\nGo input arguments: (url string, code int)\n\nGo return type: Handler\n\nJoker input arguments: [^String url, ^Int code]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "redirectHandler(_url, _code)"}
;;   [^String _url, ^Int _code])

JOKER FUNC net/http.Serve:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming HTTP connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nHTTP/2 support is only enabled if the Listener returns *tls.Conn\nconnections and they were configured with \"h2\" in the TLS\nConfig.NextProtos.\n\nServe always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^net.Listener l, ^net/http.Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.Serve(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^net.Listener _l, ^net/http.Handler _handler])

JOKER FUNC net/http.ServeContent:
;; (defn ServeContent
;;   "ServeContent replies to the request using the content in the\nprovided ReadSeeker. The main benefit of ServeContent over io.Copy\nis that it handles Range requests properly, sets the MIME type, and\nhandles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,\nand If-Range requests.\n\nIf the response's Content-Type header is not set, ServeContent\nfirst tries to deduce the type from name's file extension and,\nif that fails, falls back to reading the first block of the content\nand passing it to DetectContentType.\nThe name is otherwise unused; in particular it can be empty and is\nnever sent in the response.\n\nIf modtime is not the zero time or Unix epoch, ServeContent\nincludes it in a Last-Modified header in the response. If the\nrequest includes an If-Modified-Since header, ServeContent uses\nmodtime to decide whether the content needs to be sent at all.\n\nThe content's Seek method must work: ServeContent uses\na seek to the end of the content to determine its size.\n\nIf the caller has set w's ETag header formatted per RFC 7232, section 2.3,\nServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.\n\nNote that *os.File implements the io.ReadSeeker interface.\n\nGo input arguments: (w net/http.ResponseWriter, req *net/http.Request, name string, modtime time.Time, content io.ReadSeeker)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) req, ^String name, ^time.Time modtime, ^io.ReadSeeker content]"
;;   {:added "1.0"
;;    :go "serveContent(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_req))), _name, ABEND904(custom-runtime routine not implemented: time.Time(_modtime)), ABEND904(custom-runtime routine not implemented: io.ReadSeeker(_content)))"}
;;   [^net/http.ResponseWriter _w, ^Object _req, ^String _name, ^time.Time _modtime, ^io.ReadSeeker _content])

JOKER FUNC net/http.ServeFile:
;; (defn ServeFile
;;   "ServeFile replies to the request with the contents of the named\nfile or directory.\n\nIf the provided file or directory name is a relative path, it is\ninterpreted relative to the current directory and may ascend to\nparent directories. If the provided name is constructed from user\ninput, it should be sanitized before calling ServeFile.\n\nAs a precaution, ServeFile will reject requests where r.URL.Path\ncontains a \"..\" path element; this protects against callers who\nmight unsafely use filepath.Join on r.URL.Path without sanitizing\nit and then use that filepath.Join result as the name argument.\n\nAs another special case, ServeFile redirects any request where r.URL.Path\nends in \"/index.html\" to the same path, without the final\n\"index.html\". To avoid such redirects either modify the path or\nuse ServeContent.\n\nOutside of those two special cases, ServeFile does not use\nr.URL.Path for selecting the file or directory to serve; only the\nfile or directory provided in the name argument is used.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request, name string)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r, ^String name]"
;;   {:added "1.0"
;;    :go "serveFile(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))), _name)"}
;;   [^net/http.ResponseWriter _w, ^Object _r, ^String _name])

JOKER FUNC net/http.ServeTLS:
;; (defn ^"Error" ServeTLS
;;   "ServeTLS accepts incoming HTTPS connections on the listener l,\ncreating a new service goroutine for each. The service goroutines\nread requests and then call handler to reply to them.\n\nThe handler is typically nil, in which case the DefaultServeMux is used.\n\nAdditionally, files containing a certificate and matching private key\nfor the server must be provided. If the certificate is signed by a\ncertificate authority, the certFile should be the concatenation\nof the server's certificate, any intermediates, and the CA's certificate.\n\nServeTLS always returns a non-nil error.\n\nGo input arguments: (l net.Listener, handler net/http.Handler, certFile string, keyFile string)\n\nGo return type: error\n\nJoker input arguments: [^net.Listener l, ^net/http.Handler handler, ^String certFile, ^String keyFile]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "http.ServeTLS(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)), _certFile, _keyFile)"}
;;   [^net.Listener _l, ^net/http.Handler _handler, ^String _certFile, ^String _keyFile])

JOKER FUNC net/http.SetCookie:
;; (defn SetCookie
;;   "SetCookie adds a Set-Cookie header to the provided ResponseWriter's headers.\nThe provided cookie must have a valid Name. Invalid cookies may be\nsilently dropped.\n\nGo input arguments: (w net/http.ResponseWriter, cookie *net/http.Cookie)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Cookie) cookie]"
;;   {:added "1.0"
;;    :go "setCookie(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Cookie(ABEND904(custom-runtime routine not implemented: net/http.Cookie(_cookie))))"}
;;   [^net/http.ResponseWriter _w, ^Object _cookie])

JOKER FUNC net/http.StatusText:
(defn ^"String" StatusText
  "StatusText returns a text for the HTTP status code. It returns the empty\nstring if the code is unknown.\n\nGo input arguments: (code int)\n\nGo return type: string\n\nJoker input arguments: [^Int code]\n\nJoker return type: String"
  {:added "1.0"
   :go "http.StatusText(_code)"}
  [^Int _code])

JOKER FUNC net/http.StripPrefix:
;; (defn StripPrefix
;;   "StripPrefix returns a handler that serves HTTP requests\nby removing the given prefix from the request URL's Path\nand invoking the handler h. StripPrefix handles a\nrequest for a path that doesn't begin with prefix by\nreplying with an HTTP 404 not found error.\n\nGo input arguments: (prefix string, h net/http.Handler)\n\nGo return type: Handler\n\nJoker input arguments: [^String prefix, ^net/http.Handler h]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "stripPrefix(_prefix, ABEND904(custom-runtime routine not implemented: net/http.Handler(_h)))"}
;;   [^String _prefix, ^net/http.Handler _h])

JOKER FUNC net/http.TimeoutHandler:
;; (defn TimeoutHandler
;;   "TimeoutHandler returns a Handler that runs h with the given time limit.\n\nThe new Handler calls h.ServeHTTP to handle each request, but if a\ncall runs for longer than its time limit, the handler responds with\na 503 Service Unavailable error and the given message in its body.\n(If msg is empty, a suitable default message will be sent.)\nAfter such a timeout, writes by h to its ResponseWriter will return\nErrHandlerTimeout.\n\nTimeoutHandler buffers all Handler writes to memory and does not\nsupport the Hijacker or Flusher interfaces.\n\nGo input arguments: (h net/http.Handler, dt time.Duration, msg string)\n\nGo return type: Handler\n\nJoker input arguments: [^net/http.Handler h, ^time.Duration dt, ^String msg]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "timeoutHandler(ABEND904(custom-runtime routine not implemented: net/http.Handler(_h)), ABEND904(custom-runtime routine not implemented: time.Duration(_dt)), _msg)"}
;;   [^net/http.Handler _h, ^time.Duration _dt, ^String _msg])

JOKER FUNC net/http/cgi.Request:
;; (defn Request
;;   "Request returns the HTTP request as represented in the current\nenvironment. This assumes the current program is being run\nby a web server in a CGI environment.\nThe returned Request's Body is populated, if applicable.\n\nGo return type: (*struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *struct {Value ...; File ...}; Trailer Header; RemoteAddr string; RequestURI string; TLS *struct {Version int; HandshakeComplete bool; DidResume bool; CipherSuite int; NegotiatedProtocol string; NegotiatedProtocolIsMutual bool; ServerName string; PeerCertificates []*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; VerifiedChains [][]*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; SignedCertificateTimestamps [][]int; OCSPResponse []int; TLSUnique []int}; Cancel ...; Response *Response}, error)\n\nJoker input arguments: []\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/cgi.Header), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND042(cannot find typename net/http/cgi.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/cgi.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/cgi.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/cgi.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/cgi.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/cgi.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/cgi.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/cgi.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/cgi.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/cgi.Response)} Error]"
;;   {:added "1.0"
;;    :go "request()"}
;;   [])

JOKER FUNC net/http/cgi.RequestFromMap:
;; (defn RequestFromMap
;;   "RequestFromMap creates an http.Request from CGI variables.\nThe returned Request's Body field is not populated.\n\nGo input arguments: (params map[])\n\nGo return type: (*struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *struct {Value ...; File ...}; Trailer Header; RemoteAddr string; RequestURI string; TLS *struct {Version int; HandshakeComplete bool; DidResume bool; CipherSuite int; NegotiatedProtocol string; NegotiatedProtocolIsMutual bool; ServerName string; PeerCertificates []*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; VerifiedChains [][]*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; SignedCertificateTimestamps [][]int; OCSPResponse []int; TLSUnique []int}; Cancel ...; Response *Response}, error)\n\nJoker input arguments: [^{} params]\n\nJoker return type: [{:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/cgi.Header), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND042(cannot find typename net/http/cgi.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/cgi.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/cgi.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/cgi.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/cgi.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/cgi.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/cgi.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/cgi.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/cgi.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/cgi.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/cgi.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/cgi.IP), :Mask ^ABEND042(cannot find typename net/http/cgi.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/cgi.Response)} Error]"
;;   {:added "1.0"
;;    :go "requestFromMap(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))"}
;;   [^{} _params])

JOKER FUNC net/http/cgi.Serve:
;; (defn ^"Error" Serve
;;   "Serve executes the provided Handler on the currently active CGI\nrequest, if any. If there's no current CGI environment\nan error is returned. The provided handler may be nil to use\nhttp.DefaultServeMux.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^net/http.Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "cgi.Serve(ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^net/http.Handler _handler])

JOKER FUNC net/http/cookiejar.New:
;; (defn New
;;   "New returns a new cookie jar. A nil *Options is equivalent to a zero\nOptions.\n\nGo input arguments: (o *net/http/cookiejar.Options)\n\nGo return type: (*Jar, error)\n\nJoker input arguments: [^(atom-of net/http/cookiejar.Options) o]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "new(ConvertToIndirectOfnet/http/cookiejar.Options(ABEND904(custom-runtime routine not implemented: net/http/cookiejar.Options(_o))))"}
;;   [^Object _o])

JOKER FUNC net/http/fcgi.ProcessEnv:
;; (defn ProcessEnv
;;   "ProcessEnv returns FastCGI environment variables associated with the request r\nfor which no effort was made to be included in the request itself - the data\nis hidden in the request's context. As an example, if REMOTE_USER is set for a\nrequest, it will not be found anywhere in r, but it will be included in\nProcessEnv's response (via r's context).\n\nGo input arguments: (r *net/http.Request)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of net/http.Request) r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/fcgi/child.go:358:34)"
;;   {:added "1.0"
;;    :go "processEnv(ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^Object _r])

JOKER FUNC net/http/fcgi.Serve:
;; (defn ^"Error" Serve
;;   "Serve accepts incoming FastCGI connections on the listener l, creating a new\ngoroutine for each. The goroutine reads requests and then calls handler\nto reply to them.\nIf l is nil, Serve accepts connections from os.Stdin.\nIf handler is nil, http.DefaultServeMux is used.\n\nGo input arguments: (l net.Listener, handler net/http.Handler)\n\nGo return type: error\n\nJoker input arguments: [^net.Listener l, ^net/http.Handler handler]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "fcgi.Serve(ABEND904(custom-runtime routine not implemented: net.Listener(_l)), ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler)))"}
;;   [^net.Listener _l, ^net/http.Handler _handler])

JOKER FUNC net/http/httptest.NewRecorder:
;; (defn NewRecorder
;;   "NewRecorder returns an initialized ResponseRecorder.\n\nGo return type: *ResponseRecorder\n\nJoker input arguments: []\n\nJoker return type: {:Code ^Int, :HeaderMap ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/header.go:20:13), :Body ^{}, :Flushed ^Bool}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRecorder())"}
;;   [])

JOKER FUNC net/http/httptest.NewRequest:
;; (defn NewRequest
;;   "NewRequest returns a new incoming server Request, suitable\nfor passing to an http.Handler for testing.\n\nThe target is the RFC 7230 \"request-target\": it may be either a\npath or an absolute URL. If target is an absolute URL, the host name\nfrom the URL is used. Otherwise, \"example.com\" is used.\n\nThe TLS field is set to a non-nil dummy value if target has scheme\n\"https\".\n\nThe Request.Proto is always HTTP/1.1.\n\nAn empty method means \"GET\".\n\nThe provided body may be nil. If the body is of type *bytes.Reader,\n*strings.Reader, or *bytes.Buffer, the Request.ContentLength is\nset.\n\nNewRequest panics on error for ease of use in testing, where a\npanic is acceptable.\n\nTo generate a client HTTP request instead of a server request, see\nthe NewRequest function in the net/http package.\n\nGo input arguments: (method string, target string, body io.Reader)\n\nGo return type: *struct {Method string; URL *struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; Proto string; ProtoMajor int; ProtoMinor int; Header Header; Body ...; GetBody ...; ContentLength int; TransferEncoding []string; Close bool; Host string; Form ...; PostForm ...; MultipartForm *struct {Value ...; File ...}; Trailer Header; RemoteAddr string; RequestURI string; TLS *struct {Version int; HandshakeComplete bool; DidResume bool; CipherSuite int; NegotiatedProtocol string; NegotiatedProtocolIsMutual bool; ServerName string; PeerCertificates []*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; VerifiedChains [][]*struct {Raw []int; RawTBSCertificate []int; RawSubjectPublicKeyInfo []int; RawSubject []int; RawIssuer []int; Signature []int; SignatureAlgorithm SignatureAlgorithm; PublicKeyAlgorithm PublicKeyAlgorithm; PublicKey ...; Version int; SerialNumber *struct {}; Issuer struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; Subject struct {Country []string; Organization []string; OrganizationalUnit []string; Locality []string; Province []string; StreetAddress []string; PostalCode []string; SerialNumber string; CommonName string; Names []AttributeTypeAndValue; ExtraNames []AttributeTypeAndValue}; NotBefore struct {}; NotAfter struct {}; KeyUsage KeyUsage; Extensions []struct {Id []int; Critical bool; Value []int}; ExtraExtensions []struct {Id []int; Critical bool; Value []int}; UnhandledCriticalExtensions [][]int; ExtKeyUsage []ExtKeyUsage; UnknownExtKeyUsage [][]int; BasicConstraintsValid bool; IsCA bool; MaxPathLen int; MaxPathLenZero bool; SubjectKeyId []int; AuthorityKeyId []int; OCSPServer []string; IssuingCertificateURL []string; DNSNames []string; EmailAddresses []string; IPAddresses [][]int; URIs []*struct {Scheme string; Opaque string; User *Userinfo; Host string; Path string; RawPath string; ForceQuery bool; RawQuery string; Fragment string}; PermittedDNSDomainsCritical bool; PermittedDNSDomains []string; ExcludedDNSDomains []string; PermittedIPRanges []*struct {IP IP; Mask IPMask}; ExcludedIPRanges []*struct {IP IP; Mask IPMask}; PermittedEmailAddresses []string; ExcludedEmailAddresses []string; PermittedURIDomains []string; ExcludedURIDomains []string; CRLDistributionPoints []string; PolicyIdentifiers [][]int}; SignedCertificateTimestamps [][]int; OCSPResponse []int; TLSUnique []int}; Cancel ...; Response *Response}\n\nJoker input arguments: [^String method, ^String target, ^io.Reader body]\n\nJoker return type: {:Method ^String, :URL ^{:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/httptest.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}, :Proto ^String, :ProtoMajor ^Int, :ProtoMinor ^Int, :Header ^ABEND042(cannot find typename net/http/httptest.Header), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:126:17), :GetBody ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/request.go:189:10), :ContentLength ^Int, :TransferEncoding ^(vector-of String), :Close ^Bool, :Host ^String, :Form ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :PostForm ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13), :MultipartForm ^{:Value ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:118:8), :File ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/mime/multipart/formdata.go:119:8)}, :Trailer ^ABEND042(cannot find typename net/http/httptest.Header), :RemoteAddr ^String, :RequestURI ^String, :TLS ^{:Version ^Int, :HandshakeComplete ^Bool, :DidResume ^Bool, :CipherSuite ^Int, :NegotiatedProtocol ^String, :NegotiatedProtocolIsMutual ^Bool, :ServerName ^String, :PeerCertificates ^(vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/httptest.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/httptest.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/httptest.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/httptest.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/httptest.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/httptest.IP), :Mask ^ABEND042(cannot find typename net/http/httptest.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/httptest.IP), :Mask ^ABEND042(cannot find typename net/http/httptest.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))}), :VerifiedChains ^(vector-of (vector-of {:Raw ^(vector-of Int), :RawTBSCertificate ^(vector-of Int), :RawSubjectPublicKeyInfo ^(vector-of Int), :RawSubject ^(vector-of Int), :RawIssuer ^(vector-of Int), :Signature ^(vector-of Int), :SignatureAlgorithm ^ABEND042(cannot find typename net/http/httptest.SignatureAlgorithm), :PublicKeyAlgorithm ^ABEND042(cannot find typename net/http/httptest.PublicKeyAlgorithm), :PublicKey ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/crypto/x509/x509.go:644:21), :Version ^Int, :SerialNumber ^{}, :Issuer ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue))}, :Subject ^{:Country ^(vector-of String), :Organization ^(vector-of String), :OrganizationalUnit ^(vector-of String), :Locality ^(vector-of String), :Province ^(vector-of String), :StreetAddress ^(vector-of String), :PostalCode ^(vector-of String), :SerialNumber ^String, :CommonName ^String, :Names ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue)), :ExtraNames ^(vector-of ABEND042(cannot find typename net/http/httptest.AttributeTypeAndValue))}, :NotBefore ^{}, :NotAfter ^{}, :KeyUsage ^ABEND042(cannot find typename net/http/httptest.KeyUsage), :Extensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :ExtraExtensions ^(vector-of {:Id ^(vector-of Int), :Critical ^Bool, :Value ^(vector-of Int)}), :UnhandledCriticalExtensions ^(vector-of (vector-of Int)), :ExtKeyUsage ^(vector-of ABEND042(cannot find typename net/http/httptest.ExtKeyUsage)), :UnknownExtKeyUsage ^(vector-of (vector-of Int)), :BasicConstraintsValid ^Bool, :IsCA ^Bool, :MaxPathLen ^Int, :MaxPathLenZero ^Bool, :SubjectKeyId ^(vector-of Int), :AuthorityKeyId ^(vector-of Int), :OCSPServer ^(vector-of String), :IssuingCertificateURL ^(vector-of String), :DNSNames ^(vector-of String), :EmailAddresses ^(vector-of String), :IPAddresses ^(vector-of (vector-of Int)), :URIs ^(vector-of {:Scheme ^String, :Opaque ^String, :User ^ABEND042(cannot find typename net/http/httptest.Userinfo), :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String}), :PermittedDNSDomainsCritical ^Bool, :PermittedDNSDomains ^(vector-of String), :ExcludedDNSDomains ^(vector-of String), :PermittedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/httptest.IP), :Mask ^ABEND042(cannot find typename net/http/httptest.IPMask)}), :ExcludedIPRanges ^(vector-of {:IP ^ABEND042(cannot find typename net/http/httptest.IP), :Mask ^ABEND042(cannot find typename net/http/httptest.IPMask)}), :PermittedEmailAddresses ^(vector-of String), :ExcludedEmailAddresses ^(vector-of String), :PermittedURIDomains ^(vector-of String), :ExcludedURIDomains ^(vector-of String), :CRLDistributionPoints ^(vector-of String), :PolicyIdentifiers ^(vector-of (vector-of Int))})), :SignedCertificateTimestamps ^(vector-of (vector-of Int)), :OCSPResponse ^(vector-of Int), :TLSUnique ^(vector-of Int)}, :Cancel ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/net/http/request.go:308:9), :Response ^ABEND042(cannot find typename net/http/httptest.Response)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newRequest(_method, _target, ABEND904(custom-runtime routine not implemented: io.Reader(_body))))"}
;;   [^String _method, ^String _target, ^io.Reader _body])

JOKER FUNC net/http/httptest.NewServer:
;; (defn NewServer
;;   "NewServer starts and returns a new Server.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^net/http.Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15), :TLS ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :ReadTimeout ^Int, :ReadHeaderTimeout ^Int, :WriteTimeout ^Int, :IdleTimeout ^Int, :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/server.go:2506:12), :ErrorLog ^{}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer(ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler))))"}
;;   [^net/http.Handler _handler])

JOKER FUNC net/http/httptest.NewTLSServer:
;; (defn NewTLSServer
;;   "NewTLSServer starts and returns a new Server using TLS.\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^net/http.Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15), :TLS ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :ReadTimeout ^Int, :ReadHeaderTimeout ^Int, :WriteTimeout ^Int, :IdleTimeout ^Int, :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/server.go:2506:12), :ErrorLog ^{}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTLSServer(ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler))))"}
;;   [^net/http.Handler _handler])

JOKER FUNC net/http/httptest.NewUnstartedServer:
;; (defn NewUnstartedServer
;;   "NewUnstartedServer returns a new Server but doesn't start it.\n\nAfter changing its configuration, the caller should call Start or\nStartTLS.\n\nThe caller should call Close when finished, to shut it down.\n\nGo input arguments: (handler net/http.Handler)\n\nGo return type: *Server\n\nJoker input arguments: [^net/http.Handler handler]\n\nJoker return type: {:URL ^String, :Listener ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/net.go:365:15), :TLS ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :Config ^{:Addr ^String, :Handler ^ABEND042(cannot find typename net/http/httptest.Handler), :TLSConfig ^{:Rand ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Time ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:353:7), :Certificates ^(vector-of ABEND042(cannot find typename net/http/httptest.Certificate)), :NameToCertificate ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/crypto/tls/common.go:368:20), :GetCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:377:17), :GetClientCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:392:23), :GetConfigForClient ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:412:21), :VerifyPeerCertificate ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/crypto/tls/common.go:425:24), :RootCAs ^{}, :NextProtos ^(vector-of String), :ServerName ^String, :ClientAuth ^ABEND042(cannot find typename net/http/httptest.ClientAuthType), :ClientCAs ^{}, :InsecureSkipVerify ^Bool, :CipherSuites ^(vector-of Int), :PreferServerCipherSuites ^Bool, :SessionTicketsDisabled ^Bool, :SessionTicketKey ^(vector-of Int), :ClientSessionCache ^ABEND042(cannot find typename net/http/httptest.ClientSessionCache), :MinVersion ^Int, :MaxVersion ^Int, :CurvePreferences ^(vector-of ABEND042(cannot find typename net/http/httptest.CurveID)), :DynamicRecordSizingDisabled ^Bool, :Renegotiation ^ABEND042(cannot find typename net/http/httptest.RenegotiationSupport), :KeyLogWriter ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)}, :ReadTimeout ^Int, :ReadHeaderTimeout ^Int, :WriteTimeout ^Int, :IdleTimeout ^Int, :MaxHeaderBytes ^Int, :TLSNextProto ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/http/server.go:2501:15), :ConnState ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/server.go:2506:12), :ErrorLog ^{}}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newUnstartedServer(ABEND904(custom-runtime routine not implemented: net/http.Handler(_handler))))"}
;;   [^net/http.Handler _handler])

JOKER FUNC net/http/httptrace.ContextClientTrace:
;; (defn ContextClientTrace
;;   "ContextClientTrace returns the ClientTrace associated with the\nprovided context. If none, it returns nil.\n\nGo input arguments: (ctx context.Context)\n\nGo return type: *ClientTrace\n\nJoker input arguments: [^context.Context ctx]\n\nJoker return type: {:GetConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:85:10), :GotConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:91:10), :PutIdleConn ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:101:14), :GotFirstResponseByte ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:105:23), :Got100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:109:17), :Got1xxResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:115:17), :DNSStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:118:11), :DNSDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:121:10), :ConnectStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:126:15), :ConnectDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:133:14), :TLSHandshakeStart ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:138:20), :TLSHandshakeDone ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:143:19), :WroteHeaderField ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:148:19), :WroteHeaders ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:152:15), :Wait100Continue ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:158:18), :WroteRequest ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httptrace/trace.go:163:15)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: contextClientTrace(ABEND904(custom-runtime routine not implemented: context.Context(_ctx))))"}
;;   [^context.Context _ctx])

JOKER FUNC net/http/httptrace.WithClientTrace:
;; (defn WithClientTrace
;;   "WithClientTrace returns a new context based on the provided parent\nctx. HTTP client requests made with the returned context will use\nthe provided trace hooks, in addition to any previous hooks\nregistered with ctx. Any hooks defined in the provided trace will\nbe called first.\n\nGo input arguments: (ctx context.Context, trace *net/http/httptrace.ClientTrace)\n\nGo return type: ...\n\nJoker input arguments: [^context.Context ctx, ^(atom-of net/http/httptrace.ClientTrace) trace]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "withClientTrace(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), ConvertToIndirectOfnet/http/httptrace.ClientTrace(ABEND904(custom-runtime routine not implemented: net/http/httptrace.ClientTrace(_trace))))"}
;;   [^context.Context _ctx, ^Object _trace])

JOKER FUNC net/http/httputil.DumpRequest:
;; (defn DumpRequest
;;   "DumpRequest returns the given request in its HTTP/1.x wire\nrepresentation. It should only be used by servers to debug client\nrequests. The returned representation is an approximation only;\nsome details of the initial request are lost while parsing it into\nan http.Request. In particular, the order and case of header field\nnames are lost. The order of values in multi-valued headers is kept\nintact. HTTP/2 requests are dumped in HTTP/1.x form, not in their\noriginal binary representations.\n\nIf body is true, DumpRequest also returns the body. To do so, it\nconsumes req.Body and then replaces it with a new io.ReadCloser\nthat yields the same bytes. If DumpRequest returns an error,\nthe state of req is undefined.\n\nThe documentation for http.Request.Write details which fields\nof req are included in the dump.\n\nGo input arguments: (req *net/http.Request, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of net/http.Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequest(ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_req))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpRequestOut:
;; (defn DumpRequestOut
;;   "DumpRequestOut is like DumpRequest but for outgoing client requests. It\nincludes any headers that the standard http.Transport adds, such as\nUser-Agent.\n\nGo input arguments: (req *net/http.Request, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of net/http.Request) req, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpRequestOut(ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_req))), _body)"}
;;   [^Object _req, ^Bool _body])

JOKER FUNC net/http/httputil.DumpResponse:
;; (defn DumpResponse
;;   "DumpResponse is like DumpRequest but dumps a response.\n\nGo input arguments: (resp *net/http.Response, body bool)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of net/http.Response) resp, ^Bool body]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "dumpResponse(ConvertToIndirectOfnet/http.Response(ABEND904(custom-runtime routine not implemented: net/http.Response(_resp))), _body)"}
;;   [^Object _resp, ^Bool _body])

JOKER FUNC net/http/httputil.NewChunkedReader:
;; (defn NewChunkedReader
;;   "NewChunkedReader returns a new chunkedReader that translates the data read from r\nout of HTTP \"chunked\" format before returning it.\nThe chunkedReader returns io.EOF when the final 0-length chunk is read.\n\nNewChunkedReader is not needed by normal applications. The http package\nautomatically decodes chunking when reading response bodies.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newChunkedReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC net/http/httputil.NewChunkedWriter:
;; (defn NewChunkedWriter
;;   "NewChunkedWriter returns a new chunkedWriter that translates writes into HTTP\n\"chunked\" format before writing them to w. Closing the returned chunkedWriter\nsends the final 0-length chunk that marks the end of the stream but does\nnot send the final CRLF that appears after trailers; trailers and the last\nCRLF must be written separately.\n\nNewChunkedWriter is not needed by normal applications. The http\npackage adds chunking automatically if handlers don't set a\nContent-Length header. Using NewChunkedWriter inside a handler\nwould result in double chunking or chunking with a Content-Length\nlength, both of which are wrong.\n\nGo input arguments: (w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:132:18)"
;;   {:added "1.0"
;;    :go "newChunkedWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC net/http/httputil.NewClientConn:
;; (defn NewClientConn
;;   "NewClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^net.Conn c, ^(atom-of bufio.Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^net.Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewProxyClientConn:
;; (defn NewProxyClientConn
;;   "NewProxyClientConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Client or Transport in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ClientConn\n\nJoker input arguments: [^net.Conn c, ^(atom-of bufio.Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newProxyClientConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^net.Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewServerConn:
;; (defn NewServerConn
;;   "NewServerConn is an artifact of Go's early HTTP implementation.\nIt is low-level, old, and unused by Go's current HTTP stack.\nWe should have deleted it before Go 1.\n\nDeprecated: Use the Server in package net/http instead.\n\nGo input arguments: (c net.Conn, r *bufio.Reader)\n\nGo return type: *ServerConn\n\nJoker input arguments: [^net.Conn c, ^(atom-of bufio.Reader) r]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServerConn(ABEND904(custom-runtime routine not implemented: net.Conn(_c)), ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^net.Conn _c, ^Object _r])

JOKER FUNC net/http/httputil.NewSingleHostReverseProxy:
;; (defn NewSingleHostReverseProxy
;;   "NewSingleHostReverseProxy returns a new ReverseProxy that routes\nURLs to the scheme, host, and base path provided in target. If the\ntarget's path is \"/base\" and the incoming request was for \"/dir\",\nthe target request will be for /base/dir.\nNewSingleHostReverseProxy does not rewrite the Host header.\nTo rewrite Host headers, use ReverseProxy directly with a custom\nDirector policy.\n\nGo input arguments: (target *net/url.URL)\n\nGo return type: *ReverseProxy\n\nJoker input arguments: [^(atom-of net/url.URL) target]\n\nJoker return type: {:Director ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:35:11), :Transport ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/client.go:115:19), :FlushInterval ^Int, :ErrorLog ^{}, :BufferPool ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/httputil/reverseproxy.go:79:17), :ModifyResponse ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:67:17), :ErrorHandler ^ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/net/http/httputil/reverseproxy.go:74:15)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newSingleHostReverseProxy(ConvertToIndirectOfnet/url.URL(ABEND904(custom-runtime routine not implemented: net/url.URL(_target)))))"}
;;   [^Object _target])

JOKER FUNC net/http/pprof.Cmdline:
;; (defn Cmdline
;;   "Cmdline responds with the running program's\ncommand line, with arguments separated by NUL bytes.\nThe package initialization registers it as /debug/pprof/cmdline.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "cmdline(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Handler:
;; (defn Handler
;;   "Handler returns an HTTP handler that serves the named profile.\n\nGo input arguments: (name string)\n\nGo return type: ...\n\nJoker input arguments: [^String name]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/http/server.go:84:14)"
;;   {:added "1.0"
;;    :go "handler(_name)"}
;;   [^String _name])

JOKER FUNC net/http/pprof.Index:
;; (defn Index
;;   "Index responds with the pprof-formatted profile named by the request.\nFor example, \"/debug/pprof/heap\" serves the \"heap\" profile.\nIndex responds to a request for \"/debug/pprof/\" with an HTML page\nlisting the available profiles.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "index(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Profile:
;; (defn Profile
;;   "Profile responds with the pprof-formatted cpu profile.\nProfiling lasts for duration specified in seconds GET parameter, or for 30 seconds if not specified.\nThe package initialization registers it as /debug/pprof/profile.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "profile(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Symbol:
;; (defn Symbol
;;   "Symbol looks up the program counters listed in the request,\nresponding with a table mapping program counters to function names.\nThe package initialization registers it as /debug/pprof/symbol.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "symbol(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/http/pprof.Trace:
;; (defn Trace
;;   "Trace responds with the execution trace in binary form.\nTracing lasts for duration specified in seconds GET parameter, or for 1 second if not specified.\nThe package initialization registers it as /debug/pprof/trace.\n\nGo input arguments: (w net/http.ResponseWriter, r *net/http.Request)\n\nJoker input arguments: [^net/http.ResponseWriter w, ^(atom-of net/http.Request) r]"
;;   {:added "1.0"
;;    :go "trace(ABEND904(custom-runtime routine not implemented: net/http.ResponseWriter(_w)), ConvertToIndirectOfnet/http.Request(ABEND904(custom-runtime routine not implemented: net/http.Request(_r))))"}
;;   [^net/http.ResponseWriter _w, ^Object _r])

JOKER FUNC net/mail.ParseAddress:
(defn ParseAddress
  "Parses a single RFC 5322 address, e.g. \"Barry Gibbs <bg@example.com>\"\n\nGo input arguments: (address string)\n\nGo return type: (*Address, error)\n\nJoker input arguments: [^String address]\n\nJoker return type: [{:Name ^String, :Address ^String} Error]"
  {:added "1.0"
   :go "parseAddress(_address)"}
  [^String _address])

JOKER FUNC net/mail.ParseAddressList:
(defn ParseAddressList
  "ParseAddressList parses the given string as a list of addresses.\n\nGo input arguments: (list string)\n\nGo return type: ([]*Address, error)\n\nJoker input arguments: [^String list]\n\nJoker return type: [(vector-of {:Name ^String, :Address ^String}) Error]"
  {:added "1.0"
   :go "parseAddressList(_list)"}
  [^String _list])

JOKER FUNC net/mail.ParseDate:
(defn ParseDate
  "ParseDate parses an RFC 5322 date string.\n\nGo input arguments: (date string)\n\nGo return type: (struct {}, error)\n\nJoker input arguments: [^String date]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parseDate(_date)"}
  [^String _date])

JOKER FUNC net/mail.ReadMessage:
;; (defn ReadMessage
;;   "ReadMessage reads a message from r.\nThe headers are parsed, and the body of the message will be available\nfor reading from msg.Body.\n\nGo input arguments: (r io.Reader)\n\nGo return type: (msg *Message, err error)\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: [{:Header ^ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/mail/message.go:106:13), :Body ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)} Error]"
;;   {:added "1.0"
;;    :go "readMessage(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC net/rpc.Accept:
;; (defn Accept
;;   "Accept accepts connections on the listener and serves requests\nto DefaultServer for each incoming connection.\nAccept blocks; the caller typically invokes it in a go statement.\n\nGo input arguments: (lis net.Listener)\n\nJoker input arguments: [^net.Listener lis]"
;;   {:added "1.0"
;;    :go "accept(ABEND904(custom-runtime routine not implemented: net.Listener(_lis)))"}
;;   [^net.Listener _lis])

JOKER FUNC net/rpc.Dial:
(defn Dial
  "Dial connects to an RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTP:
(defn DialHTTP
  "DialHTTP connects to an HTTP RPC server at the specified network address\nlistening on the default HTTP RPC path.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTP(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc.DialHTTPPath:
(defn DialHTTPPath
  "DialHTTPPath connects to an HTTP RPC server\nat the specified network address and path.\n\nGo input arguments: (network string, address string, path string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String network, ^String address, ^String path]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dialHTTPPath(_network, _address, _path)"}
  [^String _network, ^String _address, ^String _path])

JOKER FUNC net/rpc.HandleHTTP:
;; (defn HandleHTTP
;;   "HandleHTTP registers an HTTP handler for RPC messages to DefaultServer\non DefaultRPCPath and a debugging handler on DefaultDebugPath.\nIt is still necessary to invoke http.Serve(), typically in a go statement.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "handleHTTP()"}
;;   [])

JOKER FUNC net/rpc.NewClient:
;; (defn NewClient
;;   "NewClient returns a new Client to handle requests to the\nset of services at the other end of the connection.\nIt adds a buffer to the write side of the connection so\nthe header and payload are sent as a unit.\n\nThe read and write halves of the connection are serialized independently,\nso no interlocking is required. However each half may be accessed\nconcurrently so the implementation of conn should protect against\nconcurrent reads or concurrent writes.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Client\n\nJoker input arguments: [^io.ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/rpc.NewClientWithCodec:
;; (defn NewClientWithCodec
;;   "NewClientWithCodec is like NewClient but uses the specified\ncodec to encode requests and decode responses.\n\nGo input arguments: (codec net/rpc.ClientCodec)\n\nGo return type: *Client\n\nJoker input arguments: [^net/rpc.ClientCodec codec]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClientWithCodec(ABEND904(custom-runtime routine not implemented: net/rpc.ClientCodec(_codec))))"}
;;   [^net/rpc.ClientCodec _codec])

JOKER FUNC net/rpc.NewServer:
;; (defn NewServer
;;   "NewServer returns a new Server.\n\nGo return type: *Server\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newServer())"}
;;   [])

JOKER FUNC net/rpc.Register:
;; (defn ^"Error" Register
;;   "Register publishes the receiver's methods in the DefaultServer.\n\nGo input arguments: (rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.Register(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.RegisterName:
;; (defn ^"Error" RegisterName
;;   "RegisterName is like Register but uses the provided name for the type\ninstead of the receiver's concrete type.\n\nGo input arguments: (name string, rcvr interface {})\n\nGo return type: error\n\nJoker input arguments: [^String name, ^<protocol-or-something> rcvr]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.RegisterName(_name, ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^String _name, ^<protocol-or-something> _rcvr])

JOKER FUNC net/rpc.ServeCodec:
;; (defn ServeCodec
;;   "ServeCodec is like ServeConn but uses the specified codec to\ndecode requests and encode responses.\n\nGo input arguments: (codec net/rpc.ServerCodec)\n\nJoker input arguments: [^net/rpc.ServerCodec codec]"
;;   {:added "1.0"
;;    :go "serveCodec(ABEND904(custom-runtime routine not implemented: net/rpc.ServerCodec(_codec)))"}
;;   [^net/rpc.ServerCodec _codec])

JOKER FUNC net/rpc.ServeConn:
;; (defn ServeConn
;;   "ServeConn runs the DefaultServer on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\nServeConn uses the gob wire format (see package gob) on the\nconnection. To use an alternate codec, use ServeCodec.\nSee NewClient's comment for information about concurrent access.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^io.ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/rpc.ServeRequest:
;; (defn ^"Error" ServeRequest
;;   "ServeRequest is like ServeCodec but synchronously serves a single request.\nIt does not close the codec upon completion.\n\nGo input arguments: (codec net/rpc.ServerCodec)\n\nGo return type: error\n\nJoker input arguments: [^net/rpc.ServerCodec codec]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "rpc.ServeRequest(ABEND904(custom-runtime routine not implemented: net/rpc.ServerCodec(_codec)))"}
;;   [^net/rpc.ServerCodec _codec])

JOKER FUNC net/rpc/jsonrpc.Dial:
(defn Dial
  "Dial connects to a JSON-RPC server at the specified network address.\n\nGo input arguments: (network string, address string)\n\nGo return type: (*struct {}, error)\n\nJoker input arguments: [^String network, ^String address]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _address)"}
  [^String _network, ^String _address])

JOKER FUNC net/rpc/jsonrpc.NewClient:
;; (defn NewClient
;;   "NewClient returns a new rpc.Client to handle requests to the\nset of services at the other end of the connection.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *struct {}\n\nJoker input arguments: [^io.ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newClient(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewClientCodec:
;; (defn NewClientCodec
;;   "NewClientCodec returns a new rpc.ClientCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: ...\n\nJoker input arguments: [^io.ReadWriteCloser conn]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/rpc/client.go:63:18)"
;;   {:added "1.0"
;;    :go "newClientCodec(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.NewServerCodec:
;; (defn NewServerCodec
;;   "NewServerCodec returns a new rpc.ServerCodec using JSON-RPC on conn.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: ...\n\nJoker input arguments: [^io.ReadWriteCloser conn]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/rpc/server.go:658:18)"
;;   {:added "1.0"
;;    :go "newServerCodec(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/rpc/jsonrpc.ServeConn:
;; (defn ServeConn
;;   "ServeConn runs the JSON-RPC server on a single connection.\nServeConn blocks, serving the connection until the client hangs up.\nThe caller typically invokes ServeConn in a go statement.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nJoker input arguments: [^io.ReadWriteCloser conn]"
;;   {:added "1.0"
;;    :go "serveConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn)))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/smtp.CRAMMD5Auth:
;; (defn CRAMMD5Auth
;;   "CRAMMD5Auth returns an Auth that implements the CRAM-MD5 authentication\nmechanism as defined in RFC 2195.\nThe returned Auth uses the given username and secret to authenticate\nto the server using the challenge-response mechanism.\n\nGo input arguments: (username string, secret string)\n\nGo return type: Auth\n\nJoker input arguments: [^String username, ^String secret]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "cRAMMD5Auth(_username, _secret)"}
;;   [^String _username, ^String _secret])

JOKER FUNC net/smtp.Dial:
(defn Dial
  "Dial returns a new Client connected to an SMTP server at addr.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nGo input arguments: (addr string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^String addr]\n\nJoker return type: [{:Text ^{}} Error]"
  {:added "1.0"
   :go "dial(_addr)"}
  [^String _addr])

JOKER FUNC net/smtp.NewClient:
;; (defn NewClient
;;   "NewClient returns a new Client using an existing connection and host as a\nserver name to be used when authenticating.\n\nGo input arguments: (conn net.Conn, host string)\n\nGo return type: (*Client, error)\n\nJoker input arguments: [^net.Conn conn, ^String host]\n\nJoker return type: [{:Text ^{}} Error]"
;;   {:added "1.0"
;;    :go "newClient(ABEND904(custom-runtime routine not implemented: net.Conn(_conn)), _host)"}
;;   [^net.Conn _conn, ^String _host])

JOKER FUNC net/smtp.PlainAuth:
;; (defn PlainAuth
;;   "PlainAuth returns an Auth that implements the PLAIN authentication\nmechanism as defined in RFC 4616. The returned Auth uses the given\nusername and password to authenticate to host and act as identity.\nUsually identity should be the empty string, to act as username.\n\nPlainAuth will only send the credentials if the connection is using TLS\nor is connected to localhost. Otherwise authentication will fail with an\nerror, without sending the credentials.\n\nGo input arguments: (identity string, username string, password string, host string)\n\nGo return type: Auth\n\nJoker input arguments: [^String identity, ^String username, ^String password, ^String host]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/net/smtp/auth.go:15:11)"
;;   {:added "1.0"
;;    :go "plainAuth(_identity, _username, _password, _host)"}
;;   [^String _identity, ^String _username, ^String _password, ^String _host])

JOKER FUNC net/smtp.SendMail:
;; (defn ^"Error" SendMail
;;   "SendMail connects to the server at addr, switches to TLS if\npossible, authenticates with the optional mechanism a if possible,\nand then sends an email from address from, to addresses to, with\nmessage msg.\nThe addr must include a port, as in \"mail.example.com:smtp\".\n\nThe addresses in the to parameter are the SMTP RCPT addresses.\n\nThe msg parameter should be an RFC 822-style email with headers\nfirst, a blank line, and then the message body. The lines of msg\nshould be CRLF terminated. The msg headers should usually include\nfields such as \"From\", \"To\", \"Subject\", and \"Cc\".  Sending \"Bcc\"\nmessages is accomplished by including an email address in the to\nparameter but not including it in the msg headers.\n\nThe SendMail function and the net/smtp package are low-level\nmechanisms and provide no support for DKIM signing, MIME\nattachments (see the mime/multipart package), or other mail\nfunctionality. Higher-level packages exist outside of the standard\nlibrary.\n\nGo input arguments: (addr string, a net/smtp.Auth, from string, to []string, msg []byte)\n\nGo return type: error\n\nJoker input arguments: [^String addr, ^net/smtp.Auth a, ^String from, ^(vector-of String) to, ^(vector-of Byte) msg]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "smtp.SendMail(_addr, ABEND904(custom-runtime routine not implemented: net/smtp.Auth(_a)), _from, ConvertToArrayOfString(_to), ConvertToArrayOfByte(_msg))"}
;;   [^String _addr, ^net/smtp.Auth _a, ^String _from, ^Object _to, ^Object _msg])

JOKER FUNC net/textproto.CanonicalMIMEHeaderKey:
(defn ^"String" CanonicalMIMEHeaderKey
  "CanonicalMIMEHeaderKey returns the canonical format of the\nMIME header key s. The canonicalization converts the first\nletter and any letter following a hyphen to upper case;\nthe rest are converted to lowercase. For example, the\ncanonical key for \"accept-encoding\" is \"Accept-Encoding\".\nMIME header keys are assumed to be ASCII only.\nIf s contains a space or invalid header field bytes, it is\nreturned without modifications.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.CanonicalMIMEHeaderKey(_s)"}
  [^String _s])

JOKER FUNC net/textproto.Dial:
(defn Dial
  "Dial connects to the given address on the given network using net.Dial\nand then returns a new Conn for the connection.\n\nGo input arguments: (network string, addr string)\n\nGo return type: (*Conn, error)\n\nJoker input arguments: [^String network, ^String addr]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "dial(_network, _addr)"}
  [^String _network, ^String _addr])

JOKER FUNC net/textproto.NewConn:
;; (defn NewConn
;;   "NewConn returns a new Conn using conn for I/O.\n\nGo input arguments: (conn io.ReadWriteCloser)\n\nGo return type: *Conn\n\nJoker input arguments: [^io.ReadWriteCloser conn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newConn(ABEND904(custom-runtime routine not implemented: io.ReadWriteCloser(_conn))))"}
;;   [^io.ReadWriteCloser _conn])

JOKER FUNC net/textproto.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from r.\n\nTo avoid denial of service attacks, the provided bufio.Reader\nshould be reading from an io.LimitReader or similar Reader to bound\nthe size of responses.\n\nGo input arguments: (r *bufio.Reader)\n\nGo return type: *Reader\n\nJoker input arguments: [^(atom-of bufio.Reader) r]\n\nJoker return type: {:R ^{}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(ConvertToIndirectOfbufio.Reader(ABEND904(custom-runtime routine not implemented: bufio.Reader(_r)))))"}
;;   [^Object _r])

JOKER FUNC net/textproto.NewWriter:
;; (defn NewWriter
;;   "NewWriter returns a new Writer writing to w.\n\nGo input arguments: (w *bufio.Writer)\n\nGo return type: *Writer\n\nJoker input arguments: [^(atom-of bufio.Writer) w]\n\nJoker return type: {:W ^{}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ConvertToIndirectOfbufio.Writer(ABEND904(custom-runtime routine not implemented: bufio.Writer(_w)))))"}
;;   [^Object _w])

JOKER FUNC net/textproto.TrimBytes:
(defn TrimBytes
  "TrimBytes returns b without leading and trailing ASCII space.\n\nGo input arguments: (b []byte)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "trimBytes(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC net/textproto.TrimString:
(defn ^"String" TrimString
  "TrimString returns s without leading and trailing ASCII space.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "textproto.TrimString(_s)"}
  [^String _s])

JOKER FUNC net/url.Parse:
(defn Parse
  "Parse parses rawurl into a URL structure.\n\nThe rawurl may be relative (a path, without a host) or absolute\n(starting with a scheme). Trying to parse a hostname and path\nwithout a scheme is invalid but may not necessarily return an\nerror, due to parsing ambiguities.\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parse(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.ParseQuery:
;; (defn ParseQuery
;;   "ParseQuery parses the URL-encoded query string and returns\na map listing the values specified for each key.\nParseQuery always returns a non-nil map containing all the\nvalid query parameters found; err describes the first decoding error\nencountered, if any.\n\nQuery is expected to be a list of key=value settings separated by\nampersands or semicolons. A setting without an equals sign is\ninterpreted as a key set to an empty value.\n\nGo input arguments: (query string)\n\nGo return type: (Values, error)\n\nJoker input arguments: [^String query]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/net/url/url.go:804:13) Error]"
;;   {:added "1.0"
;;    :go "parseQuery(_query)"}
;;   [^String _query])

JOKER FUNC net/url.ParseRequestURI:
(defn ParseRequestURI
  "ParseRequestURI parses rawurl into a URL structure. It assumes that\nrawurl was received in an HTTP request, so the rawurl is interpreted\nonly as an absolute URI or an absolute path.\nThe string rawurl is assumed not to have a #fragment suffix.\n(Web browsers strip #fragment before sending the URL to a web server.)\n\nGo input arguments: (rawurl string)\n\nGo return type: (*URL, error)\n\nJoker input arguments: [^String rawurl]\n\nJoker return type: [{:Scheme ^String, :Opaque ^String, :User ^{}, :Host ^String, :Path ^String, :RawPath ^String, :ForceQuery ^Bool, :RawQuery ^String, :Fragment ^String} Error]"
  {:added "1.0"
   :go "parseRequestURI(_rawurl)"}
  [^String _rawurl])

JOKER FUNC net/url.PathEscape:
(defn ^"String" PathEscape
  "PathEscape escapes the string so it can be safely placed\ninside a URL path segment.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.PathEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.PathUnescape:
(defn PathUnescape
  "PathUnescape does the inverse transformation of PathEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB. It returns an error if any % is not followed\nby two hexadecimal digits.\n\nPathUnescape is identical to QueryUnescape except that it does not\nunescape '+' to ' ' (space).\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "pathUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryEscape:
(defn ^"String" QueryEscape
  "QueryEscape escapes the string so it can be safely placed\ninside a URL query.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "url.QueryEscape(_s)"}
  [^String _s])

JOKER FUNC net/url.QueryUnescape:
(defn QueryUnescape
  "QueryUnescape does the inverse transformation of QueryEscape,\nconverting each 3-byte encoded substring of the form \"%AB\" into the\nhex-decoded byte 0xAB.\nIt returns an error if any % is not followed by two hexadecimal\ndigits.\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "queryUnescape(_s)"}
  [^String _s])

JOKER FUNC net/url.User:
;; (defn User
;;   "User returns a Userinfo containing the provided username\nand no password set.\n\nGo input arguments: (username string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: user(_username))"}
;;   [^String _username])

JOKER FUNC net/url.UserPassword:
;; (defn UserPassword
;;   "UserPassword returns a Userinfo containing the provided username\nand password.\n\nThis functionality should only be used with legacy web sites.\nRFC 2396 warns that interpreting Userinfo this way\n``is NOT RECOMMENDED, because the passing of authentication\ninformation in clear text (such as URI) has proven to be a\nsecurity risk in almost every case where it has been used.''\n\nGo input arguments: (username string, password string)\n\nGo return type: *Userinfo\n\nJoker input arguments: [^String username, ^String password]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: userPassword(_username, _password))"}
;;   [^String _username, ^String _password])

JOKER FUNC os.Chdir:
(defn ^"Error" Chdir
  "Chdir changes the current working directory to the named directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (dir string)\n\nGo return type: error\n\nJoker input arguments: [^String dir]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chdir(_dir)"}
  [^String _dir])

JOKER FUNC os.Chmod:
;; (defn ^"Error" Chmod
;;   "Chmod changes the mode of the named file to mode.\nIf the file is a symbolic link, it changes the mode of the link's target.\nIf there is an error, it will be of type *PathError.\n\nA different subset of the mode bits are used, depending on the\noperating system.\n\nOn Unix, the mode's permission bits, ModeSetuid, ModeSetgid, and\nModeSticky are used.\n\nOn Windows, the mode must be non-zero but otherwise only the 0200\nbit (owner writable) of mode is used; it controls whether the\nfile's read-only attribute is set or cleared. attribute. The other\nbits are currently unused. Use mode 0400 for a read-only file and\n0600 for a readable+writable file.\n\nOn Plan 9, the mode's permission bits, ModeAppend, ModeExclusive,\nand ModeTemporary are used.\n\nGo input arguments: (name string, mode os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^os.FileMode mode]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chmod(_name, ABEND904(custom-runtime routine not implemented: os.FileMode(_mode)))"}
;;   [^String _name, ^os.FileMode _mode])

JOKER FUNC os.Chown:
(defn ^"Error" Chown
  "Chown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link's target.\nA uid or gid of -1 means to not change that value.\nIf there is an error, it will be of type *PathError.\n\nOn Windows or Plan 9, Chown always returns the syscall.EWINDOWS or\nEPLAN9 error, wrapped in *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Chown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Chtimes:
;; (defn ^"Error" Chtimes
;;   "Chtimes changes the access and modification times of the named\nfile, similar to the Unix utime() or utimes() functions.\n\nThe underlying filesystem may truncate or round the values to a\nless precise time unit.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, atime time.Time, mtime time.Time)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^time.Time atime, ^time.Time mtime]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Chtimes(_name, ABEND904(custom-runtime routine not implemented: time.Time(_atime)), ABEND904(custom-runtime routine not implemented: time.Time(_mtime)))"}
;;   [^String _name, ^time.Time _atime, ^time.Time _mtime])

JOKER FUNC os.Clearenv:
;; (defn Clearenv
;;   "Clearenv deletes all environment variables.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC os.Create:
(defn Create
  "Create creates the named file with mode 0666 (before umask), truncating\nit if it already exists. If successful, methods on the returned\nFile can be used for I/O; the associated file descriptor has mode\nO_RDWR.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "create(_name)"}
  [^String _name])

JOKER FUNC os.Environ:
(defn Environ
  "Environ returns a copy of strings representing the environment,\nin the form \"key=value\".\n\nGo return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC os.Executable:
(defn Executable
  "Executable returns the path name for the executable that started\nthe current process. There is no guarantee that the path is still\npointing to the correct executable. If a symlink was used to start\nthe process, depending on the operating system, the result might\nbe the symlink or the path it pointed to. If a stable result is\nneeded, path/filepath.EvalSymlinks might help.\n\nExecutable returns an absolute path unless an error occurred.\n\nThe main use case is finding resources located relative to an\nexecutable.\n\nExecutable is not supported on nacl.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "executable()"}
  [])

JOKER FUNC os.Exit:
;; (defn Exit
;;   "Exit causes the current program to exit with the given status code.\nConventionally, code zero indicates success, non-zero an error.\nThe program terminates immediately; deferred functions are not run.\n\nGo input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "exit(_code)"}
;;   [^Int _code])

JOKER FUNC os.Expand:
;; (defn ^"String" Expand
;;   "Expand replaces ${var} or $var in the string based on the mapping function.\nFor example, os.ExpandEnv(s) is equivalent to os.Expand(s, os.Getenv).\n\nGo input arguments: (s string, mapping func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn mapping]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "os.Expand(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _mapping])

JOKER FUNC os.ExpandEnv:
(defn ^"String" ExpandEnv
  "ExpandEnv replaces ${var} or $var in the string according to the values\nof the current environment variables. References to undefined\nvariables are replaced by the empty string.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.ExpandEnv(_s)"}
  [^String _s])

JOKER FUNC os.FindProcess:
(defn FindProcess
  "FindProcess looks for a running process by its pid.\n\nThe Process it returns can be used to obtain information\nabout the underlying operating system process.\n\nOn Unix systems, FindProcess always succeeds and returns a Process\nfor the given pid, regardless of whether the process exists.\n\nGo input arguments: (pid int)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [{:Pid ^Int} Error]"
  {:added "1.0"
   :go "findProcess(_pid)"}
  [^Int _pid])

JOKER FUNC os.Getegid:
(defn ^"Int" Getegid
  "Getegid returns the numeric effective group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getegid()"}
  [])

JOKER FUNC os.Getenv:
(defn ^"String" Getenv
  "Getenv retrieves the value of the environment variable named by the key.\nIt returns the value, which will be empty if the variable is not present.\nTo distinguish between an empty value and an unset value, use LookupEnv.\n\nGo input arguments: (key string)\n\nGo return type: string\n\nJoker input arguments: [^String key]\n\nJoker return type: String"
  {:added "1.0"
   :go "os.Getenv(_key)"}
  [^String _key])

JOKER FUNC os.Geteuid:
(defn ^"Int" Geteuid
  "Geteuid returns the numeric effective user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Geteuid()"}
  [])

JOKER FUNC os.Getgid:
(defn ^"Int" Getgid
  "Getgid returns the numeric group id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getgid()"}
  [])

JOKER FUNC os.Getgroups:
(defn Getgroups
  "Getgroups returns a list of the numeric ids of groups that the caller belongs to.\n\nOn Windows, it returns syscall.EWINDOWS. See the os/user package\nfor a possible alternative.\n\nGo return type: ([]int, error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC os.Getpagesize:
(defn ^"Int" Getpagesize
  "Getpagesize returns the underlying system's memory page size.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpagesize()"}
  [])

JOKER FUNC os.Getpid:
(defn ^"Int" Getpid
  "Getpid returns the process id of the caller.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getpid()"}
  [])

JOKER FUNC os.Getppid:
(defn ^"Int" Getppid
  "Getppid returns the process id of the caller's parent.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getppid()"}
  [])

JOKER FUNC os.Getuid:
(defn ^"Int" Getuid
  "Getuid returns the numeric user id of the caller.\n\nOn Windows, it returns -1.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "os.Getuid()"}
  [])

JOKER FUNC os.Getwd:
(defn Getwd
  "Getwd returns a rooted path name corresponding to the\ncurrent directory. If the current directory can be\nreached via multiple paths (due to symbolic links),\nGetwd may return any one of them.\n\nGo return type: (dir string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC os.Hostname:
(defn Hostname
  "Hostname returns the host name reported by the kernel.\n\nGo return type: (name string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "hostname()"}
  [])

JOKER FUNC os.IsExist:
;; (defn ^"Bool" IsExist
;;   "IsExist returns a boolean indicating whether the error is known to report\nthat a file or directory already exists. It is satisfied by ErrExist as\nwell as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:68:18) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsExist(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:68:18) _err])

JOKER FUNC os.IsNotExist:
;; (defn ^"Bool" IsNotExist
;;   "IsNotExist returns a boolean indicating whether the error is known to\nreport that a file or directory does not exist. It is satisfied by\nErrNotExist as well as some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:75:21) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsNotExist(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:75:21) _err])

JOKER FUNC os.IsPathSeparator:
;; (defn ^"Bool" IsPathSeparator
;;   "IsPathSeparator reports whether c is a directory separator character.\n\nGo input arguments: (c uint8)\n\nGo return type: bool\n\nJoker input arguments: [^uint8 c]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPathSeparator(_c)"}
;;   [^ABEND044(unsupported built-in type uint8) _c])

JOKER FUNC os.IsPermission:
;; (defn ^"Bool" IsPermission
;;   "IsPermission returns a boolean indicating whether the error is known to\nreport that permission is denied. It is satisfied by ErrPermission as well\nas some syscall errors.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:82:23) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsPermission(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:82:23) _err])

JOKER FUNC os.IsTimeout:
;; (defn ^"Bool" IsTimeout
;;   "IsTimeout returns a boolean indicating whether the error is known\nto report that a timeout occurred.\n\nGo input arguments: (err error)\n\nGo return type: bool\n\nJoker input arguments: [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:88:20) err]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.IsTimeout(_err)"}
;;   [^ABEND885(unrecognized type error at: GO.link/src/os/error.go:88:20) _err])

JOKER FUNC os.Lchown:
(defn ^"Error" Lchown
  "Lchown changes the numeric uid and gid of the named file.\nIf the file is a symbolic link, it changes the uid and gid of the link itself.\nIf there is an error, it will be of type *PathError.\n\nOn Windows, it always returns the syscall.EWINDOWS error, wrapped\nin *PathError.\n\nGo input arguments: (name string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Lchown(_name, _uid, _gid)"}
  [^String _name, ^Int _uid, ^Int _gid])

JOKER FUNC os.Link:
(defn ^"Error" Link
  "Link creates newname as a hard link to the oldname file.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Link(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.LookupEnv:
(defn LookupEnv
  "LookupEnv retrieves the value of the environment variable named\nby the key. If the variable is present in the environment the\nvalue (which may be empty) is returned and the boolean is true.\nOtherwise the returned value will be empty and the boolean will\nbe false.\n\nGo input arguments: (key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "lookupEnv(_key)"}
  [^String _key])

JOKER FUNC os.Lstat:
;; (defn Lstat
;;   "Lstat returns a FileInfo describing the named file.\nIf the file is a symbolic link, the returned FileInfo\ndescribes the symbolic link. Lstat makes no attempt to follow the link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "lstat(_name)"}
;;   [^String _name])

JOKER FUNC os.Mkdir:
;; (defn ^"Error" Mkdir
;;   "Mkdir creates a new directory with the specified name and permission\nbits (before umask).\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^os.FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.Mkdir(_name, ABEND904(custom-runtime routine not implemented: os.FileMode(_perm)))"}
;;   [^String _name, ^os.FileMode _perm])

JOKER FUNC os.MkdirAll:
;; (defn ^"Error" MkdirAll
;;   "MkdirAll creates a directory named path,\nalong with any necessary parents, and returns nil,\nor else returns an error.\nThe permission bits perm (before umask) are used for all\ndirectories that MkdirAll creates.\nIf path is already a directory, MkdirAll does nothing\nand returns nil.\n\nGo input arguments: (path string, perm os.FileMode)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^os.FileMode perm]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.MkdirAll(_path, ABEND904(custom-runtime routine not implemented: os.FileMode(_perm)))"}
;;   [^String _path, ^os.FileMode _perm])

JOKER FUNC os.NewFile:
;; (defn NewFile
;;   "NewFile returns a new File with the given file descriptor and\nname. The returned value will be nil if fd is not a valid file\ndescriptor. On Unix systems, if the file descriptor is in\nnon-blocking mode, NewFile will attempt to return a pollable File\n(one for which the SetDeadline methods work).\n\nGo input arguments: (fd uintptr, name string)\n\nGo return type: *File\n\nJoker input arguments: [^uintptr fd, ^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newFile(_fd, _name))"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd, ^String _name])

JOKER FUNC os.NewSyscallError:
;; (defn ^"Error" NewSyscallError
;;   "NewSyscallError returns, as an error, a new SyscallError\nwith the given system call name and error details.\nAs a convenience, if err is nil, NewSyscallError returns nil.\n\nGo input arguments: (syscall string, err error)\n\nGo return type: error\n\nJoker input arguments: [^String syscall, ^ABEND885(unrecognized type error at: GO.link/src/os/error.go:58:42) err]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "os.NewSyscallError(_syscall, _err)"}
;;   [^String _syscall, ^ABEND885(unrecognized type error at: GO.link/src/os/error.go:58:42) _err])

JOKER FUNC os.Open:
(defn Open
  "Open opens the named file for reading. If successful, methods on\nthe returned file can be used for reading; the associated file\ndescriptor has mode O_RDONLY.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(_name)"}
  [^String _name])

JOKER FUNC os.OpenFile:
;; (defn OpenFile
;;   "OpenFile is the generalized open call; most users will use Open\nor Create instead. It opens the named file with specified flag\n(O_RDONLY etc.) and perm (before umask), if applicable. If successful,\nmethods on the returned File can be used for I/O.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, flag int, perm os.FileMode)\n\nGo return type: (*File, error)\n\nJoker input arguments: [^String name, ^Int flag, ^os.FileMode perm]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "openFile(_name, _flag, ABEND904(custom-runtime routine not implemented: os.FileMode(_perm)))"}
;;   [^String _name, ^Int _flag, ^os.FileMode _perm])

JOKER FUNC os.Pipe:
(defn Pipe
  "Pipe returns a connected pair of Files; reads from r return bytes written to w.\nIt returns the files and an error, if any.\n\nGo return type: (r *File, w *File, err error)\n\nJoker input arguments: []\n\nJoker return type: [{} {} Error]"
  {:added "1.0"
   :go "pipe()"}
  [])

JOKER FUNC os.Readlink:
(defn Readlink
  "Readlink returns the destination of the named symbolic link.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "readlink(_name)"}
  [^String _name])

JOKER FUNC os.Remove:
(defn ^"Error" Remove
  "Remove removes the named file or (empty) directory.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: error\n\nJoker input arguments: [^String name]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Remove(_name)"}
  [^String _name])

JOKER FUNC os.RemoveAll:
(defn ^"Error" RemoveAll
  "RemoveAll removes path and any children it contains.\nIt removes everything it can but returns the first error\nit encounters. If the path does not exist, RemoveAll\nreturns nil (no error).\n\nGo input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.RemoveAll(_path)"}
  [^String _path])

JOKER FUNC os.Rename:
(defn ^"Error" Rename
  "Rename renames (moves) oldpath to newpath.\nIf newpath already exists and is not a directory, Rename replaces it.\nOS-specific restrictions may apply when oldpath and newpath are in different directories.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Rename(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC os.SameFile:
;; (defn ^"Bool" SameFile
;;   "SameFile reports whether fi1 and fi2 describe the same file.\nFor example, on Unix this means that the device and inode fields\nof the two underlying structures are identical; on other systems\nthe decision may be based on the path names.\nSameFile only applies to results returned by this package's Stat.\nIt returns false in other cases.\n\nGo input arguments: (fi1 os.FileInfo, fi2 os.FileInfo)\n\nGo return type: bool\n\nJoker input arguments: [^os.FileInfo fi1, ^os.FileInfo fi2]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "os.SameFile(ABEND904(custom-runtime routine not implemented: os.FileInfo(_fi1)), ABEND904(custom-runtime routine not implemented: os.FileInfo(_fi2)))"}
;;   [^os.FileInfo _fi1, ^os.FileInfo _fi2])

JOKER FUNC os.Setenv:
(defn ^"Error" Setenv
  "Setenv sets the value of the environment variable named by the key.\nIt returns an error, if any.\n\nGo input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC os.StartProcess:
;; (defn StartProcess
;;   "StartProcess starts a new process with the program, arguments and attributes\nspecified by name, argv and attr. The argv slice will become os.Args in the\nnew process, so it normally starts with the program name.\n\nIf the calling goroutine has locked the operating system thread\nwith runtime.LockOSThread and modified any inheritable OS-level\nthread state (for example, Linux or Plan 9 name spaces), the new\nprocess will inherit the caller's thread state.\n\nStartProcess is a low-level interface. The os/exec package provides\nhigher-level interfaces.\n\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, argv []string, attr *os.ProcAttr)\n\nGo return type: (*Process, error)\n\nJoker input arguments: [^String name, ^(vector-of String) argv, ^(atom-of os.ProcAttr) attr]\n\nJoker return type: [{:Pid ^Int} Error]"
;;   {:added "1.0"
;;    :go "startProcess(_name, ConvertToArrayOfString(_argv), ConvertToIndirectOfos.ProcAttr(ABEND904(custom-runtime routine not implemented: os.ProcAttr(_attr))))"}
;;   [^String _name, ^Object _argv, ^Object _attr])

JOKER FUNC os.Stat:
;; (defn Stat
;;   "Stat returns a FileInfo describing the named file.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string)\n\nGo return type: (FileInfo, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/os/types.go:21:15) Error]"
;;   {:added "1.0"
;;    :go "stat(_name)"}
;;   [^String _name])

JOKER FUNC os.Symlink:
(defn ^"Error" Symlink
  "Symlink creates newname as a symbolic link to oldname.\nIf there is an error, it will be of type *LinkError.\n\nGo input arguments: (oldname string, newname string)\n\nGo return type: error\n\nJoker input arguments: [^String oldname, ^String newname]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Symlink(_oldname, _newname)"}
  [^String _oldname, ^String _newname])

JOKER FUNC os.TempDir:
(defn ^"String" TempDir
  "TempDir returns the default directory to use for temporary files.\n\nOn Unix systems, it returns $TMPDIR if non-empty, else /tmp.\nOn Windows, it uses GetTempPath, returning the first non-empty\nvalue from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.\nOn Plan 9, it returns /tmp.\n\nThe directory is neither guaranteed to exist nor have accessible\npermissions.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "os.TempDir()"}
  [])

JOKER FUNC os.Truncate:
(defn ^"Error" Truncate
  "Truncate changes the size of the named file.\nIf the file is a symbolic link, it changes the size of the link's target.\nIf there is an error, it will be of type *PathError.\n\nGo input arguments: (name string, size int64)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Int64 size]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Truncate(_name, _size)"}
  [^String _name, ^Int64 _size])

JOKER FUNC os.Unsetenv:
(defn ^"Error" Unsetenv
  "Unsetenv unsets a single environment variable.\n\nGo input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "os.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC os.UserCacheDir:
(defn UserCacheDir
  "UserCacheDir returns the default root directory to use for user-specific\ncached data. Users should create their own application-specific subdirectory\nwithin this one and use that.\n\nOn Unix systems, it returns $XDG_CACHE_HOME as specified by\nhttps://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html if\nnon-empty, else $HOME/.cache.\nOn Darwin, it returns $HOME/Library/Caches.\nOn Windows, it returns %LocalAppData%.\nOn Plan 9, it returns $home/lib/cache.\n\nIf the location cannot be determined (for example, $HOME is not defined),\nthen it will return an error.\n\nGo return type: (string, error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "userCacheDir()"}
  [])

JOKER FUNC os/exec.Command:
;; (defn Command
;;   "Command returns the Cmd struct to execute the named program with\nthe given arguments.\n\nIt sets only the Path and Args in the returned structure.\n\nIf name contains no path separators, Command uses LookPath to\nresolve name to a complete path if possible. Otherwise it uses name\ndirectly as Path.\n\nThe returned Cmd's Args field is constructed from the command name\nfollowed by the elements of arg, so arg should not include the\ncommand name itself. For example, Command(\"echo\", \"hello\").\nArgs[0] is always name, not the possibly resolved Path.\n\nGo input arguments: (name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Stdout ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13), :Stderr ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13), :ExtraFiles ^(vector-of {}), :SysProcAttr ^{:Chroot ^String, :Credential ^ABEND042(cannot find typename os/exec.Credential), :Ptrace ^Bool, :Setsid ^Bool, :Setpgid ^Bool, :Setctty ^Bool, :Noctty ^Bool, :Ctty ^Int, :Foreground ^Bool, :Pgid ^Int, :Pdeathsig ^ABEND042(cannot find typename os/exec.Signal), :Cloneflags ^ABEND043(unsupported built-in type uintptr), :Unshareflags ^ABEND043(unsupported built-in type uintptr), :UidMappings ^(vector-of ABEND042(cannot find typename os/exec.SysProcIDMap)), :GidMappings ^(vector-of ABEND042(cannot find typename os/exec.SysProcIDMap)), :GidMappingsEnableSetgroups ^Bool, :AmbientCaps ^(vector-of ABEND043(unsupported built-in type uintptr))}, :Process ^{:Pid ^Int}, :ProcessState ^{}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: command(_name, ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_arg))))"}
;;   [^String _name, ^String _arg])

JOKER FUNC os/exec.CommandContext:
;; (defn CommandContext
;;   "CommandContext is like Command but includes a context.\n\nThe provided context is used to kill the process (by calling\nos.Process.Kill) if the context becomes done before the command\ncompletes on its own.\n\nGo input arguments: (ctx context.Context, name string, arg ...string)\n\nGo return type: *Cmd\n\nJoker input arguments: [^context.Context ctx, ^String name, ^(ellipsis-somehow String) arg]\n\nJoker return type: {:Path ^String, :Args ^(vector-of String), :Env ^(vector-of String), :Dir ^String, :Stdin ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13), :Stdout ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13), :Stderr ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13), :ExtraFiles ^(vector-of {}), :SysProcAttr ^{:Chroot ^String, :Credential ^ABEND042(cannot find typename os/exec.Credential), :Ptrace ^Bool, :Setsid ^Bool, :Setpgid ^Bool, :Setctty ^Bool, :Noctty ^Bool, :Ctty ^Int, :Foreground ^Bool, :Pgid ^Int, :Pdeathsig ^ABEND042(cannot find typename os/exec.Signal), :Cloneflags ^ABEND043(unsupported built-in type uintptr), :Unshareflags ^ABEND043(unsupported built-in type uintptr), :UidMappings ^(vector-of ABEND042(cannot find typename os/exec.SysProcIDMap)), :GidMappings ^(vector-of ABEND042(cannot find typename os/exec.SysProcIDMap)), :GidMappingsEnableSetgroups ^Bool, :AmbientCaps ^(vector-of ABEND043(unsupported built-in type uintptr))}, :Process ^{:Pid ^Int}, :ProcessState ^{}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: commandContext(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _name, ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_arg))))"}
;;   [^context.Context _ctx, ^String _name, ^String _arg])

JOKER FUNC os/exec.LookPath:
(defn LookPath
  "LookPath searches for an executable named file in the\ndirectories named by the PATH environment variable.\nIf file contains a slash, it is tried directly and the PATH is not consulted.\nThe result may be an absolute path or a path relative to the current directory.\n\nGo input arguments: (file string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String file]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "lookPath(_file)"}
  [^String _file])

JOKER FUNC os/signal.Ignore:
;; (defn Ignore
;;   "Ignore causes the provided signals to be ignored. If they are received by\nthe program, nothing will happen. Ignore undoes the effect of any prior\ncalls to Notify for the provided signals.\nIf no signals are provided, all incoming signals will be ignored.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os.Signal) sig]"
;;   {:added "1.0"
;;    :go "ignore(ConvertToEllipsisHaHaos.Signal(ABEND904(custom-runtime routine not implemented: os.Signal(_sig))))"}
;;   [^os.Signal _sig])

JOKER FUNC os/signal.Ignored:
;; (defn ^"Bool" Ignored
;;   "Ignored reports whether sig is currently ignored.\n\nGo input arguments: (sig os.Signal)\n\nGo return type: bool\n\nJoker input arguments: [^os.Signal sig]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "signal.Ignored(ABEND904(custom-runtime routine not implemented: os.Signal(_sig)))"}
;;   [^os.Signal _sig])

JOKER FUNC os/signal.Notify:
;; (defn Notify
;;   "Notify causes package signal to relay incoming signals to c.\nIf no signals are provided, all incoming signals will be relayed to c.\nOtherwise, just the provided signals will.\n\nPackage signal will not block sending to c: the caller must ensure\nthat c has sufficient buffer space to keep up with the expected\nsignal rate. For a channel used for notification of just one signal value,\na buffer of size 1 is sufficient.\n\nIt is allowed to call Notify multiple times with the same channel:\neach call expands the set of signals sent to that channel.\nThe only way to remove signals from the set is to call Stop.\n\nIt is allowed to call Notify multiple times with different channels\nand the same signals: each channel receives copies of incoming\nsignals independently.\n\nGo input arguments: (c <-chan, sig ...os.Signal)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c, ^(ellipsis-somehow os.Signal) sig]"
;;   {:added "1.0"
;;    :go "notify(ABEND909(custom-runtime routine not implemented: ConvertToChanTypeHaHa()), ConvertToEllipsisHaHaos.Signal(ABEND904(custom-runtime routine not implemented: os.Signal(_sig))))"}
;;   [^<no-idea-about-chan-yet> _c, ^os.Signal _sig])

JOKER FUNC os/signal.Reset:
;; (defn Reset
;;   "Reset undoes the effect of any prior calls to Notify for the provided\nsignals.\nIf no signals are provided, all signal handlers will be reset.\n\nGo input arguments: (sig ...os.Signal)\n\nJoker input arguments: [^(ellipsis-somehow os.Signal) sig]"
;;   {:added "1.0"
;;    :go "reset(ConvertToEllipsisHaHaos.Signal(ABEND904(custom-runtime routine not implemented: os.Signal(_sig))))"}
;;   [^os.Signal _sig])

JOKER FUNC os/signal.Stop:
;; (defn Stop
;;   "Stop causes package signal to stop relaying incoming signals to c.\nIt undoes the effect of all prior calls to Notify using c.\nWhen Stop returns, it is guaranteed that c will receive no more signals.\n\nGo input arguments: (c <-chan)\n\nJoker input arguments: [^<no-idea-about-chan-yet> c]"
;;   {:added "1.0"
;;    :go "stop(ABEND909(custom-runtime routine not implemented: ConvertToChanTypeHaHa()))"}
;;   [^<no-idea-about-chan-yet> _c])

JOKER FUNC os/user.Current:
(defn Current
  "Current returns the current user.\n\nGo return type: (*User, error)\n\nJoker input arguments: []\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "current()"}
  [])

JOKER FUNC os/user.Lookup:
(defn Lookup
  "Lookup looks up a user by username. If the user cannot be found, the\nreturned error is of type UnknownUserError.\n\nGo input arguments: (username string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String username]\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "lookup(_username)"}
  [^String _username])

JOKER FUNC os/user.LookupGroup:
(defn LookupGroup
  "LookupGroup looks up a group by name. If the group cannot be found, the\nreturned error is of type UnknownGroupError.\n\nGo input arguments: (name string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
  {:added "1.0"
   :go "lookupGroup(_name)"}
  [^String _name])

JOKER FUNC os/user.LookupGroupId:
(defn LookupGroupId
  "LookupGroupId looks up a group by groupid. If the group cannot be found, the\nreturned error is of type UnknownGroupIdError.\n\nGo input arguments: (gid string)\n\nGo return type: (*Group, error)\n\nJoker input arguments: [^String gid]\n\nJoker return type: [{:Gid ^String, :Name ^String} Error]"
  {:added "1.0"
   :go "lookupGroupId(_gid)"}
  [^String _gid])

JOKER FUNC os/user.LookupId:
(defn LookupId
  "LookupId looks up a user by userid. If the user cannot be found, the\nreturned error is of type UnknownUserIdError.\n\nGo input arguments: (uid string)\n\nGo return type: (*User, error)\n\nJoker input arguments: [^String uid]\n\nJoker return type: [{:Uid ^String, :Gid ^String, :Username ^String, :Name ^String, :HomeDir ^String} Error]"
  {:added "1.0"
   :go "lookupId(_uid)"}
  [^String _uid])

JOKER FUNC path.Base:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing slashes are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of slashes, Base returns \"/\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Base(_path)"}
  [^String _path])

JOKER FUNC path.Clean:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple slashes with a single slash.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path.\n\nThe returned path ends in a slash only if it is the root \"/\".\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Clean(_path)"}
  [^String _path])

JOKER FUNC path.Dir:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element using Split, the path is Cleaned and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of slashes followed by non-slash bytes, Dir\nreturns a single slash. In any other case, the returned path does not end in a\nslash.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Dir(_path)"}
  [^String _path])

JOKER FUNC path.Ext:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final slash-separated element of path;\nit is empty if there is no dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "path.Ext(_path)"}
  [^String _path])

JOKER FUNC path.IsAbs:
(defn ^"Bool" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "path.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path.Join:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding a\nseparating slash if necessary. The result is Cleaned; in particular,\nall empty strings are ignored.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "path.Join(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_elem)))"}
;;   [^String _elem])

JOKER FUNC path.Match:
(defn Match
  "Match reports whether name matches the shell pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-/ characters\n\t\t'?'         matches any single non-/ character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path.Split:
(defn Split
  "Split splits path immediately following the final slash,\nseparating it into a directory and file name component.\nIf there is no slash in path, Split returns an empty dir and\nfile set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Abs:
(defn Abs
  "Abs returns an absolute representation of path.\nIf the path is not absolute it will be joined with the current\nworking directory to turn it into an absolute path. The absolute\npath name for a given file is not guaranteed to be unique.\nAbs calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "abs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Base:
(defn ^"String" Base
  "Base returns the last element of path.\nTrailing path separators are removed before extracting the last element.\nIf the path is empty, Base returns \".\".\nIf the path consists entirely of separators, Base returns a single separator.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Base(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Clean:
(defn ^"String" Clean
  "Clean returns the shortest path name equivalent to path\nby purely lexical processing. It applies the following rules\niteratively until no further processing can be done:\n\n\t1. Replace multiple Separator elements with a single one.\n\t2. Eliminate each . path name element (the current directory).\n\t3. Eliminate each inner .. path name element (the parent directory)\n\t   along with the non-.. element that precedes it.\n\t4. Eliminate .. elements that begin a rooted path:\n\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n\t   assuming Separator is '/'.\n\nThe returned path ends in a slash only if it represents a root directory,\nsuch as \"/\" on Unix or `C:\\` on Windows.\n\nFinally, any occurrences of slash are replaced by Separator.\n\nIf the result of this process is an empty string, Clean\nreturns the string \".\".\n\nSee also Rob Pike, ``Lexical File Names in Plan 9 or\nGetting Dot-Dot Right,''\nhttps://9p.io/sys/doc/lexnames.html\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Clean(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Dir:
(defn ^"String" Dir
  "Dir returns all but the last element of path, typically the path's directory.\nAfter dropping the final element, Dir calls Clean on the path and trailing\nslashes are removed.\nIf the path is empty, Dir returns \".\".\nIf the path consists entirely of separators, Dir returns a single separator.\nThe returned path does not end in a separator unless it is the root directory.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Dir(_path)"}
  [^String _path])

JOKER FUNC path/filepath.EvalSymlinks:
(defn EvalSymlinks
  "EvalSymlinks returns the path name after the evaluation of any symbolic\nlinks.\nIf path is relative the result will be relative to the current directory,\nunless one of the components is an absolute symbolic link.\nEvalSymlinks calls Clean on the result.\n\nGo input arguments: (path string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "evalSymlinks(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Ext:
(defn ^"String" Ext
  "Ext returns the file name extension used by path.\nThe extension is the suffix beginning at the final dot\nin the final element of path; it is empty if there is\nno dot.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.Ext(_path)"}
  [^String _path])

JOKER FUNC path/filepath.FromSlash:
(defn ^"String" FromSlash
  "FromSlash returns the result of replacing each slash ('/') character\nin path with a separator character. Multiple slashes are replaced\nby multiple separators.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.FromSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Glob:
(defn Glob
  "Glob returns the names of all files matching pattern or nil\nif there is no matching file. The syntax of patterns is the same\nas in Match. The pattern may describe hierarchical names such as\n/usr/*/bin/ed (assuming the Separator is '/').\n\nGlob ignores file system errors such as I/O errors reading directories.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nGo input arguments: (pattern string)\n\nGo return type: (matches []string, err error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [(vector-of String) Error]"
  {:added "1.0"
   :go "glob(_pattern)"}
  [^String _pattern])

JOKER FUNC path/filepath.HasPrefix:
(defn ^"Bool" HasPrefix
  "HasPrefix exists for historical compatibility and should not be used.\n\nDeprecated: HasPrefix does not respect path boundaries and\ndoes not ignore case when required.\n\nGo input arguments: (p string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String p, ^String prefix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.HasPrefix(_p, _prefix)"}
  [^String _p, ^String _prefix])

JOKER FUNC path/filepath.IsAbs:
(defn ^"Bool" IsAbs
  "IsAbs reports whether the path is absolute.\n\nGo input arguments: (path string)\n\nGo return type: bool\n\nJoker input arguments: [^String path]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "filepath.IsAbs(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Join:
;; (defn ^"String" Join
;;   "Join joins any number of path elements into a single path, adding\na Separator if necessary. Join calls Clean on the result; in particular,\nall empty strings are ignored.\nOn Windows, the result is a UNC path if and only if the first path\nelement is a UNC path.\n\nGo input arguments: (elem ...string)\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow String) elem]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "filepath.Join(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_elem)))"}
;;   [^String _elem])

JOKER FUNC path/filepath.Match:
(defn Match
  "Match reports whether name matches the shell file name pattern.\nThe pattern syntax is:\n\n\tpattern:\n\t\t{ term }\n\tterm:\n\t\t'*'         matches any sequence of non-Separator characters\n\t\t'?'         matches any single non-Separator character\n\t\t'[' [ '^' ] { character-range } ']'\n\t\t            character class (must be non-empty)\n\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n\t\t'\\\\' c      matches character c\n\n\tcharacter-range:\n\t\tc           matches character c (c != '\\\\', '-', ']')\n\t\t'\\\\' c      matches character c\n\t\tlo '-' hi   matches character c for lo <= c <= hi\n\nMatch requires pattern to match all of name, not just a substring.\nThe only possible returned error is ErrBadPattern, when pattern\nis malformed.\n\nOn Windows, escaping is disabled. Instead, '\\\\' is treated as\npath separator.\n\nGo input arguments: (pattern string, name string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String name]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(_pattern, _name)"}
  [^String _pattern, ^String _name])

JOKER FUNC path/filepath.Rel:
(defn Rel
  "Rel returns a relative path that is lexically equivalent to targpath when\njoined to basepath with an intervening separator. That is,\nJoin(basepath, Rel(basepath, targpath)) is equivalent to targpath itself.\nOn success, the returned path will always be relative to basepath,\neven if basepath and targpath share no elements.\nAn error is returned if targpath can't be made relative to basepath or if\nknowing the current working directory would be necessary to compute it.\nRel calls Clean on the result.\n\nGo input arguments: (basepath string, targpath string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String basepath, ^String targpath]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "rel(_basepath, _targpath)"}
  [^String _basepath, ^String _targpath])

JOKER FUNC path/filepath.Split:
(defn Split
  "Split splits path immediately following the final Separator,\nseparating it into a directory and file name component.\nIf there is no Separator in path, Split returns an empty dir\nand file set to path.\nThe returned values have the property that path = dir+file.\n\nGo input arguments: (path string)\n\nGo return type: (dir string, file string)\n\nJoker input arguments: [^String path]\n\nJoker return type: [String String]"
  {:added "1.0"
   :go "split(_path)"}
  [^String _path])

JOKER FUNC path/filepath.SplitList:
(defn SplitList
  "SplitList splits a list of paths joined by the OS-specific ListSeparator,\nusually found in PATH or GOPATH environment variables.\nUnlike strings.Split, SplitList returns an empty slice when passed an empty\nstring.\n\nGo input arguments: (path string)\n\nGo return type: []string\n\nJoker input arguments: [^String path]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitList(_path)"}
  [^String _path])

JOKER FUNC path/filepath.ToSlash:
(defn ^"String" ToSlash
  "ToSlash returns the result of replacing each separator character\nin path with a slash ('/') character. Multiple separators are\nreplaced by multiple slashes.\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.ToSlash(_path)"}
  [^String _path])

JOKER FUNC path/filepath.VolumeName:
(defn ^"String" VolumeName
  "VolumeName returns leading volume name.\nGiven \"C:\\foo\\bar\" it returns \"C:\" on Windows.\nGiven \"\\\\host\\share\\foo\" it returns \"\\\\host\\share\".\nOn other platforms it returns \"\".\n\nGo input arguments: (path string)\n\nGo return type: string\n\nJoker input arguments: [^String path]\n\nJoker return type: String"
  {:added "1.0"
   :go "filepath.VolumeName(_path)"}
  [^String _path])

JOKER FUNC path/filepath.Walk:
;; (defn ^"Error" Walk
;;   "Walk walks the file tree rooted at root, calling walkFn for each file or\ndirectory in the tree, including root. All errors that arise visiting files\nand directories are filtered by walkFn. The files are walked in lexical\norder, which makes the output deterministic but means that for very\nlarge directories Walk can be inefficient.\nWalk does not follow symbolic links.\n\nGo input arguments: (root string, walkFn path/filepath.WalkFunc)\n\nGo return type: error\n\nJoker input arguments: [^String root, ^path/filepath.WalkFunc walkFn]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "filepath.Walk(_root, ABEND904(custom-runtime routine not implemented: path/filepath.WalkFunc(_walkFn)))"}
;;   [^String _root, ^path/filepath.WalkFunc _walkFn])

JOKER FUNC plugin.Open:
(defn Open
  "Open opens a Go plugin.\nIf a path has already been opened, then the existing *Plugin is returned.\nIt is safe for concurrent use by multiple goroutines.\n\nGo input arguments: (path string)\n\nGo return type: (*Plugin, error)\n\nJoker input arguments: [^String path]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "open(_path)"}
  [^String _path])

JOKER FUNC reflect.Append:
;; (defn Append
;;   "Append appends the values x to a slice s and returns the resulting slice.\nAs in Go, each x's value must be assignable to the slice's element type.\n\nGo input arguments: (s reflect.Value, x ...reflect.Value)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Value s, ^(ellipsis-somehow reflect.Value) x]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "append(ABEND904(custom-runtime routine not implemented: reflect.Value(_s)), ConvertToEllipsisHaHareflect.Value(ABEND904(custom-runtime routine not implemented: reflect.Value(_x))))"}
;;   [^reflect.Value _s, ^reflect.Value _x])

JOKER FUNC reflect.AppendSlice:
;; (defn AppendSlice
;;   "AppendSlice appends a slice t to a slice s and returns the resulting slice.\nThe slices s and t must have the same element type.\n\nGo input arguments: (s reflect.Value, t reflect.Value)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Value s, ^reflect.Value t]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "appendSlice(ABEND904(custom-runtime routine not implemented: reflect.Value(_s)), ABEND904(custom-runtime routine not implemented: reflect.Value(_t)))"}
;;   [^reflect.Value _s, ^reflect.Value _t])

JOKER FUNC reflect.ArrayOf:
;; (defn ArrayOf
;;   "ArrayOf returns the array type with the given count and element type.\nFor example, if t represents int, ArrayOf(5, t) represents [5]int.\n\nIf the resulting type would be larger than the available address space,\nArrayOf panics.\n\nGo input arguments: (count int, elem reflect.Type)\n\nGo return type: Type\n\nJoker input arguments: [^Int count, ^reflect.Type elem]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "arrayOf(_count, ABEND904(custom-runtime routine not implemented: reflect.Type(_elem)))"}
;;   [^Int _count, ^reflect.Type _elem])

JOKER FUNC reflect.ChanOf:
;; (defn ChanOf
;;   "ChanOf returns the channel type with the given direction and element type.\nFor example, if t represents int, ChanOf(RecvDir, t) represents <-chan int.\n\nThe gc runtime imposes a limit of 64 kB on channel element types.\nIf t's size is equal to or exceeds this limit, ChanOf panics.\n\nGo input arguments: (dir reflect.ChanDir, t reflect.Type)\n\nGo return type: Type\n\nJoker input arguments: [^reflect.ChanDir dir, ^reflect.Type t]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "chanOf(ABEND904(custom-runtime routine not implemented: reflect.ChanDir(_dir)), ABEND904(custom-runtime routine not implemented: reflect.Type(_t)))"}
;;   [^reflect.ChanDir _dir, ^reflect.Type _t])

JOKER FUNC reflect.Copy:
;; (defn ^"Int" Copy
;;   "Copy copies the contents of src into dst until either\ndst has been filled or src has been exhausted.\nIt returns the number of elements copied.\nDst and src each must have kind Slice or Array, and\ndst and src must have the same element type.\n\nAs a special case, src can have kind String if the element type of dst is kind Uint8.\n\nGo input arguments: (dst reflect.Value, src reflect.Value)\n\nGo return type: int\n\nJoker input arguments: [^reflect.Value dst, ^reflect.Value src]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "reflect.Copy(ABEND904(custom-runtime routine not implemented: reflect.Value(_dst)), ABEND904(custom-runtime routine not implemented: reflect.Value(_src)))"}
;;   [^reflect.Value _dst, ^reflect.Value _src])

JOKER FUNC reflect.DeepEqual:
;; (defn ^"Bool" DeepEqual
;;   "DeepEqual reports whether x and y are ``deeply equal,'' defined as follows.\nTwo values of identical type are deeply equal if one of the following cases applies.\nValues of distinct types are never deeply equal.\n\nArray values are deeply equal when their corresponding elements are deeply equal.\n\nStruct values are deeply equal if their corresponding fields,\nboth exported and unexported, are deeply equal.\n\nFunc values are deeply equal if both are nil; otherwise they are not deeply equal.\n\nInterface values are deeply equal if they hold deeply equal concrete values.\n\nMap values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they are the same map object or their corresponding keys\n(matched using Go equality) map to deeply equal values.\n\nPointer values are deeply equal if they are equal using Go's == operator\nor if they point to deeply equal values.\n\nSlice values are deeply equal when all of the following are true:\nthey are both nil or both non-nil, they have the same length,\nand either they point to the same initial entry of the same underlying array\n(that is, &x[0] == &y[0]) or their corresponding elements (up to length) are deeply equal.\nNote that a non-nil empty slice and a nil slice (for example, []byte{} and []byte(nil))\nare not deeply equal.\n\nOther values - numbers, bools, strings, and channels - are deeply equal\nif they are equal using Go's == operator.\n\nIn general DeepEqual is a recursive relaxation of Go's == operator.\nHowever, this idea is impossible to implement without some inconsistency.\nSpecifically, it is possible for a value to be unequal to itself,\neither because it is of func type (uncomparable in general)\nor because it is a floating-point NaN value (not equal to itself in floating-point comparison),\nor because it is an array, struct, or interface containing\nsuch a value.\nOn the other hand, pointer values are always equal to themselves,\neven if they point at or contain such problematic values,\nbecause they compare equal using Go's == operator, and that\nis a sufficient condition to be deeply equal, regardless of content.\nDeepEqual has been defined so that the same short-cut applies\nto slices and maps: if x and y are the same slice or the same map,\nthey are deeply equal regardless of content.\n\nAs DeepEqual traverses the data values it may find a cycle. The\nsecond and subsequent times that DeepEqual compares two pointer\nvalues that have been compared before, it treats the values as\nequal rather than examining the values to which they point.\nThis ensures that DeepEqual terminates.\n\nGo input arguments: (x interface {}, y interface {})\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> x, ^<protocol-or-something> y]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "reflect.DeepEqual(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x, ^<protocol-or-something> _y])

JOKER FUNC reflect.FuncOf:
;; (defn FuncOf
;;   "FuncOf returns the function type with the given argument and result types.\nFor example if k represents int and e represents string,\nFuncOf([]Type{k}, []Type{e}, false) represents func(int) string.\n\nThe variadic argument controls whether the function is variadic. FuncOf\npanics if the in[len(in)-1] does not represent a slice and variadic is\ntrue.\n\nGo input arguments: (in []reflect.Type, out []reflect.Type, variadic bool)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of reflect.Type) in, ^(vector-of reflect.Type) out, ^Bool variadic]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "funcOf(ConvertToArrayOfreflect.Type(ABEND904(custom-runtime routine not implemented: reflect.Type(_in))), ConvertToArrayOfreflect.Type(ABEND904(custom-runtime routine not implemented: reflect.Type(_out))), _variadic)"}
;;   [^Object _in, ^Object _out, ^Bool _variadic])

JOKER FUNC reflect.Indirect:
;; (defn Indirect
;;   "Indirect returns the value that v points to.\nIf v is a nil pointer, Indirect returns a zero Value.\nIf v is not a pointer, Indirect returns v.\n\nGo input arguments: (v reflect.Value)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Value v]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "indirect(ABEND904(custom-runtime routine not implemented: reflect.Value(_v)))"}
;;   [^reflect.Value _v])

JOKER FUNC reflect.MakeChan:
;; (defn MakeChan
;;   "MakeChan creates a new channel with the specified type and buffer size.\n\nGo input arguments: (typ reflect.Type, buffer int)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ, ^Int buffer]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeChan(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)), _buffer)"}
;;   [^reflect.Type _typ, ^Int _buffer])

JOKER FUNC reflect.MakeFunc:
;; (defn MakeFunc
;;   "MakeFunc returns a new function of the given Type\nthat wraps the function fn. When called, that new function\ndoes the following:\n\n\t- converts its arguments to a slice of Values.\n\t- runs results := fn(args).\n\t- returns the results as a slice of Values, one per formal result.\n\nThe implementation fn can assume that the argument Value slice\nhas the number and type of arguments given by typ.\nIf typ describes a variadic function, the final Value is itself\na slice representing the variadic arguments, as in the\nbody of a variadic function. The result Value slice returned by fn\nmust have the number and type of results given by typ.\n\nThe Value.Call method allows the caller to invoke a typed function\nin terms of Values; in contrast, MakeFunc allows the caller to implement\na typed function in terms of Values.\n\nThe Examples section of the documentation includes an illustration\nof how to use MakeFunc to build a swap function for different types.\n\nGo input arguments: (typ reflect.Type, fn func)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ, ^fn fn]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeFunc(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^reflect.Type _typ, ^fn _fn])

JOKER FUNC reflect.MakeMap:
;; (defn MakeMap
;;   "MakeMap creates a new map with the specified type.\n\nGo input arguments: (typ reflect.Type)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeMap(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)))"}
;;   [^reflect.Type _typ])

JOKER FUNC reflect.MakeMapWithSize:
;; (defn MakeMapWithSize
;;   "MakeMapWithSize creates a new map with the specified type\nand initial space for approximately n elements.\n\nGo input arguments: (typ reflect.Type, n int)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ, ^Int n]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeMapWithSize(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)), _n)"}
;;   [^reflect.Type _typ, ^Int _n])

JOKER FUNC reflect.MakeSlice:
;; (defn MakeSlice
;;   "MakeSlice creates a new zero-initialized slice value\nfor the specified slice type, length, and capacity.\n\nGo input arguments: (typ reflect.Type, len int, cap int)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ, ^Int len, ^Int cap]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "makeSlice(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)), _len, _cap)"}
;;   [^reflect.Type _typ, ^Int _len, ^Int _cap])

JOKER FUNC reflect.MapOf:
;; (defn MapOf
;;   "MapOf returns the map type with the given key and element types.\nFor example, if k represents int and e represents string,\nMapOf(k, e) represents map[int]string.\n\nIf the key type is not a valid map key type (that is, if it does\nnot implement Go's == operator), MapOf panics.\n\nGo input arguments: (key reflect.Type, elem reflect.Type)\n\nGo return type: Type\n\nJoker input arguments: [^reflect.Type key, ^reflect.Type elem]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "mapOf(ABEND904(custom-runtime routine not implemented: reflect.Type(_key)), ABEND904(custom-runtime routine not implemented: reflect.Type(_elem)))"}
;;   [^reflect.Type _key, ^reflect.Type _elem])

JOKER FUNC reflect.New:
;; (defn New
;;   "New returns a Value representing a pointer to a new zero value\nfor the specified type. That is, the returned Value's Type is PtrTo(typ).\n\nGo input arguments: (typ reflect.Type)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "new(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)))"}
;;   [^reflect.Type _typ])

JOKER FUNC reflect.NewAt:
;; (defn NewAt
;;   "NewAt returns a Value representing a pointer to a value of the\nspecified type, using p as that pointer.\n\nGo input arguments: (typ reflect.Type, p unsafe.Pointer)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ, ^unsafe.Pointer p]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "newAt(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_p)))"}
;;   [^reflect.Type _typ, ^unsafe.Pointer _p])

JOKER FUNC reflect.PtrTo:
;; (defn PtrTo
;;   "PtrTo returns the pointer type with element t.\nFor example, if t represents type Foo, PtrTo(t) represents *Foo.\n\nGo input arguments: (t reflect.Type)\n\nGo return type: Type\n\nJoker input arguments: [^reflect.Type t]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "ptrTo(ABEND904(custom-runtime routine not implemented: reflect.Type(_t)))"}
;;   [^reflect.Type _t])

JOKER FUNC reflect.Select:
;; (defn Select
;;   "Select executes a select operation described by the list of cases.\nLike the Go select statement, it blocks until at least one of the cases\ncan proceed, makes a uniform pseudo-random choice,\nand then executes that case. It returns the index of the chosen case\nand, if that case was a receive operation, the value received and a\nboolean indicating whether the value corresponds to a send on the channel\n(as opposed to a zero value received because the channel is closed).\n\nGo input arguments: (cases []reflect.SelectCase)\n\nGo return type: (chosen int, recv Value, recvOK bool)\n\nJoker input arguments: [^(vector-of reflect.SelectCase) cases]\n\nJoker return type: [Int {} Bool]"
;;   {:added "1.0"
;;    :go "select(ConvertToArrayOfreflect.SelectCase(ABEND904(custom-runtime routine not implemented: reflect.SelectCase(_cases))))"}
;;   [^Object _cases])

JOKER FUNC reflect.SliceOf:
;; (defn SliceOf
;;   "SliceOf returns the slice type with element type t.\nFor example, if t represents int, SliceOf(t) represents []int.\n\nGo input arguments: (t reflect.Type)\n\nGo return type: Type\n\nJoker input arguments: [^reflect.Type t]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "sliceOf(ABEND904(custom-runtime routine not implemented: reflect.Type(_t)))"}
;;   [^reflect.Type _t])

JOKER FUNC reflect.StructOf:
;; (defn StructOf
;;   "StructOf returns the struct type containing fields.\nThe Offset and Index fields are ignored and computed as they would be\nby the compiler.\n\nStructOf currently does not generate wrapper methods for embedded\nfields and panics if passed unexported StructFields.\nThese limitations may be lifted in a future version.\n\nGo input arguments: (fields []reflect.StructField)\n\nGo return type: Type\n\nJoker input arguments: [^(vector-of reflect.StructField) fields]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "structOf(ConvertToArrayOfreflect.StructField(ABEND904(custom-runtime routine not implemented: reflect.StructField(_fields))))"}
;;   [^Object _fields])

JOKER FUNC reflect.Swapper:
;; (defn Swapper
;;   "Swapper returns a function that swaps the elements in the provided\nslice.\n\nSwapper panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {})\n\nGo return type: ...\n\nJoker input arguments: [^<protocol-or-something> slice]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.FuncType at: GO.link/src/reflect/swapper.go:13:33)"
;;   {:added "1.0"
;;    :go "swapper(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _slice])

JOKER FUNC reflect.TypeOf:
;; (defn TypeOf
;;   "TypeOf returns the reflection Type that represents the dynamic type of i.\nIf i is a nil interface value, TypeOf returns nil.\n\nGo input arguments: (i interface {})\n\nGo return type: Type\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/reflect/type.go:38:11)"
;;   {:added "1.0"
;;    :go "typeOf(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.ValueOf:
;; (defn ValueOf
;;   "ValueOf returns a new Value initialized to the concrete value\nstored in the interface i. ValueOf(nil) returns the zero Value.\n\nGo input arguments: (i interface {})\n\nGo return type: Value\n\nJoker input arguments: [^<protocol-or-something> i]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "valueOf(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _i])

JOKER FUNC reflect.Zero:
;; (defn Zero
;;   "Zero returns a Value representing the zero value for the specified type.\nThe result is different from the zero value of the Value struct,\nwhich represents no value at all.\nFor example, Zero(TypeOf(42)) returns a Value with Kind Int and value 0.\nThe returned value is neither addressable nor settable.\n\nGo input arguments: (typ reflect.Type)\n\nGo return type: Value\n\nJoker input arguments: [^reflect.Type typ]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "zero(ABEND904(custom-runtime routine not implemented: reflect.Type(_typ)))"}
;;   [^reflect.Type _typ])

JOKER FUNC regexp.Compile:
(defn Compile
  "Compile parses a regular expression and returns, if successful,\na Regexp object that can be used to match against text.\n\nWhen matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses the one that a backtracking search would have found first.\nThis so-called leftmost-first matching is the same semantics\nthat Perl, Python, and other implementations use, although this\npackage implements it without the expense of backtracking.\nFor POSIX leftmost-longest matching, see CompilePOSIX.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "compile(_expr)"}
  [^String _expr])

JOKER FUNC regexp.CompilePOSIX:
(defn CompilePOSIX
  "CompilePOSIX is like Compile but restricts the regular expression\nto POSIX ERE (egrep) syntax and changes the match semantics to\nleftmost-longest.\n\nThat is, when matching against text, the regexp returns a match that\nbegins as early as possible in the input (leftmost), and among those\nit chooses a match that is as long as possible.\nThis so-called leftmost-longest matching is the same semantics\nthat early regular expression implementations used and that POSIX\nspecifies.\n\nHowever, there can be multiple leftmost-longest matches, with different\nsubmatch choices, and here this package diverges from POSIX.\nAmong the possible leftmost-longest matches, this package chooses\nthe one that a backtracking search would have found first, while POSIX\nspecifies that the match be chosen to maximize the length of the first\nsubexpression, then the second, and so on from left to right.\nThe POSIX rule is computationally prohibitive and not even well-defined.\nSee https://swtch.com/~rsc/regexp/regexp2.html#posix for details.\n\nGo input arguments: (expr string)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String expr]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "compilePOSIX(_expr)"}
  [^String _expr])

JOKER FUNC regexp.Match:
(defn Match
  "MatchString reports whether the byte slice b\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, b []byte)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^(vector-of Byte) b]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "match(_pattern, ConvertToArrayOfByte(_b))"}
  [^String _pattern, ^Object _b])

JOKER FUNC regexp.MatchReader:
;; (defn MatchReader
;;   "MatchReader reports whether the text returned by the RuneReader\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, r io.RuneReader)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^io.RuneReader r]\n\nJoker return type: [Bool Error]"
;;   {:added "1.0"
;;    :go "matchReader(_pattern, ABEND904(custom-runtime routine not implemented: io.RuneReader(_r)))"}
;;   [^String _pattern, ^io.RuneReader _r])

JOKER FUNC regexp.MatchString:
(defn MatchString
  "MatchString reports whether the string s\ncontains any match of the regular expression pattern.\nMore complicated queries need to use Compile and the full Regexp interface.\n\nGo input arguments: (pattern string, s string)\n\nGo return type: (matched bool, err error)\n\nJoker input arguments: [^String pattern, ^String s]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "matchString(_pattern, _s)"}
  [^String _pattern, ^String _s])

JOKER FUNC regexp.MustCompile:
;; (defn MustCompile
;;   "MustCompile is like Compile but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: mustCompile(_str))"}
;;   [^String _str])

JOKER FUNC regexp.MustCompilePOSIX:
;; (defn MustCompilePOSIX
;;   "MustCompilePOSIX is like CompilePOSIX but panics if the expression cannot be parsed.\nIt simplifies safe initialization of global variables holding compiled regular\nexpressions.\n\nGo input arguments: (str string)\n\nGo return type: *Regexp\n\nJoker input arguments: [^String str]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: mustCompilePOSIX(_str))"}
;;   [^String _str])

JOKER FUNC regexp.QuoteMeta:
(defn ^"String" QuoteMeta
  "QuoteMeta returns a string that escapes all regular expression metacharacters\ninside the argument text; the returned string is a regular expression matching\nthe literal text.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "regexp.QuoteMeta(_s)"}
  [^String _s])

JOKER FUNC regexp/syntax.Compile:
;; (defn Compile
;;   "Compile compiles the regexp into a program to be executed.\nThe regexp should have been simplified already (returned from re.Simplify).\n\nGo input arguments: (re *regexp/syntax.Regexp)\n\nGo return type: (*Prog, error)\n\nJoker input arguments: [^(atom-of regexp/syntax.Regexp) re]\n\nJoker return type: [{:Inst ^(vector-of {:Op ^ABEND043(unsupported built-in type uint8), :Out ^Int, :Arg ^Int, :Rune ^(vector-of ABEND043(unsupported built-in type rune))}), :Start ^Int, :NumCap ^Int} Error]"
;;   {:added "1.0"
;;    :go "compile(ConvertToIndirectOfregexp/syntax.Regexp(ABEND904(custom-runtime routine not implemented: regexp/syntax.Regexp(_re))))"}
;;   [^Object _re])

JOKER FUNC regexp/syntax.EmptyOpContext:
;; (defn EmptyOpContext
;;   "EmptyOpContext returns the zero-width assertions\nsatisfied at the position between the runes r1 and r2.\nPassing r1 == -1 indicates that the position is\nat the beginning of the text.\nPassing r2 == -1 indicates that the position is\nat the end of the text.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: EmptyOp\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: ABEND043(unsupported built-in type uint8)"
;;   {:added "1.0"
;;    :go "emptyOpContext(_r1, _r2)"}
;;   [^ABEND044(unsupported built-in type rune) _r1, ^ABEND044(unsupported built-in type rune) _r2])

JOKER FUNC regexp/syntax.IsWordChar:
;; (defn ^"Bool" IsWordChar
;;   "IsWordChar reports whether r is consider a ``word character''\nduring the evaluation of the \\b and \\B zero-width assertions.\nThese assertions are ASCII-only: the word characters are [A-Za-z0-9_].\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "syntax.IsWordChar(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC regexp/syntax.Parse:
;; (defn Parse
;;   "Parse parses a regular expression string s, controlled by the specified\nFlags, and returns a regular expression parse tree. The syntax is\ndescribed in the top-level comment.\n\nGo input arguments: (s string, flags regexp/syntax.Flags)\n\nGo return type: (*Regexp, error)\n\nJoker input arguments: [^String s, ^regexp/syntax.Flags flags]\n\nJoker return type: [{:Op ^ABEND043(unsupported built-in type uint8), :Flags ^Int, :Sub ^(vector-of ABEND947(recursive type reference involving regexp/syntax.Regexp)), :Sub0 ^(vector-of ABEND947(recursive type reference involving regexp/syntax.Regexp)), :Rune ^(vector-of ABEND043(unsupported built-in type rune)), :Rune0 ^(vector-of ABEND043(unsupported built-in type rune)), :Min ^Int, :Max ^Int, :Cap ^Int, :Name ^String} Error]"
;;   {:added "1.0"
;;    :go "parse(_s, ABEND904(custom-runtime routine not implemented: regexp/syntax.Flags(_flags)))"}
;;   [^String _s, ^regexp/syntax.Flags _flags])

JOKER FUNC runtime.BlockProfile:
;; (defn BlockProfile
;;   "BlockProfile returns n, the number of records in the current blocking profile.\nIf len(p) >= n, BlockProfile copies the profile into p and returns n, true.\nIf len(p) < n, BlockProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.blockprofile flag instead\nof calling BlockProfile directly.\n\nGo input arguments: (p []runtime.BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of runtime.BlockProfileRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "blockProfile(ConvertToArrayOfruntime.BlockProfileRecord(ABEND904(custom-runtime routine not implemented: runtime.BlockProfileRecord(_p))))"}
;;   [^Object _p])

JOKER FUNC runtime.Breakpoint:
;; (defn Breakpoint
;;   "Breakpoint executes a breakpoint trap.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "breakpoint()"}
;;   [])

JOKER FUNC runtime.CPUProfile:
(defn CPUProfile
  "CPUProfile panics.\nIt formerly provided raw access to chunks of\na pprof-format profile generated by the runtime.\nThe details of generating that format have changed,\nso this functionality has been removed.\n\nDeprecated: use the runtime/pprof package,\nor the handlers in the net/http/pprof package,\nor the testing package's -test.cpuprofile flag instead.\n\nGo return type: []int\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "cPUProfile()"}
  [])

JOKER FUNC runtime.Caller:
;; (defn Caller
;;   "Caller reports file and line number information about function invocations on\nthe calling goroutine's stack. The argument skip is the number of stack frames\nto ascend, with 0 identifying the caller of Caller.  (For historical reasons the\nmeaning of skip differs between Caller and Callers.) The return values report the\nprogram counter, file name, and line number within the file of the corresponding\ncall. The boolean ok is false if it was not possible to recover the information.\n\nGo input arguments: (skip int)\n\nGo return type: (pc ..., file string, line int, ok bool)\n\nJoker input arguments: [^Int skip]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) String Int Bool]"
;;   {:added "1.0"
;;    :go "caller(_skip)"}
;;   [^Int _skip])

JOKER FUNC runtime.Callers:
;; (defn ^"Int" Callers
;;   "Callers fills the slice pc with the return program counters of function invocations\non the calling goroutine's stack. The argument skip is the number of stack frames\nto skip before recording in pc, with 0 identifying the frame for Callers itself and\n1 identifying the caller of Callers.\nIt returns the number of entries written to pc.\n\nTo translate these PCs into symbolic information such as function\nnames and line numbers, use CallersFrames. CallersFrames accounts\nfor inlined functions and adjusts the return program counters into\ncall program counters. Iterating over the returned slice of PCs\ndirectly is discouraged, as is using FuncForPC on any of the\nreturned PCs, since these cannot account for inlining or return\nprogram counter adjustment.\n\nGo input arguments: (skip int, pc []uintptr)\n\nGo return type: int\n\nJoker input arguments: [^Int skip, ^(vector-of uintptr) pc]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "runtime.Callers(_skip, ConvertToArrayOfABEND044(unsupported built-in type uintptr)(_pc))"}
;;   [^Int _skip, ^Object _pc])

JOKER FUNC runtime.CallersFrames:
;; (defn CallersFrames
;;   "CallersFrames takes a slice of PC values returned by Callers and\nprepares to return function/file/line information.\nDo not change the slice until you are done with the Frames.\n\nGo input arguments: (callers []uintptr)\n\nGo return type: *Frames\n\nJoker input arguments: [^(vector-of uintptr) callers]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: callersFrames(ConvertToArrayOfABEND044(unsupported built-in type uintptr)(_callers)))"}
;;   [^Object _callers])

JOKER FUNC runtime.FuncForPC:
;; (defn FuncForPC
;;   "FuncForPC returns a *Func describing the function that contains the\ngiven program counter address, or else nil.\n\nIf pc represents multiple functions because of inlining, it returns\nthe *Func describing the outermost function.\n\nGo input arguments: (pc uintptr)\n\nGo return type: *Func\n\nJoker input arguments: [^uintptr pc]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: funcForPC(_pc))"}
;;   [^ABEND044(unsupported built-in type uintptr) _pc])

JOKER FUNC runtime.GC:
;; (defn GC
;;   "GC runs a garbage collection and blocks the caller until the\ngarbage collection is complete. It may also block the entire\nprogram.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "gC()"}
;;   [])

JOKER FUNC runtime.GOMAXPROCS:
(defn ^"Int" GOMAXPROCS
  "GOMAXPROCS sets the maximum number of CPUs that can be executing\nsimultaneously and returns the previous setting. If n < 1, it does not\nchange the current setting.\nThe number of logical CPUs on the local machine can be queried with NumCPU.\nThis call will go away when the scheduler improves.\n\nGo input arguments: (n int)\n\nGo return type: int\n\nJoker input arguments: [^Int n]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.GOMAXPROCS(_n)"}
  [^Int _n])

JOKER FUNC runtime.GOROOT:
(defn ^"String" GOROOT
  "GOROOT returns the root of the Go tree. It uses the\nGOROOT environment variable, if set at process start,\nor else the root used during the Go build.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.GOROOT()"}
  [])

JOKER FUNC runtime.Goexit:
;; (defn Goexit
;;   "Goexit terminates the goroutine that calls it. No other goroutine is affected.\nGoexit runs all deferred calls before terminating the goroutine. Because Goexit\nis not a panic, any recover calls in those deferred functions will return nil.\n\nCalling Goexit from the main goroutine terminates that goroutine\nwithout func main returning. Since func main has not returned,\nthe program continues execution of other goroutines.\nIf all other goroutines exit, the program crashes.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "goexit()"}
;;   [])

JOKER FUNC runtime.GoroutineProfile:
;; (defn GoroutineProfile
;;   "GoroutineProfile returns n, the number of records in the active goroutine stack profile.\nIf len(p) >= n, GoroutineProfile copies the profile into p and returns n, true.\nIf len(p) < n, GoroutineProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling GoroutineProfile directly.\n\nGo input arguments: (p []runtime.StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of runtime.StackRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "goroutineProfile(ConvertToArrayOfruntime.StackRecord(ABEND904(custom-runtime routine not implemented: runtime.StackRecord(_p))))"}
;;   [^Object _p])

JOKER FUNC runtime.Gosched:
;; (defn Gosched
;;   "Gosched yields the processor, allowing other goroutines to run. It does not\nsuspend the current goroutine, so execution resumes automatically.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "gosched()"}
;;   [])

JOKER FUNC runtime.KeepAlive:
;; (defn KeepAlive
;;   "KeepAlive marks its argument as currently reachable.\nThis ensures that the object is not freed, and its finalizer is not run,\nbefore the point in the program where KeepAlive is called.\n\nA very simplified example showing where KeepAlive is required:\n\ttype File struct { d int }\n\td, err := syscall.Open(\"/file/path\", syscall.O_RDONLY, 0)\n\t// ... do something if err != nil ...\n\tp := &File{d}\n\truntime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n\tvar buf [10]byte\n\tn, err := syscall.Read(p.d, buf[:])\n\t// Ensure p is not finalized until Read returns.\n\truntime.KeepAlive(p)\n\t// No more uses of p after this point.\n\nWithout the KeepAlive call, the finalizer could run at the start of\nsyscall.Read, closing the file descriptor before syscall.Read makes\nthe actual system call.\n\nGo input arguments: (x interface {})\n\nJoker input arguments: [^<protocol-or-something> x]"
;;   {:added "1.0"
;;    :go "keepAlive(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _x])

JOKER FUNC runtime.LockOSThread:
;; (defn LockOSThread
;;   "LockOSThread wires the calling goroutine to its current operating system thread.\nThe calling goroutine will always execute in that thread,\nand no other goroutine will execute in it,\nuntil the calling goroutine has made as many calls to\nUnlockOSThread as to LockOSThread.\nIf the calling goroutine exits without unlocking the thread,\nthe thread will be terminated.\n\nAll init functions are run on the startup thread. Calling LockOSThread\nfrom an init function will cause the main function to be invoked on\nthat thread.\n\nA goroutine should call LockOSThread before calling OS services or\nnon-Go library functions that depend on per-thread state.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "lockOSThread()"}
;;   [])

JOKER FUNC runtime.MemProfile:
;; (defn MemProfile
;;   "MemProfile returns a profile of memory allocated and freed per allocation\nsite.\n\nMemProfile returns n, the number of records in the current memory profile.\nIf len(p) >= n, MemProfile copies the profile into p and returns n, true.\nIf len(p) < n, MemProfile does not change p and returns n, false.\n\nIf inuseZero is true, the profile includes allocation records\nwhere r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\nThese are sites where memory was allocated, but it has all\nbeen released back to the runtime.\n\nThe returned profile may be up to two garbage collection cycles old.\nThis is to avoid skewing the profile toward allocations; because\nallocations happen in real time but frees are delayed until the garbage\ncollector performs sweeping, the profile only accounts for allocations\nthat have had a chance to be freed by the garbage collector.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.memprofile flag instead\nof calling MemProfile directly.\n\nGo input arguments: (p []runtime.MemProfileRecord, inuseZero bool)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of runtime.MemProfileRecord) p, ^Bool inuseZero]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "memProfile(ConvertToArrayOfruntime.MemProfileRecord(ABEND904(custom-runtime routine not implemented: runtime.MemProfileRecord(_p))), _inuseZero)"}
;;   [^Object _p, ^Bool _inuseZero])

JOKER FUNC runtime.MutexProfile:
;; (defn MutexProfile
;;   "MutexProfile returns n, the number of records in the current mutex profile.\nIf len(p) >= n, MutexProfile copies the profile into p and returns n, true.\nOtherwise, MutexProfile does not change p, and returns n, false.\n\nMost clients should use the runtime/pprof package\ninstead of calling MutexProfile directly.\n\nGo input arguments: (p []runtime.BlockProfileRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of runtime.BlockProfileRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "mutexProfile(ConvertToArrayOfruntime.BlockProfileRecord(ABEND904(custom-runtime routine not implemented: runtime.BlockProfileRecord(_p))))"}
;;   [^Object _p])

JOKER FUNC runtime.NumCPU:
(defn ^"Int" NumCPU
  "NumCPU returns the number of logical CPUs usable by the current process.\n\nThe set of available CPUs is checked by querying the operating system\nat process startup. Changes to operating system CPU allocation after\nprocess startup are not reflected.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumCPU()"}
  [])

JOKER FUNC runtime.NumCgoCall:
(defn ^"Int" NumCgoCall
  "NumCgoCall returns the number of cgo calls made by the current process.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "int(runtime.NumCgoCall())"}
  [])

JOKER FUNC runtime.NumGoroutine:
(defn ^"Int" NumGoroutine
  "NumGoroutine returns the number of goroutines that currently exist.\n\nGo return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.NumGoroutine()"}
  [])

JOKER FUNC runtime.ReadMemStats:
;; (defn ReadMemStats
;;   "ReadMemStats populates m with memory allocator statistics.\n\nThe returned memory allocator statistics are up to date as of the\ncall to ReadMemStats. This is in contrast with a heap profile,\nwhich is a snapshot as of the most recently completed garbage\ncollection cycle.\n\nGo input arguments: (m *runtime.MemStats)\n\nJoker input arguments: [^(atom-of runtime.MemStats) m]"
;;   {:added "1.0"
;;    :go "readMemStats(ConvertToIndirectOfruntime.MemStats(ABEND904(custom-runtime routine not implemented: runtime.MemStats(_m))))"}
;;   [^Object _m])

JOKER FUNC runtime.ReadTrace:
(defn ReadTrace
  "ReadTrace returns the next chunk of binary tracing data, blocking until data\nis available. If tracing is turned off and all the data accumulated while it\nwas on has been returned, ReadTrace returns nil. The caller must copy the\nreturned data before calling ReadTrace again.\nReadTrace must be called from one goroutine at a time.\n\nGo return type: []int\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "readTrace()"}
  [])

JOKER FUNC runtime.SetBlockProfileRate:
;; (defn SetBlockProfileRate
;;   "SetBlockProfileRate controls the fraction of goroutine blocking events\nthat are reported in the blocking profile. The profiler aims to sample\nan average of one blocking event per rate nanoseconds spent blocked.\n\nTo include every blocking event in the profile, pass rate = 1.\nTo turn off profiling entirely, pass rate <= 0.\n\nGo input arguments: (rate int)\n\nJoker input arguments: [^Int rate]"
;;   {:added "1.0"
;;    :go "setBlockProfileRate(_rate)"}
;;   [^Int _rate])

JOKER FUNC runtime.SetCPUProfileRate:
;; (defn SetCPUProfileRate
;;   "SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\nIf hz <= 0, SetCPUProfileRate turns off profiling.\nIf the profiler is on, the rate cannot be changed without first turning it off.\n\nMost clients should use the runtime/pprof package or\nthe testing package's -test.cpuprofile flag instead of calling\nSetCPUProfileRate directly.\n\nGo input arguments: (hz int)\n\nJoker input arguments: [^Int hz]"
;;   {:added "1.0"
;;    :go "setCPUProfileRate(_hz)"}
;;   [^Int _hz])

JOKER FUNC runtime.SetCgoTraceback:
;; (defn SetCgoTraceback
;;   "SetCgoTraceback records three C functions to use to gather\ntraceback information from C code and to convert that traceback\ninformation into symbolic information. These are used when printing\nstack traces for a program that uses cgo.\n\nThe traceback and context functions may be called from a signal\nhandler, and must therefore use only async-signal safe functions.\nThe symbolizer function may be called while the program is\ncrashing, and so must be cautious about using memory.  None of the\nfunctions may call back into Go.\n\nThe context function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t Context;\n\t};\n\nIf the Context field is 0, the context function is being called to\nrecord the current traceback context. It should record in the\nContext field whatever information is needed about the current\npoint of execution to later produce a stack trace, probably the\nstack pointer and PC. In this case the context function will be\ncalled from C code.\n\nIf the Context field is not 0, then it is a value returned by a\nprevious call to the context function. This case is called when the\ncontext is no longer needed; that is, when the Go code is returning\nto its C code caller. This permits the context function to release\nany associated resources.\n\nWhile it would be correct for the context function to record a\ncomplete a stack trace whenever it is called, and simply copy that\nout in the traceback function, in a typical program the context\nfunction will be called many times without ever recording a\ntraceback for that context. Recording a complete stack trace in a\ncall to the context function is likely to be inefficient.\n\nThe traceback function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tContext    uintptr\n\t\tSigContext uintptr\n\t\tBuf        *uintptr\n\t\tMax        uintptr\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t  Context;\n\t\tuintptr_t  SigContext;\n\t\tuintptr_t* Buf;\n\t\tuintptr_t  Max;\n\t};\n\nThe Context field will be zero to gather a traceback from the\ncurrent program execution point. In this case, the traceback\nfunction will be called from C code.\n\nOtherwise Context will be a value previously returned by a call to\nthe context function. The traceback function should gather a stack\ntrace from that saved point in the program execution. The traceback\nfunction may be called from an execution thread other than the one\nthat recorded the context, but only when the context is known to be\nvalid and unchanging. The traceback function may also be called\ndeeper in the call stack on the same thread that recorded the\ncontext. The traceback function may be called multiple times with\nthe same Context value; it will usually be appropriate to cache the\nresult, if possible, the first time this is called for a specific\ncontext value.\n\nIf the traceback function is called from a signal handler on a Unix\nsystem, SigContext will be the signal context argument passed to\nthe signal handler (a C ucontext_t* cast to uintptr_t). This may be\nused to start tracing at the point where the signal occurred. If\nthe traceback function is not called from a signal handler,\nSigContext will be zero.\n\nBuf is where the traceback information should be stored. It should\nbe PC values, such that Buf[0] is the PC of the caller, Buf[1] is\nthe PC of that function's caller, and so on.  Max is the maximum\nnumber of entries to store.  The function should store a zero to\nindicate the top of the stack, or that the caller is on a different\nstack, presumably a Go stack.\n\nUnlike runtime.Callers, the PC values returned should, when passed\nto the symbolizer function, return the file/line of the call\ninstruction.  No additional subtraction is required or appropriate.\n\nOn all platforms, the traceback function is invoked when a call from\nGo to C to Go requests a stack trace. On linux/amd64, linux/ppc64le,\nand freebsd/amd64, the traceback function is also invoked when a\nsignal is received by a thread that is executing a cgo call. The\ntraceback function should not make assumptions about when it is\ncalled, as future versions of Go may make additional calls.\n\nThe symbolizer function will be called with a single argument, a\npointer to a struct:\n\n\tstruct {\n\t\tPC      uintptr // program counter to fetch information for\n\t\tFile    *byte   // file name (NUL terminated)\n\t\tLineno  uintptr // line number\n\t\tFunc    *byte   // function name (NUL terminated)\n\t\tEntry   uintptr // function entry point\n\t\tMore    uintptr // set non-zero if more info for this PC\n\t\tData    uintptr // unused by runtime, available for function\n\t}\n\nIn C syntax, this struct will be\n\n\tstruct {\n\t\tuintptr_t PC;\n\t\tchar*     File;\n\t\tuintptr_t Lineno;\n\t\tchar*     Func;\n\t\tuintptr_t Entry;\n\t\tuintptr_t More;\n\t\tuintptr_t Data;\n\t};\n\nThe PC field will be a value returned by a call to the traceback\nfunction.\n\nThe first time the function is called for a particular traceback,\nall the fields except PC will be 0. The function should fill in the\nother fields if possible, setting them to 0/nil if the information\nis not available. The Data field may be used to store any useful\ninformation across calls. The More field should be set to non-zero\nif there is more information for this PC, zero otherwise. If More\nis set non-zero, the function will be called again with the same\nPC, and may return different information (this is intended for use\nwith inlined functions). If More is zero, the function will be\ncalled with the next PC value in the traceback. When the traceback\nis complete, the function will be called once more with PC set to\nzero; this may be used to free any information. Each call will\nleave the fields of the struct set to the same values they had upon\nreturn, except for the PC field when the More field is zero. The\nfunction must not keep a copy of the struct pointer between calls.\n\nWhen calling SetCgoTraceback, the version argument is the version\nnumber of the structs that the functions expect to receive.\nCurrently this must be zero.\n\nThe symbolizer function may be nil, in which case the results of\nthe traceback function will be displayed as numbers. If the\ntraceback function is nil, the symbolizer function will never be\ncalled. The context function may be nil, in which case the\ntraceback function will only be called with the context field set\nto zero.  If the context function is nil, then calls from Go to C\nto Go will not show a traceback for the C portion of the call stack.\n\nSetCgoTraceback should be called only once, ideally from an init function.\n\nGo input arguments: (version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer)\n\nJoker input arguments: [^Int version, ^unsafe.Pointer traceback, ^unsafe.Pointer context, ^unsafe.Pointer symbolizer]"
;;   {:added "1.0"
;;    :go "setCgoTraceback(_version, ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_traceback)), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_context)), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_symbolizer)))"}
;;   [^Int _version, ^unsafe.Pointer _traceback, ^unsafe.Pointer _context, ^unsafe.Pointer _symbolizer])

JOKER FUNC runtime.SetFinalizer:
;; (defn SetFinalizer
;;   "SetFinalizer sets the finalizer associated with obj to the provided\nfinalizer function. When the garbage collector finds an unreachable block\nwith an associated finalizer, it clears the association and runs\nfinalizer(obj) in a separate goroutine. This makes obj reachable again,\nbut now without an associated finalizer. Assuming that SetFinalizer\nis not called again, the next time the garbage collector sees\nthat obj is unreachable, it will free obj.\n\nSetFinalizer(obj, nil) clears any finalizer associated with obj.\n\nThe argument obj must be a pointer to an object allocated by calling\nnew, by taking the address of a composite literal, or by taking the\naddress of a local variable.\nThe argument finalizer must be a function that takes a single argument\nto which obj's type can be assigned, and can have arbitrary ignored return\nvalues. If either of these is not true, SetFinalizer may abort the\nprogram.\n\nFinalizers are run in dependency order: if A points at B, both have\nfinalizers, and they are otherwise unreachable, only the finalizer\nfor A runs; once A is freed, the finalizer for B can run.\nIf a cyclic structure includes a block with a finalizer, that\ncycle is not guaranteed to be garbage collected and the finalizer\nis not guaranteed to run, because there is no ordering that\nrespects the dependencies.\n\nThe finalizer is scheduled to run at some arbitrary time after the\nprogram can no longer reach the object to which obj points.\nThere is no guarantee that finalizers will run before a program exits,\nso typically they are useful only for releasing non-memory resources\nassociated with an object during a long-running program.\nFor example, an os.File object could use a finalizer to close the\nassociated operating system file descriptor when a program discards\nan os.File without calling Close, but it would be a mistake\nto depend on a finalizer to flush an in-memory I/O buffer such as a\nbufio.Writer, because the buffer would not be flushed at program exit.\n\nIt is not guaranteed that a finalizer will run if the size of *obj is\nzero bytes.\n\nIt is not guaranteed that a finalizer will run for objects allocated\nin initializers for package-level variables. Such objects may be\nlinker-allocated, not heap-allocated.\n\nA finalizer may run as soon as an object becomes unreachable.\nIn order to use finalizers correctly, the program must ensure that\nthe object is reachable until it is no longer required.\nObjects stored in global variables, or that can be found by tracing\npointers from a global variable, are reachable. For other objects,\npass the object to a call of the KeepAlive function to mark the\nlast point in the function where the object must be reachable.\n\nFor example, if p points to a struct that contains a file descriptor d,\nand p has a finalizer that closes that file descriptor, and if the last\nuse of p in a function is a call to syscall.Write(p.d, buf, size), then\np may be unreachable as soon as the program enters syscall.Write. The\nfinalizer may run at that moment, closing p.d, causing syscall.Write\nto fail because it is writing to a closed file descriptor (or, worse,\nto an entirely different file descriptor opened by a different goroutine).\nTo avoid this problem, call runtime.KeepAlive(p) after the call to\nsyscall.Write.\n\nA single goroutine runs all finalizers for a program, sequentially.\nIf a finalizer must run for a long time, it should do so by starting\na new goroutine.\n\nGo input arguments: (obj interface {}, finalizer interface {})\n\nJoker input arguments: [^<protocol-or-something> obj, ^<protocol-or-something> finalizer]"
;;   {:added "1.0"
;;    :go "setFinalizer(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _obj, ^<protocol-or-something> _finalizer])

JOKER FUNC runtime.SetMutexProfileFraction:
(defn ^"Int" SetMutexProfileFraction
  "SetMutexProfileFraction controls the fraction of mutex contention events\nthat are reported in the mutex profile. On average 1/rate events are\nreported. The previous rate is returned.\n\nTo turn off profiling entirely, pass rate 0.\nTo just read the current rate, pass rate < 0.\n(For n>1 the details of sampling may change.)\n\nGo input arguments: (rate int)\n\nGo return type: int\n\nJoker input arguments: [^Int rate]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.SetMutexProfileFraction(_rate)"}
  [^Int _rate])

JOKER FUNC runtime.Stack:
(defn ^"Int" Stack
  "Stack formats a stack trace of the calling goroutine into buf\nand returns the number of bytes written to buf.\nIf all is true, Stack formats stack traces of all other goroutines\ninto buf after the trace for the current goroutine.\n\nGo input arguments: (buf []byte, all bool)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) buf, ^Bool all]\n\nJoker return type: Int"
  {:added "1.0"
   :go "runtime.Stack(ConvertToArrayOfByte(_buf), _all)"}
  [^Object _buf, ^Bool _all])

JOKER FUNC runtime.StartTrace:
(defn ^"Error" StartTrace
  "StartTrace enables tracing for the current process.\nWhile tracing, the data will be buffered and available via ReadTrace.\nStartTrace returns an error if tracing is already enabled.\nMost clients should use the runtime/trace package or the testing package's\n-test.trace flag instead of calling StartTrace directly.\n\nGo return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "runtime.StartTrace()"}
  [])

JOKER FUNC runtime.StopTrace:
;; (defn StopTrace
;;   "StopTrace stops tracing, if it was previously enabled.\nStopTrace only returns after all the reads for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stopTrace()"}
;;   [])

JOKER FUNC runtime.ThreadCreateProfile:
;; (defn ThreadCreateProfile
;;   "ThreadCreateProfile returns n, the number of records in the thread creation profile.\nIf len(p) >= n, ThreadCreateProfile copies the profile into p and returns n, true.\nIf len(p) < n, ThreadCreateProfile does not change p and returns n, false.\n\nMost clients should use the runtime/pprof package instead\nof calling ThreadCreateProfile directly.\n\nGo input arguments: (p []runtime.StackRecord)\n\nGo return type: (n int, ok bool)\n\nJoker input arguments: [^(vector-of runtime.StackRecord) p]\n\nJoker return type: [Int Bool]"
;;   {:added "1.0"
;;    :go "threadCreateProfile(ConvertToArrayOfruntime.StackRecord(ABEND904(custom-runtime routine not implemented: runtime.StackRecord(_p))))"}
;;   [^Object _p])

JOKER FUNC runtime.UnlockOSThread:
;; (defn UnlockOSThread
;;   "UnlockOSThread undoes an earlier call to LockOSThread.\nIf this drops the number of active LockOSThread calls on the\ncalling goroutine to zero, it unwires the calling goroutine from\nits fixed operating system thread.\nIf there are no active LockOSThread calls, this is a no-op.\n\nBefore calling UnlockOSThread, the caller must ensure that the OS\nthread is suitable for running other goroutines. If the caller made\nany permanent changes to the state of the thread that would affect\nother goroutines, it should not call this function and thus leave\nthe goroutine locked to the OS thread until the goroutine (and\nhence the thread) exits.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "unlockOSThread()"}
;;   [])

JOKER FUNC runtime.Version:
(defn ^"String" Version
  "Version returns the Go tree's version string.\nIt is either the commit hash and date at the time of the build or,\nwhen possible, a release tag like \"go1.3\".\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "runtime.Version()"}
  [])

JOKER FUNC runtime/debug.FreeOSMemory:
;; (defn FreeOSMemory
;;   "FreeOSMemory forces a garbage collection followed by an\nattempt to return as much memory to the operating system\nas possible. (Even if this is not called, the runtime gradually\nreturns memory to the operating system in a background task.)\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "freeOSMemory()"}
;;   [])

JOKER FUNC runtime/debug.PrintStack:
;; (defn PrintStack
;;   "PrintStack prints to standard error the stack trace returned by runtime.Stack.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "printStack()"}
;;   [])

JOKER FUNC runtime/debug.ReadGCStats:
;; (defn ReadGCStats
;;   "ReadGCStats reads statistics about garbage collection into stats.\nThe number of entries in the pause history is system-dependent;\nstats.Pause slice will be reused if large enough, reallocated otherwise.\nReadGCStats may use the full capacity of the stats.Pause slice.\nIf stats.PauseQuantiles is non-empty, ReadGCStats fills it with quantiles\nsummarizing the distribution of pause time. For example, if\nlen(stats.PauseQuantiles) is 5, it will be filled with the minimum,\n25%, 50%, 75%, and maximum pause times.\n\nGo input arguments: (stats *runtime/debug.GCStats)\n\nJoker input arguments: [^(atom-of runtime/debug.GCStats) stats]"
;;   {:added "1.0"
;;    :go "readGCStats(ConvertToIndirectOfruntime/debug.GCStats(ABEND904(custom-runtime routine not implemented: runtime/debug.GCStats(_stats))))"}
;;   [^Object _stats])

JOKER FUNC runtime/debug.SetGCPercent:
(defn ^"Int" SetGCPercent
  "SetGCPercent sets the garbage collection target percentage:\na collection is triggered when the ratio of freshly allocated data\nto live data remaining after the previous collection reaches this percentage.\nSetGCPercent returns the previous setting.\nThe initial setting is the value of the GOGC environment variable\nat startup, or 100 if the variable is not set.\nA negative percentage disables garbage collection.\n\nGo input arguments: (percent int)\n\nGo return type: int\n\nJoker input arguments: [^Int percent]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetGCPercent(_percent)"}
  [^Int _percent])

JOKER FUNC runtime/debug.SetMaxStack:
(defn ^"Int" SetMaxStack
  "SetMaxStack sets the maximum amount of memory that\ncan be used by a single goroutine stack.\nIf any goroutine exceeds this limit while growing its stack,\nthe program crashes.\nSetMaxStack returns the previous setting.\nThe initial setting is 1 GB on 64-bit systems, 250 MB on 32-bit systems.\n\nSetMaxStack is useful mainly for limiting the damage done by\ngoroutines that enter an infinite recursion. It only limits future\nstack growth.\n\nGo input arguments: (bytes int)\n\nGo return type: int\n\nJoker input arguments: [^Int bytes]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxStack(_bytes)"}
  [^Int _bytes])

JOKER FUNC runtime/debug.SetMaxThreads:
(defn ^"Int" SetMaxThreads
  "SetMaxThreads sets the maximum number of operating system\nthreads that the Go program can use. If it attempts to use more than\nthis many, the program crashes.\nSetMaxThreads returns the previous setting.\nThe initial setting is 10,000 threads.\n\nThe limit controls the number of operating system threads, not the number\nof goroutines. A Go program creates a new thread only when a goroutine\nis ready to run but all the existing threads are blocked in system calls, cgo calls,\nor are locked to other goroutines due to use of runtime.LockOSThread.\n\nSetMaxThreads is useful mainly for limiting the damage done by\nprograms that create an unbounded number of threads. The idea is\nto take down the program before it takes down the operating system.\n\nGo input arguments: (threads int)\n\nGo return type: int\n\nJoker input arguments: [^Int threads]\n\nJoker return type: Int"
  {:added "1.0"
   :go "debug.SetMaxThreads(_threads)"}
  [^Int _threads])

JOKER FUNC runtime/debug.SetPanicOnFault:
(defn ^"Bool" SetPanicOnFault
  "SetPanicOnFault controls the runtime's behavior when a program faults\nat an unexpected (non-nil) address. Such faults are typically caused by\nbugs such as runtime memory corruption, so the default response is to crash\nthe program. Programs working with memory-mapped files or unsafe\nmanipulation of memory may cause faults at non-nil addresses in less\ndramatic situations; SetPanicOnFault allows such programs to request\nthat the runtime trigger only a panic, not a crash.\nSetPanicOnFault applies only to the current goroutine.\nIt returns the previous setting.\n\nGo input arguments: (enabled bool)\n\nGo return type: bool\n\nJoker input arguments: [^Bool enabled]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "debug.SetPanicOnFault(_enabled)"}
  [^Bool _enabled])

JOKER FUNC runtime/debug.SetTraceback:
;; (defn SetTraceback
;;   "SetTraceback sets the amount of detail printed by the runtime in\nthe traceback it prints before exiting due to an unrecovered panic\nor an internal runtime error.\nThe level argument takes the same values as the GOTRACEBACK\nenvironment variable. For example, SetTraceback(\"all\") ensure\nthat the program prints all goroutines when it crashes.\nSee the package runtime documentation for details.\nIf SetTraceback is called with a level lower than that of the\nenvironment variable, the call is ignored.\n\nGo input arguments: (level string)\n\nJoker input arguments: [^String level]"
;;   {:added "1.0"
;;    :go "setTraceback(_level)"}
;;   [^String _level])

JOKER FUNC runtime/debug.Stack:
(defn Stack
  "Stack returns a formatted stack trace of the goroutine that calls it.\nIt calls runtime.Stack with a large enough buffer to capture the entire trace.\n\nGo return type: []int\n\nJoker input arguments: []\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "stack()"}
  [])

JOKER FUNC runtime/debug.WriteHeapDump:
;; (defn WriteHeapDump
;;   "WriteHeapDump writes a description of the heap and the objects in\nit to the given file descriptor.\n\nWriteHeapDump suspends the execution of all goroutines until the heap\ndump is completely written.  Thus, the file descriptor must not be\nconnected to a pipe or socket whose other end is in the same Go\nprocess; instead, use a temporary file or network socket.\n\nThe heap dump format is defined at https://golang.org/s/go15heapdump.\n\nGo input arguments: (fd uintptr)\n\nJoker input arguments: [^uintptr fd]"
;;   {:added "1.0"
;;    :go "writeHeapDump(_fd)"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd])

JOKER FUNC runtime/pprof.Do:
;; (defn Do
;;   "Do calls f with a copy of the parent context with the\ngiven labels added to the parent's label map.\nEach key/value pair in labels is inserted into the label map in the\norder provided, overriding any previous value for the same key.\nThe augmented label map will be set for the duration of the call to f\nand restored once f returns.\n\nGo input arguments: (ctx context.Context, labels runtime/pprof.LabelSet, f func)\n\nJoker input arguments: [^context.Context ctx, ^runtime/pprof.LabelSet labels, ^fn f]"
;;   {:added "1.0"
;;    :go "do(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), ABEND904(custom-runtime routine not implemented: runtime/pprof.LabelSet(_labels)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^context.Context _ctx, ^runtime/pprof.LabelSet _labels, ^fn _f])

JOKER FUNC runtime/pprof.ForLabels:
;; (defn ForLabels
;;   "ForLabels invokes f with each label set on the context.\nThe function f should return true to continue iteration or false to stop iteration early.\n\nGo input arguments: (ctx context.Context, f func)\n\nJoker input arguments: [^context.Context ctx, ^fn f]"
;;   {:added "1.0"
;;    :go "forLabels(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^context.Context _ctx, ^fn _f])

JOKER FUNC runtime/pprof.Label:
;; (defn Label
;;   "Label returns the value of the label with the given key on ctx, and a boolean indicating\nwhether that label exists.\n\nGo input arguments: (ctx context.Context, key string)\n\nGo return type: (string, bool)\n\nJoker input arguments: [^context.Context ctx, ^String key]\n\nJoker return type: [String Bool]"
;;   {:added "1.0"
;;    :go "label(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _key)"}
;;   [^context.Context _ctx, ^String _key])

JOKER FUNC runtime/pprof.Labels:
;; (defn Labels
;;   "Labels takes an even number of strings representing key-value pairs\nand makes a LabelSet containing them.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (args ...string)\n\nGo return type: LabelSet\n\nJoker input arguments: [^(ellipsis-somehow String) args]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "labels(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_args)))"}
;;   [^String _args])

JOKER FUNC runtime/pprof.Lookup:
;; (defn Lookup
;;   "Lookup returns the profile with the given name, or nil if no such profile exists.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: lookup(_name))"}
;;   [^String _name])

JOKER FUNC runtime/pprof.NewProfile:
;; (defn NewProfile
;;   "NewProfile creates a new profile with the given name.\nIf a profile with that name already exists, NewProfile panics.\nThe convention is to use a 'import/path.' prefix to create\nseparate name spaces for each package.\nFor compatibility with various tools that read pprof data,\nprofile names should not contain spaces.\n\nGo input arguments: (name string)\n\nGo return type: *Profile\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newProfile(_name))"}
;;   [^String _name])

JOKER FUNC runtime/pprof.Profiles:
;; (defn Profiles
;;   "Profiles returns a slice of all the known profiles, sorted by name.\n\nGo return type: []*Profile\n\nJoker input arguments: []\n\nJoker return type: (vector-of {})"
;;   {:added "1.0"
;;    :go "profiles()"}
;;   [])

JOKER FUNC runtime/pprof.SetGoroutineLabels:
;; (defn SetGoroutineLabels
;;   "SetGoroutineLabels sets the current goroutine's labels to match ctx.\nThis is a lower-level API than Do, which should be used instead when possible.\n\nGo input arguments: (ctx context.Context)\n\nJoker input arguments: [^context.Context ctx]"
;;   {:added "1.0"
;;    :go "setGoroutineLabels(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)))"}
;;   [^context.Context _ctx])

JOKER FUNC runtime/pprof.StartCPUProfile:
;; (defn ^"Error" StartCPUProfile
;;   "StartCPUProfile enables CPU profiling for the current process.\nWhile profiling, the profile will be buffered and written to w.\nStartCPUProfile returns an error if profiling is already enabled.\n\nOn Unix-like systems, StartCPUProfile does not work by default for\nGo code built with -buildmode=c-archive or -buildmode=c-shared.\nStartCPUProfile relies on the SIGPROF signal, but that signal will\nbe delivered to the main program's SIGPROF signal handler (if any)\nnot to the one used by Go. To make it work, call os/signal.Notify\nfor syscall.SIGPROF, but note that doing so may break any profiling\nbeing done by the main program.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.StartCPUProfile(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC runtime/pprof.StopCPUProfile:
;; (defn StopCPUProfile
;;   "StopCPUProfile stops the current CPU profile, if any.\nStopCPUProfile only returns after all the writes for the\nprofile have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stopCPUProfile()"}
;;   [])

JOKER FUNC runtime/pprof.WithLabels:
;; (defn WithLabels
;;   "WithLabels returns a new context.Context with the given labels added.\nA label overwrites a prior label with the same key.\n\nGo input arguments: (ctx context.Context, labels runtime/pprof.LabelSet)\n\nGo return type: ...\n\nJoker input arguments: [^context.Context ctx, ^runtime/pprof.LabelSet labels]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14)"
;;   {:added "1.0"
;;    :go "withLabels(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), ABEND904(custom-runtime routine not implemented: runtime/pprof.LabelSet(_labels)))"}
;;   [^context.Context _ctx, ^runtime/pprof.LabelSet _labels])

JOKER FUNC runtime/pprof.WriteHeapProfile:
;; (defn ^"Error" WriteHeapProfile
;;   "WriteHeapProfile is shorthand for Lookup(\"heap\").WriteTo(w, 0).\nIt is preserved for backwards compatibility.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "pprof.WriteHeapProfile(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC runtime/trace.IsEnabled:
(defn ^"Bool" IsEnabled
  "IsEnabled returns whether tracing is enabled.\nThe information is advisory only. The tracing status\nmay have changed by the time this function returns.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "trace.IsEnabled()"}
  [])

JOKER FUNC runtime/trace.Log:
;; (defn Log
;;   "Log emits a one-off event with the given category and message.\nCategory can be empty and the API assumes there are only a handful of\nunique categories in the system.\n\nGo input arguments: (ctx context.Context, category string, message string)\n\nJoker input arguments: [^context.Context ctx, ^String category, ^String message]"
;;   {:added "1.0"
;;    :go "log(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _category, _message)"}
;;   [^context.Context _ctx, ^String _category, ^String _message])

JOKER FUNC runtime/trace.Logf:
;; (defn Logf
;;   "Logf is like Log, but the value is formatted using the specified format spec.\n\nGo input arguments: (ctx context.Context, category string, format string, args ...interface {})\n\nJoker input arguments: [^context.Context ctx, ^String category, ^String format, ^(ellipsis-somehow <protocol-or-something>) args]"
;;   {:added "1.0"
;;    :go "logf(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _category, _format, ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^context.Context _ctx, ^String _category, ^String _format, ^<protocol-or-something> _args])

JOKER FUNC runtime/trace.NewTask:
;; (defn NewTask
;;   "NewTask creates a task instance with the type taskType and returns\nit along with a Context that carries the task.\nIf the input context contains a task, the new task is its subtask.\n\nThe taskType is used to classify task instances. Analysis tools\nlike the Go execution tracer may assume there are only a bounded\nnumber of unique task types in the system.\n\nThe returned end function is used to mark the task's end.\nThe trace tool measures task latency as the time between task creation\nand when the end function is called, and provides the latency\ndistribution per task type.\nIf the end function is called multiple times, only the first\ncall is used in the latency measurement.\n\n  ctx, task := trace.NewTask(ctx, \"awesomeTask\")\n  trace.WithRegion(ctx, \"preparation\", prepWork)\n  // preparation of the task\n  go func() {  // continue processing the task in a separate goroutine.\n      defer task.End()\n      trace.WithRegion(ctx, \"remainingWork\", remainingWork)\n  }()\n\nGo input arguments: (pctx context.Context, taskType string)\n\nGo return type: (ctx ..., task *Task)\n\nJoker input arguments: [^context.Context pctx, ^String taskType]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/context/context.go:62:14) {}]"
;;   {:added "1.0"
;;    :go "newTask(ABEND904(custom-runtime routine not implemented: context.Context(_pctx)), _taskType)"}
;;   [^context.Context _pctx, ^String _taskType])

JOKER FUNC runtime/trace.Start:
;; (defn ^"Error" Start
;;   "Start enables tracing for the current program.\nWhile tracing, the trace will be buffered and written to w.\nStart returns an error if tracing is already enabled.\n\nGo input arguments: (w io.Writer)\n\nGo return type: error\n\nJoker input arguments: [^io.Writer w]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "trace.Start(ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^io.Writer _w])

JOKER FUNC runtime/trace.StartRegion:
;; (defn StartRegion
;;   "StartRegion starts a region and returns a function for marking the\nend of the region. The returned Region's End function must be called\nfrom the same goroutine where the region was started.\nWithin each goroutine, regions must nest. That is, regions started\nafter this region must be ended before this region can be ended.\nRecommended usage is\n\n    defer trace.StartRegion(ctx, \"myTracedRegion\").End()\n\nGo input arguments: (ctx context.Context, regionType string)\n\nGo return type: *Region\n\nJoker input arguments: [^context.Context ctx, ^String regionType]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: startRegion(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _regionType))"}
;;   [^context.Context _ctx, ^String _regionType])

JOKER FUNC runtime/trace.Stop:
;; (defn Stop
;;   "Stop stops the current tracing, if any.\nStop only returns after all the writes for the trace have completed.\n\nJoker input arguments: []"
;;   {:added "1.0"
;;    :go "stop()"}
;;   [])

JOKER FUNC runtime/trace.WithRegion:
;; (defn WithRegion
;;   "WithRegion starts a region associated with its calling goroutine, runs fn,\nand then ends the region. If the context carries a task, the region is\nassociated with the task. Otherwise, the region is attached to the background\ntask.\n\nThe regionType is used to classify regions, so there should be only a\nhandful of unique region types.\n\nGo input arguments: (ctx context.Context, regionType string, fn func)\n\nJoker input arguments: [^context.Context ctx, ^String regionType, ^fn fn]"
;;   {:added "1.0"
;;    :go "withRegion(ABEND904(custom-runtime routine not implemented: context.Context(_ctx)), _regionType, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^context.Context _ctx, ^String _regionType, ^fn _fn])

JOKER FUNC sort.Float64s:
;; (defn Float64s
;;   "Float64s sorts a slice of float64s in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nJoker input arguments: [^(vector-of float64) a]"
;;   {:added "1.0"
;;    :go "float64s(ConvertToArrayOfABEND044(unsupported built-in type float64)(_a))"}
;;   [^Object _a])

JOKER FUNC sort.Float64sAreSorted:
;; (defn ^"Bool" Float64sAreSorted
;;   "Float64sAreSorted tests whether a slice of float64s is sorted in increasing order\n(not-a-number values are treated as less than other values).\n\nGo input arguments: (a []float64)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of float64) a]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.Float64sAreSorted(ConvertToArrayOfABEND044(unsupported built-in type float64)(_a))"}
;;   [^Object _a])

JOKER FUNC sort.Ints:
;; (defn Ints
;;   "Ints sorts a slice of ints in increasing order.\n\nGo input arguments: (a []int)\n\nJoker input arguments: [^(vector-of Int) a]"
;;   {:added "1.0"
;;    :go "ints(ConvertToArrayOfInt(_a))"}
;;   [^Object _a])

JOKER FUNC sort.IntsAreSorted:
(defn ^"Bool" IntsAreSorted
  "IntsAreSorted tests whether a slice of ints is sorted in increasing order.\n\nGo input arguments: (a []int)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Int) a]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "sort.IntsAreSorted(ConvertToArrayOfInt(_a))"}
  [^Object _a])

JOKER FUNC sort.IsSorted:
;; (defn ^"Bool" IsSorted
;;   "IsSorted reports whether data is sorted.\n\nGo input arguments: (data sort.Interface)\n\nGo return type: bool\n\nJoker input arguments: [^sort.Interface data]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.IsSorted(ABEND904(custom-runtime routine not implemented: sort.Interface(_data)))"}
;;   [^sort.Interface _data])

JOKER FUNC sort.Reverse:
;; (defn Reverse
;;   "Reverse returns the reverse order for data.\n\nGo input arguments: (data sort.Interface)\n\nGo return type: Interface\n\nJoker input arguments: [^sort.Interface data]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sort/sort.go:14:16)"
;;   {:added "1.0"
;;    :go "reverse(ABEND904(custom-runtime routine not implemented: sort.Interface(_data)))"}
;;   [^sort.Interface _data])

JOKER FUNC sort.Search:
;; (defn ^"Int" Search
;;   "Search uses binary search to find and return the smallest index i\nin [0, n) at which f(i) is true, assuming that on the range [0, n),\nf(i) == true implies f(i+1) == true. That is, Search requires that\nf is false for some (possibly empty) prefix of the input range [0, n)\nand then true for the (possibly empty) remainder; Search returns\nthe first true index. If there is no such index, Search returns n.\n(Note that the \"not found\" return value is not -1 as in, for instance,\nstrings.Index.)\nSearch calls f(i) only for i in the range [0, n).\n\nA common use of Search is to find the index i for a value x in\na sorted, indexable data structure such as an array or slice.\nIn this case, the argument f, typically a closure, captures the value\nto be searched for, and how the data structure is indexed and\nordered.\n\nFor instance, given a slice data sorted in ascending order,\nthe call Search(len(data), func(i int) bool { return data[i] >= 23 })\nreturns the smallest index i such that data[i] >= 23. If the caller\nwants to find whether 23 is in the slice, it must test data[i] == 23\nseparately.\n\nSearching data sorted in descending order would use the <=\noperator instead of the >= operator.\n\nTo complete the example above, the following code tries to find the value\nx in an integer slice data sorted in ascending order:\n\n\tx := 23\n\ti := sort.Search(len(data), func(i int) bool { return data[i] >= x })\n\tif i < len(data) && data[i] == x {\n\t\t// x is present at data[i]\n\t} else {\n\t\t// x is not present in data,\n\t\t// but i is the index where it would be inserted.\n\t}\n\nAs a more whimsical example, this program guesses your number:\n\n\tfunc GuessingGame() {\n\t\tvar s string\n\t\tfmt.Printf(\"Pick an integer from 0 to 100.\\n\")\n\t\tanswer := sort.Search(100, func(i int) bool {\n\t\t\tfmt.Printf(\"Is your number <= %d? \", i)\n\t\t\tfmt.Scanf(\"%s\", &s)\n\t\t\treturn s != \"\" && s[0] == 'y'\n\t\t})\n\t\tfmt.Printf(\"Your number is %d.\\n\", answer)\n\t}\n\nGo input arguments: (n int, f func)\n\nGo return type: int\n\nJoker input arguments: [^Int n, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.Search(_n, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Int _n, ^fn _f])

JOKER FUNC sort.SearchFloat64s:
;; (defn ^"Int" SearchFloat64s
;;   "SearchFloat64s searches for x in a sorted slice of float64s and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []float64, x float64)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of float64) a, ^float64 x]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "sort.SearchFloat64s(ConvertToArrayOfABEND044(unsupported built-in type float64)(_a), _x)"}
;;   [^Object _a, ^ABEND044(unsupported built-in type float64) _x])

JOKER FUNC sort.SearchInts:
(defn ^"Int" SearchInts
  "SearchInts searches for x in a sorted slice of ints and returns the index\nas specified by Search. The return value is the index to insert x if x is\nnot present (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []int, x int)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Int) a, ^Int x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "sort.SearchInts(ConvertToArrayOfInt(_a), _x)"}
  [^Object _a, ^Int _x])

JOKER FUNC sort.SearchStrings:
(defn ^"Int" SearchStrings
  "SearchStrings searches for x in a sorted slice of strings and returns the index\nas specified by Search. The return value is the index to insert x if x is not\npresent (it could be len(a)).\nThe slice must be sorted in ascending order.\n\nGo input arguments: (a []string, x string)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of String) a, ^String x]\n\nJoker return type: Int"
  {:added "1.0"
   :go "sort.SearchStrings(ConvertToArrayOfString(_a), _x)"}
  [^Object _a, ^String _x])

JOKER FUNC sort.Slice:
;; (defn Slice
;;   "Slice sorts the provided slice given the provided less function.\n\nThe sort is not guaranteed to be stable. For a stable sort, use\nSliceStable.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "slice(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceIsSorted:
;; (defn ^"Bool" SliceIsSorted
;;   "SliceIsSorted tests whether a slice is sorted.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nGo return type: bool\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "sort.SliceIsSorted(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.SliceStable:
;; (defn SliceStable
;;   "SliceStable sorts the provided slice given the provided less\nfunction while keeping the original order of equal elements.\n\nThe function panics if the provided interface is not a slice.\n\nGo input arguments: (slice interface {}, less func)\n\nJoker input arguments: [^<protocol-or-something> slice, ^fn less]"
;;   {:added "1.0"
;;    :go "sliceStable(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^<protocol-or-something> _slice, ^fn _less])

JOKER FUNC sort.Sort:
;; (defn Sort
;;   "Sort sorts data.\nIt makes one call to data.Len to determine n, and O(n*log(n)) calls to\ndata.Less and data.Swap. The sort is not guaranteed to be stable.\n\nGo input arguments: (data sort.Interface)\n\nJoker input arguments: [^sort.Interface data]"
;;   {:added "1.0"
;;    :go "sort(ABEND904(custom-runtime routine not implemented: sort.Interface(_data)))"}
;;   [^sort.Interface _data])

JOKER FUNC sort.Stable:
;; (defn Stable
;;   "Stable sorts data while keeping the original order of equal elements.\n\nIt makes one call to data.Len to determine n, O(n*log(n)) calls to\ndata.Less and O(n*log(n)*log(n)) calls to data.Swap.\n\nGo input arguments: (data sort.Interface)\n\nJoker input arguments: [^sort.Interface data]"
;;   {:added "1.0"
;;    :go "stable(ABEND904(custom-runtime routine not implemented: sort.Interface(_data)))"}
;;   [^sort.Interface _data])

JOKER FUNC sort.Strings:
;; (defn Strings
;;   "Strings sorts a slice of strings in increasing order.\n\nGo input arguments: (a []string)\n\nJoker input arguments: [^(vector-of String) a]"
;;   {:added "1.0"
;;    :go "strings(ConvertToArrayOfString(_a))"}
;;   [^Object _a])

JOKER FUNC sort.StringsAreSorted:
(defn ^"Bool" StringsAreSorted
  "StringsAreSorted tests whether a slice of strings is sorted in increasing order.\n\nGo input arguments: (a []string)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of String) a]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "sort.StringsAreSorted(ConvertToArrayOfString(_a))"}
  [^Object _a])

JOKER FUNC strconv.AppendBool:
(defn AppendBool
  "AppendBool appends \"true\" or \"false\", according to the value of b,\nto dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, b bool)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^Bool b]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "appendBool(ConvertToArrayOfByte(_dst), _b)"}
  [^Object _dst, ^Bool _b])

JOKER FUNC strconv.AppendFloat:
;; (defn AppendFloat
;;   "AppendFloat appends the string form of the floating-point number f,\nas generated by FormatFloat, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, f float64, fmt byte, prec int, bitSize int)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendFloat(ConvertToArrayOfByte(_dst), _f, _fmt, _prec, _bitSize)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.AppendInt:
(defn AppendInt
  "AppendInt appends the string form of the integer i,\nas generated by FormatInt, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i int64, base int)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^Int64 i, ^Int base]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "appendInt(ConvertToArrayOfByte(_dst), _i, _base)"}
  [^Object _dst, ^Int64 _i, ^Int _base])

JOKER FUNC strconv.AppendQuote:
(defn AppendQuote
  "AppendQuote appends a double-quoted Go string literal representing s,\nas generated by Quote, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "appendQuote(ConvertToArrayOfByte(_dst), _s)"}
  [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteRune:
;; (defn AppendQuoteRune
;;   "AppendQuoteRune appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRune, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRune(ConvertToArrayOfByte(_dst), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToASCII:
;; (defn AppendQuoteRuneToASCII
;;   "AppendQuoteRuneToASCII appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToASCII(ConvertToArrayOfByte(_dst), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteRuneToGraphic:
;; (defn AppendQuoteRuneToGraphic
;;   "AppendQuoteRuneToGraphic appends a single-quoted Go character literal representing the rune,\nas generated by QuoteRuneToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, r rune)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^rune r]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendQuoteRuneToGraphic(ConvertToArrayOfByte(_dst), _r)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.AppendQuoteToASCII:
(defn AppendQuoteToASCII
  "AppendQuoteToASCII appends a double-quoted Go string literal representing s,\nas generated by QuoteToASCII, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "appendQuoteToASCII(ConvertToArrayOfByte(_dst), _s)"}
  [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendQuoteToGraphic:
(defn AppendQuoteToGraphic
  "AppendQuoteToGraphic appends a double-quoted Go string literal representing s,\nas generated by QuoteToGraphic, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, s string)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "appendQuoteToGraphic(ConvertToArrayOfByte(_dst), _s)"}
  [^Object _dst, ^String _s])

JOKER FUNC strconv.AppendUint:
;; (defn AppendUint
;;   "AppendUint appends the string form of the unsigned integer i,\nas generated by FormatUint, to dst and returns the extended buffer.\n\nGo input arguments: (dst []byte, i uint64, base int)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of Byte) dst, ^uint64 i, ^Int base]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "appendUint(ConvertToArrayOfByte(_dst), _i, _base)"}
;;   [^Object _dst, ^ABEND044(unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.Atoi:
(defn Atoi
  "Atoi returns the result of ParseInt(s, 10, 0) converted to type int.\n\nGo input arguments: (s string)\n\nGo return type: (int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "atoi(_s)"}
  [^String _s])

JOKER FUNC strconv.CanBackquote:
(defn ^"Bool" CanBackquote
  "CanBackquote reports whether the string s can be represented\nunchanged as a single-line backquoted string without control\ncharacters other than tab.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strconv.CanBackquote(_s)"}
  [^String _s])

JOKER FUNC strconv.FormatBool:
(defn ^"String" FormatBool
  "FormatBool returns \"true\" or \"false\" according to the value of b.\n\nGo input arguments: (b bool)\n\nGo return type: string\n\nJoker input arguments: [^Bool b]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatBool(_b)"}
  [^Bool _b])

JOKER FUNC strconv.FormatFloat:
;; (defn ^"String" FormatFloat
;;   "FormatFloat converts the floating-point number f to a string,\naccording to the format fmt and precision prec. It rounds the\nresult assuming that the original was obtained from a floating-point\nvalue of bitSize bits (32 for float32, 64 for float64).\n\nThe format fmt is one of\n'b' (-ddddpddd, a binary exponent),\n'e' (-d.ddddedd, a decimal exponent),\n'E' (-d.ddddEdd, a decimal exponent),\n'f' (-ddd.dddd, no exponent),\n'g' ('e' for large exponents, 'f' otherwise), or\n'G' ('E' for large exponents, 'f' otherwise).\n\nThe precision prec controls the number of digits (excluding the exponent)\nprinted by the 'e', 'E', 'f', 'g', and 'G' formats.\nFor 'e', 'E', and 'f' it is the number of digits after the decimal point.\nFor 'g' and 'G' it is the maximum number of significant digits (trailing\nzeros are removed).\nThe special precision -1 uses the smallest number of digits\nnecessary such that ParseFloat will return f exactly.\n\nGo input arguments: (f float64, fmt byte, prec int, bitSize int)\n\nGo return type: string\n\nJoker input arguments: [^float64 f, ^Byte fmt, ^Int prec, ^Int bitSize]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatFloat(_f, _fmt, _prec, _bitSize)"}
;;   [^ABEND044(unsupported built-in type float64) _f, ^Byte _fmt, ^Int _prec, ^Int _bitSize])

JOKER FUNC strconv.FormatInt:
(defn ^"String" FormatInt
  "FormatInt returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i int64, base int)\n\nGo return type: string\n\nJoker input arguments: [^Int64 i, ^Int base]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.FormatInt(_i, _base)"}
  [^Int64 _i, ^Int _base])

JOKER FUNC strconv.FormatUint:
;; (defn ^"String" FormatUint
;;   "FormatUint returns the string representation of i in the given base,\nfor 2 <= base <= 36. The result uses the lower-case letters 'a' to 'z'\nfor digit values >= 10.\n\nGo input arguments: (i uint64, base int)\n\nGo return type: string\n\nJoker input arguments: [^uint64 i, ^Int base]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.FormatUint(_i, _base)"}
;;   [^ABEND044(unsupported built-in type uint64) _i, ^Int _base])

JOKER FUNC strconv.IsGraphic:
;; (defn ^"Bool" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, and Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.IsPrint:
;; (defn ^"Bool" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go, with\nthe same definition as unicode.IsPrint: letters, numbers, punctuation,\nsymbols and ASCII space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strconv.IsPrint(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.Itoa:
(defn ^"String" Itoa
  "Itoa is shorthand for FormatInt(int64(i), 10).\n\nGo input arguments: (i int)\n\nGo return type: string\n\nJoker input arguments: [^Int i]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Itoa(_i)"}
  [^Int _i])

JOKER FUNC strconv.ParseBool:
(defn ParseBool
  "ParseBool returns the boolean value represented by the string.\nIt accepts 1, t, T, TRUE, true, True, 0, f, F, FALSE, false, False.\nAny other value returns an error.\n\nGo input arguments: (str string)\n\nGo return type: (bool, error)\n\nJoker input arguments: [^String str]\n\nJoker return type: [Bool Error]"
  {:added "1.0"
   :go "parseBool(_str)"}
  [^String _str])

JOKER FUNC strconv.ParseFloat:
;; (defn ParseFloat
;;   "ParseFloat converts the string s to a floating-point number\nwith the precision specified by bitSize: 32 for float32, or 64 for float64.\nWhen bitSize=32, the result still has type float64, but it will be\nconvertible to float32 without changing its value.\n\nIf s is well-formed and near a valid floating point number,\nParseFloat returns the nearest floating point number rounded\nusing IEEE754 unbiased rounding.\n\nThe errors that ParseFloat returns have concrete type *NumError\nand include err.Num = s.\n\nIf s is not syntactically well-formed, ParseFloat returns err.Err = ErrSyntax.\n\nIf s is syntactically well-formed but is more than 1/2 ULP\naway from the largest floating point number of the given size,\nParseFloat returns f = Inf, err.Err = ErrRange.\n\nGo input arguments: (s string, bitSize int)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String s, ^Int bitSize]\n\nJoker return type: [ABEND043(unsupported built-in type float64) Error]"
;;   {:added "1.0"
;;    :go "parseFloat(_s, _bitSize)"}
;;   [^String _s, ^Int _bitSize])

JOKER FUNC strconv.ParseInt:
(defn ParseInt
  "ParseInt interprets a string s in the given base (0, 2 to 36) and\nbit size (0 to 64) and returns the corresponding value i.\n\nIf base == 0, the base is implied by the string's prefix:\nbase 16 for \"0x\", base 8 for \"0\", and base 10 otherwise.\nFor bases 1, below 0 or above 36 an error is returned.\n\nThe bitSize argument specifies the integer type\nthat the result must fit into. Bit sizes 0, 8, 16, 32, and 64\ncorrespond to int, int8, int16, int32, and int64.\nFor a bitSize below 0 or above 64 an error is returned.\n\nThe errors that ParseInt returns have concrete type *NumError\nand include err.Num = s. If s is empty or contains invalid\ndigits, err.Err = ErrSyntax and the returned value is 0;\nif the value corresponding to s cannot be represented by a\nsigned integer of the given size, err.Err = ErrRange and the\nreturned value is the maximum magnitude integer of the\nappropriate bitSize and sign.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (i int, err error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "parseInt(_s, _base, _bitSize)"}
  [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.ParseUint:
;; (defn ParseUint
;;   "ParseUint is like ParseInt but for unsigned numbers.\n\nGo input arguments: (s string, base int, bitSize int)\n\nGo return type: (..., error)\n\nJoker input arguments: [^String s, ^Int base, ^Int bitSize]\n\nJoker return type: [ABEND043(unsupported built-in type uint64) Error]"
;;   {:added "1.0"
;;    :go "parseUint(_s, _base, _bitSize)"}
;;   [^String _s, ^Int _base, ^Int _bitSize])

JOKER FUNC strconv.Quote:
(defn ^"String" Quote
  "Quote returns a double-quoted Go string literal representing s. The\nreturned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\ncontrol characters and non-printable characters as defined by\nIsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.Quote(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteRune:
;; (defn ^"String" QuoteRune
;;   "QuoteRune returns a single-quoted Go character literal representing the\nrune. The returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100)\nfor control characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToASCII:
;; (defn ^"String" QuoteRuneToASCII
;;   "QuoteRuneToASCII returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsPrint.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToASCII(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteRuneToGraphic:
;; (defn ^"String" QuoteRuneToGraphic
;;   "QuoteRuneToGraphic returns a single-quoted Go character literal representing\nthe rune. The returned string uses Go escape sequences (\\t, \\n, \\xFF,\n\\u0100) for non-ASCII characters and non-printable characters as defined\nby IsGraphic.\n\nGo input arguments: (r rune)\n\nGo return type: string\n\nJoker input arguments: [^rune r]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strconv.QuoteRuneToGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strconv.QuoteToASCII:
(defn ^"String" QuoteToASCII
  "QuoteToASCII returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsPrint.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToASCII(_s)"}
  [^String _s])

JOKER FUNC strconv.QuoteToGraphic:
(defn ^"String" QuoteToGraphic
  "QuoteToGraphic returns a double-quoted Go string literal representing s.\nThe returned string uses Go escape sequences (\\t, \\n, \\xFF, \\u0100) for\nnon-ASCII characters and non-printable characters as defined by IsGraphic.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strconv.QuoteToGraphic(_s)"}
  [^String _s])

JOKER FUNC strconv.Unquote:
(defn Unquote
  "Unquote interprets s as a single-quoted, double-quoted,\nor backquoted Go string literal, returning the string value\nthat s quotes.  (If s is single-quoted, it would be a Go\ncharacter literal; Unquote returns the corresponding\none-character string.)\n\nGo input arguments: (s string)\n\nGo return type: (string, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "unquote(_s)"}
  [^String _s])

JOKER FUNC strconv.UnquoteChar:
;; (defn UnquoteChar
;;   "UnquoteChar decodes the first character or byte in the escaped string\nor character literal represented by the string s.\nIt returns four values:\n\n\t1) value, the decoded Unicode code point or byte value;\n\t2) multibyte, a boolean indicating whether the decoded character requires a multibyte UTF-8 representation;\n\t3) tail, the remainder of the string after the character; and\n\t4) an error that will be nil if the character is syntactically valid.\n\nThe second argument, quote, specifies the type of literal being parsed\nand therefore which escaped quote character is permitted.\nIf set to a single quote, it permits the sequence \\' and disallows unescaped '.\nIf set to a double quote, it permits \\\" and disallows unescaped \".\nIf set to zero, it does not permit either escape and allows both quote characters to appear unescaped.\n\nGo input arguments: (s string, quote byte)\n\nGo return type: (value ..., multibyte bool, tail string, err error)\n\nJoker input arguments: [^String s, ^Byte quote]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Bool String Error]"
;;   {:added "1.0"
;;    :go "unquoteChar(_s, _quote)"}
;;   [^String _s, ^Byte _quote])

JOKER FUNC strings.Compare:
(defn ^"Int" Compare
  "Compare returns an integer comparing two strings lexicographically.\nThe result will be 0 if a==b, -1 if a < b, and +1 if a > b.\n\nCompare is included only for symmetry with package bytes.\nIt is usually clearer and always faster to use the built-in\nstring comparison operators ==, <, >, and so on.\n\nGo input arguments: (a string, b string)\n\nGo return type: int\n\nJoker input arguments: [^String a, ^String b]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Compare(_a, _b)"}
  [^String _a, ^String _b])

JOKER FUNC strings.Contains:
(defn ^"Bool" Contains
  "Contains reports whether substr is within s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.Contains(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.ContainsAny:
(defn ^"Bool" ContainsAny
  "ContainsAny reports whether any Unicode code points in chars are within s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.ContainsAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.ContainsRune:
;; (defn ^"Bool" ContainsRune
;;   "ContainsRune reports whether the Unicode code point r is within s.\n\nGo input arguments: (s string, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "strings.ContainsRune(_s, _r)"}
;;   [^String _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strings.Count:
(defn ^"Int" Count
  "Count counts the number of non-overlapping instances of substr in s.\nIf substr is an empty string, Count returns 1 + the number of Unicode code points in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Count(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.EqualFold:
(defn ^"Bool" EqualFold
  "EqualFold reports whether s and t, interpreted as UTF-8 strings,\nare equal under Unicode case-folding.\n\nGo input arguments: (s string, t string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String t]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.EqualFold(_s, _t)"}
  [^String _s, ^String _t])

JOKER FUNC strings.Fields:
(defn Fields
  "Fields splits the string s around each instance of one or more consecutive white space\ncharacters, as defined by unicode.IsSpace, returning a slice of substrings of s or an\nempty slice if s contains only white space.\n\nGo input arguments: (s string)\n\nGo return type: []string\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "fields(_s)"}
  [^String _s])

JOKER FUNC strings.FieldsFunc:
;; (defn FieldsFunc
;;   "FieldsFunc splits the string s at each run of Unicode code points c satisfying f(c)\nand returns an array of slices of s. If all code points in s satisfy f(c) or the\nstring is empty, an empty slice is returned.\nFieldsFunc makes no guarantees about the order in which it calls f(c).\nIf f does not return consistent results for a given c, FieldsFunc may crash.\n\nGo input arguments: (s string, f func)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: (vector-of String)"
;;   {:added "1.0"
;;    :go "fieldsFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.HasPrefix:
(defn ^"Bool" HasPrefix
  "HasPrefix tests whether the string s begins with prefix.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.HasSuffix:
(defn ^"Bool" HasSuffix
  "HasSuffix tests whether the string s ends with suffix.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: bool\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "strings.HasSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

JOKER FUNC strings.Index:
(defn ^"Int" Index
  "Index returns the index of the first instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.Index(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.IndexAny:
(defn ^"Int" IndexAny
  "IndexAny returns the index of the first instance of any Unicode code point\nfrom chars in s, or -1 if no Unicode code point from chars is present in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.IndexByte:
(defn ^"Int" IndexByte
  "IndexByte returns the index of the first instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.IndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.IndexFunc:
;; (defn ^"Int" IndexFunc
;;   "IndexFunc returns the index into s of the first Unicode\ncode point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.IndexRune:
;; (defn ^"Int" IndexRune
;;   "IndexRune returns the index of the first instance of the Unicode code point\nr, or -1 if rune is not present in s.\nIf r is utf8.RuneError, it returns the first instance of any\ninvalid UTF-8 byte sequence.\n\nGo input arguments: (s string, r rune)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.IndexRune(_s, _r)"}
;;   [^String _s, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC strings.Join:
(defn ^"String" Join
  "Join concatenates the elements of a to create a single string. The separator string\nsep is placed between elements in the resulting string.\n\nGo input arguments: (a []string, sep string)\n\nGo return type: string\n\nJoker input arguments: [^(vector-of String) a, ^String sep]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Join(ConvertToArrayOfString(_a), _sep)"}
  [^Object _a, ^String _sep])

JOKER FUNC strings.LastIndex:
(defn ^"Int" LastIndex
  "LastIndex returns the index of the last instance of substr in s, or -1 if substr is not present in s.\n\nGo input arguments: (s string, substr string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String substr]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndex(_s, _substr)"}
  [^String _s, ^String _substr])

JOKER FUNC strings.LastIndexAny:
(defn ^"Int" LastIndexAny
  "LastIndexAny returns the index of the last instance of any Unicode code\npoint from chars in s, or -1 if no Unicode code point from chars is\npresent in s.\n\nGo input arguments: (s string, chars string)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^String chars]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexAny(_s, _chars)"}
  [^String _s, ^String _chars])

JOKER FUNC strings.LastIndexByte:
(defn ^"Int" LastIndexByte
  "LastIndexByte returns the index of the last instance of c in s, or -1 if c is not present in s.\n\nGo input arguments: (s string, c byte)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^Byte c]\n\nJoker return type: Int"
  {:added "1.0"
   :go "strings.LastIndexByte(_s, _c)"}
  [^String _s, ^Byte _c])

JOKER FUNC strings.LastIndexFunc:
;; (defn ^"Int" LastIndexFunc
;;   "LastIndexFunc returns the index into s of the last\nUnicode code point satisfying f(c), or -1 if none do.\n\nGo input arguments: (s string, f func)\n\nGo return type: int\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "strings.LastIndexFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.Map:
;; (defn ^"String" Map
;;   "Map returns a copy of the string s with all its characters modified\naccording to the mapping function. If mapping returns a negative value, the character is\ndropped from the string with no replacement.\n\nGo input arguments: (mapping func, s string)\n\nGo return type: string\n\nJoker input arguments: [^fn mapping, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.Map(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), _s)"}
;;   [^fn _mapping, ^String _s])

JOKER FUNC strings.NewReader:
;; (defn NewReader
;;   "NewReader returns a new Reader reading from s.\nIt is similar to bytes.NewBufferString but more efficient and read-only.\n\nGo input arguments: (s string)\n\nGo return type: *Reader\n\nJoker input arguments: [^String s]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReader(_s))"}
;;   [^String _s])

JOKER FUNC strings.NewReplacer:
;; (defn NewReplacer
;;   "NewReplacer returns a new Replacer from a list of old, new string\npairs. Replacements are performed in the order they appear in the\ntarget string, without overlapping matches.\n\nGo input arguments: (oldnew ...string)\n\nGo return type: *Replacer\n\nJoker input arguments: [^(ellipsis-somehow String) oldnew]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newReplacer(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_oldnew))))"}
;;   [^String _oldnew])

JOKER FUNC strings.Repeat:
(defn ^"String" Repeat
  "Repeat returns a new string consisting of count copies of the string s.\n\nIt panics if count is negative or if\nthe result of (len(s) * count) overflows.\n\nGo input arguments: (s string, count int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^Int count]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Repeat(_s, _count)"}
  [^String _s, ^Int _count])

JOKER FUNC strings.Replace:
(defn ^"String" Replace
  "Replace returns a copy of the string s with the first n\nnon-overlapping instances of old replaced by new.\nIf old is empty, it matches at the beginning of the string\nand after each UTF-8 sequence, yielding up to k+1 replacements\nfor a k-rune string.\nIf n < 0, there is no limit on the number of replacements.\n\nGo input arguments: (s string, old string, new string, n int)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String old, ^String new, ^Int n]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Replace(_s, _old, _new, _n)"}
  [^String _s, ^String _old, ^String _new, ^Int _n])

JOKER FUNC strings.Split:
(defn Split
  "Split slices s into all substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nIf s does not contain sep and sep is not empty, Split returns a\nslice of length 1 whose only element is s.\n\nIf sep is empty, Split splits after each UTF-8 sequence. If both s\nand sep are empty, Split returns an empty slice.\n\nIt is equivalent to SplitN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "split(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfter:
(defn SplitAfter
  "SplitAfter slices s into all substrings after each instance of sep and\nreturns a slice of those substrings.\n\nIf s does not contain sep and sep is not empty, SplitAfter returns\na slice of length 1 whose only element is s.\n\nIf sep is empty, SplitAfter splits after each UTF-8 sequence. If\nboth s and sep are empty, SplitAfter returns an empty slice.\n\nIt is equivalent to SplitAfterN with a count of -1.\n\nGo input arguments: (s string, sep string)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfter(_s, _sep)"}
  [^String _s, ^String _sep])

JOKER FUNC strings.SplitAfterN:
(defn SplitAfterN
  "SplitAfterN slices s into substrings after each instance of sep and\nreturns a slice of those substrings.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for SplitAfter.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitAfterN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.SplitN:
(defn SplitN
  "SplitN slices s into substrings separated by sep and returns a slice of\nthe substrings between those separators.\n\nThe count determines the number of substrings to return:\n  n > 0: at most n substrings; the last substring will be the unsplit remainder.\n  n == 0: the result is nil (zero substrings)\n  n < 0: all substrings\n\nEdge cases for s and sep (for example, empty strings) are handled\nas described in the documentation for Split.\n\nGo input arguments: (s string, sep string, n int)\n\nGo return type: []string\n\nJoker input arguments: [^String s, ^String sep, ^Int n]\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "splitN(_s, _sep, _n)"}
  [^String _s, ^String _sep, ^Int _n])

JOKER FUNC strings.Title:
(defn ^"String" Title
  "Title returns a copy of the string s with all Unicode letters that begin words\nmapped to their title case.\n\nBUG(rsc): The rule Title uses for word boundaries does not handle Unicode punctuation properly.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Title(_s)"}
  [^String _s])

JOKER FUNC strings.ToLower:
(defn ^"String" ToLower
  "ToLower returns a copy of the string s with all Unicode letters mapped to their lower case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToLower(_s)"}
  [^String _s])

JOKER FUNC strings.ToLowerSpecial:
;; (defn ^"String" ToLowerSpecial
;;   "ToLowerSpecial returns a copy of the string s with all Unicode letters mapped to their\nlower case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^unicode.SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToLowerSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), _s)"}
;;   [^unicode.SpecialCase _c, ^String _s])

JOKER FUNC strings.ToTitle:
(defn ^"String" ToTitle
  "ToTitle returns a copy of the string s with all Unicode letters mapped to their title case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToTitle(_s)"}
  [^String _s])

JOKER FUNC strings.ToTitleSpecial:
;; (defn ^"String" ToTitleSpecial
;;   "ToTitleSpecial returns a copy of the string s with all Unicode letters mapped to their\ntitle case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^unicode.SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToTitleSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), _s)"}
;;   [^unicode.SpecialCase _c, ^String _s])

JOKER FUNC strings.ToUpper:
(defn ^"String" ToUpper
  "ToUpper returns a copy of the string s with all Unicode letters mapped to their upper case.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.ToUpper(_s)"}
  [^String _s])

JOKER FUNC strings.ToUpperSpecial:
;; (defn ^"String" ToUpperSpecial
;;   "ToUpperSpecial returns a copy of the string s with all Unicode letters mapped to their\nupper case, giving priority to the special casing rules.\n\nGo input arguments: (c unicode.SpecialCase, s string)\n\nGo return type: string\n\nJoker input arguments: [^unicode.SpecialCase c, ^String s]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.ToUpperSpecial(ABEND904(custom-runtime routine not implemented: unicode.SpecialCase(_c)), _s)"}
;;   [^unicode.SpecialCase _c, ^String _s])

JOKER FUNC strings.Trim:
(defn ^"String" Trim
  "Trim returns a slice of the string s with all leading and\ntrailing Unicode code points contained in cutset removed.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.Trim(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimFunc:
;; (defn ^"String" TrimFunc
;;   "TrimFunc returns a slice of the string s with all leading\nand trailing Unicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimLeft:
(defn ^"String" TrimLeft
  "TrimLeft returns a slice of the string s with all leading\nUnicode code points contained in cutset removed.\n\nTo remove a prefix, use TrimPrefix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimLeft(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimLeftFunc:
;; (defn ^"String" TrimLeftFunc
;;   "TrimLeftFunc returns a slice of the string s with all leading\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimLeftFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimPrefix:
(defn ^"String" TrimPrefix
  "TrimPrefix returns s without the provided leading prefix string.\nIf s doesn't start with prefix, s is returned unchanged.\n\nGo input arguments: (s string, prefix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String prefix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimPrefix(_s, _prefix)"}
  [^String _s, ^String _prefix])

JOKER FUNC strings.TrimRight:
(defn ^"String" TrimRight
  "TrimRight returns a slice of the string s, with all trailing\nUnicode code points contained in cutset removed.\n\nTo remove a suffix, use TrimSuffix instead.\n\nGo input arguments: (s string, cutset string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String cutset]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimRight(_s, _cutset)"}
  [^String _s, ^String _cutset])

JOKER FUNC strings.TrimRightFunc:
;; (defn ^"String" TrimRightFunc
;;   "TrimRightFunc returns a slice of the string s with all trailing\nUnicode code points c satisfying f(c) removed.\n\nGo input arguments: (s string, f func)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^fn f]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "strings.TrimRightFunc(_s, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^String _s, ^fn _f])

JOKER FUNC strings.TrimSpace:
(defn ^"String" TrimSpace
  "TrimSpace returns a slice of the string s, with all leading\nand trailing white space removed, as defined by Unicode.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSpace(_s)"}
  [^String _s])

JOKER FUNC strings.TrimSuffix:
(defn ^"String" TrimSuffix
  "TrimSuffix returns s without the provided trailing suffix string.\nIf s doesn't end with suffix, s is returned unchanged.\n\nGo input arguments: (s string, suffix string)\n\nGo return type: string\n\nJoker input arguments: [^String s, ^String suffix]\n\nJoker return type: String"
  {:added "1.0"
   :go "strings.TrimSuffix(_s, _suffix)"}
  [^String _s, ^String _suffix])

JOKER FUNC sync.NewCond:
;; (defn NewCond
;;   "NewCond returns a new Cond with Locker l.\n\nGo input arguments: (l sync.Locker)\n\nGo return type: *Cond\n\nJoker input arguments: [^sync.Locker l]\n\nJoker return type: {:L ^ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/sync/mutex.go:31:13)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newCond(ABEND904(custom-runtime routine not implemented: sync.Locker(_l))))"}
;;   [^sync.Locker _l])

JOKER FUNC sync/atomic.AddInt32:
;; (defn ^"Int" AddInt32
;;   "AddInt32 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int32, delta int32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.AddInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt32(_addr)), _delta))"}
;;   [^Object _addr, ^Int32 _delta])

JOKER FUNC sync/atomic.AddInt64:
;; (defn ^"Int" AddInt64
;;   "AddInt64 atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *int64, delta int64)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.AddInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_addr)), _delta))"}
;;   [^Object _addr, ^Int64 _delta])

JOKER FUNC sync/atomic.AddUint32:
;; (defn ^"Int" AddUint32
;;   "AddUint32 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint32(&x, ^uint32(c-1)).\nIn particular, to decrement x, do AddUint32(&x, ^uint32(0)).\n\nGo input arguments: (addr *uint32, delta uint32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 delta]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.AddUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt32(_addr)), _delta))"}
;;   [^Object _addr, ^UInt32 _delta])

JOKER FUNC sync/atomic.AddUint64:
;; (defn AddUint64
;;   "AddUint64 atomically adds delta to *addr and returns the new value.\nTo subtract a signed positive constant value c from x, do AddUint64(&x, ^uint64(c-1)).\nIn particular, to decrement x, do AddUint64(&x, ^uint64(0)).\n\nGo input arguments: (addr *uint64, delta uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 delta]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "addUint64(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_addr), _delta)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _delta])

JOKER FUNC sync/atomic.AddUintptr:
;; (defn AddUintptr
;;   "AddUintptr atomically adds delta to *addr and returns the new value.\n\nGo input arguments: (addr *uintptr, delta uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr delta]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "addUintptr(ConvertToIndirectOfABEND044(unsupported built-in type uintptr)(_addr), _delta)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _delta])

JOKER FUNC sync/atomic.CompareAndSwapInt32:
;; (defn ^"Bool" CompareAndSwapInt32
;;   "CompareAndSwapInt32 executes the compare-and-swap operation for an int32 value.\n\nGo input arguments: (addr *int32, old int32, new int32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 old, ^Int32 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt32(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int32 _old, ^Int32 _new])

JOKER FUNC sync/atomic.CompareAndSwapInt64:
;; (defn ^"Bool" CompareAndSwapInt64
;;   "CompareAndSwapInt64 executes the compare-and-swap operation for an int64 value.\n\nGo input arguments: (addr *int64, old int64, new int64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 old, ^Int64 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_addr)), _old, _new)"}
;;   [^Object _addr, ^Int64 _old, ^Int64 _new])

JOKER FUNC sync/atomic.CompareAndSwapPointer:
;; (defn ^"Bool" CompareAndSwapPointer
;;   "CompareAndSwapPointer executes the compare-and-swap operation for a unsafe.Pointer value.\n\nGo input arguments: (addr *unsafe.Pointer, old unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of unsafe.Pointer) addr, ^unsafe.Pointer old, ^unsafe.Pointer new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapPointer(ConvertToIndirectOfunsafe.Pointer(ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_addr))), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_old)), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_new)))"}
;;   [^Object _addr, ^unsafe.Pointer _old, ^unsafe.Pointer _new])

JOKER FUNC sync/atomic.CompareAndSwapUint32:
;; (defn ^"Bool" CompareAndSwapUint32
;;   "CompareAndSwapUint32 executes the compare-and-swap operation for a uint32 value.\n\nGo input arguments: (addr *uint32, old uint32, new uint32)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 old, ^UInt32 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt32(_addr)), _old, _new)"}
;;   [^Object _addr, ^UInt32 _old, ^UInt32 _new])

JOKER FUNC sync/atomic.CompareAndSwapUint64:
;; (defn ^"Bool" CompareAndSwapUint64
;;   "CompareAndSwapUint64 executes the compare-and-swap operation for a uint64 value.\n\nGo input arguments: (addr *uint64, old uint64, new uint64)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 old, ^uint64 new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUint64(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_addr), _old, _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _old, ^ABEND044(unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.CompareAndSwapUintptr:
;; (defn ^"Bool" CompareAndSwapUintptr
;;   "CompareAndSwapUintptr executes the compare-and-swap operation for a uintptr value.\n\nGo input arguments: (addr *uintptr, old uintptr, new uintptr)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr old, ^uintptr new]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "atomic.CompareAndSwapUintptr(ConvertToIndirectOfABEND044(unsupported built-in type uintptr)(_addr), _old, _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _old, ^ABEND044(unsupported built-in type uintptr) _new])

JOKER FUNC sync/atomic.LoadInt32:
;; (defn ^"Int" LoadInt32
;;   "LoadInt32 atomically loads *addr.\n\nGo input arguments: (addr *int32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int32) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.LoadInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt32(_addr))))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadInt64:
;; (defn ^"Int" LoadInt64
;;   "LoadInt64 atomically loads *addr.\n\nGo input arguments: (addr *int64)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int64) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.LoadInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_addr))))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadPointer:
;; (defn LoadPointer
;;   "LoadPointer atomically loads *addr.\n\nGo input arguments: (addr *unsafe.Pointer)\n\nGo return type: *ArbitraryType\n\nJoker input arguments: [^(atom-of unsafe.Pointer) addr]\n\nJoker return type: ABEND042(cannot find typename sync/atomic.ArbitraryType)"
;;   {:added "1.0"
;;    :go "loadPointer(ConvertToIndirectOfunsafe.Pointer(ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_addr))))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUint32:
;; (defn ^"Int" LoadUint32
;;   "LoadUint32 atomically loads *addr.\n\nGo input arguments: (addr *uint32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of UInt32) addr]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.LoadUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt32(_addr))))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUint64:
;; (defn LoadUint64
;;   "LoadUint64 atomically loads *addr.\n\nGo input arguments: (addr *uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "loadUint64(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_addr))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.LoadUintptr:
;; (defn LoadUintptr
;;   "LoadUintptr atomically loads *addr.\n\nGo input arguments: (addr *uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "loadUintptr(ConvertToIndirectOfABEND044(unsupported built-in type uintptr)(_addr))"}
;;   [^Object _addr])

JOKER FUNC sync/atomic.StoreInt32:
;; (defn StoreInt32
;;   "StoreInt32 atomically stores val into *addr.\n\nGo input arguments: (addr *int32, val int32)\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 val]"
;;   {:added "1.0"
;;    :go "storeInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt32(_addr)), _val)"}
;;   [^Object _addr, ^Int32 _val])

JOKER FUNC sync/atomic.StoreInt64:
;; (defn StoreInt64
;;   "StoreInt64 atomically stores val into *addr.\n\nGo input arguments: (addr *int64, val int64)\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 val]"
;;   {:added "1.0"
;;    :go "storeInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_addr)), _val)"}
;;   [^Object _addr, ^Int64 _val])

JOKER FUNC sync/atomic.StorePointer:
;; (defn StorePointer
;;   "StorePointer atomically stores val into *addr.\n\nGo input arguments: (addr *unsafe.Pointer, val unsafe.Pointer)\n\nJoker input arguments: [^(atom-of unsafe.Pointer) addr, ^unsafe.Pointer val]"
;;   {:added "1.0"
;;    :go "storePointer(ConvertToIndirectOfunsafe.Pointer(ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_addr))), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_val)))"}
;;   [^Object _addr, ^unsafe.Pointer _val])

JOKER FUNC sync/atomic.StoreUint32:
;; (defn StoreUint32
;;   "StoreUint32 atomically stores val into *addr.\n\nGo input arguments: (addr *uint32, val uint32)\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 val]"
;;   {:added "1.0"
;;    :go "storeUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt32(_addr)), _val)"}
;;   [^Object _addr, ^UInt32 _val])

JOKER FUNC sync/atomic.StoreUint64:
;; (defn StoreUint64
;;   "StoreUint64 atomically stores val into *addr.\n\nGo input arguments: (addr *uint64, val uint64)\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 val]"
;;   {:added "1.0"
;;    :go "storeUint64(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_addr), _val)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _val])

JOKER FUNC sync/atomic.StoreUintptr:
;; (defn StoreUintptr
;;   "StoreUintptr atomically stores val into *addr.\n\nGo input arguments: (addr *uintptr, val uintptr)\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr val]"
;;   {:added "1.0"
;;    :go "storeUintptr(ConvertToIndirectOfABEND044(unsupported built-in type uintptr)(_addr), _val)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _val])

JOKER FUNC sync/atomic.SwapInt32:
;; (defn ^"Int" SwapInt32
;;   "SwapInt32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int32, new int32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int32) addr, ^Int32 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.SwapInt32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt32(_addr)), _new))"}
;;   [^Object _addr, ^Int32 _new])

JOKER FUNC sync/atomic.SwapInt64:
;; (defn ^"Int" SwapInt64
;;   "SwapInt64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *int64, new int64)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of Int64) addr, ^Int64 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.SwapInt64(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_addr)), _new))"}
;;   [^Object _addr, ^Int64 _new])

JOKER FUNC sync/atomic.SwapPointer:
;; (defn SwapPointer
;;   "SwapPointer atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *unsafe.Pointer, new unsafe.Pointer)\n\nGo return type: *ArbitraryType\n\nJoker input arguments: [^(atom-of unsafe.Pointer) addr, ^unsafe.Pointer new]\n\nJoker return type: ABEND042(cannot find typename sync/atomic.ArbitraryType)"
;;   {:added "1.0"
;;    :go "swapPointer(ConvertToIndirectOfunsafe.Pointer(ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_addr))), ABEND904(custom-runtime routine not implemented: unsafe.Pointer(_new)))"}
;;   [^Object _addr, ^unsafe.Pointer _new])

JOKER FUNC sync/atomic.SwapUint32:
;; (defn ^"Int" SwapUint32
;;   "SwapUint32 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint32, new uint32)\n\nGo return type: int\n\nJoker input arguments: [^(atom-of UInt32) addr, ^UInt32 new]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(atomic.SwapUint32(ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfUInt32(_addr)), _new))"}
;;   [^Object _addr, ^UInt32 _new])

JOKER FUNC sync/atomic.SwapUint64:
;; (defn SwapUint64
;;   "SwapUint64 atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uint64, new uint64)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uint64) addr, ^uint64 new]\n\nJoker return type: ABEND043(unsupported built-in type uint64)"
;;   {:added "1.0"
;;    :go "swapUint64(ConvertToIndirectOfABEND044(unsupported built-in type uint64)(_addr), _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uint64) _new])

JOKER FUNC sync/atomic.SwapUintptr:
;; (defn SwapUintptr
;;   "SwapUintptr atomically stores new into *addr and returns the previous *addr value.\n\nGo input arguments: (addr *uintptr, new uintptr)\n\nGo return type: ...\n\nJoker input arguments: [^(atom-of uintptr) addr, ^uintptr new]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "swapUintptr(ConvertToIndirectOfABEND044(unsupported built-in type uintptr)(_addr), _new)"}
;;   [^Object _addr, ^ABEND044(unsupported built-in type uintptr) _new])

JOKER FUNC syscall.Accept:
;; (defn Accept
;;   "Go input arguments: (fd int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "accept(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.Accept4:
;; (defn Accept4
;;   "Go input arguments: (fd int, flags int)\n\nGo return type: (nfd int, sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^Int flags]\n\nJoker return type: [Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "accept4(_fd, _flags)"}
;;   [^Int _fd, ^Int _flags])

JOKER FUNC syscall.Access:
(defn ^"Error" Access
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Access(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Acct:
(defn ^"Error" Acct
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Acct(_path)"}
  [^String _path])

JOKER FUNC syscall.Adjtimex:
;; (defn Adjtimex
;;   "Go input arguments: (buf *syscall.Timex)\n\nGo return type: (state int, err error)\n\nJoker input arguments: [^(atom-of syscall.Timex) buf]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "adjtimex(ConvertToIndirectOfsyscall.Timex(ABEND904(custom-runtime routine not implemented: syscall.Timex(_buf))))"}
;;   [^Object _buf])

JOKER FUNC syscall.AttachLsf:
;; (defn ^"Error" AttachLsf
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int, i []syscall.SockFilter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of syscall.SockFilter) i]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.AttachLsf(_fd, ConvertToArrayOfsyscall.SockFilter(ABEND904(custom-runtime routine not implemented: syscall.SockFilter(_i))))"}
;;   [^Int _fd, ^Object _i])

JOKER FUNC syscall.Bind:
;; (defn ^"Error" Bind
;;   "Go input arguments: (fd int, sa syscall.Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^syscall.Sockaddr sa]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Bind(_fd, ABEND904(custom-runtime routine not implemented: syscall.Sockaddr(_sa)))"}
;;   [^Int _fd, ^syscall.Sockaddr _sa])

JOKER FUNC syscall.BindToDevice:
(defn ^"Error" BindToDevice
  "BindToDevice binds the socket associated with fd to device.\n\nGo input arguments: (fd int, device string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^String device]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.BindToDevice(_fd, _device)"}
  [^Int _fd, ^String _device])

JOKER FUNC syscall.BytePtrFromString:
(defn BytePtrFromString
  "BytePtrFromString returns a pointer to a NUL-terminated array of\nbytes containing the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: (*int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "bytePtrFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.ByteSliceFromString:
(defn ByteSliceFromString
  "ByteSliceFromString returns a NUL-terminated slice of bytes\ncontaining the text of s. If s contains a NUL byte at any\nlocation, it returns (nil, EINVAL).\n\nGo input arguments: (s string)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "byteSliceFromString(_s)"}
  [^String _s])

JOKER FUNC syscall.Chdir:
(defn ^"Error" Chdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chdir(_path)"}
  [^String _path])

JOKER FUNC syscall.Chmod:
(defn ^"Error" Chmod
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chmod(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Chown:
(defn ^"Error" Chown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Chroot:
(defn ^"Error" Chroot
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Chroot(_path)"}
  [^String _path])

JOKER FUNC syscall.Clearenv:
;; (defn Clearenv
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "clearenv()"}
;;   [])

JOKER FUNC syscall.Close:
(defn ^"Error" Close
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Close(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.CloseOnExec:
;; (defn CloseOnExec
;;   "Go input arguments: (fd int)\n\nJoker input arguments: [^Int fd]"
;;   {:added "1.0"
;;    :go "closeOnExec(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.CmsgLen:
(defn ^"Int" CmsgLen
  "CmsgLen returns the value to store in the Len field of the Cmsghdr\nstructure, taking into account any necessary alignment.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgLen(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.CmsgSpace:
(defn ^"Int" CmsgSpace
  "CmsgSpace returns the number of bytes an ancillary element with\npayload of the passed data length occupies.\n\nGo input arguments: (datalen int)\n\nGo return type: int\n\nJoker input arguments: [^Int datalen]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.CmsgSpace(_datalen)"}
  [^Int _datalen])

JOKER FUNC syscall.Connect:
;; (defn ^"Error" Connect
;;   "Go input arguments: (fd int, sa syscall.Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^syscall.Sockaddr sa]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Connect(_fd, ABEND904(custom-runtime routine not implemented: syscall.Sockaddr(_sa)))"}
;;   [^Int _fd, ^syscall.Sockaddr _sa])

JOKER FUNC syscall.Creat:
(defn Creat
  "Go input arguments: (path string, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "creat(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.DetachLsf:
(defn ^"Error" DetachLsf
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.DetachLsf(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Dup:
(defn Dup
  "Go input arguments: (oldfd int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int oldfd]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "dup(_oldfd)"}
  [^Int _oldfd])

JOKER FUNC syscall.Dup2:
(defn ^"Error" Dup2
  "Go input arguments: (oldfd int, newfd int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup2(_oldfd, _newfd)"}
  [^Int _oldfd, ^Int _newfd])

JOKER FUNC syscall.Dup3:
(defn ^"Error" Dup3
  "Go input arguments: (oldfd int, newfd int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int oldfd, ^Int newfd, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Dup3(_oldfd, _newfd, _flags)"}
  [^Int _oldfd, ^Int _newfd, ^Int _flags])

JOKER FUNC syscall.Environ:
(defn Environ
  "Go return type: []string\n\nJoker input arguments: []\n\nJoker return type: (vector-of String)"
  {:added "1.0"
   :go "environ()"}
  [])

JOKER FUNC syscall.EpollCreate:
(defn EpollCreate
  "Go input arguments: (size int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int size]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "epollCreate(_size)"}
  [^Int _size])

JOKER FUNC syscall.EpollCreate1:
(defn EpollCreate1
  "Go input arguments: (flag int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flag]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "epollCreate1(_flag)"}
  [^Int _flag])

JOKER FUNC syscall.EpollCtl:
;; (defn ^"Error" EpollCtl
;;   "Go input arguments: (epfd int, op int, fd int, event *syscall.EpollEvent)\n\nGo return type: error\n\nJoker input arguments: [^Int epfd, ^Int op, ^Int fd, ^(atom-of syscall.EpollEvent) event]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.EpollCtl(_epfd, _op, _fd, ConvertToIndirectOfsyscall.EpollEvent(ABEND904(custom-runtime routine not implemented: syscall.EpollEvent(_event))))"}
;;   [^Int _epfd, ^Int _op, ^Int _fd, ^Object _event])

JOKER FUNC syscall.EpollWait:
;; (defn EpollWait
;;   "Go input arguments: (epfd int, events []syscall.EpollEvent, msec int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int epfd, ^(vector-of syscall.EpollEvent) events, ^Int msec]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "epollWait(_epfd, ConvertToArrayOfsyscall.EpollEvent(ABEND904(custom-runtime routine not implemented: syscall.EpollEvent(_events))), _msec)"}
;;   [^Int _epfd, ^Object _events, ^Int _msec])

JOKER FUNC syscall.Exec:
(defn ^"Error" Exec
  "Exec invokes the execve(2) system call.\n\nGo input arguments: (argv0 string, argv []string, envv []string)\n\nGo return type: error\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(vector-of String) envv]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Exec(_argv0, ConvertToArrayOfString(_argv), ConvertToArrayOfString(_envv))"}
  [^String _argv0, ^Object _argv, ^Object _envv])

JOKER FUNC syscall.Exit:
;; (defn Exit
;;   "Go input arguments: (code int)\n\nJoker input arguments: [^Int code]"
;;   {:added "1.0"
;;    :go "exit(_code)"}
;;   [^Int _code])

JOKER FUNC syscall.Faccessat:
(defn ^"Error" Faccessat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Faccessat(_dirfd, _path, _mode, _flags)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _flags])

JOKER FUNC syscall.Fallocate:
(defn ^"Error" Fallocate
  "Go input arguments: (fd int, mode uint32, off int64, len int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^UInt32 mode, ^Int64 off, ^Int64 len]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fallocate(_fd, _mode, _off, _len)"}
  [^Int _fd, ^UInt32 _mode, ^Int64 _off, ^Int64 _len])

JOKER FUNC syscall.Fchdir:
(defn ^"Error" Fchdir
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchdir(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Fchmod:
(defn ^"Error" Fchmod
  "Go input arguments: (fd int, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmod(_fd, _mode)"}
  [^Int _fd, ^UInt32 _mode])

JOKER FUNC syscall.Fchmodat:
(defn ^"Error" Fchmodat
  "Go input arguments: (dirfd int, path string, mode uint32, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchmodat(_dirfd, _path, _mode, _flags)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _flags])

JOKER FUNC syscall.Fchown:
(defn ^"Error" Fchown
  "Go input arguments: (fd int, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchown(_fd, _uid, _gid)"}
  [^Int _fd, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Fchownat:
(defn ^"Error" Fchownat
  "Go input arguments: (dirfd int, path string, uid int, gid int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int uid, ^Int gid, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fchownat(_dirfd, _path, _uid, _gid, _flags)"}
  [^Int _dirfd, ^String _path, ^Int _uid, ^Int _gid, ^Int _flags])

JOKER FUNC syscall.FcntlFlock:
;; (defn ^"Error" FcntlFlock
;;   "FcntlFlock performs a fcntl syscall for the F_GETLK, F_SETLK or F_SETLKW command.\n\nGo input arguments: (fd uintptr, cmd int, lk *syscall.Flock_t)\n\nGo return type: error\n\nJoker input arguments: [^uintptr fd, ^Int cmd, ^(atom-of syscall.Flock_t) lk]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.FcntlFlock(_fd, _cmd, ConvertToIndirectOfsyscall.Flock_t(ABEND904(custom-runtime routine not implemented: syscall.Flock_t(_lk))))"}
;;   [^ABEND044(unsupported built-in type uintptr) _fd, ^Int _cmd, ^Object _lk])

JOKER FUNC syscall.Fdatasync:
(defn ^"Error" Fdatasync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fdatasync(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Flock:
(defn ^"Error" Flock
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Flock(_fd, _how)"}
  [^Int _fd, ^Int _how])

JOKER FUNC syscall.ForkExec:
;; (defn ForkExec
;;   "Combination of fork and exec, careful to be thread safe.\n\nGo input arguments: (argv0 string, argv []string, attr *syscall.ProcAttr)\n\nGo return type: (pid int, err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of syscall.ProcAttr) attr]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "forkExec(_argv0, ConvertToArrayOfString(_argv), ConvertToIndirectOfsyscall.ProcAttr(ABEND904(custom-runtime routine not implemented: syscall.ProcAttr(_attr))))"}
;;   [^String _argv0, ^Object _argv, ^Object _attr])

JOKER FUNC syscall.Fstat:
;; (defn ^"Error" Fstat
;;   "Go input arguments: (fd int, stat *syscall.Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of syscall.Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstat(_fd, ConvertToIndirectOfsyscall.Stat_t(ABEND904(custom-runtime routine not implemented: syscall.Stat_t(_stat))))"}
;;   [^Int _fd, ^Object _stat])

JOKER FUNC syscall.Fstatfs:
;; (defn ^"Error" Fstatfs
;;   "Go input arguments: (fd int, buf *syscall.Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(atom-of syscall.Statfs_t) buf]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Fstatfs(_fd, ConvertToIndirectOfsyscall.Statfs_t(ABEND904(custom-runtime routine not implemented: syscall.Statfs_t(_buf))))"}
;;   [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Fsync:
(defn ^"Error" Fsync
  "Go input arguments: (fd int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Fsync(_fd)"}
  [^Int _fd])

JOKER FUNC syscall.Ftruncate:
(defn ^"Error" Ftruncate
  "Go input arguments: (fd int, length int64)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ftruncate(_fd, _length)"}
  [^Int _fd, ^Int64 _length])

JOKER FUNC syscall.Futimes:
;; (defn ^"Error" Futimes
;;   "Go input arguments: (fd int, tv []syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimes(_fd, ConvertToArrayOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^Int _fd, ^Object _tv])

JOKER FUNC syscall.Futimesat:
;; (defn ^"Error" Futimesat
;;   "Go input arguments: (dirfd int, path string, tv []syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^(vector-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Futimesat(_dirfd, _path, ConvertToArrayOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^Int _dirfd, ^String _path, ^Object _tv])

JOKER FUNC syscall.Getcwd:
(defn Getcwd
  "Go input arguments: (buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getcwd(ConvertToArrayOfByte(_buf))"}
  [^Object _buf])

JOKER FUNC syscall.Getdents:
(defn Getdents
  "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getdents(_fd, ConvertToArrayOfByte(_buf))"}
  [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Getegid:
(defn ^"Int" Getegid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getegid()"}
  [])

JOKER FUNC syscall.Getenv:
(defn Getenv
  "Go input arguments: (key string)\n\nGo return type: (value string, found bool)\n\nJoker input arguments: [^String key]\n\nJoker return type: [String Bool]"
  {:added "1.0"
   :go "getenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Geteuid:
(defn ^"Int" Geteuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Geteuid()"}
  [])

JOKER FUNC syscall.Getgid:
(defn ^"Int" Getgid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getgid()"}
  [])

JOKER FUNC syscall.Getgroups:
(defn Getgroups
  "Go return type: (gids []int, err error)\n\nJoker input arguments: []\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getgroups()"}
  [])

JOKER FUNC syscall.Getpagesize:
(defn ^"Int" Getpagesize
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpagesize()"}
  [])

JOKER FUNC syscall.Getpeername:
;; (defn Getpeername
;;   "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "getpeername(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.Getpgid:
(defn Getpgid
  "Go input arguments: (pid int)\n\nGo return type: (pgid int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpgid(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.Getpgrp:
(defn ^"Int" Getpgrp
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpgrp()"}
  [])

JOKER FUNC syscall.Getpid:
(defn ^"Int" Getpid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getpid()"}
  [])

JOKER FUNC syscall.Getppid:
(defn ^"Int" Getppid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getppid()"}
  [])

JOKER FUNC syscall.Getpriority:
(defn Getpriority
  "Go input arguments: (which int, who int)\n\nGo return type: (prio int, err error)\n\nJoker input arguments: [^Int which, ^Int who]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getpriority(_which, _who)"}
  [^Int _which, ^Int _who])

JOKER FUNC syscall.Getrlimit:
;; (defn ^"Error" Getrlimit
;;   "Go input arguments: (resource int, rlim *syscall.Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of syscall.Rlimit) rlim]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrlimit(_resource, ConvertToIndirectOfsyscall.Rlimit(ABEND904(custom-runtime routine not implemented: syscall.Rlimit(_rlim))))"}
;;   [^Int _resource, ^Object _rlim])

JOKER FUNC syscall.Getrusage:
;; (defn ^"Error" Getrusage
;;   "Go input arguments: (who int, rusage *syscall.Rusage)\n\nGo return type: error\n\nJoker input arguments: [^Int who, ^(atom-of syscall.Rusage) rusage]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Getrusage(_who, ConvertToIndirectOfsyscall.Rusage(ABEND904(custom-runtime routine not implemented: syscall.Rusage(_rusage))))"}
;;   [^Int _who, ^Object _rusage])

JOKER FUNC syscall.Getsockname:
;; (defn Getsockname
;;   "Go input arguments: (fd int)\n\nGo return type: (sa Sockaddr, err error)\n\nJoker input arguments: [^Int fd]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "getsockname(_fd)"}
;;   [^Int _fd])

JOKER FUNC syscall.GetsockoptICMPv6Filter:
(defn GetsockoptICMPv6Filter
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*ICMPv6Filter, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Data ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "getsockoptICMPv6Filter(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPMreq:
(defn GetsockoptIPMreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^(vector-of Int)} Error]"
  {:added "1.0"
   :go "getsockoptIPMreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPMreqn:
(defn GetsockoptIPMreqn
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPMreqn, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Multiaddr ^(vector-of Int), :Address ^(vector-of Int), :Ifindex ^Int} Error]"
  {:added "1.0"
   :go "getsockoptIPMreqn(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6MTUInfo:
(defn GetsockoptIPv6MTUInfo
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6MTUInfo, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Addr ^{:Family ^Int, :Port ^Int, :Flowinfo ^Int, :Addr ^(vector-of Int), :Scope_id ^Int}, :Mtu ^Int} Error]"
  {:added "1.0"
   :go "getsockoptIPv6MTUInfo(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptIPv6Mreq:
(defn GetsockoptIPv6Mreq
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*IPv6Mreq, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Multiaddr ^(vector-of Int), :Interface ^Int} Error]"
  {:added "1.0"
   :go "getsockoptIPv6Mreq(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInet4Addr:
(defn GetsockoptInet4Addr
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value []int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "getsockoptInet4Addr(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptInt:
(defn GetsockoptInt
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (value int, err error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getsockoptInt(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.GetsockoptUcred:
(defn GetsockoptUcred
  "Go input arguments: (fd int, level int, opt int)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt]\n\nJoker return type: [{:Pid ^Int, :Uid ^Int, :Gid ^Int} Error]"
  {:added "1.0"
   :go "getsockoptUcred(_fd, _level, _opt)"}
  [^Int _fd, ^Int _level, ^Int _opt])

JOKER FUNC syscall.Gettid:
(defn ^"Int" Gettid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Gettid()"}
  [])

JOKER FUNC syscall.Gettimeofday:
;; (defn ^"Error" Gettimeofday
;;   "Go input arguments: (tv *syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Gettimeofday(ConvertToIndirectOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^Object _tv])

JOKER FUNC syscall.Getuid:
(defn ^"Int" Getuid
  "Go return type: int\n\nJoker input arguments: []\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Getuid()"}
  [])

JOKER FUNC syscall.Getwd:
(defn Getwd
  "Go return type: (wd string, err error)\n\nJoker input arguments: []\n\nJoker return type: [String Error]"
  {:added "1.0"
   :go "getwd()"}
  [])

JOKER FUNC syscall.Getxattr:
(defn Getxattr
  "Go input arguments: (path string, attr string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Byte) dest]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "getxattr(_path, _attr, ConvertToArrayOfByte(_dest))"}
  [^String _path, ^String _attr, ^Object _dest])

JOKER FUNC syscall.InotifyAddWatch:
(defn InotifyAddWatch
  "Go input arguments: (fd int, pathname string, mask uint32)\n\nGo return type: (watchdesc int, err error)\n\nJoker input arguments: [^Int fd, ^String pathname, ^UInt32 mask]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "inotifyAddWatch(_fd, _pathname, _mask)"}
  [^Int _fd, ^String _pathname, ^UInt32 _mask])

JOKER FUNC syscall.InotifyInit:
(defn InotifyInit
  "Go return type: (fd int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "inotifyInit()"}
  [])

JOKER FUNC syscall.InotifyInit1:
(defn InotifyInit1
  "Go input arguments: (flags int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int flags]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "inotifyInit1(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.InotifyRmWatch:
(defn InotifyRmWatch
  "Go input arguments: (fd int, watchdesc uint32)\n\nGo return type: (success int, err error)\n\nJoker input arguments: [^Int fd, ^UInt32 watchdesc]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "inotifyRmWatch(_fd, _watchdesc)"}
  [^Int _fd, ^UInt32 _watchdesc])

JOKER FUNC syscall.Ioperm:
(defn ^"Error" Ioperm
  "Go input arguments: (from int, num int, on int)\n\nGo return type: error\n\nJoker input arguments: [^Int from, ^Int num, ^Int on]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Ioperm(_from, _num, _on)"}
  [^Int _from, ^Int _num, ^Int _on])

JOKER FUNC syscall.Iopl:
(defn ^"Error" Iopl
  "Go input arguments: (level int)\n\nGo return type: error\n\nJoker input arguments: [^Int level]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Iopl(_level)"}
  [^Int _level])

JOKER FUNC syscall.Kill:
;; (defn ^"Error" Kill
;;   "Go input arguments: (pid int, sig syscall.Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^syscall.Signal sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Kill(_pid, ABEND904(custom-runtime routine not implemented: syscall.Signal(_sig)))"}
;;   [^Int _pid, ^syscall.Signal _sig])

JOKER FUNC syscall.Klogctl:
(defn Klogctl
  "Go input arguments: (typ int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int typ, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "klogctl(_typ, ConvertToArrayOfByte(_buf))"}
  [^Int _typ, ^Object _buf])

JOKER FUNC syscall.Lchown:
(defn ^"Error" Lchown
  "Go input arguments: (path string, uid int, gid int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int uid, ^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Lchown(_path, _uid, _gid)"}
  [^String _path, ^Int _uid, ^Int _gid])

JOKER FUNC syscall.Link:
(defn ^"Error" Link
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Link(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Listen:
(defn ^"Error" Listen
  "Go input arguments: (s int, n int)\n\nGo return type: error\n\nJoker input arguments: [^Int s, ^Int n]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Listen(_s, _n)"}
  [^Int _s, ^Int _n])

JOKER FUNC syscall.Listxattr:
(defn Listxattr
  "Go input arguments: (path string, dest []byte)\n\nGo return type: (sz int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Byte) dest]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "listxattr(_path, ConvertToArrayOfByte(_dest))"}
  [^String _path, ^Object _dest])

JOKER FUNC syscall.LsfJump:
;; (defn LsfJump
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int, jt int, jf int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k, ^Int jt, ^Int jf]\n\nJoker return type: {:Code ^Int, :Jt ^ABEND043(unsupported built-in type uint8), :Jf ^ABEND043(unsupported built-in type uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: lsfJump(_code, _k, _jt, _jf))"}
;;   [^Int _code, ^Int _k, ^Int _jt, ^Int _jf])

JOKER FUNC syscall.LsfSocket:
(defn LsfSocket
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (ifindex int, proto int)\n\nGo return type: (int, error)\n\nJoker input arguments: [^Int ifindex, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "lsfSocket(_ifindex, _proto)"}
  [^Int _ifindex, ^Int _proto])

JOKER FUNC syscall.LsfStmt:
;; (defn LsfStmt
;;   "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (code int, k int)\n\nGo return type: *SockFilter\n\nJoker input arguments: [^Int code, ^Int k]\n\nJoker return type: {:Code ^Int, :Jt ^ABEND043(unsupported built-in type uint8), :Jf ^ABEND043(unsupported built-in type uint8), :K ^Int}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: lsfStmt(_code, _k))"}
;;   [^Int _code, ^Int _k])

JOKER FUNC syscall.Lstat:
;; (defn ^"Error" Lstat
;;   "Go input arguments: (path string, stat *syscall.Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of syscall.Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Lstat(_path, ConvertToIndirectOfsyscall.Stat_t(ABEND904(custom-runtime routine not implemented: syscall.Stat_t(_stat))))"}
;;   [^String _path, ^Object _stat])

JOKER FUNC syscall.Madvise:
(defn ^"Error" Madvise
  "Go input arguments: (b []byte, advice int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b, ^Int advice]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Madvise(ConvertToArrayOfByte(_b), _advice)"}
  [^Object _b, ^Int _advice])

JOKER FUNC syscall.Mkdir:
(defn ^"Error" Mkdir
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdir(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mkdirat:
(defn ^"Error" Mkdirat
  "Go input arguments: (dirfd int, path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkdirat(_dirfd, _path, _mode)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mkfifo:
(defn ^"Error" Mkfifo
  "Go input arguments: (path string, mode uint32)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mkfifo(_path, _mode)"}
  [^String _path, ^UInt32 _mode])

JOKER FUNC syscall.Mknod:
(defn ^"Error" Mknod
  "Go input arguments: (path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^UInt32 mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknod(_path, _mode, _dev)"}
  [^String _path, ^UInt32 _mode, ^Int _dev])

JOKER FUNC syscall.Mknodat:
(defn ^"Error" Mknodat
  "Go input arguments: (dirfd int, path string, mode uint32, dev int)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path, ^UInt32 mode, ^Int dev]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mknodat(_dirfd, _path, _mode, _dev)"}
  [^Int _dirfd, ^String _path, ^UInt32 _mode, ^Int _dev])

JOKER FUNC syscall.Mlock:
(defn ^"Error" Mlock
  "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlock(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC syscall.Mlockall:
(defn ^"Error" Mlockall
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mlockall(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.Mmap:
(defn Mmap
  "Go input arguments: (fd int, offset int64, length int, prot int, flags int)\n\nGo return type: (data []int, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int length, ^Int prot, ^Int flags]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "mmap(_fd, _offset, _length, _prot, _flags)"}
  [^Int _fd, ^Int64 _offset, ^Int _length, ^Int _prot, ^Int _flags])

JOKER FUNC syscall.Mount:
;; (defn ^"Error" Mount
;;   "Go input arguments: (source string, target string, fstype string, flags uintptr, data string)\n\nGo return type: error\n\nJoker input arguments: [^String source, ^String target, ^String fstype, ^uintptr flags, ^String data]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Mount(_source, _target, _fstype, _flags, _data)"}
;;   [^String _source, ^String _target, ^String _fstype, ^ABEND044(unsupported built-in type uintptr) _flags, ^String _data])

JOKER FUNC syscall.Mprotect:
(defn ^"Error" Mprotect
  "Go input arguments: (b []byte, prot int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b, ^Int prot]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Mprotect(ConvertToArrayOfByte(_b), _prot)"}
  [^Object _b, ^Int _prot])

JOKER FUNC syscall.Munlock:
(defn ^"Error" Munlock
  "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlock(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC syscall.Munlockall:
(defn ^"Error" Munlockall
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munlockall()"}
  [])

JOKER FUNC syscall.Munmap:
(defn ^"Error" Munmap
  "Go input arguments: (b []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Munmap(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC syscall.Nanosleep:
;; (defn ^"Error" Nanosleep
;;   "Go input arguments: (time *syscall.Timespec, leftover *syscall.Timespec)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of syscall.Timespec) time, ^(atom-of syscall.Timespec) leftover]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Nanosleep(ConvertToIndirectOfsyscall.Timespec(ABEND904(custom-runtime routine not implemented: syscall.Timespec(_time))), ConvertToIndirectOfsyscall.Timespec(ABEND904(custom-runtime routine not implemented: syscall.Timespec(_leftover))))"}
;;   [^Object _time, ^Object _leftover])

JOKER FUNC syscall.NetlinkRIB:
(defn NetlinkRIB
  "NetlinkRIB returns routing information base, as known as RIB, which\nconsists of network facility information, states and parameters.\n\nGo input arguments: (proto int, family int)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^Int proto, ^Int family]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "netlinkRIB(_proto, _family)"}
  [^Int _proto, ^Int _family])

JOKER FUNC syscall.NsecToTimespec:
(defn NsecToTimespec
  "NsecToTimespec takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timespec value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timespec\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: {:Sec ^Int, :Nsec ^Int}"
  {:added "1.0"
   :go "nsecToTimespec(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.NsecToTimeval:
(defn NsecToTimeval
  "NsecToTimeval takes a number of nanoseconds since the Unix epoch\nand returns the corresponding Timeval value.\n\nGo input arguments: (nsec int64)\n\nGo return type: Timeval\n\nJoker input arguments: [^Int64 nsec]\n\nJoker return type: {:Sec ^Int, :Usec ^Int}"
  {:added "1.0"
   :go "nsecToTimeval(_nsec)"}
  [^Int64 _nsec])

JOKER FUNC syscall.Open:
(defn Open
  "Go input arguments: (path string, mode int, perm uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^String path, ^Int mode, ^UInt32 perm]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "open(_path, _mode, _perm)"}
  [^String _path, ^Int _mode, ^UInt32 _perm])

JOKER FUNC syscall.Openat:
(defn Openat
  "Go input arguments: (dirfd int, path string, flags int, mode uint32)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int dirfd, ^String path, ^Int flags, ^UInt32 mode]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "openat(_dirfd, _path, _flags, _mode)"}
  [^Int _dirfd, ^String _path, ^Int _flags, ^UInt32 _mode])

JOKER FUNC syscall.ParseDirent:
(defn ParseDirent
  "ParseDirent parses up to max directory entries in buf,\nappending the names to names. It returns the number of\nbytes consumed from buf, the number of entries added\nto names, and the new names slice.\n\nGo input arguments: (buf []byte, max int, names []string)\n\nGo return type: (consumed int, count int, newnames []string)\n\nJoker input arguments: [^(vector-of Byte) buf, ^Int max, ^(vector-of String) names]\n\nJoker return type: [Int Int (vector-of String)]"
  {:added "1.0"
   :go "parseDirent(ConvertToArrayOfByte(_buf), _max, ConvertToArrayOfString(_names))"}
  [^Object _buf, ^Int _max, ^Object _names])

JOKER FUNC syscall.ParseNetlinkMessage:
(defn ParseNetlinkMessage
  "ParseNetlinkMessage parses b as an array of netlink messages and\nreturns the slice containing the NetlinkMessage structures.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]NetlinkMessage, error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of {:Header ^{:Len ^Int, :Type ^Int, :Flags ^Int, :Seq ^Int, :Pid ^Int}, :Data ^(vector-of Int)}) Error]"
  {:added "1.0"
   :go "parseNetlinkMessage(ConvertToArrayOfByte(_b))"}
  [^Object _b])

JOKER FUNC syscall.ParseNetlinkRouteAttr:
;; (defn ParseNetlinkRouteAttr
;;   "ParseNetlinkRouteAttr parses m's payload as an array of netlink\nroute attributes and returns the slice containing the\nNetlinkRouteAttr structures.\n\nGo input arguments: (m *syscall.NetlinkMessage)\n\nGo return type: ([]NetlinkRouteAttr, error)\n\nJoker input arguments: [^(atom-of syscall.NetlinkMessage) m]\n\nJoker return type: [(vector-of {:Attr ^{:Len ^Int, :Type ^Int}, :Value ^(vector-of Int)}) Error]"
;;   {:added "1.0"
;;    :go "parseNetlinkRouteAttr(ConvertToIndirectOfsyscall.NetlinkMessage(ABEND904(custom-runtime routine not implemented: syscall.NetlinkMessage(_m))))"}
;;   [^Object _m])

JOKER FUNC syscall.ParseSocketControlMessage:
;; (defn ParseSocketControlMessage
;;   "ParseSocketControlMessage parses b as an array of socket control\nmessages.\n\nGo input arguments: (b []byte)\n\nGo return type: ([]SocketControlMessage, error)\n\nJoker input arguments: [^(vector-of Byte) b]\n\nJoker return type: [(vector-of {:Header ^{:Len ^ABEND043(unsupported built-in type uint64), :Level ^Int, :Type ^Int}, :Data ^(vector-of Int)}) Error]"
;;   {:added "1.0"
;;    :go "parseSocketControlMessage(ConvertToArrayOfByte(_b))"}
;;   [^Object _b])

JOKER FUNC syscall.ParseUnixCredentials:
;; (defn ParseUnixCredentials
;;   "ParseUnixCredentials decodes a socket control message that contains\ncredentials in a Ucred structure. To receive such a message, the\nSO_PASSCRED option must be enabled on the socket.\n\nGo input arguments: (m *syscall.SocketControlMessage)\n\nGo return type: (*Ucred, error)\n\nJoker input arguments: [^(atom-of syscall.SocketControlMessage) m]\n\nJoker return type: [{:Pid ^Int, :Uid ^Int, :Gid ^Int} Error]"
;;   {:added "1.0"
;;    :go "parseUnixCredentials(ConvertToIndirectOfsyscall.SocketControlMessage(ABEND904(custom-runtime routine not implemented: syscall.SocketControlMessage(_m))))"}
;;   [^Object _m])

JOKER FUNC syscall.ParseUnixRights:
;; (defn ParseUnixRights
;;   "ParseUnixRights decodes a socket control message that contains an\ninteger array of open file descriptors from another process.\n\nGo input arguments: (m *syscall.SocketControlMessage)\n\nGo return type: ([]int, error)\n\nJoker input arguments: [^(atom-of syscall.SocketControlMessage) m]\n\nJoker return type: [(vector-of Int) Error]"
;;   {:added "1.0"
;;    :go "parseUnixRights(ConvertToIndirectOfsyscall.SocketControlMessage(ABEND904(custom-runtime routine not implemented: syscall.SocketControlMessage(_m))))"}
;;   [^Object _m])

JOKER FUNC syscall.Pause:
(defn ^"Error" Pause
  "Go return type: error\n\nJoker input arguments: []\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Pause()"}
  [])

JOKER FUNC syscall.Pipe:
(defn ^"Error" Pipe
  "Go input arguments: (p []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Pipe(ConvertToArrayOfInt(_p))"}
  [^Object _p])

JOKER FUNC syscall.Pipe2:
(defn ^"Error" Pipe2
  "Go input arguments: (p []int, flags int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) p, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Pipe2(ConvertToArrayOfInt(_p), _flags)"}
  [^Object _p, ^Int _flags])

JOKER FUNC syscall.PivotRoot:
(defn ^"Error" PivotRoot
  "Go input arguments: (newroot string, putold string)\n\nGo return type: error\n\nJoker input arguments: [^String newroot, ^String putold]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PivotRoot(_newroot, _putold)"}
  [^String _newroot, ^String _putold])

JOKER FUNC syscall.Pread:
(defn Pread
  "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "pread(_fd, ConvertToArrayOfByte(_p), _offset)"}
  [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.PtraceAttach:
(defn ^"Error" PtraceAttach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceAttach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceCont:
(defn ^"Error" PtraceCont
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceCont(_pid, _signal)"}
  [^Int _pid, ^Int _signal])

JOKER FUNC syscall.PtraceDetach:
(defn ^"Error" PtraceDetach
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceDetach(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceGetEventMsg:
(defn PtraceGetEventMsg
  "Go input arguments: (pid int)\n\nGo return type: (msg int, err error)\n\nJoker input arguments: [^Int pid]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "ptraceGetEventMsg(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceGetRegs:
;; (defn ^"Error" PtraceGetRegs
;;   "Go input arguments: (pid int, regsout *syscall.PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of syscall.PtraceRegs) regsout]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.PtraceGetRegs(_pid, ConvertToIndirectOfsyscall.PtraceRegs(ABEND904(custom-runtime routine not implemented: syscall.PtraceRegs(_regsout))))"}
;;   [^Int _pid, ^Object _regsout])

JOKER FUNC syscall.PtracePeekData:
;; (defn PtracePeekData
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^uintptr addr, ^(vector-of Byte) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "ptracePeekData(_pid, _addr, ConvertToArrayOfByte(_out))"}
;;   [^Int _pid, ^ABEND044(unsupported built-in type uintptr) _addr, ^Object _out])

JOKER FUNC syscall.PtracePeekText:
;; (defn PtracePeekText
;;   "Go input arguments: (pid int, addr uintptr, out []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^uintptr addr, ^(vector-of Byte) out]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "ptracePeekText(_pid, _addr, ConvertToArrayOfByte(_out))"}
;;   [^Int _pid, ^ABEND044(unsupported built-in type uintptr) _addr, ^Object _out])

JOKER FUNC syscall.PtracePokeData:
;; (defn PtracePokeData
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^uintptr addr, ^(vector-of Byte) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "ptracePokeData(_pid, _addr, ConvertToArrayOfByte(_data))"}
;;   [^Int _pid, ^ABEND044(unsupported built-in type uintptr) _addr, ^Object _data])

JOKER FUNC syscall.PtracePokeText:
;; (defn PtracePokeText
;;   "Go input arguments: (pid int, addr uintptr, data []byte)\n\nGo return type: (count int, err error)\n\nJoker input arguments: [^Int pid, ^uintptr addr, ^(vector-of Byte) data]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "ptracePokeText(_pid, _addr, ConvertToArrayOfByte(_data))"}
;;   [^Int _pid, ^ABEND044(unsupported built-in type uintptr) _addr, ^Object _data])

JOKER FUNC syscall.PtraceSetOptions:
(defn ^"Error" PtraceSetOptions
  "Go input arguments: (pid int, options int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int options]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSetOptions(_pid, _options)"}
  [^Int _pid, ^Int _options])

JOKER FUNC syscall.PtraceSetRegs:
;; (defn ^"Error" PtraceSetRegs
;;   "Go input arguments: (pid int, regs *syscall.PtraceRegs)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^(atom-of syscall.PtraceRegs) regs]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.PtraceSetRegs(_pid, ConvertToIndirectOfsyscall.PtraceRegs(ABEND904(custom-runtime routine not implemented: syscall.PtraceRegs(_regs))))"}
;;   [^Int _pid, ^Object _regs])

JOKER FUNC syscall.PtraceSingleStep:
(defn ^"Error" PtraceSingleStep
  "Go input arguments: (pid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSingleStep(_pid)"}
  [^Int _pid])

JOKER FUNC syscall.PtraceSyscall:
(defn ^"Error" PtraceSyscall
  "Go input arguments: (pid int, signal int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int signal]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.PtraceSyscall(_pid, _signal)"}
  [^Int _pid, ^Int _signal])

JOKER FUNC syscall.Pwrite:
(defn Pwrite
  "Go input arguments: (fd int, p []byte, offset int64)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int64 offset]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "pwrite(_fd, ConvertToArrayOfByte(_p), _offset)"}
  [^Int _fd, ^Object _p, ^Int64 _offset])

JOKER FUNC syscall.RawSyscall:
;; (defn RawSyscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr)]"
;;   {:added "1.0"
;;    :go "rawSyscall(_trap, _a1, _a2, _a3)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3])

JOKER FUNC syscall.RawSyscall6:
;; (defn RawSyscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3, ^uintptr a4, ^uintptr a5, ^uintptr a6]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr)]"
;;   {:added "1.0"
;;    :go "rawSyscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3, ^ABEND044(unsupported built-in type uintptr) _a4, ^ABEND044(unsupported built-in type uintptr) _a5, ^ABEND044(unsupported built-in type uintptr) _a6])

JOKER FUNC syscall.Read:
(defn Read
  "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "read(_fd, ConvertToArrayOfByte(_p))"}
  [^Int _fd, ^Object _p])

JOKER FUNC syscall.ReadDirent:
(defn ReadDirent
  "Go input arguments: (fd int, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "readDirent(_fd, ConvertToArrayOfByte(_buf))"}
  [^Int _fd, ^Object _buf])

JOKER FUNC syscall.Readlink:
(defn Readlink
  "Go input arguments: (path string, buf []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^String path, ^(vector-of Byte) buf]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "readlink(_path, ConvertToArrayOfByte(_buf))"}
  [^String _path, ^Object _buf])

JOKER FUNC syscall.Reboot:
(defn ^"Error" Reboot
  "Go input arguments: (cmd int)\n\nGo return type: error\n\nJoker input arguments: [^Int cmd]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Reboot(_cmd)"}
  [^Int _cmd])

JOKER FUNC syscall.Recvfrom:
;; (defn Recvfrom
;;   "Go input arguments: (fd int, p []byte, flags int)\n\nGo return type: (n int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags]\n\nJoker return type: [Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "recvfrom(_fd, ConvertToArrayOfByte(_p), _flags)"}
;;   [^Int _fd, ^Object _p, ^Int _flags])

JOKER FUNC syscall.Recvmsg:
;; (defn Recvmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, flags int)\n\nGo return type: (n int, oobn int, recvflags int, from Sockaddr, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^Int flags]\n\nJoker return type: [Int Int Int ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/syscall/syscall_unix.go:205:15) Error]"
;;   {:added "1.0"
;;    :go "recvmsg(_fd, ConvertToArrayOfByte(_p), ConvertToArrayOfByte(_oob), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^Int _flags])

JOKER FUNC syscall.Removexattr:
(defn ^"Error" Removexattr
  "Go input arguments: (path string, attr string)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Removexattr(_path, _attr)"}
  [^String _path, ^String _attr])

JOKER FUNC syscall.Rename:
(defn ^"Error" Rename
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rename(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Renameat:
(defn ^"Error" Renameat
  "Go input arguments: (olddirfd int, oldpath string, newdirfd int, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^Int olddirfd, ^String oldpath, ^Int newdirfd, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Renameat(_olddirfd, _oldpath, _newdirfd, _newpath)"}
  [^Int _olddirfd, ^String _oldpath, ^Int _newdirfd, ^String _newpath])

JOKER FUNC syscall.Rmdir:
(defn ^"Error" Rmdir
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Rmdir(_path)"}
  [^String _path])

JOKER FUNC syscall.Seek:
(defn Seek
  "Go input arguments: (fd int, offset int64, whence int)\n\nGo return type: (off int, err error)\n\nJoker input arguments: [^Int fd, ^Int64 offset, ^Int whence]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "seek(_fd, _offset, _whence)"}
  [^Int _fd, ^Int64 _offset, ^Int _whence])

JOKER FUNC syscall.Select:
;; (defn Select
;;   "Go input arguments: (nfd int, r *syscall.FdSet, w *syscall.FdSet, e *syscall.FdSet, timeout *syscall.Timeval)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int nfd, ^(atom-of syscall.FdSet) r, ^(atom-of syscall.FdSet) w, ^(atom-of syscall.FdSet) e, ^(atom-of syscall.Timeval) timeout]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "select(_nfd, ConvertToIndirectOfsyscall.FdSet(ABEND904(custom-runtime routine not implemented: syscall.FdSet(_r))), ConvertToIndirectOfsyscall.FdSet(ABEND904(custom-runtime routine not implemented: syscall.FdSet(_w))), ConvertToIndirectOfsyscall.FdSet(ABEND904(custom-runtime routine not implemented: syscall.FdSet(_e))), ConvertToIndirectOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_timeout))))"}
;;   [^Int _nfd, ^Object _r, ^Object _w, ^Object _e, ^Object _timeout])

JOKER FUNC syscall.Sendfile:
;; (defn Sendfile
;;   "Go input arguments: (outfd int, infd int, offset *int64, count int)\n\nGo return type: (written int, err error)\n\nJoker input arguments: [^Int outfd, ^Int infd, ^(atom-of Int64) offset, ^Int count]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendfile(_outfd, _infd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_offset)), _count)"}
;;   [^Int _outfd, ^Int _infd, ^Object _offset, ^Int _count])

JOKER FUNC syscall.Sendmsg:
;; (defn ^"Error" Sendmsg
;;   "Go input arguments: (fd int, p []byte, oob []byte, to syscall.Sockaddr, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^syscall.Sockaddr to, ^Int flags]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendmsg(_fd, ConvertToArrayOfByte(_p), ConvertToArrayOfByte(_oob), ABEND904(custom-runtime routine not implemented: syscall.Sockaddr(_to)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^syscall.Sockaddr _to, ^Int _flags])

JOKER FUNC syscall.SendmsgN:
;; (defn SendmsgN
;;   "Go input arguments: (fd int, p []byte, oob []byte, to syscall.Sockaddr, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^(vector-of Byte) oob, ^syscall.Sockaddr to, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "sendmsgN(_fd, ConvertToArrayOfByte(_p), ConvertToArrayOfByte(_oob), ABEND904(custom-runtime routine not implemented: syscall.Sockaddr(_to)), _flags)"}
;;   [^Int _fd, ^Object _p, ^Object _oob, ^syscall.Sockaddr _to, ^Int _flags])

JOKER FUNC syscall.Sendto:
;; (defn ^"Error" Sendto
;;   "Go input arguments: (fd int, p []byte, flags int, to syscall.Sockaddr)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p, ^Int flags, ^syscall.Sockaddr to]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sendto(_fd, ConvertToArrayOfByte(_p), _flags, ABEND904(custom-runtime routine not implemented: syscall.Sockaddr(_to)))"}
;;   [^Int _fd, ^Object _p, ^Int _flags, ^syscall.Sockaddr _to])

JOKER FUNC syscall.SetLsfPromisc:
(defn ^"Error" SetLsfPromisc
  "Deprecated: Use golang.org/x/net/bpf instead.\n\nGo input arguments: (name string, m bool)\n\nGo return type: error\n\nJoker input arguments: [^String name, ^Bool m]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetLsfPromisc(_name, _m)"}
  [^String _name, ^Bool _m])

JOKER FUNC syscall.SetNonblock:
(defn ^"Error" SetNonblock
  "Go input arguments: (fd int, nonblocking bool)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Bool nonblocking]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetNonblock(_fd, _nonblocking)"}
  [^Int _fd, ^Bool _nonblocking])

JOKER FUNC syscall.Setdomainname:
(defn ^"Error" Setdomainname
  "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setdomainname(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC syscall.Setenv:
(defn ^"Error" Setenv
  "Go input arguments: (key string, value string)\n\nGo return type: error\n\nJoker input arguments: [^String key, ^String value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setenv(_key, _value)"}
  [^String _key, ^String _value])

JOKER FUNC syscall.Setfsgid:
(defn ^"Error" Setfsgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsgid(_gid)"}
  [^Int _gid])

JOKER FUNC syscall.Setfsuid:
(defn ^"Error" Setfsuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setfsuid(_uid)"}
  [^Int _uid])

JOKER FUNC syscall.Setgid:
(defn ^"Error" Setgid
  "Go input arguments: (gid int)\n\nGo return type: error\n\nJoker input arguments: [^Int gid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgid(_gid)"}
  [^Int _gid])

JOKER FUNC syscall.Setgroups:
(defn ^"Error" Setgroups
  "Go input arguments: (gids []int)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Int) gids]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setgroups(ConvertToArrayOfInt(_gids))"}
  [^Object _gids])

JOKER FUNC syscall.Sethostname:
(defn ^"Error" Sethostname
  "Go input arguments: (p []byte)\n\nGo return type: error\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Sethostname(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC syscall.Setpgid:
(defn ^"Error" Setpgid
  "Go input arguments: (pid int, pgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int pid, ^Int pgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpgid(_pid, _pgid)"}
  [^Int _pid, ^Int _pgid])

JOKER FUNC syscall.Setpriority:
(defn ^"Error" Setpriority
  "Go input arguments: (which int, who int, prio int)\n\nGo return type: error\n\nJoker input arguments: [^Int which, ^Int who, ^Int prio]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setpriority(_which, _who, _prio)"}
  [^Int _which, ^Int _who, ^Int _prio])

JOKER FUNC syscall.Setregid:
(defn ^"Error" Setregid
  "Go input arguments: (rgid int, egid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setregid(_rgid, _egid)"}
  [^Int _rgid, ^Int _egid])

JOKER FUNC syscall.Setresgid:
(defn ^"Error" Setresgid
  "Go input arguments: (rgid int, egid int, sgid int)\n\nGo return type: error\n\nJoker input arguments: [^Int rgid, ^Int egid, ^Int sgid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresgid(_rgid, _egid, _sgid)"}
  [^Int _rgid, ^Int _egid, ^Int _sgid])

JOKER FUNC syscall.Setresuid:
(defn ^"Error" Setresuid
  "Go input arguments: (ruid int, euid int, suid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid, ^Int suid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setresuid(_ruid, _euid, _suid)"}
  [^Int _ruid, ^Int _euid, ^Int _suid])

JOKER FUNC syscall.Setreuid:
(defn ^"Error" Setreuid
  "Go input arguments: (ruid int, euid int)\n\nGo return type: error\n\nJoker input arguments: [^Int ruid, ^Int euid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setreuid(_ruid, _euid)"}
  [^Int _ruid, ^Int _euid])

JOKER FUNC syscall.Setrlimit:
;; (defn ^"Error" Setrlimit
;;   "Go input arguments: (resource int, rlim *syscall.Rlimit)\n\nGo return type: error\n\nJoker input arguments: [^Int resource, ^(atom-of syscall.Rlimit) rlim]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Setrlimit(_resource, ConvertToIndirectOfsyscall.Rlimit(ABEND904(custom-runtime routine not implemented: syscall.Rlimit(_rlim))))"}
;;   [^Int _resource, ^Object _rlim])

JOKER FUNC syscall.Setsid:
(defn Setsid
  "Go return type: (pid int, err error)\n\nJoker input arguments: []\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "setsid()"}
  [])

JOKER FUNC syscall.SetsockoptByte:
(defn ^"Error" SetsockoptByte
  "Go input arguments: (fd int, level int, opt int, value byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Byte value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptByte(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Byte _value])

JOKER FUNC syscall.SetsockoptICMPv6Filter:
;; (defn ^"Error" SetsockoptICMPv6Filter
;;   "Go input arguments: (fd int, level int, opt int, filter *syscall.ICMPv6Filter)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.ICMPv6Filter) filter]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptICMPv6Filter(_fd, _level, _opt, ConvertToIndirectOfsyscall.ICMPv6Filter(ABEND904(custom-runtime routine not implemented: syscall.ICMPv6Filter(_filter))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _filter])

JOKER FUNC syscall.SetsockoptIPMreq:
;; (defn ^"Error" SetsockoptIPMreq
;;   "Go input arguments: (fd int, level int, opt int, mreq *syscall.IPMreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.IPMreq) mreq]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPMreq(_fd, _level, _opt, ConvertToIndirectOfsyscall.IPMreq(ABEND904(custom-runtime routine not implemented: syscall.IPMreq(_mreq))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _mreq])

JOKER FUNC syscall.SetsockoptIPMreqn:
;; (defn ^"Error" SetsockoptIPMreqn
;;   "Go input arguments: (fd int, level int, opt int, mreq *syscall.IPMreqn)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.IPMreqn) mreq]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPMreqn(_fd, _level, _opt, ConvertToIndirectOfsyscall.IPMreqn(ABEND904(custom-runtime routine not implemented: syscall.IPMreqn(_mreq))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _mreq])

JOKER FUNC syscall.SetsockoptIPv6Mreq:
;; (defn ^"Error" SetsockoptIPv6Mreq
;;   "Go input arguments: (fd int, level int, opt int, mreq *syscall.IPv6Mreq)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.IPv6Mreq) mreq]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptIPv6Mreq(_fd, _level, _opt, ConvertToIndirectOfsyscall.IPv6Mreq(ABEND904(custom-runtime routine not implemented: syscall.IPv6Mreq(_mreq))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _mreq])

JOKER FUNC syscall.SetsockoptInet4Addr:
;; (defn ^"Error" SetsockoptInet4Addr
;;   "Go input arguments: (fd int, level int, opt int, value []byte)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(vector-of Byte) value]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptInet4Addr(_fd, _level, _opt, ABEND901(specific-length arrays not supported: ConvertToArrayOfByte(_value)))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _value])

JOKER FUNC syscall.SetsockoptInt:
(defn ^"Error" SetsockoptInt
  "Go input arguments: (fd int, level int, opt int, value int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^Int value]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptInt(_fd, _level, _opt, _value)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^Int _value])

JOKER FUNC syscall.SetsockoptLinger:
;; (defn ^"Error" SetsockoptLinger
;;   "Go input arguments: (fd int, level int, opt int, l *syscall.Linger)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.Linger) l]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptLinger(_fd, _level, _opt, ConvertToIndirectOfsyscall.Linger(ABEND904(custom-runtime routine not implemented: syscall.Linger(_l))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _l])

JOKER FUNC syscall.SetsockoptString:
(defn ^"Error" SetsockoptString
  "Go input arguments: (fd int, level int, opt int, s string)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^String s]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SetsockoptString(_fd, _level, _opt, _s)"}
  [^Int _fd, ^Int _level, ^Int _opt, ^String _s])

JOKER FUNC syscall.SetsockoptTimeval:
;; (defn ^"Error" SetsockoptTimeval
;;   "Go input arguments: (fd int, level int, opt int, tv *syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int level, ^Int opt, ^(atom-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.SetsockoptTimeval(_fd, _level, _opt, ConvertToIndirectOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^Int _fd, ^Int _level, ^Int _opt, ^Object _tv])

JOKER FUNC syscall.Settimeofday:
;; (defn ^"Error" Settimeofday
;;   "Go input arguments: (tv *syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Settimeofday(ConvertToIndirectOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^Object _tv])

JOKER FUNC syscall.Setuid:
(defn ^"Error" Setuid
  "Go input arguments: (uid int)\n\nGo return type: error\n\nJoker input arguments: [^Int uid]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setuid(_uid)"}
  [^Int _uid])

JOKER FUNC syscall.Setxattr:
(defn ^"Error" Setxattr
  "Go input arguments: (path string, attr string, data []byte, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^String attr, ^(vector-of Byte) data, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Setxattr(_path, _attr, ConvertToArrayOfByte(_data), _flags)"}
  [^String _path, ^String _attr, ^Object _data, ^Int _flags])

JOKER FUNC syscall.Shutdown:
(defn ^"Error" Shutdown
  "Go input arguments: (fd int, how int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int how]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Shutdown(_fd, _how)"}
  [^Int _fd, ^Int _how])

JOKER FUNC syscall.SlicePtrFromStrings:
(defn SlicePtrFromStrings
  "SlicePtrFromStrings converts a slice of strings to a slice of\npointers to NUL-terminated byte arrays. If any string contains\na NUL byte, it returns (nil, EINVAL).\n\nGo input arguments: (ss []string)\n\nGo return type: ([]*int, error)\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "slicePtrFromStrings(ConvertToArrayOfString(_ss))"}
  [^Object _ss])

JOKER FUNC syscall.Socket:
(defn Socket
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "socket(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.Socketpair:
(defn Socketpair
  "Go input arguments: (domain int, typ int, proto int)\n\nGo return type: (fd []int, err error)\n\nJoker input arguments: [^Int domain, ^Int typ, ^Int proto]\n\nJoker return type: [(vector-of Int) Error]"
  {:added "1.0"
   :go "socketpair(_domain, _typ, _proto)"}
  [^Int _domain, ^Int _typ, ^Int _proto])

JOKER FUNC syscall.Splice:
;; (defn Splice
;;   "Go input arguments: (rfd int, roff *int64, wfd int, woff *int64, len int, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int rfd, ^(atom-of Int64) roff, ^Int wfd, ^(atom-of Int64) woff, ^Int len, ^Int flags]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "splice(_rfd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_roff)), _wfd, ABEND903(custom-runtime routine not implemented: ConvertToIndirectOfInt64(_woff)), _len, _flags)"}
;;   [^Int _rfd, ^Object _roff, ^Int _wfd, ^Object _woff, ^Int _len, ^Int _flags])

JOKER FUNC syscall.StartProcess:
;; (defn StartProcess
;;   "StartProcess wraps ForkExec for package os.\n\nGo input arguments: (argv0 string, argv []string, attr *syscall.ProcAttr)\n\nGo return type: (pid int, handle ..., err error)\n\nJoker input arguments: [^String argv0, ^(vector-of String) argv, ^(atom-of syscall.ProcAttr) attr]\n\nJoker return type: [Int ABEND043(unsupported built-in type uintptr) Error]"
;;   {:added "1.0"
;;    :go "startProcess(_argv0, ConvertToArrayOfString(_argv), ConvertToIndirectOfsyscall.ProcAttr(ABEND904(custom-runtime routine not implemented: syscall.ProcAttr(_attr))))"}
;;   [^String _argv0, ^Object _argv, ^Object _attr])

JOKER FUNC syscall.Stat:
;; (defn ^"Error" Stat
;;   "Go input arguments: (path string, stat *syscall.Stat_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of syscall.Stat_t) stat]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Stat(_path, ConvertToIndirectOfsyscall.Stat_t(ABEND904(custom-runtime routine not implemented: syscall.Stat_t(_stat))))"}
;;   [^String _path, ^Object _stat])

JOKER FUNC syscall.Statfs:
;; (defn ^"Error" Statfs
;;   "Go input arguments: (path string, buf *syscall.Statfs_t)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of syscall.Statfs_t) buf]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Statfs(_path, ConvertToIndirectOfsyscall.Statfs_t(ABEND904(custom-runtime routine not implemented: syscall.Statfs_t(_buf))))"}
;;   [^String _path, ^Object _buf])

JOKER FUNC syscall.StringBytePtr:
;; (defn ^"Int" StringBytePtr
;;   "StringBytePtr returns a pointer to a NUL-terminated array of bytes.\nIf s contains a NUL byte this function panics instead of returning\nan error.\n\nDeprecated: Use BytePtrFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: *int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: syscall.StringBytePtr(_s))"}
;;   [^String _s])

JOKER FUNC syscall.StringByteSlice:
(defn StringByteSlice
  "StringByteSlice converts a string to a NUL-terminated []byte,\nIf s contains a NUL byte this function panics instead of\nreturning an error.\n\nDeprecated: Use ByteSliceFromString instead.\n\nGo input arguments: (s string)\n\nGo return type: []int\n\nJoker input arguments: [^String s]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "stringByteSlice(_s)"}
  [^String _s])

JOKER FUNC syscall.StringSlicePtr:
(defn StringSlicePtr
  "StringSlicePtr converts a slice of strings to a slice of pointers\nto NUL-terminated byte arrays. If any string contains a NUL byte\nthis function panics instead of returning an error.\n\nDeprecated: Use SlicePtrFromStrings instead.\n\nGo input arguments: (ss []string)\n\nGo return type: []*int\n\nJoker input arguments: [^(vector-of String) ss]\n\nJoker return type: (vector-of Int)"
  {:added "1.0"
   :go "stringSlicePtr(ConvertToArrayOfString(_ss))"}
  [^Object _ss])

JOKER FUNC syscall.Symlink:
(defn ^"Error" Symlink
  "Go input arguments: (oldpath string, newpath string)\n\nGo return type: error\n\nJoker input arguments: [^String oldpath, ^String newpath]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Symlink(_oldpath, _newpath)"}
  [^String _oldpath, ^String _newpath])

JOKER FUNC syscall.Sync:
;; (defn Sync
;;   "Joker input arguments: []"
;;   {:added "1.0"
;;    :go "sync()"}
;;   [])

JOKER FUNC syscall.SyncFileRange:
(defn ^"Error" SyncFileRange
  "Go input arguments: (fd int, off int64, n int64, flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int fd, ^Int64 off, ^Int64 n, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.SyncFileRange(_fd, _off, _n, _flags)"}
  [^Int _fd, ^Int64 _off, ^Int64 _n, ^Int _flags])

JOKER FUNC syscall.Syscall:
;; (defn Syscall
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr)]"
;;   {:added "1.0"
;;    :go "syscall(_trap, _a1, _a2, _a3)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3])

JOKER FUNC syscall.Syscall6:
;; (defn Syscall6
;;   "Go input arguments: (trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr)\n\nGo return type: (r1 ..., r2 ..., err Errno)\n\nJoker input arguments: [^uintptr trap, ^uintptr a1, ^uintptr a2, ^uintptr a3, ^uintptr a4, ^uintptr a5, ^uintptr a6]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr) ABEND043(unsupported built-in type uintptr)]"
;;   {:added "1.0"
;;    :go "syscall6(_trap, _a1, _a2, _a3, _a4, _a5, _a6)"}
;;   [^ABEND044(unsupported built-in type uintptr) _trap, ^ABEND044(unsupported built-in type uintptr) _a1, ^ABEND044(unsupported built-in type uintptr) _a2, ^ABEND044(unsupported built-in type uintptr) _a3, ^ABEND044(unsupported built-in type uintptr) _a4, ^ABEND044(unsupported built-in type uintptr) _a5, ^ABEND044(unsupported built-in type uintptr) _a6])

JOKER FUNC syscall.Sysinfo:
;; (defn ^"Error" Sysinfo
;;   "Go input arguments: (info *syscall.Sysinfo_t)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of syscall.Sysinfo_t) info]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Sysinfo(ConvertToIndirectOfsyscall.Sysinfo_t(ABEND904(custom-runtime routine not implemented: syscall.Sysinfo_t(_info))))"}
;;   [^Object _info])

JOKER FUNC syscall.Tee:
(defn Tee
  "Go input arguments: (rfd int, wfd int, len int, flags int)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int rfd, ^Int wfd, ^Int len, ^Int flags]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "tee(_rfd, _wfd, _len, _flags)"}
  [^Int _rfd, ^Int _wfd, ^Int _len, ^Int _flags])

JOKER FUNC syscall.Tgkill:
;; (defn ^"Error" Tgkill
;;   "Go input arguments: (tgid int, tid int, sig syscall.Signal)\n\nGo return type: error\n\nJoker input arguments: [^Int tgid, ^Int tid, ^syscall.Signal sig]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Tgkill(_tgid, _tid, ABEND904(custom-runtime routine not implemented: syscall.Signal(_sig)))"}
;;   [^Int _tgid, ^Int _tid, ^syscall.Signal _sig])

JOKER FUNC syscall.Time:
;; (defn Time
;;   "Go input arguments: (t *syscall.Time_t)\n\nGo return type: (tt Time_t, err error)\n\nJoker input arguments: [^(atom-of syscall.Time_t) t]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "time(ConvertToIndirectOfsyscall.Time_t(ABEND904(custom-runtime routine not implemented: syscall.Time_t(_t))))"}
;;   [^Object _t])

JOKER FUNC syscall.Times:
;; (defn Times
;;   "Go input arguments: (tms *syscall.Tms)\n\nGo return type: (ticks ..., err error)\n\nJoker input arguments: [^(atom-of syscall.Tms) tms]\n\nJoker return type: [ABEND043(unsupported built-in type uintptr) Error]"
;;   {:added "1.0"
;;    :go "times(ConvertToIndirectOfsyscall.Tms(ABEND904(custom-runtime routine not implemented: syscall.Tms(_tms))))"}
;;   [^Object _tms])

JOKER FUNC syscall.TimespecToNsec:
;; (defn ^"Int" TimespecToNsec
;;   "TimespecToNsec converts a Timespec value into a number of\nnanoseconds since the Unix epoch.\n\nGo input arguments: (ts syscall.Timespec)\n\nGo return type: int\n\nJoker input arguments: [^syscall.Timespec ts]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(syscall.TimespecToNsec(ABEND904(custom-runtime routine not implemented: syscall.Timespec(_ts))))"}
;;   [^syscall.Timespec _ts])

JOKER FUNC syscall.TimevalToNsec:
;; (defn ^"Int" TimevalToNsec
;;   "TimevalToNsec converts a Timeval value into a number of nanoseconds\nsince the Unix epoch.\n\nGo input arguments: (tv syscall.Timeval)\n\nGo return type: int\n\nJoker input arguments: [^syscall.Timeval tv]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(syscall.TimevalToNsec(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^syscall.Timeval _tv])

JOKER FUNC syscall.Truncate:
(defn ^"Error" Truncate
  "Go input arguments: (path string, length int64)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^Int64 length]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Truncate(_path, _length)"}
  [^String _path, ^Int64 _length])

JOKER FUNC syscall.Umask:
(defn ^"Int" Umask
  "Go input arguments: (mask int)\n\nGo return type: int\n\nJoker input arguments: [^Int mask]\n\nJoker return type: Int"
  {:added "1.0"
   :go "syscall.Umask(_mask)"}
  [^Int _mask])

JOKER FUNC syscall.Uname:
;; (defn ^"Error" Uname
;;   "Go input arguments: (buf *syscall.Utsname)\n\nGo return type: error\n\nJoker input arguments: [^(atom-of syscall.Utsname) buf]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Uname(ConvertToIndirectOfsyscall.Utsname(ABEND904(custom-runtime routine not implemented: syscall.Utsname(_buf))))"}
;;   [^Object _buf])

JOKER FUNC syscall.UnixCredentials:
;; (defn UnixCredentials
;;   "UnixCredentials encodes credentials into a socket control message\nfor sending to another process. This can be used for\nauthentication.\n\nGo input arguments: (ucred *syscall.Ucred)\n\nGo return type: []int\n\nJoker input arguments: [^(atom-of syscall.Ucred) ucred]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "unixCredentials(ConvertToIndirectOfsyscall.Ucred(ABEND904(custom-runtime routine not implemented: syscall.Ucred(_ucred))))"}
;;   [^Object _ucred])

JOKER FUNC syscall.UnixRights:
;; (defn UnixRights
;;   "UnixRights encodes a set of open file descriptors into a socket\ncontrol message for sending to another process.\n\nGo input arguments: (fds ...int)\n\nGo return type: []int\n\nJoker input arguments: [^(ellipsis-somehow Int) fds]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "unixRights(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaInt(_fds)))"}
;;   [^Int _fds])

JOKER FUNC syscall.Unlink:
(defn ^"Error" Unlink
  "Go input arguments: (path string)\n\nGo return type: error\n\nJoker input arguments: [^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlink(_path)"}
  [^String _path])

JOKER FUNC syscall.Unlinkat:
(defn ^"Error" Unlinkat
  "Go input arguments: (dirfd int, path string)\n\nGo return type: error\n\nJoker input arguments: [^Int dirfd, ^String path]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unlinkat(_dirfd, _path)"}
  [^Int _dirfd, ^String _path])

JOKER FUNC syscall.Unmount:
(defn ^"Error" Unmount
  "Go input arguments: (target string, flags int)\n\nGo return type: error\n\nJoker input arguments: [^String target, ^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unmount(_target, _flags)"}
  [^String _target, ^Int _flags])

JOKER FUNC syscall.Unsetenv:
(defn ^"Error" Unsetenv
  "Go input arguments: (key string)\n\nGo return type: error\n\nJoker input arguments: [^String key]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unsetenv(_key)"}
  [^String _key])

JOKER FUNC syscall.Unshare:
(defn ^"Error" Unshare
  "Go input arguments: (flags int)\n\nGo return type: error\n\nJoker input arguments: [^Int flags]\n\nJoker return type: Error"
  {:added "1.0"
   :go "syscall.Unshare(_flags)"}
  [^Int _flags])

JOKER FUNC syscall.Ustat:
;; (defn ^"Error" Ustat
;;   "Go input arguments: (dev int, ubuf *syscall.Ustat_t)\n\nGo return type: error\n\nJoker input arguments: [^Int dev, ^(atom-of syscall.Ustat_t) ubuf]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Ustat(_dev, ConvertToIndirectOfsyscall.Ustat_t(ABEND904(custom-runtime routine not implemented: syscall.Ustat_t(_ubuf))))"}
;;   [^Int _dev, ^Object _ubuf])

JOKER FUNC syscall.Utime:
;; (defn ^"Error" Utime
;;   "Go input arguments: (path string, buf *syscall.Utimbuf)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(atom-of syscall.Utimbuf) buf]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utime(_path, ConvertToIndirectOfsyscall.Utimbuf(ABEND904(custom-runtime routine not implemented: syscall.Utimbuf(_buf))))"}
;;   [^String _path, ^Object _buf])

JOKER FUNC syscall.Utimes:
;; (defn ^"Error" Utimes
;;   "Go input arguments: (path string, tv []syscall.Timeval)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of syscall.Timeval) tv]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.Utimes(_path, ConvertToArrayOfsyscall.Timeval(ABEND904(custom-runtime routine not implemented: syscall.Timeval(_tv))))"}
;;   [^String _path, ^Object _tv])

JOKER FUNC syscall.UtimesNano:
;; (defn ^"Error" UtimesNano
;;   "Go input arguments: (path string, ts []syscall.Timespec)\n\nGo return type: error\n\nJoker input arguments: [^String path, ^(vector-of syscall.Timespec) ts]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "syscall.UtimesNano(_path, ConvertToArrayOfsyscall.Timespec(ABEND904(custom-runtime routine not implemented: syscall.Timespec(_ts))))"}
;;   [^String _path, ^Object _ts])

JOKER FUNC syscall.Wait4:
;; (defn Wait4
;;   "Go input arguments: (pid int, wstatus *syscall.WaitStatus, options int, rusage *syscall.Rusage)\n\nGo return type: (wpid int, err error)\n\nJoker input arguments: [^Int pid, ^(atom-of syscall.WaitStatus) wstatus, ^Int options, ^(atom-of syscall.Rusage) rusage]\n\nJoker return type: [Int Error]"
;;   {:added "1.0"
;;    :go "wait4(_pid, ConvertToIndirectOfsyscall.WaitStatus(ABEND904(custom-runtime routine not implemented: syscall.WaitStatus(_wstatus))), _options, ConvertToIndirectOfsyscall.Rusage(ABEND904(custom-runtime routine not implemented: syscall.Rusage(_rusage))))"}
;;   [^Int _pid, ^Object _wstatus, ^Int _options, ^Object _rusage])

JOKER FUNC syscall.Write:
(defn Write
  "Go input arguments: (fd int, p []byte)\n\nGo return type: (n int, err error)\n\nJoker input arguments: [^Int fd, ^(vector-of Byte) p]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "write(_fd, ConvertToArrayOfByte(_p))"}
  [^Int _fd, ^Object _p])

JOKER FUNC testing.AllocsPerRun:
;; (defn AllocsPerRun
;;   "AllocsPerRun returns the average number of allocations during calls to f.\nAlthough the return value has type float64, it will always be an integral value.\n\nTo compute the number of allocations, the function will first be run once as\na warm-up. The average number of allocations over the specified number of\nruns will then be measured and returned.\n\nAllocsPerRun sets GOMAXPROCS to 1 during its measurement and will restore\nit before returning.\n\nGo input arguments: (runs int, f func)\n\nGo return type: ...\n\nJoker input arguments: [^Int runs, ^fn f]\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "allocsPerRun(_runs, ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^Int _runs, ^fn _f])

JOKER FUNC testing.Benchmark:
;; (defn Benchmark
;;   "Benchmark benchmarks a single function. Useful for creating\ncustom benchmarks that do not use the \"go test\" command.\n\nIf f calls Run, the result will be an estimate of running all its\nsubbenchmarks that don't call Run in sequence in a single benchmark.\n\nGo input arguments: (f func)\n\nGo return type: BenchmarkResult\n\nJoker input arguments: [^fn f]\n\nJoker return type: {:N ^Int, :T ^Int, :Bytes ^Int, :MemAllocs ^ABEND043(unsupported built-in type uint64), :MemBytes ^ABEND043(unsupported built-in type uint64)}"
;;   {:added "1.0"
;;    :go "benchmark(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()))"}
;;   [^fn _f])

JOKER FUNC testing.CoverMode:
(defn ^"String" CoverMode
  "CoverMode reports what the test coverage mode is set to. The\nvalues are \"set\", \"count\", or \"atomic\". The return value will be\nempty if test coverage is not enabled.\n\nGo return type: string\n\nJoker input arguments: []\n\nJoker return type: String"
  {:added "1.0"
   :go "testing.CoverMode()"}
  [])

JOKER FUNC testing.Coverage:
;; (defn Coverage
;;   "Coverage reports the current code coverage as a fraction in the range [0, 1].\nIf coverage is not enabled, Coverage returns 0.\n\nWhen running a large set of sequential test cases, checking Coverage after each one\ncan be useful for identifying which test cases exercise new code paths.\nIt is not a replacement for the reports generated by 'go test -cover' and\n'go tool cover'.\n\nGo return type: ...\n\nJoker input arguments: []\n\nJoker return type: ABEND043(unsupported built-in type float64)"
;;   {:added "1.0"
;;    :go "coverage()"}
;;   [])

JOKER FUNC testing.Main:
;; (defn Main
;;   "Main is an internal function, part of the implementation of the \"go test\" command.\nIt was exported because it is cross-package and predates \"internal\" packages.\nIt is no longer used by \"go test\" but preserved, as much as possible, for other\nsystems that simulate \"go test\" using Main, but Main sometimes cannot be updated as\nnew functionality is added to the testing package.\nSystems simulating \"go test\" should be updated to use MainStart.\n\nGo input arguments: (matchString func, tests []testing.InternalTest, benchmarks []testing.InternalBenchmark, examples []testing.InternalExample)\n\nJoker input arguments: [^fn matchString, ^(vector-of testing.InternalTest) tests, ^(vector-of testing.InternalBenchmark) benchmarks, ^(vector-of testing.InternalExample) examples]"
;;   {:added "1.0"
;;    :go "main(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOftesting.InternalTest(ABEND904(custom-runtime routine not implemented: testing.InternalTest(_tests))), ConvertToArrayOftesting.InternalBenchmark(ABEND904(custom-runtime routine not implemented: testing.InternalBenchmark(_benchmarks))), ConvertToArrayOftesting.InternalExample(ABEND904(custom-runtime routine not implemented: testing.InternalExample(_examples))))"}
;;   [^fn _matchString, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.MainStart:
;; (defn MainStart
;;   "MainStart is meant for use by tests generated by 'go test'.\nIt is not meant to be called directly and is not subject to the Go 1 compatibility document.\nIt may change signature from release to release.\n\nGo input arguments: (deps testDeps, tests []testing.InternalTest, benchmarks []testing.InternalBenchmark, examples []testing.InternalExample)\n\nGo return type: *M\n\nJoker input arguments: [^testDeps deps, ^(vector-of testing.InternalTest) tests, ^(vector-of testing.InternalBenchmark) benchmarks, ^(vector-of testing.InternalExample) examples]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: mainStart(_deps, ConvertToArrayOftesting.InternalTest(ABEND904(custom-runtime routine not implemented: testing.InternalTest(_tests))), ConvertToArrayOftesting.InternalBenchmark(ABEND904(custom-runtime routine not implemented: testing.InternalBenchmark(_benchmarks))), ConvertToArrayOftesting.InternalExample(ABEND904(custom-runtime routine not implemented: testing.InternalExample(_examples)))))"}
;;   [^ABEND044(unsupported built-in type testDeps) _deps, ^Object _tests, ^Object _benchmarks, ^Object _examples])

JOKER FUNC testing.RegisterCover:
;; (defn RegisterCover
;;   "RegisterCover records the coverage data accumulators for the tests.\nNOTE: This function is internal to the testing infrastructure and may change.\nIt is not covered (yet) by the Go 1 compatibility guidelines.\n\nGo input arguments: (c testing.Cover)\n\nJoker input arguments: [^testing.Cover c]"
;;   {:added "1.0"
;;    :go "registerCover(ABEND904(custom-runtime routine not implemented: testing.Cover(_c)))"}
;;   [^testing.Cover _c])

JOKER FUNC testing.RunBenchmarks:
;; (defn RunBenchmarks
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, benchmarks []testing.InternalBenchmark)\n\nJoker input arguments: [^fn matchString, ^(vector-of testing.InternalBenchmark) benchmarks]"
;;   {:added "1.0"
;;    :go "runBenchmarks(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOftesting.InternalBenchmark(ABEND904(custom-runtime routine not implemented: testing.InternalBenchmark(_benchmarks))))"}
;;   [^fn _matchString, ^Object _benchmarks])

JOKER FUNC testing.RunExamples:
;; (defn ^"Bool" RunExamples
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, examples []testing.InternalExample)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of testing.InternalExample) examples]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunExamples(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOftesting.InternalExample(ABEND904(custom-runtime routine not implemented: testing.InternalExample(_examples))))"}
;;   [^fn _matchString, ^Object _examples])

JOKER FUNC testing.RunTests:
;; (defn ^"Bool" RunTests
;;   "An internal function but exported because it is cross-package; part of the implementation\nof the \"go test\" command.\n\nGo input arguments: (matchString func, tests []testing.InternalTest)\n\nGo return type: bool\n\nJoker input arguments: [^fn matchString, ^(vector-of testing.InternalTest) tests]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "testing.RunTests(ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa()), ConvertToArrayOftesting.InternalTest(ABEND904(custom-runtime routine not implemented: testing.InternalTest(_tests))))"}
;;   [^fn _matchString, ^Object _tests])

JOKER FUNC testing.Short:
(defn ^"Bool" Short
  "Short reports whether the -test.short flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Short()"}
  [])

JOKER FUNC testing.Verbose:
(defn ^"Bool" Verbose
  "Verbose reports whether the -test.v flag is set.\n\nGo return type: bool\n\nJoker input arguments: []\n\nJoker return type: Bool"
  {:added "1.0"
   :go "testing.Verbose()"}
  [])

JOKER FUNC testing/iotest.DataErrReader:
;; (defn DataErrReader
;;   "DataErrReader changes the way errors are handled by a Reader. Normally, a\nReader returns an error (typically EOF) from the first Read call after the\nlast piece of data is read. DataErrReader wraps a Reader and changes its\nbehavior so the final error is returned along with the final data, instead\nof in the first call after the final data.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "dataErrReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC testing/iotest.HalfReader:
;; (defn HalfReader
;;   "HalfReader returns a Reader that implements Read\nby reading half as many requested bytes from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "halfReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC testing/iotest.NewReadLogger:
;; (defn NewReadLogger
;;   "NewReadLogger returns a reader that behaves like r except\nthat it logs (using log.Printf) each read to standard error,\nprinting the prefix and the hexadecimal data read.\n\nGo input arguments: (prefix string, r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^String prefix, ^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "newReadLogger(_prefix, ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^String _prefix, ^io.Reader _r])

JOKER FUNC testing/iotest.NewWriteLogger:
;; (defn NewWriteLogger
;;   "NewWriteLogger returns a writer that behaves like w except\nthat it logs (using log.Printf) each write to standard error,\nprinting the prefix and the hexadecimal data written.\n\nGo input arguments: (prefix string, w io.Writer)\n\nGo return type: ...\n\nJoker input arguments: [^String prefix, ^io.Writer w]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "newWriteLogger(_prefix, ABEND904(custom-runtime routine not implemented: io.Writer(_w)))"}
;;   [^String _prefix, ^io.Writer _w])

JOKER FUNC testing/iotest.OneByteReader:
;; (defn OneByteReader
;;   "OneByteReader returns a Reader that implements\neach non-empty Read by reading one byte from r.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "oneByteReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC testing/iotest.TimeoutReader:
;; (defn TimeoutReader
;;   "TimeoutReader returns ErrTimeout on the second read\nwith no data. Subsequent calls to read succeed.\n\nGo input arguments: (r io.Reader)\n\nGo return type: ...\n\nJoker input arguments: [^io.Reader r]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:77:13)"
;;   {:added "1.0"
;;    :go "timeoutReader(ABEND904(custom-runtime routine not implemented: io.Reader(_r)))"}
;;   [^io.Reader _r])

JOKER FUNC testing/iotest.TruncateWriter:
;; (defn TruncateWriter
;;   "TruncateWriter returns a Writer that writes to w\nbut stops silently after n bytes.\n\nGo input arguments: (w io.Writer, n int64)\n\nGo return type: ...\n\nJoker input arguments: [^io.Writer w, ^Int64 n]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/io/io.go:90:13)"
;;   {:added "1.0"
;;    :go "truncateWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), _n)"}
;;   [^io.Writer _w, ^Int64 _n])

JOKER FUNC testing/quick.Check:
;; (defn ^"Error" Check
;;   "Check looks for an input to f, any function that returns bool,\nsuch that f returns false. It calls f repeatedly, with arbitrary\nvalues for each argument. If f returns false on a given input,\nCheck returns that input as a *CheckError.\nFor example:\n\n\tfunc TestOddMultipleOfThree(t *testing.T) {\n\t\tf := func(x int) bool {\n\t\t\ty := OddMultipleOfThree(x)\n\t\t\treturn y%2 == 1 && y%3 == 0\n\t\t}\n\t\tif err := quick.Check(f, nil); err != nil {\n\t\t\tt.Error(err)\n\t\t}\n\t}\n\nGo input arguments: (f interface {}, config *testing/quick.Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^(atom-of testing/quick.Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.Check(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ConvertToIndirectOftesting/quick.Config(ABEND904(custom-runtime routine not implemented: testing/quick.Config(_config))))"}
;;   [^<protocol-or-something> _f, ^Object _config])

JOKER FUNC testing/quick.CheckEqual:
;; (defn ^"Error" CheckEqual
;;   "CheckEqual looks for an input on which f and g return different results.\nIt calls f and g repeatedly with arbitrary values for each argument.\nIf f and g return different answers, CheckEqual returns a *CheckEqualError\ndescribing the input and the outputs.\n\nGo input arguments: (f interface {}, g interface {}, config *testing/quick.Config)\n\nGo return type: error\n\nJoker input arguments: [^<protocol-or-something> f, ^<protocol-or-something> g, ^(atom-of testing/quick.Config) config]\n\nJoker return type: Error"
;;   {:added "1.0"
;;    :go "quick.CheckEqual(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()), ConvertToIndirectOftesting/quick.Config(ABEND904(custom-runtime routine not implemented: testing/quick.Config(_config))))"}
;;   [^<protocol-or-something> _f, ^<protocol-or-something> _g, ^Object _config])

JOKER FUNC testing/quick.Value:
;; (defn Value
;;   "Value returns an arbitrary value of the given type.\nIf the type implements the Generator interface, that will be used.\nNote: To create arbitrary values for structs, all the fields must be exported.\n\nGo input arguments: (t reflect.Type, rand *math/rand.Rand)\n\nGo return type: (value struct {}, ok bool)\n\nJoker input arguments: [^reflect.Type t, ^(atom-of math/rand.Rand) rand]\n\nJoker return type: [{} Bool]"
;;   {:added "1.0"
;;    :go "value(ABEND904(custom-runtime routine not implemented: reflect.Type(_t)), ConvertToIndirectOfmath/rand.Rand(ABEND904(custom-runtime routine not implemented: math/rand.Rand(_rand))))"}
;;   [^reflect.Type _t, ^Object _rand])

JOKER FUNC text/scanner.TokenString:
;; (defn ^"String" TokenString
;;   "TokenString returns a printable string for a token or Unicode character.\n\nGo input arguments: (tok rune)\n\nGo return type: string\n\nJoker input arguments: [^rune tok]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "scanner.TokenString(_tok)"}
;;   [^ABEND044(unsupported built-in type rune) _tok])

JOKER FUNC text/tabwriter.NewWriter:
;; (defn NewWriter
;;   "NewWriter allocates and initializes a new tabwriter.Writer.\nThe parameters are the same as for the Init function.\n\nGo input arguments: (output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint)\n\nGo return type: *Writer\n\nJoker input arguments: [^io.Writer output, ^Int minwidth, ^Int tabwidth, ^Int padding, ^Byte padchar, ^UInt flags]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newWriter(ABEND904(custom-runtime routine not implemented: io.Writer(_output)), _minwidth, _tabwidth, _padding, _padchar, _flags))"}
;;   [^io.Writer _output, ^Int _minwidth, ^Int _tabwidth, ^Int _padding, ^Byte _padchar, ^UInt _flags])

JOKER FUNC text/template.HTMLEscape:
;; (defn HTMLEscape
;;   "HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "hTMLEscape(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_b))"}
;;   [^io.Writer _w, ^Object _b])

JOKER FUNC text/template.HTMLEscapeString:
(defn ^"String" HTMLEscapeString
  "HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.HTMLEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.HTMLEscaper:
;; (defn ^"String" HTMLEscaper
;;   "HTMLEscaper returns the escaped HTML equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.HTMLEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.IsTrue:
;; (defn IsTrue
;;   "IsTrue reports whether the value is 'true', in the sense of not the zero of its type,\nand whether the value has a meaningful truth value. This is the definition of\ntruth used by if and other such actions.\n\nGo input arguments: (val interface {})\n\nGo return type: (truth bool, ok bool)\n\nJoker input arguments: [^<protocol-or-something> val]\n\nJoker return type: [Bool Bool]"
;;   {:added "1.0"
;;    :go "isTrue(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa()))"}
;;   [^<protocol-or-something> _val])

JOKER FUNC text/template.JSEscape:
;; (defn JSEscape
;;   "JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.\n\nGo input arguments: (w io.Writer, b []byte)\n\nJoker input arguments: [^io.Writer w, ^(vector-of Byte) b]"
;;   {:added "1.0"
;;    :go "jSEscape(ABEND904(custom-runtime routine not implemented: io.Writer(_w)), ConvertToArrayOfByte(_b))"}
;;   [^io.Writer _w, ^Object _b])

JOKER FUNC text/template.JSEscapeString:
(defn ^"String" JSEscapeString
  "JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.\n\nGo input arguments: (s string)\n\nGo return type: string\n\nJoker input arguments: [^String s]\n\nJoker return type: String"
  {:added "1.0"
   :go "template.JSEscapeString(_s)"}
  [^String _s])

JOKER FUNC text/template.JSEscaper:
;; (defn ^"String" JSEscaper
;;   "JSEscaper returns the escaped JavaScript equivalent of the textual\nrepresentation of its arguments.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.JSEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template.Must:
;; (defn Must
;;   "Must is a helper that wraps a call to a function returning (*Template, error)\nand panics if the error is non-nil. It is intended for use in variable\ninitializations such as\n\tvar t = template.Must(template.New(\"name\").Parse(\"text\"))\n\nGo input arguments: (t *text/template.Template, err error)\n\nGo return type: *Template\n\nJoker input arguments: [^(atom-of text/template.Template) t, ^ABEND885(unrecognized type error at: GO.link/src/text/template/helper.go:21:28) err]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: must(ConvertToIndirectOftext/template.Template(ABEND904(custom-runtime routine not implemented: text/template.Template(_t))), _err))"}
;;   [^Object _t, ^ABEND885(unrecognized type error at: GO.link/src/text/template/helper.go:21:28) _err])

JOKER FUNC text/template.New:
;; (defn New
;;   "New allocates a new, undefined template with the given name.\n\nGo input arguments: (name string)\n\nGo return type: *Template\n\nJoker input arguments: [^String name]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(_name))"}
;;   [^String _name])

JOKER FUNC text/template.ParseFiles:
;; (defn ParseFiles
;;   "ParseFiles creates a new Template and parses the template definitions from\nthe named files. The returned template's name will have the base name and\nparsed contents of the first file. There must be at least one file.\nIf an error occurs, parsing stops and the returned *Template is nil.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\nFor instance, ParseFiles(\"a/foo\", \"b/foo\") stores \"b/foo\" as the template\nnamed \"foo\", while \"a/foo\" is unavailable.\n\nGo input arguments: (filenames ...string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^(ellipsis-somehow String) filenames]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "parseFiles(ABEND905(custom-runtime routine not implemented: ConvertToEllipsisHaHaString(_filenames)))"}
;;   [^String _filenames])

JOKER FUNC text/template.ParseGlob:
(defn ParseGlob
  "ParseGlob creates a new Template and parses the template definitions from the\nfiles identified by the pattern, which must match at least one file. The\nreturned template will have the (base) name and (parsed) contents of the\nfirst file matched by the pattern. ParseGlob is equivalent to calling\nParseFiles with the list of files matched by the pattern.\n\nWhen parsing multiple files with the same name in different directories,\nthe last one mentioned will be the one that results.\n\nGo input arguments: (pattern string)\n\nGo return type: (*Template, error)\n\nJoker input arguments: [^String pattern]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parseGlob(_pattern)"}
  [^String _pattern])

JOKER FUNC text/template.URLQueryEscaper:
;; (defn ^"String" URLQueryEscaper
;;   "URLQueryEscaper returns the escaped value of the textual representation of\nits arguments in a form suitable for embedding in a URL query.\n\nGo input arguments: (args ...interface {})\n\nGo return type: string\n\nJoker input arguments: [^(ellipsis-somehow <protocol-or-something>) args]\n\nJoker return type: String"
;;   {:added "1.0"
;;    :go "template.URLQueryEscaper(ConvertToEllipsisHaHa<protocol-or-something>(ABEND907(custom-runtime routine not implemented: ConvertToInterfaceTypeHaHa())))"}
;;   [^<protocol-or-something> _args])

JOKER FUNC text/template/parse.IsEmptyTree:
;; (defn ^"Bool" IsEmptyTree
;;   "IsEmptyTree reports whether this tree (node) is empty of everything but space.\n\nGo input arguments: (n text/template/parse.Node)\n\nGo return type: bool\n\nJoker input arguments: [^text/template/parse.Node n]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "parse.IsEmptyTree(ABEND904(custom-runtime routine not implemented: text/template/parse.Node(_n)))"}
;;   [^text/template/parse.Node _n])

JOKER FUNC text/template/parse.New:
;; (defn New
;;   "New allocates a new parse tree with the given name.\n\nGo input arguments: (name string, funcs ...map[])\n\nGo return type: *Tree\n\nJoker input arguments: [^String name, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: {:Name ^String, :ParseName ^String, :Root ^{:Nodes ^(vector-of ABEND883(unrecognized Expr type *ast.InterfaceType at: GO.link/src/text/template/parse/node.go:21:11))}}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: new(_name, ConvertToEllipsisHaHa{}(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa()))))"}
;;   [^String _name, ^{} _funcs])

JOKER FUNC text/template/parse.NewIdentifier:
;; (defn NewIdentifier
;;   "NewIdentifier returns a new IdentifierNode with the given identifier name.\n\nGo input arguments: (ident string)\n\nGo return type: *IdentifierNode\n\nJoker input arguments: [^String ident]\n\nJoker return type: {:Ident ^String}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newIdentifier(_ident))"}
;;   [^String _ident])

JOKER FUNC text/template/parse.Parse:
;; (defn Parse
;;   "Parse returns a map from template name to parse.Tree, created by parsing the\ntemplates described in the argument string. The top-level template will be\ngiven the specified name. If an error is encountered, parsing stops and an\nempty map is returned with the error.\n\nGo input arguments: (name string, text string, leftDelim string, rightDelim string, funcs ...map[])\n\nGo return type: (..., error)\n\nJoker input arguments: [^String name, ^String text, ^String leftDelim, ^String rightDelim, ^(ellipsis-somehow {}) funcs]\n\nJoker return type: [ABEND883(unrecognized Expr type *ast.MapType at: GO.link/src/text/template/parse/parse.go:51:88) Error]"
;;   {:added "1.0"
;;    :go "parse(_name, _text, _leftDelim, _rightDelim, ConvertToEllipsisHaHa{}(ABEND908(custom-runtime routine not implemented: ConvertToMapTypeHaHa())))"}
;;   [^String _name, ^String _text, ^String _leftDelim, ^String _rightDelim, ^{} _funcs])

JOKER FUNC time.After:
;; (defn After
;;   "After waits for the duration to elapse and then sends the current time\non the returned channel.\nIt is equivalent to NewTimer(d).C.\nThe underlying Timer is not recovered by the garbage collector\nuntil the timer fires. If efficiency is a concern, use NewTimer\ninstead and call Timer.Stop if the timer is no longer needed.\n\nGo input arguments: (d time.Duration)\n\nGo return type: ...\n\nJoker input arguments: [^time.Duration d]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:152:24)"
;;   {:added "1.0"
;;    :go "after(ABEND904(custom-runtime routine not implemented: time.Duration(_d)))"}
;;   [^time.Duration _d])

JOKER FUNC time.AfterFunc:
;; (defn AfterFunc
;;   "AfterFunc waits for the duration to elapse and then calls f\nin its own goroutine. It returns a Timer that can\nbe used to cancel the call using its Stop method.\n\nGo input arguments: (d time.Duration, f func)\n\nGo return type: *Timer\n\nJoker input arguments: [^time.Duration d, ^fn f]\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:50:4)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: afterFunc(ABEND904(custom-runtime routine not implemented: time.Duration(_d)), ABEND906(custom-runtime routine not implemented: ConvertToFuncTypeHaHa())))"}
;;   [^time.Duration _d, ^fn _f])

JOKER FUNC time.Date:
;; (defn Date
;;   "Date returns the Time corresponding to\n\tyyyy-mm-dd hh:mm:ss + nsec nanoseconds\nin the appropriate zone for that time in the given location.\n\nThe month, day, hour, min, sec, and nsec values may be outside\ntheir usual ranges and will be normalized during the conversion.\nFor example, October 32 converts to November 1.\n\nA daylight savings time transition skips or repeats times.\nFor example, in the United States, March 13, 2011 2:15am never occurred,\nwhile November 6, 2011 1:15am occurred twice. In such cases, the\nchoice of time zone, and therefore the time, is not well-defined.\nDate returns a time that is correct in one of the two zones involved\nin the transition, but it does not guarantee which.\n\nDate panics if loc is nil.\n\nGo input arguments: (year int, month time.Month, day int, hour int, min int, sec int, nsec int, loc *time.Location)\n\nGo return type: Time\n\nJoker input arguments: [^Int year, ^time.Month month, ^Int day, ^Int hour, ^Int min, ^Int sec, ^Int nsec, ^(atom-of time.Location) loc]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "date(_year, ABEND904(custom-runtime routine not implemented: time.Month(_month)), _day, _hour, _min, _sec, _nsec, ConvertToIndirectOftime.Location(ABEND904(custom-runtime routine not implemented: time.Location(_loc))))"}
;;   [^Int _year, ^time.Month _month, ^Int _day, ^Int _hour, ^Int _min, ^Int _sec, ^Int _nsec, ^Object _loc])

JOKER FUNC time.FixedZone:
;; (defn FixedZone
;;   "FixedZone returns a Location that always uses\nthe given zone name and offset (seconds east of UTC).\n\nGo input arguments: (name string, offset int)\n\nGo return type: *Location\n\nJoker input arguments: [^String name, ^Int offset]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: fixedZone(_name, _offset))"}
;;   [^String _name, ^Int _offset])

JOKER FUNC time.LoadLocation:
(defn LoadLocation
  "LoadLocation returns the Location with the given name.\n\nIf the name is \"\" or \"UTC\", LoadLocation returns UTC.\nIf the name is \"Local\", LoadLocation returns Local.\n\nOtherwise, the name is taken to be a location name corresponding to a file\nin the IANA Time Zone database, such as \"America/New_York\".\n\nThe time zone database needed by LoadLocation may not be\npresent on all systems, especially non-Unix systems.\nLoadLocation looks in the directory or uncompressed zip file\nnamed by the ZONEINFO environment variable, if any, then looks in\nknown installation locations on Unix systems,\nand finally looks in $GOROOT/lib/time/zoneinfo.zip.\n\nGo input arguments: (name string)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "loadLocation(_name)"}
  [^String _name])

JOKER FUNC time.LoadLocationFromTZData:
(defn LoadLocationFromTZData
  "LoadLocationFromTZData returns a Location with the given name\ninitialized from the IANA Time Zone database-formatted data.\nThe data should be in the format of a standard IANA time zone file\n(for example, the content of /etc/localtime on Unix systems).\n\nGo input arguments: (name string, data []byte)\n\nGo return type: (*Location, error)\n\nJoker input arguments: [^String name, ^(vector-of Byte) data]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "loadLocationFromTZData(_name, ConvertToArrayOfByte(_data))"}
  [^String _name, ^Object _data])

JOKER FUNC time.NewTicker:
;; (defn NewTicker
;;   "NewTicker returns a new Ticker containing a channel that will send the\ntime with a period specified by the duration argument.\nIt adjusts the intervals or drops ticks to make up for slow receivers.\nThe duration d must be greater than zero; if not, NewTicker will panic.\nStop the ticker to release associated resources.\n\nGo input arguments: (d time.Duration)\n\nGo return type: *Ticker\n\nJoker input arguments: [^time.Duration d]\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/tick.go:12:4)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTicker(ABEND904(custom-runtime routine not implemented: time.Duration(_d))))"}
;;   [^time.Duration _d])

JOKER FUNC time.NewTimer:
;; (defn NewTimer
;;   "NewTimer creates a new Timer that will send\nthe current time on its channel after at least duration d.\n\nGo input arguments: (d time.Duration)\n\nGo return type: *Timer\n\nJoker input arguments: [^time.Duration d]\n\nJoker return type: {:C ^ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/sleep.go:50:4)}"
;;   {:added "1.0"
;;    :go "ABEND401(StarExpr not supported -- no refs returned just yet: newTimer(ABEND904(custom-runtime routine not implemented: time.Duration(_d))))"}
;;   [^time.Duration _d])

JOKER FUNC time.Now:
;; (defn Now
;;   "Now returns the current local time.\n\nGo return type: Time\n\nJoker input arguments: []\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "now()"}
;;   [])

JOKER FUNC time.Parse:
(defn Parse
  "Parse parses a formatted string and returns the time value it represents.\nThe layout defines the format by showing how the reference time,\ndefined to be\n\tMon Jan 2 15:04:05 -0700 MST 2006\nwould be interpreted if it were the value; it serves as an example of\nthe input format. The same interpretation will then be made to the\ninput string.\n\nPredefined layouts ANSIC, UnixDate, RFC3339 and others describe standard\nand convenient representations of the reference time. For more information\nabout the formats and the definition of the reference time, see the\ndocumentation for ANSIC and the other constants defined by this package.\nAlso, the executable example for Time.Format demonstrates the working\nof the layout string in detail and is a good reference.\n\nElements omitted from the value are assumed to be zero or, when\nzero is impossible, one, so parsing \"3:04pm\" returns the time\ncorresponding to Jan 1, year 0, 15:04:00 UTC (note that because the year is\n0, this time is before the zero Time).\nYears must be in the range 0000..9999. The day of the week is checked\nfor syntax but it is otherwise ignored.\n\nIn the absence of a time zone indicator, Parse returns a time in UTC.\n\nWhen parsing a time with a zone offset like -0700, if the offset corresponds\nto a time zone used by the current location (Local), then Parse uses that\nlocation and zone in the returned time. Otherwise it records the time as\nbeing in a fabricated location with time fixed at the given zone offset.\n\nWhen parsing a time with a zone abbreviation like MST, if the zone abbreviation\nhas a defined offset in the current location, then that offset is used.\nThe zone abbreviation \"UTC\" is recognized as UTC regardless of location.\nIf the zone abbreviation is unknown, Parse records the time as being\nin a fabricated location with the given zone abbreviation and a zero offset.\nThis choice means that such a time can be parsed and reformatted with the\nsame layout losslessly, but the exact instant used in the representation will\ndiffer by the actual zone offset. To avoid such problems, prefer time layouts\nthat use a numeric zone offset, or use ParseInLocation.\n\nGo input arguments: (layout string, value string)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value]\n\nJoker return type: [{} Error]"
  {:added "1.0"
   :go "parse(_layout, _value)"}
  [^String _layout, ^String _value])

JOKER FUNC time.ParseDuration:
(defn ParseDuration
  "ParseDuration parses a duration string.\nA duration string is a possibly signed sequence of\ndecimal numbers, each with optional fraction and a unit suffix,\nsuch as \"300ms\", \"-1.5h\" or \"2h45m\".\nValid time units are \"ns\", \"us\" (or \"s\"), \"ms\", \"s\", \"m\", \"h\".\n\nGo input arguments: (s string)\n\nGo return type: (Duration, error)\n\nJoker input arguments: [^String s]\n\nJoker return type: [Int Error]"
  {:added "1.0"
   :go "parseDuration(_s)"}
  [^String _s])

JOKER FUNC time.ParseInLocation:
;; (defn ParseInLocation
;;   "ParseInLocation is like Parse but differs in two important ways.\nFirst, in the absence of time zone information, Parse interprets a time as UTC;\nParseInLocation interprets the time as in the given location.\nSecond, when given a zone offset or abbreviation, Parse tries to match it\nagainst the Local location; ParseInLocation uses the given location.\n\nGo input arguments: (layout string, value string, loc *time.Location)\n\nGo return type: (Time, error)\n\nJoker input arguments: [^String layout, ^String value, ^(atom-of time.Location) loc]\n\nJoker return type: [{} Error]"
;;   {:added "1.0"
;;    :go "parseInLocation(_layout, _value, ConvertToIndirectOftime.Location(ABEND904(custom-runtime routine not implemented: time.Location(_loc))))"}
;;   [^String _layout, ^String _value, ^Object _loc])

JOKER FUNC time.Since:
;; (defn ^"Int" Since
;;   "Since returns the time elapsed since t.\nIt is shorthand for time.Now().Sub(t).\n\nGo input arguments: (t time.Time)\n\nGo return type: Duration\n\nJoker input arguments: [^time.Time t]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(time.Since(ABEND904(custom-runtime routine not implemented: time.Time(_t))))"}
;;   [^time.Time _t])

JOKER FUNC time.Sleep:
;; (defn Sleep
;;   "Sleep pauses the current goroutine for at least the duration d.\nA negative or zero duration causes Sleep to return immediately.\n\nGo input arguments: (d time.Duration)\n\nJoker input arguments: [^time.Duration d]"
;;   {:added "1.0"
;;    :go "sleep(ABEND904(custom-runtime routine not implemented: time.Duration(_d)))"}
;;   [^time.Duration _d])

JOKER FUNC time.Tick:
;; (defn Tick
;;   "Tick is a convenience wrapper for NewTicker providing access to the ticking\nchannel only. While Tick is useful for clients that have no need to shut down\nthe Ticker, be aware that without a way to shut it down the underlying\nTicker cannot be recovered by the garbage collector; it \"leaks\".\nUnlike NewTicker, Tick will return nil if d <= 0.\n\nGo input arguments: (d time.Duration)\n\nGo return type: ...\n\nJoker input arguments: [^time.Duration d]\n\nJoker return type: ABEND883(unrecognized Expr type *ast.ChanType at: GO.link/src/time/tick.go:54:23)"
;;   {:added "1.0"
;;    :go "tick(ABEND904(custom-runtime routine not implemented: time.Duration(_d)))"}
;;   [^time.Duration _d])

JOKER FUNC time.Unix:
;; (defn Unix
;;   "Unix returns the local Time corresponding to the given Unix time,\nsec seconds and nsec nanoseconds since January 1, 1970 UTC.\nIt is valid to pass nsec outside the range [0, 999999999].\nNot all sec values have a corresponding time value. One such\nvalue is 1<<63-1 (the largest int64 value).\n\nGo input arguments: (sec int64, nsec int64)\n\nGo return type: Time\n\nJoker input arguments: [^Int64 sec, ^Int64 nsec]\n\nJoker return type: {}"
;;   {:added "1.0"
;;    :go "unix(_sec, _nsec)"}
;;   [^Int64 _sec, ^Int64 _nsec])

JOKER FUNC time.Until:
;; (defn ^"Int" Until
;;   "Until returns the duration until t.\nIt is shorthand for t.Sub(time.Now()).\n\nGo input arguments: (t time.Time)\n\nGo return type: Duration\n\nJoker input arguments: [^time.Time t]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "int(time.Until(ABEND904(custom-runtime routine not implemented: time.Time(_t))))"}
;;   [^time.Time _t])

JOKER FUNC unicode.In:
;; (defn ^"Bool" In
;;   "In reports whether the rune is a member of one of the ranges.\n\nGo input arguments: (r rune, ranges ...*unicode.RangeTable)\n\nGo return type: bool\n\nJoker input arguments: [^rune r, ^(ellipsis-somehow Object) ranges]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.In(_r, ConvertToEllipsisHaHaObject(ConvertToIndirectOfunicode.RangeTable(ABEND904(custom-runtime routine not implemented: unicode.RangeTable(_ranges)))))"}
;;   [^ABEND044(unsupported built-in type rune) _r, ^Object _ranges])

JOKER FUNC unicode.Is:
;; (defn ^"Bool" Is
;;   "Is reports whether the rune is in the specified table of ranges.\n\nGo input arguments: (rangeTab *unicode.RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(atom-of unicode.RangeTable) rangeTab, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.Is(ConvertToIndirectOfunicode.RangeTable(ABEND904(custom-runtime routine not implemented: unicode.RangeTable(_rangeTab))), _r)"}
;;   [^Object _rangeTab, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsControl:
;; (defn ^"Bool" IsControl
;;   "IsControl reports whether the rune is a control character.\nThe C (Other) Unicode category includes more code points\nsuch as surrogates; use Is(C, r) to test for them.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsControl(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsDigit:
;; (defn ^"Bool" IsDigit
;;   "IsDigit reports whether the rune is a decimal digit.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsDigit(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsGraphic:
;; (defn ^"Bool" IsGraphic
;;   "IsGraphic reports whether the rune is defined as a Graphic by Unicode.\nSuch characters include letters, marks, numbers, punctuation, symbols, and\nspaces, from categories L, M, N, P, S, Zs.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsGraphic(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLetter:
;; (defn ^"Bool" IsLetter
;;   "IsLetter reports whether the rune is a letter (category L).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLetter(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsLower:
;; (defn ^"Bool" IsLower
;;   "IsLower reports whether the rune is a lower case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsLower(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsMark:
;; (defn ^"Bool" IsMark
;;   "IsMark reports whether the rune is a mark character (category M).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsMark(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsNumber:
;; (defn ^"Bool" IsNumber
;;   "IsNumber reports whether the rune is a number (category N).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsNumber(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsOneOf:
;; (defn ^"Bool" IsOneOf
;;   "IsOneOf reports whether the rune is a member of one of the ranges.\nThe function \"In\" provides a nicer signature and should be used in preference to IsOneOf.\n\nGo input arguments: (ranges []*unicode.RangeTable, r rune)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of (atom-of unicode.RangeTable)) ranges, ^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsOneOf(ConvertToArrayOfObject(ConvertToIndirectOfunicode.RangeTable(ABEND904(custom-runtime routine not implemented: unicode.RangeTable(_ranges)))), _r)"}
;;   [^Object _ranges, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPrint:
;; (defn ^"Bool" IsPrint
;;   "IsPrint reports whether the rune is defined as printable by Go. Such\ncharacters include letters, marks, numbers, punctuation, symbols, and the\nASCII space character, from categories L, M, N, P, S and the ASCII space\ncharacter. This categorization is the same as IsGraphic except that the\nonly spacing character is ASCII space, U+0020.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPrint(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsPunct:
;; (defn ^"Bool" IsPunct
;;   "IsPunct reports whether the rune is a Unicode punctuation character\n(category P).\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsPunct(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSpace:
;; (defn ^"Bool" IsSpace
;;   "IsSpace reports whether the rune is a space character as defined\nby Unicode's White Space property; in the Latin-1 space\nthis is\n\t'\\t', '\\n', '\\v', '\\f', '\\r', ' ', U+0085 (NEL), U+00A0 (NBSP).\nOther definitions of spacing characters are set by category\nZ and property Pattern_White_Space.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSpace(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsSymbol:
;; (defn ^"Bool" IsSymbol
;;   "IsSymbol reports whether the rune is a symbolic character.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsSymbol(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsTitle:
;; (defn ^"Bool" IsTitle
;;   "IsTitle reports whether the rune is a title case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsTitle(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.IsUpper:
;; (defn ^"Bool" IsUpper
;;   "IsUpper reports whether the rune is an upper case letter.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "unicode.IsUpper(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.SimpleFold:
;; (defn SimpleFold
;;   "SimpleFold iterates over Unicode code points equivalent under\nthe Unicode-defined simple case folding. Among the code points\nequivalent to rune (including rune itself), SimpleFold returns the\nsmallest rune > r if one exists, or else the smallest rune >= 0.\nIf r is not a valid Unicode code point, SimpleFold(r) returns r.\n\nFor example:\n\tSimpleFold('A') = 'a'\n\tSimpleFold('a') = 'A'\n\n\tSimpleFold('K') = 'k'\n\tSimpleFold('k') = '\\u212A' (Kelvin symbol, )\n\tSimpleFold('\\u212A') = 'K'\n\n\tSimpleFold('1') = '1'\n\n\tSimpleFold(-2) = -2\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "simpleFold(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.To:
;; (defn To
;;   "To maps the rune to the specified case: UpperCase, LowerCase, or TitleCase.\n\nGo input arguments: (_case int, r rune)\n\nGo return type: ...\n\nJoker input arguments: [^Int _case, ^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "to(__case, _r)"}
;;   [^Int __case, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToLower:
;; (defn ToLower
;;   "ToLower maps the rune to lower case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toLower(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToTitle:
;; (defn ToTitle
;;   "ToTitle maps the rune to title case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toTitle(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode.ToUpper:
;; (defn ToUpper
;;   "ToUpper maps the rune to upper case.\n\nGo input arguments: (r rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "toUpper(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.Decode:
;; (defn Decode
;;   "Decode returns the Unicode code point sequence represented\nby the UTF-16 encoding s.\n\nGo input arguments: (s []uint16)\n\nGo return type: []...\n\nJoker input arguments: [^(vector-of UInt16) s]\n\nJoker return type: (vector-of ABEND043(unsupported built-in type rune))"
;;   {:added "1.0"
;;    :go "decode(ABEND902(custom-runtime routine not implemented: ConvertToArrayOfUInt16(_s)))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.DecodeRune:
;; (defn DecodeRune
;;   "DecodeRune returns the UTF-16 decoding of a surrogate pair.\nIf the pair is not a valid UTF-16 surrogate pair, DecodeRune returns\nthe Unicode replacement code point U+FFFD.\n\nGo input arguments: (r1 rune, r2 rune)\n\nGo return type: ...\n\nJoker input arguments: [^rune r1, ^rune r2]\n\nJoker return type: ABEND043(unsupported built-in type rune)"
;;   {:added "1.0"
;;    :go "decodeRune(_r1, _r2)"}
;;   [^ABEND044(unsupported built-in type rune) _r1, ^ABEND044(unsupported built-in type rune) _r2])

JOKER FUNC unicode/utf16.Encode:
;; (defn Encode
;;   "Encode returns the UTF-16 encoding of the Unicode code point sequence s.\n\nGo input arguments: (s []rune)\n\nGo return type: []int\n\nJoker input arguments: [^(vector-of rune) s]\n\nJoker return type: (vector-of Int)"
;;   {:added "1.0"
;;    :go "encode(ConvertToArrayOfABEND044(unsupported built-in type rune)(_s))"}
;;   [^Object _s])

JOKER FUNC unicode/utf16.EncodeRune:
;; (defn EncodeRune
;;   "EncodeRune returns the UTF-16 surrogate pair r1, r2 for the given rune.\nIf the rune is not a valid Unicode code point or does not need encoding,\nEncodeRune returns U+FFFD, U+FFFD.\n\nGo input arguments: (r rune)\n\nGo return type: (r1 ..., r2 ...)\n\nJoker input arguments: [^rune r]\n\nJoker return type: [ABEND043(unsupported built-in type rune) ABEND043(unsupported built-in type rune)]"
;;   {:added "1.0"
;;    :go "encodeRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf16.IsSurrogate:
;; (defn ^"Bool" IsSurrogate
;;   "IsSurrogate reports whether the specified Unicode code point\ncan appear in a surrogate pair.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf16.IsSurrogate(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.DecodeLastRune:
;; (defn DecodeLastRune
;;   "DecodeLastRune unpacks the last UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRune(ConvertToArrayOfByte(_p))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeLastRuneInString:
;; (defn DecodeLastRuneInString
;;   "DecodeLastRuneInString is like DecodeLastRune but its input is a string. If\ns is empty it returns (RuneError, 0). Otherwise, if the encoding is invalid,\nit returns (RuneError, 1). Both are impossible results for correct,\nnon-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeLastRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.DecodeRune:
;; (defn DecodeRune
;;   "DecodeRune unpacks the first UTF-8 encoding in p and returns the rune and\nits width in bytes. If p is empty it returns (RuneError, 0). Otherwise, if\nthe encoding is invalid, it returns (RuneError, 1). Both are impossible\nresults for correct, non-empty UTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (p []byte)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRune(ConvertToArrayOfByte(_p))"}
;;   [^Object _p])

JOKER FUNC unicode/utf8.DecodeRuneInString:
;; (defn DecodeRuneInString
;;   "DecodeRuneInString is like DecodeRune but its input is a string. If s is\nempty it returns (RuneError, 0). Otherwise, if the encoding is invalid, it\nreturns (RuneError, 1). Both are impossible results for correct, non-empty\nUTF-8.\n\nAn encoding is invalid if it is incorrect UTF-8, encodes a rune that is\nout of range, or is not the shortest possible UTF-8 encoding for the\nvalue. No other validation is performed.\n\nGo input arguments: (s string)\n\nGo return type: (r ..., size int)\n\nJoker input arguments: [^String s]\n\nJoker return type: [ABEND043(unsupported built-in type rune) Int]"
;;   {:added "1.0"
;;    :go "decodeRuneInString(_s)"}
;;   [^String _s])

JOKER FUNC unicode/utf8.EncodeRune:
;; (defn ^"Int" EncodeRune
;;   "EncodeRune writes into p (which must be large enough) the UTF-8 encoding of the rune.\nIt returns the number of bytes written.\n\nGo input arguments: (p []byte, r rune)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p, ^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.EncodeRune(ConvertToArrayOfByte(_p), _r)"}
;;   [^Object _p, ^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.FullRune:
(defn ^"Bool" FullRune
  "FullRune reports whether the bytes in p begin with a full UTF-8 encoding of a rune.\nAn invalid encoding is considered a full Rune since it will convert as a width-1 error rune.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.FullRune(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC unicode/utf8.FullRuneInString:
(defn ^"Bool" FullRuneInString
  "FullRuneInString is like FullRune but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.FullRuneInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneCount:
(defn ^"Int" RuneCount
  "RuneCount returns the number of runes in p. Erroneous and short\nencodings are treated as single runes of width 1 byte.\n\nGo input arguments: (p []byte)\n\nGo return type: int\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCount(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC unicode/utf8.RuneCountInString:
(defn ^"Int" RuneCountInString
  "RuneCountInString is like RuneCount but its input is a string.\n\nGo input arguments: (s string)\n\nGo return type: int\n\nJoker input arguments: [^String s]\n\nJoker return type: Int"
  {:added "1.0"
   :go "utf8.RuneCountInString(_s)"}
  [^String _s])

JOKER FUNC unicode/utf8.RuneLen:
;; (defn ^"Int" RuneLen
;;   "RuneLen returns the number of bytes required to encode the rune.\nIt returns -1 if the rune is not a valid value to encode in UTF-8.\n\nGo input arguments: (r rune)\n\nGo return type: int\n\nJoker input arguments: [^rune r]\n\nJoker return type: Int"
;;   {:added "1.0"
;;    :go "utf8.RuneLen(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.RuneStart:
(defn ^"Bool" RuneStart
  "RuneStart reports whether the byte could be the first byte of an encoded,\npossibly invalid rune. Second and subsequent bytes always have the top two\nbits set to 10.\n\nGo input arguments: (b byte)\n\nGo return type: bool\n\nJoker input arguments: [^Byte b]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.RuneStart(_b)"}
  [^Byte _b])

JOKER FUNC unicode/utf8.Valid:
(defn ^"Bool" Valid
  "Valid reports whether p consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (p []byte)\n\nGo return type: bool\n\nJoker input arguments: [^(vector-of Byte) p]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.Valid(ConvertToArrayOfByte(_p))"}
  [^Object _p])

JOKER FUNC unicode/utf8.ValidRune:
;; (defn ^"Bool" ValidRune
;;   "ValidRune reports whether r can be legally encoded as UTF-8.\nCode points that are out of range or a surrogate half are illegal.\n\nGo input arguments: (r rune)\n\nGo return type: bool\n\nJoker input arguments: [^rune r]\n\nJoker return type: Bool"
;;   {:added "1.0"
;;    :go "utf8.ValidRune(_r)"}
;;   [^ABEND044(unsupported built-in type rune) _r])

JOKER FUNC unicode/utf8.ValidString:
(defn ^"Bool" ValidString
  "ValidString reports whether s consists entirely of valid UTF-8-encoded runes.\n\nGo input arguments: (s string)\n\nGo return type: bool\n\nJoker input arguments: [^String s]\n\nJoker return type: Bool"
  {:added "1.0"
   :go "utf8.ValidString(_s)"}
  [^String _s])

JOKER FUNC unsafe.Alignof:
;; (defn Alignof
;;   "Alignof takes an expression x of any type and returns the required alignment\nof a hypothetical variable v as if v was declared via var v = x.\nIt is the largest value m such that the address of v is always zero mod m.\nIt is the same as the value returned by reflect.TypeOf(x).Align().\nAs a special case, if a variable s is of struct type and f is a field\nwithin that struct, then Alignof(s.f) will return the required alignment\nof a field of that type within a struct. This case is the same as the\nvalue returned by reflect.TypeOf(s.f).FieldAlign().\n\nGo input arguments: (x unsafe.ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^unsafe.ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "alignof(ABEND904(custom-runtime routine not implemented: unsafe.ArbitraryType(_x)))"}
;;   [^unsafe.ArbitraryType _x])

JOKER FUNC unsafe.Offsetof:
;; (defn Offsetof
;;   "Offsetof returns the offset within the struct of the field represented by x,\nwhich must be of the form structValue.field. In other words, it returns the\nnumber of bytes between the start of the struct and the start of the field.\n\nGo input arguments: (x unsafe.ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^unsafe.ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "offsetof(ABEND904(custom-runtime routine not implemented: unsafe.ArbitraryType(_x)))"}
;;   [^unsafe.ArbitraryType _x])

JOKER FUNC unsafe.Sizeof:
;; (defn Sizeof
;;   "Sizeof takes an expression x of any type and returns the size in bytes\nof a hypothetical variable v as if v was declared via var v = x.\nThe size does not include any memory possibly referenced by x.\nFor instance, if x is a slice, Sizeof returns the size of the slice\ndescriptor, not the size of the memory referenced by the slice.\n\nGo input arguments: (x unsafe.ArbitraryType)\n\nGo return type: ...\n\nJoker input arguments: [^unsafe.ArbitraryType x]\n\nJoker return type: ABEND043(unsupported built-in type uintptr)"
;;   {:added "1.0"
;;    :go "sizeof(ABEND904(custom-runtime routine not implemented: unsafe.ArbitraryType(_x)))"}
;;   [^unsafe.ArbitraryType _x])

GO FUNC archive/tar.FileInfoHeader:
// func fileInfoHeader(fi os.FileInfo, link string) Object {
// 	_res1, _res2 := _tar.FileInfoHeader(fi, link)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Typeflag"), MakeInt(int((*_res1).Typeflag)))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		_map1.Add(MakeKeyword("Linkname"), MakeString((*_res1).Linkname))
// 		_map1.Add(MakeKeyword("Size"), MakeInt(int((*_res1).Size)))
// 		_map1.Add(MakeKeyword("Mode"), MakeInt(int((*_res1).Mode)))
// 		_map1.Add(MakeKeyword("Uid"), MakeInt((*_res1).Uid))
// 		_map1.Add(MakeKeyword("Gid"), MakeInt((*_res1).Gid))
// 		_map1.Add(MakeKeyword("Uname"), MakeString((*_res1).Uname))
// 		_map1.Add(MakeKeyword("Gname"), MakeString((*_res1).Gname))
// 		_map1.Add(MakeKeyword("ModTime"), NIL)
// 		_map1.Add(MakeKeyword("AccessTime"), NIL)
// 		_map1.Add(MakeKeyword("ChangeTime"), NIL)
// 		_map1.Add(MakeKeyword("Devmajor"), MakeInt(int((*_res1).Devmajor)))
// 		_map1.Add(MakeKeyword("Devminor"), MakeInt(int((*_res1).Devminor)))
// 		_map1.Add(MakeKeyword("Xattrs"), (*_res1).Xattrs)
// 		_map1.Add(MakeKeyword("PAXRecords"), (*_res1).PAXRecords)
// 		_map1.Add(MakeKeyword("Format"), MakeInt((*_res1).Format))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/tar.NewReader:
// func newReader(r io.Reader) Object {
// 	return _tar.NewReader(r)
// 	ABEND124(no public information returned)
// }

GO FUNC archive/tar.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _tar.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC archive/zip.FileInfoHeader:
// func fileInfoHeader(fi os.FileInfo) Object {
// 	_res1, _res2 := _zip.FileInfoHeader(fi)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		_map1.Add(MakeKeyword("Comment"), MakeString((*_res1).Comment))
// 		_map1.Add(MakeKeyword("NonUTF8"), MakeBool((*_res1).NonUTF8))
// 		_map1.Add(MakeKeyword("CreatorVersion"), MakeInt(int((*_res1).CreatorVersion)))
// 		_map1.Add(MakeKeyword("ReaderVersion"), MakeInt(int((*_res1).ReaderVersion)))
// 		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
// 		_map1.Add(MakeKeyword("Method"), MakeInt(int((*_res1).Method)))
// 		_map1.Add(MakeKeyword("Modified"), NIL)
// 		_map1.Add(MakeKeyword("ModifiedTime"), MakeInt(int((*_res1).ModifiedTime)))
// 		_map1.Add(MakeKeyword("ModifiedDate"), MakeInt(int((*_res1).ModifiedDate)))
// 		_map1.Add(MakeKeyword("CRC32"), MakeInt(int((*_res1).CRC32)))
// 		_map1.Add(MakeKeyword("CompressedSize"), MakeInt(int((*_res1).CompressedSize)))
// 		_map1.Add(MakeKeyword("UncompressedSize"), MakeInt(int((*_res1).UncompressedSize)))
// 		_map1.Add(MakeKeyword("CompressedSize64"), (*_res1).CompressedSize64)
// 		_map1.Add(MakeKeyword("UncompressedSize64"), (*_res1).UncompressedSize64)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).Extra {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_map1.Add(MakeKeyword("Extra"), _vec3)
// 		_map1.Add(MakeKeyword("ExternalAttrs"), MakeInt(int((*_res1).ExternalAttrs)))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewReader:
// func newReader(r io.ReaderAt, size int64) Object {
// 	_res1, _res2 := _zip.NewReader(r, size)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("File"), NIL)
// 		_map1.Add(MakeKeyword("Comment"), MakeString((*_res1).Comment))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC archive/zip.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _zip.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC archive/zip.OpenReader:
func openReader(name string) Object {
	_, _res2 := _zip.OpenReader(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC archive/zip.RegisterCompressor:
// func registerCompressor(method uint16, comp archive/zip.Compressor) Object {
// 	_zip.RegisterCompressor(method, comp)
// 	...ABEND675: TODO...
// }

GO FUNC archive/zip.RegisterDecompressor:
// func registerDecompressor(method uint16, dcomp archive/zip.Decompressor) Object {
// 	_zip.RegisterDecompressor(method, dcomp)
// 	...ABEND675: TODO...
// }

GO FUNC bufio.NewReadWriter:
// func newReadWriter(r *bufio.Reader, w *bufio.Writer) Object {
// 	return _bufio.NewReadWriter(r, w)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewReader:
// func newReader(rd io.Reader) Object {
// 	return _bufio.NewReader(rd)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewReaderSize:
// func newReaderSize(rd io.Reader, size int) Object {
// 	return _bufio.NewReaderSize(rd, size)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewScanner:
// func newScanner(r io.Reader) Object {
// 	return _bufio.NewScanner(r)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _bufio.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.NewWriterSize:
// func newWriterSize(w io.Writer, size int) Object {
// 	return _bufio.NewWriterSize(w, size)
// 	ABEND124(no public information returned)
// }

GO FUNC bufio.ScanBytes:
func scanBytes(data []byte, atEOF bool) Object {
	advance, token, err := _bufio.ScanBytes(data, atEOF)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(advance))
	_vec1 := EmptyVector
	for _, _elem1 := range token {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.ScanLines:
func scanLines(data []byte, atEOF bool) Object {
	advance, token, err := _bufio.ScanLines(data, atEOF)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(advance))
	_vec1 := EmptyVector
	for _, _elem1 := range token {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.ScanRunes:
func scanRunes(data []byte, atEOF bool) Object {
	advance, token, err := _bufio.ScanRunes(data, atEOF)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(advance))
	_vec1 := EmptyVector
	for _, _elem1 := range token {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bufio.ScanWords:
func scanWords(data []byte, atEOF bool) Object {
	advance, token, err := _bufio.ScanWords(data, atEOF)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(advance))
	_vec1 := EmptyVector
	for _, _elem1 := range token {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC bytes.Fields:
func fields(s []byte) Object {
	_res := _bytes.Fields(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC bytes.FieldsFunc:
// func fieldsFunc(s []byte, f func) Object {
// 	_res := _bytes.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range _elem1 {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_vec1 = _vec1.Conjoin(_vec2)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Join:
// func join(s [][]byte, sep []byte) Object {
// 	_res := _bytes.Join(s, sep)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Map:
// func map(mapping func, s []byte) Object {
// 	_res := _bytes.Map(mapping, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.NewBuffer:
// func newBuffer(buf []byte) Object {
// 	return _bytes.NewBuffer(buf)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.NewBufferString:
// func newBufferString(s string) Object {
// 	return _bytes.NewBufferString(s)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.NewReader:
// func newReader(b []byte) Object {
// 	return _bytes.NewReader(b)
// 	ABEND124(no public information returned)
// }

GO FUNC bytes.Repeat:
func repeat(b []byte, count int) Object {
	_res := _bytes.Repeat(b, count)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.Replace:
func replace(s []byte, old []byte, new []byte, n int) Object {
	_res := _bytes.Replace(s, old, new, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.Runes:
// func runes(s []byte) Object {
// 	_res := _bytes.Runes(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC bytes.Split:
func split(s []byte, sep []byte) Object {
	_res := _bytes.Split(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC bytes.SplitAfter:
func splitAfter(s []byte, sep []byte) Object {
	_res := _bytes.SplitAfter(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC bytes.SplitAfterN:
func splitAfterN(s []byte, sep []byte, n int) Object {
	_res := _bytes.SplitAfterN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC bytes.SplitN:
func splitN(s []byte, sep []byte, n int) Object {
	_res := _bytes.SplitN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	return _vec1
}

GO FUNC bytes.Title:
func title(s []byte) Object {
	_res := _bytes.Title(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.ToLower:
func toLower(s []byte) Object {
	_res := _bytes.ToLower(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.ToLowerSpecial:
// func toLowerSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToLowerSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToTitle:
func toTitle(s []byte) Object {
	_res := _bytes.ToTitle(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.ToTitleSpecial:
// func toTitleSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToTitleSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.ToUpper:
func toUpper(s []byte) Object {
	_res := _bytes.ToUpper(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.ToUpperSpecial:
// func toUpperSpecial(c unicode.SpecialCase, s []byte) Object {
// 	_res := _bytes.ToUpperSpecial(c, s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.Trim:
func trim(s []byte, cutset string) Object {
	_res := _bytes.Trim(s, cutset)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.TrimFunc:
// func trimFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimLeft:
func trimLeft(s []byte, cutset string) Object {
	_res := _bytes.TrimLeft(s, cutset)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.TrimLeftFunc:
// func trimLeftFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimLeftFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimPrefix:
func trimPrefix(s []byte, prefix []byte) Object {
	_res := _bytes.TrimPrefix(s, prefix)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.TrimRight:
func trimRight(s []byte, cutset string) Object {
	_res := _bytes.TrimRight(s, cutset)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.TrimRightFunc:
// func trimRightFunc(s []byte, f func) Object {
// 	_res := _bytes.TrimRightFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC bytes.TrimSpace:
func trimSpace(s []byte) Object {
	_res := _bytes.TrimSpace(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC bytes.TrimSuffix:
func trimSuffix(s []byte, suffix []byte) Object {
	_res := _bytes.TrimSuffix(s, suffix)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC compress/bzip2.NewReader:
// func newReader(r io.Reader) Object {
// 	return _bzip2.NewReader(r)
// }

GO FUNC compress/flate.NewReader:
// func newReader(r io.Reader) Object {
// 	return _flate.NewReader(r)
// }

GO FUNC compress/flate.NewReaderDict:
// func newReaderDict(r io.Reader, dict []byte) Object {
// 	return _flate.NewReaderDict(r, dict)
// }

GO FUNC compress/flate.NewWriter:
// func newWriter(w io.Writer, level int) Object {
// 	_, _res2 := _flate.NewWriter(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/flate.NewWriterDict:
// func newWriterDict(w io.Writer, level int, dict []byte) Object {
// 	_, _res2 := _flate.NewWriterDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewReader:
// func newReader(r io.Reader) Object {
// 	_, _res2 := _gzip.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/gzip.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _gzip.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC compress/gzip.NewWriterLevel:
// func newWriterLevel(w io.Writer, level int) Object {
// 	_, _res2 := _gzip.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/lzw.NewReader:
// func newReader(r io.Reader, order compress/lzw.Order, litWidth int) Object {
// 	return _lzw.NewReader(r, order, litWidth)
// }

GO FUNC compress/lzw.NewWriter:
// func newWriter(w io.Writer, order compress/lzw.Order, litWidth int) Object {
// 	return _lzw.NewWriter(w, order, litWidth)
// }

GO FUNC compress/zlib.NewReader:
// func newReader(r io.Reader) Object {
// 	_res1, _res2 := _zlib.NewReader(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewReaderDict:
// func newReaderDict(r io.Reader, dict []byte) Object {
// 	_res1, _res2 := _zlib.NewReaderDict(r, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _zlib.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC compress/zlib.NewWriterLevel:
// func newWriterLevel(w io.Writer, level int) Object {
// 	_, _res2 := _zlib.NewWriterLevel(w, level)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC compress/zlib.NewWriterLevelDict:
// func newWriterLevelDict(w io.Writer, level int, dict []byte) Object {
// 	_, _res2 := _zlib.NewWriterLevelDict(w, level, dict)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC container/heap.Fix:
// func fix(h container/heap.Interface, i int) Object {
// 	_heap.Fix(h, i)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Init:
// func init(h container/heap.Interface) Object {
// 	_heap.Init(h)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Pop:
// func pop(h container/heap.Interface) Object {
// 	return _heap.Pop(h)
// }

GO FUNC container/heap.Push:
// func push(h container/heap.Interface, x interface {}) Object {
// 	_heap.Push(h, x)
// 	...ABEND675: TODO...
// }

GO FUNC container/heap.Remove:
// func remove(h container/heap.Interface, i int) Object {
// 	return _heap.Remove(h, i)
// }

GO FUNC container/list.New:
// func new() Object {
// 	return _list.New()
// 	ABEND124(no public information returned)
// }

GO FUNC container/ring.New:
// func new(n int) Object {
// 	_res := _ring.New(n)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Value"), (*_res).Value)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC context.Background:
// func background() Object {
// 	return _context.Background()
// }

GO FUNC context.TODO:
// func tODO() Object {
// 	return _context.TODO()
// }

GO FUNC context.WithCancel:
// func withCancel(parent context.Context) Object {
// 	ctx, cancel := _context.WithCancel(parent)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ctx)
// 	_res = _res.Conjoin(cancel)
// 	return _res
// }

GO FUNC context.WithDeadline:
// func withDeadline(parent context.Context, d time.Time) Object {
// 	_res1, _res2 := _context.WithDeadline(parent, d)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	return _res
// }

GO FUNC context.WithTimeout:
// func withTimeout(parent context.Context, timeout time.Duration) Object {
// 	_res1, _res2 := _context.WithTimeout(parent, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	return _res
// }

GO FUNC context.WithValue:
// func withValue(parent context.Context, key interface {}, val interface {}) Object {
// 	return _context.WithValue(parent, key, val)
// }

GO FUNC crypto.RegisterHash:
// func registerHash(h crypto.Hash, f func) Object {
// 	_crypto.RegisterHash(h, f)
// 	...ABEND675: TODO...
// }

GO FUNC crypto/aes.NewCipher:
// func newCipher(key []byte) Object {
// 	_res1, _res2 := _aes.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/cipher.NewCBCDecrypter:
// func newCBCDecrypter(b crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewCBCDecrypter(b, iv)
// }

GO FUNC crypto/cipher.NewCBCEncrypter:
// func newCBCEncrypter(b crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewCBCEncrypter(b, iv)
// }

GO FUNC crypto/cipher.NewCFBDecrypter:
// func newCFBDecrypter(block crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewCFBDecrypter(block, iv)
// }

GO FUNC crypto/cipher.NewCFBEncrypter:
// func newCFBEncrypter(block crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewCFBEncrypter(block, iv)
// }

GO FUNC crypto/cipher.NewCTR:
// func newCTR(block crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewCTR(block, iv)
// }

GO FUNC crypto/cipher.NewGCM:
// func newGCM(cipher crypto/cipher.Block) Object {
// 	_res1, _res2 := _cipher.NewGCM(cipher)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/cipher.NewGCMWithNonceSize:
// func newGCMWithNonceSize(cipher crypto/cipher.Block, size int) Object {
// 	_res1, _res2 := _cipher.NewGCMWithNonceSize(cipher, size)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/cipher.NewGCMWithTagSize:
// func newGCMWithTagSize(cipher crypto/cipher.Block, tagSize int) Object {
// 	_res1, _res2 := _cipher.NewGCMWithTagSize(cipher, tagSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/cipher.NewOFB:
// func newOFB(b crypto/cipher.Block, iv []byte) Object {
// 	return _cipher.NewOFB(b, iv)
// }

GO FUNC crypto/des.NewCipher:
// func newCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/des.NewTripleDESCipher:
// func newTripleDESCipher(key []byte) Object {
// 	_res1, _res2 := _des.NewTripleDESCipher(key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/dsa.Sign:
// func sign(rand io.Reader, priv *crypto/dsa.PrivateKey, hash []byte) Object {
// 	_, _, err := _dsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.GenerateKey:
// func generateKey(c crypto/elliptic.Curve, rand io.Reader) Object {
// 	_, _res2 := _ecdsa.GenerateKey(c, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/ecdsa.Sign:
// func sign(rand io.Reader, priv *crypto/ecdsa.PrivateKey, hash []byte) Object {
// 	_, _, err := _ecdsa.Sign(rand, priv, hash)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/elliptic.GenerateKey:
// func generateKey(curve crypto/elliptic.Curve, rand io.Reader) Object {
// 	priv, _, _, err := _elliptic.GenerateKey(curve, rand)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range priv {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/elliptic.Marshal:
// func marshal(curve crypto/elliptic.Curve, x *math/big.Int, y *math/big.Int) Object {
// 	_res := _elliptic.Marshal(curve, x, y)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/elliptic.P224:
// func p224() Object {
// 	return _elliptic.P224()
// }

GO FUNC crypto/elliptic.P256:
// func p256() Object {
// 	return _elliptic.P256()
// }

GO FUNC crypto/elliptic.P384:
// func p384() Object {
// 	return _elliptic.P384()
// }

GO FUNC crypto/elliptic.P521:
// func p521() Object {
// 	return _elliptic.P521()
// }

GO FUNC crypto/elliptic.Unmarshal:
// func unmarshal(curve crypto/elliptic.Curve, data []byte) Object {
// 	_, _ := _elliptic.Unmarshal(curve, data)
// 	ABEND123(no public information returned)
// }

GO FUNC crypto/hmac.New:
// func new(h func, key []byte) Object {
// 	return _hmac.New(h, key)
// }

GO FUNC crypto/md5.New:
// func new() Object {
// 	return _md5.New()
// }

GO FUNC crypto/md5.Sum:
func sum(data []byte) Object {
	_res := _md5.Sum(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/rand.Int:
// func int(rand io.Reader, max *math/big.Int) Object {
// 	_, err := _rand.Int(rand, max)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Prime:
// func prime(rand io.Reader, bits int) Object {
// 	_, err := _rand.Prime(rand, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/rand.Read:
func read(b []byte) Object {
	n, err := _rand.Read(b)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC crypto/rc4.NewCipher:
func newCipher(key []byte) Object {
	_, _res2 := _rc4.NewCipher(key)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/rsa.DecryptOAEP:
// func decryptOAEP(hash hash.Hash, random io.Reader, priv *crypto/rsa.PrivateKey, ciphertext []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.DecryptOAEP(hash, random, priv, ciphertext, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.DecryptPKCS1v15:
// func decryptPKCS1v15(rand io.Reader, priv *crypto/rsa.PrivateKey, ciphertext []byte) Object {
// 	_res1, _res2 := _rsa.DecryptPKCS1v15(rand, priv, ciphertext)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.EncryptOAEP:
// func encryptOAEP(hash hash.Hash, random io.Reader, pub *crypto/rsa.PublicKey, msg []byte, label []byte) Object {
// 	_res1, _res2 := _rsa.EncryptOAEP(hash, random, pub, msg, label)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.EncryptPKCS1v15:
// func encryptPKCS1v15(rand io.Reader, pub *crypto/rsa.PublicKey, msg []byte) Object {
// 	_res1, _res2 := _rsa.EncryptPKCS1v15(rand, pub, msg)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateKey:
// func generateKey(random io.Reader, bits int) Object {
// 	_, _res2 := _rsa.GenerateKey(random, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.GenerateMultiPrimeKey:
// func generateMultiPrimeKey(random io.Reader, nprimes int, bits int) Object {
// 	_, _res2 := _rsa.GenerateMultiPrimeKey(random, nprimes, bits)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPKCS1v15:
// func signPKCS1v15(rand io.Reader, priv *crypto/rsa.PrivateKey, hash crypto.Hash, hashed []byte) Object {
// 	_res1, _res2 := _rsa.SignPKCS1v15(rand, priv, hash, hashed)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/rsa.SignPSS:
// func signPSS(rand io.Reader, priv *crypto/rsa.PrivateKey, hash crypto.Hash, hashed []byte, opts *crypto/rsa.PSSOptions) Object {
// 	_res1, _res2 := _rsa.SignPSS(rand, priv, hash, hashed, opts)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/sha1.New:
// func new() Object {
// 	return _sha1.New()
// }

GO FUNC crypto/sha1.Sum:
func sum(data []byte) Object {
	_res := _sha1.Sum(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha256.New:
// func new() Object {
// 	return _sha256.New()
// }

GO FUNC crypto/sha256.New224:
// func new224() Object {
// 	return _sha256.New224()
// }

GO FUNC crypto/sha256.Sum224:
func sum224(data []byte) Object {
	_res := _sha256.Sum224(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha256.Sum256:
func sum256(data []byte) Object {
	_res := _sha256.Sum256(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha512.New:
// func new() Object {
// 	return _sha512.New()
// }

GO FUNC crypto/sha512.New384:
// func new384() Object {
// 	return _sha512.New384()
// }

GO FUNC crypto/sha512.New512_224:
// func new512_224() Object {
// 	return _sha512.New512_224()
// }

GO FUNC crypto/sha512.New512_256:
// func new512_256() Object {
// 	return _sha512.New512_256()
// }

GO FUNC crypto/sha512.Sum384:
func sum384(data []byte) Object {
	_res := _sha512.Sum384(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha512.Sum512:
func sum512(data []byte) Object {
	_res := _sha512.Sum512(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha512.Sum512_224:
func sum512_224(data []byte) Object {
	_res := _sha512.Sum512_224(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/sha512.Sum512_256:
func sum512_256(data []byte) Object {
	_res := _sha512.Sum512_256(data)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC crypto/subtle.ConstantTimeCopy:
// func constantTimeCopy(v int, x []byte, y []byte) Object {
// 	_subtle.ConstantTimeCopy(v, x, y)
// 	...ABEND675: TODO...
// }

GO FUNC crypto/tls.Client:
// func client(conn net.Conn, config *crypto/tls.Config) Object {
// 	return _tls.Client(conn, config)
// 	ABEND124(no public information returned)
// }

GO FUNC crypto/tls.Dial:
// func dial(network string, addr string, config *crypto/tls.Config) Object {
// 	_, _res2 := _tls.Dial(network, addr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.DialWithDialer:
// func dialWithDialer(dialer *net.Dialer, network string, addr string, config *crypto/tls.Config) Object {
// 	_, _res2 := _tls.DialWithDialer(dialer, network, addr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.Listen:
// func listen(network string, laddr string, config *crypto/tls.Config) Object {
// 	_res1, _res2 := _tls.Listen(network, laddr, config)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.LoadX509KeyPair:
// func loadX509KeyPair(certFile string, keyFile string) Object {
// 	_res1, _res2 := _tls.LoadX509KeyPair(certFile, keyFile)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_vec2 := EmptyVector
// 	for _, _elem2 := range _res1.Certificate {
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range _elem2 {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_vec2 = _vec2.Conjoin(_vec3)
// 	}
// 	_map1.Add(MakeKeyword("Certificate"), _vec2)
// 	_map1.Add(MakeKeyword("PrivateKey"), _res1.PrivateKey)
// 	_vec4 := EmptyVector
// 	for _, _elem4 := range _res1.OCSPStaple {
// 		_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 	}
// 	_map1.Add(MakeKeyword("OCSPStaple"), _vec4)
// 	_vec5 := EmptyVector
// 	for _, _elem5 := range _res1.SignedCertificateTimestamps {
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range _elem5 {
// 			_vec6 = _vec6.Conjoin(MakeInt(int(_elem6)))
// 		}
// 		_vec5 = _vec5.Conjoin(_vec6)
// 	}
// 	_map1.Add(MakeKeyword("SignedCertificateTimestamps"), _vec5)
// 	var _obj_map7 Object
// 	if _res1.Leaf != nil {
// 		_map7 := EmptyArrayMap()
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1.Leaf).Raw {
// 			_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 		}
// 		_map7.Add(MakeKeyword("Raw"), _vec8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res1.Leaf).RawTBSCertificate {
// 			_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 		}
// 		_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1.Leaf).RawSubjectPublicKeyInfo {
// 			_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 		}
// 		_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1.Leaf).RawSubject {
// 			_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 		}
// 		_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1.Leaf).RawIssuer {
// 			_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 		}
// 		_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1.Leaf).Signature {
// 			_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 		}
// 		_map7.Add(MakeKeyword("Signature"), _vec13)
// 		_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_res1.Leaf).SignatureAlgorithm)
// 		_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_res1.Leaf).PublicKeyAlgorithm)
// 		_map7.Add(MakeKeyword("PublicKey"), (*_res1.Leaf).PublicKey)
// 		_map7.Add(MakeKeyword("Version"), MakeInt((*_res1.Leaf).Version))
// 		_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 		_map15 := EmptyArrayMap()
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1.Leaf).Issuer.Country {
// 			_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 		}
// 		_map15.Add(MakeKeyword("Country"), _vec16)
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1.Leaf).Issuer.Organization {
// 			_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 		}
// 		_map15.Add(MakeKeyword("Organization"), _vec17)
// 		_vec18 := EmptyVector
// 		for _, _elem18 := range (*_res1.Leaf).Issuer.OrganizationalUnit {
// 			_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 		}
// 		_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 		_vec19 := EmptyVector
// 		for _, _elem19 := range (*_res1.Leaf).Issuer.Locality {
// 			_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 		}
// 		_map15.Add(MakeKeyword("Locality"), _vec19)
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res1.Leaf).Issuer.Province {
// 			_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 		}
// 		_map15.Add(MakeKeyword("Province"), _vec20)
// 		_vec21 := EmptyVector
// 		for _, _elem21 := range (*_res1.Leaf).Issuer.StreetAddress {
// 			_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 		}
// 		_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1.Leaf).Issuer.PostalCode {
// 			_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 		}
// 		_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 		_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_res1.Leaf).Issuer.SerialNumber))
// 		_map15.Add(MakeKeyword("CommonName"), MakeString((*_res1.Leaf).Issuer.CommonName))
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res1.Leaf).Issuer.Names {
// 			_vec23 = _vec23.Conjoin(_elem23)
// 		}
// 		_map15.Add(MakeKeyword("Names"), _vec23)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1.Leaf).Issuer.ExtraNames {
// 			_vec24 = _vec24.Conjoin(_elem24)
// 		}
// 		_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 		_map7.Add(MakeKeyword("Issuer"), _map15)
// 		_map25 := EmptyArrayMap()
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1.Leaf).Subject.Country {
// 			_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 		}
// 		_map25.Add(MakeKeyword("Country"), _vec26)
// 		_vec27 := EmptyVector
// 		for _, _elem27 := range (*_res1.Leaf).Subject.Organization {
// 			_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 		}
// 		_map25.Add(MakeKeyword("Organization"), _vec27)
// 		_vec28 := EmptyVector
// 		for _, _elem28 := range (*_res1.Leaf).Subject.OrganizationalUnit {
// 			_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 		}
// 		_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 		_vec29 := EmptyVector
// 		for _, _elem29 := range (*_res1.Leaf).Subject.Locality {
// 			_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 		}
// 		_map25.Add(MakeKeyword("Locality"), _vec29)
// 		_vec30 := EmptyVector
// 		for _, _elem30 := range (*_res1.Leaf).Subject.Province {
// 			_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 		}
// 		_map25.Add(MakeKeyword("Province"), _vec30)
// 		_vec31 := EmptyVector
// 		for _, _elem31 := range (*_res1.Leaf).Subject.StreetAddress {
// 			_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 		}
// 		_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 		_vec32 := EmptyVector
// 		for _, _elem32 := range (*_res1.Leaf).Subject.PostalCode {
// 			_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 		}
// 		_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 		_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_res1.Leaf).Subject.SerialNumber))
// 		_map25.Add(MakeKeyword("CommonName"), MakeString((*_res1.Leaf).Subject.CommonName))
// 		_vec33 := EmptyVector
// 		for _, _elem33 := range (*_res1.Leaf).Subject.Names {
// 			_vec33 = _vec33.Conjoin(_elem33)
// 		}
// 		_map25.Add(MakeKeyword("Names"), _vec33)
// 		_vec34 := EmptyVector
// 		for _, _elem34 := range (*_res1.Leaf).Subject.ExtraNames {
// 			_vec34 = _vec34.Conjoin(_elem34)
// 		}
// 		_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 		_map7.Add(MakeKeyword("Subject"), _map25)
// 		_map7.Add(MakeKeyword("NotBefore"), NIL)
// 		_map7.Add(MakeKeyword("NotAfter"), NIL)
// 		_map7.Add(MakeKeyword("KeyUsage"), (*_res1.Leaf).KeyUsage)
// 		_vec37 := EmptyVector
// 		for _, _elem37 := range (*_res1.Leaf).Extensions {
// 			_map38 := EmptyArrayMap()
// 			_vec39 := EmptyVector
// 			for _, _elem39 := range _elem37.Id {
// 				_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 			}
// 			_map38.Add(MakeKeyword("Id"), _vec39)
// 			_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 			_vec40 := EmptyVector
// 			for _, _elem40 := range _elem37.Value {
// 				_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 			}
// 			_map38.Add(MakeKeyword("Value"), _vec40)
// 			_vec37 = _vec37.Conjoin(_map38)
// 		}
// 		_map7.Add(MakeKeyword("Extensions"), _vec37)
// 		_vec41 := EmptyVector
// 		for _, _elem41 := range (*_res1.Leaf).ExtraExtensions {
// 			_map42 := EmptyArrayMap()
// 			_vec43 := EmptyVector
// 			for _, _elem43 := range _elem41.Id {
// 				_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 			}
// 			_map42.Add(MakeKeyword("Id"), _vec43)
// 			_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 			_vec44 := EmptyVector
// 			for _, _elem44 := range _elem41.Value {
// 				_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 			}
// 			_map42.Add(MakeKeyword("Value"), _vec44)
// 			_vec41 = _vec41.Conjoin(_map42)
// 		}
// 		_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 		_vec45 := EmptyVector
// 		for _, _elem45 := range (*_res1.Leaf).UnhandledCriticalExtensions {
// 			_vec46 := EmptyVector
// 			for _, _elem46 := range _elem45 {
// 				_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 			}
// 			_vec45 = _vec45.Conjoin(_vec46)
// 		}
// 		_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 		_vec47 := EmptyVector
// 		for _, _elem47 := range (*_res1.Leaf).ExtKeyUsage {
// 			_vec47 = _vec47.Conjoin(_elem47)
// 		}
// 		_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 		_vec48 := EmptyVector
// 		for _, _elem48 := range (*_res1.Leaf).UnknownExtKeyUsage {
// 			_vec49 := EmptyVector
// 			for _, _elem49 := range _elem48 {
// 				_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 			}
// 			_vec48 = _vec48.Conjoin(_vec49)
// 		}
// 		_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 		_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_res1.Leaf).BasicConstraintsValid))
// 		_map7.Add(MakeKeyword("IsCA"), MakeBool((*_res1.Leaf).IsCA))
// 		_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_res1.Leaf).MaxPathLen))
// 		_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_res1.Leaf).MaxPathLenZero))
// 		_vec50 := EmptyVector
// 		for _, _elem50 := range (*_res1.Leaf).SubjectKeyId {
// 			_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 		}
// 		_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 		_vec51 := EmptyVector
// 		for _, _elem51 := range (*_res1.Leaf).AuthorityKeyId {
// 			_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 		}
// 		_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 		_vec52 := EmptyVector
// 		for _, _elem52 := range (*_res1.Leaf).OCSPServer {
// 			_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 		}
// 		_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 		_vec53 := EmptyVector
// 		for _, _elem53 := range (*_res1.Leaf).IssuingCertificateURL {
// 			_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 		}
// 		_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 		_vec54 := EmptyVector
// 		for _, _elem54 := range (*_res1.Leaf).DNSNames {
// 			_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 		}
// 		_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 		_vec55 := EmptyVector
// 		for _, _elem55 := range (*_res1.Leaf).EmailAddresses {
// 			_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 		}
// 		_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 		_vec56 := EmptyVector
// 		for _, _elem56 := range (*_res1.Leaf).IPAddresses {
// 			_vec57 := EmptyVector
// 			for _, _elem57 := range _elem56 {
// 				_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 			}
// 			_vec56 = _vec56.Conjoin(_vec57)
// 		}
// 		_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 		_vec58 := EmptyVector
// 		for _, _elem58 := range (*_res1.Leaf).URIs {
// 			var _obj_map59 Object
// 			if _elem58 != nil {
// 				_map59 := EmptyArrayMap()
// 				_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 				_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 				_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 				_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 				_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 				_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 				_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 				_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 				_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 				_obj_map59 = Object(_map59)
// 			} else {
// 				_obj_map59 = NIL
// 			}
// 			_vec58 = _vec58.Conjoin(_obj_map59)
// 		}
// 		_map7.Add(MakeKeyword("URIs"), _vec58)
// 		_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_res1.Leaf).PermittedDNSDomainsCritical))
// 		_vec60 := EmptyVector
// 		for _, _elem60 := range (*_res1.Leaf).PermittedDNSDomains {
// 			_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 		}
// 		_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 		_vec61 := EmptyVector
// 		for _, _elem61 := range (*_res1.Leaf).ExcludedDNSDomains {
// 			_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 		_vec62 := EmptyVector
// 		for _, _elem62 := range (*_res1.Leaf).PermittedIPRanges {
// 			var _obj_map63 Object
// 			if _elem62 != nil {
// 				_map63 := EmptyArrayMap()
// 				_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 				_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 				_obj_map63 = Object(_map63)
// 			} else {
// 				_obj_map63 = NIL
// 			}
// 			_vec62 = _vec62.Conjoin(_obj_map63)
// 		}
// 		_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 		_vec64 := EmptyVector
// 		for _, _elem64 := range (*_res1.Leaf).ExcludedIPRanges {
// 			var _obj_map65 Object
// 			if _elem64 != nil {
// 				_map65 := EmptyArrayMap()
// 				_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 				_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 				_obj_map65 = Object(_map65)
// 			} else {
// 				_obj_map65 = NIL
// 			}
// 			_vec64 = _vec64.Conjoin(_obj_map65)
// 		}
// 		_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 		_vec66 := EmptyVector
// 		for _, _elem66 := range (*_res1.Leaf).PermittedEmailAddresses {
// 			_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 		}
// 		_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 		_vec67 := EmptyVector
// 		for _, _elem67 := range (*_res1.Leaf).ExcludedEmailAddresses {
// 			_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 		_vec68 := EmptyVector
// 		for _, _elem68 := range (*_res1.Leaf).PermittedURIDomains {
// 			_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 		}
// 		_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 		_vec69 := EmptyVector
// 		for _, _elem69 := range (*_res1.Leaf).ExcludedURIDomains {
// 			_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 		_vec70 := EmptyVector
// 		for _, _elem70 := range (*_res1.Leaf).CRLDistributionPoints {
// 			_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 		}
// 		_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 		_vec71 := EmptyVector
// 		for _, _elem71 := range (*_res1.Leaf).PolicyIdentifiers {
// 			_vec72 := EmptyVector
// 			for _, _elem72 := range _elem71 {
// 				_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 			}
// 			_vec71 = _vec71.Conjoin(_vec72)
// 		}
// 		_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 		_obj_map7 = Object(_map7)
// 	} else {
// 		_obj_map7 = NIL
// 	}
// 	_map1.Add(MakeKeyword("Leaf"), _obj_map7)
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/tls.NewLRUClientSessionCache:
// func newLRUClientSessionCache(capacity int) Object {
// 	return _tls.NewLRUClientSessionCache(capacity)
// }

GO FUNC crypto/tls.NewListener:
// func newListener(inner net.Listener, config *crypto/tls.Config) Object {
// 	return _tls.NewListener(inner, config)
// }

GO FUNC crypto/tls.Server:
// func server(conn net.Conn, config *crypto/tls.Config) Object {
// 	return _tls.Server(conn, config)
// 	ABEND124(no public information returned)
// }

GO FUNC crypto/tls.X509KeyPair:
// func x509KeyPair(certPEMBlock []byte, keyPEMBlock []byte) Object {
// 	_res1, _res2 := _tls.X509KeyPair(certPEMBlock, keyPEMBlock)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_vec2 := EmptyVector
// 	for _, _elem2 := range _res1.Certificate {
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range _elem2 {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_vec2 = _vec2.Conjoin(_vec3)
// 	}
// 	_map1.Add(MakeKeyword("Certificate"), _vec2)
// 	_map1.Add(MakeKeyword("PrivateKey"), _res1.PrivateKey)
// 	_vec4 := EmptyVector
// 	for _, _elem4 := range _res1.OCSPStaple {
// 		_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 	}
// 	_map1.Add(MakeKeyword("OCSPStaple"), _vec4)
// 	_vec5 := EmptyVector
// 	for _, _elem5 := range _res1.SignedCertificateTimestamps {
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range _elem5 {
// 			_vec6 = _vec6.Conjoin(MakeInt(int(_elem6)))
// 		}
// 		_vec5 = _vec5.Conjoin(_vec6)
// 	}
// 	_map1.Add(MakeKeyword("SignedCertificateTimestamps"), _vec5)
// 	var _obj_map7 Object
// 	if _res1.Leaf != nil {
// 		_map7 := EmptyArrayMap()
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1.Leaf).Raw {
// 			_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 		}
// 		_map7.Add(MakeKeyword("Raw"), _vec8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res1.Leaf).RawTBSCertificate {
// 			_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 		}
// 		_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1.Leaf).RawSubjectPublicKeyInfo {
// 			_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 		}
// 		_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1.Leaf).RawSubject {
// 			_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 		}
// 		_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1.Leaf).RawIssuer {
// 			_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 		}
// 		_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1.Leaf).Signature {
// 			_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 		}
// 		_map7.Add(MakeKeyword("Signature"), _vec13)
// 		_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_res1.Leaf).SignatureAlgorithm)
// 		_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_res1.Leaf).PublicKeyAlgorithm)
// 		_map7.Add(MakeKeyword("PublicKey"), (*_res1.Leaf).PublicKey)
// 		_map7.Add(MakeKeyword("Version"), MakeInt((*_res1.Leaf).Version))
// 		_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 		_map15 := EmptyArrayMap()
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1.Leaf).Issuer.Country {
// 			_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 		}
// 		_map15.Add(MakeKeyword("Country"), _vec16)
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1.Leaf).Issuer.Organization {
// 			_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 		}
// 		_map15.Add(MakeKeyword("Organization"), _vec17)
// 		_vec18 := EmptyVector
// 		for _, _elem18 := range (*_res1.Leaf).Issuer.OrganizationalUnit {
// 			_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 		}
// 		_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 		_vec19 := EmptyVector
// 		for _, _elem19 := range (*_res1.Leaf).Issuer.Locality {
// 			_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 		}
// 		_map15.Add(MakeKeyword("Locality"), _vec19)
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res1.Leaf).Issuer.Province {
// 			_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 		}
// 		_map15.Add(MakeKeyword("Province"), _vec20)
// 		_vec21 := EmptyVector
// 		for _, _elem21 := range (*_res1.Leaf).Issuer.StreetAddress {
// 			_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 		}
// 		_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1.Leaf).Issuer.PostalCode {
// 			_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 		}
// 		_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 		_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_res1.Leaf).Issuer.SerialNumber))
// 		_map15.Add(MakeKeyword("CommonName"), MakeString((*_res1.Leaf).Issuer.CommonName))
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res1.Leaf).Issuer.Names {
// 			_vec23 = _vec23.Conjoin(_elem23)
// 		}
// 		_map15.Add(MakeKeyword("Names"), _vec23)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1.Leaf).Issuer.ExtraNames {
// 			_vec24 = _vec24.Conjoin(_elem24)
// 		}
// 		_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 		_map7.Add(MakeKeyword("Issuer"), _map15)
// 		_map25 := EmptyArrayMap()
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1.Leaf).Subject.Country {
// 			_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 		}
// 		_map25.Add(MakeKeyword("Country"), _vec26)
// 		_vec27 := EmptyVector
// 		for _, _elem27 := range (*_res1.Leaf).Subject.Organization {
// 			_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 		}
// 		_map25.Add(MakeKeyword("Organization"), _vec27)
// 		_vec28 := EmptyVector
// 		for _, _elem28 := range (*_res1.Leaf).Subject.OrganizationalUnit {
// 			_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 		}
// 		_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 		_vec29 := EmptyVector
// 		for _, _elem29 := range (*_res1.Leaf).Subject.Locality {
// 			_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 		}
// 		_map25.Add(MakeKeyword("Locality"), _vec29)
// 		_vec30 := EmptyVector
// 		for _, _elem30 := range (*_res1.Leaf).Subject.Province {
// 			_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 		}
// 		_map25.Add(MakeKeyword("Province"), _vec30)
// 		_vec31 := EmptyVector
// 		for _, _elem31 := range (*_res1.Leaf).Subject.StreetAddress {
// 			_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 		}
// 		_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 		_vec32 := EmptyVector
// 		for _, _elem32 := range (*_res1.Leaf).Subject.PostalCode {
// 			_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 		}
// 		_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 		_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_res1.Leaf).Subject.SerialNumber))
// 		_map25.Add(MakeKeyword("CommonName"), MakeString((*_res1.Leaf).Subject.CommonName))
// 		_vec33 := EmptyVector
// 		for _, _elem33 := range (*_res1.Leaf).Subject.Names {
// 			_vec33 = _vec33.Conjoin(_elem33)
// 		}
// 		_map25.Add(MakeKeyword("Names"), _vec33)
// 		_vec34 := EmptyVector
// 		for _, _elem34 := range (*_res1.Leaf).Subject.ExtraNames {
// 			_vec34 = _vec34.Conjoin(_elem34)
// 		}
// 		_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 		_map7.Add(MakeKeyword("Subject"), _map25)
// 		_map7.Add(MakeKeyword("NotBefore"), NIL)
// 		_map7.Add(MakeKeyword("NotAfter"), NIL)
// 		_map7.Add(MakeKeyword("KeyUsage"), (*_res1.Leaf).KeyUsage)
// 		_vec37 := EmptyVector
// 		for _, _elem37 := range (*_res1.Leaf).Extensions {
// 			_map38 := EmptyArrayMap()
// 			_vec39 := EmptyVector
// 			for _, _elem39 := range _elem37.Id {
// 				_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 			}
// 			_map38.Add(MakeKeyword("Id"), _vec39)
// 			_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 			_vec40 := EmptyVector
// 			for _, _elem40 := range _elem37.Value {
// 				_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 			}
// 			_map38.Add(MakeKeyword("Value"), _vec40)
// 			_vec37 = _vec37.Conjoin(_map38)
// 		}
// 		_map7.Add(MakeKeyword("Extensions"), _vec37)
// 		_vec41 := EmptyVector
// 		for _, _elem41 := range (*_res1.Leaf).ExtraExtensions {
// 			_map42 := EmptyArrayMap()
// 			_vec43 := EmptyVector
// 			for _, _elem43 := range _elem41.Id {
// 				_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 			}
// 			_map42.Add(MakeKeyword("Id"), _vec43)
// 			_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 			_vec44 := EmptyVector
// 			for _, _elem44 := range _elem41.Value {
// 				_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 			}
// 			_map42.Add(MakeKeyword("Value"), _vec44)
// 			_vec41 = _vec41.Conjoin(_map42)
// 		}
// 		_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 		_vec45 := EmptyVector
// 		for _, _elem45 := range (*_res1.Leaf).UnhandledCriticalExtensions {
// 			_vec46 := EmptyVector
// 			for _, _elem46 := range _elem45 {
// 				_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 			}
// 			_vec45 = _vec45.Conjoin(_vec46)
// 		}
// 		_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 		_vec47 := EmptyVector
// 		for _, _elem47 := range (*_res1.Leaf).ExtKeyUsage {
// 			_vec47 = _vec47.Conjoin(_elem47)
// 		}
// 		_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 		_vec48 := EmptyVector
// 		for _, _elem48 := range (*_res1.Leaf).UnknownExtKeyUsage {
// 			_vec49 := EmptyVector
// 			for _, _elem49 := range _elem48 {
// 				_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 			}
// 			_vec48 = _vec48.Conjoin(_vec49)
// 		}
// 		_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 		_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_res1.Leaf).BasicConstraintsValid))
// 		_map7.Add(MakeKeyword("IsCA"), MakeBool((*_res1.Leaf).IsCA))
// 		_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_res1.Leaf).MaxPathLen))
// 		_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_res1.Leaf).MaxPathLenZero))
// 		_vec50 := EmptyVector
// 		for _, _elem50 := range (*_res1.Leaf).SubjectKeyId {
// 			_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 		}
// 		_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 		_vec51 := EmptyVector
// 		for _, _elem51 := range (*_res1.Leaf).AuthorityKeyId {
// 			_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 		}
// 		_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 		_vec52 := EmptyVector
// 		for _, _elem52 := range (*_res1.Leaf).OCSPServer {
// 			_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 		}
// 		_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 		_vec53 := EmptyVector
// 		for _, _elem53 := range (*_res1.Leaf).IssuingCertificateURL {
// 			_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 		}
// 		_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 		_vec54 := EmptyVector
// 		for _, _elem54 := range (*_res1.Leaf).DNSNames {
// 			_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 		}
// 		_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 		_vec55 := EmptyVector
// 		for _, _elem55 := range (*_res1.Leaf).EmailAddresses {
// 			_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 		}
// 		_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 		_vec56 := EmptyVector
// 		for _, _elem56 := range (*_res1.Leaf).IPAddresses {
// 			_vec57 := EmptyVector
// 			for _, _elem57 := range _elem56 {
// 				_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 			}
// 			_vec56 = _vec56.Conjoin(_vec57)
// 		}
// 		_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 		_vec58 := EmptyVector
// 		for _, _elem58 := range (*_res1.Leaf).URIs {
// 			var _obj_map59 Object
// 			if _elem58 != nil {
// 				_map59 := EmptyArrayMap()
// 				_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 				_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 				_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 				_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 				_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 				_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 				_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 				_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 				_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 				_obj_map59 = Object(_map59)
// 			} else {
// 				_obj_map59 = NIL
// 			}
// 			_vec58 = _vec58.Conjoin(_obj_map59)
// 		}
// 		_map7.Add(MakeKeyword("URIs"), _vec58)
// 		_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_res1.Leaf).PermittedDNSDomainsCritical))
// 		_vec60 := EmptyVector
// 		for _, _elem60 := range (*_res1.Leaf).PermittedDNSDomains {
// 			_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 		}
// 		_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 		_vec61 := EmptyVector
// 		for _, _elem61 := range (*_res1.Leaf).ExcludedDNSDomains {
// 			_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 		_vec62 := EmptyVector
// 		for _, _elem62 := range (*_res1.Leaf).PermittedIPRanges {
// 			var _obj_map63 Object
// 			if _elem62 != nil {
// 				_map63 := EmptyArrayMap()
// 				_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 				_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 				_obj_map63 = Object(_map63)
// 			} else {
// 				_obj_map63 = NIL
// 			}
// 			_vec62 = _vec62.Conjoin(_obj_map63)
// 		}
// 		_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 		_vec64 := EmptyVector
// 		for _, _elem64 := range (*_res1.Leaf).ExcludedIPRanges {
// 			var _obj_map65 Object
// 			if _elem64 != nil {
// 				_map65 := EmptyArrayMap()
// 				_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 				_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 				_obj_map65 = Object(_map65)
// 			} else {
// 				_obj_map65 = NIL
// 			}
// 			_vec64 = _vec64.Conjoin(_obj_map65)
// 		}
// 		_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 		_vec66 := EmptyVector
// 		for _, _elem66 := range (*_res1.Leaf).PermittedEmailAddresses {
// 			_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 		}
// 		_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 		_vec67 := EmptyVector
// 		for _, _elem67 := range (*_res1.Leaf).ExcludedEmailAddresses {
// 			_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 		_vec68 := EmptyVector
// 		for _, _elem68 := range (*_res1.Leaf).PermittedURIDomains {
// 			_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 		}
// 		_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 		_vec69 := EmptyVector
// 		for _, _elem69 := range (*_res1.Leaf).ExcludedURIDomains {
// 			_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 		}
// 		_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 		_vec70 := EmptyVector
// 		for _, _elem70 := range (*_res1.Leaf).CRLDistributionPoints {
// 			_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 		}
// 		_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 		_vec71 := EmptyVector
// 		for _, _elem71 := range (*_res1.Leaf).PolicyIdentifiers {
// 			_vec72 := EmptyVector
// 			for _, _elem72 := range _elem71 {
// 				_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 			}
// 			_vec71 = _vec71.Conjoin(_vec72)
// 		}
// 		_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 		_obj_map7 = Object(_map7)
// 	} else {
// 		_obj_map7 = NIL
// 	}
// 	_map1.Add(MakeKeyword("Leaf"), _obj_map7)
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.CreateCertificate:
// func createCertificate(rand io.Reader, template *crypto/x509.Certificate, parent *crypto/x509.Certificate, pub interface {}, priv interface {}) Object {
// 	cert, err := _x509.CreateCertificate(rand, template, parent, pub, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range cert {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.CreateCertificateRequest:
// func createCertificateRequest(rand io.Reader, template *crypto/x509.CertificateRequest, priv interface {}) Object {
// 	csr, err := _x509.CreateCertificateRequest(rand, template, priv)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range csr {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.DecryptPEMBlock:
// func decryptPEMBlock(b *encoding/pem.Block, password []byte) Object {
// 	_res1, _res2 := _x509.DecryptPEMBlock(b, password)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.EncryptPEMBlock:
// func encryptPEMBlock(rand io.Reader, blockType string, data []byte, password []byte, alg crypto/x509.PEMCipher) Object {
// 	_res1, _res2 := _x509.EncryptPEMBlock(rand, blockType, data, password, alg)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Type"), MakeString((*_res1).Type))
// 		_map1.Add(MakeKeyword("Headers"), (*_res1).Headers)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Bytes {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_map1.Add(MakeKeyword("Bytes"), _vec2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalECPrivateKey:
// func marshalECPrivateKey(key *crypto/ecdsa.PrivateKey) Object {
// 	_res1, _res2 := _x509.MarshalECPrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKCS1PrivateKey:
// func marshalPKCS1PrivateKey(key *crypto/rsa.PrivateKey) Object {
// 	_res := _x509.MarshalPKCS1PrivateKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS1PublicKey:
// func marshalPKCS1PublicKey(key *crypto/rsa.PublicKey) Object {
// 	_res := _x509.MarshalPKCS1PublicKey(key)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC crypto/x509.MarshalPKCS8PrivateKey:
// func marshalPKCS8PrivateKey(key interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKCS8PrivateKey(key)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.MarshalPKIXPublicKey:
// func marshalPKIXPublicKey(pub interface {}) Object {
// 	_res1, _res2 := _x509.MarshalPKIXPublicKey(pub)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.NewCertPool:
// func newCertPool() Object {
// 	return _x509.NewCertPool()
// 	ABEND124(no public information returned)
// }

GO FUNC crypto/x509.ParseCRL:
// func parseCRL(crlBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseCRL(crlBytes)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("TBSCertList"), (*_res1).TBSCertList)
// 		_map1.Add(MakeKeyword("SignatureAlgorithm"), (*_res1).SignatureAlgorithm)
// 		_map2 := EmptyArrayMap()
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).SignatureValue.Bytes {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_map2.Add(MakeKeyword("Bytes"), _vec3)
// 		_map2.Add(MakeKeyword("BitLength"), MakeInt((*_res1).SignatureValue.BitLength))
// 		_map1.Add(MakeKeyword("SignatureValue"), _map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificate:
// func parseCertificate(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificate(asn1Data)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Raw {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_map1.Add(MakeKeyword("Raw"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).RawTBSCertificate {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_map1.Add(MakeKeyword("RawTBSCertificate"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res1).RawSubjectPublicKeyInfo {
// 			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 		}
// 		_map1.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res1).RawSubject {
// 			_vec5 = _vec5.Conjoin(MakeInt(int(_elem5)))
// 		}
// 		_map1.Add(MakeKeyword("RawSubject"), _vec5)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).RawIssuer {
// 			_vec6 = _vec6.Conjoin(MakeInt(int(_elem6)))
// 		}
// 		_map1.Add(MakeKeyword("RawIssuer"), _vec6)
// 		_vec7 := EmptyVector
// 		for _, _elem7 := range (*_res1).Signature {
// 			_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 		}
// 		_map1.Add(MakeKeyword("Signature"), _vec7)
// 		_map1.Add(MakeKeyword("SignatureAlgorithm"), MakeInt((*_res1).SignatureAlgorithm))
// 		_map1.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt((*_res1).PublicKeyAlgorithm))
// 		_map1.Add(MakeKeyword("PublicKey"), (*_res1).PublicKey)
// 		_map1.Add(MakeKeyword("Version"), MakeInt((*_res1).Version))
// 		_map1.Add(MakeKeyword("SerialNumber"), NIL)
// 		_map9 := EmptyArrayMap()
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1).Issuer.Country {
// 			_vec10 = _vec10.Conjoin(MakeString(_elem10))
// 		}
// 		_map9.Add(MakeKeyword("Country"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).Issuer.Organization {
// 			_vec11 = _vec11.Conjoin(MakeString(_elem11))
// 		}
// 		_map9.Add(MakeKeyword("Organization"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1).Issuer.OrganizationalUnit {
// 			_vec12 = _vec12.Conjoin(MakeString(_elem12))
// 		}
// 		_map9.Add(MakeKeyword("OrganizationalUnit"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1).Issuer.Locality {
// 			_vec13 = _vec13.Conjoin(MakeString(_elem13))
// 		}
// 		_map9.Add(MakeKeyword("Locality"), _vec13)
// 		_vec14 := EmptyVector
// 		for _, _elem14 := range (*_res1).Issuer.Province {
// 			_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 		}
// 		_map9.Add(MakeKeyword("Province"), _vec14)
// 		_vec15 := EmptyVector
// 		for _, _elem15 := range (*_res1).Issuer.StreetAddress {
// 			_vec15 = _vec15.Conjoin(MakeString(_elem15))
// 		}
// 		_map9.Add(MakeKeyword("StreetAddress"), _vec15)
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1).Issuer.PostalCode {
// 			_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 		}
// 		_map9.Add(MakeKeyword("PostalCode"), _vec16)
// 		_map9.Add(MakeKeyword("SerialNumber"), MakeString((*_res1).Issuer.SerialNumber))
// 		_map9.Add(MakeKeyword("CommonName"), MakeString((*_res1).Issuer.CommonName))
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1).Issuer.Names {
// 			_vec17 = _vec17.Conjoin(_elem17)
// 		}
// 		_map9.Add(MakeKeyword("Names"), _vec17)
// 		_vec18 := EmptyVector
// 		for _, _elem18 := range (*_res1).Issuer.ExtraNames {
// 			_vec18 = _vec18.Conjoin(_elem18)
// 		}
// 		_map9.Add(MakeKeyword("ExtraNames"), _vec18)
// 		_map1.Add(MakeKeyword("Issuer"), _map9)
// 		_map19 := EmptyArrayMap()
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res1).Subject.Country {
// 			_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 		}
// 		_map19.Add(MakeKeyword("Country"), _vec20)
// 		_vec21 := EmptyVector
// 		for _, _elem21 := range (*_res1).Subject.Organization {
// 			_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 		}
// 		_map19.Add(MakeKeyword("Organization"), _vec21)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1).Subject.OrganizationalUnit {
// 			_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 		}
// 		_map19.Add(MakeKeyword("OrganizationalUnit"), _vec22)
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res1).Subject.Locality {
// 			_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 		}
// 		_map19.Add(MakeKeyword("Locality"), _vec23)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1).Subject.Province {
// 			_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 		}
// 		_map19.Add(MakeKeyword("Province"), _vec24)
// 		_vec25 := EmptyVector
// 		for _, _elem25 := range (*_res1).Subject.StreetAddress {
// 			_vec25 = _vec25.Conjoin(MakeString(_elem25))
// 		}
// 		_map19.Add(MakeKeyword("StreetAddress"), _vec25)
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1).Subject.PostalCode {
// 			_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 		}
// 		_map19.Add(MakeKeyword("PostalCode"), _vec26)
// 		_map19.Add(MakeKeyword("SerialNumber"), MakeString((*_res1).Subject.SerialNumber))
// 		_map19.Add(MakeKeyword("CommonName"), MakeString((*_res1).Subject.CommonName))
// 		_vec27 := EmptyVector
// 		for _, _elem27 := range (*_res1).Subject.Names {
// 			_vec27 = _vec27.Conjoin(_elem27)
// 		}
// 		_map19.Add(MakeKeyword("Names"), _vec27)
// 		_vec28 := EmptyVector
// 		for _, _elem28 := range (*_res1).Subject.ExtraNames {
// 			_vec28 = _vec28.Conjoin(_elem28)
// 		}
// 		_map19.Add(MakeKeyword("ExtraNames"), _vec28)
// 		_map1.Add(MakeKeyword("Subject"), _map19)
// 		_map1.Add(MakeKeyword("NotBefore"), NIL)
// 		_map1.Add(MakeKeyword("NotAfter"), NIL)
// 		_map1.Add(MakeKeyword("KeyUsage"), MakeInt((*_res1).KeyUsage))
// 		_vec31 := EmptyVector
// 		for _, _elem31 := range (*_res1).Extensions {
// 			_map32 := EmptyArrayMap()
// 			_vec33 := EmptyVector
// 			for _, _elem33 := range _elem31.Id {
// 				_vec33 = _vec33.Conjoin(MakeInt(_elem33))
// 			}
// 			_map32.Add(MakeKeyword("Id"), _vec33)
// 			_map32.Add(MakeKeyword("Critical"), MakeBool(_elem31.Critical))
// 			_vec34 := EmptyVector
// 			for _, _elem34 := range _elem31.Value {
// 				_vec34 = _vec34.Conjoin(MakeInt(int(_elem34)))
// 			}
// 			_map32.Add(MakeKeyword("Value"), _vec34)
// 			_vec31 = _vec31.Conjoin(_map32)
// 		}
// 		_map1.Add(MakeKeyword("Extensions"), _vec31)
// 		_vec35 := EmptyVector
// 		for _, _elem35 := range (*_res1).ExtraExtensions {
// 			_map36 := EmptyArrayMap()
// 			_vec37 := EmptyVector
// 			for _, _elem37 := range _elem35.Id {
// 				_vec37 = _vec37.Conjoin(MakeInt(_elem37))
// 			}
// 			_map36.Add(MakeKeyword("Id"), _vec37)
// 			_map36.Add(MakeKeyword("Critical"), MakeBool(_elem35.Critical))
// 			_vec38 := EmptyVector
// 			for _, _elem38 := range _elem35.Value {
// 				_vec38 = _vec38.Conjoin(MakeInt(int(_elem38)))
// 			}
// 			_map36.Add(MakeKeyword("Value"), _vec38)
// 			_vec35 = _vec35.Conjoin(_map36)
// 		}
// 		_map1.Add(MakeKeyword("ExtraExtensions"), _vec35)
// 		_vec39 := EmptyVector
// 		for _, _elem39 := range (*_res1).UnhandledCriticalExtensions {
// 			_vec40 := EmptyVector
// 			for _, _elem40 := range _elem39 {
// 				_vec40 = _vec40.Conjoin(MakeInt(_elem40))
// 			}
// 			_vec39 = _vec39.Conjoin(_vec40)
// 		}
// 		_map1.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec39)
// 		_vec41 := EmptyVector
// 		for _, _elem41 := range (*_res1).ExtKeyUsage {
// 			_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 		}
// 		_map1.Add(MakeKeyword("ExtKeyUsage"), _vec41)
// 		_vec42 := EmptyVector
// 		for _, _elem42 := range (*_res1).UnknownExtKeyUsage {
// 			_vec43 := EmptyVector
// 			for _, _elem43 := range _elem42 {
// 				_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 			}
// 			_vec42 = _vec42.Conjoin(_vec43)
// 		}
// 		_map1.Add(MakeKeyword("UnknownExtKeyUsage"), _vec42)
// 		_map1.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_res1).BasicConstraintsValid))
// 		_map1.Add(MakeKeyword("IsCA"), MakeBool((*_res1).IsCA))
// 		_map1.Add(MakeKeyword("MaxPathLen"), MakeInt((*_res1).MaxPathLen))
// 		_map1.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_res1).MaxPathLenZero))
// 		_vec44 := EmptyVector
// 		for _, _elem44 := range (*_res1).SubjectKeyId {
// 			_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 		}
// 		_map1.Add(MakeKeyword("SubjectKeyId"), _vec44)
// 		_vec45 := EmptyVector
// 		for _, _elem45 := range (*_res1).AuthorityKeyId {
// 			_vec45 = _vec45.Conjoin(MakeInt(int(_elem45)))
// 		}
// 		_map1.Add(MakeKeyword("AuthorityKeyId"), _vec45)
// 		_vec46 := EmptyVector
// 		for _, _elem46 := range (*_res1).OCSPServer {
// 			_vec46 = _vec46.Conjoin(MakeString(_elem46))
// 		}
// 		_map1.Add(MakeKeyword("OCSPServer"), _vec46)
// 		_vec47 := EmptyVector
// 		for _, _elem47 := range (*_res1).IssuingCertificateURL {
// 			_vec47 = _vec47.Conjoin(MakeString(_elem47))
// 		}
// 		_map1.Add(MakeKeyword("IssuingCertificateURL"), _vec47)
// 		_vec48 := EmptyVector
// 		for _, _elem48 := range (*_res1).DNSNames {
// 			_vec48 = _vec48.Conjoin(MakeString(_elem48))
// 		}
// 		_map1.Add(MakeKeyword("DNSNames"), _vec48)
// 		_vec49 := EmptyVector
// 		for _, _elem49 := range (*_res1).EmailAddresses {
// 			_vec49 = _vec49.Conjoin(MakeString(_elem49))
// 		}
// 		_map1.Add(MakeKeyword("EmailAddresses"), _vec49)
// 		_vec50 := EmptyVector
// 		for _, _elem50 := range (*_res1).IPAddresses {
// 			_vec51 := EmptyVector
// 			for _, _elem51 := range _elem50 {
// 				_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 			}
// 			_vec50 = _vec50.Conjoin(_vec51)
// 		}
// 		_map1.Add(MakeKeyword("IPAddresses"), _vec50)
// 		_vec52 := EmptyVector
// 		for _, _elem52 := range (*_res1).URIs {
// 			var _obj_map53 Object
// 			if _elem52 != nil {
// 				_map53 := EmptyArrayMap()
// 				_map53.Add(MakeKeyword("Scheme"), MakeString((*_elem52).Scheme))
// 				_map53.Add(MakeKeyword("Opaque"), MakeString((*_elem52).Opaque))
// 				_map53.Add(MakeKeyword("User"), (*(*_elem52).User))
// 				_map53.Add(MakeKeyword("Host"), MakeString((*_elem52).Host))
// 				_map53.Add(MakeKeyword("Path"), MakeString((*_elem52).Path))
// 				_map53.Add(MakeKeyword("RawPath"), MakeString((*_elem52).RawPath))
// 				_map53.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem52).ForceQuery))
// 				_map53.Add(MakeKeyword("RawQuery"), MakeString((*_elem52).RawQuery))
// 				_map53.Add(MakeKeyword("Fragment"), MakeString((*_elem52).Fragment))
// 				_obj_map53 = Object(_map53)
// 			} else {
// 				_obj_map53 = NIL
// 			}
// 			_vec52 = _vec52.Conjoin(_obj_map53)
// 		}
// 		_map1.Add(MakeKeyword("URIs"), _vec52)
// 		_map1.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_res1).PermittedDNSDomainsCritical))
// 		_vec54 := EmptyVector
// 		for _, _elem54 := range (*_res1).PermittedDNSDomains {
// 			_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 		}
// 		_map1.Add(MakeKeyword("PermittedDNSDomains"), _vec54)
// 		_vec55 := EmptyVector
// 		for _, _elem55 := range (*_res1).ExcludedDNSDomains {
// 			_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 		}
// 		_map1.Add(MakeKeyword("ExcludedDNSDomains"), _vec55)
// 		_vec56 := EmptyVector
// 		for _, _elem56 := range (*_res1).PermittedIPRanges {
// 			var _obj_map57 Object
// 			if _elem56 != nil {
// 				_map57 := EmptyArrayMap()
// 				_map57.Add(MakeKeyword("IP"), (*_elem56).IP)
// 				_map57.Add(MakeKeyword("Mask"), (*_elem56).Mask)
// 				_obj_map57 = Object(_map57)
// 			} else {
// 				_obj_map57 = NIL
// 			}
// 			_vec56 = _vec56.Conjoin(_obj_map57)
// 		}
// 		_map1.Add(MakeKeyword("PermittedIPRanges"), _vec56)
// 		_vec58 := EmptyVector
// 		for _, _elem58 := range (*_res1).ExcludedIPRanges {
// 			var _obj_map59 Object
// 			if _elem58 != nil {
// 				_map59 := EmptyArrayMap()
// 				_map59.Add(MakeKeyword("IP"), (*_elem58).IP)
// 				_map59.Add(MakeKeyword("Mask"), (*_elem58).Mask)
// 				_obj_map59 = Object(_map59)
// 			} else {
// 				_obj_map59 = NIL
// 			}
// 			_vec58 = _vec58.Conjoin(_obj_map59)
// 		}
// 		_map1.Add(MakeKeyword("ExcludedIPRanges"), _vec58)
// 		_vec60 := EmptyVector
// 		for _, _elem60 := range (*_res1).PermittedEmailAddresses {
// 			_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 		}
// 		_map1.Add(MakeKeyword("PermittedEmailAddresses"), _vec60)
// 		_vec61 := EmptyVector
// 		for _, _elem61 := range (*_res1).ExcludedEmailAddresses {
// 			_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 		}
// 		_map1.Add(MakeKeyword("ExcludedEmailAddresses"), _vec61)
// 		_vec62 := EmptyVector
// 		for _, _elem62 := range (*_res1).PermittedURIDomains {
// 			_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 		}
// 		_map1.Add(MakeKeyword("PermittedURIDomains"), _vec62)
// 		_vec63 := EmptyVector
// 		for _, _elem63 := range (*_res1).ExcludedURIDomains {
// 			_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 		}
// 		_map1.Add(MakeKeyword("ExcludedURIDomains"), _vec63)
// 		_vec64 := EmptyVector
// 		for _, _elem64 := range (*_res1).CRLDistributionPoints {
// 			_vec64 = _vec64.Conjoin(MakeString(_elem64))
// 		}
// 		_map1.Add(MakeKeyword("CRLDistributionPoints"), _vec64)
// 		_vec65 := EmptyVector
// 		for _, _elem65 := range (*_res1).PolicyIdentifiers {
// 			_vec66 := EmptyVector
// 			for _, _elem66 := range _elem65 {
// 				_vec66 = _vec66.Conjoin(MakeInt(_elem66))
// 			}
// 			_vec65 = _vec65.Conjoin(_vec66)
// 		}
// 		_map1.Add(MakeKeyword("PolicyIdentifiers"), _vec65)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificateRequest:
// func parseCertificateRequest(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificateRequest(asn1Data)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Raw {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_map1.Add(MakeKeyword("Raw"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).RawTBSCertificateRequest {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_map1.Add(MakeKeyword("RawTBSCertificateRequest"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res1).RawSubjectPublicKeyInfo {
// 			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 		}
// 		_map1.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res1).RawSubject {
// 			_vec5 = _vec5.Conjoin(MakeInt(int(_elem5)))
// 		}
// 		_map1.Add(MakeKeyword("RawSubject"), _vec5)
// 		_map1.Add(MakeKeyword("Version"), MakeInt((*_res1).Version))
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).Signature {
// 			_vec6 = _vec6.Conjoin(MakeInt(int(_elem6)))
// 		}
// 		_map1.Add(MakeKeyword("Signature"), _vec6)
// 		_map1.Add(MakeKeyword("SignatureAlgorithm"), MakeInt((*_res1).SignatureAlgorithm))
// 		_map1.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt((*_res1).PublicKeyAlgorithm))
// 		_map1.Add(MakeKeyword("PublicKey"), (*_res1).PublicKey)
// 		_map7 := EmptyArrayMap()
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1).Subject.Country {
// 			_vec8 = _vec8.Conjoin(MakeString(_elem8))
// 		}
// 		_map7.Add(MakeKeyword("Country"), _vec8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res1).Subject.Organization {
// 			_vec9 = _vec9.Conjoin(MakeString(_elem9))
// 		}
// 		_map7.Add(MakeKeyword("Organization"), _vec9)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1).Subject.OrganizationalUnit {
// 			_vec10 = _vec10.Conjoin(MakeString(_elem10))
// 		}
// 		_map7.Add(MakeKeyword("OrganizationalUnit"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).Subject.Locality {
// 			_vec11 = _vec11.Conjoin(MakeString(_elem11))
// 		}
// 		_map7.Add(MakeKeyword("Locality"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1).Subject.Province {
// 			_vec12 = _vec12.Conjoin(MakeString(_elem12))
// 		}
// 		_map7.Add(MakeKeyword("Province"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1).Subject.StreetAddress {
// 			_vec13 = _vec13.Conjoin(MakeString(_elem13))
// 		}
// 		_map7.Add(MakeKeyword("StreetAddress"), _vec13)
// 		_vec14 := EmptyVector
// 		for _, _elem14 := range (*_res1).Subject.PostalCode {
// 			_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 		}
// 		_map7.Add(MakeKeyword("PostalCode"), _vec14)
// 		_map7.Add(MakeKeyword("SerialNumber"), MakeString((*_res1).Subject.SerialNumber))
// 		_map7.Add(MakeKeyword("CommonName"), MakeString((*_res1).Subject.CommonName))
// 		_vec15 := EmptyVector
// 		for _, _elem15 := range (*_res1).Subject.Names {
// 			_vec15 = _vec15.Conjoin(_elem15)
// 		}
// 		_map7.Add(MakeKeyword("Names"), _vec15)
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1).Subject.ExtraNames {
// 			_vec16 = _vec16.Conjoin(_elem16)
// 		}
// 		_map7.Add(MakeKeyword("ExtraNames"), _vec16)
// 		_map1.Add(MakeKeyword("Subject"), _map7)
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1).Attributes {
// 			_map18 := EmptyArrayMap()
// 			_vec19 := EmptyVector
// 			for _, _elem19 := range _elem17.Type {
// 				_vec19 = _vec19.Conjoin(MakeInt(_elem19))
// 			}
// 			_map18.Add(MakeKeyword("Type"), _vec19)
// 			_vec20 := EmptyVector
// 			for _, _elem20 := range _elem17.Value {
// 				_vec21 := EmptyVector
// 				for _, _elem21 := range _elem20 {
// 					_vec21 = _vec21.Conjoin(_elem21)
// 				}
// 				_vec20 = _vec20.Conjoin(_vec21)
// 			}
// 			_map18.Add(MakeKeyword("Value"), _vec20)
// 			_vec17 = _vec17.Conjoin(_map18)
// 		}
// 		_map1.Add(MakeKeyword("Attributes"), _vec17)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1).Extensions {
// 			_map23 := EmptyArrayMap()
// 			_vec24 := EmptyVector
// 			for _, _elem24 := range _elem22.Id {
// 				_vec24 = _vec24.Conjoin(MakeInt(_elem24))
// 			}
// 			_map23.Add(MakeKeyword("Id"), _vec24)
// 			_map23.Add(MakeKeyword("Critical"), MakeBool(_elem22.Critical))
// 			_vec25 := EmptyVector
// 			for _, _elem25 := range _elem22.Value {
// 				_vec25 = _vec25.Conjoin(MakeInt(int(_elem25)))
// 			}
// 			_map23.Add(MakeKeyword("Value"), _vec25)
// 			_vec22 = _vec22.Conjoin(_map23)
// 		}
// 		_map1.Add(MakeKeyword("Extensions"), _vec22)
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1).ExtraExtensions {
// 			_map27 := EmptyArrayMap()
// 			_vec28 := EmptyVector
// 			for _, _elem28 := range _elem26.Id {
// 				_vec28 = _vec28.Conjoin(MakeInt(_elem28))
// 			}
// 			_map27.Add(MakeKeyword("Id"), _vec28)
// 			_map27.Add(MakeKeyword("Critical"), MakeBool(_elem26.Critical))
// 			_vec29 := EmptyVector
// 			for _, _elem29 := range _elem26.Value {
// 				_vec29 = _vec29.Conjoin(MakeInt(int(_elem29)))
// 			}
// 			_map27.Add(MakeKeyword("Value"), _vec29)
// 			_vec26 = _vec26.Conjoin(_map27)
// 		}
// 		_map1.Add(MakeKeyword("ExtraExtensions"), _vec26)
// 		_vec30 := EmptyVector
// 		for _, _elem30 := range (*_res1).DNSNames {
// 			_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 		}
// 		_map1.Add(MakeKeyword("DNSNames"), _vec30)
// 		_vec31 := EmptyVector
// 		for _, _elem31 := range (*_res1).EmailAddresses {
// 			_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 		}
// 		_map1.Add(MakeKeyword("EmailAddresses"), _vec31)
// 		_vec32 := EmptyVector
// 		for _, _elem32 := range (*_res1).IPAddresses {
// 			_vec33 := EmptyVector
// 			for _, _elem33 := range _elem32 {
// 				_vec33 = _vec33.Conjoin(MakeInt(int(_elem33)))
// 			}
// 			_vec32 = _vec32.Conjoin(_vec33)
// 		}
// 		_map1.Add(MakeKeyword("IPAddresses"), _vec32)
// 		_vec34 := EmptyVector
// 		for _, _elem34 := range (*_res1).URIs {
// 			var _obj_map35 Object
// 			if _elem34 != nil {
// 				_map35 := EmptyArrayMap()
// 				_map35.Add(MakeKeyword("Scheme"), MakeString((*_elem34).Scheme))
// 				_map35.Add(MakeKeyword("Opaque"), MakeString((*_elem34).Opaque))
// 				_map35.Add(MakeKeyword("User"), (*(*_elem34).User))
// 				_map35.Add(MakeKeyword("Host"), MakeString((*_elem34).Host))
// 				_map35.Add(MakeKeyword("Path"), MakeString((*_elem34).Path))
// 				_map35.Add(MakeKeyword("RawPath"), MakeString((*_elem34).RawPath))
// 				_map35.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem34).ForceQuery))
// 				_map35.Add(MakeKeyword("RawQuery"), MakeString((*_elem34).RawQuery))
// 				_map35.Add(MakeKeyword("Fragment"), MakeString((*_elem34).Fragment))
// 				_obj_map35 = Object(_map35)
// 			} else {
// 				_obj_map35 = NIL
// 			}
// 			_vec34 = _vec34.Conjoin(_obj_map35)
// 		}
// 		_map1.Add(MakeKeyword("URIs"), _vec34)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseCertificates:
// func parseCertificates(asn1Data []byte) Object {
// 	_res1, _res2 := _x509.ParseCertificates(asn1Data)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		var _obj_map2 Object
// 		if _elem1 != nil {
// 			_map2 := EmptyArrayMap()
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*_elem1).Raw {
// 				_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 			}
// 			_map2.Add(MakeKeyword("Raw"), _vec3)
// 			_vec4 := EmptyVector
// 			for _, _elem4 := range (*_elem1).RawTBSCertificate {
// 				_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 			}
// 			_map2.Add(MakeKeyword("RawTBSCertificate"), _vec4)
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*_elem1).RawSubjectPublicKeyInfo {
// 				_vec5 = _vec5.Conjoin(MakeInt(int(_elem5)))
// 			}
// 			_map2.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec5)
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*_elem1).RawSubject {
// 				_vec6 = _vec6.Conjoin(MakeInt(int(_elem6)))
// 			}
// 			_map2.Add(MakeKeyword("RawSubject"), _vec6)
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*_elem1).RawIssuer {
// 				_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 			}
// 			_map2.Add(MakeKeyword("RawIssuer"), _vec7)
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*_elem1).Signature {
// 				_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 			}
// 			_map2.Add(MakeKeyword("Signature"), _vec8)
// 			_map2.Add(MakeKeyword("SignatureAlgorithm"), MakeInt((*_elem1).SignatureAlgorithm))
// 			_map2.Add(MakeKeyword("PublicKeyAlgorithm"), MakeInt((*_elem1).PublicKeyAlgorithm))
// 			_map2.Add(MakeKeyword("PublicKey"), (*_elem1).PublicKey)
// 			_map2.Add(MakeKeyword("Version"), MakeInt((*_elem1).Version))
// 			_map2.Add(MakeKeyword("SerialNumber"), NIL)
// 			_map10 := EmptyArrayMap()
// 			_vec11 := EmptyVector
// 			for _, _elem11 := range (*_elem1).Issuer.Country {
// 				_vec11 = _vec11.Conjoin(MakeString(_elem11))
// 			}
// 			_map10.Add(MakeKeyword("Country"), _vec11)
// 			_vec12 := EmptyVector
// 			for _, _elem12 := range (*_elem1).Issuer.Organization {
// 				_vec12 = _vec12.Conjoin(MakeString(_elem12))
// 			}
// 			_map10.Add(MakeKeyword("Organization"), _vec12)
// 			_vec13 := EmptyVector
// 			for _, _elem13 := range (*_elem1).Issuer.OrganizationalUnit {
// 				_vec13 = _vec13.Conjoin(MakeString(_elem13))
// 			}
// 			_map10.Add(MakeKeyword("OrganizationalUnit"), _vec13)
// 			_vec14 := EmptyVector
// 			for _, _elem14 := range (*_elem1).Issuer.Locality {
// 				_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 			}
// 			_map10.Add(MakeKeyword("Locality"), _vec14)
// 			_vec15 := EmptyVector
// 			for _, _elem15 := range (*_elem1).Issuer.Province {
// 				_vec15 = _vec15.Conjoin(MakeString(_elem15))
// 			}
// 			_map10.Add(MakeKeyword("Province"), _vec15)
// 			_vec16 := EmptyVector
// 			for _, _elem16 := range (*_elem1).Issuer.StreetAddress {
// 				_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 			}
// 			_map10.Add(MakeKeyword("StreetAddress"), _vec16)
// 			_vec17 := EmptyVector
// 			for _, _elem17 := range (*_elem1).Issuer.PostalCode {
// 				_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 			}
// 			_map10.Add(MakeKeyword("PostalCode"), _vec17)
// 			_map10.Add(MakeKeyword("SerialNumber"), MakeString((*_elem1).Issuer.SerialNumber))
// 			_map10.Add(MakeKeyword("CommonName"), MakeString((*_elem1).Issuer.CommonName))
// 			_vec18 := EmptyVector
// 			for _, _elem18 := range (*_elem1).Issuer.Names {
// 				_vec18 = _vec18.Conjoin(_elem18)
// 			}
// 			_map10.Add(MakeKeyword("Names"), _vec18)
// 			_vec19 := EmptyVector
// 			for _, _elem19 := range (*_elem1).Issuer.ExtraNames {
// 				_vec19 = _vec19.Conjoin(_elem19)
// 			}
// 			_map10.Add(MakeKeyword("ExtraNames"), _vec19)
// 			_map2.Add(MakeKeyword("Issuer"), _map10)
// 			_map20 := EmptyArrayMap()
// 			_vec21 := EmptyVector
// 			for _, _elem21 := range (*_elem1).Subject.Country {
// 				_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 			}
// 			_map20.Add(MakeKeyword("Country"), _vec21)
// 			_vec22 := EmptyVector
// 			for _, _elem22 := range (*_elem1).Subject.Organization {
// 				_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 			}
// 			_map20.Add(MakeKeyword("Organization"), _vec22)
// 			_vec23 := EmptyVector
// 			for _, _elem23 := range (*_elem1).Subject.OrganizationalUnit {
// 				_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 			}
// 			_map20.Add(MakeKeyword("OrganizationalUnit"), _vec23)
// 			_vec24 := EmptyVector
// 			for _, _elem24 := range (*_elem1).Subject.Locality {
// 				_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 			}
// 			_map20.Add(MakeKeyword("Locality"), _vec24)
// 			_vec25 := EmptyVector
// 			for _, _elem25 := range (*_elem1).Subject.Province {
// 				_vec25 = _vec25.Conjoin(MakeString(_elem25))
// 			}
// 			_map20.Add(MakeKeyword("Province"), _vec25)
// 			_vec26 := EmptyVector
// 			for _, _elem26 := range (*_elem1).Subject.StreetAddress {
// 				_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 			}
// 			_map20.Add(MakeKeyword("StreetAddress"), _vec26)
// 			_vec27 := EmptyVector
// 			for _, _elem27 := range (*_elem1).Subject.PostalCode {
// 				_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 			}
// 			_map20.Add(MakeKeyword("PostalCode"), _vec27)
// 			_map20.Add(MakeKeyword("SerialNumber"), MakeString((*_elem1).Subject.SerialNumber))
// 			_map20.Add(MakeKeyword("CommonName"), MakeString((*_elem1).Subject.CommonName))
// 			_vec28 := EmptyVector
// 			for _, _elem28 := range (*_elem1).Subject.Names {
// 				_vec28 = _vec28.Conjoin(_elem28)
// 			}
// 			_map20.Add(MakeKeyword("Names"), _vec28)
// 			_vec29 := EmptyVector
// 			for _, _elem29 := range (*_elem1).Subject.ExtraNames {
// 				_vec29 = _vec29.Conjoin(_elem29)
// 			}
// 			_map20.Add(MakeKeyword("ExtraNames"), _vec29)
// 			_map2.Add(MakeKeyword("Subject"), _map20)
// 			_map2.Add(MakeKeyword("NotBefore"), NIL)
// 			_map2.Add(MakeKeyword("NotAfter"), NIL)
// 			_map2.Add(MakeKeyword("KeyUsage"), MakeInt((*_elem1).KeyUsage))
// 			_vec32 := EmptyVector
// 			for _, _elem32 := range (*_elem1).Extensions {
// 				_map33 := EmptyArrayMap()
// 				_vec34 := EmptyVector
// 				for _, _elem34 := range _elem32.Id {
// 					_vec34 = _vec34.Conjoin(MakeInt(_elem34))
// 				}
// 				_map33.Add(MakeKeyword("Id"), _vec34)
// 				_map33.Add(MakeKeyword("Critical"), MakeBool(_elem32.Critical))
// 				_vec35 := EmptyVector
// 				for _, _elem35 := range _elem32.Value {
// 					_vec35 = _vec35.Conjoin(MakeInt(int(_elem35)))
// 				}
// 				_map33.Add(MakeKeyword("Value"), _vec35)
// 				_vec32 = _vec32.Conjoin(_map33)
// 			}
// 			_map2.Add(MakeKeyword("Extensions"), _vec32)
// 			_vec36 := EmptyVector
// 			for _, _elem36 := range (*_elem1).ExtraExtensions {
// 				_map37 := EmptyArrayMap()
// 				_vec38 := EmptyVector
// 				for _, _elem38 := range _elem36.Id {
// 					_vec38 = _vec38.Conjoin(MakeInt(_elem38))
// 				}
// 				_map37.Add(MakeKeyword("Id"), _vec38)
// 				_map37.Add(MakeKeyword("Critical"), MakeBool(_elem36.Critical))
// 				_vec39 := EmptyVector
// 				for _, _elem39 := range _elem36.Value {
// 					_vec39 = _vec39.Conjoin(MakeInt(int(_elem39)))
// 				}
// 				_map37.Add(MakeKeyword("Value"), _vec39)
// 				_vec36 = _vec36.Conjoin(_map37)
// 			}
// 			_map2.Add(MakeKeyword("ExtraExtensions"), _vec36)
// 			_vec40 := EmptyVector
// 			for _, _elem40 := range (*_elem1).UnhandledCriticalExtensions {
// 				_vec41 := EmptyVector
// 				for _, _elem41 := range _elem40 {
// 					_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 				}
// 				_vec40 = _vec40.Conjoin(_vec41)
// 			}
// 			_map2.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec40)
// 			_vec42 := EmptyVector
// 			for _, _elem42 := range (*_elem1).ExtKeyUsage {
// 				_vec42 = _vec42.Conjoin(MakeInt(_elem42))
// 			}
// 			_map2.Add(MakeKeyword("ExtKeyUsage"), _vec42)
// 			_vec43 := EmptyVector
// 			for _, _elem43 := range (*_elem1).UnknownExtKeyUsage {
// 				_vec44 := EmptyVector
// 				for _, _elem44 := range _elem43 {
// 					_vec44 = _vec44.Conjoin(MakeInt(_elem44))
// 				}
// 				_vec43 = _vec43.Conjoin(_vec44)
// 			}
// 			_map2.Add(MakeKeyword("UnknownExtKeyUsage"), _vec43)
// 			_map2.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem1).BasicConstraintsValid))
// 			_map2.Add(MakeKeyword("IsCA"), MakeBool((*_elem1).IsCA))
// 			_map2.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem1).MaxPathLen))
// 			_map2.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem1).MaxPathLenZero))
// 			_vec45 := EmptyVector
// 			for _, _elem45 := range (*_elem1).SubjectKeyId {
// 				_vec45 = _vec45.Conjoin(MakeInt(int(_elem45)))
// 			}
// 			_map2.Add(MakeKeyword("SubjectKeyId"), _vec45)
// 			_vec46 := EmptyVector
// 			for _, _elem46 := range (*_elem1).AuthorityKeyId {
// 				_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 			}
// 			_map2.Add(MakeKeyword("AuthorityKeyId"), _vec46)
// 			_vec47 := EmptyVector
// 			for _, _elem47 := range (*_elem1).OCSPServer {
// 				_vec47 = _vec47.Conjoin(MakeString(_elem47))
// 			}
// 			_map2.Add(MakeKeyword("OCSPServer"), _vec47)
// 			_vec48 := EmptyVector
// 			for _, _elem48 := range (*_elem1).IssuingCertificateURL {
// 				_vec48 = _vec48.Conjoin(MakeString(_elem48))
// 			}
// 			_map2.Add(MakeKeyword("IssuingCertificateURL"), _vec48)
// 			_vec49 := EmptyVector
// 			for _, _elem49 := range (*_elem1).DNSNames {
// 				_vec49 = _vec49.Conjoin(MakeString(_elem49))
// 			}
// 			_map2.Add(MakeKeyword("DNSNames"), _vec49)
// 			_vec50 := EmptyVector
// 			for _, _elem50 := range (*_elem1).EmailAddresses {
// 				_vec50 = _vec50.Conjoin(MakeString(_elem50))
// 			}
// 			_map2.Add(MakeKeyword("EmailAddresses"), _vec50)
// 			_vec51 := EmptyVector
// 			for _, _elem51 := range (*_elem1).IPAddresses {
// 				_vec52 := EmptyVector
// 				for _, _elem52 := range _elem51 {
// 					_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 				}
// 				_vec51 = _vec51.Conjoin(_vec52)
// 			}
// 			_map2.Add(MakeKeyword("IPAddresses"), _vec51)
// 			_vec53 := EmptyVector
// 			for _, _elem53 := range (*_elem1).URIs {
// 				var _obj_map54 Object
// 				if _elem53 != nil {
// 					_map54 := EmptyArrayMap()
// 					_map54.Add(MakeKeyword("Scheme"), MakeString((*_elem53).Scheme))
// 					_map54.Add(MakeKeyword("Opaque"), MakeString((*_elem53).Opaque))
// 					_map54.Add(MakeKeyword("User"), (*(*_elem53).User))
// 					_map54.Add(MakeKeyword("Host"), MakeString((*_elem53).Host))
// 					_map54.Add(MakeKeyword("Path"), MakeString((*_elem53).Path))
// 					_map54.Add(MakeKeyword("RawPath"), MakeString((*_elem53).RawPath))
// 					_map54.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem53).ForceQuery))
// 					_map54.Add(MakeKeyword("RawQuery"), MakeString((*_elem53).RawQuery))
// 					_map54.Add(MakeKeyword("Fragment"), MakeString((*_elem53).Fragment))
// 					_obj_map54 = Object(_map54)
// 				} else {
// 					_obj_map54 = NIL
// 				}
// 				_vec53 = _vec53.Conjoin(_obj_map54)
// 			}
// 			_map2.Add(MakeKeyword("URIs"), _vec53)
// 			_map2.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem1).PermittedDNSDomainsCritical))
// 			_vec55 := EmptyVector
// 			for _, _elem55 := range (*_elem1).PermittedDNSDomains {
// 				_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 			}
// 			_map2.Add(MakeKeyword("PermittedDNSDomains"), _vec55)
// 			_vec56 := EmptyVector
// 			for _, _elem56 := range (*_elem1).ExcludedDNSDomains {
// 				_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 			}
// 			_map2.Add(MakeKeyword("ExcludedDNSDomains"), _vec56)
// 			_vec57 := EmptyVector
// 			for _, _elem57 := range (*_elem1).PermittedIPRanges {
// 				var _obj_map58 Object
// 				if _elem57 != nil {
// 					_map58 := EmptyArrayMap()
// 					_map58.Add(MakeKeyword("IP"), (*_elem57).IP)
// 					_map58.Add(MakeKeyword("Mask"), (*_elem57).Mask)
// 					_obj_map58 = Object(_map58)
// 				} else {
// 					_obj_map58 = NIL
// 				}
// 				_vec57 = _vec57.Conjoin(_obj_map58)
// 			}
// 			_map2.Add(MakeKeyword("PermittedIPRanges"), _vec57)
// 			_vec59 := EmptyVector
// 			for _, _elem59 := range (*_elem1).ExcludedIPRanges {
// 				var _obj_map60 Object
// 				if _elem59 != nil {
// 					_map60 := EmptyArrayMap()
// 					_map60.Add(MakeKeyword("IP"), (*_elem59).IP)
// 					_map60.Add(MakeKeyword("Mask"), (*_elem59).Mask)
// 					_obj_map60 = Object(_map60)
// 				} else {
// 					_obj_map60 = NIL
// 				}
// 				_vec59 = _vec59.Conjoin(_obj_map60)
// 			}
// 			_map2.Add(MakeKeyword("ExcludedIPRanges"), _vec59)
// 			_vec61 := EmptyVector
// 			for _, _elem61 := range (*_elem1).PermittedEmailAddresses {
// 				_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 			}
// 			_map2.Add(MakeKeyword("PermittedEmailAddresses"), _vec61)
// 			_vec62 := EmptyVector
// 			for _, _elem62 := range (*_elem1).ExcludedEmailAddresses {
// 				_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 			}
// 			_map2.Add(MakeKeyword("ExcludedEmailAddresses"), _vec62)
// 			_vec63 := EmptyVector
// 			for _, _elem63 := range (*_elem1).PermittedURIDomains {
// 				_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 			}
// 			_map2.Add(MakeKeyword("PermittedURIDomains"), _vec63)
// 			_vec64 := EmptyVector
// 			for _, _elem64 := range (*_elem1).ExcludedURIDomains {
// 				_vec64 = _vec64.Conjoin(MakeString(_elem64))
// 			}
// 			_map2.Add(MakeKeyword("ExcludedURIDomains"), _vec64)
// 			_vec65 := EmptyVector
// 			for _, _elem65 := range (*_elem1).CRLDistributionPoints {
// 				_vec65 = _vec65.Conjoin(MakeString(_elem65))
// 			}
// 			_map2.Add(MakeKeyword("CRLDistributionPoints"), _vec65)
// 			_vec66 := EmptyVector
// 			for _, _elem66 := range (*_elem1).PolicyIdentifiers {
// 				_vec67 := EmptyVector
// 				for _, _elem67 := range _elem66 {
// 					_vec67 = _vec67.Conjoin(MakeInt(_elem67))
// 				}
// 				_vec66 = _vec66.Conjoin(_vec67)
// 			}
// 			_map2.Add(MakeKeyword("PolicyIdentifiers"), _vec66)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_vec1 = _vec1.Conjoin(_obj_map2)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseDERCRL:
// func parseDERCRL(derBytes []byte) Object {
// 	_res1, _res2 := _x509.ParseDERCRL(derBytes)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("TBSCertList"), (*_res1).TBSCertList)
// 		_map1.Add(MakeKeyword("SignatureAlgorithm"), (*_res1).SignatureAlgorithm)
// 		_map2 := EmptyArrayMap()
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).SignatureValue.Bytes {
// 			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 		}
// 		_map2.Add(MakeKeyword("Bytes"), _vec3)
// 		_map2.Add(MakeKeyword("BitLength"), MakeInt((*_res1).SignatureValue.BitLength))
// 		_map1.Add(MakeKeyword("SignatureValue"), _map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParseECPrivateKey:
func parseECPrivateKey(der []byte) Object {
	_, _res2 := _x509.ParseECPrivateKey(der)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/x509.ParsePKCS1PrivateKey:
// func parsePKCS1PrivateKey(der []byte) Object {
// 	_res1, _res2 := _x509.ParsePKCS1PrivateKey(der)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("D"), NIL)
// 		_map1.Add(MakeKeyword("Primes"), NIL)
// 		_map1.Add(MakeKeyword("Precomputed"), (*_res1).Precomputed)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKCS1PublicKey:
func parsePKCS1PublicKey(der []byte) Object {
	_res1, _res2 := _x509.ParsePKCS1PublicKey(der)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("N"), NIL)
		_map1.Add(MakeKeyword("E"), MakeInt((*_res1).E))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC crypto/x509.ParsePKCS8PrivateKey:
// func parsePKCS8PrivateKey(der []byte) Object {
// 	key, err := _x509.ParsePKCS8PrivateKey(der)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(key)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.ParsePKIXPublicKey:
// func parsePKIXPublicKey(derBytes []byte) Object {
// 	pub, err := _x509.ParsePKIXPublicKey(derBytes)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pub)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC crypto/x509.SystemCertPool:
func systemCertPool() Object {
	_, _res2 := _x509.SystemCertPool()
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.Drivers:
func drivers() Object {
	_res := _sql.Drivers()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC database/sql.Named:
// func named(name string, value interface {}) Object {
// 	_res := _sql.Named(name, value)
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("Name"), MakeString(_res.Name))
// 	_map1.Add(MakeKeyword("Value"), _res.Value)
// 	return _map1
// }

GO FUNC database/sql.Open:
func open(driverName string, dataSourceName string) Object {
	_, _res2 := _sql.Open(driverName, dataSourceName)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC database/sql.OpenDB:
// func openDB(c database/sql/driver.Connector) Object {
// 	return _sql.OpenDB(c)
// 	ABEND124(no public information returned)
// }

GO FUNC database/sql.Register:
// func register(name string, driver database/sql/driver.Driver) Object {
// 	_sql.Register(name, driver)
// 	...ABEND675: TODO...
// }

GO FUNC debug/dwarf.New:
func new(abbrev []byte, aranges []byte, frame []byte, info []byte, line []byte, pubnames []byte, ranges []byte, str []byte) Object {
	_, _res2 := _dwarf.New(abbrev, aranges, frame, info, line, pubnames, ranges, str)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.NewFile:
// func newFile(r io.ReaderAt) Object {
// 	_, _res2 := _elf.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/elf.Open:
func open(name string) Object {
	_, _res2 := _elf.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/elf.R_INFO:
// func r_INFO(sym uint32, typ uint32) Object {
// 	return _elf.R_INFO(sym, typ)
// }

GO FUNC debug/elf.ST_INFO:
// func sT_INFO(bind debug/elf.SymBind, typ debug/elf.SymType) Object {
// 	return _elf.ST_INFO(bind, typ)
// }

GO FUNC debug/gosym.NewLineTable:
// func newLineTable(data []byte, text uint64) Object {
// 	_res := _gosym.NewLineTable(data, text)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Data {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_map1.Add(MakeKeyword("Data"), _vec2)
// 		_map1.Add(MakeKeyword("PC"), (*_res).PC)
// 		_map1.Add(MakeKeyword("Line"), MakeInt((*_res).Line))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC debug/gosym.NewTable:
// func newTable(symtab []byte, pcln *debug/gosym.LineTable) Object {
// 	_res1, _res2 := _gosym.NewTable(symtab, pcln)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Syms {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Value"), _elem2.Value)
// 			_map3.Add(MakeKeyword("Type"), MakeInt(int(_elem2.Type)))
// 			_map3.Add(MakeKeyword("Name"), MakeString(_elem2.Name))
// 			_map3.Add(MakeKeyword("GoType"), _elem2.GoType)
// 			var _obj_map4 Object
// 			if _elem2.Func != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Entry"), (*_elem2.Func).Entry)
// 				_map4.Add(MakeKeyword("End"), (*_elem2.Func).End)
// 				_vec5 := EmptyVector
// 				for _, _elem5 := range (*_elem2.Func).Params {
// 					_vec5 = _vec5.Conjoin()
// 				}
// 				_map4.Add(MakeKeyword("Params"), _vec5)
// 				_vec6 := EmptyVector
// 				for _, _elem6 := range (*_elem2.Func).Locals {
// 					_vec6 = _vec6.Conjoin()
// 				}
// 				_map4.Add(MakeKeyword("Locals"), _vec6)
// 				_map4.Add(MakeKeyword("FrameSize"), MakeInt((*_elem2.Func).FrameSize))
// 				var _obj_map7 Object
// 				if (*_elem2.Func).LineTable != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*(*_elem2.Func).LineTable).Data {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Data"), _vec8)
// 					_map7.Add(MakeKeyword("PC"), (*(*_elem2.Func).LineTable).PC)
// 					_map7.Add(MakeKeyword("Line"), MakeInt((*(*_elem2.Func).LineTable).Line))
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_map4.Add(MakeKeyword("LineTable"), _obj_map7)
// 				var _obj_map9 Object
// 				if (*_elem2.Func).Obj != nil {
// 					_map9 := EmptyArrayMap()
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*(*_elem2.Func).Obj).Funcs {
// 						_vec10 = _vec10.Conjoin()
// 					}
// 					_map9.Add(MakeKeyword("Funcs"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*(*_elem2.Func).Obj).Paths {
// 						_vec11 = _vec11.Conjoin()
// 					}
// 					_map9.Add(MakeKeyword("Paths"), _vec11)
// 					_obj_map9 = Object(_map9)
// 				} else {
// 					_obj_map9 = NIL
// 				}
// 				_map4.Add(MakeKeyword("Obj"), _obj_map9)
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("Func"), _obj_map4)
// 			_vec2 = _vec2.Conjoin(_map3)
// 		}
// 		_map1.Add(MakeKeyword("Syms"), _vec2)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1).Funcs {
// 			_map13 := EmptyArrayMap()
// 			_map13.Add(MakeKeyword("Entry"), _elem12.Entry)
// 			_map13.Add(MakeKeyword("End"), _elem12.End)
// 			_vec14 := EmptyVector
// 			for _, _elem14 := range _elem12.Params {
// 				var _obj_map15 Object
// 				if _elem14 != nil {
// 					_map15 := EmptyArrayMap()
// 					_map15.Add(MakeKeyword("Value"), (*_elem14).Value)
// 					_map15.Add(MakeKeyword("Type"), MakeInt(int((*_elem14).Type)))
// 					_map15.Add(MakeKeyword("Name"), MakeString((*_elem14).Name))
// 					_map15.Add(MakeKeyword("GoType"), (*_elem14).GoType)
// 					_map15.Add(MakeKeyword("Func"), )
// 					_obj_map15 = Object(_map15)
// 				} else {
// 					_obj_map15 = NIL
// 				}
// 				_vec14 = _vec14.Conjoin(_obj_map15)
// 			}
// 			_map13.Add(MakeKeyword("Params"), _vec14)
// 			_vec16 := EmptyVector
// 			for _, _elem16 := range _elem12.Locals {
// 				var _obj_map17 Object
// 				if _elem16 != nil {
// 					_map17 := EmptyArrayMap()
// 					_map17.Add(MakeKeyword("Value"), (*_elem16).Value)
// 					_map17.Add(MakeKeyword("Type"), MakeInt(int((*_elem16).Type)))
// 					_map17.Add(MakeKeyword("Name"), MakeString((*_elem16).Name))
// 					_map17.Add(MakeKeyword("GoType"), (*_elem16).GoType)
// 					_map17.Add(MakeKeyword("Func"), )
// 					_obj_map17 = Object(_map17)
// 				} else {
// 					_obj_map17 = NIL
// 				}
// 				_vec16 = _vec16.Conjoin(_obj_map17)
// 			}
// 			_map13.Add(MakeKeyword("Locals"), _vec16)
// 			_map13.Add(MakeKeyword("FrameSize"), MakeInt(_elem12.FrameSize))
// 			var _obj_map18 Object
// 			if _elem12.LineTable != nil {
// 				_map18 := EmptyArrayMap()
// 				_vec19 := EmptyVector
// 				for _, _elem19 := range (*_elem12.LineTable).Data {
// 					_vec19 = _vec19.Conjoin(MakeInt(int(_elem19)))
// 				}
// 				_map18.Add(MakeKeyword("Data"), _vec19)
// 				_map18.Add(MakeKeyword("PC"), (*_elem12.LineTable).PC)
// 				_map18.Add(MakeKeyword("Line"), MakeInt((*_elem12.LineTable).Line))
// 				_obj_map18 = Object(_map18)
// 			} else {
// 				_obj_map18 = NIL
// 			}
// 			_map13.Add(MakeKeyword("LineTable"), _obj_map18)
// 			var _obj_map20 Object
// 			if _elem12.Obj != nil {
// 				_map20 := EmptyArrayMap()
// 				_vec21 := EmptyVector
// 				for _, _elem21 := range (*_elem12.Obj).Funcs {
// 					_vec21 = _vec21.Conjoin()
// 				}
// 				_map20.Add(MakeKeyword("Funcs"), _vec21)
// 				_vec22 := EmptyVector
// 				for _, _elem22 := range (*_elem12.Obj).Paths {
// 					_map23 := EmptyArrayMap()
// 					_map23.Add(MakeKeyword("Value"), _elem22.Value)
// 					_map23.Add(MakeKeyword("Type"), MakeInt(int(_elem22.Type)))
// 					_map23.Add(MakeKeyword("Name"), MakeString(_elem22.Name))
// 					_map23.Add(MakeKeyword("GoType"), _elem22.GoType)
// 					_map23.Add(MakeKeyword("Func"), )
// 					_vec22 = _vec22.Conjoin(_map23)
// 				}
// 				_map20.Add(MakeKeyword("Paths"), _vec22)
// 				_obj_map20 = Object(_map20)
// 			} else {
// 				_obj_map20 = NIL
// 			}
// 			_map13.Add(MakeKeyword("Obj"), _obj_map20)
// 			_vec12 = _vec12.Conjoin(_map13)
// 		}
// 		_map1.Add(MakeKeyword("Funcs"), _vec12)
// 		_map1.Add(MakeKeyword("Files"), (*_res1).Files)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1).Objs {
// 			_map25 := EmptyArrayMap()
// 			_vec26 := EmptyVector
// 			for _, _elem26 := range _elem24.Funcs {
// 				_map27 := EmptyArrayMap()
// 				_map27.Add(MakeKeyword("Entry"), _elem26.Entry)
// 				_map27.Add(MakeKeyword("End"), _elem26.End)
// 				_vec28 := EmptyVector
// 				for _, _elem28 := range _elem26.Params {
// 					var _obj_map29 Object
// 					if _elem28 != nil {
// 						_map29 := EmptyArrayMap()
// 						_map29.Add(MakeKeyword("Value"), (*_elem28).Value)
// 						_map29.Add(MakeKeyword("Type"), MakeInt(int((*_elem28).Type)))
// 						_map29.Add(MakeKeyword("Name"), MakeString((*_elem28).Name))
// 						_map29.Add(MakeKeyword("GoType"), (*_elem28).GoType)
// 						_map29.Add(MakeKeyword("Func"), )
// 						_obj_map29 = Object(_map29)
// 					} else {
// 						_obj_map29 = NIL
// 					}
// 					_vec28 = _vec28.Conjoin(_obj_map29)
// 				}
// 				_map27.Add(MakeKeyword("Params"), _vec28)
// 				_vec30 := EmptyVector
// 				for _, _elem30 := range _elem26.Locals {
// 					var _obj_map31 Object
// 					if _elem30 != nil {
// 						_map31 := EmptyArrayMap()
// 						_map31.Add(MakeKeyword("Value"), (*_elem30).Value)
// 						_map31.Add(MakeKeyword("Type"), MakeInt(int((*_elem30).Type)))
// 						_map31.Add(MakeKeyword("Name"), MakeString((*_elem30).Name))
// 						_map31.Add(MakeKeyword("GoType"), (*_elem30).GoType)
// 						_map31.Add(MakeKeyword("Func"), )
// 						_obj_map31 = Object(_map31)
// 					} else {
// 						_obj_map31 = NIL
// 					}
// 					_vec30 = _vec30.Conjoin(_obj_map31)
// 				}
// 				_map27.Add(MakeKeyword("Locals"), _vec30)
// 				_map27.Add(MakeKeyword("FrameSize"), MakeInt(_elem26.FrameSize))
// 				var _obj_map32 Object
// 				if _elem26.LineTable != nil {
// 					_map32 := EmptyArrayMap()
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem26.LineTable).Data {
// 						_vec33 = _vec33.Conjoin(MakeInt(int(_elem33)))
// 					}
// 					_map32.Add(MakeKeyword("Data"), _vec33)
// 					_map32.Add(MakeKeyword("PC"), (*_elem26.LineTable).PC)
// 					_map32.Add(MakeKeyword("Line"), MakeInt((*_elem26.LineTable).Line))
// 					_obj_map32 = Object(_map32)
// 				} else {
// 					_obj_map32 = NIL
// 				}
// 				_map27.Add(MakeKeyword("LineTable"), _obj_map32)
// 				_map27.Add(MakeKeyword("Obj"), )
// 				_vec26 = _vec26.Conjoin(_map27)
// 			}
// 			_map25.Add(MakeKeyword("Funcs"), _vec26)
// 			_vec34 := EmptyVector
// 			for _, _elem34 := range _elem24.Paths {
// 				_map35 := EmptyArrayMap()
// 				_map35.Add(MakeKeyword("Value"), _elem34.Value)
// 				_map35.Add(MakeKeyword("Type"), MakeInt(int(_elem34.Type)))
// 				_map35.Add(MakeKeyword("Name"), MakeString(_elem34.Name))
// 				_map35.Add(MakeKeyword("GoType"), _elem34.GoType)
// 				var _obj_map36 Object
// 				if _elem34.Func != nil {
// 					_map36 := EmptyArrayMap()
// 					_map36.Add(MakeKeyword("Entry"), (*_elem34.Func).Entry)
// 					_map36.Add(MakeKeyword("End"), (*_elem34.Func).End)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem34.Func).Params {
// 						_vec37 = _vec37.Conjoin()
// 					}
// 					_map36.Add(MakeKeyword("Params"), _vec37)
// 					_vec38 := EmptyVector
// 					for _, _elem38 := range (*_elem34.Func).Locals {
// 						_vec38 = _vec38.Conjoin()
// 					}
// 					_map36.Add(MakeKeyword("Locals"), _vec38)
// 					_map36.Add(MakeKeyword("FrameSize"), MakeInt((*_elem34.Func).FrameSize))
// 					var _obj_map39 Object
// 					if (*_elem34.Func).LineTable != nil {
// 						_map39 := EmptyArrayMap()
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range (*(*_elem34.Func).LineTable).Data {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map39.Add(MakeKeyword("Data"), _vec40)
// 						_map39.Add(MakeKeyword("PC"), (*(*_elem34.Func).LineTable).PC)
// 						_map39.Add(MakeKeyword("Line"), MakeInt((*(*_elem34.Func).LineTable).Line))
// 						_obj_map39 = Object(_map39)
// 					} else {
// 						_obj_map39 = NIL
// 					}
// 					_map36.Add(MakeKeyword("LineTable"), _obj_map39)
// 					_map36.Add(MakeKeyword("Obj"), )
// 					_obj_map36 = Object(_map36)
// 				} else {
// 					_obj_map36 = NIL
// 				}
// 				_map35.Add(MakeKeyword("Func"), _obj_map36)
// 				_vec34 = _vec34.Conjoin(_map35)
// 			}
// 			_map25.Add(MakeKeyword("Paths"), _vec34)
// 			_vec24 = _vec24.Conjoin(_map25)
// 		}
// 		_map1.Add(MakeKeyword("Objs"), _vec24)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFatFile:
// func newFatFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _macho.NewFatFile(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Magic"), MakeInt(int((*_res1).Magic)))
// 		_map1.Add(MakeKeyword("Arches"), NIL)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.NewFile:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _macho.NewFile(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("ByteOrder"), (*_res1).ByteOrder)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Loads {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Loads"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).Sections {
// 			var _obj_map4 Object
// 			if _elem3 != nil {
// 				_map4 := EmptyArrayMap()
// 				_vec5 := EmptyVector
// 				for _, _elem5 := range (*_elem3).Relocs {
// 					_map6 := EmptyArrayMap()
// 					_map6.Add(MakeKeyword("Addr"), MakeInt(int(_elem5.Addr)))
// 					_map6.Add(MakeKeyword("Value"), MakeInt(int(_elem5.Value)))
// 					_map6.Add(MakeKeyword("Type"), _elem5.Type)
// 					_map6.Add(MakeKeyword("Len"), _elem5.Len)
// 					_map6.Add(MakeKeyword("Pcrel"), MakeBool(_elem5.Pcrel))
// 					_map6.Add(MakeKeyword("Extern"), MakeBool(_elem5.Extern))
// 					_map6.Add(MakeKeyword("Scattered"), MakeBool(_elem5.Scattered))
// 					_vec5 = _vec5.Conjoin(_map6)
// 				}
// 				_map4.Add(MakeKeyword("Relocs"), _vec5)
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_vec3 = _vec3.Conjoin(_obj_map4)
// 		}
// 		_map1.Add(MakeKeyword("Sections"), _vec3)
// 		var _obj_map7 Object
// 		if (*_res1).Symtab != nil {
// 			_map7 := EmptyArrayMap()
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res1).Symtab).Syms {
// 				_map9 := EmptyArrayMap()
// 				_map9.Add(MakeKeyword("Name"), MakeString(_elem8.Name))
// 				_map9.Add(MakeKeyword("Type"), _elem8.Type)
// 				_map9.Add(MakeKeyword("Sect"), _elem8.Sect)
// 				_map9.Add(MakeKeyword("Desc"), MakeInt(int(_elem8.Desc)))
// 				_map9.Add(MakeKeyword("Value"), _elem8.Value)
// 				_vec8 = _vec8.Conjoin(_map9)
// 			}
// 			_map7.Add(MakeKeyword("Syms"), _vec8)
// 			_obj_map7 = Object(_map7)
// 		} else {
// 			_obj_map7 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Symtab"), _obj_map7)
// 		var _obj_map10 Object
// 		if (*_res1).Dysymtab != nil {
// 			_map10 := EmptyArrayMap()
// 			_vec11 := EmptyVector
// 			for _, _elem11 := range (*(*_res1).Dysymtab).IndirectSyms {
// 				_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 			}
// 			_map10.Add(MakeKeyword("IndirectSyms"), _vec11)
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Dysymtab"), _obj_map10)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.Open:
// func open(name string) Object {
// 	_res1, _res2 := _macho.Open(name)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("ByteOrder"), (*_res1).ByteOrder)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Loads {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Loads"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).Sections {
// 			var _obj_map4 Object
// 			if _elem3 != nil {
// 				_map4 := EmptyArrayMap()
// 				_vec5 := EmptyVector
// 				for _, _elem5 := range (*_elem3).Relocs {
// 					_map6 := EmptyArrayMap()
// 					_map6.Add(MakeKeyword("Addr"), MakeInt(int(_elem5.Addr)))
// 					_map6.Add(MakeKeyword("Value"), MakeInt(int(_elem5.Value)))
// 					_map6.Add(MakeKeyword("Type"), _elem5.Type)
// 					_map6.Add(MakeKeyword("Len"), _elem5.Len)
// 					_map6.Add(MakeKeyword("Pcrel"), MakeBool(_elem5.Pcrel))
// 					_map6.Add(MakeKeyword("Extern"), MakeBool(_elem5.Extern))
// 					_map6.Add(MakeKeyword("Scattered"), MakeBool(_elem5.Scattered))
// 					_vec5 = _vec5.Conjoin(_map6)
// 				}
// 				_map4.Add(MakeKeyword("Relocs"), _vec5)
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_vec3 = _vec3.Conjoin(_obj_map4)
// 		}
// 		_map1.Add(MakeKeyword("Sections"), _vec3)
// 		var _obj_map7 Object
// 		if (*_res1).Symtab != nil {
// 			_map7 := EmptyArrayMap()
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res1).Symtab).Syms {
// 				_map9 := EmptyArrayMap()
// 				_map9.Add(MakeKeyword("Name"), MakeString(_elem8.Name))
// 				_map9.Add(MakeKeyword("Type"), _elem8.Type)
// 				_map9.Add(MakeKeyword("Sect"), _elem8.Sect)
// 				_map9.Add(MakeKeyword("Desc"), MakeInt(int(_elem8.Desc)))
// 				_map9.Add(MakeKeyword("Value"), _elem8.Value)
// 				_vec8 = _vec8.Conjoin(_map9)
// 			}
// 			_map7.Add(MakeKeyword("Syms"), _vec8)
// 			_obj_map7 = Object(_map7)
// 		} else {
// 			_obj_map7 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Symtab"), _obj_map7)
// 		var _obj_map10 Object
// 		if (*_res1).Dysymtab != nil {
// 			_map10 := EmptyArrayMap()
// 			_vec11 := EmptyVector
// 			for _, _elem11 := range (*(*_res1).Dysymtab).IndirectSyms {
// 				_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 			}
// 			_map10.Add(MakeKeyword("IndirectSyms"), _vec11)
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Dysymtab"), _obj_map10)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/macho.OpenFat:
func openFat(name string) Object {
	_res1, _res2 := _macho.OpenFat(name)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Magic"), MakeInt(int((*_res1).Magic)))
		_map1.Add(MakeKeyword("Arches"), NIL)
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC debug/pe.NewFile:
// func newFile(r io.ReaderAt) Object {
// 	_res1, _res2 := _pe.NewFile(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("OptionalHeader"), (*_res1).OptionalHeader)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Sections {
// 			var _obj_map3 Object
// 			if _elem2 != nil {
// 				_map3 := EmptyArrayMap()
// 				_vec4 := EmptyVector
// 				for _, _elem4 := range (*_elem2).Relocs {
// 					_map5 := EmptyArrayMap()
// 					_map5.Add(MakeKeyword("VirtualAddress"), MakeInt(int(_elem4.VirtualAddress)))
// 					_map5.Add(MakeKeyword("SymbolTableIndex"), MakeInt(int(_elem4.SymbolTableIndex)))
// 					_map5.Add(MakeKeyword("Type"), MakeInt(int(_elem4.Type)))
// 					_vec4 = _vec4.Conjoin(_map5)
// 				}
// 				_map3.Add(MakeKeyword("Relocs"), _vec4)
// 				_obj_map3 = Object(_map3)
// 			} else {
// 				_obj_map3 = NIL
// 			}
// 			_vec2 = _vec2.Conjoin(_obj_map3)
// 		}
// 		_map1.Add(MakeKeyword("Sections"), _vec2)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).Symbols {
// 			var _obj_map7 Object
// 			if _elem6 != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Name"), MakeString((*_elem6).Name))
// 				_map7.Add(MakeKeyword("Value"), MakeInt(int((*_elem6).Value)))
// 				_map7.Add(MakeKeyword("SectionNumber"), MakeInt(int((*_elem6).SectionNumber)))
// 				_map7.Add(MakeKeyword("Type"), MakeInt(int((*_elem6).Type)))
// 				_map7.Add(MakeKeyword("StorageClass"), (*_elem6).StorageClass)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_vec6 = _vec6.Conjoin(_obj_map7)
// 		}
// 		_map1.Add(MakeKeyword("Symbols"), _vec6)
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1).COFFSymbols {
// 			_map9 := EmptyArrayMap()
// 			_vec10 := EmptyVector
// 			for _, _elem10 := range _elem8.Name {
// 				_vec10 = _vec10.Conjoin(_elem10)
// 			}
// 			_map9.Add(MakeKeyword("Name"), _vec10)
// 			_map9.Add(MakeKeyword("Value"), MakeInt(int(_elem8.Value)))
// 			_map9.Add(MakeKeyword("SectionNumber"), MakeInt(int(_elem8.SectionNumber)))
// 			_map9.Add(MakeKeyword("Type"), MakeInt(int(_elem8.Type)))
// 			_map9.Add(MakeKeyword("StorageClass"), _elem8.StorageClass)
// 			_map9.Add(MakeKeyword("NumberOfAuxSymbols"), _elem8.NumberOfAuxSymbols)
// 			_vec8 = _vec8.Conjoin(_map9)
// 		}
// 		_map1.Add(MakeKeyword("COFFSymbols"), _vec8)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).StringTable {
// 			_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 		}
// 		_map1.Add(MakeKeyword("StringTable"), _vec11)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/pe.Open:
// func open(name string) Object {
// 	_res1, _res2 := _pe.Open(name)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("OptionalHeader"), (*_res1).OptionalHeader)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Sections {
// 			var _obj_map3 Object
// 			if _elem2 != nil {
// 				_map3 := EmptyArrayMap()
// 				_vec4 := EmptyVector
// 				for _, _elem4 := range (*_elem2).Relocs {
// 					_map5 := EmptyArrayMap()
// 					_map5.Add(MakeKeyword("VirtualAddress"), MakeInt(int(_elem4.VirtualAddress)))
// 					_map5.Add(MakeKeyword("SymbolTableIndex"), MakeInt(int(_elem4.SymbolTableIndex)))
// 					_map5.Add(MakeKeyword("Type"), MakeInt(int(_elem4.Type)))
// 					_vec4 = _vec4.Conjoin(_map5)
// 				}
// 				_map3.Add(MakeKeyword("Relocs"), _vec4)
// 				_obj_map3 = Object(_map3)
// 			} else {
// 				_obj_map3 = NIL
// 			}
// 			_vec2 = _vec2.Conjoin(_obj_map3)
// 		}
// 		_map1.Add(MakeKeyword("Sections"), _vec2)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).Symbols {
// 			var _obj_map7 Object
// 			if _elem6 != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Name"), MakeString((*_elem6).Name))
// 				_map7.Add(MakeKeyword("Value"), MakeInt(int((*_elem6).Value)))
// 				_map7.Add(MakeKeyword("SectionNumber"), MakeInt(int((*_elem6).SectionNumber)))
// 				_map7.Add(MakeKeyword("Type"), MakeInt(int((*_elem6).Type)))
// 				_map7.Add(MakeKeyword("StorageClass"), (*_elem6).StorageClass)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_vec6 = _vec6.Conjoin(_obj_map7)
// 		}
// 		_map1.Add(MakeKeyword("Symbols"), _vec6)
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1).COFFSymbols {
// 			_map9 := EmptyArrayMap()
// 			_vec10 := EmptyVector
// 			for _, _elem10 := range _elem8.Name {
// 				_vec10 = _vec10.Conjoin(_elem10)
// 			}
// 			_map9.Add(MakeKeyword("Name"), _vec10)
// 			_map9.Add(MakeKeyword("Value"), MakeInt(int(_elem8.Value)))
// 			_map9.Add(MakeKeyword("SectionNumber"), MakeInt(int(_elem8.SectionNumber)))
// 			_map9.Add(MakeKeyword("Type"), MakeInt(int(_elem8.Type)))
// 			_map9.Add(MakeKeyword("StorageClass"), _elem8.StorageClass)
// 			_map9.Add(MakeKeyword("NumberOfAuxSymbols"), _elem8.NumberOfAuxSymbols)
// 			_vec8 = _vec8.Conjoin(_map9)
// 		}
// 		_map1.Add(MakeKeyword("COFFSymbols"), _vec8)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).StringTable {
// 			_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 		}
// 		_map1.Add(MakeKeyword("StringTable"), _vec11)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/plan9obj.NewFile:
// func newFile(r io.ReaderAt) Object {
// 	_, _res2 := _plan9obj.NewFile(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC debug/plan9obj.Open:
func open(name string) Object {
	_, _res2 := _plan9obj.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/ascii85.Decode:
func decode(dst []byte, src []byte, flush bool) Object {
	ndst, nsrc, err := _ascii85.Decode(dst, src, flush)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(ndst))
	_res = _res.Conjoin(MakeInt(nsrc))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC encoding/ascii85.NewDecoder:
// func newDecoder(r io.Reader) Object {
// 	return _ascii85.NewDecoder(r)
// }

GO FUNC encoding/ascii85.NewEncoder:
// func newEncoder(w io.Writer) Object {
// 	return _ascii85.NewEncoder(w)
// }

GO FUNC encoding/asn1.Marshal:
// func marshal(val interface {}) Object {
// 	_res1, _res2 := _asn1.Marshal(val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.MarshalWithParams:
// func marshalWithParams(val interface {}, params string) Object {
// 	_res1, _res2 := _asn1.MarshalWithParams(val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/asn1.Unmarshal:
// func unmarshal(b []byte, val interface {}) Object {
// 	rest, err := _asn1.Unmarshal(b, val)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/asn1.UnmarshalWithParams:
// func unmarshalWithParams(b []byte, val interface {}, params string) Object {
// 	rest, err := _asn1.UnmarshalWithParams(b, val, params)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range rest {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC encoding/base32.NewDecoder:
// func newDecoder(enc *encoding/base32.Encoding, r io.Reader) Object {
// 	return _base32.NewDecoder(enc, r)
// }

GO FUNC encoding/base32.NewEncoder:
// func newEncoder(enc *encoding/base32.Encoding, w io.Writer) Object {
// 	return _base32.NewEncoder(enc, w)
// }

GO FUNC encoding/base32.NewEncoding:
// func newEncoding(encoder string) Object {
// 	return _base32.NewEncoding(encoder)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/base64.NewDecoder:
// func newDecoder(enc *encoding/base64.Encoding, r io.Reader) Object {
// 	return _base64.NewDecoder(enc, r)
// }

GO FUNC encoding/base64.NewEncoder:
// func newEncoder(enc *encoding/base64.Encoding, w io.Writer) Object {
// 	return _base64.NewEncoder(enc, w)
// }

GO FUNC encoding/base64.NewEncoding:
// func newEncoding(encoder string) Object {
// 	return _base64.NewEncoding(encoder)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/binary.ReadUvarint:
// func readUvarint(r io.ByteReader) Object {
// 	_res1, _res2 := _binary.ReadUvarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.ReadVarint:
// func readVarint(r io.ByteReader) Object {
// 	_res1, _res2 := _binary.ReadVarint(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/binary.Uvarint:
// func uvarint(buf []byte) Object {
// 	_res1, _res2 := _binary.Uvarint(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeInt(_res2))
// 	return _res
// }

GO FUNC encoding/binary.Varint:
func varint(buf []byte) Object {
	_res1, _res2 := _binary.Varint(buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(MakeInt(_res2))
	return _res
}

GO FUNC encoding/csv.NewReader:
// func newReader(r io.Reader) Object {
// 	_res := _csv.NewReader(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Comma"), (*_res).Comma)
// 		_map1.Add(MakeKeyword("Comment"), (*_res).Comment)
// 		_map1.Add(MakeKeyword("FieldsPerRecord"), MakeInt((*_res).FieldsPerRecord))
// 		_map1.Add(MakeKeyword("LazyQuotes"), MakeBool((*_res).LazyQuotes))
// 		_map1.Add(MakeKeyword("TrimLeadingSpace"), MakeBool((*_res).TrimLeadingSpace))
// 		_map1.Add(MakeKeyword("ReuseRecord"), MakeBool((*_res).ReuseRecord))
// 		_map1.Add(MakeKeyword("TrailingComma"), MakeBool((*_res).TrailingComma))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC encoding/csv.NewWriter:
// func newWriter(w io.Writer) Object {
// 	_res := _csv.NewWriter(w)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Comma"), (*_res).Comma)
// 		_map1.Add(MakeKeyword("UseCRLF"), MakeBool((*_res).UseCRLF))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC encoding/gob.NewDecoder:
// func newDecoder(r io.Reader) Object {
// 	return _gob.NewDecoder(r)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/gob.NewEncoder:
// func newEncoder(w io.Writer) Object {
// 	return _gob.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/gob.Register:
// func register(value interface {}) Object {
// 	_gob.Register(value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/gob.RegisterName:
// func registerName(name string, value interface {}) Object {
// 	_gob.RegisterName(name, value)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/hex.Decode:
func decode(dst []byte, src []byte) Object {
	_res1, _res2 := _hex.Decode(dst, src)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/hex.DecodeString:
func decodeString(s string) Object {
	_res1, _res2 := _hex.DecodeString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC encoding/hex.Dumper:
// func dumper(w io.Writer) Object {
// 	return _hex.Dumper(w)
// }

GO FUNC encoding/hex.NewDecoder:
// func newDecoder(r io.Reader) Object {
// 	return _hex.NewDecoder(r)
// }

GO FUNC encoding/hex.NewEncoder:
// func newEncoder(w io.Writer) Object {
// 	return _hex.NewEncoder(w)
// }

GO FUNC encoding/json.HTMLEscape:
// func hTMLEscape(dst *bytes.Buffer, src []byte) Object {
// 	_json.HTMLEscape(dst, src)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/json.Marshal:
// func marshal(v interface {}) Object {
// 	_res1, _res2 := _json.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.MarshalIndent:
// func marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _json.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/json.NewDecoder:
// func newDecoder(r io.Reader) Object {
// 	return _json.NewDecoder(r)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/json.NewEncoder:
// func newEncoder(w io.Writer) Object {
// 	return _json.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/pem.Decode:
// func decode(data []byte) Object {
// 	p, rest := _pem.Decode(data)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if p != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Type"), MakeString((*p).Type))
// 		_map1.Add(MakeKeyword("Headers"), (*p).Headers)
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*p).Bytes {
// 			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
// 		}
// 		_map1.Add(MakeKeyword("Bytes"), _vec2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_vec3 := EmptyVector
// 	for _, _elem3 := range rest {
// 		_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
// 	}
// 	_res = _res.Conjoin(_vec3)
// 	return _res
// }

GO FUNC encoding/pem.EncodeToMemory:
// func encodeToMemory(b *encoding/pem.Block) Object {
// 	_res := _pem.EncodeToMemory(b)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC encoding/xml.CopyToken:
// func copyToken(t encoding/xml.Token) Object {
// 	return _xml.CopyToken(t)
// }

GO FUNC encoding/xml.Escape:
// func escape(w io.Writer, s []byte) Object {
// 	_xml.Escape(w, s)
// 	...ABEND675: TODO...
// }

GO FUNC encoding/xml.Marshal:
// func marshal(v interface {}) Object {
// 	_res1, _res2 := _xml.Marshal(v)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.MarshalIndent:
// func marshalIndent(v interface {}, prefix string, indent string) Object {
// 	_res1, _res2 := _xml.MarshalIndent(v, prefix, indent)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC encoding/xml.NewDecoder:
// func newDecoder(r io.Reader) Object {
// 	_res := _xml.NewDecoder(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Strict"), MakeBool((*_res).Strict))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).AutoClose {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("AutoClose"), _vec2)
// 		_map1.Add(MakeKeyword("Entity"), (*_res).Entity)
// 		_map1.Add(MakeKeyword("CharsetReader"), (*_res).CharsetReader)
// 		_map1.Add(MakeKeyword("DefaultSpace"), MakeString((*_res).DefaultSpace))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC encoding/xml.NewEncoder:
// func newEncoder(w io.Writer) Object {
// 	return _xml.NewEncoder(w)
// 	ABEND124(no public information returned)
// }

GO FUNC encoding/xml.NewTokenDecoder:
// func newTokenDecoder(t encoding/xml.TokenReader) Object {
// 	_res := _xml.NewTokenDecoder(t)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Strict"), MakeBool((*_res).Strict))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).AutoClose {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("AutoClose"), _vec2)
// 		_map1.Add(MakeKeyword("Entity"), (*_res).Entity)
// 		_map1.Add(MakeKeyword("CharsetReader"), (*_res).CharsetReader)
// 		_map1.Add(MakeKeyword("DefaultSpace"), MakeString((*_res).DefaultSpace))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC expvar.Do:
// func do(f func) Object {
// 	_expvar.Do(f)
// 	...ABEND675: TODO...
// }

GO FUNC expvar.Get:
// func get(name string) Object {
// 	return _expvar.Get(name)
// }

GO FUNC expvar.Handler:
// func handler() Object {
// 	return _expvar.Handler()
// }

GO FUNC expvar.NewFloat:
// func newFloat(name string) Object {
// 	return _expvar.NewFloat(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewInt:
// func newInt(name string) Object {
// 	return _expvar.NewInt(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewMap:
// func newMap(name string) Object {
// 	return _expvar.NewMap(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.NewString:
// func newString(name string) Object {
// 	return _expvar.NewString(name)
// 	ABEND124(no public information returned)
// }

GO FUNC expvar.Publish:
// func publish(name string, v expvar.Var) Object {
// 	_expvar.Publish(name, v)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Args:
func args() Object {
	_res := _flag.Args()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC flag.BoolVar:
// func boolVar(p *bool, name string, value bool, usage string) Object {
// 	_flag.BoolVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.DurationVar:
// func durationVar(p *time.Duration, name string, value time.Duration, usage string) Object {
// 	_flag.DurationVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Float64:
// func float64(name string, value float64, usage string) Object {
// 	return _flag.Float64(name, value, usage)
// }

GO FUNC flag.Float64Var:
// func float64Var(p *float64, name string, value float64, usage string) Object {
// 	_flag.Float64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Int64Var:
// func int64Var(p *int64, name string, value int64, usage string) Object {
// 	_flag.Int64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.IntVar:
// func intVar(p *int, name string, value int, usage string) Object {
// 	_flag.IntVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Lookup:
// func lookup(name string) Object {
// 	_res := _flag.Lookup(name)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res).Name))
// 		_map1.Add(MakeKeyword("Usage"), MakeString((*_res).Usage))
// 		_map1.Add(MakeKeyword("Value"), (*_res).Value)
// 		_map1.Add(MakeKeyword("DefValue"), MakeString((*_res).DefValue))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC flag.NewFlagSet:
// func newFlagSet(name string, errorHandling flag.ErrorHandling) Object {
// 	_res := _flag.NewFlagSet(name, errorHandling)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Usage"), (*_res).Usage)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC flag.Parse:
// func parse() Object {
// 	_flag.Parse()
// 	...ABEND675: TODO...
// }

GO FUNC flag.PrintDefaults:
// func printDefaults() Object {
// 	_flag.PrintDefaults()
// 	...ABEND675: TODO...
// }

GO FUNC flag.StringVar:
// func stringVar(p *string, name string, value string, usage string) Object {
// 	_flag.StringVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Uint64:
// func uint64(name string, value uint64, usage string) Object {
// 	return _flag.Uint64(name, value, usage)
// }

GO FUNC flag.Uint64Var:
// func uint64Var(p *uint64, name string, value uint64, usage string) Object {
// 	_flag.Uint64Var(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UintVar:
// func uintVar(p *uint, name string, value uint, usage string) Object {
// 	_flag.UintVar(p, name, value, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.UnquoteUsage:
// func unquoteUsage(flag *flag.Flag) Object {
// 	name, usage := _flag.UnquoteUsage(flag)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(name))
// 	_res = _res.Conjoin(MakeString(usage))
// 	return _res
// }

GO FUNC flag.Var:
// func var(value flag.Value, name string, usage string) Object {
// 	_flag.Var(value, name, usage)
// 	...ABEND675: TODO...
// }

GO FUNC flag.Visit:
// func visit(fn func) Object {
// 	_flag.Visit(fn)
// 	...ABEND675: TODO...
// }

GO FUNC flag.VisitAll:
// func visitAll(fn func) Object {
// 	_flag.VisitAll(fn)
// 	...ABEND675: TODO...
// }

GO FUNC fmt.Fprint:
// func fprint(w io.Writer, a ...interface {}) Object {
// 	n, err := _fmt.Fprint(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintf:
// func fprintf(w io.Writer, format string, a ...interface {}) Object {
// 	n, err := _fmt.Fprintf(w, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fprintln:
// func fprintln(w io.Writer, a ...interface {}) Object {
// 	n, err := _fmt.Fprintln(w, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscan:
// func fscan(r io.Reader, a ...interface {}) Object {
// 	n, err := _fmt.Fscan(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanf:
// func fscanf(r io.Reader, format string, a ...interface {}) Object {
// 	n, err := _fmt.Fscanf(r, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Fscanln:
// func fscanln(r io.Reader, a ...interface {}) Object {
// 	n, err := _fmt.Fscanln(r, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Print:
// func print(a ...interface {}) Object {
// 	n, err := _fmt.Print(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Printf:
// func printf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Printf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Println:
// func println(a ...interface {}) Object {
// 	n, err := _fmt.Println(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scan:
// func scan(a ...interface {}) Object {
// 	n, err := _fmt.Scan(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanf:
// func scanf(format string, a ...interface {}) Object {
// 	n, err := _fmt.Scanf(format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Scanln:
// func scanln(a ...interface {}) Object {
// 	n, err := _fmt.Scanln(a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscan:
// func sscan(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscan(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanf:
// func sscanf(str string, format string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanf(str, format, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC fmt.Sscanln:
// func sscanln(str string, a ...interface {}) Object {
// 	n, err := _fmt.Sscanln(str, a)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/ast.Inspect:
// func inspect(node go/ast.Node, f func) Object {
// 	_ast.Inspect(node, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.MergePackageFiles:
// func mergePackageFiles(pkg *go/ast.Package, mode go/ast.MergeMode) Object {
// 	_res := _ast.MergePackageFiles(pkg, mode)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		var _obj_map2 Object
// 		if (*_res).Doc != nil {
// 			_map2 := EmptyArrayMap()
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*(*_res).Doc).List {
// 				var _obj_map4 Object
// 				if _elem3 != nil {
// 					_map4 := EmptyArrayMap()
// 					_map4.Add(MakeKeyword("Slash"), MakeInt((*_elem3).Slash))
// 					_map4.Add(MakeKeyword("Text"), MakeString((*_elem3).Text))
// 					_obj_map4 = Object(_map4)
// 				} else {
// 					_obj_map4 = NIL
// 				}
// 				_vec3 = _vec3.Conjoin(_obj_map4)
// 			}
// 			_map2.Add(MakeKeyword("List"), _vec3)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Doc"), _obj_map2)
// 		_map1.Add(MakeKeyword("Package"), MakeInt((*_res).Package))
// 		var _obj_map5 Object
// 		if (*_res).Name != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("NamePos"), MakeInt((*(*_res).Name).NamePos))
// 			_map5.Add(MakeKeyword("Name"), MakeString((*(*_res).Name).Name))
// 			var _obj_map6 Object
// 			if (*(*_res).Name).Obj != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Kind"), MakeInt((*(*(*_res).Name).Obj).Kind))
// 				_map6.Add(MakeKeyword("Name"), MakeString((*(*(*_res).Name).Obj).Name))
// 				_map6.Add(MakeKeyword("Decl"), (*(*(*_res).Name).Obj).Decl)
// 				_map6.Add(MakeKeyword("Data"), (*(*(*_res).Name).Obj).Data)
// 				_map6.Add(MakeKeyword("Type"), (*(*(*_res).Name).Obj).Type)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map5.Add(MakeKeyword("Obj"), _obj_map6)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Name"), _obj_map5)
// 		_vec7 := EmptyVector
// 		for _, _elem7 := range (*_res).Decls {
// 			_vec7 = _vec7.Conjoin(_elem7)
// 		}
// 		_map1.Add(MakeKeyword("Decls"), _vec7)
// 		var _obj_map8 Object
// 		if (*_res).Scope != nil {
// 			_map8 := EmptyArrayMap()
// 			_map8.Add(MakeKeyword("Outer"), )
// 			_map8.Add(MakeKeyword("Objects"), (*(*_res).Scope).Objects)
// 			_obj_map8 = Object(_map8)
// 		} else {
// 			_obj_map8 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Scope"), _obj_map8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res).Imports {
// 			var _obj_map10 Object
// 			if _elem9 != nil {
// 				_map10 := EmptyArrayMap()
// 				var _obj_map11 Object
// 				if (*_elem9).Doc != nil {
// 					_map11 := EmptyArrayMap()
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*(*_elem9).Doc).List {
// 						var _obj_map13 Object
// 						if _elem12 != nil {
// 							_map13 := EmptyArrayMap()
// 							_map13.Add(MakeKeyword("Slash"), MakeInt((*_elem12).Slash))
// 							_map13.Add(MakeKeyword("Text"), MakeString((*_elem12).Text))
// 							_obj_map13 = Object(_map13)
// 						} else {
// 							_obj_map13 = NIL
// 						}
// 						_vec12 = _vec12.Conjoin(_obj_map13)
// 					}
// 					_map11.Add(MakeKeyword("List"), _vec12)
// 					_obj_map11 = Object(_map11)
// 				} else {
// 					_obj_map11 = NIL
// 				}
// 				_map10.Add(MakeKeyword("Doc"), _obj_map11)
// 				var _obj_map14 Object
// 				if (*_elem9).Name != nil {
// 					_map14 := EmptyArrayMap()
// 					_map14.Add(MakeKeyword("NamePos"), MakeInt((*(*_elem9).Name).NamePos))
// 					_map14.Add(MakeKeyword("Name"), MakeString((*(*_elem9).Name).Name))
// 					var _obj_map15 Object
// 					if (*(*_elem9).Name).Obj != nil {
// 						_map15 := EmptyArrayMap()
// 						_map15.Add(MakeKeyword("Kind"), MakeInt((*(*(*_elem9).Name).Obj).Kind))
// 						_map15.Add(MakeKeyword("Name"), MakeString((*(*(*_elem9).Name).Obj).Name))
// 						_map15.Add(MakeKeyword("Decl"), (*(*(*_elem9).Name).Obj).Decl)
// 						_map15.Add(MakeKeyword("Data"), (*(*(*_elem9).Name).Obj).Data)
// 						_map15.Add(MakeKeyword("Type"), (*(*(*_elem9).Name).Obj).Type)
// 						_obj_map15 = Object(_map15)
// 					} else {
// 						_obj_map15 = NIL
// 					}
// 					_map14.Add(MakeKeyword("Obj"), _obj_map15)
// 					_obj_map14 = Object(_map14)
// 				} else {
// 					_obj_map14 = NIL
// 				}
// 				_map10.Add(MakeKeyword("Name"), _obj_map14)
// 				var _obj_map16 Object
// 				if (*_elem9).Path != nil {
// 					_map16 := EmptyArrayMap()
// 					_map16.Add(MakeKeyword("ValuePos"), MakeInt((*(*_elem9).Path).ValuePos))
// 					_map16.Add(MakeKeyword("Kind"), MakeInt((*(*_elem9).Path).Kind))
// 					_map16.Add(MakeKeyword("Value"), MakeString((*(*_elem9).Path).Value))
// 					_obj_map16 = Object(_map16)
// 				} else {
// 					_obj_map16 = NIL
// 				}
// 				_map10.Add(MakeKeyword("Path"), _obj_map16)
// 				var _obj_map17 Object
// 				if (*_elem9).Comment != nil {
// 					_map17 := EmptyArrayMap()
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*(*_elem9).Comment).List {
// 						var _obj_map19 Object
// 						if _elem18 != nil {
// 							_map19 := EmptyArrayMap()
// 							_map19.Add(MakeKeyword("Slash"), MakeInt((*_elem18).Slash))
// 							_map19.Add(MakeKeyword("Text"), MakeString((*_elem18).Text))
// 							_obj_map19 = Object(_map19)
// 						} else {
// 							_obj_map19 = NIL
// 						}
// 						_vec18 = _vec18.Conjoin(_obj_map19)
// 					}
// 					_map17.Add(MakeKeyword("List"), _vec18)
// 					_obj_map17 = Object(_map17)
// 				} else {
// 					_obj_map17 = NIL
// 				}
// 				_map10.Add(MakeKeyword("Comment"), _obj_map17)
// 				_map10.Add(MakeKeyword("EndPos"), MakeInt((*_elem9).EndPos))
// 				_obj_map10 = Object(_map10)
// 			} else {
// 				_obj_map10 = NIL
// 			}
// 			_vec9 = _vec9.Conjoin(_obj_map10)
// 		}
// 		_map1.Add(MakeKeyword("Imports"), _vec9)
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res).Unresolved {
// 			var _obj_map21 Object
// 			if _elem20 != nil {
// 				_map21 := EmptyArrayMap()
// 				_map21.Add(MakeKeyword("NamePos"), MakeInt((*_elem20).NamePos))
// 				_map21.Add(MakeKeyword("Name"), MakeString((*_elem20).Name))
// 				var _obj_map22 Object
// 				if (*_elem20).Obj != nil {
// 					_map22 := EmptyArrayMap()
// 					_map22.Add(MakeKeyword("Kind"), MakeInt((*(*_elem20).Obj).Kind))
// 					_map22.Add(MakeKeyword("Name"), MakeString((*(*_elem20).Obj).Name))
// 					_map22.Add(MakeKeyword("Decl"), (*(*_elem20).Obj).Decl)
// 					_map22.Add(MakeKeyword("Data"), (*(*_elem20).Obj).Data)
// 					_map22.Add(MakeKeyword("Type"), (*(*_elem20).Obj).Type)
// 					_obj_map22 = Object(_map22)
// 				} else {
// 					_obj_map22 = NIL
// 				}
// 				_map21.Add(MakeKeyword("Obj"), _obj_map22)
// 				_obj_map21 = Object(_map21)
// 			} else {
// 				_obj_map21 = NIL
// 			}
// 			_vec20 = _vec20.Conjoin(_obj_map21)
// 		}
// 		_map1.Add(MakeKeyword("Unresolved"), _vec20)
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res).Comments {
// 			var _obj_map24 Object
// 			if _elem23 != nil {
// 				_map24 := EmptyArrayMap()
// 				_vec25 := EmptyVector
// 				for _, _elem25 := range (*_elem23).List {
// 					var _obj_map26 Object
// 					if _elem25 != nil {
// 						_map26 := EmptyArrayMap()
// 						_map26.Add(MakeKeyword("Slash"), MakeInt((*_elem25).Slash))
// 						_map26.Add(MakeKeyword("Text"), MakeString((*_elem25).Text))
// 						_obj_map26 = Object(_map26)
// 					} else {
// 						_obj_map26 = NIL
// 					}
// 					_vec25 = _vec25.Conjoin(_obj_map26)
// 				}
// 				_map24.Add(MakeKeyword("List"), _vec25)
// 				_obj_map24 = Object(_map24)
// 			} else {
// 				_obj_map24 = NIL
// 			}
// 			_vec23 = _vec23.Conjoin(_obj_map24)
// 		}
// 		_map1.Add(MakeKeyword("Comments"), _vec23)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC go/ast.NewCommentMap:
// func newCommentMap(fset *go/token.FileSet, node go/ast.Node, comments []*go/ast.CommentGroup) Object {
// 	return _ast.NewCommentMap(fset, node, comments)
// }

GO FUNC go/ast.NewIdent:
// func newIdent(name string) Object {
// 	_res := _ast.NewIdent(name)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("NamePos"), MakeInt((*_res).NamePos))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res).Name))
// 		var _obj_map2 Object
// 		if (*_res).Obj != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Kind"), MakeInt((*(*_res).Obj).Kind))
// 			_map2.Add(MakeKeyword("Name"), MakeString((*(*_res).Obj).Name))
// 			_map2.Add(MakeKeyword("Decl"), (*(*_res).Obj).Decl)
// 			_map2.Add(MakeKeyword("Data"), (*(*_res).Obj).Data)
// 			_map2.Add(MakeKeyword("Type"), (*(*_res).Obj).Type)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Obj"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC go/ast.NewObj:
// func newObj(kind go/ast.ObjKind, name string) Object {
// 	_res := _ast.NewObj(kind, name)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Kind"), MakeInt((*_res).Kind))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res).Name))
// 		_map1.Add(MakeKeyword("Decl"), (*_res).Decl)
// 		_map1.Add(MakeKeyword("Data"), (*_res).Data)
// 		_map1.Add(MakeKeyword("Type"), (*_res).Type)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC go/ast.NewPackage:
// func newPackage(fset *go/token.FileSet, files map[], importer go/ast.Importer, universe *go/ast.Scope) Object {
// 	_res1, _res2 := _ast.NewPackage(fset, files, importer, universe)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		var _obj_map2 Object
// 		if (*_res1).Scope != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Outer"), )
// 			_map2.Add(MakeKeyword("Objects"), (*(*_res1).Scope).Objects)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Scope"), _obj_map2)
// 		_map1.Add(MakeKeyword("Imports"), (*_res1).Imports)
// 		_map1.Add(MakeKeyword("Files"), (*_res1).Files)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/ast.NewScope:
// func newScope(outer *go/ast.Scope) Object {
// 	_res := _ast.NewScope(outer)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Outer"), )
// 		_map1.Add(MakeKeyword("Objects"), (*_res).Objects)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC go/ast.SortImports:
// func sortImports(fset *go/token.FileSet, f *go/ast.File) Object {
// 	_ast.SortImports(fset, f)
// 	...ABEND675: TODO...
// }

GO FUNC go/ast.Walk:
// func walk(v go/ast.Visitor, node go/ast.Node) Object {
// 	_ast.Walk(v, node)
// 	...ABEND675: TODO...
// }

GO FUNC go/build.ArchChar:
func archChar(goarch string) Object {
	_res1, _res2 := _build.ArchChar(goarch)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/build.Import:
// func import(path string, srcDir string, mode go/build.ImportMode) Object {
// 	_res1, _res2 := _build.Import(path, srcDir, mode)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Dir"), MakeString((*_res1).Dir))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		_map1.Add(MakeKeyword("ImportComment"), MakeString((*_res1).ImportComment))
// 		_map1.Add(MakeKeyword("Doc"), MakeString((*_res1).Doc))
// 		_map1.Add(MakeKeyword("ImportPath"), MakeString((*_res1).ImportPath))
// 		_map1.Add(MakeKeyword("Root"), MakeString((*_res1).Root))
// 		_map1.Add(MakeKeyword("SrcRoot"), MakeString((*_res1).SrcRoot))
// 		_map1.Add(MakeKeyword("PkgRoot"), MakeString((*_res1).PkgRoot))
// 		_map1.Add(MakeKeyword("PkgTargetRoot"), MakeString((*_res1).PkgTargetRoot))
// 		_map1.Add(MakeKeyword("BinDir"), MakeString((*_res1).BinDir))
// 		_map1.Add(MakeKeyword("Goroot"), MakeBool((*_res1).Goroot))
// 		_map1.Add(MakeKeyword("PkgObj"), MakeString((*_res1).PkgObj))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).AllTags {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("AllTags"), _vec2)
// 		_map1.Add(MakeKeyword("ConflictDir"), MakeString((*_res1).ConflictDir))
// 		_map1.Add(MakeKeyword("BinaryOnly"), MakeBool((*_res1).BinaryOnly))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).GoFiles {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("GoFiles"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res1).CgoFiles {
// 			_vec4 = _vec4.Conjoin(MakeString(_elem4))
// 		}
// 		_map1.Add(MakeKeyword("CgoFiles"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res1).IgnoredGoFiles {
// 			_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 		}
// 		_map1.Add(MakeKeyword("IgnoredGoFiles"), _vec5)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).InvalidGoFiles {
// 			_vec6 = _vec6.Conjoin(MakeString(_elem6))
// 		}
// 		_map1.Add(MakeKeyword("InvalidGoFiles"), _vec6)
// 		_vec7 := EmptyVector
// 		for _, _elem7 := range (*_res1).CFiles {
// 			_vec7 = _vec7.Conjoin(MakeString(_elem7))
// 		}
// 		_map1.Add(MakeKeyword("CFiles"), _vec7)
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1).CXXFiles {
// 			_vec8 = _vec8.Conjoin(MakeString(_elem8))
// 		}
// 		_map1.Add(MakeKeyword("CXXFiles"), _vec8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res1).MFiles {
// 			_vec9 = _vec9.Conjoin(MakeString(_elem9))
// 		}
// 		_map1.Add(MakeKeyword("MFiles"), _vec9)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1).HFiles {
// 			_vec10 = _vec10.Conjoin(MakeString(_elem10))
// 		}
// 		_map1.Add(MakeKeyword("HFiles"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).FFiles {
// 			_vec11 = _vec11.Conjoin(MakeString(_elem11))
// 		}
// 		_map1.Add(MakeKeyword("FFiles"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1).SFiles {
// 			_vec12 = _vec12.Conjoin(MakeString(_elem12))
// 		}
// 		_map1.Add(MakeKeyword("SFiles"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1).SwigFiles {
// 			_vec13 = _vec13.Conjoin(MakeString(_elem13))
// 		}
// 		_map1.Add(MakeKeyword("SwigFiles"), _vec13)
// 		_vec14 := EmptyVector
// 		for _, _elem14 := range (*_res1).SwigCXXFiles {
// 			_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 		}
// 		_map1.Add(MakeKeyword("SwigCXXFiles"), _vec14)
// 		_vec15 := EmptyVector
// 		for _, _elem15 := range (*_res1).SysoFiles {
// 			_vec15 = _vec15.Conjoin(MakeString(_elem15))
// 		}
// 		_map1.Add(MakeKeyword("SysoFiles"), _vec15)
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1).CgoCFLAGS {
// 			_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 		}
// 		_map1.Add(MakeKeyword("CgoCFLAGS"), _vec16)
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1).CgoCPPFLAGS {
// 			_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 		}
// 		_map1.Add(MakeKeyword("CgoCPPFLAGS"), _vec17)
// 		_vec18 := EmptyVector
// 		for _, _elem18 := range (*_res1).CgoCXXFLAGS {
// 			_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 		}
// 		_map1.Add(MakeKeyword("CgoCXXFLAGS"), _vec18)
// 		_vec19 := EmptyVector
// 		for _, _elem19 := range (*_res1).CgoFFLAGS {
// 			_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 		}
// 		_map1.Add(MakeKeyword("CgoFFLAGS"), _vec19)
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res1).CgoLDFLAGS {
// 			_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 		}
// 		_map1.Add(MakeKeyword("CgoLDFLAGS"), _vec20)
// 		_vec21 := EmptyVector
// 		for _, _elem21 := range (*_res1).CgoPkgConfig {
// 			_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 		}
// 		_map1.Add(MakeKeyword("CgoPkgConfig"), _vec21)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1).Imports {
// 			_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 		}
// 		_map1.Add(MakeKeyword("Imports"), _vec22)
// 		_map1.Add(MakeKeyword("ImportPos"), (*_res1).ImportPos)
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res1).TestGoFiles {
// 			_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 		}
// 		_map1.Add(MakeKeyword("TestGoFiles"), _vec23)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1).TestImports {
// 			_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 		}
// 		_map1.Add(MakeKeyword("TestImports"), _vec24)
// 		_map1.Add(MakeKeyword("TestImportPos"), (*_res1).TestImportPos)
// 		_vec25 := EmptyVector
// 		for _, _elem25 := range (*_res1).XTestGoFiles {
// 			_vec25 = _vec25.Conjoin(MakeString(_elem25))
// 		}
// 		_map1.Add(MakeKeyword("XTestGoFiles"), _vec25)
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1).XTestImports {
// 			_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 		}
// 		_map1.Add(MakeKeyword("XTestImports"), _vec26)
// 		_map1.Add(MakeKeyword("XTestImportPos"), (*_res1).XTestImportPos)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/build.ImportDir:
// func importDir(dir string, mode go/build.ImportMode) Object {
// 	_res1, _res2 := _build.ImportDir(dir, mode)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Dir"), MakeString((*_res1).Dir))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		_map1.Add(MakeKeyword("ImportComment"), MakeString((*_res1).ImportComment))
// 		_map1.Add(MakeKeyword("Doc"), MakeString((*_res1).Doc))
// 		_map1.Add(MakeKeyword("ImportPath"), MakeString((*_res1).ImportPath))
// 		_map1.Add(MakeKeyword("Root"), MakeString((*_res1).Root))
// 		_map1.Add(MakeKeyword("SrcRoot"), MakeString((*_res1).SrcRoot))
// 		_map1.Add(MakeKeyword("PkgRoot"), MakeString((*_res1).PkgRoot))
// 		_map1.Add(MakeKeyword("PkgTargetRoot"), MakeString((*_res1).PkgTargetRoot))
// 		_map1.Add(MakeKeyword("BinDir"), MakeString((*_res1).BinDir))
// 		_map1.Add(MakeKeyword("Goroot"), MakeBool((*_res1).Goroot))
// 		_map1.Add(MakeKeyword("PkgObj"), MakeString((*_res1).PkgObj))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).AllTags {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("AllTags"), _vec2)
// 		_map1.Add(MakeKeyword("ConflictDir"), MakeString((*_res1).ConflictDir))
// 		_map1.Add(MakeKeyword("BinaryOnly"), MakeBool((*_res1).BinaryOnly))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).GoFiles {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("GoFiles"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res1).CgoFiles {
// 			_vec4 = _vec4.Conjoin(MakeString(_elem4))
// 		}
// 		_map1.Add(MakeKeyword("CgoFiles"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res1).IgnoredGoFiles {
// 			_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 		}
// 		_map1.Add(MakeKeyword("IgnoredGoFiles"), _vec5)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).InvalidGoFiles {
// 			_vec6 = _vec6.Conjoin(MakeString(_elem6))
// 		}
// 		_map1.Add(MakeKeyword("InvalidGoFiles"), _vec6)
// 		_vec7 := EmptyVector
// 		for _, _elem7 := range (*_res1).CFiles {
// 			_vec7 = _vec7.Conjoin(MakeString(_elem7))
// 		}
// 		_map1.Add(MakeKeyword("CFiles"), _vec7)
// 		_vec8 := EmptyVector
// 		for _, _elem8 := range (*_res1).CXXFiles {
// 			_vec8 = _vec8.Conjoin(MakeString(_elem8))
// 		}
// 		_map1.Add(MakeKeyword("CXXFiles"), _vec8)
// 		_vec9 := EmptyVector
// 		for _, _elem9 := range (*_res1).MFiles {
// 			_vec9 = _vec9.Conjoin(MakeString(_elem9))
// 		}
// 		_map1.Add(MakeKeyword("MFiles"), _vec9)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res1).HFiles {
// 			_vec10 = _vec10.Conjoin(MakeString(_elem10))
// 		}
// 		_map1.Add(MakeKeyword("HFiles"), _vec10)
// 		_vec11 := EmptyVector
// 		for _, _elem11 := range (*_res1).FFiles {
// 			_vec11 = _vec11.Conjoin(MakeString(_elem11))
// 		}
// 		_map1.Add(MakeKeyword("FFiles"), _vec11)
// 		_vec12 := EmptyVector
// 		for _, _elem12 := range (*_res1).SFiles {
// 			_vec12 = _vec12.Conjoin(MakeString(_elem12))
// 		}
// 		_map1.Add(MakeKeyword("SFiles"), _vec12)
// 		_vec13 := EmptyVector
// 		for _, _elem13 := range (*_res1).SwigFiles {
// 			_vec13 = _vec13.Conjoin(MakeString(_elem13))
// 		}
// 		_map1.Add(MakeKeyword("SwigFiles"), _vec13)
// 		_vec14 := EmptyVector
// 		for _, _elem14 := range (*_res1).SwigCXXFiles {
// 			_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 		}
// 		_map1.Add(MakeKeyword("SwigCXXFiles"), _vec14)
// 		_vec15 := EmptyVector
// 		for _, _elem15 := range (*_res1).SysoFiles {
// 			_vec15 = _vec15.Conjoin(MakeString(_elem15))
// 		}
// 		_map1.Add(MakeKeyword("SysoFiles"), _vec15)
// 		_vec16 := EmptyVector
// 		for _, _elem16 := range (*_res1).CgoCFLAGS {
// 			_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 		}
// 		_map1.Add(MakeKeyword("CgoCFLAGS"), _vec16)
// 		_vec17 := EmptyVector
// 		for _, _elem17 := range (*_res1).CgoCPPFLAGS {
// 			_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 		}
// 		_map1.Add(MakeKeyword("CgoCPPFLAGS"), _vec17)
// 		_vec18 := EmptyVector
// 		for _, _elem18 := range (*_res1).CgoCXXFLAGS {
// 			_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 		}
// 		_map1.Add(MakeKeyword("CgoCXXFLAGS"), _vec18)
// 		_vec19 := EmptyVector
// 		for _, _elem19 := range (*_res1).CgoFFLAGS {
// 			_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 		}
// 		_map1.Add(MakeKeyword("CgoFFLAGS"), _vec19)
// 		_vec20 := EmptyVector
// 		for _, _elem20 := range (*_res1).CgoLDFLAGS {
// 			_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 		}
// 		_map1.Add(MakeKeyword("CgoLDFLAGS"), _vec20)
// 		_vec21 := EmptyVector
// 		for _, _elem21 := range (*_res1).CgoPkgConfig {
// 			_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 		}
// 		_map1.Add(MakeKeyword("CgoPkgConfig"), _vec21)
// 		_vec22 := EmptyVector
// 		for _, _elem22 := range (*_res1).Imports {
// 			_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 		}
// 		_map1.Add(MakeKeyword("Imports"), _vec22)
// 		_map1.Add(MakeKeyword("ImportPos"), (*_res1).ImportPos)
// 		_vec23 := EmptyVector
// 		for _, _elem23 := range (*_res1).TestGoFiles {
// 			_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 		}
// 		_map1.Add(MakeKeyword("TestGoFiles"), _vec23)
// 		_vec24 := EmptyVector
// 		for _, _elem24 := range (*_res1).TestImports {
// 			_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 		}
// 		_map1.Add(MakeKeyword("TestImports"), _vec24)
// 		_map1.Add(MakeKeyword("TestImportPos"), (*_res1).TestImportPos)
// 		_vec25 := EmptyVector
// 		for _, _elem25 := range (*_res1).XTestGoFiles {
// 			_vec25 = _vec25.Conjoin(MakeString(_elem25))
// 		}
// 		_map1.Add(MakeKeyword("XTestGoFiles"), _vec25)
// 		_vec26 := EmptyVector
// 		for _, _elem26 := range (*_res1).XTestImports {
// 			_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 		}
// 		_map1.Add(MakeKeyword("XTestImports"), _vec26)
// 		_map1.Add(MakeKeyword("XTestImportPos"), (*_res1).XTestImportPos)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/constant.BinaryOp:
// func binaryOp(x_ go/constant.Value, op go/token.Token, y_ go/constant.Value) Object {
// 	return _constant.BinaryOp(x_, op, y_)
// }

GO FUNC go/constant.Bytes:
// func bytes(x go/constant.Value) Object {
// 	_res := _constant.Bytes(x)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC go/constant.Denom:
// func denom(x go/constant.Value) Object {
// 	return _constant.Denom(x)
// }

GO FUNC go/constant.Float32Val:
// func float32Val(x go/constant.Value) Object {
// 	_res1, _res2 := _constant.Float32Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.Float64Val:
// func float64Val(x go/constant.Value) Object {
// 	_res1, _res2 := _constant.Float64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.Imag:
// func imag(x go/constant.Value) Object {
// 	return _constant.Imag(x)
// }

GO FUNC go/constant.Int64Val:
// func int64Val(x go/constant.Value) Object {
// 	_res1, _res2 := _constant.Int64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(_res1)))
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.MakeBool:
// func makeBool(b bool) Object {
// 	return _constant.MakeBool(b)
// }

GO FUNC go/constant.MakeFloat64:
// func makeFloat64(x float64) Object {
// 	return _constant.MakeFloat64(x)
// }

GO FUNC go/constant.MakeFromBytes:
// func makeFromBytes(bytes []byte) Object {
// 	return _constant.MakeFromBytes(bytes)
// }

GO FUNC go/constant.MakeFromLiteral:
// func makeFromLiteral(lit string, tok go/token.Token, zero uint) Object {
// 	return _constant.MakeFromLiteral(lit, tok, zero)
// }

GO FUNC go/constant.MakeImag:
// func makeImag(x go/constant.Value) Object {
// 	return _constant.MakeImag(x)
// }

GO FUNC go/constant.MakeInt64:
// func makeInt64(x int64) Object {
// 	return _constant.MakeInt64(x)
// }

GO FUNC go/constant.MakeString:
// func makeString(s string) Object {
// 	return _constant.MakeString(s)
// }

GO FUNC go/constant.MakeUint64:
// func makeUint64(x uint64) Object {
// 	return _constant.MakeUint64(x)
// }

GO FUNC go/constant.MakeUnknown:
// func makeUnknown() Object {
// 	return _constant.MakeUnknown()
// }

GO FUNC go/constant.Num:
// func num(x go/constant.Value) Object {
// 	return _constant.Num(x)
// }

GO FUNC go/constant.Real:
// func real(x go/constant.Value) Object {
// 	return _constant.Real(x)
// }

GO FUNC go/constant.Shift:
// func shift(x go/constant.Value, op go/token.Token, s uint) Object {
// 	return _constant.Shift(x, op, s)
// }

GO FUNC go/constant.ToComplex:
// func toComplex(x go/constant.Value) Object {
// 	return _constant.ToComplex(x)
// }

GO FUNC go/constant.ToFloat:
// func toFloat(x go/constant.Value) Object {
// 	return _constant.ToFloat(x)
// }

GO FUNC go/constant.ToInt:
// func toInt(x go/constant.Value) Object {
// 	return _constant.ToInt(x)
// }

GO FUNC go/constant.Uint64Val:
// func uint64Val(x go/constant.Value) Object {
// 	_res1, _res2 := _constant.Uint64Val(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC go/constant.UnaryOp:
// func unaryOp(op go/token.Token, y go/constant.Value, prec uint) Object {
// 	return _constant.UnaryOp(op, y, prec)
// }

GO FUNC go/doc.Examples:
// func examples(files ...*go/ast.File) Object {
// 	_res := _doc.Examples(files)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		var _obj_map2 Object
// 		if _elem1 != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Name"), MakeString((*_elem1).Name))
// 			_map2.Add(MakeKeyword("Doc"), MakeString((*_elem1).Doc))
// 			_map2.Add(MakeKeyword("Code"), (*_elem1).Code)
// 			var _obj_map3 Object
// 			if (*_elem1).Play != nil {
// 				_map3 := EmptyArrayMap()
// 				_map3.Add(MakeKeyword("Doc"), (*(*(*_elem1).Play).Doc))
// 				_map3.Add(MakeKeyword("Package"), MakeInt((*(*_elem1).Play).Package))
// 				_map3.Add(MakeKeyword("Name"), (*(*(*_elem1).Play).Name))
// 				_vec4 := EmptyVector
// 				for _, _elem4 := range (*(*_elem1).Play).Decls {
// 					_vec4 = _vec4.Conjoin(_elem4)
// 				}
// 				_map3.Add(MakeKeyword("Decls"), _vec4)
// 				_map3.Add(MakeKeyword("Scope"), (*(*(*_elem1).Play).Scope))
// 				_vec5 := EmptyVector
// 				for _, _elem5 := range (*(*_elem1).Play).Imports {
// 					_vec5 = _vec5.Conjoin((*_elem5))
// 				}
// 				_map3.Add(MakeKeyword("Imports"), _vec5)
// 				_vec6 := EmptyVector
// 				for _, _elem6 := range (*(*_elem1).Play).Unresolved {
// 					_vec6 = _vec6.Conjoin((*_elem6))
// 				}
// 				_map3.Add(MakeKeyword("Unresolved"), _vec6)
// 				_vec7 := EmptyVector
// 				for _, _elem7 := range (*(*_elem1).Play).Comments {
// 					_vec7 = _vec7.Conjoin((*_elem7))
// 				}
// 				_map3.Add(MakeKeyword("Comments"), _vec7)
// 				_obj_map3 = Object(_map3)
// 			} else {
// 				_obj_map3 = NIL
// 			}
// 			_map2.Add(MakeKeyword("Play"), _obj_map3)
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*_elem1).Comments {
// 				var _obj_map9 Object
// 				if _elem8 != nil {
// 					_map9 := EmptyArrayMap()
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem8).List {
// 						_vec10 = _vec10.Conjoin((*_elem10))
// 					}
// 					_map9.Add(MakeKeyword("List"), _vec10)
// 					_obj_map9 = Object(_map9)
// 				} else {
// 					_obj_map9 = NIL
// 				}
// 				_vec8 = _vec8.Conjoin(_obj_map9)
// 			}
// 			_map2.Add(MakeKeyword("Comments"), _vec8)
// 			_map2.Add(MakeKeyword("Output"), MakeString((*_elem1).Output))
// 			_map2.Add(MakeKeyword("Unordered"), MakeBool((*_elem1).Unordered))
// 			_map2.Add(MakeKeyword("EmptyOutput"), MakeBool((*_elem1).EmptyOutput))
// 			_map2.Add(MakeKeyword("Order"), MakeInt((*_elem1).Order))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_vec1 = _vec1.Conjoin(_obj_map2)
// 	}
// 	return _vec1
// }

GO FUNC go/doc.New:
// func new(pkg *go/ast.Package, importPath string, mode go/doc.Mode) Object {
// 	_res := _doc.New(pkg, importPath, mode)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Doc"), MakeString((*_res).Doc))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res).Name))
// 		_map1.Add(MakeKeyword("ImportPath"), MakeString((*_res).ImportPath))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Imports {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("Imports"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).Filenames {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("Filenames"), _vec3)
// 		_map1.Add(MakeKeyword("Notes"), (*_res).Notes)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res).Bugs {
// 			_vec4 = _vec4.Conjoin(MakeString(_elem4))
// 		}
// 		_map1.Add(MakeKeyword("Bugs"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res).Consts {
// 			var _obj_map6 Object
// 			if _elem5 != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Doc"), MakeString((*_elem5).Doc))
// 				_vec7 := EmptyVector
// 				for _, _elem7 := range (*_elem5).Names {
// 					_vec7 = _vec7.Conjoin(MakeString(_elem7))
// 				}
// 				_map6.Add(MakeKeyword("Names"), _vec7)
// 				var _obj_map8 Object
// 				if (*_elem5).Decl != nil {
// 					_map8 := EmptyArrayMap()
// 					_map8.Add(MakeKeyword("Doc"), (*(*(*_elem5).Decl).Doc))
// 					_map8.Add(MakeKeyword("TokPos"), MakeInt((*(*_elem5).Decl).TokPos))
// 					_map8.Add(MakeKeyword("Tok"), MakeInt((*(*_elem5).Decl).Tok))
// 					_map8.Add(MakeKeyword("Lparen"), MakeInt((*(*_elem5).Decl).Lparen))
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*(*_elem5).Decl).Specs {
// 						_vec9 = _vec9.Conjoin(_elem9)
// 					}
// 					_map8.Add(MakeKeyword("Specs"), _vec9)
// 					_map8.Add(MakeKeyword("Rparen"), MakeInt((*(*_elem5).Decl).Rparen))
// 					_obj_map8 = Object(_map8)
// 				} else {
// 					_obj_map8 = NIL
// 				}
// 				_map6.Add(MakeKeyword("Decl"), _obj_map8)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_vec5 = _vec5.Conjoin(_obj_map6)
// 		}
// 		_map1.Add(MakeKeyword("Consts"), _vec5)
// 		_vec10 := EmptyVector
// 		for _, _elem10 := range (*_res).Types {
// 			var _obj_map11 Object
// 			if _elem10 != nil {
// 				_map11 := EmptyArrayMap()
// 				_map11.Add(MakeKeyword("Doc"), MakeString((*_elem10).Doc))
// 				_map11.Add(MakeKeyword("Name"), MakeString((*_elem10).Name))
// 				var _obj_map12 Object
// 				if (*_elem10).Decl != nil {
// 					_map12 := EmptyArrayMap()
// 					_map12.Add(MakeKeyword("Doc"), (*(*(*_elem10).Decl).Doc))
// 					_map12.Add(MakeKeyword("TokPos"), MakeInt((*(*_elem10).Decl).TokPos))
// 					_map12.Add(MakeKeyword("Tok"), MakeInt((*(*_elem10).Decl).Tok))
// 					_map12.Add(MakeKeyword("Lparen"), MakeInt((*(*_elem10).Decl).Lparen))
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*(*_elem10).Decl).Specs {
// 						_vec13 = _vec13.Conjoin(_elem13)
// 					}
// 					_map12.Add(MakeKeyword("Specs"), _vec13)
// 					_map12.Add(MakeKeyword("Rparen"), MakeInt((*(*_elem10).Decl).Rparen))
// 					_obj_map12 = Object(_map12)
// 				} else {
// 					_obj_map12 = NIL
// 				}
// 				_map11.Add(MakeKeyword("Decl"), _obj_map12)
// 				_vec14 := EmptyVector
// 				for _, _elem14 := range (*_elem10).Consts {
// 					var _obj_map15 Object
// 					if _elem14 != nil {
// 						_map15 := EmptyArrayMap()
// 						_map15.Add(MakeKeyword("Doc"), MakeString((*_elem14).Doc))
// 						_vec16 := EmptyVector
// 						for _, _elem16 := range (*_elem14).Names {
// 							_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 						}
// 						_map15.Add(MakeKeyword("Names"), _vec16)
// 						var _obj_map17 Object
// 						if (*_elem14).Decl != nil {
// 							_map17 := EmptyArrayMap()
// 							_map17.Add(MakeKeyword("Doc"), (*(*(*_elem14).Decl).Doc))
// 							_map17.Add(MakeKeyword("TokPos"), MakeInt((*(*_elem14).Decl).TokPos))
// 							_map17.Add(MakeKeyword("Tok"), MakeInt((*(*_elem14).Decl).Tok))
// 							_map17.Add(MakeKeyword("Lparen"), MakeInt((*(*_elem14).Decl).Lparen))
// 							_vec18 := EmptyVector
// 							for _, _elem18 := range (*(*_elem14).Decl).Specs {
// 								_vec18 = _vec18.Conjoin(_elem18)
// 							}
// 							_map17.Add(MakeKeyword("Specs"), _vec18)
// 							_map17.Add(MakeKeyword("Rparen"), MakeInt((*(*_elem14).Decl).Rparen))
// 							_obj_map17 = Object(_map17)
// 						} else {
// 							_obj_map17 = NIL
// 						}
// 						_map15.Add(MakeKeyword("Decl"), _obj_map17)
// 						_obj_map15 = Object(_map15)
// 					} else {
// 						_obj_map15 = NIL
// 					}
// 					_vec14 = _vec14.Conjoin(_obj_map15)
// 				}
// 				_map11.Add(MakeKeyword("Consts"), _vec14)
// 				_vec19 := EmptyVector
// 				for _, _elem19 := range (*_elem10).Vars {
// 					var _obj_map20 Object
// 					if _elem19 != nil {
// 						_map20 := EmptyArrayMap()
// 						_map20.Add(MakeKeyword("Doc"), MakeString((*_elem19).Doc))
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem19).Names {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map20.Add(MakeKeyword("Names"), _vec21)
// 						var _obj_map22 Object
// 						if (*_elem19).Decl != nil {
// 							_map22 := EmptyArrayMap()
// 							_map22.Add(MakeKeyword("Doc"), (*(*(*_elem19).Decl).Doc))
// 							_map22.Add(MakeKeyword("TokPos"), MakeInt((*(*_elem19).Decl).TokPos))
// 							_map22.Add(MakeKeyword("Tok"), MakeInt((*(*_elem19).Decl).Tok))
// 							_map22.Add(MakeKeyword("Lparen"), MakeInt((*(*_elem19).Decl).Lparen))
// 							_vec23 := EmptyVector
// 							for _, _elem23 := range (*(*_elem19).Decl).Specs {
// 								_vec23 = _vec23.Conjoin(_elem23)
// 							}
// 							_map22.Add(MakeKeyword("Specs"), _vec23)
// 							_map22.Add(MakeKeyword("Rparen"), MakeInt((*(*_elem19).Decl).Rparen))
// 							_obj_map22 = Object(_map22)
// 						} else {
// 							_obj_map22 = NIL
// 						}
// 						_map20.Add(MakeKeyword("Decl"), _obj_map22)
// 						_obj_map20 = Object(_map20)
// 					} else {
// 						_obj_map20 = NIL
// 					}
// 					_vec19 = _vec19.Conjoin(_obj_map20)
// 				}
// 				_map11.Add(MakeKeyword("Vars"), _vec19)
// 				_vec24 := EmptyVector
// 				for _, _elem24 := range (*_elem10).Funcs {
// 					var _obj_map25 Object
// 					if _elem24 != nil {
// 						_map25 := EmptyArrayMap()
// 						_map25.Add(MakeKeyword("Doc"), MakeString((*_elem24).Doc))
// 						_map25.Add(MakeKeyword("Name"), MakeString((*_elem24).Name))
// 						var _obj_map26 Object
// 						if (*_elem24).Decl != nil {
// 							_map26 := EmptyArrayMap()
// 							_map26.Add(MakeKeyword("Doc"), (*(*(*_elem24).Decl).Doc))
// 							_map26.Add(MakeKeyword("Recv"), (*(*(*_elem24).Decl).Recv))
// 							_map26.Add(MakeKeyword("Name"), (*(*(*_elem24).Decl).Name))
// 							_map26.Add(MakeKeyword("Type"), (*(*(*_elem24).Decl).Type))
// 							_map26.Add(MakeKeyword("Body"), (*(*(*_elem24).Decl).Body))
// 							_obj_map26 = Object(_map26)
// 						} else {
// 							_obj_map26 = NIL
// 						}
// 						_map25.Add(MakeKeyword("Decl"), _obj_map26)
// 						_map25.Add(MakeKeyword("Recv"), MakeString((*_elem24).Recv))
// 						_map25.Add(MakeKeyword("Orig"), MakeString((*_elem24).Orig))
// 						_map25.Add(MakeKeyword("Level"), MakeInt((*_elem24).Level))
// 						_obj_map25 = Object(_map25)
// 					} else {
// 						_obj_map25 = NIL
// 					}
// 					_vec24 = _vec24.Conjoin(_obj_map25)
// 				}
// 				_map11.Add(MakeKeyword("Funcs"), _vec24)
// 				_vec27 := EmptyVector
// 				for _, _elem27 := range (*_elem10).Methods {
// 					var _obj_map28 Object
// 					if _elem27 != nil {
// 						_map28 := EmptyArrayMap()
// 						_map28.Add(MakeKeyword("Doc"), MakeString((*_elem27).Doc))
// 						_map28.Add(MakeKeyword("Name"), MakeString((*_elem27).Name))
// 						var _obj_map29 Object
// 						if (*_elem27).Decl != nil {
// 							_map29 := EmptyArrayMap()
// 							_map29.Add(MakeKeyword("Doc"), (*(*(*_elem27).Decl).Doc))
// 							_map29.Add(MakeKeyword("Recv"), (*(*(*_elem27).Decl).Recv))
// 							_map29.Add(MakeKeyword("Name"), (*(*(*_elem27).Decl).Name))
// 							_map29.Add(MakeKeyword("Type"), (*(*(*_elem27).Decl).Type))
// 							_map29.Add(MakeKeyword("Body"), (*(*(*_elem27).Decl).Body))
// 							_obj_map29 = Object(_map29)
// 						} else {
// 							_obj_map29 = NIL
// 						}
// 						_map28.Add(MakeKeyword("Decl"), _obj_map29)
// 						_map28.Add(MakeKeyword("Recv"), MakeString((*_elem27).Recv))
// 						_map28.Add(MakeKeyword("Orig"), MakeString((*_elem27).Orig))
// 						_map28.Add(MakeKeyword("Level"), MakeInt((*_elem27).Level))
// 						_obj_map28 = Object(_map28)
// 					} else {
// 						_obj_map28 = NIL
// 					}
// 					_vec27 = _vec27.Conjoin(_obj_map28)
// 				}
// 				_map11.Add(MakeKeyword("Methods"), _vec27)
// 				_obj_map11 = Object(_map11)
// 			} else {
// 				_obj_map11 = NIL
// 			}
// 			_vec10 = _vec10.Conjoin(_obj_map11)
// 		}
// 		_map1.Add(MakeKeyword("Types"), _vec10)
// 		_vec30 := EmptyVector
// 		for _, _elem30 := range (*_res).Vars {
// 			var _obj_map31 Object
// 			if _elem30 != nil {
// 				_map31 := EmptyArrayMap()
// 				_map31.Add(MakeKeyword("Doc"), MakeString((*_elem30).Doc))
// 				_vec32 := EmptyVector
// 				for _, _elem32 := range (*_elem30).Names {
// 					_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 				}
// 				_map31.Add(MakeKeyword("Names"), _vec32)
// 				var _obj_map33 Object
// 				if (*_elem30).Decl != nil {
// 					_map33 := EmptyArrayMap()
// 					_map33.Add(MakeKeyword("Doc"), (*(*(*_elem30).Decl).Doc))
// 					_map33.Add(MakeKeyword("TokPos"), MakeInt((*(*_elem30).Decl).TokPos))
// 					_map33.Add(MakeKeyword("Tok"), MakeInt((*(*_elem30).Decl).Tok))
// 					_map33.Add(MakeKeyword("Lparen"), MakeInt((*(*_elem30).Decl).Lparen))
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*(*_elem30).Decl).Specs {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map33.Add(MakeKeyword("Specs"), _vec34)
// 					_map33.Add(MakeKeyword("Rparen"), MakeInt((*(*_elem30).Decl).Rparen))
// 					_obj_map33 = Object(_map33)
// 				} else {
// 					_obj_map33 = NIL
// 				}
// 				_map31.Add(MakeKeyword("Decl"), _obj_map33)
// 				_obj_map31 = Object(_map31)
// 			} else {
// 				_obj_map31 = NIL
// 			}
// 			_vec30 = _vec30.Conjoin(_obj_map31)
// 		}
// 		_map1.Add(MakeKeyword("Vars"), _vec30)
// 		_vec35 := EmptyVector
// 		for _, _elem35 := range (*_res).Funcs {
// 			var _obj_map36 Object
// 			if _elem35 != nil {
// 				_map36 := EmptyArrayMap()
// 				_map36.Add(MakeKeyword("Doc"), MakeString((*_elem35).Doc))
// 				_map36.Add(MakeKeyword("Name"), MakeString((*_elem35).Name))
// 				var _obj_map37 Object
// 				if (*_elem35).Decl != nil {
// 					_map37 := EmptyArrayMap()
// 					_map37.Add(MakeKeyword("Doc"), (*(*(*_elem35).Decl).Doc))
// 					_map37.Add(MakeKeyword("Recv"), (*(*(*_elem35).Decl).Recv))
// 					_map37.Add(MakeKeyword("Name"), (*(*(*_elem35).Decl).Name))
// 					_map37.Add(MakeKeyword("Type"), (*(*(*_elem35).Decl).Type))
// 					_map37.Add(MakeKeyword("Body"), (*(*(*_elem35).Decl).Body))
// 					_obj_map37 = Object(_map37)
// 				} else {
// 					_obj_map37 = NIL
// 				}
// 				_map36.Add(MakeKeyword("Decl"), _obj_map37)
// 				_map36.Add(MakeKeyword("Recv"), MakeString((*_elem35).Recv))
// 				_map36.Add(MakeKeyword("Orig"), MakeString((*_elem35).Orig))
// 				_map36.Add(MakeKeyword("Level"), MakeInt((*_elem35).Level))
// 				_obj_map36 = Object(_map36)
// 			} else {
// 				_obj_map36 = NIL
// 			}
// 			_vec35 = _vec35.Conjoin(_obj_map36)
// 		}
// 		_map1.Add(MakeKeyword("Funcs"), _vec35)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC go/doc.ToHTML:
// func toHTML(w io.Writer, text string, words map[]) Object {
// 	_doc.ToHTML(w, text, words)
// 	...ABEND675: TODO...
// }

GO FUNC go/doc.ToText:
// func toText(w io.Writer, text string, indent string, preIndent string, width int) Object {
// 	_doc.ToText(w, text, indent, preIndent, width)
// 	...ABEND675: TODO...
// }

GO FUNC go/format.Source:
func source(src []byte) Object {
	_res1, _res2 := _format.Source(src)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC go/importer.Default:
// func default() Object {
// 	return _importer.Default()
// }

GO FUNC go/importer.For:
// func for(compiler string, lookup go/importer.Lookup) Object {
// 	return _importer.For(compiler, lookup)
// }

GO FUNC go/parser.ParseDir:
// func parseDir(fset *go/token.FileSet, path string, filter func, mode go/parser.Mode) Object {
// 	pkgs, first := _parser.ParseDir(fset, path, filter, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pkgs)
// 	_res = _res.Conjoin(func () Object { if (first) == nil { return NIL } else { return MakeError(first) } }())
// 	return _res
// }

GO FUNC go/parser.ParseExpr:
// func parseExpr(x string) Object {
// 	_res1, _res2 := _parser.ParseExpr(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/parser.ParseExprFrom:
// func parseExprFrom(fset *go/token.FileSet, filename string, src interface {}, mode go/parser.Mode) Object {
// 	_res1, _res2 := _parser.ParseExprFrom(fset, filename, src, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC go/parser.ParseFile:
// func parseFile(fset *go/token.FileSet, filename string, src interface {}, mode go/parser.Mode) Object {
// 	f, err := _parser.ParseFile(fset, filename, src, mode)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if f != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Doc"), (*(*f).Doc))
// 		_map1.Add(MakeKeyword("Package"), MakeInt((*f).Package))
// 		_map1.Add(MakeKeyword("Name"), (*(*f).Name))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*f).Decls {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Decls"), _vec2)
// 		_map1.Add(MakeKeyword("Scope"), (*(*f).Scope))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*f).Imports {
// 			_vec3 = _vec3.Conjoin((*_elem3))
// 		}
// 		_map1.Add(MakeKeyword("Imports"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*f).Unresolved {
// 			_vec4 = _vec4.Conjoin((*_elem4))
// 		}
// 		_map1.Add(MakeKeyword("Unresolved"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*f).Comments {
// 			_vec5 = _vec5.Conjoin((*_elem5))
// 		}
// 		_map1.Add(MakeKeyword("Comments"), _vec5)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/scanner.PrintError:
// func printError(w io.Writer, err error) Object {
// 	_scanner.PrintError(w, err)
// 	...ABEND675: TODO...
// }

GO FUNC go/token.NewFileSet:
// func newFileSet() Object {
// 	return _token.NewFileSet()
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.DefPredeclaredTestFuncs:
// func defPredeclaredTestFuncs() Object {
// 	_types.DefPredeclaredTestFuncs()
// 	...ABEND675: TODO...
// }

GO FUNC go/types.Default:
// func default(typ go/types.Type) Object {
// 	return _types.Default(typ)
// }

GO FUNC go/types.Eval:
// func eval(fset *go/token.FileSet, pkg *go/types.Package, pos go/token.Pos, expr string) Object {
// 	_, err := _types.Eval(fset, pkg, pos, expr)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("Type"), _.Type)
// 	_map1.Add(MakeKeyword("Value"), _.Value)
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC go/types.LookupFieldOrMethod:
// func lookupFieldOrMethod(T go/types.Type, addressable bool, pkg *go/types.Package, name string) Object {
// 	obj, index, indirect := _types.LookupFieldOrMethod(T, addressable, pkg, name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(obj)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range index {
// 		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(MakeBool(indirect))
// 	return _res
// }

GO FUNC go/types.MissingMethod:
// func missingMethod(V go/types.Type, T *go/types.Interface, static bool) Object {
// 	_, wrongType := _types.MissingMethod(V, T, static)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(MakeBool(wrongType))
// 	return _res
// }

GO FUNC go/types.NewArray:
// func newArray(elem go/types.Type, len int64) Object {
// 	return _types.NewArray(elem, len)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewChan:
// func newChan(dir go/types.ChanDir, elem go/types.Type) Object {
// 	return _types.NewChan(dir, elem)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewChecker:
// func newChecker(conf *go/types.Config, fset *go/token.FileSet, pkg *go/types.Package, info *go/types.Info) Object {
// 	return _types.NewChecker(conf, fset, pkg, info)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewConst:
// func newConst(pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type, val go/constant.Value) Object {
// 	return _types.NewConst(pos, pkg, name, typ, val)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewField:
// func newField(pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type, embedded bool) Object {
// 	return _types.NewField(pos, pkg, name, typ, embedded)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewFunc:
// func newFunc(pos go/token.Pos, pkg *go/types.Package, name string, sig *go/types.Signature) Object {
// 	return _types.NewFunc(pos, pkg, name, sig)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewInterface:
// func newInterface(methods []*go/types.Func, embeddeds []*go/types.Named) Object {
// 	return _types.NewInterface(methods, embeddeds)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewInterfaceType:
// func newInterfaceType(methods []*go/types.Func, embeddeds []go/types.Type) Object {
// 	return _types.NewInterfaceType(methods, embeddeds)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewLabel:
// func newLabel(pos go/token.Pos, pkg *go/types.Package, name string) Object {
// 	return _types.NewLabel(pos, pkg, name)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewMap:
// func newMap(key go/types.Type, elem go/types.Type) Object {
// 	return _types.NewMap(key, elem)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewMethodSet:
// func newMethodSet(T go/types.Type) Object {
// 	return _types.NewMethodSet(T)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewNamed:
// func newNamed(obj *go/types.TypeName, underlying go/types.Type, methods []*go/types.Func) Object {
// 	return _types.NewNamed(obj, underlying, methods)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewPackage:
// func newPackage(path string, name string) Object {
// 	return _types.NewPackage(path, name)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewParam:
// func newParam(pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type) Object {
// 	return _types.NewParam(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewPkgName:
// func newPkgName(pos go/token.Pos, pkg *go/types.Package, name string, imported *go/types.Package) Object {
// 	return _types.NewPkgName(pos, pkg, name, imported)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewPointer:
// func newPointer(elem go/types.Type) Object {
// 	return _types.NewPointer(elem)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewScope:
// func newScope(parent *go/types.Scope, pos go/token.Pos, end go/token.Pos, comment string) Object {
// 	return _types.NewScope(parent, pos, end, comment)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewSignature:
// func newSignature(recv *go/types.Var, params *go/types.Tuple, results *go/types.Tuple, variadic bool) Object {
// 	return _types.NewSignature(recv, params, results, variadic)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewSlice:
// func newSlice(elem go/types.Type) Object {
// 	return _types.NewSlice(elem)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewStruct:
// func newStruct(fields []*go/types.Var, tags []string) Object {
// 	return _types.NewStruct(fields, tags)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewTuple:
// func newTuple(x ...*go/types.Var) Object {
// 	return _types.NewTuple(x)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewTypeName:
// func newTypeName(pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type) Object {
// 	return _types.NewTypeName(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.NewVar:
// func newVar(pos go/token.Pos, pkg *go/types.Package, name string, typ go/types.Type) Object {
// 	return _types.NewVar(pos, pkg, name, typ)
// 	ABEND124(no public information returned)
// }

GO FUNC go/types.RelativeTo:
// func relativeTo(pkg *go/types.Package) Object {
// 	return _types.RelativeTo(pkg)
// }

GO FUNC go/types.SizesFor:
// func sizesFor(compiler string, arch string) Object {
// 	return _types.SizesFor(compiler, arch)
// }

GO FUNC go/types.WriteExpr:
// func writeExpr(buf *bytes.Buffer, x go/ast.Expr) Object {
// 	_types.WriteExpr(buf, x)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteSignature:
// func writeSignature(buf *bytes.Buffer, sig *go/types.Signature, qf go/types.Qualifier) Object {
// 	_types.WriteSignature(buf, sig, qf)
// 	...ABEND675: TODO...
// }

GO FUNC go/types.WriteType:
// func writeType(buf *bytes.Buffer, typ go/types.Type, qf go/types.Qualifier) Object {
// 	_types.WriteType(buf, typ, qf)
// 	...ABEND675: TODO...
// }

GO FUNC hash/adler32.New:
// func new() Object {
// 	return _adler32.New()
// }

GO FUNC hash/crc32.MakeTable:
// func makeTable(poly uint32) Object {
// 	_res := _crc32.MakeTable(poly)
// 	var _obj_vec1 Object
// 	if _res != nil {
// 		_vec1 := EmptyVector
// 		for _, _elem1 := range (*_res) {
// 			_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 		}
// 		_obj_vec1 = Object(_vec1)
// 	} else {
// 		_obj_vec1 = NIL
// 	}
// 	return _obj_vec1
// }

GO FUNC hash/crc32.New:
// func new(tab *hash/crc32.Table) Object {
// 	return _crc32.New(tab)
// }

GO FUNC hash/crc32.NewIEEE:
// func newIEEE() Object {
// 	return _crc32.NewIEEE()
// }

GO FUNC hash/crc64.Checksum:
// func checksum(data []byte, tab *hash/crc64.Table) Object {
// 	return _crc64.Checksum(data, tab)
// }

GO FUNC hash/crc64.MakeTable:
// func makeTable(poly uint64) Object {
// 	_res := _crc64.MakeTable(poly)
// 	var _obj_vec1 Object
// 	if _res != nil {
// 		_vec1 := EmptyVector
// 		for _, _elem1 := range (*_res) {
// 			_vec1 = _vec1.Conjoin(_elem1)
// 		}
// 		_obj_vec1 = Object(_vec1)
// 	} else {
// 		_obj_vec1 = NIL
// 	}
// 	return _obj_vec1
// }

GO FUNC hash/crc64.New:
// func new(tab *hash/crc64.Table) Object {
// 	return _crc64.New(tab)
// }

GO FUNC hash/crc64.Update:
// func update(crc uint64, tab *hash/crc64.Table, p []byte) Object {
// 	return _crc64.Update(crc, tab, p)
// }

GO FUNC hash/fnv.New128:
// func new128() Object {
// 	return _fnv.New128()
// }

GO FUNC hash/fnv.New128a:
// func new128a() Object {
// 	return _fnv.New128a()
// }

GO FUNC hash/fnv.New32:
// func new32() Object {
// 	return _fnv.New32()
// }

GO FUNC hash/fnv.New32a:
// func new32a() Object {
// 	return _fnv.New32a()
// }

GO FUNC hash/fnv.New64:
// func new64() Object {
// 	return _fnv.New64()
// }

GO FUNC hash/fnv.New64a:
// func new64a() Object {
// 	return _fnv.New64a()
// }

GO FUNC html/template.HTMLEscape:
// func hTMLEscape(w io.Writer, b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.IsTrue:
// func isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(truth))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC html/template.JSEscape:
// func jSEscape(w io.Writer, b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC html/template.Must:
// func must(t *html/template.Template, err error) Object {
// 	_res := _template.Must(t, err)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		var _obj_map2 Object
// 		if (*_res).Tree != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Name"), MakeString((*(*_res).Tree).Name))
// 			_map2.Add(MakeKeyword("ParseName"), MakeString((*(*_res).Tree).ParseName))
// 			_map2.Add(MakeKeyword("Root"), (*(*(*_res).Tree).Root))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Tree"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC html/template.New:
// func new(name string) Object {
// 	_res := _template.New(name)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		var _obj_map2 Object
// 		if (*_res).Tree != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Name"), MakeString((*(*_res).Tree).Name))
// 			_map2.Add(MakeKeyword("ParseName"), MakeString((*(*_res).Tree).ParseName))
// 			_map2.Add(MakeKeyword("Root"), (*(*(*_res).Tree).Root))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Tree"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC html/template.ParseFiles:
// func parseFiles(filenames ...string) Object {
// 	_res1, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		var _obj_map2 Object
// 		if (*_res1).Tree != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Name"), MakeString((*(*_res1).Tree).Name))
// 			_map2.Add(MakeKeyword("ParseName"), MakeString((*(*_res1).Tree).ParseName))
// 			_map2.Add(MakeKeyword("Root"), (*(*(*_res1).Tree).Root))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Tree"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC html/template.ParseGlob:
// func parseGlob(pattern string) Object {
// 	_res1, _res2 := _template.ParseGlob(pattern)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		var _obj_map2 Object
// 		if (*_res1).Tree != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Name"), MakeString((*(*_res1).Tree).Name))
// 			_map2.Add(MakeKeyword("ParseName"), MakeString((*(*_res1).Tree).ParseName))
// 			_map2.Add(MakeKeyword("Root"), (*(*(*_res1).Tree).Root))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Tree"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image.Decode:
// func decode(r io.Reader) Object {
// 	_res1, _res2, _res3 := _image.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.DecodeConfig:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2, _res3 := _image.DecodeConfig(r)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("ColorModel"), _res1.ColorModel)
// 	_map1.Add(MakeKeyword("Width"), MakeInt(_res1.Width))
// 	_map1.Add(MakeKeyword("Height"), MakeInt(_res1.Height))
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(MakeString(_res2))
// 	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
// 	return _res
// }

GO FUNC image.NewAlpha:
// func newAlpha(r image.Rectangle) Object {
// 	_res := _image.NewAlpha(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewAlpha16:
// func newAlpha16(r image.Rectangle) Object {
// 	_res := _image.NewAlpha16(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewCMYK:
// func newCMYK(r image.Rectangle) Object {
// 	_res := _image.NewCMYK(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewGray:
// func newGray(r image.Rectangle) Object {
// 	_res := _image.NewGray(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewGray16:
// func newGray16(r image.Rectangle) Object {
// 	_res := _image.NewGray16(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewNRGBA:
// func newNRGBA(r image.Rectangle) Object {
// 	_res := _image.NewNRGBA(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewNRGBA64:
// func newNRGBA64(r image.Rectangle) Object {
// 	_res := _image.NewNRGBA64(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewNYCbCrA:
// func newNYCbCrA(r image.Rectangle, subsampleRatio image.YCbCrSubsampleRatio) Object {
// 	_res := _image.NewNYCbCrA(r, subsampleRatio)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).A {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("A"), _vec2)
// 		_map1.Add(MakeKeyword("AStride"), MakeInt((*_res).AStride))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewPaletted:
// func newPaletted(r image.Rectangle, p image/color.Palette) Object {
// 	_res := _image.NewPaletted(r, p)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res).Palette {
// 			_vec6 = _vec6.Conjoin(_elem6)
// 		}
// 		_map1.Add(MakeKeyword("Palette"), _vec6)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewRGBA:
// func newRGBA(r image.Rectangle) Object {
// 	_res := _image.NewRGBA(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewRGBA64:
// func newRGBA64(r image.Rectangle) Object {
// 	_res := _image.NewRGBA64(r)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Pix {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Pix"), _vec2)
// 		_map1.Add(MakeKeyword("Stride"), MakeInt((*_res).Stride))
// 		_map3 := EmptyArrayMap()
// 		_map4 := EmptyArrayMap()
// 		_map4.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map4.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map3.Add(MakeKeyword("Min"), _map4)
// 		_map5 := EmptyArrayMap()
// 		_map5.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map5.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map3.Add(MakeKeyword("Max"), _map5)
// 		_map1.Add(MakeKeyword("Rect"), _map3)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewUniform:
// func newUniform(c image/color.Color) Object {
// 	_res := _image.NewUniform(c)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("C"), (*_res).C)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.NewYCbCr:
// func newYCbCr(r image.Rectangle, subsampleRatio image.YCbCrSubsampleRatio) Object {
// 	_res := _image.NewYCbCr(r, subsampleRatio)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Y {
// 			_vec2 = _vec2.Conjoin(_elem2)
// 		}
// 		_map1.Add(MakeKeyword("Y"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).Cb {
// 			_vec3 = _vec3.Conjoin(_elem3)
// 		}
// 		_map1.Add(MakeKeyword("Cb"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res).Cr {
// 			_vec4 = _vec4.Conjoin(_elem4)
// 		}
// 		_map1.Add(MakeKeyword("Cr"), _vec4)
// 		_map1.Add(MakeKeyword("YStride"), MakeInt((*_res).YStride))
// 		_map1.Add(MakeKeyword("CStride"), MakeInt((*_res).CStride))
// 		_map1.Add(MakeKeyword("SubsampleRatio"), MakeInt((*_res).SubsampleRatio))
// 		_map5 := EmptyArrayMap()
// 		_map6 := EmptyArrayMap()
// 		_map6.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Min.X))
// 		_map6.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Min.Y))
// 		_map5.Add(MakeKeyword("Min"), _map6)
// 		_map7 := EmptyArrayMap()
// 		_map7.Add(MakeKeyword("X"), MakeInt((*_res).Rect.Max.X))
// 		_map7.Add(MakeKeyword("Y"), MakeInt((*_res).Rect.Max.Y))
// 		_map5.Add(MakeKeyword("Max"), _map7)
// 		_map1.Add(MakeKeyword("Rect"), _map5)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC image.Pt:
func pt(X int, Y int) Object {
	_res := _image.Pt(X, Y)
	_map1 := EmptyArrayMap()
	_map1.Add(MakeKeyword("X"), MakeInt(_res.X))
	_map1.Add(MakeKeyword("Y"), MakeInt(_res.Y))
	return _map1
}

GO FUNC image.Rect:
func rect(x0 int, y0 int, x1 int, y1 int) Object {
	_res := _image.Rect(x0, y0, x1, y1)
	_map1 := EmptyArrayMap()
	_map2 := EmptyArrayMap()
	_map2.Add(MakeKeyword("X"), MakeInt(_res.Min.X))
	_map2.Add(MakeKeyword("Y"), MakeInt(_res.Min.Y))
	_map1.Add(MakeKeyword("Min"), _map2)
	_map3 := EmptyArrayMap()
	_map3.Add(MakeKeyword("X"), MakeInt(_res.Max.X))
	_map3.Add(MakeKeyword("Y"), MakeInt(_res.Max.Y))
	_map1.Add(MakeKeyword("Max"), _map3)
	return _map1
}

GO FUNC image.RegisterFormat:
// func registerFormat(name string, magic string, decode func, decodeConfig func) Object {
// 	_image.RegisterFormat(name, magic, decode, decodeConfig)
// 	...ABEND675: TODO...
// }

GO FUNC image/color.CMYKToRGB:
// func cMYKToRGB(c uint8, m uint8, y uint8, k uint8) Object {
// 	_res1, _res2, _res3 := _color.CMYKToRGB(c, m, y, k)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.ModelFunc:
// func modelFunc(f func) Object {
// 	return _color.ModelFunc(f)
// }

GO FUNC image/color.RGBToCMYK:
// func rGBToCMYK(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3, _res4 := _color.RGBToCMYK(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	_res = _res.Conjoin(_res4)
// 	return _res
// }

GO FUNC image/color.RGBToYCbCr:
// func rGBToYCbCr(r uint8, g uint8, b uint8) Object {
// 	_res1, _res2, _res3 := _color.RGBToYCbCr(r, g, b)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/color.YCbCrToRGB:
// func yCbCrToRGB(y uint8, cb uint8, cr uint8) Object {
// 	_res1, _res2, _res3 := _color.YCbCrToRGB(y, cb, cr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	_res = _res.Conjoin(_res3)
// 	return _res
// }

GO FUNC image/draw.Draw:
// func draw(dst image/draw.Image, r image.Rectangle, src image.Image, sp image.Point, op image/draw.Op) Object {
// 	_draw.Draw(dst, r, src, sp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/draw.DrawMask:
// func drawMask(dst image/draw.Image, r image.Rectangle, src image.Image, sp image.Point, mask image.Image, mp image.Point, op image/draw.Op) Object {
// 	_draw.DrawMask(dst, r, src, sp, mask, mp, op)
// 	...ABEND675: TODO...
// }

GO FUNC image/gif.Decode:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _gif.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeAll:
// func decodeAll(r io.Reader) Object {
// 	_res1, _res2 := _gif.DecodeAll(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Image {
// 			var _obj_map3 Object
// 			if _elem2 != nil {
// 				_map3 := EmptyArrayMap()
// 				_vec4 := EmptyVector
// 				for _, _elem4 := range (*_elem2).Pix {
// 					_vec4 = _vec4.Conjoin(_elem4)
// 				}
// 				_map3.Add(MakeKeyword("Pix"), _vec4)
// 				_map3.Add(MakeKeyword("Stride"), MakeInt((*_elem2).Stride))
// 				_map3.Add(MakeKeyword("Rect"), (*_elem2).Rect)
// 				_vec5 := EmptyVector
// 				for _, _elem5 := range (*_elem2).Palette {
// 					_vec5 = _vec5.Conjoin(_elem5)
// 				}
// 				_map3.Add(MakeKeyword("Palette"), _vec5)
// 				_obj_map3 = Object(_map3)
// 			} else {
// 				_obj_map3 = NIL
// 			}
// 			_vec2 = _vec2.Conjoin(_obj_map3)
// 		}
// 		_map1.Add(MakeKeyword("Image"), _vec2)
// 		_vec6 := EmptyVector
// 		for _, _elem6 := range (*_res1).Delay {
// 			_vec6 = _vec6.Conjoin(MakeInt(_elem6))
// 		}
// 		_map1.Add(MakeKeyword("Delay"), _vec6)
// 		_map1.Add(MakeKeyword("LoopCount"), MakeInt((*_res1).LoopCount))
// 		_vec7 := EmptyVector
// 		for _, _elem7 := range (*_res1).Disposal {
// 			_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 		}
// 		_map1.Add(MakeKeyword("Disposal"), _vec7)
// 		_map8 := EmptyArrayMap()
// 		_map8.Add(MakeKeyword("ColorModel"), (*_res1).Config.ColorModel)
// 		_map8.Add(MakeKeyword("Width"), MakeInt((*_res1).Config.Width))
// 		_map8.Add(MakeKeyword("Height"), MakeInt((*_res1).Config.Height))
// 		_map1.Add(MakeKeyword("Config"), _map8)
// 		_map1.Add(MakeKeyword("BackgroundIndex"), MakeInt(int((*_res1).BackgroundIndex)))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/gif.DecodeConfig:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _gif.DecodeConfig(r)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("ColorModel"), _res1.ColorModel)
// 	_map1.Add(MakeKeyword("Width"), MakeInt(_res1.Width))
// 	_map1.Add(MakeKeyword("Height"), MakeInt(_res1.Height))
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.Decode:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _jpeg.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/jpeg.DecodeConfig:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _jpeg.DecodeConfig(r)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("ColorModel"), _res1.ColorModel)
// 	_map1.Add(MakeKeyword("Width"), MakeInt(_res1.Width))
// 	_map1.Add(MakeKeyword("Height"), MakeInt(_res1.Height))
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.Decode:
// func decode(r io.Reader) Object {
// 	_res1, _res2 := _png.Decode(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC image/png.DecodeConfig:
// func decodeConfig(r io.Reader) Object {
// 	_res1, _res2 := _png.DecodeConfig(r)
// 	_res := EmptyVector
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("ColorModel"), _res1.ColorModel)
// 	_map1.Add(MakeKeyword("Width"), MakeInt(_res1.Width))
// 	_map1.Add(MakeKeyword("Height"), MakeInt(_res1.Height))
// 	_res = _res.Conjoin(_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC index/suffixarray.New:
// func new(data []byte) Object {
// 	return _suffixarray.New(data)
// 	ABEND124(no public information returned)
// }

GO FUNC io.Copy:
// func copy(dst io.Writer, src io.Reader) Object {
// 	written, err := _io.Copy(dst, src)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(written)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.CopyBuffer:
// func copyBuffer(dst io.Writer, src io.Reader, buf []byte) Object {
// 	written, err := _io.CopyBuffer(dst, src, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(written)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.CopyN:
// func copyN(dst io.Writer, src io.Reader, n int64) Object {
// 	written, err := _io.CopyN(dst, src, n)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(written)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.LimitReader:
// func limitReader(r io.Reader, n int64) Object {
// 	return _io.LimitReader(r, n)
// }

GO FUNC io.MultiReader:
// func multiReader(readers ...io.Reader) Object {
// 	return _io.MultiReader(readers)
// }

GO FUNC io.MultiWriter:
// func multiWriter(writers ...io.Writer) Object {
// 	return _io.MultiWriter(writers)
// }

GO FUNC io.NewSectionReader:
// func newSectionReader(r io.ReaderAt, off int64, n int64) Object {
// 	return _io.NewSectionReader(r, off, n)
// 	ABEND124(no public information returned)
// }

GO FUNC io.Pipe:
// func pipe() Object {
// 	_, _ := _io.Pipe()
// 	ABEND123(no public information returned)
// }

GO FUNC io.ReadAtLeast:
// func readAtLeast(r io.Reader, buf []byte, min int) Object {
// 	n, err := _io.ReadAtLeast(r, buf, min)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.ReadFull:
// func readFull(r io.Reader, buf []byte) Object {
// 	n, err := _io.ReadFull(r, buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io.TeeReader:
// func teeReader(r io.Reader, w io.Writer) Object {
// 	return _io.TeeReader(r, w)
// }

GO FUNC io.WriteString:
// func writeString(w io.Writer, s string) Object {
// 	n, err := _io.WriteString(w, s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC io/ioutil.NopCloser:
// func nopCloser(r io.Reader) Object {
// 	return _ioutil.NopCloser(r)
// }

GO FUNC io/ioutil.ReadAll:
// func readAll(r io.Reader) Object {
// 	_res1, _res2 := _ioutil.ReadAll(r)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC io/ioutil.ReadDir:
// func readDir(dirname string) Object {
// 	_res1, _res2 := _ioutil.ReadDir(dirname)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC io/ioutil.ReadFile:
func readFile(filename string) Object {
	_res1, _res2 := _ioutil.ReadFile(filename)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC io/ioutil.TempDir:
func tempDir(dir string, prefix string) Object {
	name, err := _ioutil.TempDir(dir, prefix)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC io/ioutil.TempFile:
func tempFile(dir string, pattern string) Object {
	_, err := _ioutil.TempFile(dir, pattern)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC log.Fatal:
// func fatal(v ...interface {}) Object {
// 	_log.Fatal(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalf:
// func fatalf(format string, v ...interface {}) Object {
// 	_log.Fatalf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Fatalln:
// func fatalln(v ...interface {}) Object {
// 	_log.Fatalln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.New:
// func new(out io.Writer, prefix string, flag int) Object {
// 	return _log.New(out, prefix, flag)
// 	ABEND124(no public information returned)
// }

GO FUNC log.Panic:
// func panic(v ...interface {}) Object {
// 	_log.Panic(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicf:
// func panicf(format string, v ...interface {}) Object {
// 	_log.Panicf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Panicln:
// func panicln(v ...interface {}) Object {
// 	_log.Panicln(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Print:
// func print(v ...interface {}) Object {
// 	_log.Print(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Printf:
// func printf(format string, v ...interface {}) Object {
// 	_log.Printf(format, v)
// 	...ABEND675: TODO...
// }

GO FUNC log.Println:
// func println(v ...interface {}) Object {
// 	_log.Println(v)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetFlags:
// func setFlags(flag int) Object {
// 	_log.SetFlags(flag)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetOutput:
// func setOutput(w io.Writer) Object {
// 	_log.SetOutput(w)
// 	...ABEND675: TODO...
// }

GO FUNC log.SetPrefix:
// func setPrefix(prefix string) Object {
// 	_log.SetPrefix(prefix)
// 	...ABEND675: TODO...
// }

GO FUNC log/syslog.Dial:
// func dial(network string, raddr string, priority log/syslog.Priority, tag string) Object {
// 	_, _res2 := _syslog.Dial(network, raddr, priority, tag)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC log/syslog.New:
// func new(priority log/syslog.Priority, tag string) Object {
// 	_, _res2 := _syslog.New(priority, tag)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC log/syslog.NewLogger:
// func newLogger(p log/syslog.Priority, logFlag int) Object {
// 	_, _res2 := _syslog.NewLogger(p, logFlag)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC math.Abs:
// func abs(x float64) Object {
// 	return _math.Abs(x)
// }

GO FUNC math.Acos:
// func acos(x float64) Object {
// 	return _math.Acos(x)
// }

GO FUNC math.Acosh:
// func acosh(x float64) Object {
// 	return _math.Acosh(x)
// }

GO FUNC math.Asin:
// func asin(x float64) Object {
// 	return _math.Asin(x)
// }

GO FUNC math.Asinh:
// func asinh(x float64) Object {
// 	return _math.Asinh(x)
// }

GO FUNC math.Atan:
// func atan(x float64) Object {
// 	return _math.Atan(x)
// }

GO FUNC math.Atan2:
// func atan2(y float64, x float64) Object {
// 	return _math.Atan2(y, x)
// }

GO FUNC math.Atanh:
// func atanh(x float64) Object {
// 	return _math.Atanh(x)
// }

GO FUNC math.Cbrt:
// func cbrt(x float64) Object {
// 	return _math.Cbrt(x)
// }

GO FUNC math.Ceil:
// func ceil(x float64) Object {
// 	return _math.Ceil(x)
// }

GO FUNC math.Copysign:
// func copysign(x float64, y float64) Object {
// 	return _math.Copysign(x, y)
// }

GO FUNC math.Cos:
// func cos(x float64) Object {
// 	return _math.Cos(x)
// }

GO FUNC math.Cosh:
// func cosh(x float64) Object {
// 	return _math.Cosh(x)
// }

GO FUNC math.Dim:
// func dim(x float64, y float64) Object {
// 	return _math.Dim(x, y)
// }

GO FUNC math.Erf:
// func erf(x float64) Object {
// 	return _math.Erf(x)
// }

GO FUNC math.Erfc:
// func erfc(x float64) Object {
// 	return _math.Erfc(x)
// }

GO FUNC math.Erfcinv:
// func erfcinv(x float64) Object {
// 	return _math.Erfcinv(x)
// }

GO FUNC math.Erfinv:
// func erfinv(x float64) Object {
// 	return _math.Erfinv(x)
// }

GO FUNC math.Exp:
// func exp(x float64) Object {
// 	return _math.Exp(x)
// }

GO FUNC math.Exp2:
// func exp2(x float64) Object {
// 	return _math.Exp2(x)
// }

GO FUNC math.Expm1:
// func expm1(x float64) Object {
// 	return _math.Expm1(x)
// }

GO FUNC math.Float32frombits:
// func float32frombits(b uint32) Object {
// 	return _math.Float32frombits(b)
// }

GO FUNC math.Float64bits:
// func float64bits(f float64) Object {
// 	return _math.Float64bits(f)
// }

GO FUNC math.Float64frombits:
// func float64frombits(b uint64) Object {
// 	return _math.Float64frombits(b)
// }

GO FUNC math.Floor:
// func floor(x float64) Object {
// 	return _math.Floor(x)
// }

GO FUNC math.Frexp:
// func frexp(f float64) Object {
// 	frac, exp := _math.Frexp(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(frac)
// 	_res = _res.Conjoin(MakeInt(exp))
// 	return _res
// }

GO FUNC math.Gamma:
// func gamma(x float64) Object {
// 	return _math.Gamma(x)
// }

GO FUNC math.Hypot:
// func hypot(p float64, q float64) Object {
// 	return _math.Hypot(p, q)
// }

GO FUNC math.Inf:
// func inf(sign int) Object {
// 	return _math.Inf(sign)
// }

GO FUNC math.J0:
// func j0(x float64) Object {
// 	return _math.J0(x)
// }

GO FUNC math.J1:
// func j1(x float64) Object {
// 	return _math.J1(x)
// }

GO FUNC math.Jn:
// func jn(n int, x float64) Object {
// 	return _math.Jn(n, x)
// }

GO FUNC math.Ldexp:
// func ldexp(frac float64, exp int) Object {
// 	return _math.Ldexp(frac, exp)
// }

GO FUNC math.Lgamma:
// func lgamma(x float64) Object {
// 	lgamma, sign := _math.Lgamma(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(lgamma)
// 	_res = _res.Conjoin(MakeInt(sign))
// 	return _res
// }

GO FUNC math.Log:
// func log(x float64) Object {
// 	return _math.Log(x)
// }

GO FUNC math.Log10:
// func log10(x float64) Object {
// 	return _math.Log10(x)
// }

GO FUNC math.Log1p:
// func log1p(x float64) Object {
// 	return _math.Log1p(x)
// }

GO FUNC math.Log2:
// func log2(x float64) Object {
// 	return _math.Log2(x)
// }

GO FUNC math.Logb:
// func logb(x float64) Object {
// 	return _math.Logb(x)
// }

GO FUNC math.Max:
// func max(x float64, y float64) Object {
// 	return _math.Max(x, y)
// }

GO FUNC math.Min:
// func min(x float64, y float64) Object {
// 	return _math.Min(x, y)
// }

GO FUNC math.Mod:
// func mod(x float64, y float64) Object {
// 	return _math.Mod(x, y)
// }

GO FUNC math.Modf:
// func modf(f float64) Object {
// 	int, frac := _math.Modf(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(int)
// 	_res = _res.Conjoin(frac)
// 	return _res
// }

GO FUNC math.NaN:
// func naN() Object {
// 	return _math.NaN()
// }

GO FUNC math.Nextafter:
// func nextafter(x float64, y float64) Object {
// 	return _math.Nextafter(x, y)
// }

GO FUNC math.Nextafter32:
// func nextafter32(x float32, y float32) Object {
// 	return _math.Nextafter32(x, y)
// }

GO FUNC math.Pow:
// func pow(x float64, y float64) Object {
// 	return _math.Pow(x, y)
// }

GO FUNC math.Pow10:
// func pow10(n int) Object {
// 	return _math.Pow10(n)
// }

GO FUNC math.Remainder:
// func remainder(x float64, y float64) Object {
// 	return _math.Remainder(x, y)
// }

GO FUNC math.Round:
// func round(x float64) Object {
// 	return _math.Round(x)
// }

GO FUNC math.RoundToEven:
// func roundToEven(x float64) Object {
// 	return _math.RoundToEven(x)
// }

GO FUNC math.Sin:
// func sin(x float64) Object {
// 	return _math.Sin(x)
// }

GO FUNC math.Sincos:
// func sincos(x float64) Object {
// 	sin, cos := _math.Sincos(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(sin)
// 	_res = _res.Conjoin(cos)
// 	return _res
// }

GO FUNC math.Sinh:
// func sinh(x float64) Object {
// 	return _math.Sinh(x)
// }

GO FUNC math.Sqrt:
// func sqrt(x float64) Object {
// 	return _math.Sqrt(x)
// }

GO FUNC math.Tan:
// func tan(x float64) Object {
// 	return _math.Tan(x)
// }

GO FUNC math.Tanh:
// func tanh(x float64) Object {
// 	return _math.Tanh(x)
// }

GO FUNC math.Trunc:
// func trunc(x float64) Object {
// 	return _math.Trunc(x)
// }

GO FUNC math.Y0:
// func y0(x float64) Object {
// 	return _math.Y0(x)
// }

GO FUNC math.Y1:
// func y1(x float64) Object {
// 	return _math.Y1(x)
// }

GO FUNC math.Yn:
// func yn(n int, x float64) Object {
// 	return _math.Yn(n, x)
// }

GO FUNC math/big.NewFloat:
// func newFloat(x float64) Object {
// 	return _big.NewFloat(x)
// 	ABEND124(no public information returned)
// }

GO FUNC math/big.NewInt:
// func newInt(x int64) Object {
// 	return _big.NewInt(x)
// 	ABEND124(no public information returned)
// }

GO FUNC math/big.NewRat:
// func newRat(a int64, b int64) Object {
// 	return _big.NewRat(a, b)
// 	ABEND124(no public information returned)
// }

GO FUNC math/big.ParseFloat:
// func parseFloat(s string, base int, prec uint, mode math/big.RoundingMode) Object {
// 	_, b, err := _big.ParseFloat(s, base, prec, mode)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(MakeInt(b))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC math/bits.Reverse64:
// func reverse64(x uint64) Object {
// 	return _bits.Reverse64(x)
// }

GO FUNC math/bits.Reverse8:
// func reverse8(x uint8) Object {
// 	return _bits.Reverse8(x)
// }

GO FUNC math/bits.ReverseBytes64:
// func reverseBytes64(x uint64) Object {
// 	return _bits.ReverseBytes64(x)
// }

GO FUNC math/bits.RotateLeft64:
// func rotateLeft64(x uint64, k int) Object {
// 	return _bits.RotateLeft64(x, k)
// }

GO FUNC math/bits.RotateLeft8:
// func rotateLeft8(x uint8, k int) Object {
// 	return _bits.RotateLeft8(x, k)
// }

GO FUNC math/cmplx.Abs:
// func abs(x complex128) Object {
// 	return _cmplx.Abs(x)
// }

GO FUNC math/cmplx.Acos:
// func acos(x complex128) Object {
// 	return _cmplx.Acos(x)
// }

GO FUNC math/cmplx.Acosh:
// func acosh(x complex128) Object {
// 	return _cmplx.Acosh(x)
// }

GO FUNC math/cmplx.Asin:
// func asin(x complex128) Object {
// 	return _cmplx.Asin(x)
// }

GO FUNC math/cmplx.Asinh:
// func asinh(x complex128) Object {
// 	return _cmplx.Asinh(x)
// }

GO FUNC math/cmplx.Atan:
// func atan(x complex128) Object {
// 	return _cmplx.Atan(x)
// }

GO FUNC math/cmplx.Atanh:
// func atanh(x complex128) Object {
// 	return _cmplx.Atanh(x)
// }

GO FUNC math/cmplx.Conj:
// func conj(x complex128) Object {
// 	return _cmplx.Conj(x)
// }

GO FUNC math/cmplx.Cos:
// func cos(x complex128) Object {
// 	return _cmplx.Cos(x)
// }

GO FUNC math/cmplx.Cosh:
// func cosh(x complex128) Object {
// 	return _cmplx.Cosh(x)
// }

GO FUNC math/cmplx.Cot:
// func cot(x complex128) Object {
// 	return _cmplx.Cot(x)
// }

GO FUNC math/cmplx.Exp:
// func exp(x complex128) Object {
// 	return _cmplx.Exp(x)
// }

GO FUNC math/cmplx.Inf:
// func inf() Object {
// 	return _cmplx.Inf()
// }

GO FUNC math/cmplx.Log:
// func log(x complex128) Object {
// 	return _cmplx.Log(x)
// }

GO FUNC math/cmplx.Log10:
// func log10(x complex128) Object {
// 	return _cmplx.Log10(x)
// }

GO FUNC math/cmplx.NaN:
// func naN() Object {
// 	return _cmplx.NaN()
// }

GO FUNC math/cmplx.Phase:
// func phase(x complex128) Object {
// 	return _cmplx.Phase(x)
// }

GO FUNC math/cmplx.Polar:
// func polar(x complex128) Object {
// 	r,  := _cmplx.Polar(x)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin()
// 	return _res
// }

GO FUNC math/cmplx.Pow:
// func pow(x complex128, y complex128) Object {
// 	return _cmplx.Pow(x, y)
// }

GO FUNC math/cmplx.Rect:
// func rect(r float64,  float64) Object {
// 	return _cmplx.Rect(r, )
// }

GO FUNC math/cmplx.Sin:
// func sin(x complex128) Object {
// 	return _cmplx.Sin(x)
// }

GO FUNC math/cmplx.Sinh:
// func sinh(x complex128) Object {
// 	return _cmplx.Sinh(x)
// }

GO FUNC math/cmplx.Sqrt:
// func sqrt(x complex128) Object {
// 	return _cmplx.Sqrt(x)
// }

GO FUNC math/cmplx.Tan:
// func tan(x complex128) Object {
// 	return _cmplx.Tan(x)
// }

GO FUNC math/cmplx.Tanh:
// func tanh(x complex128) Object {
// 	return _cmplx.Tanh(x)
// }

GO FUNC math/rand.ExpFloat64:
// func expFloat64() Object {
// 	return _rand.ExpFloat64()
// }

GO FUNC math/rand.Float32:
// func float32() Object {
// 	return _rand.Float32()
// }

GO FUNC math/rand.Float64:
// func float64() Object {
// 	return _rand.Float64()
// }

GO FUNC math/rand.New:
// func new(src math/rand.Source) Object {
// 	return _rand.New(src)
// 	ABEND124(no public information returned)
// }

GO FUNC math/rand.NewSource:
// func newSource(seed int64) Object {
// 	return _rand.NewSource(seed)
// }

GO FUNC math/rand.NewZipf:
// func newZipf(r *math/rand.Rand, s float64, v float64, imax uint64) Object {
// 	return _rand.NewZipf(r, s, v, imax)
// 	ABEND124(no public information returned)
// }

GO FUNC math/rand.NormFloat64:
// func normFloat64() Object {
// 	return _rand.NormFloat64()
// }

GO FUNC math/rand.Perm:
func perm(n int) Object {
	_res := _rand.Perm(n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	return _vec1
}

GO FUNC math/rand.Read:
func read(p []byte) Object {
	n, err := _rand.Read(p)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC math/rand.Seed:
// func seed(seed int64) Object {
// 	_rand.Seed(seed)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Shuffle:
// func shuffle(n int, swap func) Object {
// 	_rand.Shuffle(n, swap)
// 	...ABEND675: TODO...
// }

GO FUNC math/rand.Uint64:
// func uint64() Object {
// 	return _rand.Uint64()
// }

GO FUNC mime.ExtensionsByType:
func extensionsByType(typ string) Object {
	_res1, _res2 := _mime.ExtensionsByType(typ)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC mime.ParseMediaType:
// func parseMediaType(v string) Object {
// 	mediatype, params, err := _mime.ParseMediaType(v)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(mediatype))
// 	_res = _res.Conjoin(params)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC mime/multipart.NewReader:
// func newReader(r io.Reader, boundary string) Object {
// 	return _multipart.NewReader(r, boundary)
// 	ABEND124(no public information returned)
// }

GO FUNC mime/multipart.NewWriter:
// func newWriter(w io.Writer) Object {
// 	return _multipart.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC mime/quotedprintable.NewReader:
// func newReader(r io.Reader) Object {
// 	return _quotedprintable.NewReader(r)
// 	ABEND124(no public information returned)
// }

GO FUNC mime/quotedprintable.NewWriter:
// func newWriter(w io.Writer) Object {
// 	_res := _quotedprintable.NewWriter(w)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Binary"), MakeBool((*_res).Binary))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net.CIDRMask:
func cIDRMask(ones int, bits int) Object {
	_res := _net.CIDRMask(ones, bits)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.Dial:
// func dial(network string, address string) Object {
// 	_res1, _res2 := _net.Dial(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialIP:
// func dialIP(network string, laddr *net.IPAddr, raddr *net.IPAddr) Object {
// 	_, _res2 := _net.DialIP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTCP:
// func dialTCP(network string, laddr *net.TCPAddr, raddr *net.TCPAddr) Object {
// 	_, _res2 := _net.DialTCP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialTimeout:
// func dialTimeout(network string, address string, timeout time.Duration) Object {
// 	_res1, _res2 := _net.DialTimeout(network, address, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUDP:
// func dialUDP(network string, laddr *net.UDPAddr, raddr *net.UDPAddr) Object {
// 	_, _res2 := _net.DialUDP(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.DialUnix:
// func dialUnix(network string, laddr *net.UnixAddr, raddr *net.UnixAddr) Object {
// 	_, _res2 := _net.DialUnix(network, laddr, raddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.FileConn:
// func fileConn(f *os.File) Object {
// 	c, err := _net.FileConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(c)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FileListener:
// func fileListener(f *os.File) Object {
// 	ln, err := _net.FileListener(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ln)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.FilePacketConn:
// func filePacketConn(f *os.File) Object {
// 	c, err := _net.FilePacketConn(f)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(c)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net.IPv4:
func iPv4(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4(a, b, c, d)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.IPv4Mask:
func iPv4Mask(a byte, b byte, c byte, d byte) Object {
	_res := _net.IPv4Mask(a, b, c, d)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.InterfaceAddrs:
// func interfaceAddrs() Object {
// 	_res1, _res2 := _net.InterfaceAddrs()
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.InterfaceByIndex:
func interfaceByIndex(index int) Object {
	_res1, _res2 := _net.InterfaceByIndex(index)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Index"), MakeInt((*_res1).Index))
		_map1.Add(MakeKeyword("MTU"), MakeInt((*_res1).MTU))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).HardwareAddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("HardwareAddr"), _vec2)
		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.InterfaceByName:
func interfaceByName(name string) Object {
	_res1, _res2 := _net.InterfaceByName(name)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Index"), MakeInt((*_res1).Index))
		_map1.Add(MakeKeyword("MTU"), MakeInt((*_res1).MTU))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).HardwareAddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("HardwareAddr"), _vec2)
		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Interfaces:
func interfaces() Object {
	_res1, _res2 := _net.Interfaces()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_map2 := EmptyArrayMap()
		_map2.Add(MakeKeyword("Index"), MakeInt(_elem1.Index))
		_map2.Add(MakeKeyword("MTU"), MakeInt(_elem1.MTU))
		_map2.Add(MakeKeyword("Name"), MakeString(_elem1.Name))
		_vec3 := EmptyVector
		for _, _elem3 := range _elem1.HardwareAddr {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map2.Add(MakeKeyword("HardwareAddr"), _vec3)
		_map2.Add(MakeKeyword("Flags"), MakeInt(int(_elem1.Flags)))
		_vec1 = _vec1.Conjoin(_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.Listen:
// func listen(network string, address string) Object {
// 	_res1, _res2 := _net.Listen(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenIP:
// func listenIP(network string, laddr *net.IPAddr) Object {
// 	_, _res2 := _net.ListenIP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenMulticastUDP:
// func listenMulticastUDP(network string, ifi *net.Interface, gaddr *net.UDPAddr) Object {
// 	_, _res2 := _net.ListenMulticastUDP(network, ifi, gaddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenPacket:
// func listenPacket(network string, address string) Object {
// 	_res1, _res2 := _net.ListenPacket(network, address)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenTCP:
// func listenTCP(network string, laddr *net.TCPAddr) Object {
// 	_, _res2 := _net.ListenTCP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUDP:
// func listenUDP(network string, laddr *net.UDPAddr) Object {
// 	_, _res2 := _net.ListenUDP(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnix:
// func listenUnix(network string, laddr *net.UnixAddr) Object {
// 	_, _res2 := _net.ListenUnix(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.ListenUnixgram:
// func listenUnixgram(network string, laddr *net.UnixAddr) Object {
// 	_, _res2 := _net.ListenUnixgram(network, laddr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net.LookupAddr:
func lookupAddr(addr string) Object {
	names, err := _net.LookupAddr(addr)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range names {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupCNAME:
func lookupCNAME(host string) Object {
	cname, err := _net.LookupCNAME(host)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupHost:
func lookupHost(host string) Object {
	addrs, err := _net.LookupHost(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupIP:
func lookupIP(host string) Object {
	_res1, _res2 := _net.LookupIP(host)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec2 := EmptyVector
		for _, _elem2 := range _elem1 {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_vec1 = _vec1.Conjoin(_vec2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupMX:
func lookupMX(name string) Object {
	_res1, _res2 := _net.LookupMX(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Host"), MakeString((*_elem1).Host))
			_map2.Add(MakeKeyword("Pref"), MakeInt(int((*_elem1).Pref)))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupNS:
func lookupNS(name string) Object {
	_res1, _res2 := _net.LookupNS(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Host"), MakeString((*_elem1).Host))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.LookupPort:
func lookupPort(network string, service string) Object {
	port, err := _net.LookupPort(network, service)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupSRV:
func lookupSRV(service string, proto string, name string) Object {
	cname, addrs, err := _net.LookupSRV(service, proto, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(cname))
	_vec1 := EmptyVector
	for _, _elem1 := range addrs {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Target"), MakeString((*_elem1).Target))
			_map2.Add(MakeKeyword("Port"), MakeInt(int((*_elem1).Port)))
			_map2.Add(MakeKeyword("Priority"), MakeInt(int((*_elem1).Priority)))
			_map2.Add(MakeKeyword("Weight"), MakeInt(int((*_elem1).Weight)))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.LookupTXT:
func lookupTXT(name string) Object {
	_res1, _res2 := _net.LookupTXT(name)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ParseCIDR:
func parseCIDR(s string) Object {
	_res1, _res2, _res3 := _net.ParseCIDR(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	var _obj_map2 Object
	if _res2 != nil {
		_map2 := EmptyArrayMap()
		_vec3 := EmptyVector
		for _, _elem3 := range (*_res2).IP {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map2.Add(MakeKeyword("IP"), _vec3)
		_vec4 := EmptyVector
		for _, _elem4 := range (*_res2).Mask {
			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
		}
		_map2.Add(MakeKeyword("Mask"), _vec4)
		_obj_map2 = Object(_map2)
	} else {
		_obj_map2 = NIL
	}
	_res = _res.Conjoin(_obj_map2)
	_res = _res.Conjoin(func () Object { if (_res3) == nil { return NIL } else { return MakeError(_res3) } }())
	return _res
}

GO FUNC net.ParseIP:
func parseIP(s string) Object {
	_res := _net.ParseIP(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net.ParseMAC:
func parseMAC(s string) Object {
	hw, err := _net.ParseMAC(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range hw {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net.Pipe:
// func pipe() Object {
// 	_res1, _res2 := _net.Pipe()
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(_res2)
// 	return _res
// }

GO FUNC net.ResolveIPAddr:
func resolveIPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveIPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveTCPAddr:
func resolveTCPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveTCPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Port"), MakeInt((*_res1).Port))
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUDPAddr:
func resolveUDPAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUDPAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).IP {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("IP"), _vec2)
		_map1.Add(MakeKeyword("Port"), MakeInt((*_res1).Port))
		_map1.Add(MakeKeyword("Zone"), MakeString((*_res1).Zone))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.ResolveUnixAddr:
func resolveUnixAddr(network string, address string) Object {
	_res1, _res2 := _net.ResolveUnixAddr(network, address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("Net"), MakeString((*_res1).Net))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net.SplitHostPort:
func splitHostPort(hostport string) Object {
	host, port, err := _net.SplitHostPort(hostport)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(host))
	_res = _res.Conjoin(MakeString(port))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Error:
// func error(w net/http.ResponseWriter, error string, code int) Object {
// 	_http.Error(w, error, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.FileServer:
// func fileServer(root net/http.FileSystem) Object {
// 	return _http.FileServer(root)
// }

GO FUNC net/http.Get:
// func get(url string) Object {
// 	resp, err := _http.Get(url)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			var _obj_map6 Object
// 			if (*(*resp).Request).MultipartForm != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Value"), (*(*(*resp).Request).MultipartForm).Value)
// 				_map6.Add(MakeKeyword("File"), (*(*(*resp).Request).MultipartForm).File)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map3.Add(MakeKeyword("MultipartForm"), _obj_map6)
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			var _obj_map7 Object
// 			if (*(*resp).Request).TLS != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Version"), MakeInt(int((*(*(*resp).Request).TLS).Version)))
// 				_map7.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*resp).Request).TLS).HandshakeComplete))
// 				_map7.Add(MakeKeyword("DidResume"), MakeBool((*(*(*resp).Request).TLS).DidResume))
// 				_map7.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*resp).Request).TLS).CipherSuite)))
// 				_map7.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*resp).Request).TLS).NegotiatedProtocol))
// 				_map7.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*resp).Request).TLS).NegotiatedProtocolIsMutual))
// 				_map7.Add(MakeKeyword("ServerName"), MakeString((*(*(*resp).Request).TLS).ServerName))
// 				_vec8 := EmptyVector
// 				for _, _elem8 := range (*(*(*resp).Request).TLS).PeerCertificates {
// 					var _obj_map9 Object
// 					if _elem8 != nil {
// 						_map9 := EmptyArrayMap()
// 						_vec10 := EmptyVector
// 						for _, _elem10 := range (*_elem8).Raw {
// 							_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 						}
// 						_map9.Add(MakeKeyword("Raw"), _vec10)
// 						_vec11 := EmptyVector
// 						for _, _elem11 := range (*_elem8).RawTBSCertificate {
// 							_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 						}
// 						_map9.Add(MakeKeyword("RawTBSCertificate"), _vec11)
// 						_vec12 := EmptyVector
// 						for _, _elem12 := range (*_elem8).RawSubjectPublicKeyInfo {
// 							_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec12)
// 						_vec13 := EmptyVector
// 						for _, _elem13 := range (*_elem8).RawSubject {
// 							_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubject"), _vec13)
// 						_vec14 := EmptyVector
// 						for _, _elem14 := range (*_elem8).RawIssuer {
// 							_vec14 = _vec14.Conjoin(MakeInt(int(_elem14)))
// 						}
// 						_map9.Add(MakeKeyword("RawIssuer"), _vec14)
// 						_vec15 := EmptyVector
// 						for _, _elem15 := range (*_elem8).Signature {
// 							_vec15 = _vec15.Conjoin(MakeInt(int(_elem15)))
// 						}
// 						_map9.Add(MakeKeyword("Signature"), _vec15)
// 						_map9.Add(MakeKeyword("SignatureAlgorithm"), (*_elem8).SignatureAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem8).PublicKeyAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKey"), (*_elem8).PublicKey)
// 						_map9.Add(MakeKeyword("Version"), MakeInt((*_elem8).Version))
// 						_map9.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map17 := EmptyArrayMap()
// 						_vec18 := EmptyVector
// 						for _, _elem18 := range (*_elem8).Issuer.Country {
// 							_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 						}
// 						_map17.Add(MakeKeyword("Country"), _vec18)
// 						_vec19 := EmptyVector
// 						for _, _elem19 := range (*_elem8).Issuer.Organization {
// 							_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 						}
// 						_map17.Add(MakeKeyword("Organization"), _vec19)
// 						_vec20 := EmptyVector
// 						for _, _elem20 := range (*_elem8).Issuer.OrganizationalUnit {
// 							_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 						}
// 						_map17.Add(MakeKeyword("OrganizationalUnit"), _vec20)
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem8).Issuer.Locality {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map17.Add(MakeKeyword("Locality"), _vec21)
// 						_vec22 := EmptyVector
// 						for _, _elem22 := range (*_elem8).Issuer.Province {
// 							_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 						}
// 						_map17.Add(MakeKeyword("Province"), _vec22)
// 						_vec23 := EmptyVector
// 						for _, _elem23 := range (*_elem8).Issuer.StreetAddress {
// 							_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 						}
// 						_map17.Add(MakeKeyword("StreetAddress"), _vec23)
// 						_vec24 := EmptyVector
// 						for _, _elem24 := range (*_elem8).Issuer.PostalCode {
// 							_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 						}
// 						_map17.Add(MakeKeyword("PostalCode"), _vec24)
// 						_map17.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Issuer.SerialNumber))
// 						_map17.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Issuer.CommonName))
// 						_vec25 := EmptyVector
// 						for _, _elem25 := range (*_elem8).Issuer.Names {
// 							_vec25 = _vec25.Conjoin(_elem25)
// 						}
// 						_map17.Add(MakeKeyword("Names"), _vec25)
// 						_vec26 := EmptyVector
// 						for _, _elem26 := range (*_elem8).Issuer.ExtraNames {
// 							_vec26 = _vec26.Conjoin(_elem26)
// 						}
// 						_map17.Add(MakeKeyword("ExtraNames"), _vec26)
// 						_map9.Add(MakeKeyword("Issuer"), _map17)
// 						_map27 := EmptyArrayMap()
// 						_vec28 := EmptyVector
// 						for _, _elem28 := range (*_elem8).Subject.Country {
// 							_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 						}
// 						_map27.Add(MakeKeyword("Country"), _vec28)
// 						_vec29 := EmptyVector
// 						for _, _elem29 := range (*_elem8).Subject.Organization {
// 							_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 						}
// 						_map27.Add(MakeKeyword("Organization"), _vec29)
// 						_vec30 := EmptyVector
// 						for _, _elem30 := range (*_elem8).Subject.OrganizationalUnit {
// 							_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 						}
// 						_map27.Add(MakeKeyword("OrganizationalUnit"), _vec30)
// 						_vec31 := EmptyVector
// 						for _, _elem31 := range (*_elem8).Subject.Locality {
// 							_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 						}
// 						_map27.Add(MakeKeyword("Locality"), _vec31)
// 						_vec32 := EmptyVector
// 						for _, _elem32 := range (*_elem8).Subject.Province {
// 							_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 						}
// 						_map27.Add(MakeKeyword("Province"), _vec32)
// 						_vec33 := EmptyVector
// 						for _, _elem33 := range (*_elem8).Subject.StreetAddress {
// 							_vec33 = _vec33.Conjoin(MakeString(_elem33))
// 						}
// 						_map27.Add(MakeKeyword("StreetAddress"), _vec33)
// 						_vec34 := EmptyVector
// 						for _, _elem34 := range (*_elem8).Subject.PostalCode {
// 							_vec34 = _vec34.Conjoin(MakeString(_elem34))
// 						}
// 						_map27.Add(MakeKeyword("PostalCode"), _vec34)
// 						_map27.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Subject.SerialNumber))
// 						_map27.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Subject.CommonName))
// 						_vec35 := EmptyVector
// 						for _, _elem35 := range (*_elem8).Subject.Names {
// 							_vec35 = _vec35.Conjoin(_elem35)
// 						}
// 						_map27.Add(MakeKeyword("Names"), _vec35)
// 						_vec36 := EmptyVector
// 						for _, _elem36 := range (*_elem8).Subject.ExtraNames {
// 							_vec36 = _vec36.Conjoin(_elem36)
// 						}
// 						_map27.Add(MakeKeyword("ExtraNames"), _vec36)
// 						_map9.Add(MakeKeyword("Subject"), _map27)
// 						_map9.Add(MakeKeyword("NotBefore"), NIL)
// 						_map9.Add(MakeKeyword("NotAfter"), NIL)
// 						_map9.Add(MakeKeyword("KeyUsage"), (*_elem8).KeyUsage)
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range (*_elem8).Extensions {
// 							_map40 := EmptyArrayMap()
// 							_vec41 := EmptyVector
// 							for _, _elem41 := range _elem39.Id {
// 								_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 							}
// 							_map40.Add(MakeKeyword("Id"), _vec41)
// 							_map40.Add(MakeKeyword("Critical"), MakeBool(_elem39.Critical))
// 							_vec42 := EmptyVector
// 							for _, _elem42 := range _elem39.Value {
// 								_vec42 = _vec42.Conjoin(MakeInt(int(_elem42)))
// 							}
// 							_map40.Add(MakeKeyword("Value"), _vec42)
// 							_vec39 = _vec39.Conjoin(_map40)
// 						}
// 						_map9.Add(MakeKeyword("Extensions"), _vec39)
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range (*_elem8).ExtraExtensions {
// 							_map44 := EmptyArrayMap()
// 							_vec45 := EmptyVector
// 							for _, _elem45 := range _elem43.Id {
// 								_vec45 = _vec45.Conjoin(MakeInt(_elem45))
// 							}
// 							_map44.Add(MakeKeyword("Id"), _vec45)
// 							_map44.Add(MakeKeyword("Critical"), MakeBool(_elem43.Critical))
// 							_vec46 := EmptyVector
// 							for _, _elem46 := range _elem43.Value {
// 								_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 							}
// 							_map44.Add(MakeKeyword("Value"), _vec46)
// 							_vec43 = _vec43.Conjoin(_map44)
// 						}
// 						_map9.Add(MakeKeyword("ExtraExtensions"), _vec43)
// 						_vec47 := EmptyVector
// 						for _, _elem47 := range (*_elem8).UnhandledCriticalExtensions {
// 							_vec48 := EmptyVector
// 							for _, _elem48 := range _elem47 {
// 								_vec48 = _vec48.Conjoin(MakeInt(_elem48))
// 							}
// 							_vec47 = _vec47.Conjoin(_vec48)
// 						}
// 						_map9.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec47)
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range (*_elem8).ExtKeyUsage {
// 							_vec49 = _vec49.Conjoin(_elem49)
// 						}
// 						_map9.Add(MakeKeyword("ExtKeyUsage"), _vec49)
// 						_vec50 := EmptyVector
// 						for _, _elem50 := range (*_elem8).UnknownExtKeyUsage {
// 							_vec51 := EmptyVector
// 							for _, _elem51 := range _elem50 {
// 								_vec51 = _vec51.Conjoin(MakeInt(_elem51))
// 							}
// 							_vec50 = _vec50.Conjoin(_vec51)
// 						}
// 						_map9.Add(MakeKeyword("UnknownExtKeyUsage"), _vec50)
// 						_map9.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem8).BasicConstraintsValid))
// 						_map9.Add(MakeKeyword("IsCA"), MakeBool((*_elem8).IsCA))
// 						_map9.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem8).MaxPathLen))
// 						_map9.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem8).MaxPathLenZero))
// 						_vec52 := EmptyVector
// 						for _, _elem52 := range (*_elem8).SubjectKeyId {
// 							_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 						}
// 						_map9.Add(MakeKeyword("SubjectKeyId"), _vec52)
// 						_vec53 := EmptyVector
// 						for _, _elem53 := range (*_elem8).AuthorityKeyId {
// 							_vec53 = _vec53.Conjoin(MakeInt(int(_elem53)))
// 						}
// 						_map9.Add(MakeKeyword("AuthorityKeyId"), _vec53)
// 						_vec54 := EmptyVector
// 						for _, _elem54 := range (*_elem8).OCSPServer {
// 							_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 						}
// 						_map9.Add(MakeKeyword("OCSPServer"), _vec54)
// 						_vec55 := EmptyVector
// 						for _, _elem55 := range (*_elem8).IssuingCertificateURL {
// 							_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 						}
// 						_map9.Add(MakeKeyword("IssuingCertificateURL"), _vec55)
// 						_vec56 := EmptyVector
// 						for _, _elem56 := range (*_elem8).DNSNames {
// 							_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 						}
// 						_map9.Add(MakeKeyword("DNSNames"), _vec56)
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range (*_elem8).EmailAddresses {
// 							_vec57 = _vec57.Conjoin(MakeString(_elem57))
// 						}
// 						_map9.Add(MakeKeyword("EmailAddresses"), _vec57)
// 						_vec58 := EmptyVector
// 						for _, _elem58 := range (*_elem8).IPAddresses {
// 							_vec59 := EmptyVector
// 							for _, _elem59 := range _elem58 {
// 								_vec59 = _vec59.Conjoin(MakeInt(int(_elem59)))
// 							}
// 							_vec58 = _vec58.Conjoin(_vec59)
// 						}
// 						_map9.Add(MakeKeyword("IPAddresses"), _vec58)
// 						_vec60 := EmptyVector
// 						for _, _elem60 := range (*_elem8).URIs {
// 							var _obj_map61 Object
// 							if _elem60 != nil {
// 								_map61 := EmptyArrayMap()
// 								_map61.Add(MakeKeyword("Scheme"), MakeString((*_elem60).Scheme))
// 								_map61.Add(MakeKeyword("Opaque"), MakeString((*_elem60).Opaque))
// 								_map61.Add(MakeKeyword("User"), (*(*_elem60).User))
// 								_map61.Add(MakeKeyword("Host"), MakeString((*_elem60).Host))
// 								_map61.Add(MakeKeyword("Path"), MakeString((*_elem60).Path))
// 								_map61.Add(MakeKeyword("RawPath"), MakeString((*_elem60).RawPath))
// 								_map61.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem60).ForceQuery))
// 								_map61.Add(MakeKeyword("RawQuery"), MakeString((*_elem60).RawQuery))
// 								_map61.Add(MakeKeyword("Fragment"), MakeString((*_elem60).Fragment))
// 								_obj_map61 = Object(_map61)
// 							} else {
// 								_obj_map61 = NIL
// 							}
// 							_vec60 = _vec60.Conjoin(_obj_map61)
// 						}
// 						_map9.Add(MakeKeyword("URIs"), _vec60)
// 						_map9.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem8).PermittedDNSDomainsCritical))
// 						_vec62 := EmptyVector
// 						for _, _elem62 := range (*_elem8).PermittedDNSDomains {
// 							_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 						}
// 						_map9.Add(MakeKeyword("PermittedDNSDomains"), _vec62)
// 						_vec63 := EmptyVector
// 						for _, _elem63 := range (*_elem8).ExcludedDNSDomains {
// 							_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedDNSDomains"), _vec63)
// 						_vec64 := EmptyVector
// 						for _, _elem64 := range (*_elem8).PermittedIPRanges {
// 							var _obj_map65 Object
// 							if _elem64 != nil {
// 								_map65 := EmptyArrayMap()
// 								_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 								_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 								_obj_map65 = Object(_map65)
// 							} else {
// 								_obj_map65 = NIL
// 							}
// 							_vec64 = _vec64.Conjoin(_obj_map65)
// 						}
// 						_map9.Add(MakeKeyword("PermittedIPRanges"), _vec64)
// 						_vec66 := EmptyVector
// 						for _, _elem66 := range (*_elem8).ExcludedIPRanges {
// 							var _obj_map67 Object
// 							if _elem66 != nil {
// 								_map67 := EmptyArrayMap()
// 								_map67.Add(MakeKeyword("IP"), (*_elem66).IP)
// 								_map67.Add(MakeKeyword("Mask"), (*_elem66).Mask)
// 								_obj_map67 = Object(_map67)
// 							} else {
// 								_obj_map67 = NIL
// 							}
// 							_vec66 = _vec66.Conjoin(_obj_map67)
// 						}
// 						_map9.Add(MakeKeyword("ExcludedIPRanges"), _vec66)
// 						_vec68 := EmptyVector
// 						for _, _elem68 := range (*_elem8).PermittedEmailAddresses {
// 							_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 						}
// 						_map9.Add(MakeKeyword("PermittedEmailAddresses"), _vec68)
// 						_vec69 := EmptyVector
// 						for _, _elem69 := range (*_elem8).ExcludedEmailAddresses {
// 							_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedEmailAddresses"), _vec69)
// 						_vec70 := EmptyVector
// 						for _, _elem70 := range (*_elem8).PermittedURIDomains {
// 							_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 						}
// 						_map9.Add(MakeKeyword("PermittedURIDomains"), _vec70)
// 						_vec71 := EmptyVector
// 						for _, _elem71 := range (*_elem8).ExcludedURIDomains {
// 							_vec71 = _vec71.Conjoin(MakeString(_elem71))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedURIDomains"), _vec71)
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range (*_elem8).CRLDistributionPoints {
// 							_vec72 = _vec72.Conjoin(MakeString(_elem72))
// 						}
// 						_map9.Add(MakeKeyword("CRLDistributionPoints"), _vec72)
// 						_vec73 := EmptyVector
// 						for _, _elem73 := range (*_elem8).PolicyIdentifiers {
// 							_vec74 := EmptyVector
// 							for _, _elem74 := range _elem73 {
// 								_vec74 = _vec74.Conjoin(MakeInt(_elem74))
// 							}
// 							_vec73 = _vec73.Conjoin(_vec74)
// 						}
// 						_map9.Add(MakeKeyword("PolicyIdentifiers"), _vec73)
// 						_obj_map9 = Object(_map9)
// 					} else {
// 						_obj_map9 = NIL
// 					}
// 					_vec8 = _vec8.Conjoin(_obj_map9)
// 				}
// 				_map7.Add(MakeKeyword("PeerCertificates"), _vec8)
// 				_vec75 := EmptyVector
// 				for _, _elem75 := range (*(*(*resp).Request).TLS).VerifiedChains {
// 					_vec76 := EmptyVector
// 					for _, _elem76 := range _elem75 {
// 						var _obj_map77 Object
// 						if _elem76 != nil {
// 							_map77 := EmptyArrayMap()
// 							_vec78 := EmptyVector
// 							for _, _elem78 := range (*_elem76).Raw {
// 								_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 							}
// 							_map77.Add(MakeKeyword("Raw"), _vec78)
// 							_vec79 := EmptyVector
// 							for _, _elem79 := range (*_elem76).RawTBSCertificate {
// 								_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 							}
// 							_map77.Add(MakeKeyword("RawTBSCertificate"), _vec79)
// 							_vec80 := EmptyVector
// 							for _, _elem80 := range (*_elem76).RawSubjectPublicKeyInfo {
// 								_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec80)
// 							_vec81 := EmptyVector
// 							for _, _elem81 := range (*_elem76).RawSubject {
// 								_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubject"), _vec81)
// 							_vec82 := EmptyVector
// 							for _, _elem82 := range (*_elem76).RawIssuer {
// 								_vec82 = _vec82.Conjoin(MakeInt(int(_elem82)))
// 							}
// 							_map77.Add(MakeKeyword("RawIssuer"), _vec82)
// 							_vec83 := EmptyVector
// 							for _, _elem83 := range (*_elem76).Signature {
// 								_vec83 = _vec83.Conjoin(MakeInt(int(_elem83)))
// 							}
// 							_map77.Add(MakeKeyword("Signature"), _vec83)
// 							_map77.Add(MakeKeyword("SignatureAlgorithm"), (*_elem76).SignatureAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem76).PublicKeyAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKey"), (*_elem76).PublicKey)
// 							_map77.Add(MakeKeyword("Version"), MakeInt((*_elem76).Version))
// 							_map77.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map85 := EmptyArrayMap()
// 							_vec86 := EmptyVector
// 							for _, _elem86 := range (*_elem76).Issuer.Country {
// 								_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 							}
// 							_map85.Add(MakeKeyword("Country"), _vec86)
// 							_vec87 := EmptyVector
// 							for _, _elem87 := range (*_elem76).Issuer.Organization {
// 								_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 							}
// 							_map85.Add(MakeKeyword("Organization"), _vec87)
// 							_vec88 := EmptyVector
// 							for _, _elem88 := range (*_elem76).Issuer.OrganizationalUnit {
// 								_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 							}
// 							_map85.Add(MakeKeyword("OrganizationalUnit"), _vec88)
// 							_vec89 := EmptyVector
// 							for _, _elem89 := range (*_elem76).Issuer.Locality {
// 								_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 							}
// 							_map85.Add(MakeKeyword("Locality"), _vec89)
// 							_vec90 := EmptyVector
// 							for _, _elem90 := range (*_elem76).Issuer.Province {
// 								_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 							}
// 							_map85.Add(MakeKeyword("Province"), _vec90)
// 							_vec91 := EmptyVector
// 							for _, _elem91 := range (*_elem76).Issuer.StreetAddress {
// 								_vec91 = _vec91.Conjoin(MakeString(_elem91))
// 							}
// 							_map85.Add(MakeKeyword("StreetAddress"), _vec91)
// 							_vec92 := EmptyVector
// 							for _, _elem92 := range (*_elem76).Issuer.PostalCode {
// 								_vec92 = _vec92.Conjoin(MakeString(_elem92))
// 							}
// 							_map85.Add(MakeKeyword("PostalCode"), _vec92)
// 							_map85.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Issuer.SerialNumber))
// 							_map85.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Issuer.CommonName))
// 							_vec93 := EmptyVector
// 							for _, _elem93 := range (*_elem76).Issuer.Names {
// 								_vec93 = _vec93.Conjoin(_elem93)
// 							}
// 							_map85.Add(MakeKeyword("Names"), _vec93)
// 							_vec94 := EmptyVector
// 							for _, _elem94 := range (*_elem76).Issuer.ExtraNames {
// 								_vec94 = _vec94.Conjoin(_elem94)
// 							}
// 							_map85.Add(MakeKeyword("ExtraNames"), _vec94)
// 							_map77.Add(MakeKeyword("Issuer"), _map85)
// 							_map95 := EmptyArrayMap()
// 							_vec96 := EmptyVector
// 							for _, _elem96 := range (*_elem76).Subject.Country {
// 								_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 							}
// 							_map95.Add(MakeKeyword("Country"), _vec96)
// 							_vec97 := EmptyVector
// 							for _, _elem97 := range (*_elem76).Subject.Organization {
// 								_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 							}
// 							_map95.Add(MakeKeyword("Organization"), _vec97)
// 							_vec98 := EmptyVector
// 							for _, _elem98 := range (*_elem76).Subject.OrganizationalUnit {
// 								_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 							}
// 							_map95.Add(MakeKeyword("OrganizationalUnit"), _vec98)
// 							_vec99 := EmptyVector
// 							for _, _elem99 := range (*_elem76).Subject.Locality {
// 								_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 							}
// 							_map95.Add(MakeKeyword("Locality"), _vec99)
// 							_vec100 := EmptyVector
// 							for _, _elem100 := range (*_elem76).Subject.Province {
// 								_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 							}
// 							_map95.Add(MakeKeyword("Province"), _vec100)
// 							_vec101 := EmptyVector
// 							for _, _elem101 := range (*_elem76).Subject.StreetAddress {
// 								_vec101 = _vec101.Conjoin(MakeString(_elem101))
// 							}
// 							_map95.Add(MakeKeyword("StreetAddress"), _vec101)
// 							_vec102 := EmptyVector
// 							for _, _elem102 := range (*_elem76).Subject.PostalCode {
// 								_vec102 = _vec102.Conjoin(MakeString(_elem102))
// 							}
// 							_map95.Add(MakeKeyword("PostalCode"), _vec102)
// 							_map95.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Subject.SerialNumber))
// 							_map95.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Subject.CommonName))
// 							_vec103 := EmptyVector
// 							for _, _elem103 := range (*_elem76).Subject.Names {
// 								_vec103 = _vec103.Conjoin(_elem103)
// 							}
// 							_map95.Add(MakeKeyword("Names"), _vec103)
// 							_vec104 := EmptyVector
// 							for _, _elem104 := range (*_elem76).Subject.ExtraNames {
// 								_vec104 = _vec104.Conjoin(_elem104)
// 							}
// 							_map95.Add(MakeKeyword("ExtraNames"), _vec104)
// 							_map77.Add(MakeKeyword("Subject"), _map95)
// 							_map77.Add(MakeKeyword("NotBefore"), NIL)
// 							_map77.Add(MakeKeyword("NotAfter"), NIL)
// 							_map77.Add(MakeKeyword("KeyUsage"), (*_elem76).KeyUsage)
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range (*_elem76).Extensions {
// 								_map108 := EmptyArrayMap()
// 								_vec109 := EmptyVector
// 								for _, _elem109 := range _elem107.Id {
// 									_vec109 = _vec109.Conjoin(MakeInt(_elem109))
// 								}
// 								_map108.Add(MakeKeyword("Id"), _vec109)
// 								_map108.Add(MakeKeyword("Critical"), MakeBool(_elem107.Critical))
// 								_vec110 := EmptyVector
// 								for _, _elem110 := range _elem107.Value {
// 									_vec110 = _vec110.Conjoin(MakeInt(int(_elem110)))
// 								}
// 								_map108.Add(MakeKeyword("Value"), _vec110)
// 								_vec107 = _vec107.Conjoin(_map108)
// 							}
// 							_map77.Add(MakeKeyword("Extensions"), _vec107)
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range (*_elem76).ExtraExtensions {
// 								_map112 := EmptyArrayMap()
// 								_vec113 := EmptyVector
// 								for _, _elem113 := range _elem111.Id {
// 									_vec113 = _vec113.Conjoin(MakeInt(_elem113))
// 								}
// 								_map112.Add(MakeKeyword("Id"), _vec113)
// 								_map112.Add(MakeKeyword("Critical"), MakeBool(_elem111.Critical))
// 								_vec114 := EmptyVector
// 								for _, _elem114 := range _elem111.Value {
// 									_vec114 = _vec114.Conjoin(MakeInt(int(_elem114)))
// 								}
// 								_map112.Add(MakeKeyword("Value"), _vec114)
// 								_vec111 = _vec111.Conjoin(_map112)
// 							}
// 							_map77.Add(MakeKeyword("ExtraExtensions"), _vec111)
// 							_vec115 := EmptyVector
// 							for _, _elem115 := range (*_elem76).UnhandledCriticalExtensions {
// 								_vec116 := EmptyVector
// 								for _, _elem116 := range _elem115 {
// 									_vec116 = _vec116.Conjoin(MakeInt(_elem116))
// 								}
// 								_vec115 = _vec115.Conjoin(_vec116)
// 							}
// 							_map77.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec115)
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range (*_elem76).ExtKeyUsage {
// 								_vec117 = _vec117.Conjoin(_elem117)
// 							}
// 							_map77.Add(MakeKeyword("ExtKeyUsage"), _vec117)
// 							_vec118 := EmptyVector
// 							for _, _elem118 := range (*_elem76).UnknownExtKeyUsage {
// 								_vec119 := EmptyVector
// 								for _, _elem119 := range _elem118 {
// 									_vec119 = _vec119.Conjoin(MakeInt(_elem119))
// 								}
// 								_vec118 = _vec118.Conjoin(_vec119)
// 							}
// 							_map77.Add(MakeKeyword("UnknownExtKeyUsage"), _vec118)
// 							_map77.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem76).BasicConstraintsValid))
// 							_map77.Add(MakeKeyword("IsCA"), MakeBool((*_elem76).IsCA))
// 							_map77.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem76).MaxPathLen))
// 							_map77.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem76).MaxPathLenZero))
// 							_vec120 := EmptyVector
// 							for _, _elem120 := range (*_elem76).SubjectKeyId {
// 								_vec120 = _vec120.Conjoin(MakeInt(int(_elem120)))
// 							}
// 							_map77.Add(MakeKeyword("SubjectKeyId"), _vec120)
// 							_vec121 := EmptyVector
// 							for _, _elem121 := range (*_elem76).AuthorityKeyId {
// 								_vec121 = _vec121.Conjoin(MakeInt(int(_elem121)))
// 							}
// 							_map77.Add(MakeKeyword("AuthorityKeyId"), _vec121)
// 							_vec122 := EmptyVector
// 							for _, _elem122 := range (*_elem76).OCSPServer {
// 								_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 							}
// 							_map77.Add(MakeKeyword("OCSPServer"), _vec122)
// 							_vec123 := EmptyVector
// 							for _, _elem123 := range (*_elem76).IssuingCertificateURL {
// 								_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 							}
// 							_map77.Add(MakeKeyword("IssuingCertificateURL"), _vec123)
// 							_vec124 := EmptyVector
// 							for _, _elem124 := range (*_elem76).DNSNames {
// 								_vec124 = _vec124.Conjoin(MakeString(_elem124))
// 							}
// 							_map77.Add(MakeKeyword("DNSNames"), _vec124)
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range (*_elem76).EmailAddresses {
// 								_vec125 = _vec125.Conjoin(MakeString(_elem125))
// 							}
// 							_map77.Add(MakeKeyword("EmailAddresses"), _vec125)
// 							_vec126 := EmptyVector
// 							for _, _elem126 := range (*_elem76).IPAddresses {
// 								_vec127 := EmptyVector
// 								for _, _elem127 := range _elem126 {
// 									_vec127 = _vec127.Conjoin(MakeInt(int(_elem127)))
// 								}
// 								_vec126 = _vec126.Conjoin(_vec127)
// 							}
// 							_map77.Add(MakeKeyword("IPAddresses"), _vec126)
// 							_vec128 := EmptyVector
// 							for _, _elem128 := range (*_elem76).URIs {
// 								var _obj_map129 Object
// 								if _elem128 != nil {
// 									_map129 := EmptyArrayMap()
// 									_map129.Add(MakeKeyword("Scheme"), MakeString((*_elem128).Scheme))
// 									_map129.Add(MakeKeyword("Opaque"), MakeString((*_elem128).Opaque))
// 									_map129.Add(MakeKeyword("User"), (*(*_elem128).User))
// 									_map129.Add(MakeKeyword("Host"), MakeString((*_elem128).Host))
// 									_map129.Add(MakeKeyword("Path"), MakeString((*_elem128).Path))
// 									_map129.Add(MakeKeyword("RawPath"), MakeString((*_elem128).RawPath))
// 									_map129.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem128).ForceQuery))
// 									_map129.Add(MakeKeyword("RawQuery"), MakeString((*_elem128).RawQuery))
// 									_map129.Add(MakeKeyword("Fragment"), MakeString((*_elem128).Fragment))
// 									_obj_map129 = Object(_map129)
// 								} else {
// 									_obj_map129 = NIL
// 								}
// 								_vec128 = _vec128.Conjoin(_obj_map129)
// 							}
// 							_map77.Add(MakeKeyword("URIs"), _vec128)
// 							_map77.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem76).PermittedDNSDomainsCritical))
// 							_vec130 := EmptyVector
// 							for _, _elem130 := range (*_elem76).PermittedDNSDomains {
// 								_vec130 = _vec130.Conjoin(MakeString(_elem130))
// 							}
// 							_map77.Add(MakeKeyword("PermittedDNSDomains"), _vec130)
// 							_vec131 := EmptyVector
// 							for _, _elem131 := range (*_elem76).ExcludedDNSDomains {
// 								_vec131 = _vec131.Conjoin(MakeString(_elem131))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedDNSDomains"), _vec131)
// 							_vec132 := EmptyVector
// 							for _, _elem132 := range (*_elem76).PermittedIPRanges {
// 								var _obj_map133 Object
// 								if _elem132 != nil {
// 									_map133 := EmptyArrayMap()
// 									_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 									_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 									_obj_map133 = Object(_map133)
// 								} else {
// 									_obj_map133 = NIL
// 								}
// 								_vec132 = _vec132.Conjoin(_obj_map133)
// 							}
// 							_map77.Add(MakeKeyword("PermittedIPRanges"), _vec132)
// 							_vec134 := EmptyVector
// 							for _, _elem134 := range (*_elem76).ExcludedIPRanges {
// 								var _obj_map135 Object
// 								if _elem134 != nil {
// 									_map135 := EmptyArrayMap()
// 									_map135.Add(MakeKeyword("IP"), (*_elem134).IP)
// 									_map135.Add(MakeKeyword("Mask"), (*_elem134).Mask)
// 									_obj_map135 = Object(_map135)
// 								} else {
// 									_obj_map135 = NIL
// 								}
// 								_vec134 = _vec134.Conjoin(_obj_map135)
// 							}
// 							_map77.Add(MakeKeyword("ExcludedIPRanges"), _vec134)
// 							_vec136 := EmptyVector
// 							for _, _elem136 := range (*_elem76).PermittedEmailAddresses {
// 								_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 							}
// 							_map77.Add(MakeKeyword("PermittedEmailAddresses"), _vec136)
// 							_vec137 := EmptyVector
// 							for _, _elem137 := range (*_elem76).ExcludedEmailAddresses {
// 								_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedEmailAddresses"), _vec137)
// 							_vec138 := EmptyVector
// 							for _, _elem138 := range (*_elem76).PermittedURIDomains {
// 								_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 							}
// 							_map77.Add(MakeKeyword("PermittedURIDomains"), _vec138)
// 							_vec139 := EmptyVector
// 							for _, _elem139 := range (*_elem76).ExcludedURIDomains {
// 								_vec139 = _vec139.Conjoin(MakeString(_elem139))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedURIDomains"), _vec139)
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range (*_elem76).CRLDistributionPoints {
// 								_vec140 = _vec140.Conjoin(MakeString(_elem140))
// 							}
// 							_map77.Add(MakeKeyword("CRLDistributionPoints"), _vec140)
// 							_vec141 := EmptyVector
// 							for _, _elem141 := range (*_elem76).PolicyIdentifiers {
// 								_vec142 := EmptyVector
// 								for _, _elem142 := range _elem141 {
// 									_vec142 = _vec142.Conjoin(MakeInt(_elem142))
// 								}
// 								_vec141 = _vec141.Conjoin(_vec142)
// 							}
// 							_map77.Add(MakeKeyword("PolicyIdentifiers"), _vec141)
// 							_obj_map77 = Object(_map77)
// 						} else {
// 							_obj_map77 = NIL
// 						}
// 						_vec76 = _vec76.Conjoin(_obj_map77)
// 					}
// 					_vec75 = _vec75.Conjoin(_vec76)
// 				}
// 				_map7.Add(MakeKeyword("VerifiedChains"), _vec75)
// 				_vec143 := EmptyVector
// 				for _, _elem143 := range (*(*(*resp).Request).TLS).SignedCertificateTimestamps {
// 					_vec144 := EmptyVector
// 					for _, _elem144 := range _elem143 {
// 						_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 					}
// 					_vec143 = _vec143.Conjoin(_vec144)
// 				}
// 				_map7.Add(MakeKeyword("SignedCertificateTimestamps"), _vec143)
// 				_vec145 := EmptyVector
// 				for _, _elem145 := range (*(*(*resp).Request).TLS).OCSPResponse {
// 					_vec145 = _vec145.Conjoin(MakeInt(int(_elem145)))
// 				}
// 				_map7.Add(MakeKeyword("OCSPResponse"), _vec145)
// 				_vec146 := EmptyVector
// 				for _, _elem146 := range (*(*(*resp).Request).TLS).TLSUnique {
// 					_vec146 = _vec146.Conjoin(MakeInt(int(_elem146)))
// 				}
// 				_map7.Add(MakeKeyword("TLSUnique"), _vec146)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_map3.Add(MakeKeyword("TLS"), _obj_map7)
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		var _obj_map147 Object
// 		if (*resp).TLS != nil {
// 			_map147 := EmptyArrayMap()
// 			_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*resp).TLS).Version)))
// 			_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*resp).TLS).HandshakeComplete))
// 			_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*resp).TLS).DidResume))
// 			_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*resp).TLS).CipherSuite)))
// 			_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*resp).TLS).NegotiatedProtocol))
// 			_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*resp).TLS).NegotiatedProtocolIsMutual))
// 			_map147.Add(MakeKeyword("ServerName"), MakeString((*(*resp).TLS).ServerName))
// 			_vec148 := EmptyVector
// 			for _, _elem148 := range (*(*resp).TLS).PeerCertificates {
// 				var _obj_map149 Object
// 				if _elem148 != nil {
// 					_map149 := EmptyArrayMap()
// 					_vec150 := EmptyVector
// 					for _, _elem150 := range (*_elem148).Raw {
// 						_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 					}
// 					_map149.Add(MakeKeyword("Raw"), _vec150)
// 					_vec151 := EmptyVector
// 					for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 						_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 					}
// 					_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 					_vec152 := EmptyVector
// 					for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 						_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 					_vec153 := EmptyVector
// 					for _, _elem153 := range (*_elem148).RawSubject {
// 						_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 					_vec154 := EmptyVector
// 					for _, _elem154 := range (*_elem148).RawIssuer {
// 						_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 					}
// 					_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 					_vec155 := EmptyVector
// 					for _, _elem155 := range (*_elem148).Signature {
// 						_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 					}
// 					_map149.Add(MakeKeyword("Signature"), _vec155)
// 					_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 					_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 					_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map157 := EmptyArrayMap()
// 					_vec158 := EmptyVector
// 					for _, _elem158 := range (*_elem148).Issuer.Country {
// 						_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 					}
// 					_map157.Add(MakeKeyword("Country"), _vec158)
// 					_vec159 := EmptyVector
// 					for _, _elem159 := range (*_elem148).Issuer.Organization {
// 						_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 					}
// 					_map157.Add(MakeKeyword("Organization"), _vec159)
// 					_vec160 := EmptyVector
// 					for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 						_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 					}
// 					_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 					_vec161 := EmptyVector
// 					for _, _elem161 := range (*_elem148).Issuer.Locality {
// 						_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 					}
// 					_map157.Add(MakeKeyword("Locality"), _vec161)
// 					_vec162 := EmptyVector
// 					for _, _elem162 := range (*_elem148).Issuer.Province {
// 						_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 					}
// 					_map157.Add(MakeKeyword("Province"), _vec162)
// 					_vec163 := EmptyVector
// 					for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 						_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 					}
// 					_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 					_vec164 := EmptyVector
// 					for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 						_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 					}
// 					_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 					_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 					_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 					_vec165 := EmptyVector
// 					for _, _elem165 := range (*_elem148).Issuer.Names {
// 						_vec165 = _vec165.Conjoin(_elem165)
// 					}
// 					_map157.Add(MakeKeyword("Names"), _vec165)
// 					_vec166 := EmptyVector
// 					for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 						_vec166 = _vec166.Conjoin(_elem166)
// 					}
// 					_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 					_map149.Add(MakeKeyword("Issuer"), _map157)
// 					_map167 := EmptyArrayMap()
// 					_vec168 := EmptyVector
// 					for _, _elem168 := range (*_elem148).Subject.Country {
// 						_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 					}
// 					_map167.Add(MakeKeyword("Country"), _vec168)
// 					_vec169 := EmptyVector
// 					for _, _elem169 := range (*_elem148).Subject.Organization {
// 						_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 					}
// 					_map167.Add(MakeKeyword("Organization"), _vec169)
// 					_vec170 := EmptyVector
// 					for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 						_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 					}
// 					_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 					_vec171 := EmptyVector
// 					for _, _elem171 := range (*_elem148).Subject.Locality {
// 						_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 					}
// 					_map167.Add(MakeKeyword("Locality"), _vec171)
// 					_vec172 := EmptyVector
// 					for _, _elem172 := range (*_elem148).Subject.Province {
// 						_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 					}
// 					_map167.Add(MakeKeyword("Province"), _vec172)
// 					_vec173 := EmptyVector
// 					for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 						_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 					}
// 					_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 					_vec174 := EmptyVector
// 					for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 						_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 					}
// 					_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 					_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 					_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 					_vec175 := EmptyVector
// 					for _, _elem175 := range (*_elem148).Subject.Names {
// 						_vec175 = _vec175.Conjoin(_elem175)
// 					}
// 					_map167.Add(MakeKeyword("Names"), _vec175)
// 					_vec176 := EmptyVector
// 					for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 						_vec176 = _vec176.Conjoin(_elem176)
// 					}
// 					_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 					_map149.Add(MakeKeyword("Subject"), _map167)
// 					_map149.Add(MakeKeyword("NotBefore"), NIL)
// 					_map149.Add(MakeKeyword("NotAfter"), NIL)
// 					_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 					_vec179 := EmptyVector
// 					for _, _elem179 := range (*_elem148).Extensions {
// 						_map180 := EmptyArrayMap()
// 						_vec181 := EmptyVector
// 						for _, _elem181 := range _elem179.Id {
// 							_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 						}
// 						_map180.Add(MakeKeyword("Id"), _vec181)
// 						_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 						_vec182 := EmptyVector
// 						for _, _elem182 := range _elem179.Value {
// 							_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 						}
// 						_map180.Add(MakeKeyword("Value"), _vec182)
// 						_vec179 = _vec179.Conjoin(_map180)
// 					}
// 					_map149.Add(MakeKeyword("Extensions"), _vec179)
// 					_vec183 := EmptyVector
// 					for _, _elem183 := range (*_elem148).ExtraExtensions {
// 						_map184 := EmptyArrayMap()
// 						_vec185 := EmptyVector
// 						for _, _elem185 := range _elem183.Id {
// 							_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 						}
// 						_map184.Add(MakeKeyword("Id"), _vec185)
// 						_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 						_vec186 := EmptyVector
// 						for _, _elem186 := range _elem183.Value {
// 							_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 						}
// 						_map184.Add(MakeKeyword("Value"), _vec186)
// 						_vec183 = _vec183.Conjoin(_map184)
// 					}
// 					_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 					_vec187 := EmptyVector
// 					for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 						_vec188 := EmptyVector
// 						for _, _elem188 := range _elem187 {
// 							_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 						}
// 						_vec187 = _vec187.Conjoin(_vec188)
// 					}
// 					_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 					_vec189 := EmptyVector
// 					for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 						_vec189 = _vec189.Conjoin(_elem189)
// 					}
// 					_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 					_vec190 := EmptyVector
// 					for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 						_vec191 := EmptyVector
// 						for _, _elem191 := range _elem190 {
// 							_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 						}
// 						_vec190 = _vec190.Conjoin(_vec191)
// 					}
// 					_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 					_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 					_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 					_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 					_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 					_vec192 := EmptyVector
// 					for _, _elem192 := range (*_elem148).SubjectKeyId {
// 						_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 					}
// 					_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 					_vec193 := EmptyVector
// 					for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 						_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 					}
// 					_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 					_vec194 := EmptyVector
// 					for _, _elem194 := range (*_elem148).OCSPServer {
// 						_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 					}
// 					_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 					_vec195 := EmptyVector
// 					for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 						_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 					}
// 					_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 					_vec196 := EmptyVector
// 					for _, _elem196 := range (*_elem148).DNSNames {
// 						_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 					}
// 					_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 					_vec197 := EmptyVector
// 					for _, _elem197 := range (*_elem148).EmailAddresses {
// 						_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 					}
// 					_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 					_vec198 := EmptyVector
// 					for _, _elem198 := range (*_elem148).IPAddresses {
// 						_vec199 := EmptyVector
// 						for _, _elem199 := range _elem198 {
// 							_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 						}
// 						_vec198 = _vec198.Conjoin(_vec199)
// 					}
// 					_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 					_vec200 := EmptyVector
// 					for _, _elem200 := range (*_elem148).URIs {
// 						var _obj_map201 Object
// 						if _elem200 != nil {
// 							_map201 := EmptyArrayMap()
// 							_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 							_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 							_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 							_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 							_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 							_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 							_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 							_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 							_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 							_obj_map201 = Object(_map201)
// 						} else {
// 							_obj_map201 = NIL
// 						}
// 						_vec200 = _vec200.Conjoin(_obj_map201)
// 					}
// 					_map149.Add(MakeKeyword("URIs"), _vec200)
// 					_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 					_vec202 := EmptyVector
// 					for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 						_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 					}
// 					_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 					_vec203 := EmptyVector
// 					for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 						_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 					_vec204 := EmptyVector
// 					for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 						var _obj_map205 Object
// 						if _elem204 != nil {
// 							_map205 := EmptyArrayMap()
// 							_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 							_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 							_obj_map205 = Object(_map205)
// 						} else {
// 							_obj_map205 = NIL
// 						}
// 						_vec204 = _vec204.Conjoin(_obj_map205)
// 					}
// 					_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 					_vec206 := EmptyVector
// 					for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 						var _obj_map207 Object
// 						if _elem206 != nil {
// 							_map207 := EmptyArrayMap()
// 							_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 							_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 							_obj_map207 = Object(_map207)
// 						} else {
// 							_obj_map207 = NIL
// 						}
// 						_vec206 = _vec206.Conjoin(_obj_map207)
// 					}
// 					_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 					_vec208 := EmptyVector
// 					for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 						_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 					}
// 					_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 					_vec209 := EmptyVector
// 					for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 						_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 					_vec210 := EmptyVector
// 					for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 						_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 					}
// 					_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 					_vec211 := EmptyVector
// 					for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 						_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 					_vec212 := EmptyVector
// 					for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 						_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 					}
// 					_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 					_vec213 := EmptyVector
// 					for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 						_vec214 := EmptyVector
// 						for _, _elem214 := range _elem213 {
// 							_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 						}
// 						_vec213 = _vec213.Conjoin(_vec214)
// 					}
// 					_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 					_obj_map149 = Object(_map149)
// 				} else {
// 					_obj_map149 = NIL
// 				}
// 				_vec148 = _vec148.Conjoin(_obj_map149)
// 			}
// 			_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 			_vec215 := EmptyVector
// 			for _, _elem215 := range (*(*resp).TLS).VerifiedChains {
// 				_vec216 := EmptyVector
// 				for _, _elem216 := range _elem215 {
// 					var _obj_map217 Object
// 					if _elem216 != nil {
// 						_map217 := EmptyArrayMap()
// 						_vec218 := EmptyVector
// 						for _, _elem218 := range (*_elem216).Raw {
// 							_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 						}
// 						_map217.Add(MakeKeyword("Raw"), _vec218)
// 						_vec219 := EmptyVector
// 						for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 							_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 						}
// 						_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 						_vec220 := EmptyVector
// 						for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 							_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 						_vec221 := EmptyVector
// 						for _, _elem221 := range (*_elem216).RawSubject {
// 							_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 						_vec222 := EmptyVector
// 						for _, _elem222 := range (*_elem216).RawIssuer {
// 							_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 						}
// 						_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 						_vec223 := EmptyVector
// 						for _, _elem223 := range (*_elem216).Signature {
// 							_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 						}
// 						_map217.Add(MakeKeyword("Signature"), _vec223)
// 						_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 						_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 						_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map225 := EmptyArrayMap()
// 						_vec226 := EmptyVector
// 						for _, _elem226 := range (*_elem216).Issuer.Country {
// 							_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 						}
// 						_map225.Add(MakeKeyword("Country"), _vec226)
// 						_vec227 := EmptyVector
// 						for _, _elem227 := range (*_elem216).Issuer.Organization {
// 							_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 						}
// 						_map225.Add(MakeKeyword("Organization"), _vec227)
// 						_vec228 := EmptyVector
// 						for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 							_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 						}
// 						_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 						_vec229 := EmptyVector
// 						for _, _elem229 := range (*_elem216).Issuer.Locality {
// 							_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 						}
// 						_map225.Add(MakeKeyword("Locality"), _vec229)
// 						_vec230 := EmptyVector
// 						for _, _elem230 := range (*_elem216).Issuer.Province {
// 							_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 						}
// 						_map225.Add(MakeKeyword("Province"), _vec230)
// 						_vec231 := EmptyVector
// 						for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 							_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 						}
// 						_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 						_vec232 := EmptyVector
// 						for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 							_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 						}
// 						_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 						_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 						_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 						_vec233 := EmptyVector
// 						for _, _elem233 := range (*_elem216).Issuer.Names {
// 							_vec233 = _vec233.Conjoin(_elem233)
// 						}
// 						_map225.Add(MakeKeyword("Names"), _vec233)
// 						_vec234 := EmptyVector
// 						for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 							_vec234 = _vec234.Conjoin(_elem234)
// 						}
// 						_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 						_map217.Add(MakeKeyword("Issuer"), _map225)
// 						_map235 := EmptyArrayMap()
// 						_vec236 := EmptyVector
// 						for _, _elem236 := range (*_elem216).Subject.Country {
// 							_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 						}
// 						_map235.Add(MakeKeyword("Country"), _vec236)
// 						_vec237 := EmptyVector
// 						for _, _elem237 := range (*_elem216).Subject.Organization {
// 							_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 						}
// 						_map235.Add(MakeKeyword("Organization"), _vec237)
// 						_vec238 := EmptyVector
// 						for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 							_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 						}
// 						_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 						_vec239 := EmptyVector
// 						for _, _elem239 := range (*_elem216).Subject.Locality {
// 							_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 						}
// 						_map235.Add(MakeKeyword("Locality"), _vec239)
// 						_vec240 := EmptyVector
// 						for _, _elem240 := range (*_elem216).Subject.Province {
// 							_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 						}
// 						_map235.Add(MakeKeyword("Province"), _vec240)
// 						_vec241 := EmptyVector
// 						for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 							_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 						}
// 						_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 						_vec242 := EmptyVector
// 						for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 							_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 						}
// 						_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 						_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 						_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 						_vec243 := EmptyVector
// 						for _, _elem243 := range (*_elem216).Subject.Names {
// 							_vec243 = _vec243.Conjoin(_elem243)
// 						}
// 						_map235.Add(MakeKeyword("Names"), _vec243)
// 						_vec244 := EmptyVector
// 						for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 							_vec244 = _vec244.Conjoin(_elem244)
// 						}
// 						_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 						_map217.Add(MakeKeyword("Subject"), _map235)
// 						_map217.Add(MakeKeyword("NotBefore"), NIL)
// 						_map217.Add(MakeKeyword("NotAfter"), NIL)
// 						_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 						_vec247 := EmptyVector
// 						for _, _elem247 := range (*_elem216).Extensions {
// 							_map248 := EmptyArrayMap()
// 							_vec249 := EmptyVector
// 							for _, _elem249 := range _elem247.Id {
// 								_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 							}
// 							_map248.Add(MakeKeyword("Id"), _vec249)
// 							_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 							_vec250 := EmptyVector
// 							for _, _elem250 := range _elem247.Value {
// 								_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 							}
// 							_map248.Add(MakeKeyword("Value"), _vec250)
// 							_vec247 = _vec247.Conjoin(_map248)
// 						}
// 						_map217.Add(MakeKeyword("Extensions"), _vec247)
// 						_vec251 := EmptyVector
// 						for _, _elem251 := range (*_elem216).ExtraExtensions {
// 							_map252 := EmptyArrayMap()
// 							_vec253 := EmptyVector
// 							for _, _elem253 := range _elem251.Id {
// 								_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 							}
// 							_map252.Add(MakeKeyword("Id"), _vec253)
// 							_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 							_vec254 := EmptyVector
// 							for _, _elem254 := range _elem251.Value {
// 								_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 							}
// 							_map252.Add(MakeKeyword("Value"), _vec254)
// 							_vec251 = _vec251.Conjoin(_map252)
// 						}
// 						_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 						_vec255 := EmptyVector
// 						for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 							_vec256 := EmptyVector
// 							for _, _elem256 := range _elem255 {
// 								_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 							}
// 							_vec255 = _vec255.Conjoin(_vec256)
// 						}
// 						_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 						_vec257 := EmptyVector
// 						for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 							_vec257 = _vec257.Conjoin(_elem257)
// 						}
// 						_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 						_vec258 := EmptyVector
// 						for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 							_vec259 := EmptyVector
// 							for _, _elem259 := range _elem258 {
// 								_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 							}
// 							_vec258 = _vec258.Conjoin(_vec259)
// 						}
// 						_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 						_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 						_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 						_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 						_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 						_vec260 := EmptyVector
// 						for _, _elem260 := range (*_elem216).SubjectKeyId {
// 							_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 						}
// 						_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 						_vec261 := EmptyVector
// 						for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 							_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 						}
// 						_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 						_vec262 := EmptyVector
// 						for _, _elem262 := range (*_elem216).OCSPServer {
// 							_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 						}
// 						_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 						_vec263 := EmptyVector
// 						for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 							_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 						}
// 						_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 						_vec264 := EmptyVector
// 						for _, _elem264 := range (*_elem216).DNSNames {
// 							_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 						}
// 						_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 						_vec265 := EmptyVector
// 						for _, _elem265 := range (*_elem216).EmailAddresses {
// 							_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 						}
// 						_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 						_vec266 := EmptyVector
// 						for _, _elem266 := range (*_elem216).IPAddresses {
// 							_vec267 := EmptyVector
// 							for _, _elem267 := range _elem266 {
// 								_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 							}
// 							_vec266 = _vec266.Conjoin(_vec267)
// 						}
// 						_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 						_vec268 := EmptyVector
// 						for _, _elem268 := range (*_elem216).URIs {
// 							var _obj_map269 Object
// 							if _elem268 != nil {
// 								_map269 := EmptyArrayMap()
// 								_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 								_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 								_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 								_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 								_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 								_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 								_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 								_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 								_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 								_obj_map269 = Object(_map269)
// 							} else {
// 								_obj_map269 = NIL
// 							}
// 							_vec268 = _vec268.Conjoin(_obj_map269)
// 						}
// 						_map217.Add(MakeKeyword("URIs"), _vec268)
// 						_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 						_vec270 := EmptyVector
// 						for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 							_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 						}
// 						_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 						_vec271 := EmptyVector
// 						for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 							_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 						_vec272 := EmptyVector
// 						for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 							var _obj_map273 Object
// 							if _elem272 != nil {
// 								_map273 := EmptyArrayMap()
// 								_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 								_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 								_obj_map273 = Object(_map273)
// 							} else {
// 								_obj_map273 = NIL
// 							}
// 							_vec272 = _vec272.Conjoin(_obj_map273)
// 						}
// 						_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 						_vec274 := EmptyVector
// 						for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 							var _obj_map275 Object
// 							if _elem274 != nil {
// 								_map275 := EmptyArrayMap()
// 								_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 								_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 								_obj_map275 = Object(_map275)
// 							} else {
// 								_obj_map275 = NIL
// 							}
// 							_vec274 = _vec274.Conjoin(_obj_map275)
// 						}
// 						_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 						_vec276 := EmptyVector
// 						for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 							_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 						}
// 						_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 						_vec277 := EmptyVector
// 						for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 							_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 						_vec278 := EmptyVector
// 						for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 							_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 						}
// 						_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 						_vec279 := EmptyVector
// 						for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 							_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 						_vec280 := EmptyVector
// 						for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 							_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 						}
// 						_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 						_vec281 := EmptyVector
// 						for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 							_vec282 := EmptyVector
// 							for _, _elem282 := range _elem281 {
// 								_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 							}
// 							_vec281 = _vec281.Conjoin(_vec282)
// 						}
// 						_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 						_obj_map217 = Object(_map217)
// 					} else {
// 						_obj_map217 = NIL
// 					}
// 					_vec216 = _vec216.Conjoin(_obj_map217)
// 				}
// 				_vec215 = _vec215.Conjoin(_vec216)
// 			}
// 			_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 			_vec283 := EmptyVector
// 			for _, _elem283 := range (*(*resp).TLS).SignedCertificateTimestamps {
// 				_vec284 := EmptyVector
// 				for _, _elem284 := range _elem283 {
// 					_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 				}
// 				_vec283 = _vec283.Conjoin(_vec284)
// 			}
// 			_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 			_vec285 := EmptyVector
// 			for _, _elem285 := range (*(*resp).TLS).OCSPResponse {
// 				_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 			}
// 			_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 			_vec286 := EmptyVector
// 			for _, _elem286 := range (*(*resp).TLS).TLSUnique {
// 				_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 			}
// 			_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 			_obj_map147 = Object(_map147)
// 		} else {
// 			_obj_map147 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map147)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.Handle:
// func handle(pattern string, handler net/http.Handler) Object {
// 	_http.Handle(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.HandleFunc:
// func handleFunc(pattern string, handler func) Object {
// 	_http.HandleFunc(pattern, handler)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.Head:
// func head(url string) Object {
// 	resp, err := _http.Head(url)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			var _obj_map6 Object
// 			if (*(*resp).Request).MultipartForm != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Value"), (*(*(*resp).Request).MultipartForm).Value)
// 				_map6.Add(MakeKeyword("File"), (*(*(*resp).Request).MultipartForm).File)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map3.Add(MakeKeyword("MultipartForm"), _obj_map6)
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			var _obj_map7 Object
// 			if (*(*resp).Request).TLS != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Version"), MakeInt(int((*(*(*resp).Request).TLS).Version)))
// 				_map7.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*resp).Request).TLS).HandshakeComplete))
// 				_map7.Add(MakeKeyword("DidResume"), MakeBool((*(*(*resp).Request).TLS).DidResume))
// 				_map7.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*resp).Request).TLS).CipherSuite)))
// 				_map7.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*resp).Request).TLS).NegotiatedProtocol))
// 				_map7.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*resp).Request).TLS).NegotiatedProtocolIsMutual))
// 				_map7.Add(MakeKeyword("ServerName"), MakeString((*(*(*resp).Request).TLS).ServerName))
// 				_vec8 := EmptyVector
// 				for _, _elem8 := range (*(*(*resp).Request).TLS).PeerCertificates {
// 					var _obj_map9 Object
// 					if _elem8 != nil {
// 						_map9 := EmptyArrayMap()
// 						_vec10 := EmptyVector
// 						for _, _elem10 := range (*_elem8).Raw {
// 							_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 						}
// 						_map9.Add(MakeKeyword("Raw"), _vec10)
// 						_vec11 := EmptyVector
// 						for _, _elem11 := range (*_elem8).RawTBSCertificate {
// 							_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 						}
// 						_map9.Add(MakeKeyword("RawTBSCertificate"), _vec11)
// 						_vec12 := EmptyVector
// 						for _, _elem12 := range (*_elem8).RawSubjectPublicKeyInfo {
// 							_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec12)
// 						_vec13 := EmptyVector
// 						for _, _elem13 := range (*_elem8).RawSubject {
// 							_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubject"), _vec13)
// 						_vec14 := EmptyVector
// 						for _, _elem14 := range (*_elem8).RawIssuer {
// 							_vec14 = _vec14.Conjoin(MakeInt(int(_elem14)))
// 						}
// 						_map9.Add(MakeKeyword("RawIssuer"), _vec14)
// 						_vec15 := EmptyVector
// 						for _, _elem15 := range (*_elem8).Signature {
// 							_vec15 = _vec15.Conjoin(MakeInt(int(_elem15)))
// 						}
// 						_map9.Add(MakeKeyword("Signature"), _vec15)
// 						_map9.Add(MakeKeyword("SignatureAlgorithm"), (*_elem8).SignatureAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem8).PublicKeyAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKey"), (*_elem8).PublicKey)
// 						_map9.Add(MakeKeyword("Version"), MakeInt((*_elem8).Version))
// 						_map9.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map17 := EmptyArrayMap()
// 						_vec18 := EmptyVector
// 						for _, _elem18 := range (*_elem8).Issuer.Country {
// 							_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 						}
// 						_map17.Add(MakeKeyword("Country"), _vec18)
// 						_vec19 := EmptyVector
// 						for _, _elem19 := range (*_elem8).Issuer.Organization {
// 							_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 						}
// 						_map17.Add(MakeKeyword("Organization"), _vec19)
// 						_vec20 := EmptyVector
// 						for _, _elem20 := range (*_elem8).Issuer.OrganizationalUnit {
// 							_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 						}
// 						_map17.Add(MakeKeyword("OrganizationalUnit"), _vec20)
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem8).Issuer.Locality {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map17.Add(MakeKeyword("Locality"), _vec21)
// 						_vec22 := EmptyVector
// 						for _, _elem22 := range (*_elem8).Issuer.Province {
// 							_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 						}
// 						_map17.Add(MakeKeyword("Province"), _vec22)
// 						_vec23 := EmptyVector
// 						for _, _elem23 := range (*_elem8).Issuer.StreetAddress {
// 							_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 						}
// 						_map17.Add(MakeKeyword("StreetAddress"), _vec23)
// 						_vec24 := EmptyVector
// 						for _, _elem24 := range (*_elem8).Issuer.PostalCode {
// 							_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 						}
// 						_map17.Add(MakeKeyword("PostalCode"), _vec24)
// 						_map17.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Issuer.SerialNumber))
// 						_map17.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Issuer.CommonName))
// 						_vec25 := EmptyVector
// 						for _, _elem25 := range (*_elem8).Issuer.Names {
// 							_vec25 = _vec25.Conjoin(_elem25)
// 						}
// 						_map17.Add(MakeKeyword("Names"), _vec25)
// 						_vec26 := EmptyVector
// 						for _, _elem26 := range (*_elem8).Issuer.ExtraNames {
// 							_vec26 = _vec26.Conjoin(_elem26)
// 						}
// 						_map17.Add(MakeKeyword("ExtraNames"), _vec26)
// 						_map9.Add(MakeKeyword("Issuer"), _map17)
// 						_map27 := EmptyArrayMap()
// 						_vec28 := EmptyVector
// 						for _, _elem28 := range (*_elem8).Subject.Country {
// 							_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 						}
// 						_map27.Add(MakeKeyword("Country"), _vec28)
// 						_vec29 := EmptyVector
// 						for _, _elem29 := range (*_elem8).Subject.Organization {
// 							_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 						}
// 						_map27.Add(MakeKeyword("Organization"), _vec29)
// 						_vec30 := EmptyVector
// 						for _, _elem30 := range (*_elem8).Subject.OrganizationalUnit {
// 							_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 						}
// 						_map27.Add(MakeKeyword("OrganizationalUnit"), _vec30)
// 						_vec31 := EmptyVector
// 						for _, _elem31 := range (*_elem8).Subject.Locality {
// 							_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 						}
// 						_map27.Add(MakeKeyword("Locality"), _vec31)
// 						_vec32 := EmptyVector
// 						for _, _elem32 := range (*_elem8).Subject.Province {
// 							_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 						}
// 						_map27.Add(MakeKeyword("Province"), _vec32)
// 						_vec33 := EmptyVector
// 						for _, _elem33 := range (*_elem8).Subject.StreetAddress {
// 							_vec33 = _vec33.Conjoin(MakeString(_elem33))
// 						}
// 						_map27.Add(MakeKeyword("StreetAddress"), _vec33)
// 						_vec34 := EmptyVector
// 						for _, _elem34 := range (*_elem8).Subject.PostalCode {
// 							_vec34 = _vec34.Conjoin(MakeString(_elem34))
// 						}
// 						_map27.Add(MakeKeyword("PostalCode"), _vec34)
// 						_map27.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Subject.SerialNumber))
// 						_map27.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Subject.CommonName))
// 						_vec35 := EmptyVector
// 						for _, _elem35 := range (*_elem8).Subject.Names {
// 							_vec35 = _vec35.Conjoin(_elem35)
// 						}
// 						_map27.Add(MakeKeyword("Names"), _vec35)
// 						_vec36 := EmptyVector
// 						for _, _elem36 := range (*_elem8).Subject.ExtraNames {
// 							_vec36 = _vec36.Conjoin(_elem36)
// 						}
// 						_map27.Add(MakeKeyword("ExtraNames"), _vec36)
// 						_map9.Add(MakeKeyword("Subject"), _map27)
// 						_map9.Add(MakeKeyword("NotBefore"), NIL)
// 						_map9.Add(MakeKeyword("NotAfter"), NIL)
// 						_map9.Add(MakeKeyword("KeyUsage"), (*_elem8).KeyUsage)
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range (*_elem8).Extensions {
// 							_map40 := EmptyArrayMap()
// 							_vec41 := EmptyVector
// 							for _, _elem41 := range _elem39.Id {
// 								_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 							}
// 							_map40.Add(MakeKeyword("Id"), _vec41)
// 							_map40.Add(MakeKeyword("Critical"), MakeBool(_elem39.Critical))
// 							_vec42 := EmptyVector
// 							for _, _elem42 := range _elem39.Value {
// 								_vec42 = _vec42.Conjoin(MakeInt(int(_elem42)))
// 							}
// 							_map40.Add(MakeKeyword("Value"), _vec42)
// 							_vec39 = _vec39.Conjoin(_map40)
// 						}
// 						_map9.Add(MakeKeyword("Extensions"), _vec39)
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range (*_elem8).ExtraExtensions {
// 							_map44 := EmptyArrayMap()
// 							_vec45 := EmptyVector
// 							for _, _elem45 := range _elem43.Id {
// 								_vec45 = _vec45.Conjoin(MakeInt(_elem45))
// 							}
// 							_map44.Add(MakeKeyword("Id"), _vec45)
// 							_map44.Add(MakeKeyword("Critical"), MakeBool(_elem43.Critical))
// 							_vec46 := EmptyVector
// 							for _, _elem46 := range _elem43.Value {
// 								_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 							}
// 							_map44.Add(MakeKeyword("Value"), _vec46)
// 							_vec43 = _vec43.Conjoin(_map44)
// 						}
// 						_map9.Add(MakeKeyword("ExtraExtensions"), _vec43)
// 						_vec47 := EmptyVector
// 						for _, _elem47 := range (*_elem8).UnhandledCriticalExtensions {
// 							_vec48 := EmptyVector
// 							for _, _elem48 := range _elem47 {
// 								_vec48 = _vec48.Conjoin(MakeInt(_elem48))
// 							}
// 							_vec47 = _vec47.Conjoin(_vec48)
// 						}
// 						_map9.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec47)
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range (*_elem8).ExtKeyUsage {
// 							_vec49 = _vec49.Conjoin(_elem49)
// 						}
// 						_map9.Add(MakeKeyword("ExtKeyUsage"), _vec49)
// 						_vec50 := EmptyVector
// 						for _, _elem50 := range (*_elem8).UnknownExtKeyUsage {
// 							_vec51 := EmptyVector
// 							for _, _elem51 := range _elem50 {
// 								_vec51 = _vec51.Conjoin(MakeInt(_elem51))
// 							}
// 							_vec50 = _vec50.Conjoin(_vec51)
// 						}
// 						_map9.Add(MakeKeyword("UnknownExtKeyUsage"), _vec50)
// 						_map9.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem8).BasicConstraintsValid))
// 						_map9.Add(MakeKeyword("IsCA"), MakeBool((*_elem8).IsCA))
// 						_map9.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem8).MaxPathLen))
// 						_map9.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem8).MaxPathLenZero))
// 						_vec52 := EmptyVector
// 						for _, _elem52 := range (*_elem8).SubjectKeyId {
// 							_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 						}
// 						_map9.Add(MakeKeyword("SubjectKeyId"), _vec52)
// 						_vec53 := EmptyVector
// 						for _, _elem53 := range (*_elem8).AuthorityKeyId {
// 							_vec53 = _vec53.Conjoin(MakeInt(int(_elem53)))
// 						}
// 						_map9.Add(MakeKeyword("AuthorityKeyId"), _vec53)
// 						_vec54 := EmptyVector
// 						for _, _elem54 := range (*_elem8).OCSPServer {
// 							_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 						}
// 						_map9.Add(MakeKeyword("OCSPServer"), _vec54)
// 						_vec55 := EmptyVector
// 						for _, _elem55 := range (*_elem8).IssuingCertificateURL {
// 							_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 						}
// 						_map9.Add(MakeKeyword("IssuingCertificateURL"), _vec55)
// 						_vec56 := EmptyVector
// 						for _, _elem56 := range (*_elem8).DNSNames {
// 							_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 						}
// 						_map9.Add(MakeKeyword("DNSNames"), _vec56)
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range (*_elem8).EmailAddresses {
// 							_vec57 = _vec57.Conjoin(MakeString(_elem57))
// 						}
// 						_map9.Add(MakeKeyword("EmailAddresses"), _vec57)
// 						_vec58 := EmptyVector
// 						for _, _elem58 := range (*_elem8).IPAddresses {
// 							_vec59 := EmptyVector
// 							for _, _elem59 := range _elem58 {
// 								_vec59 = _vec59.Conjoin(MakeInt(int(_elem59)))
// 							}
// 							_vec58 = _vec58.Conjoin(_vec59)
// 						}
// 						_map9.Add(MakeKeyword("IPAddresses"), _vec58)
// 						_vec60 := EmptyVector
// 						for _, _elem60 := range (*_elem8).URIs {
// 							var _obj_map61 Object
// 							if _elem60 != nil {
// 								_map61 := EmptyArrayMap()
// 								_map61.Add(MakeKeyword("Scheme"), MakeString((*_elem60).Scheme))
// 								_map61.Add(MakeKeyword("Opaque"), MakeString((*_elem60).Opaque))
// 								_map61.Add(MakeKeyword("User"), (*(*_elem60).User))
// 								_map61.Add(MakeKeyword("Host"), MakeString((*_elem60).Host))
// 								_map61.Add(MakeKeyword("Path"), MakeString((*_elem60).Path))
// 								_map61.Add(MakeKeyword("RawPath"), MakeString((*_elem60).RawPath))
// 								_map61.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem60).ForceQuery))
// 								_map61.Add(MakeKeyword("RawQuery"), MakeString((*_elem60).RawQuery))
// 								_map61.Add(MakeKeyword("Fragment"), MakeString((*_elem60).Fragment))
// 								_obj_map61 = Object(_map61)
// 							} else {
// 								_obj_map61 = NIL
// 							}
// 							_vec60 = _vec60.Conjoin(_obj_map61)
// 						}
// 						_map9.Add(MakeKeyword("URIs"), _vec60)
// 						_map9.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem8).PermittedDNSDomainsCritical))
// 						_vec62 := EmptyVector
// 						for _, _elem62 := range (*_elem8).PermittedDNSDomains {
// 							_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 						}
// 						_map9.Add(MakeKeyword("PermittedDNSDomains"), _vec62)
// 						_vec63 := EmptyVector
// 						for _, _elem63 := range (*_elem8).ExcludedDNSDomains {
// 							_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedDNSDomains"), _vec63)
// 						_vec64 := EmptyVector
// 						for _, _elem64 := range (*_elem8).PermittedIPRanges {
// 							var _obj_map65 Object
// 							if _elem64 != nil {
// 								_map65 := EmptyArrayMap()
// 								_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 								_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 								_obj_map65 = Object(_map65)
// 							} else {
// 								_obj_map65 = NIL
// 							}
// 							_vec64 = _vec64.Conjoin(_obj_map65)
// 						}
// 						_map9.Add(MakeKeyword("PermittedIPRanges"), _vec64)
// 						_vec66 := EmptyVector
// 						for _, _elem66 := range (*_elem8).ExcludedIPRanges {
// 							var _obj_map67 Object
// 							if _elem66 != nil {
// 								_map67 := EmptyArrayMap()
// 								_map67.Add(MakeKeyword("IP"), (*_elem66).IP)
// 								_map67.Add(MakeKeyword("Mask"), (*_elem66).Mask)
// 								_obj_map67 = Object(_map67)
// 							} else {
// 								_obj_map67 = NIL
// 							}
// 							_vec66 = _vec66.Conjoin(_obj_map67)
// 						}
// 						_map9.Add(MakeKeyword("ExcludedIPRanges"), _vec66)
// 						_vec68 := EmptyVector
// 						for _, _elem68 := range (*_elem8).PermittedEmailAddresses {
// 							_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 						}
// 						_map9.Add(MakeKeyword("PermittedEmailAddresses"), _vec68)
// 						_vec69 := EmptyVector
// 						for _, _elem69 := range (*_elem8).ExcludedEmailAddresses {
// 							_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedEmailAddresses"), _vec69)
// 						_vec70 := EmptyVector
// 						for _, _elem70 := range (*_elem8).PermittedURIDomains {
// 							_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 						}
// 						_map9.Add(MakeKeyword("PermittedURIDomains"), _vec70)
// 						_vec71 := EmptyVector
// 						for _, _elem71 := range (*_elem8).ExcludedURIDomains {
// 							_vec71 = _vec71.Conjoin(MakeString(_elem71))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedURIDomains"), _vec71)
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range (*_elem8).CRLDistributionPoints {
// 							_vec72 = _vec72.Conjoin(MakeString(_elem72))
// 						}
// 						_map9.Add(MakeKeyword("CRLDistributionPoints"), _vec72)
// 						_vec73 := EmptyVector
// 						for _, _elem73 := range (*_elem8).PolicyIdentifiers {
// 							_vec74 := EmptyVector
// 							for _, _elem74 := range _elem73 {
// 								_vec74 = _vec74.Conjoin(MakeInt(_elem74))
// 							}
// 							_vec73 = _vec73.Conjoin(_vec74)
// 						}
// 						_map9.Add(MakeKeyword("PolicyIdentifiers"), _vec73)
// 						_obj_map9 = Object(_map9)
// 					} else {
// 						_obj_map9 = NIL
// 					}
// 					_vec8 = _vec8.Conjoin(_obj_map9)
// 				}
// 				_map7.Add(MakeKeyword("PeerCertificates"), _vec8)
// 				_vec75 := EmptyVector
// 				for _, _elem75 := range (*(*(*resp).Request).TLS).VerifiedChains {
// 					_vec76 := EmptyVector
// 					for _, _elem76 := range _elem75 {
// 						var _obj_map77 Object
// 						if _elem76 != nil {
// 							_map77 := EmptyArrayMap()
// 							_vec78 := EmptyVector
// 							for _, _elem78 := range (*_elem76).Raw {
// 								_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 							}
// 							_map77.Add(MakeKeyword("Raw"), _vec78)
// 							_vec79 := EmptyVector
// 							for _, _elem79 := range (*_elem76).RawTBSCertificate {
// 								_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 							}
// 							_map77.Add(MakeKeyword("RawTBSCertificate"), _vec79)
// 							_vec80 := EmptyVector
// 							for _, _elem80 := range (*_elem76).RawSubjectPublicKeyInfo {
// 								_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec80)
// 							_vec81 := EmptyVector
// 							for _, _elem81 := range (*_elem76).RawSubject {
// 								_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubject"), _vec81)
// 							_vec82 := EmptyVector
// 							for _, _elem82 := range (*_elem76).RawIssuer {
// 								_vec82 = _vec82.Conjoin(MakeInt(int(_elem82)))
// 							}
// 							_map77.Add(MakeKeyword("RawIssuer"), _vec82)
// 							_vec83 := EmptyVector
// 							for _, _elem83 := range (*_elem76).Signature {
// 								_vec83 = _vec83.Conjoin(MakeInt(int(_elem83)))
// 							}
// 							_map77.Add(MakeKeyword("Signature"), _vec83)
// 							_map77.Add(MakeKeyword("SignatureAlgorithm"), (*_elem76).SignatureAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem76).PublicKeyAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKey"), (*_elem76).PublicKey)
// 							_map77.Add(MakeKeyword("Version"), MakeInt((*_elem76).Version))
// 							_map77.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map85 := EmptyArrayMap()
// 							_vec86 := EmptyVector
// 							for _, _elem86 := range (*_elem76).Issuer.Country {
// 								_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 							}
// 							_map85.Add(MakeKeyword("Country"), _vec86)
// 							_vec87 := EmptyVector
// 							for _, _elem87 := range (*_elem76).Issuer.Organization {
// 								_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 							}
// 							_map85.Add(MakeKeyword("Organization"), _vec87)
// 							_vec88 := EmptyVector
// 							for _, _elem88 := range (*_elem76).Issuer.OrganizationalUnit {
// 								_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 							}
// 							_map85.Add(MakeKeyword("OrganizationalUnit"), _vec88)
// 							_vec89 := EmptyVector
// 							for _, _elem89 := range (*_elem76).Issuer.Locality {
// 								_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 							}
// 							_map85.Add(MakeKeyword("Locality"), _vec89)
// 							_vec90 := EmptyVector
// 							for _, _elem90 := range (*_elem76).Issuer.Province {
// 								_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 							}
// 							_map85.Add(MakeKeyword("Province"), _vec90)
// 							_vec91 := EmptyVector
// 							for _, _elem91 := range (*_elem76).Issuer.StreetAddress {
// 								_vec91 = _vec91.Conjoin(MakeString(_elem91))
// 							}
// 							_map85.Add(MakeKeyword("StreetAddress"), _vec91)
// 							_vec92 := EmptyVector
// 							for _, _elem92 := range (*_elem76).Issuer.PostalCode {
// 								_vec92 = _vec92.Conjoin(MakeString(_elem92))
// 							}
// 							_map85.Add(MakeKeyword("PostalCode"), _vec92)
// 							_map85.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Issuer.SerialNumber))
// 							_map85.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Issuer.CommonName))
// 							_vec93 := EmptyVector
// 							for _, _elem93 := range (*_elem76).Issuer.Names {
// 								_vec93 = _vec93.Conjoin(_elem93)
// 							}
// 							_map85.Add(MakeKeyword("Names"), _vec93)
// 							_vec94 := EmptyVector
// 							for _, _elem94 := range (*_elem76).Issuer.ExtraNames {
// 								_vec94 = _vec94.Conjoin(_elem94)
// 							}
// 							_map85.Add(MakeKeyword("ExtraNames"), _vec94)
// 							_map77.Add(MakeKeyword("Issuer"), _map85)
// 							_map95 := EmptyArrayMap()
// 							_vec96 := EmptyVector
// 							for _, _elem96 := range (*_elem76).Subject.Country {
// 								_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 							}
// 							_map95.Add(MakeKeyword("Country"), _vec96)
// 							_vec97 := EmptyVector
// 							for _, _elem97 := range (*_elem76).Subject.Organization {
// 								_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 							}
// 							_map95.Add(MakeKeyword("Organization"), _vec97)
// 							_vec98 := EmptyVector
// 							for _, _elem98 := range (*_elem76).Subject.OrganizationalUnit {
// 								_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 							}
// 							_map95.Add(MakeKeyword("OrganizationalUnit"), _vec98)
// 							_vec99 := EmptyVector
// 							for _, _elem99 := range (*_elem76).Subject.Locality {
// 								_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 							}
// 							_map95.Add(MakeKeyword("Locality"), _vec99)
// 							_vec100 := EmptyVector
// 							for _, _elem100 := range (*_elem76).Subject.Province {
// 								_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 							}
// 							_map95.Add(MakeKeyword("Province"), _vec100)
// 							_vec101 := EmptyVector
// 							for _, _elem101 := range (*_elem76).Subject.StreetAddress {
// 								_vec101 = _vec101.Conjoin(MakeString(_elem101))
// 							}
// 							_map95.Add(MakeKeyword("StreetAddress"), _vec101)
// 							_vec102 := EmptyVector
// 							for _, _elem102 := range (*_elem76).Subject.PostalCode {
// 								_vec102 = _vec102.Conjoin(MakeString(_elem102))
// 							}
// 							_map95.Add(MakeKeyword("PostalCode"), _vec102)
// 							_map95.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Subject.SerialNumber))
// 							_map95.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Subject.CommonName))
// 							_vec103 := EmptyVector
// 							for _, _elem103 := range (*_elem76).Subject.Names {
// 								_vec103 = _vec103.Conjoin(_elem103)
// 							}
// 							_map95.Add(MakeKeyword("Names"), _vec103)
// 							_vec104 := EmptyVector
// 							for _, _elem104 := range (*_elem76).Subject.ExtraNames {
// 								_vec104 = _vec104.Conjoin(_elem104)
// 							}
// 							_map95.Add(MakeKeyword("ExtraNames"), _vec104)
// 							_map77.Add(MakeKeyword("Subject"), _map95)
// 							_map77.Add(MakeKeyword("NotBefore"), NIL)
// 							_map77.Add(MakeKeyword("NotAfter"), NIL)
// 							_map77.Add(MakeKeyword("KeyUsage"), (*_elem76).KeyUsage)
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range (*_elem76).Extensions {
// 								_map108 := EmptyArrayMap()
// 								_vec109 := EmptyVector
// 								for _, _elem109 := range _elem107.Id {
// 									_vec109 = _vec109.Conjoin(MakeInt(_elem109))
// 								}
// 								_map108.Add(MakeKeyword("Id"), _vec109)
// 								_map108.Add(MakeKeyword("Critical"), MakeBool(_elem107.Critical))
// 								_vec110 := EmptyVector
// 								for _, _elem110 := range _elem107.Value {
// 									_vec110 = _vec110.Conjoin(MakeInt(int(_elem110)))
// 								}
// 								_map108.Add(MakeKeyword("Value"), _vec110)
// 								_vec107 = _vec107.Conjoin(_map108)
// 							}
// 							_map77.Add(MakeKeyword("Extensions"), _vec107)
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range (*_elem76).ExtraExtensions {
// 								_map112 := EmptyArrayMap()
// 								_vec113 := EmptyVector
// 								for _, _elem113 := range _elem111.Id {
// 									_vec113 = _vec113.Conjoin(MakeInt(_elem113))
// 								}
// 								_map112.Add(MakeKeyword("Id"), _vec113)
// 								_map112.Add(MakeKeyword("Critical"), MakeBool(_elem111.Critical))
// 								_vec114 := EmptyVector
// 								for _, _elem114 := range _elem111.Value {
// 									_vec114 = _vec114.Conjoin(MakeInt(int(_elem114)))
// 								}
// 								_map112.Add(MakeKeyword("Value"), _vec114)
// 								_vec111 = _vec111.Conjoin(_map112)
// 							}
// 							_map77.Add(MakeKeyword("ExtraExtensions"), _vec111)
// 							_vec115 := EmptyVector
// 							for _, _elem115 := range (*_elem76).UnhandledCriticalExtensions {
// 								_vec116 := EmptyVector
// 								for _, _elem116 := range _elem115 {
// 									_vec116 = _vec116.Conjoin(MakeInt(_elem116))
// 								}
// 								_vec115 = _vec115.Conjoin(_vec116)
// 							}
// 							_map77.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec115)
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range (*_elem76).ExtKeyUsage {
// 								_vec117 = _vec117.Conjoin(_elem117)
// 							}
// 							_map77.Add(MakeKeyword("ExtKeyUsage"), _vec117)
// 							_vec118 := EmptyVector
// 							for _, _elem118 := range (*_elem76).UnknownExtKeyUsage {
// 								_vec119 := EmptyVector
// 								for _, _elem119 := range _elem118 {
// 									_vec119 = _vec119.Conjoin(MakeInt(_elem119))
// 								}
// 								_vec118 = _vec118.Conjoin(_vec119)
// 							}
// 							_map77.Add(MakeKeyword("UnknownExtKeyUsage"), _vec118)
// 							_map77.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem76).BasicConstraintsValid))
// 							_map77.Add(MakeKeyword("IsCA"), MakeBool((*_elem76).IsCA))
// 							_map77.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem76).MaxPathLen))
// 							_map77.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem76).MaxPathLenZero))
// 							_vec120 := EmptyVector
// 							for _, _elem120 := range (*_elem76).SubjectKeyId {
// 								_vec120 = _vec120.Conjoin(MakeInt(int(_elem120)))
// 							}
// 							_map77.Add(MakeKeyword("SubjectKeyId"), _vec120)
// 							_vec121 := EmptyVector
// 							for _, _elem121 := range (*_elem76).AuthorityKeyId {
// 								_vec121 = _vec121.Conjoin(MakeInt(int(_elem121)))
// 							}
// 							_map77.Add(MakeKeyword("AuthorityKeyId"), _vec121)
// 							_vec122 := EmptyVector
// 							for _, _elem122 := range (*_elem76).OCSPServer {
// 								_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 							}
// 							_map77.Add(MakeKeyword("OCSPServer"), _vec122)
// 							_vec123 := EmptyVector
// 							for _, _elem123 := range (*_elem76).IssuingCertificateURL {
// 								_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 							}
// 							_map77.Add(MakeKeyword("IssuingCertificateURL"), _vec123)
// 							_vec124 := EmptyVector
// 							for _, _elem124 := range (*_elem76).DNSNames {
// 								_vec124 = _vec124.Conjoin(MakeString(_elem124))
// 							}
// 							_map77.Add(MakeKeyword("DNSNames"), _vec124)
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range (*_elem76).EmailAddresses {
// 								_vec125 = _vec125.Conjoin(MakeString(_elem125))
// 							}
// 							_map77.Add(MakeKeyword("EmailAddresses"), _vec125)
// 							_vec126 := EmptyVector
// 							for _, _elem126 := range (*_elem76).IPAddresses {
// 								_vec127 := EmptyVector
// 								for _, _elem127 := range _elem126 {
// 									_vec127 = _vec127.Conjoin(MakeInt(int(_elem127)))
// 								}
// 								_vec126 = _vec126.Conjoin(_vec127)
// 							}
// 							_map77.Add(MakeKeyword("IPAddresses"), _vec126)
// 							_vec128 := EmptyVector
// 							for _, _elem128 := range (*_elem76).URIs {
// 								var _obj_map129 Object
// 								if _elem128 != nil {
// 									_map129 := EmptyArrayMap()
// 									_map129.Add(MakeKeyword("Scheme"), MakeString((*_elem128).Scheme))
// 									_map129.Add(MakeKeyword("Opaque"), MakeString((*_elem128).Opaque))
// 									_map129.Add(MakeKeyword("User"), (*(*_elem128).User))
// 									_map129.Add(MakeKeyword("Host"), MakeString((*_elem128).Host))
// 									_map129.Add(MakeKeyword("Path"), MakeString((*_elem128).Path))
// 									_map129.Add(MakeKeyword("RawPath"), MakeString((*_elem128).RawPath))
// 									_map129.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem128).ForceQuery))
// 									_map129.Add(MakeKeyword("RawQuery"), MakeString((*_elem128).RawQuery))
// 									_map129.Add(MakeKeyword("Fragment"), MakeString((*_elem128).Fragment))
// 									_obj_map129 = Object(_map129)
// 								} else {
// 									_obj_map129 = NIL
// 								}
// 								_vec128 = _vec128.Conjoin(_obj_map129)
// 							}
// 							_map77.Add(MakeKeyword("URIs"), _vec128)
// 							_map77.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem76).PermittedDNSDomainsCritical))
// 							_vec130 := EmptyVector
// 							for _, _elem130 := range (*_elem76).PermittedDNSDomains {
// 								_vec130 = _vec130.Conjoin(MakeString(_elem130))
// 							}
// 							_map77.Add(MakeKeyword("PermittedDNSDomains"), _vec130)
// 							_vec131 := EmptyVector
// 							for _, _elem131 := range (*_elem76).ExcludedDNSDomains {
// 								_vec131 = _vec131.Conjoin(MakeString(_elem131))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedDNSDomains"), _vec131)
// 							_vec132 := EmptyVector
// 							for _, _elem132 := range (*_elem76).PermittedIPRanges {
// 								var _obj_map133 Object
// 								if _elem132 != nil {
// 									_map133 := EmptyArrayMap()
// 									_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 									_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 									_obj_map133 = Object(_map133)
// 								} else {
// 									_obj_map133 = NIL
// 								}
// 								_vec132 = _vec132.Conjoin(_obj_map133)
// 							}
// 							_map77.Add(MakeKeyword("PermittedIPRanges"), _vec132)
// 							_vec134 := EmptyVector
// 							for _, _elem134 := range (*_elem76).ExcludedIPRanges {
// 								var _obj_map135 Object
// 								if _elem134 != nil {
// 									_map135 := EmptyArrayMap()
// 									_map135.Add(MakeKeyword("IP"), (*_elem134).IP)
// 									_map135.Add(MakeKeyword("Mask"), (*_elem134).Mask)
// 									_obj_map135 = Object(_map135)
// 								} else {
// 									_obj_map135 = NIL
// 								}
// 								_vec134 = _vec134.Conjoin(_obj_map135)
// 							}
// 							_map77.Add(MakeKeyword("ExcludedIPRanges"), _vec134)
// 							_vec136 := EmptyVector
// 							for _, _elem136 := range (*_elem76).PermittedEmailAddresses {
// 								_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 							}
// 							_map77.Add(MakeKeyword("PermittedEmailAddresses"), _vec136)
// 							_vec137 := EmptyVector
// 							for _, _elem137 := range (*_elem76).ExcludedEmailAddresses {
// 								_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedEmailAddresses"), _vec137)
// 							_vec138 := EmptyVector
// 							for _, _elem138 := range (*_elem76).PermittedURIDomains {
// 								_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 							}
// 							_map77.Add(MakeKeyword("PermittedURIDomains"), _vec138)
// 							_vec139 := EmptyVector
// 							for _, _elem139 := range (*_elem76).ExcludedURIDomains {
// 								_vec139 = _vec139.Conjoin(MakeString(_elem139))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedURIDomains"), _vec139)
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range (*_elem76).CRLDistributionPoints {
// 								_vec140 = _vec140.Conjoin(MakeString(_elem140))
// 							}
// 							_map77.Add(MakeKeyword("CRLDistributionPoints"), _vec140)
// 							_vec141 := EmptyVector
// 							for _, _elem141 := range (*_elem76).PolicyIdentifiers {
// 								_vec142 := EmptyVector
// 								for _, _elem142 := range _elem141 {
// 									_vec142 = _vec142.Conjoin(MakeInt(_elem142))
// 								}
// 								_vec141 = _vec141.Conjoin(_vec142)
// 							}
// 							_map77.Add(MakeKeyword("PolicyIdentifiers"), _vec141)
// 							_obj_map77 = Object(_map77)
// 						} else {
// 							_obj_map77 = NIL
// 						}
// 						_vec76 = _vec76.Conjoin(_obj_map77)
// 					}
// 					_vec75 = _vec75.Conjoin(_vec76)
// 				}
// 				_map7.Add(MakeKeyword("VerifiedChains"), _vec75)
// 				_vec143 := EmptyVector
// 				for _, _elem143 := range (*(*(*resp).Request).TLS).SignedCertificateTimestamps {
// 					_vec144 := EmptyVector
// 					for _, _elem144 := range _elem143 {
// 						_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 					}
// 					_vec143 = _vec143.Conjoin(_vec144)
// 				}
// 				_map7.Add(MakeKeyword("SignedCertificateTimestamps"), _vec143)
// 				_vec145 := EmptyVector
// 				for _, _elem145 := range (*(*(*resp).Request).TLS).OCSPResponse {
// 					_vec145 = _vec145.Conjoin(MakeInt(int(_elem145)))
// 				}
// 				_map7.Add(MakeKeyword("OCSPResponse"), _vec145)
// 				_vec146 := EmptyVector
// 				for _, _elem146 := range (*(*(*resp).Request).TLS).TLSUnique {
// 					_vec146 = _vec146.Conjoin(MakeInt(int(_elem146)))
// 				}
// 				_map7.Add(MakeKeyword("TLSUnique"), _vec146)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_map3.Add(MakeKeyword("TLS"), _obj_map7)
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		var _obj_map147 Object
// 		if (*resp).TLS != nil {
// 			_map147 := EmptyArrayMap()
// 			_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*resp).TLS).Version)))
// 			_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*resp).TLS).HandshakeComplete))
// 			_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*resp).TLS).DidResume))
// 			_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*resp).TLS).CipherSuite)))
// 			_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*resp).TLS).NegotiatedProtocol))
// 			_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*resp).TLS).NegotiatedProtocolIsMutual))
// 			_map147.Add(MakeKeyword("ServerName"), MakeString((*(*resp).TLS).ServerName))
// 			_vec148 := EmptyVector
// 			for _, _elem148 := range (*(*resp).TLS).PeerCertificates {
// 				var _obj_map149 Object
// 				if _elem148 != nil {
// 					_map149 := EmptyArrayMap()
// 					_vec150 := EmptyVector
// 					for _, _elem150 := range (*_elem148).Raw {
// 						_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 					}
// 					_map149.Add(MakeKeyword("Raw"), _vec150)
// 					_vec151 := EmptyVector
// 					for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 						_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 					}
// 					_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 					_vec152 := EmptyVector
// 					for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 						_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 					_vec153 := EmptyVector
// 					for _, _elem153 := range (*_elem148).RawSubject {
// 						_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 					_vec154 := EmptyVector
// 					for _, _elem154 := range (*_elem148).RawIssuer {
// 						_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 					}
// 					_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 					_vec155 := EmptyVector
// 					for _, _elem155 := range (*_elem148).Signature {
// 						_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 					}
// 					_map149.Add(MakeKeyword("Signature"), _vec155)
// 					_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 					_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 					_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map157 := EmptyArrayMap()
// 					_vec158 := EmptyVector
// 					for _, _elem158 := range (*_elem148).Issuer.Country {
// 						_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 					}
// 					_map157.Add(MakeKeyword("Country"), _vec158)
// 					_vec159 := EmptyVector
// 					for _, _elem159 := range (*_elem148).Issuer.Organization {
// 						_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 					}
// 					_map157.Add(MakeKeyword("Organization"), _vec159)
// 					_vec160 := EmptyVector
// 					for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 						_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 					}
// 					_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 					_vec161 := EmptyVector
// 					for _, _elem161 := range (*_elem148).Issuer.Locality {
// 						_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 					}
// 					_map157.Add(MakeKeyword("Locality"), _vec161)
// 					_vec162 := EmptyVector
// 					for _, _elem162 := range (*_elem148).Issuer.Province {
// 						_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 					}
// 					_map157.Add(MakeKeyword("Province"), _vec162)
// 					_vec163 := EmptyVector
// 					for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 						_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 					}
// 					_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 					_vec164 := EmptyVector
// 					for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 						_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 					}
// 					_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 					_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 					_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 					_vec165 := EmptyVector
// 					for _, _elem165 := range (*_elem148).Issuer.Names {
// 						_vec165 = _vec165.Conjoin(_elem165)
// 					}
// 					_map157.Add(MakeKeyword("Names"), _vec165)
// 					_vec166 := EmptyVector
// 					for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 						_vec166 = _vec166.Conjoin(_elem166)
// 					}
// 					_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 					_map149.Add(MakeKeyword("Issuer"), _map157)
// 					_map167 := EmptyArrayMap()
// 					_vec168 := EmptyVector
// 					for _, _elem168 := range (*_elem148).Subject.Country {
// 						_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 					}
// 					_map167.Add(MakeKeyword("Country"), _vec168)
// 					_vec169 := EmptyVector
// 					for _, _elem169 := range (*_elem148).Subject.Organization {
// 						_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 					}
// 					_map167.Add(MakeKeyword("Organization"), _vec169)
// 					_vec170 := EmptyVector
// 					for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 						_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 					}
// 					_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 					_vec171 := EmptyVector
// 					for _, _elem171 := range (*_elem148).Subject.Locality {
// 						_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 					}
// 					_map167.Add(MakeKeyword("Locality"), _vec171)
// 					_vec172 := EmptyVector
// 					for _, _elem172 := range (*_elem148).Subject.Province {
// 						_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 					}
// 					_map167.Add(MakeKeyword("Province"), _vec172)
// 					_vec173 := EmptyVector
// 					for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 						_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 					}
// 					_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 					_vec174 := EmptyVector
// 					for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 						_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 					}
// 					_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 					_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 					_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 					_vec175 := EmptyVector
// 					for _, _elem175 := range (*_elem148).Subject.Names {
// 						_vec175 = _vec175.Conjoin(_elem175)
// 					}
// 					_map167.Add(MakeKeyword("Names"), _vec175)
// 					_vec176 := EmptyVector
// 					for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 						_vec176 = _vec176.Conjoin(_elem176)
// 					}
// 					_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 					_map149.Add(MakeKeyword("Subject"), _map167)
// 					_map149.Add(MakeKeyword("NotBefore"), NIL)
// 					_map149.Add(MakeKeyword("NotAfter"), NIL)
// 					_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 					_vec179 := EmptyVector
// 					for _, _elem179 := range (*_elem148).Extensions {
// 						_map180 := EmptyArrayMap()
// 						_vec181 := EmptyVector
// 						for _, _elem181 := range _elem179.Id {
// 							_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 						}
// 						_map180.Add(MakeKeyword("Id"), _vec181)
// 						_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 						_vec182 := EmptyVector
// 						for _, _elem182 := range _elem179.Value {
// 							_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 						}
// 						_map180.Add(MakeKeyword("Value"), _vec182)
// 						_vec179 = _vec179.Conjoin(_map180)
// 					}
// 					_map149.Add(MakeKeyword("Extensions"), _vec179)
// 					_vec183 := EmptyVector
// 					for _, _elem183 := range (*_elem148).ExtraExtensions {
// 						_map184 := EmptyArrayMap()
// 						_vec185 := EmptyVector
// 						for _, _elem185 := range _elem183.Id {
// 							_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 						}
// 						_map184.Add(MakeKeyword("Id"), _vec185)
// 						_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 						_vec186 := EmptyVector
// 						for _, _elem186 := range _elem183.Value {
// 							_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 						}
// 						_map184.Add(MakeKeyword("Value"), _vec186)
// 						_vec183 = _vec183.Conjoin(_map184)
// 					}
// 					_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 					_vec187 := EmptyVector
// 					for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 						_vec188 := EmptyVector
// 						for _, _elem188 := range _elem187 {
// 							_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 						}
// 						_vec187 = _vec187.Conjoin(_vec188)
// 					}
// 					_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 					_vec189 := EmptyVector
// 					for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 						_vec189 = _vec189.Conjoin(_elem189)
// 					}
// 					_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 					_vec190 := EmptyVector
// 					for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 						_vec191 := EmptyVector
// 						for _, _elem191 := range _elem190 {
// 							_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 						}
// 						_vec190 = _vec190.Conjoin(_vec191)
// 					}
// 					_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 					_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 					_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 					_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 					_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 					_vec192 := EmptyVector
// 					for _, _elem192 := range (*_elem148).SubjectKeyId {
// 						_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 					}
// 					_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 					_vec193 := EmptyVector
// 					for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 						_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 					}
// 					_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 					_vec194 := EmptyVector
// 					for _, _elem194 := range (*_elem148).OCSPServer {
// 						_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 					}
// 					_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 					_vec195 := EmptyVector
// 					for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 						_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 					}
// 					_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 					_vec196 := EmptyVector
// 					for _, _elem196 := range (*_elem148).DNSNames {
// 						_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 					}
// 					_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 					_vec197 := EmptyVector
// 					for _, _elem197 := range (*_elem148).EmailAddresses {
// 						_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 					}
// 					_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 					_vec198 := EmptyVector
// 					for _, _elem198 := range (*_elem148).IPAddresses {
// 						_vec199 := EmptyVector
// 						for _, _elem199 := range _elem198 {
// 							_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 						}
// 						_vec198 = _vec198.Conjoin(_vec199)
// 					}
// 					_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 					_vec200 := EmptyVector
// 					for _, _elem200 := range (*_elem148).URIs {
// 						var _obj_map201 Object
// 						if _elem200 != nil {
// 							_map201 := EmptyArrayMap()
// 							_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 							_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 							_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 							_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 							_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 							_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 							_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 							_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 							_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 							_obj_map201 = Object(_map201)
// 						} else {
// 							_obj_map201 = NIL
// 						}
// 						_vec200 = _vec200.Conjoin(_obj_map201)
// 					}
// 					_map149.Add(MakeKeyword("URIs"), _vec200)
// 					_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 					_vec202 := EmptyVector
// 					for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 						_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 					}
// 					_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 					_vec203 := EmptyVector
// 					for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 						_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 					_vec204 := EmptyVector
// 					for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 						var _obj_map205 Object
// 						if _elem204 != nil {
// 							_map205 := EmptyArrayMap()
// 							_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 							_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 							_obj_map205 = Object(_map205)
// 						} else {
// 							_obj_map205 = NIL
// 						}
// 						_vec204 = _vec204.Conjoin(_obj_map205)
// 					}
// 					_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 					_vec206 := EmptyVector
// 					for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 						var _obj_map207 Object
// 						if _elem206 != nil {
// 							_map207 := EmptyArrayMap()
// 							_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 							_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 							_obj_map207 = Object(_map207)
// 						} else {
// 							_obj_map207 = NIL
// 						}
// 						_vec206 = _vec206.Conjoin(_obj_map207)
// 					}
// 					_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 					_vec208 := EmptyVector
// 					for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 						_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 					}
// 					_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 					_vec209 := EmptyVector
// 					for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 						_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 					_vec210 := EmptyVector
// 					for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 						_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 					}
// 					_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 					_vec211 := EmptyVector
// 					for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 						_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 					_vec212 := EmptyVector
// 					for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 						_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 					}
// 					_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 					_vec213 := EmptyVector
// 					for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 						_vec214 := EmptyVector
// 						for _, _elem214 := range _elem213 {
// 							_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 						}
// 						_vec213 = _vec213.Conjoin(_vec214)
// 					}
// 					_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 					_obj_map149 = Object(_map149)
// 				} else {
// 					_obj_map149 = NIL
// 				}
// 				_vec148 = _vec148.Conjoin(_obj_map149)
// 			}
// 			_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 			_vec215 := EmptyVector
// 			for _, _elem215 := range (*(*resp).TLS).VerifiedChains {
// 				_vec216 := EmptyVector
// 				for _, _elem216 := range _elem215 {
// 					var _obj_map217 Object
// 					if _elem216 != nil {
// 						_map217 := EmptyArrayMap()
// 						_vec218 := EmptyVector
// 						for _, _elem218 := range (*_elem216).Raw {
// 							_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 						}
// 						_map217.Add(MakeKeyword("Raw"), _vec218)
// 						_vec219 := EmptyVector
// 						for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 							_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 						}
// 						_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 						_vec220 := EmptyVector
// 						for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 							_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 						_vec221 := EmptyVector
// 						for _, _elem221 := range (*_elem216).RawSubject {
// 							_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 						_vec222 := EmptyVector
// 						for _, _elem222 := range (*_elem216).RawIssuer {
// 							_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 						}
// 						_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 						_vec223 := EmptyVector
// 						for _, _elem223 := range (*_elem216).Signature {
// 							_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 						}
// 						_map217.Add(MakeKeyword("Signature"), _vec223)
// 						_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 						_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 						_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map225 := EmptyArrayMap()
// 						_vec226 := EmptyVector
// 						for _, _elem226 := range (*_elem216).Issuer.Country {
// 							_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 						}
// 						_map225.Add(MakeKeyword("Country"), _vec226)
// 						_vec227 := EmptyVector
// 						for _, _elem227 := range (*_elem216).Issuer.Organization {
// 							_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 						}
// 						_map225.Add(MakeKeyword("Organization"), _vec227)
// 						_vec228 := EmptyVector
// 						for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 							_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 						}
// 						_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 						_vec229 := EmptyVector
// 						for _, _elem229 := range (*_elem216).Issuer.Locality {
// 							_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 						}
// 						_map225.Add(MakeKeyword("Locality"), _vec229)
// 						_vec230 := EmptyVector
// 						for _, _elem230 := range (*_elem216).Issuer.Province {
// 							_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 						}
// 						_map225.Add(MakeKeyword("Province"), _vec230)
// 						_vec231 := EmptyVector
// 						for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 							_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 						}
// 						_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 						_vec232 := EmptyVector
// 						for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 							_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 						}
// 						_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 						_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 						_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 						_vec233 := EmptyVector
// 						for _, _elem233 := range (*_elem216).Issuer.Names {
// 							_vec233 = _vec233.Conjoin(_elem233)
// 						}
// 						_map225.Add(MakeKeyword("Names"), _vec233)
// 						_vec234 := EmptyVector
// 						for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 							_vec234 = _vec234.Conjoin(_elem234)
// 						}
// 						_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 						_map217.Add(MakeKeyword("Issuer"), _map225)
// 						_map235 := EmptyArrayMap()
// 						_vec236 := EmptyVector
// 						for _, _elem236 := range (*_elem216).Subject.Country {
// 							_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 						}
// 						_map235.Add(MakeKeyword("Country"), _vec236)
// 						_vec237 := EmptyVector
// 						for _, _elem237 := range (*_elem216).Subject.Organization {
// 							_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 						}
// 						_map235.Add(MakeKeyword("Organization"), _vec237)
// 						_vec238 := EmptyVector
// 						for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 							_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 						}
// 						_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 						_vec239 := EmptyVector
// 						for _, _elem239 := range (*_elem216).Subject.Locality {
// 							_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 						}
// 						_map235.Add(MakeKeyword("Locality"), _vec239)
// 						_vec240 := EmptyVector
// 						for _, _elem240 := range (*_elem216).Subject.Province {
// 							_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 						}
// 						_map235.Add(MakeKeyword("Province"), _vec240)
// 						_vec241 := EmptyVector
// 						for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 							_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 						}
// 						_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 						_vec242 := EmptyVector
// 						for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 							_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 						}
// 						_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 						_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 						_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 						_vec243 := EmptyVector
// 						for _, _elem243 := range (*_elem216).Subject.Names {
// 							_vec243 = _vec243.Conjoin(_elem243)
// 						}
// 						_map235.Add(MakeKeyword("Names"), _vec243)
// 						_vec244 := EmptyVector
// 						for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 							_vec244 = _vec244.Conjoin(_elem244)
// 						}
// 						_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 						_map217.Add(MakeKeyword("Subject"), _map235)
// 						_map217.Add(MakeKeyword("NotBefore"), NIL)
// 						_map217.Add(MakeKeyword("NotAfter"), NIL)
// 						_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 						_vec247 := EmptyVector
// 						for _, _elem247 := range (*_elem216).Extensions {
// 							_map248 := EmptyArrayMap()
// 							_vec249 := EmptyVector
// 							for _, _elem249 := range _elem247.Id {
// 								_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 							}
// 							_map248.Add(MakeKeyword("Id"), _vec249)
// 							_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 							_vec250 := EmptyVector
// 							for _, _elem250 := range _elem247.Value {
// 								_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 							}
// 							_map248.Add(MakeKeyword("Value"), _vec250)
// 							_vec247 = _vec247.Conjoin(_map248)
// 						}
// 						_map217.Add(MakeKeyword("Extensions"), _vec247)
// 						_vec251 := EmptyVector
// 						for _, _elem251 := range (*_elem216).ExtraExtensions {
// 							_map252 := EmptyArrayMap()
// 							_vec253 := EmptyVector
// 							for _, _elem253 := range _elem251.Id {
// 								_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 							}
// 							_map252.Add(MakeKeyword("Id"), _vec253)
// 							_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 							_vec254 := EmptyVector
// 							for _, _elem254 := range _elem251.Value {
// 								_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 							}
// 							_map252.Add(MakeKeyword("Value"), _vec254)
// 							_vec251 = _vec251.Conjoin(_map252)
// 						}
// 						_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 						_vec255 := EmptyVector
// 						for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 							_vec256 := EmptyVector
// 							for _, _elem256 := range _elem255 {
// 								_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 							}
// 							_vec255 = _vec255.Conjoin(_vec256)
// 						}
// 						_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 						_vec257 := EmptyVector
// 						for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 							_vec257 = _vec257.Conjoin(_elem257)
// 						}
// 						_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 						_vec258 := EmptyVector
// 						for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 							_vec259 := EmptyVector
// 							for _, _elem259 := range _elem258 {
// 								_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 							}
// 							_vec258 = _vec258.Conjoin(_vec259)
// 						}
// 						_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 						_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 						_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 						_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 						_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 						_vec260 := EmptyVector
// 						for _, _elem260 := range (*_elem216).SubjectKeyId {
// 							_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 						}
// 						_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 						_vec261 := EmptyVector
// 						for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 							_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 						}
// 						_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 						_vec262 := EmptyVector
// 						for _, _elem262 := range (*_elem216).OCSPServer {
// 							_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 						}
// 						_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 						_vec263 := EmptyVector
// 						for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 							_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 						}
// 						_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 						_vec264 := EmptyVector
// 						for _, _elem264 := range (*_elem216).DNSNames {
// 							_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 						}
// 						_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 						_vec265 := EmptyVector
// 						for _, _elem265 := range (*_elem216).EmailAddresses {
// 							_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 						}
// 						_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 						_vec266 := EmptyVector
// 						for _, _elem266 := range (*_elem216).IPAddresses {
// 							_vec267 := EmptyVector
// 							for _, _elem267 := range _elem266 {
// 								_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 							}
// 							_vec266 = _vec266.Conjoin(_vec267)
// 						}
// 						_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 						_vec268 := EmptyVector
// 						for _, _elem268 := range (*_elem216).URIs {
// 							var _obj_map269 Object
// 							if _elem268 != nil {
// 								_map269 := EmptyArrayMap()
// 								_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 								_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 								_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 								_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 								_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 								_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 								_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 								_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 								_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 								_obj_map269 = Object(_map269)
// 							} else {
// 								_obj_map269 = NIL
// 							}
// 							_vec268 = _vec268.Conjoin(_obj_map269)
// 						}
// 						_map217.Add(MakeKeyword("URIs"), _vec268)
// 						_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 						_vec270 := EmptyVector
// 						for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 							_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 						}
// 						_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 						_vec271 := EmptyVector
// 						for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 							_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 						_vec272 := EmptyVector
// 						for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 							var _obj_map273 Object
// 							if _elem272 != nil {
// 								_map273 := EmptyArrayMap()
// 								_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 								_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 								_obj_map273 = Object(_map273)
// 							} else {
// 								_obj_map273 = NIL
// 							}
// 							_vec272 = _vec272.Conjoin(_obj_map273)
// 						}
// 						_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 						_vec274 := EmptyVector
// 						for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 							var _obj_map275 Object
// 							if _elem274 != nil {
// 								_map275 := EmptyArrayMap()
// 								_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 								_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 								_obj_map275 = Object(_map275)
// 							} else {
// 								_obj_map275 = NIL
// 							}
// 							_vec274 = _vec274.Conjoin(_obj_map275)
// 						}
// 						_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 						_vec276 := EmptyVector
// 						for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 							_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 						}
// 						_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 						_vec277 := EmptyVector
// 						for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 							_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 						_vec278 := EmptyVector
// 						for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 							_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 						}
// 						_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 						_vec279 := EmptyVector
// 						for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 							_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 						_vec280 := EmptyVector
// 						for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 							_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 						}
// 						_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 						_vec281 := EmptyVector
// 						for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 							_vec282 := EmptyVector
// 							for _, _elem282 := range _elem281 {
// 								_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 							}
// 							_vec281 = _vec281.Conjoin(_vec282)
// 						}
// 						_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 						_obj_map217 = Object(_map217)
// 					} else {
// 						_obj_map217 = NIL
// 					}
// 					_vec216 = _vec216.Conjoin(_obj_map217)
// 				}
// 				_vec215 = _vec215.Conjoin(_vec216)
// 			}
// 			_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 			_vec283 := EmptyVector
// 			for _, _elem283 := range (*(*resp).TLS).SignedCertificateTimestamps {
// 				_vec284 := EmptyVector
// 				for _, _elem284 := range _elem283 {
// 					_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 				}
// 				_vec283 = _vec283.Conjoin(_vec284)
// 			}
// 			_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 			_vec285 := EmptyVector
// 			for _, _elem285 := range (*(*resp).TLS).OCSPResponse {
// 				_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 			}
// 			_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 			_vec286 := EmptyVector
// 			for _, _elem286 := range (*(*resp).TLS).TLSUnique {
// 				_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 			}
// 			_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 			_obj_map147 = Object(_map147)
// 		} else {
// 			_obj_map147 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map147)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.MaxBytesReader:
// func maxBytesReader(w net/http.ResponseWriter, r io.ReadCloser, n int64) Object {
// 	return _http.MaxBytesReader(w, r, n)
// }

GO FUNC net/http.NewFileTransport:
// func newFileTransport(fs net/http.FileSystem) Object {
// 	return _http.NewFileTransport(fs)
// }

GO FUNC net/http.NewRequest:
// func newRequest(method string, url string, body io.Reader) Object {
// 	_res1, _res2 := _http.NewRequest(method, url, body)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		var _obj_map4 Object
// 		if (*_res1).MultipartForm != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Value"), (*(*_res1).MultipartForm).Value)
// 			_map4.Add(MakeKeyword("File"), (*(*_res1).MultipartForm).File)
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("MultipartForm"), _obj_map4)
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		var _obj_map5 Object
// 		if (*_res1).TLS != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("Version"), MakeInt(int((*(*_res1).TLS).Version)))
// 			_map5.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res1).TLS).HandshakeComplete))
// 			_map5.Add(MakeKeyword("DidResume"), MakeBool((*(*_res1).TLS).DidResume))
// 			_map5.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res1).TLS).CipherSuite)))
// 			_map5.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res1).TLS).NegotiatedProtocol))
// 			_map5.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res1).TLS).NegotiatedProtocolIsMutual))
// 			_map5.Add(MakeKeyword("ServerName"), MakeString((*(*_res1).TLS).ServerName))
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*(*_res1).TLS).PeerCertificates {
// 				var _obj_map7 Object
// 				if _elem6 != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*_elem6).Raw {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Raw"), _vec8)
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*_elem6).RawTBSCertificate {
// 						_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 					}
// 					_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem6).RawSubjectPublicKeyInfo {
// 						_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*_elem6).RawSubject {
// 						_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*_elem6).RawIssuer {
// 						_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 					}
// 					_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*_elem6).Signature {
// 						_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 					}
// 					_map7.Add(MakeKeyword("Signature"), _vec13)
// 					_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_elem6).SignatureAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem6).PublicKeyAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKey"), (*_elem6).PublicKey)
// 					_map7.Add(MakeKeyword("Version"), MakeInt((*_elem6).Version))
// 					_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map15 := EmptyArrayMap()
// 					_vec16 := EmptyVector
// 					for _, _elem16 := range (*_elem6).Issuer.Country {
// 						_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 					}
// 					_map15.Add(MakeKeyword("Country"), _vec16)
// 					_vec17 := EmptyVector
// 					for _, _elem17 := range (*_elem6).Issuer.Organization {
// 						_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 					}
// 					_map15.Add(MakeKeyword("Organization"), _vec17)
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*_elem6).Issuer.OrganizationalUnit {
// 						_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 					}
// 					_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 					_vec19 := EmptyVector
// 					for _, _elem19 := range (*_elem6).Issuer.Locality {
// 						_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 					}
// 					_map15.Add(MakeKeyword("Locality"), _vec19)
// 					_vec20 := EmptyVector
// 					for _, _elem20 := range (*_elem6).Issuer.Province {
// 						_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 					}
// 					_map15.Add(MakeKeyword("Province"), _vec20)
// 					_vec21 := EmptyVector
// 					for _, _elem21 := range (*_elem6).Issuer.StreetAddress {
// 						_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 					}
// 					_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 					_vec22 := EmptyVector
// 					for _, _elem22 := range (*_elem6).Issuer.PostalCode {
// 						_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 					}
// 					_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 					_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Issuer.SerialNumber))
// 					_map15.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Issuer.CommonName))
// 					_vec23 := EmptyVector
// 					for _, _elem23 := range (*_elem6).Issuer.Names {
// 						_vec23 = _vec23.Conjoin(_elem23)
// 					}
// 					_map15.Add(MakeKeyword("Names"), _vec23)
// 					_vec24 := EmptyVector
// 					for _, _elem24 := range (*_elem6).Issuer.ExtraNames {
// 						_vec24 = _vec24.Conjoin(_elem24)
// 					}
// 					_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 					_map7.Add(MakeKeyword("Issuer"), _map15)
// 					_map25 := EmptyArrayMap()
// 					_vec26 := EmptyVector
// 					for _, _elem26 := range (*_elem6).Subject.Country {
// 						_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 					}
// 					_map25.Add(MakeKeyword("Country"), _vec26)
// 					_vec27 := EmptyVector
// 					for _, _elem27 := range (*_elem6).Subject.Organization {
// 						_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 					}
// 					_map25.Add(MakeKeyword("Organization"), _vec27)
// 					_vec28 := EmptyVector
// 					for _, _elem28 := range (*_elem6).Subject.OrganizationalUnit {
// 						_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 					}
// 					_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 					_vec29 := EmptyVector
// 					for _, _elem29 := range (*_elem6).Subject.Locality {
// 						_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 					}
// 					_map25.Add(MakeKeyword("Locality"), _vec29)
// 					_vec30 := EmptyVector
// 					for _, _elem30 := range (*_elem6).Subject.Province {
// 						_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 					}
// 					_map25.Add(MakeKeyword("Province"), _vec30)
// 					_vec31 := EmptyVector
// 					for _, _elem31 := range (*_elem6).Subject.StreetAddress {
// 						_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 					}
// 					_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 					_vec32 := EmptyVector
// 					for _, _elem32 := range (*_elem6).Subject.PostalCode {
// 						_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 					}
// 					_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 					_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Subject.SerialNumber))
// 					_map25.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Subject.CommonName))
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem6).Subject.Names {
// 						_vec33 = _vec33.Conjoin(_elem33)
// 					}
// 					_map25.Add(MakeKeyword("Names"), _vec33)
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*_elem6).Subject.ExtraNames {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 					_map7.Add(MakeKeyword("Subject"), _map25)
// 					_map7.Add(MakeKeyword("NotBefore"), NIL)
// 					_map7.Add(MakeKeyword("NotAfter"), NIL)
// 					_map7.Add(MakeKeyword("KeyUsage"), (*_elem6).KeyUsage)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem6).Extensions {
// 						_map38 := EmptyArrayMap()
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range _elem37.Id {
// 							_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 						}
// 						_map38.Add(MakeKeyword("Id"), _vec39)
// 						_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range _elem37.Value {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map38.Add(MakeKeyword("Value"), _vec40)
// 						_vec37 = _vec37.Conjoin(_map38)
// 					}
// 					_map7.Add(MakeKeyword("Extensions"), _vec37)
// 					_vec41 := EmptyVector
// 					for _, _elem41 := range (*_elem6).ExtraExtensions {
// 						_map42 := EmptyArrayMap()
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range _elem41.Id {
// 							_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 						}
// 						_map42.Add(MakeKeyword("Id"), _vec43)
// 						_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 						_vec44 := EmptyVector
// 						for _, _elem44 := range _elem41.Value {
// 							_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 						}
// 						_map42.Add(MakeKeyword("Value"), _vec44)
// 						_vec41 = _vec41.Conjoin(_map42)
// 					}
// 					_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 					_vec45 := EmptyVector
// 					for _, _elem45 := range (*_elem6).UnhandledCriticalExtensions {
// 						_vec46 := EmptyVector
// 						for _, _elem46 := range _elem45 {
// 							_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 						}
// 						_vec45 = _vec45.Conjoin(_vec46)
// 					}
// 					_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 					_vec47 := EmptyVector
// 					for _, _elem47 := range (*_elem6).ExtKeyUsage {
// 						_vec47 = _vec47.Conjoin(_elem47)
// 					}
// 					_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 					_vec48 := EmptyVector
// 					for _, _elem48 := range (*_elem6).UnknownExtKeyUsage {
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range _elem48 {
// 							_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 						}
// 						_vec48 = _vec48.Conjoin(_vec49)
// 					}
// 					_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 					_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem6).BasicConstraintsValid))
// 					_map7.Add(MakeKeyword("IsCA"), MakeBool((*_elem6).IsCA))
// 					_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem6).MaxPathLen))
// 					_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem6).MaxPathLenZero))
// 					_vec50 := EmptyVector
// 					for _, _elem50 := range (*_elem6).SubjectKeyId {
// 						_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 					}
// 					_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 					_vec51 := EmptyVector
// 					for _, _elem51 := range (*_elem6).AuthorityKeyId {
// 						_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 					}
// 					_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 					_vec52 := EmptyVector
// 					for _, _elem52 := range (*_elem6).OCSPServer {
// 						_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 					}
// 					_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 					_vec53 := EmptyVector
// 					for _, _elem53 := range (*_elem6).IssuingCertificateURL {
// 						_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 					}
// 					_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 					_vec54 := EmptyVector
// 					for _, _elem54 := range (*_elem6).DNSNames {
// 						_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 					}
// 					_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 					_vec55 := EmptyVector
// 					for _, _elem55 := range (*_elem6).EmailAddresses {
// 						_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 					}
// 					_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 					_vec56 := EmptyVector
// 					for _, _elem56 := range (*_elem6).IPAddresses {
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range _elem56 {
// 							_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 						}
// 						_vec56 = _vec56.Conjoin(_vec57)
// 					}
// 					_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 					_vec58 := EmptyVector
// 					for _, _elem58 := range (*_elem6).URIs {
// 						var _obj_map59 Object
// 						if _elem58 != nil {
// 							_map59 := EmptyArrayMap()
// 							_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 							_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 							_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 							_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 							_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 							_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 							_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 							_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 							_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 							_obj_map59 = Object(_map59)
// 						} else {
// 							_obj_map59 = NIL
// 						}
// 						_vec58 = _vec58.Conjoin(_obj_map59)
// 					}
// 					_map7.Add(MakeKeyword("URIs"), _vec58)
// 					_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem6).PermittedDNSDomainsCritical))
// 					_vec60 := EmptyVector
// 					for _, _elem60 := range (*_elem6).PermittedDNSDomains {
// 						_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 					}
// 					_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 					_vec61 := EmptyVector
// 					for _, _elem61 := range (*_elem6).ExcludedDNSDomains {
// 						_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 					_vec62 := EmptyVector
// 					for _, _elem62 := range (*_elem6).PermittedIPRanges {
// 						var _obj_map63 Object
// 						if _elem62 != nil {
// 							_map63 := EmptyArrayMap()
// 							_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 							_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 							_obj_map63 = Object(_map63)
// 						} else {
// 							_obj_map63 = NIL
// 						}
// 						_vec62 = _vec62.Conjoin(_obj_map63)
// 					}
// 					_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 					_vec64 := EmptyVector
// 					for _, _elem64 := range (*_elem6).ExcludedIPRanges {
// 						var _obj_map65 Object
// 						if _elem64 != nil {
// 							_map65 := EmptyArrayMap()
// 							_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 							_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 							_obj_map65 = Object(_map65)
// 						} else {
// 							_obj_map65 = NIL
// 						}
// 						_vec64 = _vec64.Conjoin(_obj_map65)
// 					}
// 					_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 					_vec66 := EmptyVector
// 					for _, _elem66 := range (*_elem6).PermittedEmailAddresses {
// 						_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 					}
// 					_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 					_vec67 := EmptyVector
// 					for _, _elem67 := range (*_elem6).ExcludedEmailAddresses {
// 						_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 					_vec68 := EmptyVector
// 					for _, _elem68 := range (*_elem6).PermittedURIDomains {
// 						_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 					}
// 					_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 					_vec69 := EmptyVector
// 					for _, _elem69 := range (*_elem6).ExcludedURIDomains {
// 						_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 					_vec70 := EmptyVector
// 					for _, _elem70 := range (*_elem6).CRLDistributionPoints {
// 						_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 					}
// 					_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 					_vec71 := EmptyVector
// 					for _, _elem71 := range (*_elem6).PolicyIdentifiers {
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range _elem71 {
// 							_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 						}
// 						_vec71 = _vec71.Conjoin(_vec72)
// 					}
// 					_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_vec6 = _vec6.Conjoin(_obj_map7)
// 			}
// 			_map5.Add(MakeKeyword("PeerCertificates"), _vec6)
// 			_vec73 := EmptyVector
// 			for _, _elem73 := range (*(*_res1).TLS).VerifiedChains {
// 				_vec74 := EmptyVector
// 				for _, _elem74 := range _elem73 {
// 					var _obj_map75 Object
// 					if _elem74 != nil {
// 						_map75 := EmptyArrayMap()
// 						_vec76 := EmptyVector
// 						for _, _elem76 := range (*_elem74).Raw {
// 							_vec76 = _vec76.Conjoin(MakeInt(int(_elem76)))
// 						}
// 						_map75.Add(MakeKeyword("Raw"), _vec76)
// 						_vec77 := EmptyVector
// 						for _, _elem77 := range (*_elem74).RawTBSCertificate {
// 							_vec77 = _vec77.Conjoin(MakeInt(int(_elem77)))
// 						}
// 						_map75.Add(MakeKeyword("RawTBSCertificate"), _vec77)
// 						_vec78 := EmptyVector
// 						for _, _elem78 := range (*_elem74).RawSubjectPublicKeyInfo {
// 							_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec78)
// 						_vec79 := EmptyVector
// 						for _, _elem79 := range (*_elem74).RawSubject {
// 							_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubject"), _vec79)
// 						_vec80 := EmptyVector
// 						for _, _elem80 := range (*_elem74).RawIssuer {
// 							_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 						}
// 						_map75.Add(MakeKeyword("RawIssuer"), _vec80)
// 						_vec81 := EmptyVector
// 						for _, _elem81 := range (*_elem74).Signature {
// 							_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 						}
// 						_map75.Add(MakeKeyword("Signature"), _vec81)
// 						_map75.Add(MakeKeyword("SignatureAlgorithm"), (*_elem74).SignatureAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem74).PublicKeyAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKey"), (*_elem74).PublicKey)
// 						_map75.Add(MakeKeyword("Version"), MakeInt((*_elem74).Version))
// 						_map75.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map83 := EmptyArrayMap()
// 						_vec84 := EmptyVector
// 						for _, _elem84 := range (*_elem74).Issuer.Country {
// 							_vec84 = _vec84.Conjoin(MakeString(_elem84))
// 						}
// 						_map83.Add(MakeKeyword("Country"), _vec84)
// 						_vec85 := EmptyVector
// 						for _, _elem85 := range (*_elem74).Issuer.Organization {
// 							_vec85 = _vec85.Conjoin(MakeString(_elem85))
// 						}
// 						_map83.Add(MakeKeyword("Organization"), _vec85)
// 						_vec86 := EmptyVector
// 						for _, _elem86 := range (*_elem74).Issuer.OrganizationalUnit {
// 							_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 						}
// 						_map83.Add(MakeKeyword("OrganizationalUnit"), _vec86)
// 						_vec87 := EmptyVector
// 						for _, _elem87 := range (*_elem74).Issuer.Locality {
// 							_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 						}
// 						_map83.Add(MakeKeyword("Locality"), _vec87)
// 						_vec88 := EmptyVector
// 						for _, _elem88 := range (*_elem74).Issuer.Province {
// 							_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 						}
// 						_map83.Add(MakeKeyword("Province"), _vec88)
// 						_vec89 := EmptyVector
// 						for _, _elem89 := range (*_elem74).Issuer.StreetAddress {
// 							_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 						}
// 						_map83.Add(MakeKeyword("StreetAddress"), _vec89)
// 						_vec90 := EmptyVector
// 						for _, _elem90 := range (*_elem74).Issuer.PostalCode {
// 							_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 						}
// 						_map83.Add(MakeKeyword("PostalCode"), _vec90)
// 						_map83.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Issuer.SerialNumber))
// 						_map83.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Issuer.CommonName))
// 						_vec91 := EmptyVector
// 						for _, _elem91 := range (*_elem74).Issuer.Names {
// 							_vec91 = _vec91.Conjoin(_elem91)
// 						}
// 						_map83.Add(MakeKeyword("Names"), _vec91)
// 						_vec92 := EmptyVector
// 						for _, _elem92 := range (*_elem74).Issuer.ExtraNames {
// 							_vec92 = _vec92.Conjoin(_elem92)
// 						}
// 						_map83.Add(MakeKeyword("ExtraNames"), _vec92)
// 						_map75.Add(MakeKeyword("Issuer"), _map83)
// 						_map93 := EmptyArrayMap()
// 						_vec94 := EmptyVector
// 						for _, _elem94 := range (*_elem74).Subject.Country {
// 							_vec94 = _vec94.Conjoin(MakeString(_elem94))
// 						}
// 						_map93.Add(MakeKeyword("Country"), _vec94)
// 						_vec95 := EmptyVector
// 						for _, _elem95 := range (*_elem74).Subject.Organization {
// 							_vec95 = _vec95.Conjoin(MakeString(_elem95))
// 						}
// 						_map93.Add(MakeKeyword("Organization"), _vec95)
// 						_vec96 := EmptyVector
// 						for _, _elem96 := range (*_elem74).Subject.OrganizationalUnit {
// 							_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 						}
// 						_map93.Add(MakeKeyword("OrganizationalUnit"), _vec96)
// 						_vec97 := EmptyVector
// 						for _, _elem97 := range (*_elem74).Subject.Locality {
// 							_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 						}
// 						_map93.Add(MakeKeyword("Locality"), _vec97)
// 						_vec98 := EmptyVector
// 						for _, _elem98 := range (*_elem74).Subject.Province {
// 							_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 						}
// 						_map93.Add(MakeKeyword("Province"), _vec98)
// 						_vec99 := EmptyVector
// 						for _, _elem99 := range (*_elem74).Subject.StreetAddress {
// 							_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 						}
// 						_map93.Add(MakeKeyword("StreetAddress"), _vec99)
// 						_vec100 := EmptyVector
// 						for _, _elem100 := range (*_elem74).Subject.PostalCode {
// 							_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 						}
// 						_map93.Add(MakeKeyword("PostalCode"), _vec100)
// 						_map93.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Subject.SerialNumber))
// 						_map93.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Subject.CommonName))
// 						_vec101 := EmptyVector
// 						for _, _elem101 := range (*_elem74).Subject.Names {
// 							_vec101 = _vec101.Conjoin(_elem101)
// 						}
// 						_map93.Add(MakeKeyword("Names"), _vec101)
// 						_vec102 := EmptyVector
// 						for _, _elem102 := range (*_elem74).Subject.ExtraNames {
// 							_vec102 = _vec102.Conjoin(_elem102)
// 						}
// 						_map93.Add(MakeKeyword("ExtraNames"), _vec102)
// 						_map75.Add(MakeKeyword("Subject"), _map93)
// 						_map75.Add(MakeKeyword("NotBefore"), NIL)
// 						_map75.Add(MakeKeyword("NotAfter"), NIL)
// 						_map75.Add(MakeKeyword("KeyUsage"), (*_elem74).KeyUsage)
// 						_vec105 := EmptyVector
// 						for _, _elem105 := range (*_elem74).Extensions {
// 							_map106 := EmptyArrayMap()
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range _elem105.Id {
// 								_vec107 = _vec107.Conjoin(MakeInt(_elem107))
// 							}
// 							_map106.Add(MakeKeyword("Id"), _vec107)
// 							_map106.Add(MakeKeyword("Critical"), MakeBool(_elem105.Critical))
// 							_vec108 := EmptyVector
// 							for _, _elem108 := range _elem105.Value {
// 								_vec108 = _vec108.Conjoin(MakeInt(int(_elem108)))
// 							}
// 							_map106.Add(MakeKeyword("Value"), _vec108)
// 							_vec105 = _vec105.Conjoin(_map106)
// 						}
// 						_map75.Add(MakeKeyword("Extensions"), _vec105)
// 						_vec109 := EmptyVector
// 						for _, _elem109 := range (*_elem74).ExtraExtensions {
// 							_map110 := EmptyArrayMap()
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range _elem109.Id {
// 								_vec111 = _vec111.Conjoin(MakeInt(_elem111))
// 							}
// 							_map110.Add(MakeKeyword("Id"), _vec111)
// 							_map110.Add(MakeKeyword("Critical"), MakeBool(_elem109.Critical))
// 							_vec112 := EmptyVector
// 							for _, _elem112 := range _elem109.Value {
// 								_vec112 = _vec112.Conjoin(MakeInt(int(_elem112)))
// 							}
// 							_map110.Add(MakeKeyword("Value"), _vec112)
// 							_vec109 = _vec109.Conjoin(_map110)
// 						}
// 						_map75.Add(MakeKeyword("ExtraExtensions"), _vec109)
// 						_vec113 := EmptyVector
// 						for _, _elem113 := range (*_elem74).UnhandledCriticalExtensions {
// 							_vec114 := EmptyVector
// 							for _, _elem114 := range _elem113 {
// 								_vec114 = _vec114.Conjoin(MakeInt(_elem114))
// 							}
// 							_vec113 = _vec113.Conjoin(_vec114)
// 						}
// 						_map75.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec113)
// 						_vec115 := EmptyVector
// 						for _, _elem115 := range (*_elem74).ExtKeyUsage {
// 							_vec115 = _vec115.Conjoin(_elem115)
// 						}
// 						_map75.Add(MakeKeyword("ExtKeyUsage"), _vec115)
// 						_vec116 := EmptyVector
// 						for _, _elem116 := range (*_elem74).UnknownExtKeyUsage {
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range _elem116 {
// 								_vec117 = _vec117.Conjoin(MakeInt(_elem117))
// 							}
// 							_vec116 = _vec116.Conjoin(_vec117)
// 						}
// 						_map75.Add(MakeKeyword("UnknownExtKeyUsage"), _vec116)
// 						_map75.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem74).BasicConstraintsValid))
// 						_map75.Add(MakeKeyword("IsCA"), MakeBool((*_elem74).IsCA))
// 						_map75.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem74).MaxPathLen))
// 						_map75.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem74).MaxPathLenZero))
// 						_vec118 := EmptyVector
// 						for _, _elem118 := range (*_elem74).SubjectKeyId {
// 							_vec118 = _vec118.Conjoin(MakeInt(int(_elem118)))
// 						}
// 						_map75.Add(MakeKeyword("SubjectKeyId"), _vec118)
// 						_vec119 := EmptyVector
// 						for _, _elem119 := range (*_elem74).AuthorityKeyId {
// 							_vec119 = _vec119.Conjoin(MakeInt(int(_elem119)))
// 						}
// 						_map75.Add(MakeKeyword("AuthorityKeyId"), _vec119)
// 						_vec120 := EmptyVector
// 						for _, _elem120 := range (*_elem74).OCSPServer {
// 							_vec120 = _vec120.Conjoin(MakeString(_elem120))
// 						}
// 						_map75.Add(MakeKeyword("OCSPServer"), _vec120)
// 						_vec121 := EmptyVector
// 						for _, _elem121 := range (*_elem74).IssuingCertificateURL {
// 							_vec121 = _vec121.Conjoin(MakeString(_elem121))
// 						}
// 						_map75.Add(MakeKeyword("IssuingCertificateURL"), _vec121)
// 						_vec122 := EmptyVector
// 						for _, _elem122 := range (*_elem74).DNSNames {
// 							_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 						}
// 						_map75.Add(MakeKeyword("DNSNames"), _vec122)
// 						_vec123 := EmptyVector
// 						for _, _elem123 := range (*_elem74).EmailAddresses {
// 							_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 						}
// 						_map75.Add(MakeKeyword("EmailAddresses"), _vec123)
// 						_vec124 := EmptyVector
// 						for _, _elem124 := range (*_elem74).IPAddresses {
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range _elem124 {
// 								_vec125 = _vec125.Conjoin(MakeInt(int(_elem125)))
// 							}
// 							_vec124 = _vec124.Conjoin(_vec125)
// 						}
// 						_map75.Add(MakeKeyword("IPAddresses"), _vec124)
// 						_vec126 := EmptyVector
// 						for _, _elem126 := range (*_elem74).URIs {
// 							var _obj_map127 Object
// 							if _elem126 != nil {
// 								_map127 := EmptyArrayMap()
// 								_map127.Add(MakeKeyword("Scheme"), MakeString((*_elem126).Scheme))
// 								_map127.Add(MakeKeyword("Opaque"), MakeString((*_elem126).Opaque))
// 								_map127.Add(MakeKeyword("User"), (*(*_elem126).User))
// 								_map127.Add(MakeKeyword("Host"), MakeString((*_elem126).Host))
// 								_map127.Add(MakeKeyword("Path"), MakeString((*_elem126).Path))
// 								_map127.Add(MakeKeyword("RawPath"), MakeString((*_elem126).RawPath))
// 								_map127.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem126).ForceQuery))
// 								_map127.Add(MakeKeyword("RawQuery"), MakeString((*_elem126).RawQuery))
// 								_map127.Add(MakeKeyword("Fragment"), MakeString((*_elem126).Fragment))
// 								_obj_map127 = Object(_map127)
// 							} else {
// 								_obj_map127 = NIL
// 							}
// 							_vec126 = _vec126.Conjoin(_obj_map127)
// 						}
// 						_map75.Add(MakeKeyword("URIs"), _vec126)
// 						_map75.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem74).PermittedDNSDomainsCritical))
// 						_vec128 := EmptyVector
// 						for _, _elem128 := range (*_elem74).PermittedDNSDomains {
// 							_vec128 = _vec128.Conjoin(MakeString(_elem128))
// 						}
// 						_map75.Add(MakeKeyword("PermittedDNSDomains"), _vec128)
// 						_vec129 := EmptyVector
// 						for _, _elem129 := range (*_elem74).ExcludedDNSDomains {
// 							_vec129 = _vec129.Conjoin(MakeString(_elem129))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedDNSDomains"), _vec129)
// 						_vec130 := EmptyVector
// 						for _, _elem130 := range (*_elem74).PermittedIPRanges {
// 							var _obj_map131 Object
// 							if _elem130 != nil {
// 								_map131 := EmptyArrayMap()
// 								_map131.Add(MakeKeyword("IP"), (*_elem130).IP)
// 								_map131.Add(MakeKeyword("Mask"), (*_elem130).Mask)
// 								_obj_map131 = Object(_map131)
// 							} else {
// 								_obj_map131 = NIL
// 							}
// 							_vec130 = _vec130.Conjoin(_obj_map131)
// 						}
// 						_map75.Add(MakeKeyword("PermittedIPRanges"), _vec130)
// 						_vec132 := EmptyVector
// 						for _, _elem132 := range (*_elem74).ExcludedIPRanges {
// 							var _obj_map133 Object
// 							if _elem132 != nil {
// 								_map133 := EmptyArrayMap()
// 								_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 								_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 								_obj_map133 = Object(_map133)
// 							} else {
// 								_obj_map133 = NIL
// 							}
// 							_vec132 = _vec132.Conjoin(_obj_map133)
// 						}
// 						_map75.Add(MakeKeyword("ExcludedIPRanges"), _vec132)
// 						_vec134 := EmptyVector
// 						for _, _elem134 := range (*_elem74).PermittedEmailAddresses {
// 							_vec134 = _vec134.Conjoin(MakeString(_elem134))
// 						}
// 						_map75.Add(MakeKeyword("PermittedEmailAddresses"), _vec134)
// 						_vec135 := EmptyVector
// 						for _, _elem135 := range (*_elem74).ExcludedEmailAddresses {
// 							_vec135 = _vec135.Conjoin(MakeString(_elem135))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedEmailAddresses"), _vec135)
// 						_vec136 := EmptyVector
// 						for _, _elem136 := range (*_elem74).PermittedURIDomains {
// 							_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 						}
// 						_map75.Add(MakeKeyword("PermittedURIDomains"), _vec136)
// 						_vec137 := EmptyVector
// 						for _, _elem137 := range (*_elem74).ExcludedURIDomains {
// 							_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedURIDomains"), _vec137)
// 						_vec138 := EmptyVector
// 						for _, _elem138 := range (*_elem74).CRLDistributionPoints {
// 							_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 						}
// 						_map75.Add(MakeKeyword("CRLDistributionPoints"), _vec138)
// 						_vec139 := EmptyVector
// 						for _, _elem139 := range (*_elem74).PolicyIdentifiers {
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range _elem139 {
// 								_vec140 = _vec140.Conjoin(MakeInt(_elem140))
// 							}
// 							_vec139 = _vec139.Conjoin(_vec140)
// 						}
// 						_map75.Add(MakeKeyword("PolicyIdentifiers"), _vec139)
// 						_obj_map75 = Object(_map75)
// 					} else {
// 						_obj_map75 = NIL
// 					}
// 					_vec74 = _vec74.Conjoin(_obj_map75)
// 				}
// 				_vec73 = _vec73.Conjoin(_vec74)
// 			}
// 			_map5.Add(MakeKeyword("VerifiedChains"), _vec73)
// 			_vec141 := EmptyVector
// 			for _, _elem141 := range (*(*_res1).TLS).SignedCertificateTimestamps {
// 				_vec142 := EmptyVector
// 				for _, _elem142 := range _elem141 {
// 					_vec142 = _vec142.Conjoin(MakeInt(int(_elem142)))
// 				}
// 				_vec141 = _vec141.Conjoin(_vec142)
// 			}
// 			_map5.Add(MakeKeyword("SignedCertificateTimestamps"), _vec141)
// 			_vec143 := EmptyVector
// 			for _, _elem143 := range (*(*_res1).TLS).OCSPResponse {
// 				_vec143 = _vec143.Conjoin(MakeInt(int(_elem143)))
// 			}
// 			_map5.Add(MakeKeyword("OCSPResponse"), _vec143)
// 			_vec144 := EmptyVector
// 			for _, _elem144 := range (*(*_res1).TLS).TLSUnique {
// 				_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 			}
// 			_map5.Add(MakeKeyword("TLSUnique"), _vec144)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map5)
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		var _obj_map145 Object
// 		if (*_res1).Response != nil {
// 			_map145 := EmptyArrayMap()
// 			_map145.Add(MakeKeyword("Status"), MakeString((*(*_res1).Response).Status))
// 			_map145.Add(MakeKeyword("StatusCode"), MakeInt((*(*_res1).Response).StatusCode))
// 			_map145.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Response).Proto))
// 			_map145.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Response).ProtoMajor))
// 			_map145.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Response).ProtoMinor))
// 			_map145.Add(MakeKeyword("Header"), (*(*_res1).Response).Header)
// 			_map145.Add(MakeKeyword("Body"), (*(*_res1).Response).Body)
// 			_map145.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Response).ContentLength)))
// 			_vec146 := EmptyVector
// 			for _, _elem146 := range (*(*_res1).Response).TransferEncoding {
// 				_vec146 = _vec146.Conjoin(MakeString(_elem146))
// 			}
// 			_map145.Add(MakeKeyword("TransferEncoding"), _vec146)
// 			_map145.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Response).Close))
// 			_map145.Add(MakeKeyword("Uncompressed"), MakeBool((*(*_res1).Response).Uncompressed))
// 			_map145.Add(MakeKeyword("Trailer"), (*(*_res1).Response).Trailer)
// 			_map145.Add(MakeKeyword("Request"), )
// 			var _obj_map147 Object
// 			if (*(*_res1).Response).TLS != nil {
// 				_map147 := EmptyArrayMap()
// 				_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*(*_res1).Response).TLS).Version)))
// 				_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*_res1).Response).TLS).HandshakeComplete))
// 				_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*(*_res1).Response).TLS).DidResume))
// 				_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*_res1).Response).TLS).CipherSuite)))
// 				_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*_res1).Response).TLS).NegotiatedProtocol))
// 				_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*_res1).Response).TLS).NegotiatedProtocolIsMutual))
// 				_map147.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res1).Response).TLS).ServerName))
// 				_vec148 := EmptyVector
// 				for _, _elem148 := range (*(*(*_res1).Response).TLS).PeerCertificates {
// 					var _obj_map149 Object
// 					if _elem148 != nil {
// 						_map149 := EmptyArrayMap()
// 						_vec150 := EmptyVector
// 						for _, _elem150 := range (*_elem148).Raw {
// 							_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 						}
// 						_map149.Add(MakeKeyword("Raw"), _vec150)
// 						_vec151 := EmptyVector
// 						for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 							_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 						}
// 						_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 						_vec152 := EmptyVector
// 						for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 							_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 						}
// 						_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 						_vec153 := EmptyVector
// 						for _, _elem153 := range (*_elem148).RawSubject {
// 							_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 						}
// 						_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 						_vec154 := EmptyVector
// 						for _, _elem154 := range (*_elem148).RawIssuer {
// 							_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 						}
// 						_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 						_vec155 := EmptyVector
// 						for _, _elem155 := range (*_elem148).Signature {
// 							_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 						}
// 						_map149.Add(MakeKeyword("Signature"), _vec155)
// 						_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 						_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 						_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 						_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 						_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map157 := EmptyArrayMap()
// 						_vec158 := EmptyVector
// 						for _, _elem158 := range (*_elem148).Issuer.Country {
// 							_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 						}
// 						_map157.Add(MakeKeyword("Country"), _vec158)
// 						_vec159 := EmptyVector
// 						for _, _elem159 := range (*_elem148).Issuer.Organization {
// 							_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 						}
// 						_map157.Add(MakeKeyword("Organization"), _vec159)
// 						_vec160 := EmptyVector
// 						for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 							_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 						}
// 						_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 						_vec161 := EmptyVector
// 						for _, _elem161 := range (*_elem148).Issuer.Locality {
// 							_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 						}
// 						_map157.Add(MakeKeyword("Locality"), _vec161)
// 						_vec162 := EmptyVector
// 						for _, _elem162 := range (*_elem148).Issuer.Province {
// 							_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 						}
// 						_map157.Add(MakeKeyword("Province"), _vec162)
// 						_vec163 := EmptyVector
// 						for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 							_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 						}
// 						_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 						_vec164 := EmptyVector
// 						for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 							_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 						}
// 						_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 						_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 						_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 						_vec165 := EmptyVector
// 						for _, _elem165 := range (*_elem148).Issuer.Names {
// 							_vec165 = _vec165.Conjoin(_elem165)
// 						}
// 						_map157.Add(MakeKeyword("Names"), _vec165)
// 						_vec166 := EmptyVector
// 						for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 							_vec166 = _vec166.Conjoin(_elem166)
// 						}
// 						_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 						_map149.Add(MakeKeyword("Issuer"), _map157)
// 						_map167 := EmptyArrayMap()
// 						_vec168 := EmptyVector
// 						for _, _elem168 := range (*_elem148).Subject.Country {
// 							_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 						}
// 						_map167.Add(MakeKeyword("Country"), _vec168)
// 						_vec169 := EmptyVector
// 						for _, _elem169 := range (*_elem148).Subject.Organization {
// 							_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 						}
// 						_map167.Add(MakeKeyword("Organization"), _vec169)
// 						_vec170 := EmptyVector
// 						for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 							_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 						}
// 						_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 						_vec171 := EmptyVector
// 						for _, _elem171 := range (*_elem148).Subject.Locality {
// 							_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 						}
// 						_map167.Add(MakeKeyword("Locality"), _vec171)
// 						_vec172 := EmptyVector
// 						for _, _elem172 := range (*_elem148).Subject.Province {
// 							_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 						}
// 						_map167.Add(MakeKeyword("Province"), _vec172)
// 						_vec173 := EmptyVector
// 						for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 							_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 						}
// 						_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 						_vec174 := EmptyVector
// 						for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 							_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 						}
// 						_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 						_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 						_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 						_vec175 := EmptyVector
// 						for _, _elem175 := range (*_elem148).Subject.Names {
// 							_vec175 = _vec175.Conjoin(_elem175)
// 						}
// 						_map167.Add(MakeKeyword("Names"), _vec175)
// 						_vec176 := EmptyVector
// 						for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 							_vec176 = _vec176.Conjoin(_elem176)
// 						}
// 						_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 						_map149.Add(MakeKeyword("Subject"), _map167)
// 						_map149.Add(MakeKeyword("NotBefore"), NIL)
// 						_map149.Add(MakeKeyword("NotAfter"), NIL)
// 						_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 						_vec179 := EmptyVector
// 						for _, _elem179 := range (*_elem148).Extensions {
// 							_map180 := EmptyArrayMap()
// 							_vec181 := EmptyVector
// 							for _, _elem181 := range _elem179.Id {
// 								_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 							}
// 							_map180.Add(MakeKeyword("Id"), _vec181)
// 							_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 							_vec182 := EmptyVector
// 							for _, _elem182 := range _elem179.Value {
// 								_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 							}
// 							_map180.Add(MakeKeyword("Value"), _vec182)
// 							_vec179 = _vec179.Conjoin(_map180)
// 						}
// 						_map149.Add(MakeKeyword("Extensions"), _vec179)
// 						_vec183 := EmptyVector
// 						for _, _elem183 := range (*_elem148).ExtraExtensions {
// 							_map184 := EmptyArrayMap()
// 							_vec185 := EmptyVector
// 							for _, _elem185 := range _elem183.Id {
// 								_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 							}
// 							_map184.Add(MakeKeyword("Id"), _vec185)
// 							_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 							_vec186 := EmptyVector
// 							for _, _elem186 := range _elem183.Value {
// 								_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 							}
// 							_map184.Add(MakeKeyword("Value"), _vec186)
// 							_vec183 = _vec183.Conjoin(_map184)
// 						}
// 						_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 						_vec187 := EmptyVector
// 						for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 							_vec188 := EmptyVector
// 							for _, _elem188 := range _elem187 {
// 								_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 							}
// 							_vec187 = _vec187.Conjoin(_vec188)
// 						}
// 						_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 						_vec189 := EmptyVector
// 						for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 							_vec189 = _vec189.Conjoin(_elem189)
// 						}
// 						_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 						_vec190 := EmptyVector
// 						for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 							_vec191 := EmptyVector
// 							for _, _elem191 := range _elem190 {
// 								_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 							}
// 							_vec190 = _vec190.Conjoin(_vec191)
// 						}
// 						_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 						_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 						_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 						_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 						_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 						_vec192 := EmptyVector
// 						for _, _elem192 := range (*_elem148).SubjectKeyId {
// 							_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 						}
// 						_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 						_vec193 := EmptyVector
// 						for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 							_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 						}
// 						_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 						_vec194 := EmptyVector
// 						for _, _elem194 := range (*_elem148).OCSPServer {
// 							_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 						}
// 						_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 						_vec195 := EmptyVector
// 						for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 							_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 						}
// 						_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 						_vec196 := EmptyVector
// 						for _, _elem196 := range (*_elem148).DNSNames {
// 							_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 						}
// 						_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 						_vec197 := EmptyVector
// 						for _, _elem197 := range (*_elem148).EmailAddresses {
// 							_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 						}
// 						_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 						_vec198 := EmptyVector
// 						for _, _elem198 := range (*_elem148).IPAddresses {
// 							_vec199 := EmptyVector
// 							for _, _elem199 := range _elem198 {
// 								_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 							}
// 							_vec198 = _vec198.Conjoin(_vec199)
// 						}
// 						_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 						_vec200 := EmptyVector
// 						for _, _elem200 := range (*_elem148).URIs {
// 							var _obj_map201 Object
// 							if _elem200 != nil {
// 								_map201 := EmptyArrayMap()
// 								_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 								_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 								_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 								_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 								_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 								_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 								_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 								_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 								_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 								_obj_map201 = Object(_map201)
// 							} else {
// 								_obj_map201 = NIL
// 							}
// 							_vec200 = _vec200.Conjoin(_obj_map201)
// 						}
// 						_map149.Add(MakeKeyword("URIs"), _vec200)
// 						_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 						_vec202 := EmptyVector
// 						for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 							_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 						}
// 						_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 						_vec203 := EmptyVector
// 						for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 							_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 						_vec204 := EmptyVector
// 						for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 							var _obj_map205 Object
// 							if _elem204 != nil {
// 								_map205 := EmptyArrayMap()
// 								_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 								_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 								_obj_map205 = Object(_map205)
// 							} else {
// 								_obj_map205 = NIL
// 							}
// 							_vec204 = _vec204.Conjoin(_obj_map205)
// 						}
// 						_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 						_vec206 := EmptyVector
// 						for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 							var _obj_map207 Object
// 							if _elem206 != nil {
// 								_map207 := EmptyArrayMap()
// 								_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 								_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 								_obj_map207 = Object(_map207)
// 							} else {
// 								_obj_map207 = NIL
// 							}
// 							_vec206 = _vec206.Conjoin(_obj_map207)
// 						}
// 						_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 						_vec208 := EmptyVector
// 						for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 							_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 						}
// 						_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 						_vec209 := EmptyVector
// 						for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 							_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 						_vec210 := EmptyVector
// 						for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 							_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 						}
// 						_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 						_vec211 := EmptyVector
// 						for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 							_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 						_vec212 := EmptyVector
// 						for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 							_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 						}
// 						_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 						_vec213 := EmptyVector
// 						for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 							_vec214 := EmptyVector
// 							for _, _elem214 := range _elem213 {
// 								_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 							}
// 							_vec213 = _vec213.Conjoin(_vec214)
// 						}
// 						_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 						_obj_map149 = Object(_map149)
// 					} else {
// 						_obj_map149 = NIL
// 					}
// 					_vec148 = _vec148.Conjoin(_obj_map149)
// 				}
// 				_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 				_vec215 := EmptyVector
// 				for _, _elem215 := range (*(*(*_res1).Response).TLS).VerifiedChains {
// 					_vec216 := EmptyVector
// 					for _, _elem216 := range _elem215 {
// 						var _obj_map217 Object
// 						if _elem216 != nil {
// 							_map217 := EmptyArrayMap()
// 							_vec218 := EmptyVector
// 							for _, _elem218 := range (*_elem216).Raw {
// 								_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 							}
// 							_map217.Add(MakeKeyword("Raw"), _vec218)
// 							_vec219 := EmptyVector
// 							for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 								_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 							}
// 							_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 							_vec220 := EmptyVector
// 							for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 								_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 							}
// 							_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 							_vec221 := EmptyVector
// 							for _, _elem221 := range (*_elem216).RawSubject {
// 								_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 							}
// 							_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 							_vec222 := EmptyVector
// 							for _, _elem222 := range (*_elem216).RawIssuer {
// 								_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 							}
// 							_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 							_vec223 := EmptyVector
// 							for _, _elem223 := range (*_elem216).Signature {
// 								_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 							}
// 							_map217.Add(MakeKeyword("Signature"), _vec223)
// 							_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 							_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 							_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 							_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 							_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map225 := EmptyArrayMap()
// 							_vec226 := EmptyVector
// 							for _, _elem226 := range (*_elem216).Issuer.Country {
// 								_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 							}
// 							_map225.Add(MakeKeyword("Country"), _vec226)
// 							_vec227 := EmptyVector
// 							for _, _elem227 := range (*_elem216).Issuer.Organization {
// 								_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 							}
// 							_map225.Add(MakeKeyword("Organization"), _vec227)
// 							_vec228 := EmptyVector
// 							for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 								_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 							}
// 							_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 							_vec229 := EmptyVector
// 							for _, _elem229 := range (*_elem216).Issuer.Locality {
// 								_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 							}
// 							_map225.Add(MakeKeyword("Locality"), _vec229)
// 							_vec230 := EmptyVector
// 							for _, _elem230 := range (*_elem216).Issuer.Province {
// 								_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 							}
// 							_map225.Add(MakeKeyword("Province"), _vec230)
// 							_vec231 := EmptyVector
// 							for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 								_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 							}
// 							_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 							_vec232 := EmptyVector
// 							for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 								_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 							}
// 							_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 							_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 							_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 							_vec233 := EmptyVector
// 							for _, _elem233 := range (*_elem216).Issuer.Names {
// 								_vec233 = _vec233.Conjoin(_elem233)
// 							}
// 							_map225.Add(MakeKeyword("Names"), _vec233)
// 							_vec234 := EmptyVector
// 							for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 								_vec234 = _vec234.Conjoin(_elem234)
// 							}
// 							_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 							_map217.Add(MakeKeyword("Issuer"), _map225)
// 							_map235 := EmptyArrayMap()
// 							_vec236 := EmptyVector
// 							for _, _elem236 := range (*_elem216).Subject.Country {
// 								_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 							}
// 							_map235.Add(MakeKeyword("Country"), _vec236)
// 							_vec237 := EmptyVector
// 							for _, _elem237 := range (*_elem216).Subject.Organization {
// 								_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 							}
// 							_map235.Add(MakeKeyword("Organization"), _vec237)
// 							_vec238 := EmptyVector
// 							for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 								_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 							}
// 							_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 							_vec239 := EmptyVector
// 							for _, _elem239 := range (*_elem216).Subject.Locality {
// 								_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 							}
// 							_map235.Add(MakeKeyword("Locality"), _vec239)
// 							_vec240 := EmptyVector
// 							for _, _elem240 := range (*_elem216).Subject.Province {
// 								_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 							}
// 							_map235.Add(MakeKeyword("Province"), _vec240)
// 							_vec241 := EmptyVector
// 							for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 								_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 							}
// 							_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 							_vec242 := EmptyVector
// 							for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 								_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 							}
// 							_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 							_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 							_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 							_vec243 := EmptyVector
// 							for _, _elem243 := range (*_elem216).Subject.Names {
// 								_vec243 = _vec243.Conjoin(_elem243)
// 							}
// 							_map235.Add(MakeKeyword("Names"), _vec243)
// 							_vec244 := EmptyVector
// 							for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 								_vec244 = _vec244.Conjoin(_elem244)
// 							}
// 							_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 							_map217.Add(MakeKeyword("Subject"), _map235)
// 							_map217.Add(MakeKeyword("NotBefore"), NIL)
// 							_map217.Add(MakeKeyword("NotAfter"), NIL)
// 							_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 							_vec247 := EmptyVector
// 							for _, _elem247 := range (*_elem216).Extensions {
// 								_map248 := EmptyArrayMap()
// 								_vec249 := EmptyVector
// 								for _, _elem249 := range _elem247.Id {
// 									_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 								}
// 								_map248.Add(MakeKeyword("Id"), _vec249)
// 								_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 								_vec250 := EmptyVector
// 								for _, _elem250 := range _elem247.Value {
// 									_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 								}
// 								_map248.Add(MakeKeyword("Value"), _vec250)
// 								_vec247 = _vec247.Conjoin(_map248)
// 							}
// 							_map217.Add(MakeKeyword("Extensions"), _vec247)
// 							_vec251 := EmptyVector
// 							for _, _elem251 := range (*_elem216).ExtraExtensions {
// 								_map252 := EmptyArrayMap()
// 								_vec253 := EmptyVector
// 								for _, _elem253 := range _elem251.Id {
// 									_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 								}
// 								_map252.Add(MakeKeyword("Id"), _vec253)
// 								_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 								_vec254 := EmptyVector
// 								for _, _elem254 := range _elem251.Value {
// 									_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 								}
// 								_map252.Add(MakeKeyword("Value"), _vec254)
// 								_vec251 = _vec251.Conjoin(_map252)
// 							}
// 							_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 							_vec255 := EmptyVector
// 							for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 								_vec256 := EmptyVector
// 								for _, _elem256 := range _elem255 {
// 									_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 								}
// 								_vec255 = _vec255.Conjoin(_vec256)
// 							}
// 							_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 							_vec257 := EmptyVector
// 							for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 								_vec257 = _vec257.Conjoin(_elem257)
// 							}
// 							_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 							_vec258 := EmptyVector
// 							for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 								_vec259 := EmptyVector
// 								for _, _elem259 := range _elem258 {
// 									_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 								}
// 								_vec258 = _vec258.Conjoin(_vec259)
// 							}
// 							_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 							_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 							_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 							_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 							_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 							_vec260 := EmptyVector
// 							for _, _elem260 := range (*_elem216).SubjectKeyId {
// 								_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 							}
// 							_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 							_vec261 := EmptyVector
// 							for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 								_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 							}
// 							_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 							_vec262 := EmptyVector
// 							for _, _elem262 := range (*_elem216).OCSPServer {
// 								_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 							}
// 							_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 							_vec263 := EmptyVector
// 							for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 								_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 							}
// 							_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 							_vec264 := EmptyVector
// 							for _, _elem264 := range (*_elem216).DNSNames {
// 								_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 							}
// 							_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 							_vec265 := EmptyVector
// 							for _, _elem265 := range (*_elem216).EmailAddresses {
// 								_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 							}
// 							_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 							_vec266 := EmptyVector
// 							for _, _elem266 := range (*_elem216).IPAddresses {
// 								_vec267 := EmptyVector
// 								for _, _elem267 := range _elem266 {
// 									_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 								}
// 								_vec266 = _vec266.Conjoin(_vec267)
// 							}
// 							_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 							_vec268 := EmptyVector
// 							for _, _elem268 := range (*_elem216).URIs {
// 								var _obj_map269 Object
// 								if _elem268 != nil {
// 									_map269 := EmptyArrayMap()
// 									_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 									_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 									_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 									_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 									_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 									_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 									_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 									_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 									_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 									_obj_map269 = Object(_map269)
// 								} else {
// 									_obj_map269 = NIL
// 								}
// 								_vec268 = _vec268.Conjoin(_obj_map269)
// 							}
// 							_map217.Add(MakeKeyword("URIs"), _vec268)
// 							_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 							_vec270 := EmptyVector
// 							for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 								_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 							}
// 							_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 							_vec271 := EmptyVector
// 							for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 								_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 							_vec272 := EmptyVector
// 							for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 								var _obj_map273 Object
// 								if _elem272 != nil {
// 									_map273 := EmptyArrayMap()
// 									_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 									_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 									_obj_map273 = Object(_map273)
// 								} else {
// 									_obj_map273 = NIL
// 								}
// 								_vec272 = _vec272.Conjoin(_obj_map273)
// 							}
// 							_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 							_vec274 := EmptyVector
// 							for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 								var _obj_map275 Object
// 								if _elem274 != nil {
// 									_map275 := EmptyArrayMap()
// 									_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 									_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 									_obj_map275 = Object(_map275)
// 								} else {
// 									_obj_map275 = NIL
// 								}
// 								_vec274 = _vec274.Conjoin(_obj_map275)
// 							}
// 							_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 							_vec276 := EmptyVector
// 							for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 								_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 							}
// 							_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 							_vec277 := EmptyVector
// 							for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 								_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 							_vec278 := EmptyVector
// 							for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 								_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 							}
// 							_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 							_vec279 := EmptyVector
// 							for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 								_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 							_vec280 := EmptyVector
// 							for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 								_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 							}
// 							_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 							_vec281 := EmptyVector
// 							for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 								_vec282 := EmptyVector
// 								for _, _elem282 := range _elem281 {
// 									_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 								}
// 								_vec281 = _vec281.Conjoin(_vec282)
// 							}
// 							_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 							_obj_map217 = Object(_map217)
// 						} else {
// 							_obj_map217 = NIL
// 						}
// 						_vec216 = _vec216.Conjoin(_obj_map217)
// 					}
// 					_vec215 = _vec215.Conjoin(_vec216)
// 				}
// 				_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 				_vec283 := EmptyVector
// 				for _, _elem283 := range (*(*(*_res1).Response).TLS).SignedCertificateTimestamps {
// 					_vec284 := EmptyVector
// 					for _, _elem284 := range _elem283 {
// 						_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 					}
// 					_vec283 = _vec283.Conjoin(_vec284)
// 				}
// 				_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 				_vec285 := EmptyVector
// 				for _, _elem285 := range (*(*(*_res1).Response).TLS).OCSPResponse {
// 					_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 				}
// 				_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 				_vec286 := EmptyVector
// 				for _, _elem286 := range (*(*(*_res1).Response).TLS).TLSUnique {
// 					_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 				}
// 				_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 				_obj_map147 = Object(_map147)
// 			} else {
// 				_obj_map147 = NIL
// 			}
// 			_map145.Add(MakeKeyword("TLS"), _obj_map147)
// 			_obj_map145 = Object(_map145)
// 		} else {
// 			_obj_map145 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Response"), _obj_map145)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.NewServeMux:
// func newServeMux() Object {
// 	return _http.NewServeMux()
// 	ABEND124(no public information returned)
// }

GO FUNC net/http.NotFound:
// func notFound(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_http.NotFound(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.NotFoundHandler:
// func notFoundHandler() Object {
// 	return _http.NotFoundHandler()
// }

GO FUNC net/http.ParseHTTPVersion:
func parseHTTPVersion(vers string) Object {
	major, minor, ok := _http.ParseHTTPVersion(vers)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(major))
	_res = _res.Conjoin(MakeInt(minor))
	_res = _res.Conjoin(MakeBool(ok))
	return _res
}

GO FUNC net/http.ParseTime:
func parseTime(text string) Object {
	_, err := _http.ParseTime(text)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC net/http.Post:
// func post(url string, contentType string, body io.Reader) Object {
// 	resp, err := _http.Post(url, contentType, body)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			var _obj_map6 Object
// 			if (*(*resp).Request).MultipartForm != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Value"), (*(*(*resp).Request).MultipartForm).Value)
// 				_map6.Add(MakeKeyword("File"), (*(*(*resp).Request).MultipartForm).File)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map3.Add(MakeKeyword("MultipartForm"), _obj_map6)
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			var _obj_map7 Object
// 			if (*(*resp).Request).TLS != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Version"), MakeInt(int((*(*(*resp).Request).TLS).Version)))
// 				_map7.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*resp).Request).TLS).HandshakeComplete))
// 				_map7.Add(MakeKeyword("DidResume"), MakeBool((*(*(*resp).Request).TLS).DidResume))
// 				_map7.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*resp).Request).TLS).CipherSuite)))
// 				_map7.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*resp).Request).TLS).NegotiatedProtocol))
// 				_map7.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*resp).Request).TLS).NegotiatedProtocolIsMutual))
// 				_map7.Add(MakeKeyword("ServerName"), MakeString((*(*(*resp).Request).TLS).ServerName))
// 				_vec8 := EmptyVector
// 				for _, _elem8 := range (*(*(*resp).Request).TLS).PeerCertificates {
// 					var _obj_map9 Object
// 					if _elem8 != nil {
// 						_map9 := EmptyArrayMap()
// 						_vec10 := EmptyVector
// 						for _, _elem10 := range (*_elem8).Raw {
// 							_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 						}
// 						_map9.Add(MakeKeyword("Raw"), _vec10)
// 						_vec11 := EmptyVector
// 						for _, _elem11 := range (*_elem8).RawTBSCertificate {
// 							_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 						}
// 						_map9.Add(MakeKeyword("RawTBSCertificate"), _vec11)
// 						_vec12 := EmptyVector
// 						for _, _elem12 := range (*_elem8).RawSubjectPublicKeyInfo {
// 							_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec12)
// 						_vec13 := EmptyVector
// 						for _, _elem13 := range (*_elem8).RawSubject {
// 							_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubject"), _vec13)
// 						_vec14 := EmptyVector
// 						for _, _elem14 := range (*_elem8).RawIssuer {
// 							_vec14 = _vec14.Conjoin(MakeInt(int(_elem14)))
// 						}
// 						_map9.Add(MakeKeyword("RawIssuer"), _vec14)
// 						_vec15 := EmptyVector
// 						for _, _elem15 := range (*_elem8).Signature {
// 							_vec15 = _vec15.Conjoin(MakeInt(int(_elem15)))
// 						}
// 						_map9.Add(MakeKeyword("Signature"), _vec15)
// 						_map9.Add(MakeKeyword("SignatureAlgorithm"), (*_elem8).SignatureAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem8).PublicKeyAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKey"), (*_elem8).PublicKey)
// 						_map9.Add(MakeKeyword("Version"), MakeInt((*_elem8).Version))
// 						_map9.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map17 := EmptyArrayMap()
// 						_vec18 := EmptyVector
// 						for _, _elem18 := range (*_elem8).Issuer.Country {
// 							_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 						}
// 						_map17.Add(MakeKeyword("Country"), _vec18)
// 						_vec19 := EmptyVector
// 						for _, _elem19 := range (*_elem8).Issuer.Organization {
// 							_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 						}
// 						_map17.Add(MakeKeyword("Organization"), _vec19)
// 						_vec20 := EmptyVector
// 						for _, _elem20 := range (*_elem8).Issuer.OrganizationalUnit {
// 							_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 						}
// 						_map17.Add(MakeKeyword("OrganizationalUnit"), _vec20)
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem8).Issuer.Locality {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map17.Add(MakeKeyword("Locality"), _vec21)
// 						_vec22 := EmptyVector
// 						for _, _elem22 := range (*_elem8).Issuer.Province {
// 							_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 						}
// 						_map17.Add(MakeKeyword("Province"), _vec22)
// 						_vec23 := EmptyVector
// 						for _, _elem23 := range (*_elem8).Issuer.StreetAddress {
// 							_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 						}
// 						_map17.Add(MakeKeyword("StreetAddress"), _vec23)
// 						_vec24 := EmptyVector
// 						for _, _elem24 := range (*_elem8).Issuer.PostalCode {
// 							_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 						}
// 						_map17.Add(MakeKeyword("PostalCode"), _vec24)
// 						_map17.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Issuer.SerialNumber))
// 						_map17.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Issuer.CommonName))
// 						_vec25 := EmptyVector
// 						for _, _elem25 := range (*_elem8).Issuer.Names {
// 							_vec25 = _vec25.Conjoin(_elem25)
// 						}
// 						_map17.Add(MakeKeyword("Names"), _vec25)
// 						_vec26 := EmptyVector
// 						for _, _elem26 := range (*_elem8).Issuer.ExtraNames {
// 							_vec26 = _vec26.Conjoin(_elem26)
// 						}
// 						_map17.Add(MakeKeyword("ExtraNames"), _vec26)
// 						_map9.Add(MakeKeyword("Issuer"), _map17)
// 						_map27 := EmptyArrayMap()
// 						_vec28 := EmptyVector
// 						for _, _elem28 := range (*_elem8).Subject.Country {
// 							_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 						}
// 						_map27.Add(MakeKeyword("Country"), _vec28)
// 						_vec29 := EmptyVector
// 						for _, _elem29 := range (*_elem8).Subject.Organization {
// 							_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 						}
// 						_map27.Add(MakeKeyword("Organization"), _vec29)
// 						_vec30 := EmptyVector
// 						for _, _elem30 := range (*_elem8).Subject.OrganizationalUnit {
// 							_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 						}
// 						_map27.Add(MakeKeyword("OrganizationalUnit"), _vec30)
// 						_vec31 := EmptyVector
// 						for _, _elem31 := range (*_elem8).Subject.Locality {
// 							_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 						}
// 						_map27.Add(MakeKeyword("Locality"), _vec31)
// 						_vec32 := EmptyVector
// 						for _, _elem32 := range (*_elem8).Subject.Province {
// 							_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 						}
// 						_map27.Add(MakeKeyword("Province"), _vec32)
// 						_vec33 := EmptyVector
// 						for _, _elem33 := range (*_elem8).Subject.StreetAddress {
// 							_vec33 = _vec33.Conjoin(MakeString(_elem33))
// 						}
// 						_map27.Add(MakeKeyword("StreetAddress"), _vec33)
// 						_vec34 := EmptyVector
// 						for _, _elem34 := range (*_elem8).Subject.PostalCode {
// 							_vec34 = _vec34.Conjoin(MakeString(_elem34))
// 						}
// 						_map27.Add(MakeKeyword("PostalCode"), _vec34)
// 						_map27.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Subject.SerialNumber))
// 						_map27.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Subject.CommonName))
// 						_vec35 := EmptyVector
// 						for _, _elem35 := range (*_elem8).Subject.Names {
// 							_vec35 = _vec35.Conjoin(_elem35)
// 						}
// 						_map27.Add(MakeKeyword("Names"), _vec35)
// 						_vec36 := EmptyVector
// 						for _, _elem36 := range (*_elem8).Subject.ExtraNames {
// 							_vec36 = _vec36.Conjoin(_elem36)
// 						}
// 						_map27.Add(MakeKeyword("ExtraNames"), _vec36)
// 						_map9.Add(MakeKeyword("Subject"), _map27)
// 						_map9.Add(MakeKeyword("NotBefore"), NIL)
// 						_map9.Add(MakeKeyword("NotAfter"), NIL)
// 						_map9.Add(MakeKeyword("KeyUsage"), (*_elem8).KeyUsage)
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range (*_elem8).Extensions {
// 							_map40 := EmptyArrayMap()
// 							_vec41 := EmptyVector
// 							for _, _elem41 := range _elem39.Id {
// 								_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 							}
// 							_map40.Add(MakeKeyword("Id"), _vec41)
// 							_map40.Add(MakeKeyword("Critical"), MakeBool(_elem39.Critical))
// 							_vec42 := EmptyVector
// 							for _, _elem42 := range _elem39.Value {
// 								_vec42 = _vec42.Conjoin(MakeInt(int(_elem42)))
// 							}
// 							_map40.Add(MakeKeyword("Value"), _vec42)
// 							_vec39 = _vec39.Conjoin(_map40)
// 						}
// 						_map9.Add(MakeKeyword("Extensions"), _vec39)
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range (*_elem8).ExtraExtensions {
// 							_map44 := EmptyArrayMap()
// 							_vec45 := EmptyVector
// 							for _, _elem45 := range _elem43.Id {
// 								_vec45 = _vec45.Conjoin(MakeInt(_elem45))
// 							}
// 							_map44.Add(MakeKeyword("Id"), _vec45)
// 							_map44.Add(MakeKeyword("Critical"), MakeBool(_elem43.Critical))
// 							_vec46 := EmptyVector
// 							for _, _elem46 := range _elem43.Value {
// 								_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 							}
// 							_map44.Add(MakeKeyword("Value"), _vec46)
// 							_vec43 = _vec43.Conjoin(_map44)
// 						}
// 						_map9.Add(MakeKeyword("ExtraExtensions"), _vec43)
// 						_vec47 := EmptyVector
// 						for _, _elem47 := range (*_elem8).UnhandledCriticalExtensions {
// 							_vec48 := EmptyVector
// 							for _, _elem48 := range _elem47 {
// 								_vec48 = _vec48.Conjoin(MakeInt(_elem48))
// 							}
// 							_vec47 = _vec47.Conjoin(_vec48)
// 						}
// 						_map9.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec47)
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range (*_elem8).ExtKeyUsage {
// 							_vec49 = _vec49.Conjoin(_elem49)
// 						}
// 						_map9.Add(MakeKeyword("ExtKeyUsage"), _vec49)
// 						_vec50 := EmptyVector
// 						for _, _elem50 := range (*_elem8).UnknownExtKeyUsage {
// 							_vec51 := EmptyVector
// 							for _, _elem51 := range _elem50 {
// 								_vec51 = _vec51.Conjoin(MakeInt(_elem51))
// 							}
// 							_vec50 = _vec50.Conjoin(_vec51)
// 						}
// 						_map9.Add(MakeKeyword("UnknownExtKeyUsage"), _vec50)
// 						_map9.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem8).BasicConstraintsValid))
// 						_map9.Add(MakeKeyword("IsCA"), MakeBool((*_elem8).IsCA))
// 						_map9.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem8).MaxPathLen))
// 						_map9.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem8).MaxPathLenZero))
// 						_vec52 := EmptyVector
// 						for _, _elem52 := range (*_elem8).SubjectKeyId {
// 							_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 						}
// 						_map9.Add(MakeKeyword("SubjectKeyId"), _vec52)
// 						_vec53 := EmptyVector
// 						for _, _elem53 := range (*_elem8).AuthorityKeyId {
// 							_vec53 = _vec53.Conjoin(MakeInt(int(_elem53)))
// 						}
// 						_map9.Add(MakeKeyword("AuthorityKeyId"), _vec53)
// 						_vec54 := EmptyVector
// 						for _, _elem54 := range (*_elem8).OCSPServer {
// 							_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 						}
// 						_map9.Add(MakeKeyword("OCSPServer"), _vec54)
// 						_vec55 := EmptyVector
// 						for _, _elem55 := range (*_elem8).IssuingCertificateURL {
// 							_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 						}
// 						_map9.Add(MakeKeyword("IssuingCertificateURL"), _vec55)
// 						_vec56 := EmptyVector
// 						for _, _elem56 := range (*_elem8).DNSNames {
// 							_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 						}
// 						_map9.Add(MakeKeyword("DNSNames"), _vec56)
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range (*_elem8).EmailAddresses {
// 							_vec57 = _vec57.Conjoin(MakeString(_elem57))
// 						}
// 						_map9.Add(MakeKeyword("EmailAddresses"), _vec57)
// 						_vec58 := EmptyVector
// 						for _, _elem58 := range (*_elem8).IPAddresses {
// 							_vec59 := EmptyVector
// 							for _, _elem59 := range _elem58 {
// 								_vec59 = _vec59.Conjoin(MakeInt(int(_elem59)))
// 							}
// 							_vec58 = _vec58.Conjoin(_vec59)
// 						}
// 						_map9.Add(MakeKeyword("IPAddresses"), _vec58)
// 						_vec60 := EmptyVector
// 						for _, _elem60 := range (*_elem8).URIs {
// 							var _obj_map61 Object
// 							if _elem60 != nil {
// 								_map61 := EmptyArrayMap()
// 								_map61.Add(MakeKeyword("Scheme"), MakeString((*_elem60).Scheme))
// 								_map61.Add(MakeKeyword("Opaque"), MakeString((*_elem60).Opaque))
// 								_map61.Add(MakeKeyword("User"), (*(*_elem60).User))
// 								_map61.Add(MakeKeyword("Host"), MakeString((*_elem60).Host))
// 								_map61.Add(MakeKeyword("Path"), MakeString((*_elem60).Path))
// 								_map61.Add(MakeKeyword("RawPath"), MakeString((*_elem60).RawPath))
// 								_map61.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem60).ForceQuery))
// 								_map61.Add(MakeKeyword("RawQuery"), MakeString((*_elem60).RawQuery))
// 								_map61.Add(MakeKeyword("Fragment"), MakeString((*_elem60).Fragment))
// 								_obj_map61 = Object(_map61)
// 							} else {
// 								_obj_map61 = NIL
// 							}
// 							_vec60 = _vec60.Conjoin(_obj_map61)
// 						}
// 						_map9.Add(MakeKeyword("URIs"), _vec60)
// 						_map9.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem8).PermittedDNSDomainsCritical))
// 						_vec62 := EmptyVector
// 						for _, _elem62 := range (*_elem8).PermittedDNSDomains {
// 							_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 						}
// 						_map9.Add(MakeKeyword("PermittedDNSDomains"), _vec62)
// 						_vec63 := EmptyVector
// 						for _, _elem63 := range (*_elem8).ExcludedDNSDomains {
// 							_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedDNSDomains"), _vec63)
// 						_vec64 := EmptyVector
// 						for _, _elem64 := range (*_elem8).PermittedIPRanges {
// 							var _obj_map65 Object
// 							if _elem64 != nil {
// 								_map65 := EmptyArrayMap()
// 								_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 								_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 								_obj_map65 = Object(_map65)
// 							} else {
// 								_obj_map65 = NIL
// 							}
// 							_vec64 = _vec64.Conjoin(_obj_map65)
// 						}
// 						_map9.Add(MakeKeyword("PermittedIPRanges"), _vec64)
// 						_vec66 := EmptyVector
// 						for _, _elem66 := range (*_elem8).ExcludedIPRanges {
// 							var _obj_map67 Object
// 							if _elem66 != nil {
// 								_map67 := EmptyArrayMap()
// 								_map67.Add(MakeKeyword("IP"), (*_elem66).IP)
// 								_map67.Add(MakeKeyword("Mask"), (*_elem66).Mask)
// 								_obj_map67 = Object(_map67)
// 							} else {
// 								_obj_map67 = NIL
// 							}
// 							_vec66 = _vec66.Conjoin(_obj_map67)
// 						}
// 						_map9.Add(MakeKeyword("ExcludedIPRanges"), _vec66)
// 						_vec68 := EmptyVector
// 						for _, _elem68 := range (*_elem8).PermittedEmailAddresses {
// 							_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 						}
// 						_map9.Add(MakeKeyword("PermittedEmailAddresses"), _vec68)
// 						_vec69 := EmptyVector
// 						for _, _elem69 := range (*_elem8).ExcludedEmailAddresses {
// 							_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedEmailAddresses"), _vec69)
// 						_vec70 := EmptyVector
// 						for _, _elem70 := range (*_elem8).PermittedURIDomains {
// 							_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 						}
// 						_map9.Add(MakeKeyword("PermittedURIDomains"), _vec70)
// 						_vec71 := EmptyVector
// 						for _, _elem71 := range (*_elem8).ExcludedURIDomains {
// 							_vec71 = _vec71.Conjoin(MakeString(_elem71))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedURIDomains"), _vec71)
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range (*_elem8).CRLDistributionPoints {
// 							_vec72 = _vec72.Conjoin(MakeString(_elem72))
// 						}
// 						_map9.Add(MakeKeyword("CRLDistributionPoints"), _vec72)
// 						_vec73 := EmptyVector
// 						for _, _elem73 := range (*_elem8).PolicyIdentifiers {
// 							_vec74 := EmptyVector
// 							for _, _elem74 := range _elem73 {
// 								_vec74 = _vec74.Conjoin(MakeInt(_elem74))
// 							}
// 							_vec73 = _vec73.Conjoin(_vec74)
// 						}
// 						_map9.Add(MakeKeyword("PolicyIdentifiers"), _vec73)
// 						_obj_map9 = Object(_map9)
// 					} else {
// 						_obj_map9 = NIL
// 					}
// 					_vec8 = _vec8.Conjoin(_obj_map9)
// 				}
// 				_map7.Add(MakeKeyword("PeerCertificates"), _vec8)
// 				_vec75 := EmptyVector
// 				for _, _elem75 := range (*(*(*resp).Request).TLS).VerifiedChains {
// 					_vec76 := EmptyVector
// 					for _, _elem76 := range _elem75 {
// 						var _obj_map77 Object
// 						if _elem76 != nil {
// 							_map77 := EmptyArrayMap()
// 							_vec78 := EmptyVector
// 							for _, _elem78 := range (*_elem76).Raw {
// 								_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 							}
// 							_map77.Add(MakeKeyword("Raw"), _vec78)
// 							_vec79 := EmptyVector
// 							for _, _elem79 := range (*_elem76).RawTBSCertificate {
// 								_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 							}
// 							_map77.Add(MakeKeyword("RawTBSCertificate"), _vec79)
// 							_vec80 := EmptyVector
// 							for _, _elem80 := range (*_elem76).RawSubjectPublicKeyInfo {
// 								_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec80)
// 							_vec81 := EmptyVector
// 							for _, _elem81 := range (*_elem76).RawSubject {
// 								_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubject"), _vec81)
// 							_vec82 := EmptyVector
// 							for _, _elem82 := range (*_elem76).RawIssuer {
// 								_vec82 = _vec82.Conjoin(MakeInt(int(_elem82)))
// 							}
// 							_map77.Add(MakeKeyword("RawIssuer"), _vec82)
// 							_vec83 := EmptyVector
// 							for _, _elem83 := range (*_elem76).Signature {
// 								_vec83 = _vec83.Conjoin(MakeInt(int(_elem83)))
// 							}
// 							_map77.Add(MakeKeyword("Signature"), _vec83)
// 							_map77.Add(MakeKeyword("SignatureAlgorithm"), (*_elem76).SignatureAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem76).PublicKeyAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKey"), (*_elem76).PublicKey)
// 							_map77.Add(MakeKeyword("Version"), MakeInt((*_elem76).Version))
// 							_map77.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map85 := EmptyArrayMap()
// 							_vec86 := EmptyVector
// 							for _, _elem86 := range (*_elem76).Issuer.Country {
// 								_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 							}
// 							_map85.Add(MakeKeyword("Country"), _vec86)
// 							_vec87 := EmptyVector
// 							for _, _elem87 := range (*_elem76).Issuer.Organization {
// 								_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 							}
// 							_map85.Add(MakeKeyword("Organization"), _vec87)
// 							_vec88 := EmptyVector
// 							for _, _elem88 := range (*_elem76).Issuer.OrganizationalUnit {
// 								_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 							}
// 							_map85.Add(MakeKeyword("OrganizationalUnit"), _vec88)
// 							_vec89 := EmptyVector
// 							for _, _elem89 := range (*_elem76).Issuer.Locality {
// 								_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 							}
// 							_map85.Add(MakeKeyword("Locality"), _vec89)
// 							_vec90 := EmptyVector
// 							for _, _elem90 := range (*_elem76).Issuer.Province {
// 								_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 							}
// 							_map85.Add(MakeKeyword("Province"), _vec90)
// 							_vec91 := EmptyVector
// 							for _, _elem91 := range (*_elem76).Issuer.StreetAddress {
// 								_vec91 = _vec91.Conjoin(MakeString(_elem91))
// 							}
// 							_map85.Add(MakeKeyword("StreetAddress"), _vec91)
// 							_vec92 := EmptyVector
// 							for _, _elem92 := range (*_elem76).Issuer.PostalCode {
// 								_vec92 = _vec92.Conjoin(MakeString(_elem92))
// 							}
// 							_map85.Add(MakeKeyword("PostalCode"), _vec92)
// 							_map85.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Issuer.SerialNumber))
// 							_map85.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Issuer.CommonName))
// 							_vec93 := EmptyVector
// 							for _, _elem93 := range (*_elem76).Issuer.Names {
// 								_vec93 = _vec93.Conjoin(_elem93)
// 							}
// 							_map85.Add(MakeKeyword("Names"), _vec93)
// 							_vec94 := EmptyVector
// 							for _, _elem94 := range (*_elem76).Issuer.ExtraNames {
// 								_vec94 = _vec94.Conjoin(_elem94)
// 							}
// 							_map85.Add(MakeKeyword("ExtraNames"), _vec94)
// 							_map77.Add(MakeKeyword("Issuer"), _map85)
// 							_map95 := EmptyArrayMap()
// 							_vec96 := EmptyVector
// 							for _, _elem96 := range (*_elem76).Subject.Country {
// 								_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 							}
// 							_map95.Add(MakeKeyword("Country"), _vec96)
// 							_vec97 := EmptyVector
// 							for _, _elem97 := range (*_elem76).Subject.Organization {
// 								_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 							}
// 							_map95.Add(MakeKeyword("Organization"), _vec97)
// 							_vec98 := EmptyVector
// 							for _, _elem98 := range (*_elem76).Subject.OrganizationalUnit {
// 								_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 							}
// 							_map95.Add(MakeKeyword("OrganizationalUnit"), _vec98)
// 							_vec99 := EmptyVector
// 							for _, _elem99 := range (*_elem76).Subject.Locality {
// 								_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 							}
// 							_map95.Add(MakeKeyword("Locality"), _vec99)
// 							_vec100 := EmptyVector
// 							for _, _elem100 := range (*_elem76).Subject.Province {
// 								_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 							}
// 							_map95.Add(MakeKeyword("Province"), _vec100)
// 							_vec101 := EmptyVector
// 							for _, _elem101 := range (*_elem76).Subject.StreetAddress {
// 								_vec101 = _vec101.Conjoin(MakeString(_elem101))
// 							}
// 							_map95.Add(MakeKeyword("StreetAddress"), _vec101)
// 							_vec102 := EmptyVector
// 							for _, _elem102 := range (*_elem76).Subject.PostalCode {
// 								_vec102 = _vec102.Conjoin(MakeString(_elem102))
// 							}
// 							_map95.Add(MakeKeyword("PostalCode"), _vec102)
// 							_map95.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Subject.SerialNumber))
// 							_map95.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Subject.CommonName))
// 							_vec103 := EmptyVector
// 							for _, _elem103 := range (*_elem76).Subject.Names {
// 								_vec103 = _vec103.Conjoin(_elem103)
// 							}
// 							_map95.Add(MakeKeyword("Names"), _vec103)
// 							_vec104 := EmptyVector
// 							for _, _elem104 := range (*_elem76).Subject.ExtraNames {
// 								_vec104 = _vec104.Conjoin(_elem104)
// 							}
// 							_map95.Add(MakeKeyword("ExtraNames"), _vec104)
// 							_map77.Add(MakeKeyword("Subject"), _map95)
// 							_map77.Add(MakeKeyword("NotBefore"), NIL)
// 							_map77.Add(MakeKeyword("NotAfter"), NIL)
// 							_map77.Add(MakeKeyword("KeyUsage"), (*_elem76).KeyUsage)
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range (*_elem76).Extensions {
// 								_map108 := EmptyArrayMap()
// 								_vec109 := EmptyVector
// 								for _, _elem109 := range _elem107.Id {
// 									_vec109 = _vec109.Conjoin(MakeInt(_elem109))
// 								}
// 								_map108.Add(MakeKeyword("Id"), _vec109)
// 								_map108.Add(MakeKeyword("Critical"), MakeBool(_elem107.Critical))
// 								_vec110 := EmptyVector
// 								for _, _elem110 := range _elem107.Value {
// 									_vec110 = _vec110.Conjoin(MakeInt(int(_elem110)))
// 								}
// 								_map108.Add(MakeKeyword("Value"), _vec110)
// 								_vec107 = _vec107.Conjoin(_map108)
// 							}
// 							_map77.Add(MakeKeyword("Extensions"), _vec107)
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range (*_elem76).ExtraExtensions {
// 								_map112 := EmptyArrayMap()
// 								_vec113 := EmptyVector
// 								for _, _elem113 := range _elem111.Id {
// 									_vec113 = _vec113.Conjoin(MakeInt(_elem113))
// 								}
// 								_map112.Add(MakeKeyword("Id"), _vec113)
// 								_map112.Add(MakeKeyword("Critical"), MakeBool(_elem111.Critical))
// 								_vec114 := EmptyVector
// 								for _, _elem114 := range _elem111.Value {
// 									_vec114 = _vec114.Conjoin(MakeInt(int(_elem114)))
// 								}
// 								_map112.Add(MakeKeyword("Value"), _vec114)
// 								_vec111 = _vec111.Conjoin(_map112)
// 							}
// 							_map77.Add(MakeKeyword("ExtraExtensions"), _vec111)
// 							_vec115 := EmptyVector
// 							for _, _elem115 := range (*_elem76).UnhandledCriticalExtensions {
// 								_vec116 := EmptyVector
// 								for _, _elem116 := range _elem115 {
// 									_vec116 = _vec116.Conjoin(MakeInt(_elem116))
// 								}
// 								_vec115 = _vec115.Conjoin(_vec116)
// 							}
// 							_map77.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec115)
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range (*_elem76).ExtKeyUsage {
// 								_vec117 = _vec117.Conjoin(_elem117)
// 							}
// 							_map77.Add(MakeKeyword("ExtKeyUsage"), _vec117)
// 							_vec118 := EmptyVector
// 							for _, _elem118 := range (*_elem76).UnknownExtKeyUsage {
// 								_vec119 := EmptyVector
// 								for _, _elem119 := range _elem118 {
// 									_vec119 = _vec119.Conjoin(MakeInt(_elem119))
// 								}
// 								_vec118 = _vec118.Conjoin(_vec119)
// 							}
// 							_map77.Add(MakeKeyword("UnknownExtKeyUsage"), _vec118)
// 							_map77.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem76).BasicConstraintsValid))
// 							_map77.Add(MakeKeyword("IsCA"), MakeBool((*_elem76).IsCA))
// 							_map77.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem76).MaxPathLen))
// 							_map77.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem76).MaxPathLenZero))
// 							_vec120 := EmptyVector
// 							for _, _elem120 := range (*_elem76).SubjectKeyId {
// 								_vec120 = _vec120.Conjoin(MakeInt(int(_elem120)))
// 							}
// 							_map77.Add(MakeKeyword("SubjectKeyId"), _vec120)
// 							_vec121 := EmptyVector
// 							for _, _elem121 := range (*_elem76).AuthorityKeyId {
// 								_vec121 = _vec121.Conjoin(MakeInt(int(_elem121)))
// 							}
// 							_map77.Add(MakeKeyword("AuthorityKeyId"), _vec121)
// 							_vec122 := EmptyVector
// 							for _, _elem122 := range (*_elem76).OCSPServer {
// 								_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 							}
// 							_map77.Add(MakeKeyword("OCSPServer"), _vec122)
// 							_vec123 := EmptyVector
// 							for _, _elem123 := range (*_elem76).IssuingCertificateURL {
// 								_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 							}
// 							_map77.Add(MakeKeyword("IssuingCertificateURL"), _vec123)
// 							_vec124 := EmptyVector
// 							for _, _elem124 := range (*_elem76).DNSNames {
// 								_vec124 = _vec124.Conjoin(MakeString(_elem124))
// 							}
// 							_map77.Add(MakeKeyword("DNSNames"), _vec124)
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range (*_elem76).EmailAddresses {
// 								_vec125 = _vec125.Conjoin(MakeString(_elem125))
// 							}
// 							_map77.Add(MakeKeyword("EmailAddresses"), _vec125)
// 							_vec126 := EmptyVector
// 							for _, _elem126 := range (*_elem76).IPAddresses {
// 								_vec127 := EmptyVector
// 								for _, _elem127 := range _elem126 {
// 									_vec127 = _vec127.Conjoin(MakeInt(int(_elem127)))
// 								}
// 								_vec126 = _vec126.Conjoin(_vec127)
// 							}
// 							_map77.Add(MakeKeyword("IPAddresses"), _vec126)
// 							_vec128 := EmptyVector
// 							for _, _elem128 := range (*_elem76).URIs {
// 								var _obj_map129 Object
// 								if _elem128 != nil {
// 									_map129 := EmptyArrayMap()
// 									_map129.Add(MakeKeyword("Scheme"), MakeString((*_elem128).Scheme))
// 									_map129.Add(MakeKeyword("Opaque"), MakeString((*_elem128).Opaque))
// 									_map129.Add(MakeKeyword("User"), (*(*_elem128).User))
// 									_map129.Add(MakeKeyword("Host"), MakeString((*_elem128).Host))
// 									_map129.Add(MakeKeyword("Path"), MakeString((*_elem128).Path))
// 									_map129.Add(MakeKeyword("RawPath"), MakeString((*_elem128).RawPath))
// 									_map129.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem128).ForceQuery))
// 									_map129.Add(MakeKeyword("RawQuery"), MakeString((*_elem128).RawQuery))
// 									_map129.Add(MakeKeyword("Fragment"), MakeString((*_elem128).Fragment))
// 									_obj_map129 = Object(_map129)
// 								} else {
// 									_obj_map129 = NIL
// 								}
// 								_vec128 = _vec128.Conjoin(_obj_map129)
// 							}
// 							_map77.Add(MakeKeyword("URIs"), _vec128)
// 							_map77.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem76).PermittedDNSDomainsCritical))
// 							_vec130 := EmptyVector
// 							for _, _elem130 := range (*_elem76).PermittedDNSDomains {
// 								_vec130 = _vec130.Conjoin(MakeString(_elem130))
// 							}
// 							_map77.Add(MakeKeyword("PermittedDNSDomains"), _vec130)
// 							_vec131 := EmptyVector
// 							for _, _elem131 := range (*_elem76).ExcludedDNSDomains {
// 								_vec131 = _vec131.Conjoin(MakeString(_elem131))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedDNSDomains"), _vec131)
// 							_vec132 := EmptyVector
// 							for _, _elem132 := range (*_elem76).PermittedIPRanges {
// 								var _obj_map133 Object
// 								if _elem132 != nil {
// 									_map133 := EmptyArrayMap()
// 									_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 									_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 									_obj_map133 = Object(_map133)
// 								} else {
// 									_obj_map133 = NIL
// 								}
// 								_vec132 = _vec132.Conjoin(_obj_map133)
// 							}
// 							_map77.Add(MakeKeyword("PermittedIPRanges"), _vec132)
// 							_vec134 := EmptyVector
// 							for _, _elem134 := range (*_elem76).ExcludedIPRanges {
// 								var _obj_map135 Object
// 								if _elem134 != nil {
// 									_map135 := EmptyArrayMap()
// 									_map135.Add(MakeKeyword("IP"), (*_elem134).IP)
// 									_map135.Add(MakeKeyword("Mask"), (*_elem134).Mask)
// 									_obj_map135 = Object(_map135)
// 								} else {
// 									_obj_map135 = NIL
// 								}
// 								_vec134 = _vec134.Conjoin(_obj_map135)
// 							}
// 							_map77.Add(MakeKeyword("ExcludedIPRanges"), _vec134)
// 							_vec136 := EmptyVector
// 							for _, _elem136 := range (*_elem76).PermittedEmailAddresses {
// 								_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 							}
// 							_map77.Add(MakeKeyword("PermittedEmailAddresses"), _vec136)
// 							_vec137 := EmptyVector
// 							for _, _elem137 := range (*_elem76).ExcludedEmailAddresses {
// 								_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedEmailAddresses"), _vec137)
// 							_vec138 := EmptyVector
// 							for _, _elem138 := range (*_elem76).PermittedURIDomains {
// 								_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 							}
// 							_map77.Add(MakeKeyword("PermittedURIDomains"), _vec138)
// 							_vec139 := EmptyVector
// 							for _, _elem139 := range (*_elem76).ExcludedURIDomains {
// 								_vec139 = _vec139.Conjoin(MakeString(_elem139))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedURIDomains"), _vec139)
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range (*_elem76).CRLDistributionPoints {
// 								_vec140 = _vec140.Conjoin(MakeString(_elem140))
// 							}
// 							_map77.Add(MakeKeyword("CRLDistributionPoints"), _vec140)
// 							_vec141 := EmptyVector
// 							for _, _elem141 := range (*_elem76).PolicyIdentifiers {
// 								_vec142 := EmptyVector
// 								for _, _elem142 := range _elem141 {
// 									_vec142 = _vec142.Conjoin(MakeInt(_elem142))
// 								}
// 								_vec141 = _vec141.Conjoin(_vec142)
// 							}
// 							_map77.Add(MakeKeyword("PolicyIdentifiers"), _vec141)
// 							_obj_map77 = Object(_map77)
// 						} else {
// 							_obj_map77 = NIL
// 						}
// 						_vec76 = _vec76.Conjoin(_obj_map77)
// 					}
// 					_vec75 = _vec75.Conjoin(_vec76)
// 				}
// 				_map7.Add(MakeKeyword("VerifiedChains"), _vec75)
// 				_vec143 := EmptyVector
// 				for _, _elem143 := range (*(*(*resp).Request).TLS).SignedCertificateTimestamps {
// 					_vec144 := EmptyVector
// 					for _, _elem144 := range _elem143 {
// 						_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 					}
// 					_vec143 = _vec143.Conjoin(_vec144)
// 				}
// 				_map7.Add(MakeKeyword("SignedCertificateTimestamps"), _vec143)
// 				_vec145 := EmptyVector
// 				for _, _elem145 := range (*(*(*resp).Request).TLS).OCSPResponse {
// 					_vec145 = _vec145.Conjoin(MakeInt(int(_elem145)))
// 				}
// 				_map7.Add(MakeKeyword("OCSPResponse"), _vec145)
// 				_vec146 := EmptyVector
// 				for _, _elem146 := range (*(*(*resp).Request).TLS).TLSUnique {
// 					_vec146 = _vec146.Conjoin(MakeInt(int(_elem146)))
// 				}
// 				_map7.Add(MakeKeyword("TLSUnique"), _vec146)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_map3.Add(MakeKeyword("TLS"), _obj_map7)
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		var _obj_map147 Object
// 		if (*resp).TLS != nil {
// 			_map147 := EmptyArrayMap()
// 			_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*resp).TLS).Version)))
// 			_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*resp).TLS).HandshakeComplete))
// 			_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*resp).TLS).DidResume))
// 			_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*resp).TLS).CipherSuite)))
// 			_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*resp).TLS).NegotiatedProtocol))
// 			_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*resp).TLS).NegotiatedProtocolIsMutual))
// 			_map147.Add(MakeKeyword("ServerName"), MakeString((*(*resp).TLS).ServerName))
// 			_vec148 := EmptyVector
// 			for _, _elem148 := range (*(*resp).TLS).PeerCertificates {
// 				var _obj_map149 Object
// 				if _elem148 != nil {
// 					_map149 := EmptyArrayMap()
// 					_vec150 := EmptyVector
// 					for _, _elem150 := range (*_elem148).Raw {
// 						_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 					}
// 					_map149.Add(MakeKeyword("Raw"), _vec150)
// 					_vec151 := EmptyVector
// 					for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 						_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 					}
// 					_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 					_vec152 := EmptyVector
// 					for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 						_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 					_vec153 := EmptyVector
// 					for _, _elem153 := range (*_elem148).RawSubject {
// 						_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 					_vec154 := EmptyVector
// 					for _, _elem154 := range (*_elem148).RawIssuer {
// 						_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 					}
// 					_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 					_vec155 := EmptyVector
// 					for _, _elem155 := range (*_elem148).Signature {
// 						_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 					}
// 					_map149.Add(MakeKeyword("Signature"), _vec155)
// 					_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 					_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 					_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map157 := EmptyArrayMap()
// 					_vec158 := EmptyVector
// 					for _, _elem158 := range (*_elem148).Issuer.Country {
// 						_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 					}
// 					_map157.Add(MakeKeyword("Country"), _vec158)
// 					_vec159 := EmptyVector
// 					for _, _elem159 := range (*_elem148).Issuer.Organization {
// 						_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 					}
// 					_map157.Add(MakeKeyword("Organization"), _vec159)
// 					_vec160 := EmptyVector
// 					for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 						_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 					}
// 					_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 					_vec161 := EmptyVector
// 					for _, _elem161 := range (*_elem148).Issuer.Locality {
// 						_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 					}
// 					_map157.Add(MakeKeyword("Locality"), _vec161)
// 					_vec162 := EmptyVector
// 					for _, _elem162 := range (*_elem148).Issuer.Province {
// 						_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 					}
// 					_map157.Add(MakeKeyword("Province"), _vec162)
// 					_vec163 := EmptyVector
// 					for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 						_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 					}
// 					_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 					_vec164 := EmptyVector
// 					for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 						_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 					}
// 					_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 					_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 					_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 					_vec165 := EmptyVector
// 					for _, _elem165 := range (*_elem148).Issuer.Names {
// 						_vec165 = _vec165.Conjoin(_elem165)
// 					}
// 					_map157.Add(MakeKeyword("Names"), _vec165)
// 					_vec166 := EmptyVector
// 					for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 						_vec166 = _vec166.Conjoin(_elem166)
// 					}
// 					_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 					_map149.Add(MakeKeyword("Issuer"), _map157)
// 					_map167 := EmptyArrayMap()
// 					_vec168 := EmptyVector
// 					for _, _elem168 := range (*_elem148).Subject.Country {
// 						_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 					}
// 					_map167.Add(MakeKeyword("Country"), _vec168)
// 					_vec169 := EmptyVector
// 					for _, _elem169 := range (*_elem148).Subject.Organization {
// 						_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 					}
// 					_map167.Add(MakeKeyword("Organization"), _vec169)
// 					_vec170 := EmptyVector
// 					for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 						_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 					}
// 					_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 					_vec171 := EmptyVector
// 					for _, _elem171 := range (*_elem148).Subject.Locality {
// 						_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 					}
// 					_map167.Add(MakeKeyword("Locality"), _vec171)
// 					_vec172 := EmptyVector
// 					for _, _elem172 := range (*_elem148).Subject.Province {
// 						_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 					}
// 					_map167.Add(MakeKeyword("Province"), _vec172)
// 					_vec173 := EmptyVector
// 					for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 						_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 					}
// 					_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 					_vec174 := EmptyVector
// 					for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 						_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 					}
// 					_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 					_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 					_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 					_vec175 := EmptyVector
// 					for _, _elem175 := range (*_elem148).Subject.Names {
// 						_vec175 = _vec175.Conjoin(_elem175)
// 					}
// 					_map167.Add(MakeKeyword("Names"), _vec175)
// 					_vec176 := EmptyVector
// 					for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 						_vec176 = _vec176.Conjoin(_elem176)
// 					}
// 					_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 					_map149.Add(MakeKeyword("Subject"), _map167)
// 					_map149.Add(MakeKeyword("NotBefore"), NIL)
// 					_map149.Add(MakeKeyword("NotAfter"), NIL)
// 					_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 					_vec179 := EmptyVector
// 					for _, _elem179 := range (*_elem148).Extensions {
// 						_map180 := EmptyArrayMap()
// 						_vec181 := EmptyVector
// 						for _, _elem181 := range _elem179.Id {
// 							_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 						}
// 						_map180.Add(MakeKeyword("Id"), _vec181)
// 						_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 						_vec182 := EmptyVector
// 						for _, _elem182 := range _elem179.Value {
// 							_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 						}
// 						_map180.Add(MakeKeyword("Value"), _vec182)
// 						_vec179 = _vec179.Conjoin(_map180)
// 					}
// 					_map149.Add(MakeKeyword("Extensions"), _vec179)
// 					_vec183 := EmptyVector
// 					for _, _elem183 := range (*_elem148).ExtraExtensions {
// 						_map184 := EmptyArrayMap()
// 						_vec185 := EmptyVector
// 						for _, _elem185 := range _elem183.Id {
// 							_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 						}
// 						_map184.Add(MakeKeyword("Id"), _vec185)
// 						_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 						_vec186 := EmptyVector
// 						for _, _elem186 := range _elem183.Value {
// 							_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 						}
// 						_map184.Add(MakeKeyword("Value"), _vec186)
// 						_vec183 = _vec183.Conjoin(_map184)
// 					}
// 					_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 					_vec187 := EmptyVector
// 					for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 						_vec188 := EmptyVector
// 						for _, _elem188 := range _elem187 {
// 							_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 						}
// 						_vec187 = _vec187.Conjoin(_vec188)
// 					}
// 					_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 					_vec189 := EmptyVector
// 					for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 						_vec189 = _vec189.Conjoin(_elem189)
// 					}
// 					_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 					_vec190 := EmptyVector
// 					for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 						_vec191 := EmptyVector
// 						for _, _elem191 := range _elem190 {
// 							_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 						}
// 						_vec190 = _vec190.Conjoin(_vec191)
// 					}
// 					_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 					_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 					_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 					_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 					_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 					_vec192 := EmptyVector
// 					for _, _elem192 := range (*_elem148).SubjectKeyId {
// 						_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 					}
// 					_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 					_vec193 := EmptyVector
// 					for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 						_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 					}
// 					_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 					_vec194 := EmptyVector
// 					for _, _elem194 := range (*_elem148).OCSPServer {
// 						_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 					}
// 					_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 					_vec195 := EmptyVector
// 					for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 						_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 					}
// 					_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 					_vec196 := EmptyVector
// 					for _, _elem196 := range (*_elem148).DNSNames {
// 						_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 					}
// 					_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 					_vec197 := EmptyVector
// 					for _, _elem197 := range (*_elem148).EmailAddresses {
// 						_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 					}
// 					_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 					_vec198 := EmptyVector
// 					for _, _elem198 := range (*_elem148).IPAddresses {
// 						_vec199 := EmptyVector
// 						for _, _elem199 := range _elem198 {
// 							_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 						}
// 						_vec198 = _vec198.Conjoin(_vec199)
// 					}
// 					_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 					_vec200 := EmptyVector
// 					for _, _elem200 := range (*_elem148).URIs {
// 						var _obj_map201 Object
// 						if _elem200 != nil {
// 							_map201 := EmptyArrayMap()
// 							_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 							_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 							_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 							_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 							_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 							_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 							_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 							_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 							_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 							_obj_map201 = Object(_map201)
// 						} else {
// 							_obj_map201 = NIL
// 						}
// 						_vec200 = _vec200.Conjoin(_obj_map201)
// 					}
// 					_map149.Add(MakeKeyword("URIs"), _vec200)
// 					_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 					_vec202 := EmptyVector
// 					for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 						_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 					}
// 					_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 					_vec203 := EmptyVector
// 					for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 						_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 					_vec204 := EmptyVector
// 					for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 						var _obj_map205 Object
// 						if _elem204 != nil {
// 							_map205 := EmptyArrayMap()
// 							_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 							_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 							_obj_map205 = Object(_map205)
// 						} else {
// 							_obj_map205 = NIL
// 						}
// 						_vec204 = _vec204.Conjoin(_obj_map205)
// 					}
// 					_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 					_vec206 := EmptyVector
// 					for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 						var _obj_map207 Object
// 						if _elem206 != nil {
// 							_map207 := EmptyArrayMap()
// 							_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 							_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 							_obj_map207 = Object(_map207)
// 						} else {
// 							_obj_map207 = NIL
// 						}
// 						_vec206 = _vec206.Conjoin(_obj_map207)
// 					}
// 					_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 					_vec208 := EmptyVector
// 					for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 						_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 					}
// 					_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 					_vec209 := EmptyVector
// 					for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 						_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 					_vec210 := EmptyVector
// 					for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 						_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 					}
// 					_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 					_vec211 := EmptyVector
// 					for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 						_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 					_vec212 := EmptyVector
// 					for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 						_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 					}
// 					_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 					_vec213 := EmptyVector
// 					for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 						_vec214 := EmptyVector
// 						for _, _elem214 := range _elem213 {
// 							_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 						}
// 						_vec213 = _vec213.Conjoin(_vec214)
// 					}
// 					_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 					_obj_map149 = Object(_map149)
// 				} else {
// 					_obj_map149 = NIL
// 				}
// 				_vec148 = _vec148.Conjoin(_obj_map149)
// 			}
// 			_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 			_vec215 := EmptyVector
// 			for _, _elem215 := range (*(*resp).TLS).VerifiedChains {
// 				_vec216 := EmptyVector
// 				for _, _elem216 := range _elem215 {
// 					var _obj_map217 Object
// 					if _elem216 != nil {
// 						_map217 := EmptyArrayMap()
// 						_vec218 := EmptyVector
// 						for _, _elem218 := range (*_elem216).Raw {
// 							_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 						}
// 						_map217.Add(MakeKeyword("Raw"), _vec218)
// 						_vec219 := EmptyVector
// 						for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 							_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 						}
// 						_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 						_vec220 := EmptyVector
// 						for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 							_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 						_vec221 := EmptyVector
// 						for _, _elem221 := range (*_elem216).RawSubject {
// 							_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 						_vec222 := EmptyVector
// 						for _, _elem222 := range (*_elem216).RawIssuer {
// 							_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 						}
// 						_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 						_vec223 := EmptyVector
// 						for _, _elem223 := range (*_elem216).Signature {
// 							_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 						}
// 						_map217.Add(MakeKeyword("Signature"), _vec223)
// 						_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 						_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 						_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map225 := EmptyArrayMap()
// 						_vec226 := EmptyVector
// 						for _, _elem226 := range (*_elem216).Issuer.Country {
// 							_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 						}
// 						_map225.Add(MakeKeyword("Country"), _vec226)
// 						_vec227 := EmptyVector
// 						for _, _elem227 := range (*_elem216).Issuer.Organization {
// 							_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 						}
// 						_map225.Add(MakeKeyword("Organization"), _vec227)
// 						_vec228 := EmptyVector
// 						for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 							_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 						}
// 						_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 						_vec229 := EmptyVector
// 						for _, _elem229 := range (*_elem216).Issuer.Locality {
// 							_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 						}
// 						_map225.Add(MakeKeyword("Locality"), _vec229)
// 						_vec230 := EmptyVector
// 						for _, _elem230 := range (*_elem216).Issuer.Province {
// 							_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 						}
// 						_map225.Add(MakeKeyword("Province"), _vec230)
// 						_vec231 := EmptyVector
// 						for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 							_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 						}
// 						_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 						_vec232 := EmptyVector
// 						for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 							_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 						}
// 						_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 						_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 						_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 						_vec233 := EmptyVector
// 						for _, _elem233 := range (*_elem216).Issuer.Names {
// 							_vec233 = _vec233.Conjoin(_elem233)
// 						}
// 						_map225.Add(MakeKeyword("Names"), _vec233)
// 						_vec234 := EmptyVector
// 						for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 							_vec234 = _vec234.Conjoin(_elem234)
// 						}
// 						_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 						_map217.Add(MakeKeyword("Issuer"), _map225)
// 						_map235 := EmptyArrayMap()
// 						_vec236 := EmptyVector
// 						for _, _elem236 := range (*_elem216).Subject.Country {
// 							_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 						}
// 						_map235.Add(MakeKeyword("Country"), _vec236)
// 						_vec237 := EmptyVector
// 						for _, _elem237 := range (*_elem216).Subject.Organization {
// 							_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 						}
// 						_map235.Add(MakeKeyword("Organization"), _vec237)
// 						_vec238 := EmptyVector
// 						for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 							_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 						}
// 						_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 						_vec239 := EmptyVector
// 						for _, _elem239 := range (*_elem216).Subject.Locality {
// 							_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 						}
// 						_map235.Add(MakeKeyword("Locality"), _vec239)
// 						_vec240 := EmptyVector
// 						for _, _elem240 := range (*_elem216).Subject.Province {
// 							_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 						}
// 						_map235.Add(MakeKeyword("Province"), _vec240)
// 						_vec241 := EmptyVector
// 						for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 							_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 						}
// 						_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 						_vec242 := EmptyVector
// 						for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 							_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 						}
// 						_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 						_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 						_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 						_vec243 := EmptyVector
// 						for _, _elem243 := range (*_elem216).Subject.Names {
// 							_vec243 = _vec243.Conjoin(_elem243)
// 						}
// 						_map235.Add(MakeKeyword("Names"), _vec243)
// 						_vec244 := EmptyVector
// 						for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 							_vec244 = _vec244.Conjoin(_elem244)
// 						}
// 						_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 						_map217.Add(MakeKeyword("Subject"), _map235)
// 						_map217.Add(MakeKeyword("NotBefore"), NIL)
// 						_map217.Add(MakeKeyword("NotAfter"), NIL)
// 						_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 						_vec247 := EmptyVector
// 						for _, _elem247 := range (*_elem216).Extensions {
// 							_map248 := EmptyArrayMap()
// 							_vec249 := EmptyVector
// 							for _, _elem249 := range _elem247.Id {
// 								_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 							}
// 							_map248.Add(MakeKeyword("Id"), _vec249)
// 							_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 							_vec250 := EmptyVector
// 							for _, _elem250 := range _elem247.Value {
// 								_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 							}
// 							_map248.Add(MakeKeyword("Value"), _vec250)
// 							_vec247 = _vec247.Conjoin(_map248)
// 						}
// 						_map217.Add(MakeKeyword("Extensions"), _vec247)
// 						_vec251 := EmptyVector
// 						for _, _elem251 := range (*_elem216).ExtraExtensions {
// 							_map252 := EmptyArrayMap()
// 							_vec253 := EmptyVector
// 							for _, _elem253 := range _elem251.Id {
// 								_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 							}
// 							_map252.Add(MakeKeyword("Id"), _vec253)
// 							_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 							_vec254 := EmptyVector
// 							for _, _elem254 := range _elem251.Value {
// 								_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 							}
// 							_map252.Add(MakeKeyword("Value"), _vec254)
// 							_vec251 = _vec251.Conjoin(_map252)
// 						}
// 						_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 						_vec255 := EmptyVector
// 						for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 							_vec256 := EmptyVector
// 							for _, _elem256 := range _elem255 {
// 								_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 							}
// 							_vec255 = _vec255.Conjoin(_vec256)
// 						}
// 						_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 						_vec257 := EmptyVector
// 						for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 							_vec257 = _vec257.Conjoin(_elem257)
// 						}
// 						_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 						_vec258 := EmptyVector
// 						for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 							_vec259 := EmptyVector
// 							for _, _elem259 := range _elem258 {
// 								_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 							}
// 							_vec258 = _vec258.Conjoin(_vec259)
// 						}
// 						_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 						_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 						_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 						_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 						_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 						_vec260 := EmptyVector
// 						for _, _elem260 := range (*_elem216).SubjectKeyId {
// 							_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 						}
// 						_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 						_vec261 := EmptyVector
// 						for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 							_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 						}
// 						_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 						_vec262 := EmptyVector
// 						for _, _elem262 := range (*_elem216).OCSPServer {
// 							_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 						}
// 						_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 						_vec263 := EmptyVector
// 						for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 							_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 						}
// 						_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 						_vec264 := EmptyVector
// 						for _, _elem264 := range (*_elem216).DNSNames {
// 							_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 						}
// 						_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 						_vec265 := EmptyVector
// 						for _, _elem265 := range (*_elem216).EmailAddresses {
// 							_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 						}
// 						_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 						_vec266 := EmptyVector
// 						for _, _elem266 := range (*_elem216).IPAddresses {
// 							_vec267 := EmptyVector
// 							for _, _elem267 := range _elem266 {
// 								_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 							}
// 							_vec266 = _vec266.Conjoin(_vec267)
// 						}
// 						_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 						_vec268 := EmptyVector
// 						for _, _elem268 := range (*_elem216).URIs {
// 							var _obj_map269 Object
// 							if _elem268 != nil {
// 								_map269 := EmptyArrayMap()
// 								_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 								_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 								_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 								_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 								_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 								_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 								_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 								_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 								_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 								_obj_map269 = Object(_map269)
// 							} else {
// 								_obj_map269 = NIL
// 							}
// 							_vec268 = _vec268.Conjoin(_obj_map269)
// 						}
// 						_map217.Add(MakeKeyword("URIs"), _vec268)
// 						_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 						_vec270 := EmptyVector
// 						for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 							_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 						}
// 						_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 						_vec271 := EmptyVector
// 						for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 							_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 						_vec272 := EmptyVector
// 						for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 							var _obj_map273 Object
// 							if _elem272 != nil {
// 								_map273 := EmptyArrayMap()
// 								_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 								_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 								_obj_map273 = Object(_map273)
// 							} else {
// 								_obj_map273 = NIL
// 							}
// 							_vec272 = _vec272.Conjoin(_obj_map273)
// 						}
// 						_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 						_vec274 := EmptyVector
// 						for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 							var _obj_map275 Object
// 							if _elem274 != nil {
// 								_map275 := EmptyArrayMap()
// 								_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 								_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 								_obj_map275 = Object(_map275)
// 							} else {
// 								_obj_map275 = NIL
// 							}
// 							_vec274 = _vec274.Conjoin(_obj_map275)
// 						}
// 						_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 						_vec276 := EmptyVector
// 						for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 							_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 						}
// 						_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 						_vec277 := EmptyVector
// 						for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 							_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 						_vec278 := EmptyVector
// 						for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 							_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 						}
// 						_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 						_vec279 := EmptyVector
// 						for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 							_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 						_vec280 := EmptyVector
// 						for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 							_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 						}
// 						_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 						_vec281 := EmptyVector
// 						for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 							_vec282 := EmptyVector
// 							for _, _elem282 := range _elem281 {
// 								_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 							}
// 							_vec281 = _vec281.Conjoin(_vec282)
// 						}
// 						_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 						_obj_map217 = Object(_map217)
// 					} else {
// 						_obj_map217 = NIL
// 					}
// 					_vec216 = _vec216.Conjoin(_obj_map217)
// 				}
// 				_vec215 = _vec215.Conjoin(_vec216)
// 			}
// 			_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 			_vec283 := EmptyVector
// 			for _, _elem283 := range (*(*resp).TLS).SignedCertificateTimestamps {
// 				_vec284 := EmptyVector
// 				for _, _elem284 := range _elem283 {
// 					_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 				}
// 				_vec283 = _vec283.Conjoin(_vec284)
// 			}
// 			_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 			_vec285 := EmptyVector
// 			for _, _elem285 := range (*(*resp).TLS).OCSPResponse {
// 				_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 			}
// 			_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 			_vec286 := EmptyVector
// 			for _, _elem286 := range (*(*resp).TLS).TLSUnique {
// 				_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 			}
// 			_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 			_obj_map147 = Object(_map147)
// 		} else {
// 			_obj_map147 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map147)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.PostForm:
// func postForm(url string, data net/url.Values) Object {
// 	resp, err := _http.PostForm(url, data)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if resp != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*resp).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*resp).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*resp).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*resp).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*resp).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*resp).Header)
// 		_map1.Add(MakeKeyword("Body"), (*resp).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*resp).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*resp).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*resp).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*resp).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*resp).Trailer)
// 		var _obj_map3 Object
// 		if (*resp).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*resp).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*resp).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*resp).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*resp).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*resp).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*resp).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*resp).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*resp).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*resp).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*resp).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*resp).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*resp).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*resp).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*resp).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*resp).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*resp).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*resp).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*resp).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*resp).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*resp).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*resp).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*resp).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*resp).Request).PostForm)
// 			var _obj_map6 Object
// 			if (*(*resp).Request).MultipartForm != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Value"), (*(*(*resp).Request).MultipartForm).Value)
// 				_map6.Add(MakeKeyword("File"), (*(*(*resp).Request).MultipartForm).File)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map3.Add(MakeKeyword("MultipartForm"), _obj_map6)
// 			_map3.Add(MakeKeyword("Trailer"), (*(*resp).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*resp).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*resp).Request).RequestURI))
// 			var _obj_map7 Object
// 			if (*(*resp).Request).TLS != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Version"), MakeInt(int((*(*(*resp).Request).TLS).Version)))
// 				_map7.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*resp).Request).TLS).HandshakeComplete))
// 				_map7.Add(MakeKeyword("DidResume"), MakeBool((*(*(*resp).Request).TLS).DidResume))
// 				_map7.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*resp).Request).TLS).CipherSuite)))
// 				_map7.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*resp).Request).TLS).NegotiatedProtocol))
// 				_map7.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*resp).Request).TLS).NegotiatedProtocolIsMutual))
// 				_map7.Add(MakeKeyword("ServerName"), MakeString((*(*(*resp).Request).TLS).ServerName))
// 				_vec8 := EmptyVector
// 				for _, _elem8 := range (*(*(*resp).Request).TLS).PeerCertificates {
// 					var _obj_map9 Object
// 					if _elem8 != nil {
// 						_map9 := EmptyArrayMap()
// 						_vec10 := EmptyVector
// 						for _, _elem10 := range (*_elem8).Raw {
// 							_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 						}
// 						_map9.Add(MakeKeyword("Raw"), _vec10)
// 						_vec11 := EmptyVector
// 						for _, _elem11 := range (*_elem8).RawTBSCertificate {
// 							_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 						}
// 						_map9.Add(MakeKeyword("RawTBSCertificate"), _vec11)
// 						_vec12 := EmptyVector
// 						for _, _elem12 := range (*_elem8).RawSubjectPublicKeyInfo {
// 							_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec12)
// 						_vec13 := EmptyVector
// 						for _, _elem13 := range (*_elem8).RawSubject {
// 							_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubject"), _vec13)
// 						_vec14 := EmptyVector
// 						for _, _elem14 := range (*_elem8).RawIssuer {
// 							_vec14 = _vec14.Conjoin(MakeInt(int(_elem14)))
// 						}
// 						_map9.Add(MakeKeyword("RawIssuer"), _vec14)
// 						_vec15 := EmptyVector
// 						for _, _elem15 := range (*_elem8).Signature {
// 							_vec15 = _vec15.Conjoin(MakeInt(int(_elem15)))
// 						}
// 						_map9.Add(MakeKeyword("Signature"), _vec15)
// 						_map9.Add(MakeKeyword("SignatureAlgorithm"), (*_elem8).SignatureAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem8).PublicKeyAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKey"), (*_elem8).PublicKey)
// 						_map9.Add(MakeKeyword("Version"), MakeInt((*_elem8).Version))
// 						_map9.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map17 := EmptyArrayMap()
// 						_vec18 := EmptyVector
// 						for _, _elem18 := range (*_elem8).Issuer.Country {
// 							_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 						}
// 						_map17.Add(MakeKeyword("Country"), _vec18)
// 						_vec19 := EmptyVector
// 						for _, _elem19 := range (*_elem8).Issuer.Organization {
// 							_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 						}
// 						_map17.Add(MakeKeyword("Organization"), _vec19)
// 						_vec20 := EmptyVector
// 						for _, _elem20 := range (*_elem8).Issuer.OrganizationalUnit {
// 							_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 						}
// 						_map17.Add(MakeKeyword("OrganizationalUnit"), _vec20)
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem8).Issuer.Locality {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map17.Add(MakeKeyword("Locality"), _vec21)
// 						_vec22 := EmptyVector
// 						for _, _elem22 := range (*_elem8).Issuer.Province {
// 							_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 						}
// 						_map17.Add(MakeKeyword("Province"), _vec22)
// 						_vec23 := EmptyVector
// 						for _, _elem23 := range (*_elem8).Issuer.StreetAddress {
// 							_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 						}
// 						_map17.Add(MakeKeyword("StreetAddress"), _vec23)
// 						_vec24 := EmptyVector
// 						for _, _elem24 := range (*_elem8).Issuer.PostalCode {
// 							_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 						}
// 						_map17.Add(MakeKeyword("PostalCode"), _vec24)
// 						_map17.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Issuer.SerialNumber))
// 						_map17.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Issuer.CommonName))
// 						_vec25 := EmptyVector
// 						for _, _elem25 := range (*_elem8).Issuer.Names {
// 							_vec25 = _vec25.Conjoin(_elem25)
// 						}
// 						_map17.Add(MakeKeyword("Names"), _vec25)
// 						_vec26 := EmptyVector
// 						for _, _elem26 := range (*_elem8).Issuer.ExtraNames {
// 							_vec26 = _vec26.Conjoin(_elem26)
// 						}
// 						_map17.Add(MakeKeyword("ExtraNames"), _vec26)
// 						_map9.Add(MakeKeyword("Issuer"), _map17)
// 						_map27 := EmptyArrayMap()
// 						_vec28 := EmptyVector
// 						for _, _elem28 := range (*_elem8).Subject.Country {
// 							_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 						}
// 						_map27.Add(MakeKeyword("Country"), _vec28)
// 						_vec29 := EmptyVector
// 						for _, _elem29 := range (*_elem8).Subject.Organization {
// 							_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 						}
// 						_map27.Add(MakeKeyword("Organization"), _vec29)
// 						_vec30 := EmptyVector
// 						for _, _elem30 := range (*_elem8).Subject.OrganizationalUnit {
// 							_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 						}
// 						_map27.Add(MakeKeyword("OrganizationalUnit"), _vec30)
// 						_vec31 := EmptyVector
// 						for _, _elem31 := range (*_elem8).Subject.Locality {
// 							_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 						}
// 						_map27.Add(MakeKeyword("Locality"), _vec31)
// 						_vec32 := EmptyVector
// 						for _, _elem32 := range (*_elem8).Subject.Province {
// 							_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 						}
// 						_map27.Add(MakeKeyword("Province"), _vec32)
// 						_vec33 := EmptyVector
// 						for _, _elem33 := range (*_elem8).Subject.StreetAddress {
// 							_vec33 = _vec33.Conjoin(MakeString(_elem33))
// 						}
// 						_map27.Add(MakeKeyword("StreetAddress"), _vec33)
// 						_vec34 := EmptyVector
// 						for _, _elem34 := range (*_elem8).Subject.PostalCode {
// 							_vec34 = _vec34.Conjoin(MakeString(_elem34))
// 						}
// 						_map27.Add(MakeKeyword("PostalCode"), _vec34)
// 						_map27.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Subject.SerialNumber))
// 						_map27.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Subject.CommonName))
// 						_vec35 := EmptyVector
// 						for _, _elem35 := range (*_elem8).Subject.Names {
// 							_vec35 = _vec35.Conjoin(_elem35)
// 						}
// 						_map27.Add(MakeKeyword("Names"), _vec35)
// 						_vec36 := EmptyVector
// 						for _, _elem36 := range (*_elem8).Subject.ExtraNames {
// 							_vec36 = _vec36.Conjoin(_elem36)
// 						}
// 						_map27.Add(MakeKeyword("ExtraNames"), _vec36)
// 						_map9.Add(MakeKeyword("Subject"), _map27)
// 						_map9.Add(MakeKeyword("NotBefore"), NIL)
// 						_map9.Add(MakeKeyword("NotAfter"), NIL)
// 						_map9.Add(MakeKeyword("KeyUsage"), (*_elem8).KeyUsage)
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range (*_elem8).Extensions {
// 							_map40 := EmptyArrayMap()
// 							_vec41 := EmptyVector
// 							for _, _elem41 := range _elem39.Id {
// 								_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 							}
// 							_map40.Add(MakeKeyword("Id"), _vec41)
// 							_map40.Add(MakeKeyword("Critical"), MakeBool(_elem39.Critical))
// 							_vec42 := EmptyVector
// 							for _, _elem42 := range _elem39.Value {
// 								_vec42 = _vec42.Conjoin(MakeInt(int(_elem42)))
// 							}
// 							_map40.Add(MakeKeyword("Value"), _vec42)
// 							_vec39 = _vec39.Conjoin(_map40)
// 						}
// 						_map9.Add(MakeKeyword("Extensions"), _vec39)
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range (*_elem8).ExtraExtensions {
// 							_map44 := EmptyArrayMap()
// 							_vec45 := EmptyVector
// 							for _, _elem45 := range _elem43.Id {
// 								_vec45 = _vec45.Conjoin(MakeInt(_elem45))
// 							}
// 							_map44.Add(MakeKeyword("Id"), _vec45)
// 							_map44.Add(MakeKeyword("Critical"), MakeBool(_elem43.Critical))
// 							_vec46 := EmptyVector
// 							for _, _elem46 := range _elem43.Value {
// 								_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 							}
// 							_map44.Add(MakeKeyword("Value"), _vec46)
// 							_vec43 = _vec43.Conjoin(_map44)
// 						}
// 						_map9.Add(MakeKeyword("ExtraExtensions"), _vec43)
// 						_vec47 := EmptyVector
// 						for _, _elem47 := range (*_elem8).UnhandledCriticalExtensions {
// 							_vec48 := EmptyVector
// 							for _, _elem48 := range _elem47 {
// 								_vec48 = _vec48.Conjoin(MakeInt(_elem48))
// 							}
// 							_vec47 = _vec47.Conjoin(_vec48)
// 						}
// 						_map9.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec47)
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range (*_elem8).ExtKeyUsage {
// 							_vec49 = _vec49.Conjoin(_elem49)
// 						}
// 						_map9.Add(MakeKeyword("ExtKeyUsage"), _vec49)
// 						_vec50 := EmptyVector
// 						for _, _elem50 := range (*_elem8).UnknownExtKeyUsage {
// 							_vec51 := EmptyVector
// 							for _, _elem51 := range _elem50 {
// 								_vec51 = _vec51.Conjoin(MakeInt(_elem51))
// 							}
// 							_vec50 = _vec50.Conjoin(_vec51)
// 						}
// 						_map9.Add(MakeKeyword("UnknownExtKeyUsage"), _vec50)
// 						_map9.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem8).BasicConstraintsValid))
// 						_map9.Add(MakeKeyword("IsCA"), MakeBool((*_elem8).IsCA))
// 						_map9.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem8).MaxPathLen))
// 						_map9.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem8).MaxPathLenZero))
// 						_vec52 := EmptyVector
// 						for _, _elem52 := range (*_elem8).SubjectKeyId {
// 							_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 						}
// 						_map9.Add(MakeKeyword("SubjectKeyId"), _vec52)
// 						_vec53 := EmptyVector
// 						for _, _elem53 := range (*_elem8).AuthorityKeyId {
// 							_vec53 = _vec53.Conjoin(MakeInt(int(_elem53)))
// 						}
// 						_map9.Add(MakeKeyword("AuthorityKeyId"), _vec53)
// 						_vec54 := EmptyVector
// 						for _, _elem54 := range (*_elem8).OCSPServer {
// 							_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 						}
// 						_map9.Add(MakeKeyword("OCSPServer"), _vec54)
// 						_vec55 := EmptyVector
// 						for _, _elem55 := range (*_elem8).IssuingCertificateURL {
// 							_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 						}
// 						_map9.Add(MakeKeyword("IssuingCertificateURL"), _vec55)
// 						_vec56 := EmptyVector
// 						for _, _elem56 := range (*_elem8).DNSNames {
// 							_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 						}
// 						_map9.Add(MakeKeyword("DNSNames"), _vec56)
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range (*_elem8).EmailAddresses {
// 							_vec57 = _vec57.Conjoin(MakeString(_elem57))
// 						}
// 						_map9.Add(MakeKeyword("EmailAddresses"), _vec57)
// 						_vec58 := EmptyVector
// 						for _, _elem58 := range (*_elem8).IPAddresses {
// 							_vec59 := EmptyVector
// 							for _, _elem59 := range _elem58 {
// 								_vec59 = _vec59.Conjoin(MakeInt(int(_elem59)))
// 							}
// 							_vec58 = _vec58.Conjoin(_vec59)
// 						}
// 						_map9.Add(MakeKeyword("IPAddresses"), _vec58)
// 						_vec60 := EmptyVector
// 						for _, _elem60 := range (*_elem8).URIs {
// 							var _obj_map61 Object
// 							if _elem60 != nil {
// 								_map61 := EmptyArrayMap()
// 								_map61.Add(MakeKeyword("Scheme"), MakeString((*_elem60).Scheme))
// 								_map61.Add(MakeKeyword("Opaque"), MakeString((*_elem60).Opaque))
// 								_map61.Add(MakeKeyword("User"), (*(*_elem60).User))
// 								_map61.Add(MakeKeyword("Host"), MakeString((*_elem60).Host))
// 								_map61.Add(MakeKeyword("Path"), MakeString((*_elem60).Path))
// 								_map61.Add(MakeKeyword("RawPath"), MakeString((*_elem60).RawPath))
// 								_map61.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem60).ForceQuery))
// 								_map61.Add(MakeKeyword("RawQuery"), MakeString((*_elem60).RawQuery))
// 								_map61.Add(MakeKeyword("Fragment"), MakeString((*_elem60).Fragment))
// 								_obj_map61 = Object(_map61)
// 							} else {
// 								_obj_map61 = NIL
// 							}
// 							_vec60 = _vec60.Conjoin(_obj_map61)
// 						}
// 						_map9.Add(MakeKeyword("URIs"), _vec60)
// 						_map9.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem8).PermittedDNSDomainsCritical))
// 						_vec62 := EmptyVector
// 						for _, _elem62 := range (*_elem8).PermittedDNSDomains {
// 							_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 						}
// 						_map9.Add(MakeKeyword("PermittedDNSDomains"), _vec62)
// 						_vec63 := EmptyVector
// 						for _, _elem63 := range (*_elem8).ExcludedDNSDomains {
// 							_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedDNSDomains"), _vec63)
// 						_vec64 := EmptyVector
// 						for _, _elem64 := range (*_elem8).PermittedIPRanges {
// 							var _obj_map65 Object
// 							if _elem64 != nil {
// 								_map65 := EmptyArrayMap()
// 								_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 								_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 								_obj_map65 = Object(_map65)
// 							} else {
// 								_obj_map65 = NIL
// 							}
// 							_vec64 = _vec64.Conjoin(_obj_map65)
// 						}
// 						_map9.Add(MakeKeyword("PermittedIPRanges"), _vec64)
// 						_vec66 := EmptyVector
// 						for _, _elem66 := range (*_elem8).ExcludedIPRanges {
// 							var _obj_map67 Object
// 							if _elem66 != nil {
// 								_map67 := EmptyArrayMap()
// 								_map67.Add(MakeKeyword("IP"), (*_elem66).IP)
// 								_map67.Add(MakeKeyword("Mask"), (*_elem66).Mask)
// 								_obj_map67 = Object(_map67)
// 							} else {
// 								_obj_map67 = NIL
// 							}
// 							_vec66 = _vec66.Conjoin(_obj_map67)
// 						}
// 						_map9.Add(MakeKeyword("ExcludedIPRanges"), _vec66)
// 						_vec68 := EmptyVector
// 						for _, _elem68 := range (*_elem8).PermittedEmailAddresses {
// 							_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 						}
// 						_map9.Add(MakeKeyword("PermittedEmailAddresses"), _vec68)
// 						_vec69 := EmptyVector
// 						for _, _elem69 := range (*_elem8).ExcludedEmailAddresses {
// 							_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedEmailAddresses"), _vec69)
// 						_vec70 := EmptyVector
// 						for _, _elem70 := range (*_elem8).PermittedURIDomains {
// 							_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 						}
// 						_map9.Add(MakeKeyword("PermittedURIDomains"), _vec70)
// 						_vec71 := EmptyVector
// 						for _, _elem71 := range (*_elem8).ExcludedURIDomains {
// 							_vec71 = _vec71.Conjoin(MakeString(_elem71))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedURIDomains"), _vec71)
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range (*_elem8).CRLDistributionPoints {
// 							_vec72 = _vec72.Conjoin(MakeString(_elem72))
// 						}
// 						_map9.Add(MakeKeyword("CRLDistributionPoints"), _vec72)
// 						_vec73 := EmptyVector
// 						for _, _elem73 := range (*_elem8).PolicyIdentifiers {
// 							_vec74 := EmptyVector
// 							for _, _elem74 := range _elem73 {
// 								_vec74 = _vec74.Conjoin(MakeInt(_elem74))
// 							}
// 							_vec73 = _vec73.Conjoin(_vec74)
// 						}
// 						_map9.Add(MakeKeyword("PolicyIdentifiers"), _vec73)
// 						_obj_map9 = Object(_map9)
// 					} else {
// 						_obj_map9 = NIL
// 					}
// 					_vec8 = _vec8.Conjoin(_obj_map9)
// 				}
// 				_map7.Add(MakeKeyword("PeerCertificates"), _vec8)
// 				_vec75 := EmptyVector
// 				for _, _elem75 := range (*(*(*resp).Request).TLS).VerifiedChains {
// 					_vec76 := EmptyVector
// 					for _, _elem76 := range _elem75 {
// 						var _obj_map77 Object
// 						if _elem76 != nil {
// 							_map77 := EmptyArrayMap()
// 							_vec78 := EmptyVector
// 							for _, _elem78 := range (*_elem76).Raw {
// 								_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 							}
// 							_map77.Add(MakeKeyword("Raw"), _vec78)
// 							_vec79 := EmptyVector
// 							for _, _elem79 := range (*_elem76).RawTBSCertificate {
// 								_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 							}
// 							_map77.Add(MakeKeyword("RawTBSCertificate"), _vec79)
// 							_vec80 := EmptyVector
// 							for _, _elem80 := range (*_elem76).RawSubjectPublicKeyInfo {
// 								_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec80)
// 							_vec81 := EmptyVector
// 							for _, _elem81 := range (*_elem76).RawSubject {
// 								_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubject"), _vec81)
// 							_vec82 := EmptyVector
// 							for _, _elem82 := range (*_elem76).RawIssuer {
// 								_vec82 = _vec82.Conjoin(MakeInt(int(_elem82)))
// 							}
// 							_map77.Add(MakeKeyword("RawIssuer"), _vec82)
// 							_vec83 := EmptyVector
// 							for _, _elem83 := range (*_elem76).Signature {
// 								_vec83 = _vec83.Conjoin(MakeInt(int(_elem83)))
// 							}
// 							_map77.Add(MakeKeyword("Signature"), _vec83)
// 							_map77.Add(MakeKeyword("SignatureAlgorithm"), (*_elem76).SignatureAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem76).PublicKeyAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKey"), (*_elem76).PublicKey)
// 							_map77.Add(MakeKeyword("Version"), MakeInt((*_elem76).Version))
// 							_map77.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map85 := EmptyArrayMap()
// 							_vec86 := EmptyVector
// 							for _, _elem86 := range (*_elem76).Issuer.Country {
// 								_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 							}
// 							_map85.Add(MakeKeyword("Country"), _vec86)
// 							_vec87 := EmptyVector
// 							for _, _elem87 := range (*_elem76).Issuer.Organization {
// 								_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 							}
// 							_map85.Add(MakeKeyword("Organization"), _vec87)
// 							_vec88 := EmptyVector
// 							for _, _elem88 := range (*_elem76).Issuer.OrganizationalUnit {
// 								_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 							}
// 							_map85.Add(MakeKeyword("OrganizationalUnit"), _vec88)
// 							_vec89 := EmptyVector
// 							for _, _elem89 := range (*_elem76).Issuer.Locality {
// 								_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 							}
// 							_map85.Add(MakeKeyword("Locality"), _vec89)
// 							_vec90 := EmptyVector
// 							for _, _elem90 := range (*_elem76).Issuer.Province {
// 								_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 							}
// 							_map85.Add(MakeKeyword("Province"), _vec90)
// 							_vec91 := EmptyVector
// 							for _, _elem91 := range (*_elem76).Issuer.StreetAddress {
// 								_vec91 = _vec91.Conjoin(MakeString(_elem91))
// 							}
// 							_map85.Add(MakeKeyword("StreetAddress"), _vec91)
// 							_vec92 := EmptyVector
// 							for _, _elem92 := range (*_elem76).Issuer.PostalCode {
// 								_vec92 = _vec92.Conjoin(MakeString(_elem92))
// 							}
// 							_map85.Add(MakeKeyword("PostalCode"), _vec92)
// 							_map85.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Issuer.SerialNumber))
// 							_map85.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Issuer.CommonName))
// 							_vec93 := EmptyVector
// 							for _, _elem93 := range (*_elem76).Issuer.Names {
// 								_vec93 = _vec93.Conjoin(_elem93)
// 							}
// 							_map85.Add(MakeKeyword("Names"), _vec93)
// 							_vec94 := EmptyVector
// 							for _, _elem94 := range (*_elem76).Issuer.ExtraNames {
// 								_vec94 = _vec94.Conjoin(_elem94)
// 							}
// 							_map85.Add(MakeKeyword("ExtraNames"), _vec94)
// 							_map77.Add(MakeKeyword("Issuer"), _map85)
// 							_map95 := EmptyArrayMap()
// 							_vec96 := EmptyVector
// 							for _, _elem96 := range (*_elem76).Subject.Country {
// 								_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 							}
// 							_map95.Add(MakeKeyword("Country"), _vec96)
// 							_vec97 := EmptyVector
// 							for _, _elem97 := range (*_elem76).Subject.Organization {
// 								_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 							}
// 							_map95.Add(MakeKeyword("Organization"), _vec97)
// 							_vec98 := EmptyVector
// 							for _, _elem98 := range (*_elem76).Subject.OrganizationalUnit {
// 								_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 							}
// 							_map95.Add(MakeKeyword("OrganizationalUnit"), _vec98)
// 							_vec99 := EmptyVector
// 							for _, _elem99 := range (*_elem76).Subject.Locality {
// 								_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 							}
// 							_map95.Add(MakeKeyword("Locality"), _vec99)
// 							_vec100 := EmptyVector
// 							for _, _elem100 := range (*_elem76).Subject.Province {
// 								_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 							}
// 							_map95.Add(MakeKeyword("Province"), _vec100)
// 							_vec101 := EmptyVector
// 							for _, _elem101 := range (*_elem76).Subject.StreetAddress {
// 								_vec101 = _vec101.Conjoin(MakeString(_elem101))
// 							}
// 							_map95.Add(MakeKeyword("StreetAddress"), _vec101)
// 							_vec102 := EmptyVector
// 							for _, _elem102 := range (*_elem76).Subject.PostalCode {
// 								_vec102 = _vec102.Conjoin(MakeString(_elem102))
// 							}
// 							_map95.Add(MakeKeyword("PostalCode"), _vec102)
// 							_map95.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Subject.SerialNumber))
// 							_map95.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Subject.CommonName))
// 							_vec103 := EmptyVector
// 							for _, _elem103 := range (*_elem76).Subject.Names {
// 								_vec103 = _vec103.Conjoin(_elem103)
// 							}
// 							_map95.Add(MakeKeyword("Names"), _vec103)
// 							_vec104 := EmptyVector
// 							for _, _elem104 := range (*_elem76).Subject.ExtraNames {
// 								_vec104 = _vec104.Conjoin(_elem104)
// 							}
// 							_map95.Add(MakeKeyword("ExtraNames"), _vec104)
// 							_map77.Add(MakeKeyword("Subject"), _map95)
// 							_map77.Add(MakeKeyword("NotBefore"), NIL)
// 							_map77.Add(MakeKeyword("NotAfter"), NIL)
// 							_map77.Add(MakeKeyword("KeyUsage"), (*_elem76).KeyUsage)
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range (*_elem76).Extensions {
// 								_map108 := EmptyArrayMap()
// 								_vec109 := EmptyVector
// 								for _, _elem109 := range _elem107.Id {
// 									_vec109 = _vec109.Conjoin(MakeInt(_elem109))
// 								}
// 								_map108.Add(MakeKeyword("Id"), _vec109)
// 								_map108.Add(MakeKeyword("Critical"), MakeBool(_elem107.Critical))
// 								_vec110 := EmptyVector
// 								for _, _elem110 := range _elem107.Value {
// 									_vec110 = _vec110.Conjoin(MakeInt(int(_elem110)))
// 								}
// 								_map108.Add(MakeKeyword("Value"), _vec110)
// 								_vec107 = _vec107.Conjoin(_map108)
// 							}
// 							_map77.Add(MakeKeyword("Extensions"), _vec107)
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range (*_elem76).ExtraExtensions {
// 								_map112 := EmptyArrayMap()
// 								_vec113 := EmptyVector
// 								for _, _elem113 := range _elem111.Id {
// 									_vec113 = _vec113.Conjoin(MakeInt(_elem113))
// 								}
// 								_map112.Add(MakeKeyword("Id"), _vec113)
// 								_map112.Add(MakeKeyword("Critical"), MakeBool(_elem111.Critical))
// 								_vec114 := EmptyVector
// 								for _, _elem114 := range _elem111.Value {
// 									_vec114 = _vec114.Conjoin(MakeInt(int(_elem114)))
// 								}
// 								_map112.Add(MakeKeyword("Value"), _vec114)
// 								_vec111 = _vec111.Conjoin(_map112)
// 							}
// 							_map77.Add(MakeKeyword("ExtraExtensions"), _vec111)
// 							_vec115 := EmptyVector
// 							for _, _elem115 := range (*_elem76).UnhandledCriticalExtensions {
// 								_vec116 := EmptyVector
// 								for _, _elem116 := range _elem115 {
// 									_vec116 = _vec116.Conjoin(MakeInt(_elem116))
// 								}
// 								_vec115 = _vec115.Conjoin(_vec116)
// 							}
// 							_map77.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec115)
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range (*_elem76).ExtKeyUsage {
// 								_vec117 = _vec117.Conjoin(_elem117)
// 							}
// 							_map77.Add(MakeKeyword("ExtKeyUsage"), _vec117)
// 							_vec118 := EmptyVector
// 							for _, _elem118 := range (*_elem76).UnknownExtKeyUsage {
// 								_vec119 := EmptyVector
// 								for _, _elem119 := range _elem118 {
// 									_vec119 = _vec119.Conjoin(MakeInt(_elem119))
// 								}
// 								_vec118 = _vec118.Conjoin(_vec119)
// 							}
// 							_map77.Add(MakeKeyword("UnknownExtKeyUsage"), _vec118)
// 							_map77.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem76).BasicConstraintsValid))
// 							_map77.Add(MakeKeyword("IsCA"), MakeBool((*_elem76).IsCA))
// 							_map77.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem76).MaxPathLen))
// 							_map77.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem76).MaxPathLenZero))
// 							_vec120 := EmptyVector
// 							for _, _elem120 := range (*_elem76).SubjectKeyId {
// 								_vec120 = _vec120.Conjoin(MakeInt(int(_elem120)))
// 							}
// 							_map77.Add(MakeKeyword("SubjectKeyId"), _vec120)
// 							_vec121 := EmptyVector
// 							for _, _elem121 := range (*_elem76).AuthorityKeyId {
// 								_vec121 = _vec121.Conjoin(MakeInt(int(_elem121)))
// 							}
// 							_map77.Add(MakeKeyword("AuthorityKeyId"), _vec121)
// 							_vec122 := EmptyVector
// 							for _, _elem122 := range (*_elem76).OCSPServer {
// 								_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 							}
// 							_map77.Add(MakeKeyword("OCSPServer"), _vec122)
// 							_vec123 := EmptyVector
// 							for _, _elem123 := range (*_elem76).IssuingCertificateURL {
// 								_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 							}
// 							_map77.Add(MakeKeyword("IssuingCertificateURL"), _vec123)
// 							_vec124 := EmptyVector
// 							for _, _elem124 := range (*_elem76).DNSNames {
// 								_vec124 = _vec124.Conjoin(MakeString(_elem124))
// 							}
// 							_map77.Add(MakeKeyword("DNSNames"), _vec124)
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range (*_elem76).EmailAddresses {
// 								_vec125 = _vec125.Conjoin(MakeString(_elem125))
// 							}
// 							_map77.Add(MakeKeyword("EmailAddresses"), _vec125)
// 							_vec126 := EmptyVector
// 							for _, _elem126 := range (*_elem76).IPAddresses {
// 								_vec127 := EmptyVector
// 								for _, _elem127 := range _elem126 {
// 									_vec127 = _vec127.Conjoin(MakeInt(int(_elem127)))
// 								}
// 								_vec126 = _vec126.Conjoin(_vec127)
// 							}
// 							_map77.Add(MakeKeyword("IPAddresses"), _vec126)
// 							_vec128 := EmptyVector
// 							for _, _elem128 := range (*_elem76).URIs {
// 								var _obj_map129 Object
// 								if _elem128 != nil {
// 									_map129 := EmptyArrayMap()
// 									_map129.Add(MakeKeyword("Scheme"), MakeString((*_elem128).Scheme))
// 									_map129.Add(MakeKeyword("Opaque"), MakeString((*_elem128).Opaque))
// 									_map129.Add(MakeKeyword("User"), (*(*_elem128).User))
// 									_map129.Add(MakeKeyword("Host"), MakeString((*_elem128).Host))
// 									_map129.Add(MakeKeyword("Path"), MakeString((*_elem128).Path))
// 									_map129.Add(MakeKeyword("RawPath"), MakeString((*_elem128).RawPath))
// 									_map129.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem128).ForceQuery))
// 									_map129.Add(MakeKeyword("RawQuery"), MakeString((*_elem128).RawQuery))
// 									_map129.Add(MakeKeyword("Fragment"), MakeString((*_elem128).Fragment))
// 									_obj_map129 = Object(_map129)
// 								} else {
// 									_obj_map129 = NIL
// 								}
// 								_vec128 = _vec128.Conjoin(_obj_map129)
// 							}
// 							_map77.Add(MakeKeyword("URIs"), _vec128)
// 							_map77.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem76).PermittedDNSDomainsCritical))
// 							_vec130 := EmptyVector
// 							for _, _elem130 := range (*_elem76).PermittedDNSDomains {
// 								_vec130 = _vec130.Conjoin(MakeString(_elem130))
// 							}
// 							_map77.Add(MakeKeyword("PermittedDNSDomains"), _vec130)
// 							_vec131 := EmptyVector
// 							for _, _elem131 := range (*_elem76).ExcludedDNSDomains {
// 								_vec131 = _vec131.Conjoin(MakeString(_elem131))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedDNSDomains"), _vec131)
// 							_vec132 := EmptyVector
// 							for _, _elem132 := range (*_elem76).PermittedIPRanges {
// 								var _obj_map133 Object
// 								if _elem132 != nil {
// 									_map133 := EmptyArrayMap()
// 									_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 									_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 									_obj_map133 = Object(_map133)
// 								} else {
// 									_obj_map133 = NIL
// 								}
// 								_vec132 = _vec132.Conjoin(_obj_map133)
// 							}
// 							_map77.Add(MakeKeyword("PermittedIPRanges"), _vec132)
// 							_vec134 := EmptyVector
// 							for _, _elem134 := range (*_elem76).ExcludedIPRanges {
// 								var _obj_map135 Object
// 								if _elem134 != nil {
// 									_map135 := EmptyArrayMap()
// 									_map135.Add(MakeKeyword("IP"), (*_elem134).IP)
// 									_map135.Add(MakeKeyword("Mask"), (*_elem134).Mask)
// 									_obj_map135 = Object(_map135)
// 								} else {
// 									_obj_map135 = NIL
// 								}
// 								_vec134 = _vec134.Conjoin(_obj_map135)
// 							}
// 							_map77.Add(MakeKeyword("ExcludedIPRanges"), _vec134)
// 							_vec136 := EmptyVector
// 							for _, _elem136 := range (*_elem76).PermittedEmailAddresses {
// 								_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 							}
// 							_map77.Add(MakeKeyword("PermittedEmailAddresses"), _vec136)
// 							_vec137 := EmptyVector
// 							for _, _elem137 := range (*_elem76).ExcludedEmailAddresses {
// 								_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedEmailAddresses"), _vec137)
// 							_vec138 := EmptyVector
// 							for _, _elem138 := range (*_elem76).PermittedURIDomains {
// 								_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 							}
// 							_map77.Add(MakeKeyword("PermittedURIDomains"), _vec138)
// 							_vec139 := EmptyVector
// 							for _, _elem139 := range (*_elem76).ExcludedURIDomains {
// 								_vec139 = _vec139.Conjoin(MakeString(_elem139))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedURIDomains"), _vec139)
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range (*_elem76).CRLDistributionPoints {
// 								_vec140 = _vec140.Conjoin(MakeString(_elem140))
// 							}
// 							_map77.Add(MakeKeyword("CRLDistributionPoints"), _vec140)
// 							_vec141 := EmptyVector
// 							for _, _elem141 := range (*_elem76).PolicyIdentifiers {
// 								_vec142 := EmptyVector
// 								for _, _elem142 := range _elem141 {
// 									_vec142 = _vec142.Conjoin(MakeInt(_elem142))
// 								}
// 								_vec141 = _vec141.Conjoin(_vec142)
// 							}
// 							_map77.Add(MakeKeyword("PolicyIdentifiers"), _vec141)
// 							_obj_map77 = Object(_map77)
// 						} else {
// 							_obj_map77 = NIL
// 						}
// 						_vec76 = _vec76.Conjoin(_obj_map77)
// 					}
// 					_vec75 = _vec75.Conjoin(_vec76)
// 				}
// 				_map7.Add(MakeKeyword("VerifiedChains"), _vec75)
// 				_vec143 := EmptyVector
// 				for _, _elem143 := range (*(*(*resp).Request).TLS).SignedCertificateTimestamps {
// 					_vec144 := EmptyVector
// 					for _, _elem144 := range _elem143 {
// 						_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 					}
// 					_vec143 = _vec143.Conjoin(_vec144)
// 				}
// 				_map7.Add(MakeKeyword("SignedCertificateTimestamps"), _vec143)
// 				_vec145 := EmptyVector
// 				for _, _elem145 := range (*(*(*resp).Request).TLS).OCSPResponse {
// 					_vec145 = _vec145.Conjoin(MakeInt(int(_elem145)))
// 				}
// 				_map7.Add(MakeKeyword("OCSPResponse"), _vec145)
// 				_vec146 := EmptyVector
// 				for _, _elem146 := range (*(*(*resp).Request).TLS).TLSUnique {
// 					_vec146 = _vec146.Conjoin(MakeInt(int(_elem146)))
// 				}
// 				_map7.Add(MakeKeyword("TLSUnique"), _vec146)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_map3.Add(MakeKeyword("TLS"), _obj_map7)
// 			_map3.Add(MakeKeyword("Cancel"), (*(*resp).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		var _obj_map147 Object
// 		if (*resp).TLS != nil {
// 			_map147 := EmptyArrayMap()
// 			_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*resp).TLS).Version)))
// 			_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*resp).TLS).HandshakeComplete))
// 			_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*resp).TLS).DidResume))
// 			_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*resp).TLS).CipherSuite)))
// 			_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*resp).TLS).NegotiatedProtocol))
// 			_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*resp).TLS).NegotiatedProtocolIsMutual))
// 			_map147.Add(MakeKeyword("ServerName"), MakeString((*(*resp).TLS).ServerName))
// 			_vec148 := EmptyVector
// 			for _, _elem148 := range (*(*resp).TLS).PeerCertificates {
// 				var _obj_map149 Object
// 				if _elem148 != nil {
// 					_map149 := EmptyArrayMap()
// 					_vec150 := EmptyVector
// 					for _, _elem150 := range (*_elem148).Raw {
// 						_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 					}
// 					_map149.Add(MakeKeyword("Raw"), _vec150)
// 					_vec151 := EmptyVector
// 					for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 						_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 					}
// 					_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 					_vec152 := EmptyVector
// 					for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 						_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 					_vec153 := EmptyVector
// 					for _, _elem153 := range (*_elem148).RawSubject {
// 						_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 					_vec154 := EmptyVector
// 					for _, _elem154 := range (*_elem148).RawIssuer {
// 						_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 					}
// 					_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 					_vec155 := EmptyVector
// 					for _, _elem155 := range (*_elem148).Signature {
// 						_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 					}
// 					_map149.Add(MakeKeyword("Signature"), _vec155)
// 					_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 					_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 					_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map157 := EmptyArrayMap()
// 					_vec158 := EmptyVector
// 					for _, _elem158 := range (*_elem148).Issuer.Country {
// 						_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 					}
// 					_map157.Add(MakeKeyword("Country"), _vec158)
// 					_vec159 := EmptyVector
// 					for _, _elem159 := range (*_elem148).Issuer.Organization {
// 						_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 					}
// 					_map157.Add(MakeKeyword("Organization"), _vec159)
// 					_vec160 := EmptyVector
// 					for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 						_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 					}
// 					_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 					_vec161 := EmptyVector
// 					for _, _elem161 := range (*_elem148).Issuer.Locality {
// 						_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 					}
// 					_map157.Add(MakeKeyword("Locality"), _vec161)
// 					_vec162 := EmptyVector
// 					for _, _elem162 := range (*_elem148).Issuer.Province {
// 						_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 					}
// 					_map157.Add(MakeKeyword("Province"), _vec162)
// 					_vec163 := EmptyVector
// 					for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 						_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 					}
// 					_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 					_vec164 := EmptyVector
// 					for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 						_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 					}
// 					_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 					_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 					_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 					_vec165 := EmptyVector
// 					for _, _elem165 := range (*_elem148).Issuer.Names {
// 						_vec165 = _vec165.Conjoin(_elem165)
// 					}
// 					_map157.Add(MakeKeyword("Names"), _vec165)
// 					_vec166 := EmptyVector
// 					for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 						_vec166 = _vec166.Conjoin(_elem166)
// 					}
// 					_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 					_map149.Add(MakeKeyword("Issuer"), _map157)
// 					_map167 := EmptyArrayMap()
// 					_vec168 := EmptyVector
// 					for _, _elem168 := range (*_elem148).Subject.Country {
// 						_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 					}
// 					_map167.Add(MakeKeyword("Country"), _vec168)
// 					_vec169 := EmptyVector
// 					for _, _elem169 := range (*_elem148).Subject.Organization {
// 						_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 					}
// 					_map167.Add(MakeKeyword("Organization"), _vec169)
// 					_vec170 := EmptyVector
// 					for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 						_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 					}
// 					_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 					_vec171 := EmptyVector
// 					for _, _elem171 := range (*_elem148).Subject.Locality {
// 						_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 					}
// 					_map167.Add(MakeKeyword("Locality"), _vec171)
// 					_vec172 := EmptyVector
// 					for _, _elem172 := range (*_elem148).Subject.Province {
// 						_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 					}
// 					_map167.Add(MakeKeyword("Province"), _vec172)
// 					_vec173 := EmptyVector
// 					for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 						_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 					}
// 					_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 					_vec174 := EmptyVector
// 					for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 						_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 					}
// 					_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 					_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 					_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 					_vec175 := EmptyVector
// 					for _, _elem175 := range (*_elem148).Subject.Names {
// 						_vec175 = _vec175.Conjoin(_elem175)
// 					}
// 					_map167.Add(MakeKeyword("Names"), _vec175)
// 					_vec176 := EmptyVector
// 					for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 						_vec176 = _vec176.Conjoin(_elem176)
// 					}
// 					_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 					_map149.Add(MakeKeyword("Subject"), _map167)
// 					_map149.Add(MakeKeyword("NotBefore"), NIL)
// 					_map149.Add(MakeKeyword("NotAfter"), NIL)
// 					_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 					_vec179 := EmptyVector
// 					for _, _elem179 := range (*_elem148).Extensions {
// 						_map180 := EmptyArrayMap()
// 						_vec181 := EmptyVector
// 						for _, _elem181 := range _elem179.Id {
// 							_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 						}
// 						_map180.Add(MakeKeyword("Id"), _vec181)
// 						_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 						_vec182 := EmptyVector
// 						for _, _elem182 := range _elem179.Value {
// 							_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 						}
// 						_map180.Add(MakeKeyword("Value"), _vec182)
// 						_vec179 = _vec179.Conjoin(_map180)
// 					}
// 					_map149.Add(MakeKeyword("Extensions"), _vec179)
// 					_vec183 := EmptyVector
// 					for _, _elem183 := range (*_elem148).ExtraExtensions {
// 						_map184 := EmptyArrayMap()
// 						_vec185 := EmptyVector
// 						for _, _elem185 := range _elem183.Id {
// 							_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 						}
// 						_map184.Add(MakeKeyword("Id"), _vec185)
// 						_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 						_vec186 := EmptyVector
// 						for _, _elem186 := range _elem183.Value {
// 							_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 						}
// 						_map184.Add(MakeKeyword("Value"), _vec186)
// 						_vec183 = _vec183.Conjoin(_map184)
// 					}
// 					_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 					_vec187 := EmptyVector
// 					for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 						_vec188 := EmptyVector
// 						for _, _elem188 := range _elem187 {
// 							_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 						}
// 						_vec187 = _vec187.Conjoin(_vec188)
// 					}
// 					_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 					_vec189 := EmptyVector
// 					for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 						_vec189 = _vec189.Conjoin(_elem189)
// 					}
// 					_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 					_vec190 := EmptyVector
// 					for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 						_vec191 := EmptyVector
// 						for _, _elem191 := range _elem190 {
// 							_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 						}
// 						_vec190 = _vec190.Conjoin(_vec191)
// 					}
// 					_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 					_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 					_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 					_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 					_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 					_vec192 := EmptyVector
// 					for _, _elem192 := range (*_elem148).SubjectKeyId {
// 						_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 					}
// 					_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 					_vec193 := EmptyVector
// 					for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 						_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 					}
// 					_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 					_vec194 := EmptyVector
// 					for _, _elem194 := range (*_elem148).OCSPServer {
// 						_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 					}
// 					_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 					_vec195 := EmptyVector
// 					for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 						_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 					}
// 					_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 					_vec196 := EmptyVector
// 					for _, _elem196 := range (*_elem148).DNSNames {
// 						_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 					}
// 					_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 					_vec197 := EmptyVector
// 					for _, _elem197 := range (*_elem148).EmailAddresses {
// 						_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 					}
// 					_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 					_vec198 := EmptyVector
// 					for _, _elem198 := range (*_elem148).IPAddresses {
// 						_vec199 := EmptyVector
// 						for _, _elem199 := range _elem198 {
// 							_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 						}
// 						_vec198 = _vec198.Conjoin(_vec199)
// 					}
// 					_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 					_vec200 := EmptyVector
// 					for _, _elem200 := range (*_elem148).URIs {
// 						var _obj_map201 Object
// 						if _elem200 != nil {
// 							_map201 := EmptyArrayMap()
// 							_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 							_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 							_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 							_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 							_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 							_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 							_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 							_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 							_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 							_obj_map201 = Object(_map201)
// 						} else {
// 							_obj_map201 = NIL
// 						}
// 						_vec200 = _vec200.Conjoin(_obj_map201)
// 					}
// 					_map149.Add(MakeKeyword("URIs"), _vec200)
// 					_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 					_vec202 := EmptyVector
// 					for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 						_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 					}
// 					_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 					_vec203 := EmptyVector
// 					for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 						_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 					_vec204 := EmptyVector
// 					for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 						var _obj_map205 Object
// 						if _elem204 != nil {
// 							_map205 := EmptyArrayMap()
// 							_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 							_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 							_obj_map205 = Object(_map205)
// 						} else {
// 							_obj_map205 = NIL
// 						}
// 						_vec204 = _vec204.Conjoin(_obj_map205)
// 					}
// 					_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 					_vec206 := EmptyVector
// 					for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 						var _obj_map207 Object
// 						if _elem206 != nil {
// 							_map207 := EmptyArrayMap()
// 							_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 							_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 							_obj_map207 = Object(_map207)
// 						} else {
// 							_obj_map207 = NIL
// 						}
// 						_vec206 = _vec206.Conjoin(_obj_map207)
// 					}
// 					_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 					_vec208 := EmptyVector
// 					for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 						_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 					}
// 					_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 					_vec209 := EmptyVector
// 					for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 						_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 					_vec210 := EmptyVector
// 					for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 						_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 					}
// 					_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 					_vec211 := EmptyVector
// 					for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 						_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 					_vec212 := EmptyVector
// 					for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 						_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 					}
// 					_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 					_vec213 := EmptyVector
// 					for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 						_vec214 := EmptyVector
// 						for _, _elem214 := range _elem213 {
// 							_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 						}
// 						_vec213 = _vec213.Conjoin(_vec214)
// 					}
// 					_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 					_obj_map149 = Object(_map149)
// 				} else {
// 					_obj_map149 = NIL
// 				}
// 				_vec148 = _vec148.Conjoin(_obj_map149)
// 			}
// 			_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 			_vec215 := EmptyVector
// 			for _, _elem215 := range (*(*resp).TLS).VerifiedChains {
// 				_vec216 := EmptyVector
// 				for _, _elem216 := range _elem215 {
// 					var _obj_map217 Object
// 					if _elem216 != nil {
// 						_map217 := EmptyArrayMap()
// 						_vec218 := EmptyVector
// 						for _, _elem218 := range (*_elem216).Raw {
// 							_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 						}
// 						_map217.Add(MakeKeyword("Raw"), _vec218)
// 						_vec219 := EmptyVector
// 						for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 							_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 						}
// 						_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 						_vec220 := EmptyVector
// 						for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 							_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 						_vec221 := EmptyVector
// 						for _, _elem221 := range (*_elem216).RawSubject {
// 							_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 						_vec222 := EmptyVector
// 						for _, _elem222 := range (*_elem216).RawIssuer {
// 							_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 						}
// 						_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 						_vec223 := EmptyVector
// 						for _, _elem223 := range (*_elem216).Signature {
// 							_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 						}
// 						_map217.Add(MakeKeyword("Signature"), _vec223)
// 						_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 						_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 						_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map225 := EmptyArrayMap()
// 						_vec226 := EmptyVector
// 						for _, _elem226 := range (*_elem216).Issuer.Country {
// 							_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 						}
// 						_map225.Add(MakeKeyword("Country"), _vec226)
// 						_vec227 := EmptyVector
// 						for _, _elem227 := range (*_elem216).Issuer.Organization {
// 							_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 						}
// 						_map225.Add(MakeKeyword("Organization"), _vec227)
// 						_vec228 := EmptyVector
// 						for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 							_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 						}
// 						_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 						_vec229 := EmptyVector
// 						for _, _elem229 := range (*_elem216).Issuer.Locality {
// 							_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 						}
// 						_map225.Add(MakeKeyword("Locality"), _vec229)
// 						_vec230 := EmptyVector
// 						for _, _elem230 := range (*_elem216).Issuer.Province {
// 							_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 						}
// 						_map225.Add(MakeKeyword("Province"), _vec230)
// 						_vec231 := EmptyVector
// 						for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 							_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 						}
// 						_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 						_vec232 := EmptyVector
// 						for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 							_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 						}
// 						_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 						_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 						_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 						_vec233 := EmptyVector
// 						for _, _elem233 := range (*_elem216).Issuer.Names {
// 							_vec233 = _vec233.Conjoin(_elem233)
// 						}
// 						_map225.Add(MakeKeyword("Names"), _vec233)
// 						_vec234 := EmptyVector
// 						for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 							_vec234 = _vec234.Conjoin(_elem234)
// 						}
// 						_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 						_map217.Add(MakeKeyword("Issuer"), _map225)
// 						_map235 := EmptyArrayMap()
// 						_vec236 := EmptyVector
// 						for _, _elem236 := range (*_elem216).Subject.Country {
// 							_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 						}
// 						_map235.Add(MakeKeyword("Country"), _vec236)
// 						_vec237 := EmptyVector
// 						for _, _elem237 := range (*_elem216).Subject.Organization {
// 							_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 						}
// 						_map235.Add(MakeKeyword("Organization"), _vec237)
// 						_vec238 := EmptyVector
// 						for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 							_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 						}
// 						_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 						_vec239 := EmptyVector
// 						for _, _elem239 := range (*_elem216).Subject.Locality {
// 							_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 						}
// 						_map235.Add(MakeKeyword("Locality"), _vec239)
// 						_vec240 := EmptyVector
// 						for _, _elem240 := range (*_elem216).Subject.Province {
// 							_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 						}
// 						_map235.Add(MakeKeyword("Province"), _vec240)
// 						_vec241 := EmptyVector
// 						for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 							_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 						}
// 						_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 						_vec242 := EmptyVector
// 						for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 							_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 						}
// 						_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 						_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 						_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 						_vec243 := EmptyVector
// 						for _, _elem243 := range (*_elem216).Subject.Names {
// 							_vec243 = _vec243.Conjoin(_elem243)
// 						}
// 						_map235.Add(MakeKeyword("Names"), _vec243)
// 						_vec244 := EmptyVector
// 						for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 							_vec244 = _vec244.Conjoin(_elem244)
// 						}
// 						_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 						_map217.Add(MakeKeyword("Subject"), _map235)
// 						_map217.Add(MakeKeyword("NotBefore"), NIL)
// 						_map217.Add(MakeKeyword("NotAfter"), NIL)
// 						_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 						_vec247 := EmptyVector
// 						for _, _elem247 := range (*_elem216).Extensions {
// 							_map248 := EmptyArrayMap()
// 							_vec249 := EmptyVector
// 							for _, _elem249 := range _elem247.Id {
// 								_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 							}
// 							_map248.Add(MakeKeyword("Id"), _vec249)
// 							_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 							_vec250 := EmptyVector
// 							for _, _elem250 := range _elem247.Value {
// 								_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 							}
// 							_map248.Add(MakeKeyword("Value"), _vec250)
// 							_vec247 = _vec247.Conjoin(_map248)
// 						}
// 						_map217.Add(MakeKeyword("Extensions"), _vec247)
// 						_vec251 := EmptyVector
// 						for _, _elem251 := range (*_elem216).ExtraExtensions {
// 							_map252 := EmptyArrayMap()
// 							_vec253 := EmptyVector
// 							for _, _elem253 := range _elem251.Id {
// 								_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 							}
// 							_map252.Add(MakeKeyword("Id"), _vec253)
// 							_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 							_vec254 := EmptyVector
// 							for _, _elem254 := range _elem251.Value {
// 								_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 							}
// 							_map252.Add(MakeKeyword("Value"), _vec254)
// 							_vec251 = _vec251.Conjoin(_map252)
// 						}
// 						_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 						_vec255 := EmptyVector
// 						for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 							_vec256 := EmptyVector
// 							for _, _elem256 := range _elem255 {
// 								_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 							}
// 							_vec255 = _vec255.Conjoin(_vec256)
// 						}
// 						_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 						_vec257 := EmptyVector
// 						for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 							_vec257 = _vec257.Conjoin(_elem257)
// 						}
// 						_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 						_vec258 := EmptyVector
// 						for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 							_vec259 := EmptyVector
// 							for _, _elem259 := range _elem258 {
// 								_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 							}
// 							_vec258 = _vec258.Conjoin(_vec259)
// 						}
// 						_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 						_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 						_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 						_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 						_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 						_vec260 := EmptyVector
// 						for _, _elem260 := range (*_elem216).SubjectKeyId {
// 							_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 						}
// 						_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 						_vec261 := EmptyVector
// 						for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 							_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 						}
// 						_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 						_vec262 := EmptyVector
// 						for _, _elem262 := range (*_elem216).OCSPServer {
// 							_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 						}
// 						_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 						_vec263 := EmptyVector
// 						for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 							_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 						}
// 						_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 						_vec264 := EmptyVector
// 						for _, _elem264 := range (*_elem216).DNSNames {
// 							_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 						}
// 						_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 						_vec265 := EmptyVector
// 						for _, _elem265 := range (*_elem216).EmailAddresses {
// 							_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 						}
// 						_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 						_vec266 := EmptyVector
// 						for _, _elem266 := range (*_elem216).IPAddresses {
// 							_vec267 := EmptyVector
// 							for _, _elem267 := range _elem266 {
// 								_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 							}
// 							_vec266 = _vec266.Conjoin(_vec267)
// 						}
// 						_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 						_vec268 := EmptyVector
// 						for _, _elem268 := range (*_elem216).URIs {
// 							var _obj_map269 Object
// 							if _elem268 != nil {
// 								_map269 := EmptyArrayMap()
// 								_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 								_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 								_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 								_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 								_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 								_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 								_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 								_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 								_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 								_obj_map269 = Object(_map269)
// 							} else {
// 								_obj_map269 = NIL
// 							}
// 							_vec268 = _vec268.Conjoin(_obj_map269)
// 						}
// 						_map217.Add(MakeKeyword("URIs"), _vec268)
// 						_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 						_vec270 := EmptyVector
// 						for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 							_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 						}
// 						_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 						_vec271 := EmptyVector
// 						for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 							_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 						_vec272 := EmptyVector
// 						for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 							var _obj_map273 Object
// 							if _elem272 != nil {
// 								_map273 := EmptyArrayMap()
// 								_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 								_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 								_obj_map273 = Object(_map273)
// 							} else {
// 								_obj_map273 = NIL
// 							}
// 							_vec272 = _vec272.Conjoin(_obj_map273)
// 						}
// 						_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 						_vec274 := EmptyVector
// 						for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 							var _obj_map275 Object
// 							if _elem274 != nil {
// 								_map275 := EmptyArrayMap()
// 								_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 								_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 								_obj_map275 = Object(_map275)
// 							} else {
// 								_obj_map275 = NIL
// 							}
// 							_vec274 = _vec274.Conjoin(_obj_map275)
// 						}
// 						_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 						_vec276 := EmptyVector
// 						for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 							_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 						}
// 						_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 						_vec277 := EmptyVector
// 						for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 							_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 						_vec278 := EmptyVector
// 						for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 							_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 						}
// 						_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 						_vec279 := EmptyVector
// 						for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 							_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 						_vec280 := EmptyVector
// 						for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 							_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 						}
// 						_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 						_vec281 := EmptyVector
// 						for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 							_vec282 := EmptyVector
// 							for _, _elem282 := range _elem281 {
// 								_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 							}
// 							_vec281 = _vec281.Conjoin(_vec282)
// 						}
// 						_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 						_obj_map217 = Object(_map217)
// 					} else {
// 						_obj_map217 = NIL
// 					}
// 					_vec216 = _vec216.Conjoin(_obj_map217)
// 				}
// 				_vec215 = _vec215.Conjoin(_vec216)
// 			}
// 			_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 			_vec283 := EmptyVector
// 			for _, _elem283 := range (*(*resp).TLS).SignedCertificateTimestamps {
// 				_vec284 := EmptyVector
// 				for _, _elem284 := range _elem283 {
// 					_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 				}
// 				_vec283 = _vec283.Conjoin(_vec284)
// 			}
// 			_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 			_vec285 := EmptyVector
// 			for _, _elem285 := range (*(*resp).TLS).OCSPResponse {
// 				_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 			}
// 			_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 			_vec286 := EmptyVector
// 			for _, _elem286 := range (*(*resp).TLS).TLSUnique {
// 				_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 			}
// 			_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 			_obj_map147 = Object(_map147)
// 		} else {
// 			_obj_map147 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map147)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/http.ProxyFromEnvironment:
// func proxyFromEnvironment(req *net/http.Request) Object {
// 	_res1, _res2 := _http.ProxyFromEnvironment(req)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
// 		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
// 		_map1.Add(MakeKeyword("User"), (*(*_res1).User))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
// 		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
// 		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
// 		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
// 		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ProxyURL:
// func proxyURL(fixedURL *net/url.URL) Object {
// 	return _http.ProxyURL(fixedURL)
// }

GO FUNC net/http.ReadRequest:
// func readRequest(b *bufio.Reader) Object {
// 	_res1, _res2 := _http.ReadRequest(b)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		var _obj_map4 Object
// 		if (*_res1).MultipartForm != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Value"), (*(*_res1).MultipartForm).Value)
// 			_map4.Add(MakeKeyword("File"), (*(*_res1).MultipartForm).File)
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("MultipartForm"), _obj_map4)
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		var _obj_map5 Object
// 		if (*_res1).TLS != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("Version"), MakeInt(int((*(*_res1).TLS).Version)))
// 			_map5.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res1).TLS).HandshakeComplete))
// 			_map5.Add(MakeKeyword("DidResume"), MakeBool((*(*_res1).TLS).DidResume))
// 			_map5.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res1).TLS).CipherSuite)))
// 			_map5.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res1).TLS).NegotiatedProtocol))
// 			_map5.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res1).TLS).NegotiatedProtocolIsMutual))
// 			_map5.Add(MakeKeyword("ServerName"), MakeString((*(*_res1).TLS).ServerName))
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*(*_res1).TLS).PeerCertificates {
// 				var _obj_map7 Object
// 				if _elem6 != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*_elem6).Raw {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Raw"), _vec8)
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*_elem6).RawTBSCertificate {
// 						_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 					}
// 					_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem6).RawSubjectPublicKeyInfo {
// 						_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*_elem6).RawSubject {
// 						_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*_elem6).RawIssuer {
// 						_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 					}
// 					_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*_elem6).Signature {
// 						_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 					}
// 					_map7.Add(MakeKeyword("Signature"), _vec13)
// 					_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_elem6).SignatureAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem6).PublicKeyAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKey"), (*_elem6).PublicKey)
// 					_map7.Add(MakeKeyword("Version"), MakeInt((*_elem6).Version))
// 					_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map15 := EmptyArrayMap()
// 					_vec16 := EmptyVector
// 					for _, _elem16 := range (*_elem6).Issuer.Country {
// 						_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 					}
// 					_map15.Add(MakeKeyword("Country"), _vec16)
// 					_vec17 := EmptyVector
// 					for _, _elem17 := range (*_elem6).Issuer.Organization {
// 						_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 					}
// 					_map15.Add(MakeKeyword("Organization"), _vec17)
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*_elem6).Issuer.OrganizationalUnit {
// 						_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 					}
// 					_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 					_vec19 := EmptyVector
// 					for _, _elem19 := range (*_elem6).Issuer.Locality {
// 						_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 					}
// 					_map15.Add(MakeKeyword("Locality"), _vec19)
// 					_vec20 := EmptyVector
// 					for _, _elem20 := range (*_elem6).Issuer.Province {
// 						_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 					}
// 					_map15.Add(MakeKeyword("Province"), _vec20)
// 					_vec21 := EmptyVector
// 					for _, _elem21 := range (*_elem6).Issuer.StreetAddress {
// 						_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 					}
// 					_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 					_vec22 := EmptyVector
// 					for _, _elem22 := range (*_elem6).Issuer.PostalCode {
// 						_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 					}
// 					_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 					_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Issuer.SerialNumber))
// 					_map15.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Issuer.CommonName))
// 					_vec23 := EmptyVector
// 					for _, _elem23 := range (*_elem6).Issuer.Names {
// 						_vec23 = _vec23.Conjoin(_elem23)
// 					}
// 					_map15.Add(MakeKeyword("Names"), _vec23)
// 					_vec24 := EmptyVector
// 					for _, _elem24 := range (*_elem6).Issuer.ExtraNames {
// 						_vec24 = _vec24.Conjoin(_elem24)
// 					}
// 					_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 					_map7.Add(MakeKeyword("Issuer"), _map15)
// 					_map25 := EmptyArrayMap()
// 					_vec26 := EmptyVector
// 					for _, _elem26 := range (*_elem6).Subject.Country {
// 						_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 					}
// 					_map25.Add(MakeKeyword("Country"), _vec26)
// 					_vec27 := EmptyVector
// 					for _, _elem27 := range (*_elem6).Subject.Organization {
// 						_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 					}
// 					_map25.Add(MakeKeyword("Organization"), _vec27)
// 					_vec28 := EmptyVector
// 					for _, _elem28 := range (*_elem6).Subject.OrganizationalUnit {
// 						_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 					}
// 					_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 					_vec29 := EmptyVector
// 					for _, _elem29 := range (*_elem6).Subject.Locality {
// 						_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 					}
// 					_map25.Add(MakeKeyword("Locality"), _vec29)
// 					_vec30 := EmptyVector
// 					for _, _elem30 := range (*_elem6).Subject.Province {
// 						_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 					}
// 					_map25.Add(MakeKeyword("Province"), _vec30)
// 					_vec31 := EmptyVector
// 					for _, _elem31 := range (*_elem6).Subject.StreetAddress {
// 						_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 					}
// 					_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 					_vec32 := EmptyVector
// 					for _, _elem32 := range (*_elem6).Subject.PostalCode {
// 						_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 					}
// 					_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 					_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Subject.SerialNumber))
// 					_map25.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Subject.CommonName))
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem6).Subject.Names {
// 						_vec33 = _vec33.Conjoin(_elem33)
// 					}
// 					_map25.Add(MakeKeyword("Names"), _vec33)
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*_elem6).Subject.ExtraNames {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 					_map7.Add(MakeKeyword("Subject"), _map25)
// 					_map7.Add(MakeKeyword("NotBefore"), NIL)
// 					_map7.Add(MakeKeyword("NotAfter"), NIL)
// 					_map7.Add(MakeKeyword("KeyUsage"), (*_elem6).KeyUsage)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem6).Extensions {
// 						_map38 := EmptyArrayMap()
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range _elem37.Id {
// 							_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 						}
// 						_map38.Add(MakeKeyword("Id"), _vec39)
// 						_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range _elem37.Value {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map38.Add(MakeKeyword("Value"), _vec40)
// 						_vec37 = _vec37.Conjoin(_map38)
// 					}
// 					_map7.Add(MakeKeyword("Extensions"), _vec37)
// 					_vec41 := EmptyVector
// 					for _, _elem41 := range (*_elem6).ExtraExtensions {
// 						_map42 := EmptyArrayMap()
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range _elem41.Id {
// 							_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 						}
// 						_map42.Add(MakeKeyword("Id"), _vec43)
// 						_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 						_vec44 := EmptyVector
// 						for _, _elem44 := range _elem41.Value {
// 							_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 						}
// 						_map42.Add(MakeKeyword("Value"), _vec44)
// 						_vec41 = _vec41.Conjoin(_map42)
// 					}
// 					_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 					_vec45 := EmptyVector
// 					for _, _elem45 := range (*_elem6).UnhandledCriticalExtensions {
// 						_vec46 := EmptyVector
// 						for _, _elem46 := range _elem45 {
// 							_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 						}
// 						_vec45 = _vec45.Conjoin(_vec46)
// 					}
// 					_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 					_vec47 := EmptyVector
// 					for _, _elem47 := range (*_elem6).ExtKeyUsage {
// 						_vec47 = _vec47.Conjoin(_elem47)
// 					}
// 					_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 					_vec48 := EmptyVector
// 					for _, _elem48 := range (*_elem6).UnknownExtKeyUsage {
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range _elem48 {
// 							_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 						}
// 						_vec48 = _vec48.Conjoin(_vec49)
// 					}
// 					_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 					_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem6).BasicConstraintsValid))
// 					_map7.Add(MakeKeyword("IsCA"), MakeBool((*_elem6).IsCA))
// 					_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem6).MaxPathLen))
// 					_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem6).MaxPathLenZero))
// 					_vec50 := EmptyVector
// 					for _, _elem50 := range (*_elem6).SubjectKeyId {
// 						_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 					}
// 					_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 					_vec51 := EmptyVector
// 					for _, _elem51 := range (*_elem6).AuthorityKeyId {
// 						_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 					}
// 					_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 					_vec52 := EmptyVector
// 					for _, _elem52 := range (*_elem6).OCSPServer {
// 						_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 					}
// 					_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 					_vec53 := EmptyVector
// 					for _, _elem53 := range (*_elem6).IssuingCertificateURL {
// 						_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 					}
// 					_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 					_vec54 := EmptyVector
// 					for _, _elem54 := range (*_elem6).DNSNames {
// 						_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 					}
// 					_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 					_vec55 := EmptyVector
// 					for _, _elem55 := range (*_elem6).EmailAddresses {
// 						_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 					}
// 					_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 					_vec56 := EmptyVector
// 					for _, _elem56 := range (*_elem6).IPAddresses {
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range _elem56 {
// 							_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 						}
// 						_vec56 = _vec56.Conjoin(_vec57)
// 					}
// 					_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 					_vec58 := EmptyVector
// 					for _, _elem58 := range (*_elem6).URIs {
// 						var _obj_map59 Object
// 						if _elem58 != nil {
// 							_map59 := EmptyArrayMap()
// 							_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 							_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 							_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 							_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 							_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 							_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 							_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 							_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 							_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 							_obj_map59 = Object(_map59)
// 						} else {
// 							_obj_map59 = NIL
// 						}
// 						_vec58 = _vec58.Conjoin(_obj_map59)
// 					}
// 					_map7.Add(MakeKeyword("URIs"), _vec58)
// 					_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem6).PermittedDNSDomainsCritical))
// 					_vec60 := EmptyVector
// 					for _, _elem60 := range (*_elem6).PermittedDNSDomains {
// 						_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 					}
// 					_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 					_vec61 := EmptyVector
// 					for _, _elem61 := range (*_elem6).ExcludedDNSDomains {
// 						_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 					_vec62 := EmptyVector
// 					for _, _elem62 := range (*_elem6).PermittedIPRanges {
// 						var _obj_map63 Object
// 						if _elem62 != nil {
// 							_map63 := EmptyArrayMap()
// 							_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 							_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 							_obj_map63 = Object(_map63)
// 						} else {
// 							_obj_map63 = NIL
// 						}
// 						_vec62 = _vec62.Conjoin(_obj_map63)
// 					}
// 					_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 					_vec64 := EmptyVector
// 					for _, _elem64 := range (*_elem6).ExcludedIPRanges {
// 						var _obj_map65 Object
// 						if _elem64 != nil {
// 							_map65 := EmptyArrayMap()
// 							_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 							_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 							_obj_map65 = Object(_map65)
// 						} else {
// 							_obj_map65 = NIL
// 						}
// 						_vec64 = _vec64.Conjoin(_obj_map65)
// 					}
// 					_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 					_vec66 := EmptyVector
// 					for _, _elem66 := range (*_elem6).PermittedEmailAddresses {
// 						_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 					}
// 					_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 					_vec67 := EmptyVector
// 					for _, _elem67 := range (*_elem6).ExcludedEmailAddresses {
// 						_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 					_vec68 := EmptyVector
// 					for _, _elem68 := range (*_elem6).PermittedURIDomains {
// 						_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 					}
// 					_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 					_vec69 := EmptyVector
// 					for _, _elem69 := range (*_elem6).ExcludedURIDomains {
// 						_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 					_vec70 := EmptyVector
// 					for _, _elem70 := range (*_elem6).CRLDistributionPoints {
// 						_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 					}
// 					_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 					_vec71 := EmptyVector
// 					for _, _elem71 := range (*_elem6).PolicyIdentifiers {
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range _elem71 {
// 							_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 						}
// 						_vec71 = _vec71.Conjoin(_vec72)
// 					}
// 					_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_vec6 = _vec6.Conjoin(_obj_map7)
// 			}
// 			_map5.Add(MakeKeyword("PeerCertificates"), _vec6)
// 			_vec73 := EmptyVector
// 			for _, _elem73 := range (*(*_res1).TLS).VerifiedChains {
// 				_vec74 := EmptyVector
// 				for _, _elem74 := range _elem73 {
// 					var _obj_map75 Object
// 					if _elem74 != nil {
// 						_map75 := EmptyArrayMap()
// 						_vec76 := EmptyVector
// 						for _, _elem76 := range (*_elem74).Raw {
// 							_vec76 = _vec76.Conjoin(MakeInt(int(_elem76)))
// 						}
// 						_map75.Add(MakeKeyword("Raw"), _vec76)
// 						_vec77 := EmptyVector
// 						for _, _elem77 := range (*_elem74).RawTBSCertificate {
// 							_vec77 = _vec77.Conjoin(MakeInt(int(_elem77)))
// 						}
// 						_map75.Add(MakeKeyword("RawTBSCertificate"), _vec77)
// 						_vec78 := EmptyVector
// 						for _, _elem78 := range (*_elem74).RawSubjectPublicKeyInfo {
// 							_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec78)
// 						_vec79 := EmptyVector
// 						for _, _elem79 := range (*_elem74).RawSubject {
// 							_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubject"), _vec79)
// 						_vec80 := EmptyVector
// 						for _, _elem80 := range (*_elem74).RawIssuer {
// 							_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 						}
// 						_map75.Add(MakeKeyword("RawIssuer"), _vec80)
// 						_vec81 := EmptyVector
// 						for _, _elem81 := range (*_elem74).Signature {
// 							_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 						}
// 						_map75.Add(MakeKeyword("Signature"), _vec81)
// 						_map75.Add(MakeKeyword("SignatureAlgorithm"), (*_elem74).SignatureAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem74).PublicKeyAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKey"), (*_elem74).PublicKey)
// 						_map75.Add(MakeKeyword("Version"), MakeInt((*_elem74).Version))
// 						_map75.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map83 := EmptyArrayMap()
// 						_vec84 := EmptyVector
// 						for _, _elem84 := range (*_elem74).Issuer.Country {
// 							_vec84 = _vec84.Conjoin(MakeString(_elem84))
// 						}
// 						_map83.Add(MakeKeyword("Country"), _vec84)
// 						_vec85 := EmptyVector
// 						for _, _elem85 := range (*_elem74).Issuer.Organization {
// 							_vec85 = _vec85.Conjoin(MakeString(_elem85))
// 						}
// 						_map83.Add(MakeKeyword("Organization"), _vec85)
// 						_vec86 := EmptyVector
// 						for _, _elem86 := range (*_elem74).Issuer.OrganizationalUnit {
// 							_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 						}
// 						_map83.Add(MakeKeyword("OrganizationalUnit"), _vec86)
// 						_vec87 := EmptyVector
// 						for _, _elem87 := range (*_elem74).Issuer.Locality {
// 							_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 						}
// 						_map83.Add(MakeKeyword("Locality"), _vec87)
// 						_vec88 := EmptyVector
// 						for _, _elem88 := range (*_elem74).Issuer.Province {
// 							_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 						}
// 						_map83.Add(MakeKeyword("Province"), _vec88)
// 						_vec89 := EmptyVector
// 						for _, _elem89 := range (*_elem74).Issuer.StreetAddress {
// 							_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 						}
// 						_map83.Add(MakeKeyword("StreetAddress"), _vec89)
// 						_vec90 := EmptyVector
// 						for _, _elem90 := range (*_elem74).Issuer.PostalCode {
// 							_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 						}
// 						_map83.Add(MakeKeyword("PostalCode"), _vec90)
// 						_map83.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Issuer.SerialNumber))
// 						_map83.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Issuer.CommonName))
// 						_vec91 := EmptyVector
// 						for _, _elem91 := range (*_elem74).Issuer.Names {
// 							_vec91 = _vec91.Conjoin(_elem91)
// 						}
// 						_map83.Add(MakeKeyword("Names"), _vec91)
// 						_vec92 := EmptyVector
// 						for _, _elem92 := range (*_elem74).Issuer.ExtraNames {
// 							_vec92 = _vec92.Conjoin(_elem92)
// 						}
// 						_map83.Add(MakeKeyword("ExtraNames"), _vec92)
// 						_map75.Add(MakeKeyword("Issuer"), _map83)
// 						_map93 := EmptyArrayMap()
// 						_vec94 := EmptyVector
// 						for _, _elem94 := range (*_elem74).Subject.Country {
// 							_vec94 = _vec94.Conjoin(MakeString(_elem94))
// 						}
// 						_map93.Add(MakeKeyword("Country"), _vec94)
// 						_vec95 := EmptyVector
// 						for _, _elem95 := range (*_elem74).Subject.Organization {
// 							_vec95 = _vec95.Conjoin(MakeString(_elem95))
// 						}
// 						_map93.Add(MakeKeyword("Organization"), _vec95)
// 						_vec96 := EmptyVector
// 						for _, _elem96 := range (*_elem74).Subject.OrganizationalUnit {
// 							_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 						}
// 						_map93.Add(MakeKeyword("OrganizationalUnit"), _vec96)
// 						_vec97 := EmptyVector
// 						for _, _elem97 := range (*_elem74).Subject.Locality {
// 							_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 						}
// 						_map93.Add(MakeKeyword("Locality"), _vec97)
// 						_vec98 := EmptyVector
// 						for _, _elem98 := range (*_elem74).Subject.Province {
// 							_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 						}
// 						_map93.Add(MakeKeyword("Province"), _vec98)
// 						_vec99 := EmptyVector
// 						for _, _elem99 := range (*_elem74).Subject.StreetAddress {
// 							_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 						}
// 						_map93.Add(MakeKeyword("StreetAddress"), _vec99)
// 						_vec100 := EmptyVector
// 						for _, _elem100 := range (*_elem74).Subject.PostalCode {
// 							_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 						}
// 						_map93.Add(MakeKeyword("PostalCode"), _vec100)
// 						_map93.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Subject.SerialNumber))
// 						_map93.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Subject.CommonName))
// 						_vec101 := EmptyVector
// 						for _, _elem101 := range (*_elem74).Subject.Names {
// 							_vec101 = _vec101.Conjoin(_elem101)
// 						}
// 						_map93.Add(MakeKeyword("Names"), _vec101)
// 						_vec102 := EmptyVector
// 						for _, _elem102 := range (*_elem74).Subject.ExtraNames {
// 							_vec102 = _vec102.Conjoin(_elem102)
// 						}
// 						_map93.Add(MakeKeyword("ExtraNames"), _vec102)
// 						_map75.Add(MakeKeyword("Subject"), _map93)
// 						_map75.Add(MakeKeyword("NotBefore"), NIL)
// 						_map75.Add(MakeKeyword("NotAfter"), NIL)
// 						_map75.Add(MakeKeyword("KeyUsage"), (*_elem74).KeyUsage)
// 						_vec105 := EmptyVector
// 						for _, _elem105 := range (*_elem74).Extensions {
// 							_map106 := EmptyArrayMap()
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range _elem105.Id {
// 								_vec107 = _vec107.Conjoin(MakeInt(_elem107))
// 							}
// 							_map106.Add(MakeKeyword("Id"), _vec107)
// 							_map106.Add(MakeKeyword("Critical"), MakeBool(_elem105.Critical))
// 							_vec108 := EmptyVector
// 							for _, _elem108 := range _elem105.Value {
// 								_vec108 = _vec108.Conjoin(MakeInt(int(_elem108)))
// 							}
// 							_map106.Add(MakeKeyword("Value"), _vec108)
// 							_vec105 = _vec105.Conjoin(_map106)
// 						}
// 						_map75.Add(MakeKeyword("Extensions"), _vec105)
// 						_vec109 := EmptyVector
// 						for _, _elem109 := range (*_elem74).ExtraExtensions {
// 							_map110 := EmptyArrayMap()
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range _elem109.Id {
// 								_vec111 = _vec111.Conjoin(MakeInt(_elem111))
// 							}
// 							_map110.Add(MakeKeyword("Id"), _vec111)
// 							_map110.Add(MakeKeyword("Critical"), MakeBool(_elem109.Critical))
// 							_vec112 := EmptyVector
// 							for _, _elem112 := range _elem109.Value {
// 								_vec112 = _vec112.Conjoin(MakeInt(int(_elem112)))
// 							}
// 							_map110.Add(MakeKeyword("Value"), _vec112)
// 							_vec109 = _vec109.Conjoin(_map110)
// 						}
// 						_map75.Add(MakeKeyword("ExtraExtensions"), _vec109)
// 						_vec113 := EmptyVector
// 						for _, _elem113 := range (*_elem74).UnhandledCriticalExtensions {
// 							_vec114 := EmptyVector
// 							for _, _elem114 := range _elem113 {
// 								_vec114 = _vec114.Conjoin(MakeInt(_elem114))
// 							}
// 							_vec113 = _vec113.Conjoin(_vec114)
// 						}
// 						_map75.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec113)
// 						_vec115 := EmptyVector
// 						for _, _elem115 := range (*_elem74).ExtKeyUsage {
// 							_vec115 = _vec115.Conjoin(_elem115)
// 						}
// 						_map75.Add(MakeKeyword("ExtKeyUsage"), _vec115)
// 						_vec116 := EmptyVector
// 						for _, _elem116 := range (*_elem74).UnknownExtKeyUsage {
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range _elem116 {
// 								_vec117 = _vec117.Conjoin(MakeInt(_elem117))
// 							}
// 							_vec116 = _vec116.Conjoin(_vec117)
// 						}
// 						_map75.Add(MakeKeyword("UnknownExtKeyUsage"), _vec116)
// 						_map75.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem74).BasicConstraintsValid))
// 						_map75.Add(MakeKeyword("IsCA"), MakeBool((*_elem74).IsCA))
// 						_map75.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem74).MaxPathLen))
// 						_map75.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem74).MaxPathLenZero))
// 						_vec118 := EmptyVector
// 						for _, _elem118 := range (*_elem74).SubjectKeyId {
// 							_vec118 = _vec118.Conjoin(MakeInt(int(_elem118)))
// 						}
// 						_map75.Add(MakeKeyword("SubjectKeyId"), _vec118)
// 						_vec119 := EmptyVector
// 						for _, _elem119 := range (*_elem74).AuthorityKeyId {
// 							_vec119 = _vec119.Conjoin(MakeInt(int(_elem119)))
// 						}
// 						_map75.Add(MakeKeyword("AuthorityKeyId"), _vec119)
// 						_vec120 := EmptyVector
// 						for _, _elem120 := range (*_elem74).OCSPServer {
// 							_vec120 = _vec120.Conjoin(MakeString(_elem120))
// 						}
// 						_map75.Add(MakeKeyword("OCSPServer"), _vec120)
// 						_vec121 := EmptyVector
// 						for _, _elem121 := range (*_elem74).IssuingCertificateURL {
// 							_vec121 = _vec121.Conjoin(MakeString(_elem121))
// 						}
// 						_map75.Add(MakeKeyword("IssuingCertificateURL"), _vec121)
// 						_vec122 := EmptyVector
// 						for _, _elem122 := range (*_elem74).DNSNames {
// 							_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 						}
// 						_map75.Add(MakeKeyword("DNSNames"), _vec122)
// 						_vec123 := EmptyVector
// 						for _, _elem123 := range (*_elem74).EmailAddresses {
// 							_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 						}
// 						_map75.Add(MakeKeyword("EmailAddresses"), _vec123)
// 						_vec124 := EmptyVector
// 						for _, _elem124 := range (*_elem74).IPAddresses {
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range _elem124 {
// 								_vec125 = _vec125.Conjoin(MakeInt(int(_elem125)))
// 							}
// 							_vec124 = _vec124.Conjoin(_vec125)
// 						}
// 						_map75.Add(MakeKeyword("IPAddresses"), _vec124)
// 						_vec126 := EmptyVector
// 						for _, _elem126 := range (*_elem74).URIs {
// 							var _obj_map127 Object
// 							if _elem126 != nil {
// 								_map127 := EmptyArrayMap()
// 								_map127.Add(MakeKeyword("Scheme"), MakeString((*_elem126).Scheme))
// 								_map127.Add(MakeKeyword("Opaque"), MakeString((*_elem126).Opaque))
// 								_map127.Add(MakeKeyword("User"), (*(*_elem126).User))
// 								_map127.Add(MakeKeyword("Host"), MakeString((*_elem126).Host))
// 								_map127.Add(MakeKeyword("Path"), MakeString((*_elem126).Path))
// 								_map127.Add(MakeKeyword("RawPath"), MakeString((*_elem126).RawPath))
// 								_map127.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem126).ForceQuery))
// 								_map127.Add(MakeKeyword("RawQuery"), MakeString((*_elem126).RawQuery))
// 								_map127.Add(MakeKeyword("Fragment"), MakeString((*_elem126).Fragment))
// 								_obj_map127 = Object(_map127)
// 							} else {
// 								_obj_map127 = NIL
// 							}
// 							_vec126 = _vec126.Conjoin(_obj_map127)
// 						}
// 						_map75.Add(MakeKeyword("URIs"), _vec126)
// 						_map75.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem74).PermittedDNSDomainsCritical))
// 						_vec128 := EmptyVector
// 						for _, _elem128 := range (*_elem74).PermittedDNSDomains {
// 							_vec128 = _vec128.Conjoin(MakeString(_elem128))
// 						}
// 						_map75.Add(MakeKeyword("PermittedDNSDomains"), _vec128)
// 						_vec129 := EmptyVector
// 						for _, _elem129 := range (*_elem74).ExcludedDNSDomains {
// 							_vec129 = _vec129.Conjoin(MakeString(_elem129))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedDNSDomains"), _vec129)
// 						_vec130 := EmptyVector
// 						for _, _elem130 := range (*_elem74).PermittedIPRanges {
// 							var _obj_map131 Object
// 							if _elem130 != nil {
// 								_map131 := EmptyArrayMap()
// 								_map131.Add(MakeKeyword("IP"), (*_elem130).IP)
// 								_map131.Add(MakeKeyword("Mask"), (*_elem130).Mask)
// 								_obj_map131 = Object(_map131)
// 							} else {
// 								_obj_map131 = NIL
// 							}
// 							_vec130 = _vec130.Conjoin(_obj_map131)
// 						}
// 						_map75.Add(MakeKeyword("PermittedIPRanges"), _vec130)
// 						_vec132 := EmptyVector
// 						for _, _elem132 := range (*_elem74).ExcludedIPRanges {
// 							var _obj_map133 Object
// 							if _elem132 != nil {
// 								_map133 := EmptyArrayMap()
// 								_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 								_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 								_obj_map133 = Object(_map133)
// 							} else {
// 								_obj_map133 = NIL
// 							}
// 							_vec132 = _vec132.Conjoin(_obj_map133)
// 						}
// 						_map75.Add(MakeKeyword("ExcludedIPRanges"), _vec132)
// 						_vec134 := EmptyVector
// 						for _, _elem134 := range (*_elem74).PermittedEmailAddresses {
// 							_vec134 = _vec134.Conjoin(MakeString(_elem134))
// 						}
// 						_map75.Add(MakeKeyword("PermittedEmailAddresses"), _vec134)
// 						_vec135 := EmptyVector
// 						for _, _elem135 := range (*_elem74).ExcludedEmailAddresses {
// 							_vec135 = _vec135.Conjoin(MakeString(_elem135))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedEmailAddresses"), _vec135)
// 						_vec136 := EmptyVector
// 						for _, _elem136 := range (*_elem74).PermittedURIDomains {
// 							_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 						}
// 						_map75.Add(MakeKeyword("PermittedURIDomains"), _vec136)
// 						_vec137 := EmptyVector
// 						for _, _elem137 := range (*_elem74).ExcludedURIDomains {
// 							_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedURIDomains"), _vec137)
// 						_vec138 := EmptyVector
// 						for _, _elem138 := range (*_elem74).CRLDistributionPoints {
// 							_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 						}
// 						_map75.Add(MakeKeyword("CRLDistributionPoints"), _vec138)
// 						_vec139 := EmptyVector
// 						for _, _elem139 := range (*_elem74).PolicyIdentifiers {
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range _elem139 {
// 								_vec140 = _vec140.Conjoin(MakeInt(_elem140))
// 							}
// 							_vec139 = _vec139.Conjoin(_vec140)
// 						}
// 						_map75.Add(MakeKeyword("PolicyIdentifiers"), _vec139)
// 						_obj_map75 = Object(_map75)
// 					} else {
// 						_obj_map75 = NIL
// 					}
// 					_vec74 = _vec74.Conjoin(_obj_map75)
// 				}
// 				_vec73 = _vec73.Conjoin(_vec74)
// 			}
// 			_map5.Add(MakeKeyword("VerifiedChains"), _vec73)
// 			_vec141 := EmptyVector
// 			for _, _elem141 := range (*(*_res1).TLS).SignedCertificateTimestamps {
// 				_vec142 := EmptyVector
// 				for _, _elem142 := range _elem141 {
// 					_vec142 = _vec142.Conjoin(MakeInt(int(_elem142)))
// 				}
// 				_vec141 = _vec141.Conjoin(_vec142)
// 			}
// 			_map5.Add(MakeKeyword("SignedCertificateTimestamps"), _vec141)
// 			_vec143 := EmptyVector
// 			for _, _elem143 := range (*(*_res1).TLS).OCSPResponse {
// 				_vec143 = _vec143.Conjoin(MakeInt(int(_elem143)))
// 			}
// 			_map5.Add(MakeKeyword("OCSPResponse"), _vec143)
// 			_vec144 := EmptyVector
// 			for _, _elem144 := range (*(*_res1).TLS).TLSUnique {
// 				_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 			}
// 			_map5.Add(MakeKeyword("TLSUnique"), _vec144)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map5)
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		var _obj_map145 Object
// 		if (*_res1).Response != nil {
// 			_map145 := EmptyArrayMap()
// 			_map145.Add(MakeKeyword("Status"), MakeString((*(*_res1).Response).Status))
// 			_map145.Add(MakeKeyword("StatusCode"), MakeInt((*(*_res1).Response).StatusCode))
// 			_map145.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Response).Proto))
// 			_map145.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Response).ProtoMajor))
// 			_map145.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Response).ProtoMinor))
// 			_map145.Add(MakeKeyword("Header"), (*(*_res1).Response).Header)
// 			_map145.Add(MakeKeyword("Body"), (*(*_res1).Response).Body)
// 			_map145.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Response).ContentLength)))
// 			_vec146 := EmptyVector
// 			for _, _elem146 := range (*(*_res1).Response).TransferEncoding {
// 				_vec146 = _vec146.Conjoin(MakeString(_elem146))
// 			}
// 			_map145.Add(MakeKeyword("TransferEncoding"), _vec146)
// 			_map145.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Response).Close))
// 			_map145.Add(MakeKeyword("Uncompressed"), MakeBool((*(*_res1).Response).Uncompressed))
// 			_map145.Add(MakeKeyword("Trailer"), (*(*_res1).Response).Trailer)
// 			_map145.Add(MakeKeyword("Request"), )
// 			var _obj_map147 Object
// 			if (*(*_res1).Response).TLS != nil {
// 				_map147 := EmptyArrayMap()
// 				_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*(*_res1).Response).TLS).Version)))
// 				_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*_res1).Response).TLS).HandshakeComplete))
// 				_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*(*_res1).Response).TLS).DidResume))
// 				_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*_res1).Response).TLS).CipherSuite)))
// 				_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*_res1).Response).TLS).NegotiatedProtocol))
// 				_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*_res1).Response).TLS).NegotiatedProtocolIsMutual))
// 				_map147.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res1).Response).TLS).ServerName))
// 				_vec148 := EmptyVector
// 				for _, _elem148 := range (*(*(*_res1).Response).TLS).PeerCertificates {
// 					var _obj_map149 Object
// 					if _elem148 != nil {
// 						_map149 := EmptyArrayMap()
// 						_vec150 := EmptyVector
// 						for _, _elem150 := range (*_elem148).Raw {
// 							_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 						}
// 						_map149.Add(MakeKeyword("Raw"), _vec150)
// 						_vec151 := EmptyVector
// 						for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 							_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 						}
// 						_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 						_vec152 := EmptyVector
// 						for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 							_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 						}
// 						_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 						_vec153 := EmptyVector
// 						for _, _elem153 := range (*_elem148).RawSubject {
// 							_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 						}
// 						_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 						_vec154 := EmptyVector
// 						for _, _elem154 := range (*_elem148).RawIssuer {
// 							_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 						}
// 						_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 						_vec155 := EmptyVector
// 						for _, _elem155 := range (*_elem148).Signature {
// 							_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 						}
// 						_map149.Add(MakeKeyword("Signature"), _vec155)
// 						_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 						_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 						_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 						_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 						_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map157 := EmptyArrayMap()
// 						_vec158 := EmptyVector
// 						for _, _elem158 := range (*_elem148).Issuer.Country {
// 							_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 						}
// 						_map157.Add(MakeKeyword("Country"), _vec158)
// 						_vec159 := EmptyVector
// 						for _, _elem159 := range (*_elem148).Issuer.Organization {
// 							_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 						}
// 						_map157.Add(MakeKeyword("Organization"), _vec159)
// 						_vec160 := EmptyVector
// 						for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 							_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 						}
// 						_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 						_vec161 := EmptyVector
// 						for _, _elem161 := range (*_elem148).Issuer.Locality {
// 							_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 						}
// 						_map157.Add(MakeKeyword("Locality"), _vec161)
// 						_vec162 := EmptyVector
// 						for _, _elem162 := range (*_elem148).Issuer.Province {
// 							_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 						}
// 						_map157.Add(MakeKeyword("Province"), _vec162)
// 						_vec163 := EmptyVector
// 						for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 							_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 						}
// 						_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 						_vec164 := EmptyVector
// 						for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 							_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 						}
// 						_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 						_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 						_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 						_vec165 := EmptyVector
// 						for _, _elem165 := range (*_elem148).Issuer.Names {
// 							_vec165 = _vec165.Conjoin(_elem165)
// 						}
// 						_map157.Add(MakeKeyword("Names"), _vec165)
// 						_vec166 := EmptyVector
// 						for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 							_vec166 = _vec166.Conjoin(_elem166)
// 						}
// 						_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 						_map149.Add(MakeKeyword("Issuer"), _map157)
// 						_map167 := EmptyArrayMap()
// 						_vec168 := EmptyVector
// 						for _, _elem168 := range (*_elem148).Subject.Country {
// 							_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 						}
// 						_map167.Add(MakeKeyword("Country"), _vec168)
// 						_vec169 := EmptyVector
// 						for _, _elem169 := range (*_elem148).Subject.Organization {
// 							_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 						}
// 						_map167.Add(MakeKeyword("Organization"), _vec169)
// 						_vec170 := EmptyVector
// 						for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 							_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 						}
// 						_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 						_vec171 := EmptyVector
// 						for _, _elem171 := range (*_elem148).Subject.Locality {
// 							_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 						}
// 						_map167.Add(MakeKeyword("Locality"), _vec171)
// 						_vec172 := EmptyVector
// 						for _, _elem172 := range (*_elem148).Subject.Province {
// 							_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 						}
// 						_map167.Add(MakeKeyword("Province"), _vec172)
// 						_vec173 := EmptyVector
// 						for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 							_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 						}
// 						_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 						_vec174 := EmptyVector
// 						for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 							_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 						}
// 						_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 						_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 						_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 						_vec175 := EmptyVector
// 						for _, _elem175 := range (*_elem148).Subject.Names {
// 							_vec175 = _vec175.Conjoin(_elem175)
// 						}
// 						_map167.Add(MakeKeyword("Names"), _vec175)
// 						_vec176 := EmptyVector
// 						for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 							_vec176 = _vec176.Conjoin(_elem176)
// 						}
// 						_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 						_map149.Add(MakeKeyword("Subject"), _map167)
// 						_map149.Add(MakeKeyword("NotBefore"), NIL)
// 						_map149.Add(MakeKeyword("NotAfter"), NIL)
// 						_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 						_vec179 := EmptyVector
// 						for _, _elem179 := range (*_elem148).Extensions {
// 							_map180 := EmptyArrayMap()
// 							_vec181 := EmptyVector
// 							for _, _elem181 := range _elem179.Id {
// 								_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 							}
// 							_map180.Add(MakeKeyword("Id"), _vec181)
// 							_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 							_vec182 := EmptyVector
// 							for _, _elem182 := range _elem179.Value {
// 								_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 							}
// 							_map180.Add(MakeKeyword("Value"), _vec182)
// 							_vec179 = _vec179.Conjoin(_map180)
// 						}
// 						_map149.Add(MakeKeyword("Extensions"), _vec179)
// 						_vec183 := EmptyVector
// 						for _, _elem183 := range (*_elem148).ExtraExtensions {
// 							_map184 := EmptyArrayMap()
// 							_vec185 := EmptyVector
// 							for _, _elem185 := range _elem183.Id {
// 								_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 							}
// 							_map184.Add(MakeKeyword("Id"), _vec185)
// 							_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 							_vec186 := EmptyVector
// 							for _, _elem186 := range _elem183.Value {
// 								_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 							}
// 							_map184.Add(MakeKeyword("Value"), _vec186)
// 							_vec183 = _vec183.Conjoin(_map184)
// 						}
// 						_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 						_vec187 := EmptyVector
// 						for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 							_vec188 := EmptyVector
// 							for _, _elem188 := range _elem187 {
// 								_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 							}
// 							_vec187 = _vec187.Conjoin(_vec188)
// 						}
// 						_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 						_vec189 := EmptyVector
// 						for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 							_vec189 = _vec189.Conjoin(_elem189)
// 						}
// 						_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 						_vec190 := EmptyVector
// 						for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 							_vec191 := EmptyVector
// 							for _, _elem191 := range _elem190 {
// 								_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 							}
// 							_vec190 = _vec190.Conjoin(_vec191)
// 						}
// 						_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 						_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 						_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 						_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 						_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 						_vec192 := EmptyVector
// 						for _, _elem192 := range (*_elem148).SubjectKeyId {
// 							_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 						}
// 						_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 						_vec193 := EmptyVector
// 						for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 							_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 						}
// 						_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 						_vec194 := EmptyVector
// 						for _, _elem194 := range (*_elem148).OCSPServer {
// 							_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 						}
// 						_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 						_vec195 := EmptyVector
// 						for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 							_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 						}
// 						_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 						_vec196 := EmptyVector
// 						for _, _elem196 := range (*_elem148).DNSNames {
// 							_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 						}
// 						_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 						_vec197 := EmptyVector
// 						for _, _elem197 := range (*_elem148).EmailAddresses {
// 							_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 						}
// 						_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 						_vec198 := EmptyVector
// 						for _, _elem198 := range (*_elem148).IPAddresses {
// 							_vec199 := EmptyVector
// 							for _, _elem199 := range _elem198 {
// 								_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 							}
// 							_vec198 = _vec198.Conjoin(_vec199)
// 						}
// 						_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 						_vec200 := EmptyVector
// 						for _, _elem200 := range (*_elem148).URIs {
// 							var _obj_map201 Object
// 							if _elem200 != nil {
// 								_map201 := EmptyArrayMap()
// 								_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 								_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 								_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 								_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 								_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 								_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 								_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 								_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 								_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 								_obj_map201 = Object(_map201)
// 							} else {
// 								_obj_map201 = NIL
// 							}
// 							_vec200 = _vec200.Conjoin(_obj_map201)
// 						}
// 						_map149.Add(MakeKeyword("URIs"), _vec200)
// 						_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 						_vec202 := EmptyVector
// 						for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 							_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 						}
// 						_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 						_vec203 := EmptyVector
// 						for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 							_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 						_vec204 := EmptyVector
// 						for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 							var _obj_map205 Object
// 							if _elem204 != nil {
// 								_map205 := EmptyArrayMap()
// 								_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 								_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 								_obj_map205 = Object(_map205)
// 							} else {
// 								_obj_map205 = NIL
// 							}
// 							_vec204 = _vec204.Conjoin(_obj_map205)
// 						}
// 						_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 						_vec206 := EmptyVector
// 						for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 							var _obj_map207 Object
// 							if _elem206 != nil {
// 								_map207 := EmptyArrayMap()
// 								_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 								_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 								_obj_map207 = Object(_map207)
// 							} else {
// 								_obj_map207 = NIL
// 							}
// 							_vec206 = _vec206.Conjoin(_obj_map207)
// 						}
// 						_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 						_vec208 := EmptyVector
// 						for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 							_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 						}
// 						_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 						_vec209 := EmptyVector
// 						for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 							_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 						_vec210 := EmptyVector
// 						for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 							_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 						}
// 						_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 						_vec211 := EmptyVector
// 						for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 							_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 						}
// 						_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 						_vec212 := EmptyVector
// 						for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 							_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 						}
// 						_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 						_vec213 := EmptyVector
// 						for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 							_vec214 := EmptyVector
// 							for _, _elem214 := range _elem213 {
// 								_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 							}
// 							_vec213 = _vec213.Conjoin(_vec214)
// 						}
// 						_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 						_obj_map149 = Object(_map149)
// 					} else {
// 						_obj_map149 = NIL
// 					}
// 					_vec148 = _vec148.Conjoin(_obj_map149)
// 				}
// 				_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 				_vec215 := EmptyVector
// 				for _, _elem215 := range (*(*(*_res1).Response).TLS).VerifiedChains {
// 					_vec216 := EmptyVector
// 					for _, _elem216 := range _elem215 {
// 						var _obj_map217 Object
// 						if _elem216 != nil {
// 							_map217 := EmptyArrayMap()
// 							_vec218 := EmptyVector
// 							for _, _elem218 := range (*_elem216).Raw {
// 								_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 							}
// 							_map217.Add(MakeKeyword("Raw"), _vec218)
// 							_vec219 := EmptyVector
// 							for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 								_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 							}
// 							_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 							_vec220 := EmptyVector
// 							for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 								_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 							}
// 							_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 							_vec221 := EmptyVector
// 							for _, _elem221 := range (*_elem216).RawSubject {
// 								_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 							}
// 							_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 							_vec222 := EmptyVector
// 							for _, _elem222 := range (*_elem216).RawIssuer {
// 								_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 							}
// 							_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 							_vec223 := EmptyVector
// 							for _, _elem223 := range (*_elem216).Signature {
// 								_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 							}
// 							_map217.Add(MakeKeyword("Signature"), _vec223)
// 							_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 							_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 							_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 							_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 							_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map225 := EmptyArrayMap()
// 							_vec226 := EmptyVector
// 							for _, _elem226 := range (*_elem216).Issuer.Country {
// 								_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 							}
// 							_map225.Add(MakeKeyword("Country"), _vec226)
// 							_vec227 := EmptyVector
// 							for _, _elem227 := range (*_elem216).Issuer.Organization {
// 								_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 							}
// 							_map225.Add(MakeKeyword("Organization"), _vec227)
// 							_vec228 := EmptyVector
// 							for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 								_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 							}
// 							_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 							_vec229 := EmptyVector
// 							for _, _elem229 := range (*_elem216).Issuer.Locality {
// 								_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 							}
// 							_map225.Add(MakeKeyword("Locality"), _vec229)
// 							_vec230 := EmptyVector
// 							for _, _elem230 := range (*_elem216).Issuer.Province {
// 								_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 							}
// 							_map225.Add(MakeKeyword("Province"), _vec230)
// 							_vec231 := EmptyVector
// 							for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 								_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 							}
// 							_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 							_vec232 := EmptyVector
// 							for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 								_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 							}
// 							_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 							_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 							_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 							_vec233 := EmptyVector
// 							for _, _elem233 := range (*_elem216).Issuer.Names {
// 								_vec233 = _vec233.Conjoin(_elem233)
// 							}
// 							_map225.Add(MakeKeyword("Names"), _vec233)
// 							_vec234 := EmptyVector
// 							for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 								_vec234 = _vec234.Conjoin(_elem234)
// 							}
// 							_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 							_map217.Add(MakeKeyword("Issuer"), _map225)
// 							_map235 := EmptyArrayMap()
// 							_vec236 := EmptyVector
// 							for _, _elem236 := range (*_elem216).Subject.Country {
// 								_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 							}
// 							_map235.Add(MakeKeyword("Country"), _vec236)
// 							_vec237 := EmptyVector
// 							for _, _elem237 := range (*_elem216).Subject.Organization {
// 								_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 							}
// 							_map235.Add(MakeKeyword("Organization"), _vec237)
// 							_vec238 := EmptyVector
// 							for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 								_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 							}
// 							_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 							_vec239 := EmptyVector
// 							for _, _elem239 := range (*_elem216).Subject.Locality {
// 								_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 							}
// 							_map235.Add(MakeKeyword("Locality"), _vec239)
// 							_vec240 := EmptyVector
// 							for _, _elem240 := range (*_elem216).Subject.Province {
// 								_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 							}
// 							_map235.Add(MakeKeyword("Province"), _vec240)
// 							_vec241 := EmptyVector
// 							for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 								_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 							}
// 							_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 							_vec242 := EmptyVector
// 							for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 								_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 							}
// 							_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 							_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 							_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 							_vec243 := EmptyVector
// 							for _, _elem243 := range (*_elem216).Subject.Names {
// 								_vec243 = _vec243.Conjoin(_elem243)
// 							}
// 							_map235.Add(MakeKeyword("Names"), _vec243)
// 							_vec244 := EmptyVector
// 							for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 								_vec244 = _vec244.Conjoin(_elem244)
// 							}
// 							_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 							_map217.Add(MakeKeyword("Subject"), _map235)
// 							_map217.Add(MakeKeyword("NotBefore"), NIL)
// 							_map217.Add(MakeKeyword("NotAfter"), NIL)
// 							_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 							_vec247 := EmptyVector
// 							for _, _elem247 := range (*_elem216).Extensions {
// 								_map248 := EmptyArrayMap()
// 								_vec249 := EmptyVector
// 								for _, _elem249 := range _elem247.Id {
// 									_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 								}
// 								_map248.Add(MakeKeyword("Id"), _vec249)
// 								_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 								_vec250 := EmptyVector
// 								for _, _elem250 := range _elem247.Value {
// 									_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 								}
// 								_map248.Add(MakeKeyword("Value"), _vec250)
// 								_vec247 = _vec247.Conjoin(_map248)
// 							}
// 							_map217.Add(MakeKeyword("Extensions"), _vec247)
// 							_vec251 := EmptyVector
// 							for _, _elem251 := range (*_elem216).ExtraExtensions {
// 								_map252 := EmptyArrayMap()
// 								_vec253 := EmptyVector
// 								for _, _elem253 := range _elem251.Id {
// 									_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 								}
// 								_map252.Add(MakeKeyword("Id"), _vec253)
// 								_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 								_vec254 := EmptyVector
// 								for _, _elem254 := range _elem251.Value {
// 									_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 								}
// 								_map252.Add(MakeKeyword("Value"), _vec254)
// 								_vec251 = _vec251.Conjoin(_map252)
// 							}
// 							_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 							_vec255 := EmptyVector
// 							for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 								_vec256 := EmptyVector
// 								for _, _elem256 := range _elem255 {
// 									_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 								}
// 								_vec255 = _vec255.Conjoin(_vec256)
// 							}
// 							_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 							_vec257 := EmptyVector
// 							for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 								_vec257 = _vec257.Conjoin(_elem257)
// 							}
// 							_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 							_vec258 := EmptyVector
// 							for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 								_vec259 := EmptyVector
// 								for _, _elem259 := range _elem258 {
// 									_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 								}
// 								_vec258 = _vec258.Conjoin(_vec259)
// 							}
// 							_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 							_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 							_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 							_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 							_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 							_vec260 := EmptyVector
// 							for _, _elem260 := range (*_elem216).SubjectKeyId {
// 								_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 							}
// 							_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 							_vec261 := EmptyVector
// 							for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 								_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 							}
// 							_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 							_vec262 := EmptyVector
// 							for _, _elem262 := range (*_elem216).OCSPServer {
// 								_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 							}
// 							_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 							_vec263 := EmptyVector
// 							for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 								_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 							}
// 							_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 							_vec264 := EmptyVector
// 							for _, _elem264 := range (*_elem216).DNSNames {
// 								_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 							}
// 							_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 							_vec265 := EmptyVector
// 							for _, _elem265 := range (*_elem216).EmailAddresses {
// 								_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 							}
// 							_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 							_vec266 := EmptyVector
// 							for _, _elem266 := range (*_elem216).IPAddresses {
// 								_vec267 := EmptyVector
// 								for _, _elem267 := range _elem266 {
// 									_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 								}
// 								_vec266 = _vec266.Conjoin(_vec267)
// 							}
// 							_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 							_vec268 := EmptyVector
// 							for _, _elem268 := range (*_elem216).URIs {
// 								var _obj_map269 Object
// 								if _elem268 != nil {
// 									_map269 := EmptyArrayMap()
// 									_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 									_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 									_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 									_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 									_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 									_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 									_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 									_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 									_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 									_obj_map269 = Object(_map269)
// 								} else {
// 									_obj_map269 = NIL
// 								}
// 								_vec268 = _vec268.Conjoin(_obj_map269)
// 							}
// 							_map217.Add(MakeKeyword("URIs"), _vec268)
// 							_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 							_vec270 := EmptyVector
// 							for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 								_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 							}
// 							_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 							_vec271 := EmptyVector
// 							for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 								_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 							_vec272 := EmptyVector
// 							for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 								var _obj_map273 Object
// 								if _elem272 != nil {
// 									_map273 := EmptyArrayMap()
// 									_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 									_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 									_obj_map273 = Object(_map273)
// 								} else {
// 									_obj_map273 = NIL
// 								}
// 								_vec272 = _vec272.Conjoin(_obj_map273)
// 							}
// 							_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 							_vec274 := EmptyVector
// 							for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 								var _obj_map275 Object
// 								if _elem274 != nil {
// 									_map275 := EmptyArrayMap()
// 									_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 									_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 									_obj_map275 = Object(_map275)
// 								} else {
// 									_obj_map275 = NIL
// 								}
// 								_vec274 = _vec274.Conjoin(_obj_map275)
// 							}
// 							_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 							_vec276 := EmptyVector
// 							for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 								_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 							}
// 							_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 							_vec277 := EmptyVector
// 							for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 								_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 							_vec278 := EmptyVector
// 							for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 								_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 							}
// 							_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 							_vec279 := EmptyVector
// 							for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 								_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 							}
// 							_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 							_vec280 := EmptyVector
// 							for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 								_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 							}
// 							_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 							_vec281 := EmptyVector
// 							for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 								_vec282 := EmptyVector
// 								for _, _elem282 := range _elem281 {
// 									_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 								}
// 								_vec281 = _vec281.Conjoin(_vec282)
// 							}
// 							_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 							_obj_map217 = Object(_map217)
// 						} else {
// 							_obj_map217 = NIL
// 						}
// 						_vec216 = _vec216.Conjoin(_obj_map217)
// 					}
// 					_vec215 = _vec215.Conjoin(_vec216)
// 				}
// 				_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 				_vec283 := EmptyVector
// 				for _, _elem283 := range (*(*(*_res1).Response).TLS).SignedCertificateTimestamps {
// 					_vec284 := EmptyVector
// 					for _, _elem284 := range _elem283 {
// 						_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 					}
// 					_vec283 = _vec283.Conjoin(_vec284)
// 				}
// 				_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 				_vec285 := EmptyVector
// 				for _, _elem285 := range (*(*(*_res1).Response).TLS).OCSPResponse {
// 					_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 				}
// 				_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 				_vec286 := EmptyVector
// 				for _, _elem286 := range (*(*(*_res1).Response).TLS).TLSUnique {
// 					_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 				}
// 				_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 				_obj_map147 = Object(_map147)
// 			} else {
// 				_obj_map147 = NIL
// 			}
// 			_map145.Add(MakeKeyword("TLS"), _obj_map147)
// 			_obj_map145 = Object(_map145)
// 		} else {
// 			_obj_map145 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Response"), _obj_map145)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.ReadResponse:
// func readResponse(r *bufio.Reader, req *net/http.Request) Object {
// 	_res1, _res2 := _http.ReadResponse(r, req)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Status"), MakeString((*_res1).Status))
// 		_map1.Add(MakeKeyword("StatusCode"), MakeInt((*_res1).StatusCode))
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).TransferEncoding {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec2)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Uncompressed"), MakeBool((*_res1).Uncompressed))
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		var _obj_map3 Object
// 		if (*_res1).Request != nil {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Method"), MakeString((*(*_res1).Request).Method))
// 			var _obj_map4 Object
// 			if (*(*_res1).Request).URL != nil {
// 				_map4 := EmptyArrayMap()
// 				_map4.Add(MakeKeyword("Scheme"), MakeString((*(*(*_res1).Request).URL).Scheme))
// 				_map4.Add(MakeKeyword("Opaque"), MakeString((*(*(*_res1).Request).URL).Opaque))
// 				_map4.Add(MakeKeyword("User"), (*(*(*(*_res1).Request).URL).User))
// 				_map4.Add(MakeKeyword("Host"), MakeString((*(*(*_res1).Request).URL).Host))
// 				_map4.Add(MakeKeyword("Path"), MakeString((*(*(*_res1).Request).URL).Path))
// 				_map4.Add(MakeKeyword("RawPath"), MakeString((*(*(*_res1).Request).URL).RawPath))
// 				_map4.Add(MakeKeyword("ForceQuery"), MakeBool((*(*(*_res1).Request).URL).ForceQuery))
// 				_map4.Add(MakeKeyword("RawQuery"), MakeString((*(*(*_res1).Request).URL).RawQuery))
// 				_map4.Add(MakeKeyword("Fragment"), MakeString((*(*(*_res1).Request).URL).Fragment))
// 				_obj_map4 = Object(_map4)
// 			} else {
// 				_obj_map4 = NIL
// 			}
// 			_map3.Add(MakeKeyword("URL"), _obj_map4)
// 			_map3.Add(MakeKeyword("Proto"), MakeString((*(*_res1).Request).Proto))
// 			_map3.Add(MakeKeyword("ProtoMajor"), MakeInt((*(*_res1).Request).ProtoMajor))
// 			_map3.Add(MakeKeyword("ProtoMinor"), MakeInt((*(*_res1).Request).ProtoMinor))
// 			_map3.Add(MakeKeyword("Header"), (*(*_res1).Request).Header)
// 			_map3.Add(MakeKeyword("Body"), (*(*_res1).Request).Body)
// 			_map3.Add(MakeKeyword("GetBody"), (*(*_res1).Request).GetBody)
// 			_map3.Add(MakeKeyword("ContentLength"), MakeInt(int((*(*_res1).Request).ContentLength)))
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res1).Request).TransferEncoding {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map3.Add(MakeKeyword("TransferEncoding"), _vec5)
// 			_map3.Add(MakeKeyword("Close"), MakeBool((*(*_res1).Request).Close))
// 			_map3.Add(MakeKeyword("Host"), MakeString((*(*_res1).Request).Host))
// 			_map3.Add(MakeKeyword("Form"), (*(*_res1).Request).Form)
// 			_map3.Add(MakeKeyword("PostForm"), (*(*_res1).Request).PostForm)
// 			var _obj_map6 Object
// 			if (*(*_res1).Request).MultipartForm != nil {
// 				_map6 := EmptyArrayMap()
// 				_map6.Add(MakeKeyword("Value"), (*(*(*_res1).Request).MultipartForm).Value)
// 				_map6.Add(MakeKeyword("File"), (*(*(*_res1).Request).MultipartForm).File)
// 				_obj_map6 = Object(_map6)
// 			} else {
// 				_obj_map6 = NIL
// 			}
// 			_map3.Add(MakeKeyword("MultipartForm"), _obj_map6)
// 			_map3.Add(MakeKeyword("Trailer"), (*(*_res1).Request).Trailer)
// 			_map3.Add(MakeKeyword("RemoteAddr"), MakeString((*(*_res1).Request).RemoteAddr))
// 			_map3.Add(MakeKeyword("RequestURI"), MakeString((*(*_res1).Request).RequestURI))
// 			var _obj_map7 Object
// 			if (*(*_res1).Request).TLS != nil {
// 				_map7 := EmptyArrayMap()
// 				_map7.Add(MakeKeyword("Version"), MakeInt(int((*(*(*_res1).Request).TLS).Version)))
// 				_map7.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*(*_res1).Request).TLS).HandshakeComplete))
// 				_map7.Add(MakeKeyword("DidResume"), MakeBool((*(*(*_res1).Request).TLS).DidResume))
// 				_map7.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*(*_res1).Request).TLS).CipherSuite)))
// 				_map7.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*(*_res1).Request).TLS).NegotiatedProtocol))
// 				_map7.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*(*_res1).Request).TLS).NegotiatedProtocolIsMutual))
// 				_map7.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res1).Request).TLS).ServerName))
// 				_vec8 := EmptyVector
// 				for _, _elem8 := range (*(*(*_res1).Request).TLS).PeerCertificates {
// 					var _obj_map9 Object
// 					if _elem8 != nil {
// 						_map9 := EmptyArrayMap()
// 						_vec10 := EmptyVector
// 						for _, _elem10 := range (*_elem8).Raw {
// 							_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 						}
// 						_map9.Add(MakeKeyword("Raw"), _vec10)
// 						_vec11 := EmptyVector
// 						for _, _elem11 := range (*_elem8).RawTBSCertificate {
// 							_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 						}
// 						_map9.Add(MakeKeyword("RawTBSCertificate"), _vec11)
// 						_vec12 := EmptyVector
// 						for _, _elem12 := range (*_elem8).RawSubjectPublicKeyInfo {
// 							_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec12)
// 						_vec13 := EmptyVector
// 						for _, _elem13 := range (*_elem8).RawSubject {
// 							_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 						}
// 						_map9.Add(MakeKeyword("RawSubject"), _vec13)
// 						_vec14 := EmptyVector
// 						for _, _elem14 := range (*_elem8).RawIssuer {
// 							_vec14 = _vec14.Conjoin(MakeInt(int(_elem14)))
// 						}
// 						_map9.Add(MakeKeyword("RawIssuer"), _vec14)
// 						_vec15 := EmptyVector
// 						for _, _elem15 := range (*_elem8).Signature {
// 							_vec15 = _vec15.Conjoin(MakeInt(int(_elem15)))
// 						}
// 						_map9.Add(MakeKeyword("Signature"), _vec15)
// 						_map9.Add(MakeKeyword("SignatureAlgorithm"), (*_elem8).SignatureAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem8).PublicKeyAlgorithm)
// 						_map9.Add(MakeKeyword("PublicKey"), (*_elem8).PublicKey)
// 						_map9.Add(MakeKeyword("Version"), MakeInt((*_elem8).Version))
// 						_map9.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map17 := EmptyArrayMap()
// 						_vec18 := EmptyVector
// 						for _, _elem18 := range (*_elem8).Issuer.Country {
// 							_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 						}
// 						_map17.Add(MakeKeyword("Country"), _vec18)
// 						_vec19 := EmptyVector
// 						for _, _elem19 := range (*_elem8).Issuer.Organization {
// 							_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 						}
// 						_map17.Add(MakeKeyword("Organization"), _vec19)
// 						_vec20 := EmptyVector
// 						for _, _elem20 := range (*_elem8).Issuer.OrganizationalUnit {
// 							_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 						}
// 						_map17.Add(MakeKeyword("OrganizationalUnit"), _vec20)
// 						_vec21 := EmptyVector
// 						for _, _elem21 := range (*_elem8).Issuer.Locality {
// 							_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 						}
// 						_map17.Add(MakeKeyword("Locality"), _vec21)
// 						_vec22 := EmptyVector
// 						for _, _elem22 := range (*_elem8).Issuer.Province {
// 							_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 						}
// 						_map17.Add(MakeKeyword("Province"), _vec22)
// 						_vec23 := EmptyVector
// 						for _, _elem23 := range (*_elem8).Issuer.StreetAddress {
// 							_vec23 = _vec23.Conjoin(MakeString(_elem23))
// 						}
// 						_map17.Add(MakeKeyword("StreetAddress"), _vec23)
// 						_vec24 := EmptyVector
// 						for _, _elem24 := range (*_elem8).Issuer.PostalCode {
// 							_vec24 = _vec24.Conjoin(MakeString(_elem24))
// 						}
// 						_map17.Add(MakeKeyword("PostalCode"), _vec24)
// 						_map17.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Issuer.SerialNumber))
// 						_map17.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Issuer.CommonName))
// 						_vec25 := EmptyVector
// 						for _, _elem25 := range (*_elem8).Issuer.Names {
// 							_vec25 = _vec25.Conjoin(_elem25)
// 						}
// 						_map17.Add(MakeKeyword("Names"), _vec25)
// 						_vec26 := EmptyVector
// 						for _, _elem26 := range (*_elem8).Issuer.ExtraNames {
// 							_vec26 = _vec26.Conjoin(_elem26)
// 						}
// 						_map17.Add(MakeKeyword("ExtraNames"), _vec26)
// 						_map9.Add(MakeKeyword("Issuer"), _map17)
// 						_map27 := EmptyArrayMap()
// 						_vec28 := EmptyVector
// 						for _, _elem28 := range (*_elem8).Subject.Country {
// 							_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 						}
// 						_map27.Add(MakeKeyword("Country"), _vec28)
// 						_vec29 := EmptyVector
// 						for _, _elem29 := range (*_elem8).Subject.Organization {
// 							_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 						}
// 						_map27.Add(MakeKeyword("Organization"), _vec29)
// 						_vec30 := EmptyVector
// 						for _, _elem30 := range (*_elem8).Subject.OrganizationalUnit {
// 							_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 						}
// 						_map27.Add(MakeKeyword("OrganizationalUnit"), _vec30)
// 						_vec31 := EmptyVector
// 						for _, _elem31 := range (*_elem8).Subject.Locality {
// 							_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 						}
// 						_map27.Add(MakeKeyword("Locality"), _vec31)
// 						_vec32 := EmptyVector
// 						for _, _elem32 := range (*_elem8).Subject.Province {
// 							_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 						}
// 						_map27.Add(MakeKeyword("Province"), _vec32)
// 						_vec33 := EmptyVector
// 						for _, _elem33 := range (*_elem8).Subject.StreetAddress {
// 							_vec33 = _vec33.Conjoin(MakeString(_elem33))
// 						}
// 						_map27.Add(MakeKeyword("StreetAddress"), _vec33)
// 						_vec34 := EmptyVector
// 						for _, _elem34 := range (*_elem8).Subject.PostalCode {
// 							_vec34 = _vec34.Conjoin(MakeString(_elem34))
// 						}
// 						_map27.Add(MakeKeyword("PostalCode"), _vec34)
// 						_map27.Add(MakeKeyword("SerialNumber"), MakeString((*_elem8).Subject.SerialNumber))
// 						_map27.Add(MakeKeyword("CommonName"), MakeString((*_elem8).Subject.CommonName))
// 						_vec35 := EmptyVector
// 						for _, _elem35 := range (*_elem8).Subject.Names {
// 							_vec35 = _vec35.Conjoin(_elem35)
// 						}
// 						_map27.Add(MakeKeyword("Names"), _vec35)
// 						_vec36 := EmptyVector
// 						for _, _elem36 := range (*_elem8).Subject.ExtraNames {
// 							_vec36 = _vec36.Conjoin(_elem36)
// 						}
// 						_map27.Add(MakeKeyword("ExtraNames"), _vec36)
// 						_map9.Add(MakeKeyword("Subject"), _map27)
// 						_map9.Add(MakeKeyword("NotBefore"), NIL)
// 						_map9.Add(MakeKeyword("NotAfter"), NIL)
// 						_map9.Add(MakeKeyword("KeyUsage"), (*_elem8).KeyUsage)
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range (*_elem8).Extensions {
// 							_map40 := EmptyArrayMap()
// 							_vec41 := EmptyVector
// 							for _, _elem41 := range _elem39.Id {
// 								_vec41 = _vec41.Conjoin(MakeInt(_elem41))
// 							}
// 							_map40.Add(MakeKeyword("Id"), _vec41)
// 							_map40.Add(MakeKeyword("Critical"), MakeBool(_elem39.Critical))
// 							_vec42 := EmptyVector
// 							for _, _elem42 := range _elem39.Value {
// 								_vec42 = _vec42.Conjoin(MakeInt(int(_elem42)))
// 							}
// 							_map40.Add(MakeKeyword("Value"), _vec42)
// 							_vec39 = _vec39.Conjoin(_map40)
// 						}
// 						_map9.Add(MakeKeyword("Extensions"), _vec39)
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range (*_elem8).ExtraExtensions {
// 							_map44 := EmptyArrayMap()
// 							_vec45 := EmptyVector
// 							for _, _elem45 := range _elem43.Id {
// 								_vec45 = _vec45.Conjoin(MakeInt(_elem45))
// 							}
// 							_map44.Add(MakeKeyword("Id"), _vec45)
// 							_map44.Add(MakeKeyword("Critical"), MakeBool(_elem43.Critical))
// 							_vec46 := EmptyVector
// 							for _, _elem46 := range _elem43.Value {
// 								_vec46 = _vec46.Conjoin(MakeInt(int(_elem46)))
// 							}
// 							_map44.Add(MakeKeyword("Value"), _vec46)
// 							_vec43 = _vec43.Conjoin(_map44)
// 						}
// 						_map9.Add(MakeKeyword("ExtraExtensions"), _vec43)
// 						_vec47 := EmptyVector
// 						for _, _elem47 := range (*_elem8).UnhandledCriticalExtensions {
// 							_vec48 := EmptyVector
// 							for _, _elem48 := range _elem47 {
// 								_vec48 = _vec48.Conjoin(MakeInt(_elem48))
// 							}
// 							_vec47 = _vec47.Conjoin(_vec48)
// 						}
// 						_map9.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec47)
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range (*_elem8).ExtKeyUsage {
// 							_vec49 = _vec49.Conjoin(_elem49)
// 						}
// 						_map9.Add(MakeKeyword("ExtKeyUsage"), _vec49)
// 						_vec50 := EmptyVector
// 						for _, _elem50 := range (*_elem8).UnknownExtKeyUsage {
// 							_vec51 := EmptyVector
// 							for _, _elem51 := range _elem50 {
// 								_vec51 = _vec51.Conjoin(MakeInt(_elem51))
// 							}
// 							_vec50 = _vec50.Conjoin(_vec51)
// 						}
// 						_map9.Add(MakeKeyword("UnknownExtKeyUsage"), _vec50)
// 						_map9.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem8).BasicConstraintsValid))
// 						_map9.Add(MakeKeyword("IsCA"), MakeBool((*_elem8).IsCA))
// 						_map9.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem8).MaxPathLen))
// 						_map9.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem8).MaxPathLenZero))
// 						_vec52 := EmptyVector
// 						for _, _elem52 := range (*_elem8).SubjectKeyId {
// 							_vec52 = _vec52.Conjoin(MakeInt(int(_elem52)))
// 						}
// 						_map9.Add(MakeKeyword("SubjectKeyId"), _vec52)
// 						_vec53 := EmptyVector
// 						for _, _elem53 := range (*_elem8).AuthorityKeyId {
// 							_vec53 = _vec53.Conjoin(MakeInt(int(_elem53)))
// 						}
// 						_map9.Add(MakeKeyword("AuthorityKeyId"), _vec53)
// 						_vec54 := EmptyVector
// 						for _, _elem54 := range (*_elem8).OCSPServer {
// 							_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 						}
// 						_map9.Add(MakeKeyword("OCSPServer"), _vec54)
// 						_vec55 := EmptyVector
// 						for _, _elem55 := range (*_elem8).IssuingCertificateURL {
// 							_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 						}
// 						_map9.Add(MakeKeyword("IssuingCertificateURL"), _vec55)
// 						_vec56 := EmptyVector
// 						for _, _elem56 := range (*_elem8).DNSNames {
// 							_vec56 = _vec56.Conjoin(MakeString(_elem56))
// 						}
// 						_map9.Add(MakeKeyword("DNSNames"), _vec56)
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range (*_elem8).EmailAddresses {
// 							_vec57 = _vec57.Conjoin(MakeString(_elem57))
// 						}
// 						_map9.Add(MakeKeyword("EmailAddresses"), _vec57)
// 						_vec58 := EmptyVector
// 						for _, _elem58 := range (*_elem8).IPAddresses {
// 							_vec59 := EmptyVector
// 							for _, _elem59 := range _elem58 {
// 								_vec59 = _vec59.Conjoin(MakeInt(int(_elem59)))
// 							}
// 							_vec58 = _vec58.Conjoin(_vec59)
// 						}
// 						_map9.Add(MakeKeyword("IPAddresses"), _vec58)
// 						_vec60 := EmptyVector
// 						for _, _elem60 := range (*_elem8).URIs {
// 							var _obj_map61 Object
// 							if _elem60 != nil {
// 								_map61 := EmptyArrayMap()
// 								_map61.Add(MakeKeyword("Scheme"), MakeString((*_elem60).Scheme))
// 								_map61.Add(MakeKeyword("Opaque"), MakeString((*_elem60).Opaque))
// 								_map61.Add(MakeKeyword("User"), (*(*_elem60).User))
// 								_map61.Add(MakeKeyword("Host"), MakeString((*_elem60).Host))
// 								_map61.Add(MakeKeyword("Path"), MakeString((*_elem60).Path))
// 								_map61.Add(MakeKeyword("RawPath"), MakeString((*_elem60).RawPath))
// 								_map61.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem60).ForceQuery))
// 								_map61.Add(MakeKeyword("RawQuery"), MakeString((*_elem60).RawQuery))
// 								_map61.Add(MakeKeyword("Fragment"), MakeString((*_elem60).Fragment))
// 								_obj_map61 = Object(_map61)
// 							} else {
// 								_obj_map61 = NIL
// 							}
// 							_vec60 = _vec60.Conjoin(_obj_map61)
// 						}
// 						_map9.Add(MakeKeyword("URIs"), _vec60)
// 						_map9.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem8).PermittedDNSDomainsCritical))
// 						_vec62 := EmptyVector
// 						for _, _elem62 := range (*_elem8).PermittedDNSDomains {
// 							_vec62 = _vec62.Conjoin(MakeString(_elem62))
// 						}
// 						_map9.Add(MakeKeyword("PermittedDNSDomains"), _vec62)
// 						_vec63 := EmptyVector
// 						for _, _elem63 := range (*_elem8).ExcludedDNSDomains {
// 							_vec63 = _vec63.Conjoin(MakeString(_elem63))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedDNSDomains"), _vec63)
// 						_vec64 := EmptyVector
// 						for _, _elem64 := range (*_elem8).PermittedIPRanges {
// 							var _obj_map65 Object
// 							if _elem64 != nil {
// 								_map65 := EmptyArrayMap()
// 								_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 								_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 								_obj_map65 = Object(_map65)
// 							} else {
// 								_obj_map65 = NIL
// 							}
// 							_vec64 = _vec64.Conjoin(_obj_map65)
// 						}
// 						_map9.Add(MakeKeyword("PermittedIPRanges"), _vec64)
// 						_vec66 := EmptyVector
// 						for _, _elem66 := range (*_elem8).ExcludedIPRanges {
// 							var _obj_map67 Object
// 							if _elem66 != nil {
// 								_map67 := EmptyArrayMap()
// 								_map67.Add(MakeKeyword("IP"), (*_elem66).IP)
// 								_map67.Add(MakeKeyword("Mask"), (*_elem66).Mask)
// 								_obj_map67 = Object(_map67)
// 							} else {
// 								_obj_map67 = NIL
// 							}
// 							_vec66 = _vec66.Conjoin(_obj_map67)
// 						}
// 						_map9.Add(MakeKeyword("ExcludedIPRanges"), _vec66)
// 						_vec68 := EmptyVector
// 						for _, _elem68 := range (*_elem8).PermittedEmailAddresses {
// 							_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 						}
// 						_map9.Add(MakeKeyword("PermittedEmailAddresses"), _vec68)
// 						_vec69 := EmptyVector
// 						for _, _elem69 := range (*_elem8).ExcludedEmailAddresses {
// 							_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedEmailAddresses"), _vec69)
// 						_vec70 := EmptyVector
// 						for _, _elem70 := range (*_elem8).PermittedURIDomains {
// 							_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 						}
// 						_map9.Add(MakeKeyword("PermittedURIDomains"), _vec70)
// 						_vec71 := EmptyVector
// 						for _, _elem71 := range (*_elem8).ExcludedURIDomains {
// 							_vec71 = _vec71.Conjoin(MakeString(_elem71))
// 						}
// 						_map9.Add(MakeKeyword("ExcludedURIDomains"), _vec71)
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range (*_elem8).CRLDistributionPoints {
// 							_vec72 = _vec72.Conjoin(MakeString(_elem72))
// 						}
// 						_map9.Add(MakeKeyword("CRLDistributionPoints"), _vec72)
// 						_vec73 := EmptyVector
// 						for _, _elem73 := range (*_elem8).PolicyIdentifiers {
// 							_vec74 := EmptyVector
// 							for _, _elem74 := range _elem73 {
// 								_vec74 = _vec74.Conjoin(MakeInt(_elem74))
// 							}
// 							_vec73 = _vec73.Conjoin(_vec74)
// 						}
// 						_map9.Add(MakeKeyword("PolicyIdentifiers"), _vec73)
// 						_obj_map9 = Object(_map9)
// 					} else {
// 						_obj_map9 = NIL
// 					}
// 					_vec8 = _vec8.Conjoin(_obj_map9)
// 				}
// 				_map7.Add(MakeKeyword("PeerCertificates"), _vec8)
// 				_vec75 := EmptyVector
// 				for _, _elem75 := range (*(*(*_res1).Request).TLS).VerifiedChains {
// 					_vec76 := EmptyVector
// 					for _, _elem76 := range _elem75 {
// 						var _obj_map77 Object
// 						if _elem76 != nil {
// 							_map77 := EmptyArrayMap()
// 							_vec78 := EmptyVector
// 							for _, _elem78 := range (*_elem76).Raw {
// 								_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 							}
// 							_map77.Add(MakeKeyword("Raw"), _vec78)
// 							_vec79 := EmptyVector
// 							for _, _elem79 := range (*_elem76).RawTBSCertificate {
// 								_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 							}
// 							_map77.Add(MakeKeyword("RawTBSCertificate"), _vec79)
// 							_vec80 := EmptyVector
// 							for _, _elem80 := range (*_elem76).RawSubjectPublicKeyInfo {
// 								_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec80)
// 							_vec81 := EmptyVector
// 							for _, _elem81 := range (*_elem76).RawSubject {
// 								_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 							}
// 							_map77.Add(MakeKeyword("RawSubject"), _vec81)
// 							_vec82 := EmptyVector
// 							for _, _elem82 := range (*_elem76).RawIssuer {
// 								_vec82 = _vec82.Conjoin(MakeInt(int(_elem82)))
// 							}
// 							_map77.Add(MakeKeyword("RawIssuer"), _vec82)
// 							_vec83 := EmptyVector
// 							for _, _elem83 := range (*_elem76).Signature {
// 								_vec83 = _vec83.Conjoin(MakeInt(int(_elem83)))
// 							}
// 							_map77.Add(MakeKeyword("Signature"), _vec83)
// 							_map77.Add(MakeKeyword("SignatureAlgorithm"), (*_elem76).SignatureAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem76).PublicKeyAlgorithm)
// 							_map77.Add(MakeKeyword("PublicKey"), (*_elem76).PublicKey)
// 							_map77.Add(MakeKeyword("Version"), MakeInt((*_elem76).Version))
// 							_map77.Add(MakeKeyword("SerialNumber"), NIL)
// 							_map85 := EmptyArrayMap()
// 							_vec86 := EmptyVector
// 							for _, _elem86 := range (*_elem76).Issuer.Country {
// 								_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 							}
// 							_map85.Add(MakeKeyword("Country"), _vec86)
// 							_vec87 := EmptyVector
// 							for _, _elem87 := range (*_elem76).Issuer.Organization {
// 								_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 							}
// 							_map85.Add(MakeKeyword("Organization"), _vec87)
// 							_vec88 := EmptyVector
// 							for _, _elem88 := range (*_elem76).Issuer.OrganizationalUnit {
// 								_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 							}
// 							_map85.Add(MakeKeyword("OrganizationalUnit"), _vec88)
// 							_vec89 := EmptyVector
// 							for _, _elem89 := range (*_elem76).Issuer.Locality {
// 								_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 							}
// 							_map85.Add(MakeKeyword("Locality"), _vec89)
// 							_vec90 := EmptyVector
// 							for _, _elem90 := range (*_elem76).Issuer.Province {
// 								_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 							}
// 							_map85.Add(MakeKeyword("Province"), _vec90)
// 							_vec91 := EmptyVector
// 							for _, _elem91 := range (*_elem76).Issuer.StreetAddress {
// 								_vec91 = _vec91.Conjoin(MakeString(_elem91))
// 							}
// 							_map85.Add(MakeKeyword("StreetAddress"), _vec91)
// 							_vec92 := EmptyVector
// 							for _, _elem92 := range (*_elem76).Issuer.PostalCode {
// 								_vec92 = _vec92.Conjoin(MakeString(_elem92))
// 							}
// 							_map85.Add(MakeKeyword("PostalCode"), _vec92)
// 							_map85.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Issuer.SerialNumber))
// 							_map85.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Issuer.CommonName))
// 							_vec93 := EmptyVector
// 							for _, _elem93 := range (*_elem76).Issuer.Names {
// 								_vec93 = _vec93.Conjoin(_elem93)
// 							}
// 							_map85.Add(MakeKeyword("Names"), _vec93)
// 							_vec94 := EmptyVector
// 							for _, _elem94 := range (*_elem76).Issuer.ExtraNames {
// 								_vec94 = _vec94.Conjoin(_elem94)
// 							}
// 							_map85.Add(MakeKeyword("ExtraNames"), _vec94)
// 							_map77.Add(MakeKeyword("Issuer"), _map85)
// 							_map95 := EmptyArrayMap()
// 							_vec96 := EmptyVector
// 							for _, _elem96 := range (*_elem76).Subject.Country {
// 								_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 							}
// 							_map95.Add(MakeKeyword("Country"), _vec96)
// 							_vec97 := EmptyVector
// 							for _, _elem97 := range (*_elem76).Subject.Organization {
// 								_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 							}
// 							_map95.Add(MakeKeyword("Organization"), _vec97)
// 							_vec98 := EmptyVector
// 							for _, _elem98 := range (*_elem76).Subject.OrganizationalUnit {
// 								_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 							}
// 							_map95.Add(MakeKeyword("OrganizationalUnit"), _vec98)
// 							_vec99 := EmptyVector
// 							for _, _elem99 := range (*_elem76).Subject.Locality {
// 								_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 							}
// 							_map95.Add(MakeKeyword("Locality"), _vec99)
// 							_vec100 := EmptyVector
// 							for _, _elem100 := range (*_elem76).Subject.Province {
// 								_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 							}
// 							_map95.Add(MakeKeyword("Province"), _vec100)
// 							_vec101 := EmptyVector
// 							for _, _elem101 := range (*_elem76).Subject.StreetAddress {
// 								_vec101 = _vec101.Conjoin(MakeString(_elem101))
// 							}
// 							_map95.Add(MakeKeyword("StreetAddress"), _vec101)
// 							_vec102 := EmptyVector
// 							for _, _elem102 := range (*_elem76).Subject.PostalCode {
// 								_vec102 = _vec102.Conjoin(MakeString(_elem102))
// 							}
// 							_map95.Add(MakeKeyword("PostalCode"), _vec102)
// 							_map95.Add(MakeKeyword("SerialNumber"), MakeString((*_elem76).Subject.SerialNumber))
// 							_map95.Add(MakeKeyword("CommonName"), MakeString((*_elem76).Subject.CommonName))
// 							_vec103 := EmptyVector
// 							for _, _elem103 := range (*_elem76).Subject.Names {
// 								_vec103 = _vec103.Conjoin(_elem103)
// 							}
// 							_map95.Add(MakeKeyword("Names"), _vec103)
// 							_vec104 := EmptyVector
// 							for _, _elem104 := range (*_elem76).Subject.ExtraNames {
// 								_vec104 = _vec104.Conjoin(_elem104)
// 							}
// 							_map95.Add(MakeKeyword("ExtraNames"), _vec104)
// 							_map77.Add(MakeKeyword("Subject"), _map95)
// 							_map77.Add(MakeKeyword("NotBefore"), NIL)
// 							_map77.Add(MakeKeyword("NotAfter"), NIL)
// 							_map77.Add(MakeKeyword("KeyUsage"), (*_elem76).KeyUsage)
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range (*_elem76).Extensions {
// 								_map108 := EmptyArrayMap()
// 								_vec109 := EmptyVector
// 								for _, _elem109 := range _elem107.Id {
// 									_vec109 = _vec109.Conjoin(MakeInt(_elem109))
// 								}
// 								_map108.Add(MakeKeyword("Id"), _vec109)
// 								_map108.Add(MakeKeyword("Critical"), MakeBool(_elem107.Critical))
// 								_vec110 := EmptyVector
// 								for _, _elem110 := range _elem107.Value {
// 									_vec110 = _vec110.Conjoin(MakeInt(int(_elem110)))
// 								}
// 								_map108.Add(MakeKeyword("Value"), _vec110)
// 								_vec107 = _vec107.Conjoin(_map108)
// 							}
// 							_map77.Add(MakeKeyword("Extensions"), _vec107)
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range (*_elem76).ExtraExtensions {
// 								_map112 := EmptyArrayMap()
// 								_vec113 := EmptyVector
// 								for _, _elem113 := range _elem111.Id {
// 									_vec113 = _vec113.Conjoin(MakeInt(_elem113))
// 								}
// 								_map112.Add(MakeKeyword("Id"), _vec113)
// 								_map112.Add(MakeKeyword("Critical"), MakeBool(_elem111.Critical))
// 								_vec114 := EmptyVector
// 								for _, _elem114 := range _elem111.Value {
// 									_vec114 = _vec114.Conjoin(MakeInt(int(_elem114)))
// 								}
// 								_map112.Add(MakeKeyword("Value"), _vec114)
// 								_vec111 = _vec111.Conjoin(_map112)
// 							}
// 							_map77.Add(MakeKeyword("ExtraExtensions"), _vec111)
// 							_vec115 := EmptyVector
// 							for _, _elem115 := range (*_elem76).UnhandledCriticalExtensions {
// 								_vec116 := EmptyVector
// 								for _, _elem116 := range _elem115 {
// 									_vec116 = _vec116.Conjoin(MakeInt(_elem116))
// 								}
// 								_vec115 = _vec115.Conjoin(_vec116)
// 							}
// 							_map77.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec115)
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range (*_elem76).ExtKeyUsage {
// 								_vec117 = _vec117.Conjoin(_elem117)
// 							}
// 							_map77.Add(MakeKeyword("ExtKeyUsage"), _vec117)
// 							_vec118 := EmptyVector
// 							for _, _elem118 := range (*_elem76).UnknownExtKeyUsage {
// 								_vec119 := EmptyVector
// 								for _, _elem119 := range _elem118 {
// 									_vec119 = _vec119.Conjoin(MakeInt(_elem119))
// 								}
// 								_vec118 = _vec118.Conjoin(_vec119)
// 							}
// 							_map77.Add(MakeKeyword("UnknownExtKeyUsage"), _vec118)
// 							_map77.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem76).BasicConstraintsValid))
// 							_map77.Add(MakeKeyword("IsCA"), MakeBool((*_elem76).IsCA))
// 							_map77.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem76).MaxPathLen))
// 							_map77.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem76).MaxPathLenZero))
// 							_vec120 := EmptyVector
// 							for _, _elem120 := range (*_elem76).SubjectKeyId {
// 								_vec120 = _vec120.Conjoin(MakeInt(int(_elem120)))
// 							}
// 							_map77.Add(MakeKeyword("SubjectKeyId"), _vec120)
// 							_vec121 := EmptyVector
// 							for _, _elem121 := range (*_elem76).AuthorityKeyId {
// 								_vec121 = _vec121.Conjoin(MakeInt(int(_elem121)))
// 							}
// 							_map77.Add(MakeKeyword("AuthorityKeyId"), _vec121)
// 							_vec122 := EmptyVector
// 							for _, _elem122 := range (*_elem76).OCSPServer {
// 								_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 							}
// 							_map77.Add(MakeKeyword("OCSPServer"), _vec122)
// 							_vec123 := EmptyVector
// 							for _, _elem123 := range (*_elem76).IssuingCertificateURL {
// 								_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 							}
// 							_map77.Add(MakeKeyword("IssuingCertificateURL"), _vec123)
// 							_vec124 := EmptyVector
// 							for _, _elem124 := range (*_elem76).DNSNames {
// 								_vec124 = _vec124.Conjoin(MakeString(_elem124))
// 							}
// 							_map77.Add(MakeKeyword("DNSNames"), _vec124)
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range (*_elem76).EmailAddresses {
// 								_vec125 = _vec125.Conjoin(MakeString(_elem125))
// 							}
// 							_map77.Add(MakeKeyword("EmailAddresses"), _vec125)
// 							_vec126 := EmptyVector
// 							for _, _elem126 := range (*_elem76).IPAddresses {
// 								_vec127 := EmptyVector
// 								for _, _elem127 := range _elem126 {
// 									_vec127 = _vec127.Conjoin(MakeInt(int(_elem127)))
// 								}
// 								_vec126 = _vec126.Conjoin(_vec127)
// 							}
// 							_map77.Add(MakeKeyword("IPAddresses"), _vec126)
// 							_vec128 := EmptyVector
// 							for _, _elem128 := range (*_elem76).URIs {
// 								var _obj_map129 Object
// 								if _elem128 != nil {
// 									_map129 := EmptyArrayMap()
// 									_map129.Add(MakeKeyword("Scheme"), MakeString((*_elem128).Scheme))
// 									_map129.Add(MakeKeyword("Opaque"), MakeString((*_elem128).Opaque))
// 									_map129.Add(MakeKeyword("User"), (*(*_elem128).User))
// 									_map129.Add(MakeKeyword("Host"), MakeString((*_elem128).Host))
// 									_map129.Add(MakeKeyword("Path"), MakeString((*_elem128).Path))
// 									_map129.Add(MakeKeyword("RawPath"), MakeString((*_elem128).RawPath))
// 									_map129.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem128).ForceQuery))
// 									_map129.Add(MakeKeyword("RawQuery"), MakeString((*_elem128).RawQuery))
// 									_map129.Add(MakeKeyword("Fragment"), MakeString((*_elem128).Fragment))
// 									_obj_map129 = Object(_map129)
// 								} else {
// 									_obj_map129 = NIL
// 								}
// 								_vec128 = _vec128.Conjoin(_obj_map129)
// 							}
// 							_map77.Add(MakeKeyword("URIs"), _vec128)
// 							_map77.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem76).PermittedDNSDomainsCritical))
// 							_vec130 := EmptyVector
// 							for _, _elem130 := range (*_elem76).PermittedDNSDomains {
// 								_vec130 = _vec130.Conjoin(MakeString(_elem130))
// 							}
// 							_map77.Add(MakeKeyword("PermittedDNSDomains"), _vec130)
// 							_vec131 := EmptyVector
// 							for _, _elem131 := range (*_elem76).ExcludedDNSDomains {
// 								_vec131 = _vec131.Conjoin(MakeString(_elem131))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedDNSDomains"), _vec131)
// 							_vec132 := EmptyVector
// 							for _, _elem132 := range (*_elem76).PermittedIPRanges {
// 								var _obj_map133 Object
// 								if _elem132 != nil {
// 									_map133 := EmptyArrayMap()
// 									_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 									_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 									_obj_map133 = Object(_map133)
// 								} else {
// 									_obj_map133 = NIL
// 								}
// 								_vec132 = _vec132.Conjoin(_obj_map133)
// 							}
// 							_map77.Add(MakeKeyword("PermittedIPRanges"), _vec132)
// 							_vec134 := EmptyVector
// 							for _, _elem134 := range (*_elem76).ExcludedIPRanges {
// 								var _obj_map135 Object
// 								if _elem134 != nil {
// 									_map135 := EmptyArrayMap()
// 									_map135.Add(MakeKeyword("IP"), (*_elem134).IP)
// 									_map135.Add(MakeKeyword("Mask"), (*_elem134).Mask)
// 									_obj_map135 = Object(_map135)
// 								} else {
// 									_obj_map135 = NIL
// 								}
// 								_vec134 = _vec134.Conjoin(_obj_map135)
// 							}
// 							_map77.Add(MakeKeyword("ExcludedIPRanges"), _vec134)
// 							_vec136 := EmptyVector
// 							for _, _elem136 := range (*_elem76).PermittedEmailAddresses {
// 								_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 							}
// 							_map77.Add(MakeKeyword("PermittedEmailAddresses"), _vec136)
// 							_vec137 := EmptyVector
// 							for _, _elem137 := range (*_elem76).ExcludedEmailAddresses {
// 								_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedEmailAddresses"), _vec137)
// 							_vec138 := EmptyVector
// 							for _, _elem138 := range (*_elem76).PermittedURIDomains {
// 								_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 							}
// 							_map77.Add(MakeKeyword("PermittedURIDomains"), _vec138)
// 							_vec139 := EmptyVector
// 							for _, _elem139 := range (*_elem76).ExcludedURIDomains {
// 								_vec139 = _vec139.Conjoin(MakeString(_elem139))
// 							}
// 							_map77.Add(MakeKeyword("ExcludedURIDomains"), _vec139)
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range (*_elem76).CRLDistributionPoints {
// 								_vec140 = _vec140.Conjoin(MakeString(_elem140))
// 							}
// 							_map77.Add(MakeKeyword("CRLDistributionPoints"), _vec140)
// 							_vec141 := EmptyVector
// 							for _, _elem141 := range (*_elem76).PolicyIdentifiers {
// 								_vec142 := EmptyVector
// 								for _, _elem142 := range _elem141 {
// 									_vec142 = _vec142.Conjoin(MakeInt(_elem142))
// 								}
// 								_vec141 = _vec141.Conjoin(_vec142)
// 							}
// 							_map77.Add(MakeKeyword("PolicyIdentifiers"), _vec141)
// 							_obj_map77 = Object(_map77)
// 						} else {
// 							_obj_map77 = NIL
// 						}
// 						_vec76 = _vec76.Conjoin(_obj_map77)
// 					}
// 					_vec75 = _vec75.Conjoin(_vec76)
// 				}
// 				_map7.Add(MakeKeyword("VerifiedChains"), _vec75)
// 				_vec143 := EmptyVector
// 				for _, _elem143 := range (*(*(*_res1).Request).TLS).SignedCertificateTimestamps {
// 					_vec144 := EmptyVector
// 					for _, _elem144 := range _elem143 {
// 						_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 					}
// 					_vec143 = _vec143.Conjoin(_vec144)
// 				}
// 				_map7.Add(MakeKeyword("SignedCertificateTimestamps"), _vec143)
// 				_vec145 := EmptyVector
// 				for _, _elem145 := range (*(*(*_res1).Request).TLS).OCSPResponse {
// 					_vec145 = _vec145.Conjoin(MakeInt(int(_elem145)))
// 				}
// 				_map7.Add(MakeKeyword("OCSPResponse"), _vec145)
// 				_vec146 := EmptyVector
// 				for _, _elem146 := range (*(*(*_res1).Request).TLS).TLSUnique {
// 					_vec146 = _vec146.Conjoin(MakeInt(int(_elem146)))
// 				}
// 				_map7.Add(MakeKeyword("TLSUnique"), _vec146)
// 				_obj_map7 = Object(_map7)
// 			} else {
// 				_obj_map7 = NIL
// 			}
// 			_map3.Add(MakeKeyword("TLS"), _obj_map7)
// 			_map3.Add(MakeKeyword("Cancel"), (*(*_res1).Request).Cancel)
// 			_map3.Add(MakeKeyword("Response"), )
// 			_obj_map3 = Object(_map3)
// 		} else {
// 			_obj_map3 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Request"), _obj_map3)
// 		var _obj_map147 Object
// 		if (*_res1).TLS != nil {
// 			_map147 := EmptyArrayMap()
// 			_map147.Add(MakeKeyword("Version"), MakeInt(int((*(*_res1).TLS).Version)))
// 			_map147.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res1).TLS).HandshakeComplete))
// 			_map147.Add(MakeKeyword("DidResume"), MakeBool((*(*_res1).TLS).DidResume))
// 			_map147.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res1).TLS).CipherSuite)))
// 			_map147.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res1).TLS).NegotiatedProtocol))
// 			_map147.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res1).TLS).NegotiatedProtocolIsMutual))
// 			_map147.Add(MakeKeyword("ServerName"), MakeString((*(*_res1).TLS).ServerName))
// 			_vec148 := EmptyVector
// 			for _, _elem148 := range (*(*_res1).TLS).PeerCertificates {
// 				var _obj_map149 Object
// 				if _elem148 != nil {
// 					_map149 := EmptyArrayMap()
// 					_vec150 := EmptyVector
// 					for _, _elem150 := range (*_elem148).Raw {
// 						_vec150 = _vec150.Conjoin(MakeInt(int(_elem150)))
// 					}
// 					_map149.Add(MakeKeyword("Raw"), _vec150)
// 					_vec151 := EmptyVector
// 					for _, _elem151 := range (*_elem148).RawTBSCertificate {
// 						_vec151 = _vec151.Conjoin(MakeInt(int(_elem151)))
// 					}
// 					_map149.Add(MakeKeyword("RawTBSCertificate"), _vec151)
// 					_vec152 := EmptyVector
// 					for _, _elem152 := range (*_elem148).RawSubjectPublicKeyInfo {
// 						_vec152 = _vec152.Conjoin(MakeInt(int(_elem152)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec152)
// 					_vec153 := EmptyVector
// 					for _, _elem153 := range (*_elem148).RawSubject {
// 						_vec153 = _vec153.Conjoin(MakeInt(int(_elem153)))
// 					}
// 					_map149.Add(MakeKeyword("RawSubject"), _vec153)
// 					_vec154 := EmptyVector
// 					for _, _elem154 := range (*_elem148).RawIssuer {
// 						_vec154 = _vec154.Conjoin(MakeInt(int(_elem154)))
// 					}
// 					_map149.Add(MakeKeyword("RawIssuer"), _vec154)
// 					_vec155 := EmptyVector
// 					for _, _elem155 := range (*_elem148).Signature {
// 						_vec155 = _vec155.Conjoin(MakeInt(int(_elem155)))
// 					}
// 					_map149.Add(MakeKeyword("Signature"), _vec155)
// 					_map149.Add(MakeKeyword("SignatureAlgorithm"), (*_elem148).SignatureAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem148).PublicKeyAlgorithm)
// 					_map149.Add(MakeKeyword("PublicKey"), (*_elem148).PublicKey)
// 					_map149.Add(MakeKeyword("Version"), MakeInt((*_elem148).Version))
// 					_map149.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map157 := EmptyArrayMap()
// 					_vec158 := EmptyVector
// 					for _, _elem158 := range (*_elem148).Issuer.Country {
// 						_vec158 = _vec158.Conjoin(MakeString(_elem158))
// 					}
// 					_map157.Add(MakeKeyword("Country"), _vec158)
// 					_vec159 := EmptyVector
// 					for _, _elem159 := range (*_elem148).Issuer.Organization {
// 						_vec159 = _vec159.Conjoin(MakeString(_elem159))
// 					}
// 					_map157.Add(MakeKeyword("Organization"), _vec159)
// 					_vec160 := EmptyVector
// 					for _, _elem160 := range (*_elem148).Issuer.OrganizationalUnit {
// 						_vec160 = _vec160.Conjoin(MakeString(_elem160))
// 					}
// 					_map157.Add(MakeKeyword("OrganizationalUnit"), _vec160)
// 					_vec161 := EmptyVector
// 					for _, _elem161 := range (*_elem148).Issuer.Locality {
// 						_vec161 = _vec161.Conjoin(MakeString(_elem161))
// 					}
// 					_map157.Add(MakeKeyword("Locality"), _vec161)
// 					_vec162 := EmptyVector
// 					for _, _elem162 := range (*_elem148).Issuer.Province {
// 						_vec162 = _vec162.Conjoin(MakeString(_elem162))
// 					}
// 					_map157.Add(MakeKeyword("Province"), _vec162)
// 					_vec163 := EmptyVector
// 					for _, _elem163 := range (*_elem148).Issuer.StreetAddress {
// 						_vec163 = _vec163.Conjoin(MakeString(_elem163))
// 					}
// 					_map157.Add(MakeKeyword("StreetAddress"), _vec163)
// 					_vec164 := EmptyVector
// 					for _, _elem164 := range (*_elem148).Issuer.PostalCode {
// 						_vec164 = _vec164.Conjoin(MakeString(_elem164))
// 					}
// 					_map157.Add(MakeKeyword("PostalCode"), _vec164)
// 					_map157.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Issuer.SerialNumber))
// 					_map157.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Issuer.CommonName))
// 					_vec165 := EmptyVector
// 					for _, _elem165 := range (*_elem148).Issuer.Names {
// 						_vec165 = _vec165.Conjoin(_elem165)
// 					}
// 					_map157.Add(MakeKeyword("Names"), _vec165)
// 					_vec166 := EmptyVector
// 					for _, _elem166 := range (*_elem148).Issuer.ExtraNames {
// 						_vec166 = _vec166.Conjoin(_elem166)
// 					}
// 					_map157.Add(MakeKeyword("ExtraNames"), _vec166)
// 					_map149.Add(MakeKeyword("Issuer"), _map157)
// 					_map167 := EmptyArrayMap()
// 					_vec168 := EmptyVector
// 					for _, _elem168 := range (*_elem148).Subject.Country {
// 						_vec168 = _vec168.Conjoin(MakeString(_elem168))
// 					}
// 					_map167.Add(MakeKeyword("Country"), _vec168)
// 					_vec169 := EmptyVector
// 					for _, _elem169 := range (*_elem148).Subject.Organization {
// 						_vec169 = _vec169.Conjoin(MakeString(_elem169))
// 					}
// 					_map167.Add(MakeKeyword("Organization"), _vec169)
// 					_vec170 := EmptyVector
// 					for _, _elem170 := range (*_elem148).Subject.OrganizationalUnit {
// 						_vec170 = _vec170.Conjoin(MakeString(_elem170))
// 					}
// 					_map167.Add(MakeKeyword("OrganizationalUnit"), _vec170)
// 					_vec171 := EmptyVector
// 					for _, _elem171 := range (*_elem148).Subject.Locality {
// 						_vec171 = _vec171.Conjoin(MakeString(_elem171))
// 					}
// 					_map167.Add(MakeKeyword("Locality"), _vec171)
// 					_vec172 := EmptyVector
// 					for _, _elem172 := range (*_elem148).Subject.Province {
// 						_vec172 = _vec172.Conjoin(MakeString(_elem172))
// 					}
// 					_map167.Add(MakeKeyword("Province"), _vec172)
// 					_vec173 := EmptyVector
// 					for _, _elem173 := range (*_elem148).Subject.StreetAddress {
// 						_vec173 = _vec173.Conjoin(MakeString(_elem173))
// 					}
// 					_map167.Add(MakeKeyword("StreetAddress"), _vec173)
// 					_vec174 := EmptyVector
// 					for _, _elem174 := range (*_elem148).Subject.PostalCode {
// 						_vec174 = _vec174.Conjoin(MakeString(_elem174))
// 					}
// 					_map167.Add(MakeKeyword("PostalCode"), _vec174)
// 					_map167.Add(MakeKeyword("SerialNumber"), MakeString((*_elem148).Subject.SerialNumber))
// 					_map167.Add(MakeKeyword("CommonName"), MakeString((*_elem148).Subject.CommonName))
// 					_vec175 := EmptyVector
// 					for _, _elem175 := range (*_elem148).Subject.Names {
// 						_vec175 = _vec175.Conjoin(_elem175)
// 					}
// 					_map167.Add(MakeKeyword("Names"), _vec175)
// 					_vec176 := EmptyVector
// 					for _, _elem176 := range (*_elem148).Subject.ExtraNames {
// 						_vec176 = _vec176.Conjoin(_elem176)
// 					}
// 					_map167.Add(MakeKeyword("ExtraNames"), _vec176)
// 					_map149.Add(MakeKeyword("Subject"), _map167)
// 					_map149.Add(MakeKeyword("NotBefore"), NIL)
// 					_map149.Add(MakeKeyword("NotAfter"), NIL)
// 					_map149.Add(MakeKeyword("KeyUsage"), (*_elem148).KeyUsage)
// 					_vec179 := EmptyVector
// 					for _, _elem179 := range (*_elem148).Extensions {
// 						_map180 := EmptyArrayMap()
// 						_vec181 := EmptyVector
// 						for _, _elem181 := range _elem179.Id {
// 							_vec181 = _vec181.Conjoin(MakeInt(_elem181))
// 						}
// 						_map180.Add(MakeKeyword("Id"), _vec181)
// 						_map180.Add(MakeKeyword("Critical"), MakeBool(_elem179.Critical))
// 						_vec182 := EmptyVector
// 						for _, _elem182 := range _elem179.Value {
// 							_vec182 = _vec182.Conjoin(MakeInt(int(_elem182)))
// 						}
// 						_map180.Add(MakeKeyword("Value"), _vec182)
// 						_vec179 = _vec179.Conjoin(_map180)
// 					}
// 					_map149.Add(MakeKeyword("Extensions"), _vec179)
// 					_vec183 := EmptyVector
// 					for _, _elem183 := range (*_elem148).ExtraExtensions {
// 						_map184 := EmptyArrayMap()
// 						_vec185 := EmptyVector
// 						for _, _elem185 := range _elem183.Id {
// 							_vec185 = _vec185.Conjoin(MakeInt(_elem185))
// 						}
// 						_map184.Add(MakeKeyword("Id"), _vec185)
// 						_map184.Add(MakeKeyword("Critical"), MakeBool(_elem183.Critical))
// 						_vec186 := EmptyVector
// 						for _, _elem186 := range _elem183.Value {
// 							_vec186 = _vec186.Conjoin(MakeInt(int(_elem186)))
// 						}
// 						_map184.Add(MakeKeyword("Value"), _vec186)
// 						_vec183 = _vec183.Conjoin(_map184)
// 					}
// 					_map149.Add(MakeKeyword("ExtraExtensions"), _vec183)
// 					_vec187 := EmptyVector
// 					for _, _elem187 := range (*_elem148).UnhandledCriticalExtensions {
// 						_vec188 := EmptyVector
// 						for _, _elem188 := range _elem187 {
// 							_vec188 = _vec188.Conjoin(MakeInt(_elem188))
// 						}
// 						_vec187 = _vec187.Conjoin(_vec188)
// 					}
// 					_map149.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec187)
// 					_vec189 := EmptyVector
// 					for _, _elem189 := range (*_elem148).ExtKeyUsage {
// 						_vec189 = _vec189.Conjoin(_elem189)
// 					}
// 					_map149.Add(MakeKeyword("ExtKeyUsage"), _vec189)
// 					_vec190 := EmptyVector
// 					for _, _elem190 := range (*_elem148).UnknownExtKeyUsage {
// 						_vec191 := EmptyVector
// 						for _, _elem191 := range _elem190 {
// 							_vec191 = _vec191.Conjoin(MakeInt(_elem191))
// 						}
// 						_vec190 = _vec190.Conjoin(_vec191)
// 					}
// 					_map149.Add(MakeKeyword("UnknownExtKeyUsage"), _vec190)
// 					_map149.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem148).BasicConstraintsValid))
// 					_map149.Add(MakeKeyword("IsCA"), MakeBool((*_elem148).IsCA))
// 					_map149.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem148).MaxPathLen))
// 					_map149.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem148).MaxPathLenZero))
// 					_vec192 := EmptyVector
// 					for _, _elem192 := range (*_elem148).SubjectKeyId {
// 						_vec192 = _vec192.Conjoin(MakeInt(int(_elem192)))
// 					}
// 					_map149.Add(MakeKeyword("SubjectKeyId"), _vec192)
// 					_vec193 := EmptyVector
// 					for _, _elem193 := range (*_elem148).AuthorityKeyId {
// 						_vec193 = _vec193.Conjoin(MakeInt(int(_elem193)))
// 					}
// 					_map149.Add(MakeKeyword("AuthorityKeyId"), _vec193)
// 					_vec194 := EmptyVector
// 					for _, _elem194 := range (*_elem148).OCSPServer {
// 						_vec194 = _vec194.Conjoin(MakeString(_elem194))
// 					}
// 					_map149.Add(MakeKeyword("OCSPServer"), _vec194)
// 					_vec195 := EmptyVector
// 					for _, _elem195 := range (*_elem148).IssuingCertificateURL {
// 						_vec195 = _vec195.Conjoin(MakeString(_elem195))
// 					}
// 					_map149.Add(MakeKeyword("IssuingCertificateURL"), _vec195)
// 					_vec196 := EmptyVector
// 					for _, _elem196 := range (*_elem148).DNSNames {
// 						_vec196 = _vec196.Conjoin(MakeString(_elem196))
// 					}
// 					_map149.Add(MakeKeyword("DNSNames"), _vec196)
// 					_vec197 := EmptyVector
// 					for _, _elem197 := range (*_elem148).EmailAddresses {
// 						_vec197 = _vec197.Conjoin(MakeString(_elem197))
// 					}
// 					_map149.Add(MakeKeyword("EmailAddresses"), _vec197)
// 					_vec198 := EmptyVector
// 					for _, _elem198 := range (*_elem148).IPAddresses {
// 						_vec199 := EmptyVector
// 						for _, _elem199 := range _elem198 {
// 							_vec199 = _vec199.Conjoin(MakeInt(int(_elem199)))
// 						}
// 						_vec198 = _vec198.Conjoin(_vec199)
// 					}
// 					_map149.Add(MakeKeyword("IPAddresses"), _vec198)
// 					_vec200 := EmptyVector
// 					for _, _elem200 := range (*_elem148).URIs {
// 						var _obj_map201 Object
// 						if _elem200 != nil {
// 							_map201 := EmptyArrayMap()
// 							_map201.Add(MakeKeyword("Scheme"), MakeString((*_elem200).Scheme))
// 							_map201.Add(MakeKeyword("Opaque"), MakeString((*_elem200).Opaque))
// 							_map201.Add(MakeKeyword("User"), (*(*_elem200).User))
// 							_map201.Add(MakeKeyword("Host"), MakeString((*_elem200).Host))
// 							_map201.Add(MakeKeyword("Path"), MakeString((*_elem200).Path))
// 							_map201.Add(MakeKeyword("RawPath"), MakeString((*_elem200).RawPath))
// 							_map201.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem200).ForceQuery))
// 							_map201.Add(MakeKeyword("RawQuery"), MakeString((*_elem200).RawQuery))
// 							_map201.Add(MakeKeyword("Fragment"), MakeString((*_elem200).Fragment))
// 							_obj_map201 = Object(_map201)
// 						} else {
// 							_obj_map201 = NIL
// 						}
// 						_vec200 = _vec200.Conjoin(_obj_map201)
// 					}
// 					_map149.Add(MakeKeyword("URIs"), _vec200)
// 					_map149.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem148).PermittedDNSDomainsCritical))
// 					_vec202 := EmptyVector
// 					for _, _elem202 := range (*_elem148).PermittedDNSDomains {
// 						_vec202 = _vec202.Conjoin(MakeString(_elem202))
// 					}
// 					_map149.Add(MakeKeyword("PermittedDNSDomains"), _vec202)
// 					_vec203 := EmptyVector
// 					for _, _elem203 := range (*_elem148).ExcludedDNSDomains {
// 						_vec203 = _vec203.Conjoin(MakeString(_elem203))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedDNSDomains"), _vec203)
// 					_vec204 := EmptyVector
// 					for _, _elem204 := range (*_elem148).PermittedIPRanges {
// 						var _obj_map205 Object
// 						if _elem204 != nil {
// 							_map205 := EmptyArrayMap()
// 							_map205.Add(MakeKeyword("IP"), (*_elem204).IP)
// 							_map205.Add(MakeKeyword("Mask"), (*_elem204).Mask)
// 							_obj_map205 = Object(_map205)
// 						} else {
// 							_obj_map205 = NIL
// 						}
// 						_vec204 = _vec204.Conjoin(_obj_map205)
// 					}
// 					_map149.Add(MakeKeyword("PermittedIPRanges"), _vec204)
// 					_vec206 := EmptyVector
// 					for _, _elem206 := range (*_elem148).ExcludedIPRanges {
// 						var _obj_map207 Object
// 						if _elem206 != nil {
// 							_map207 := EmptyArrayMap()
// 							_map207.Add(MakeKeyword("IP"), (*_elem206).IP)
// 							_map207.Add(MakeKeyword("Mask"), (*_elem206).Mask)
// 							_obj_map207 = Object(_map207)
// 						} else {
// 							_obj_map207 = NIL
// 						}
// 						_vec206 = _vec206.Conjoin(_obj_map207)
// 					}
// 					_map149.Add(MakeKeyword("ExcludedIPRanges"), _vec206)
// 					_vec208 := EmptyVector
// 					for _, _elem208 := range (*_elem148).PermittedEmailAddresses {
// 						_vec208 = _vec208.Conjoin(MakeString(_elem208))
// 					}
// 					_map149.Add(MakeKeyword("PermittedEmailAddresses"), _vec208)
// 					_vec209 := EmptyVector
// 					for _, _elem209 := range (*_elem148).ExcludedEmailAddresses {
// 						_vec209 = _vec209.Conjoin(MakeString(_elem209))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedEmailAddresses"), _vec209)
// 					_vec210 := EmptyVector
// 					for _, _elem210 := range (*_elem148).PermittedURIDomains {
// 						_vec210 = _vec210.Conjoin(MakeString(_elem210))
// 					}
// 					_map149.Add(MakeKeyword("PermittedURIDomains"), _vec210)
// 					_vec211 := EmptyVector
// 					for _, _elem211 := range (*_elem148).ExcludedURIDomains {
// 						_vec211 = _vec211.Conjoin(MakeString(_elem211))
// 					}
// 					_map149.Add(MakeKeyword("ExcludedURIDomains"), _vec211)
// 					_vec212 := EmptyVector
// 					for _, _elem212 := range (*_elem148).CRLDistributionPoints {
// 						_vec212 = _vec212.Conjoin(MakeString(_elem212))
// 					}
// 					_map149.Add(MakeKeyword("CRLDistributionPoints"), _vec212)
// 					_vec213 := EmptyVector
// 					for _, _elem213 := range (*_elem148).PolicyIdentifiers {
// 						_vec214 := EmptyVector
// 						for _, _elem214 := range _elem213 {
// 							_vec214 = _vec214.Conjoin(MakeInt(_elem214))
// 						}
// 						_vec213 = _vec213.Conjoin(_vec214)
// 					}
// 					_map149.Add(MakeKeyword("PolicyIdentifiers"), _vec213)
// 					_obj_map149 = Object(_map149)
// 				} else {
// 					_obj_map149 = NIL
// 				}
// 				_vec148 = _vec148.Conjoin(_obj_map149)
// 			}
// 			_map147.Add(MakeKeyword("PeerCertificates"), _vec148)
// 			_vec215 := EmptyVector
// 			for _, _elem215 := range (*(*_res1).TLS).VerifiedChains {
// 				_vec216 := EmptyVector
// 				for _, _elem216 := range _elem215 {
// 					var _obj_map217 Object
// 					if _elem216 != nil {
// 						_map217 := EmptyArrayMap()
// 						_vec218 := EmptyVector
// 						for _, _elem218 := range (*_elem216).Raw {
// 							_vec218 = _vec218.Conjoin(MakeInt(int(_elem218)))
// 						}
// 						_map217.Add(MakeKeyword("Raw"), _vec218)
// 						_vec219 := EmptyVector
// 						for _, _elem219 := range (*_elem216).RawTBSCertificate {
// 							_vec219 = _vec219.Conjoin(MakeInt(int(_elem219)))
// 						}
// 						_map217.Add(MakeKeyword("RawTBSCertificate"), _vec219)
// 						_vec220 := EmptyVector
// 						for _, _elem220 := range (*_elem216).RawSubjectPublicKeyInfo {
// 							_vec220 = _vec220.Conjoin(MakeInt(int(_elem220)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec220)
// 						_vec221 := EmptyVector
// 						for _, _elem221 := range (*_elem216).RawSubject {
// 							_vec221 = _vec221.Conjoin(MakeInt(int(_elem221)))
// 						}
// 						_map217.Add(MakeKeyword("RawSubject"), _vec221)
// 						_vec222 := EmptyVector
// 						for _, _elem222 := range (*_elem216).RawIssuer {
// 							_vec222 = _vec222.Conjoin(MakeInt(int(_elem222)))
// 						}
// 						_map217.Add(MakeKeyword("RawIssuer"), _vec222)
// 						_vec223 := EmptyVector
// 						for _, _elem223 := range (*_elem216).Signature {
// 							_vec223 = _vec223.Conjoin(MakeInt(int(_elem223)))
// 						}
// 						_map217.Add(MakeKeyword("Signature"), _vec223)
// 						_map217.Add(MakeKeyword("SignatureAlgorithm"), (*_elem216).SignatureAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem216).PublicKeyAlgorithm)
// 						_map217.Add(MakeKeyword("PublicKey"), (*_elem216).PublicKey)
// 						_map217.Add(MakeKeyword("Version"), MakeInt((*_elem216).Version))
// 						_map217.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map225 := EmptyArrayMap()
// 						_vec226 := EmptyVector
// 						for _, _elem226 := range (*_elem216).Issuer.Country {
// 							_vec226 = _vec226.Conjoin(MakeString(_elem226))
// 						}
// 						_map225.Add(MakeKeyword("Country"), _vec226)
// 						_vec227 := EmptyVector
// 						for _, _elem227 := range (*_elem216).Issuer.Organization {
// 							_vec227 = _vec227.Conjoin(MakeString(_elem227))
// 						}
// 						_map225.Add(MakeKeyword("Organization"), _vec227)
// 						_vec228 := EmptyVector
// 						for _, _elem228 := range (*_elem216).Issuer.OrganizationalUnit {
// 							_vec228 = _vec228.Conjoin(MakeString(_elem228))
// 						}
// 						_map225.Add(MakeKeyword("OrganizationalUnit"), _vec228)
// 						_vec229 := EmptyVector
// 						for _, _elem229 := range (*_elem216).Issuer.Locality {
// 							_vec229 = _vec229.Conjoin(MakeString(_elem229))
// 						}
// 						_map225.Add(MakeKeyword("Locality"), _vec229)
// 						_vec230 := EmptyVector
// 						for _, _elem230 := range (*_elem216).Issuer.Province {
// 							_vec230 = _vec230.Conjoin(MakeString(_elem230))
// 						}
// 						_map225.Add(MakeKeyword("Province"), _vec230)
// 						_vec231 := EmptyVector
// 						for _, _elem231 := range (*_elem216).Issuer.StreetAddress {
// 							_vec231 = _vec231.Conjoin(MakeString(_elem231))
// 						}
// 						_map225.Add(MakeKeyword("StreetAddress"), _vec231)
// 						_vec232 := EmptyVector
// 						for _, _elem232 := range (*_elem216).Issuer.PostalCode {
// 							_vec232 = _vec232.Conjoin(MakeString(_elem232))
// 						}
// 						_map225.Add(MakeKeyword("PostalCode"), _vec232)
// 						_map225.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Issuer.SerialNumber))
// 						_map225.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Issuer.CommonName))
// 						_vec233 := EmptyVector
// 						for _, _elem233 := range (*_elem216).Issuer.Names {
// 							_vec233 = _vec233.Conjoin(_elem233)
// 						}
// 						_map225.Add(MakeKeyword("Names"), _vec233)
// 						_vec234 := EmptyVector
// 						for _, _elem234 := range (*_elem216).Issuer.ExtraNames {
// 							_vec234 = _vec234.Conjoin(_elem234)
// 						}
// 						_map225.Add(MakeKeyword("ExtraNames"), _vec234)
// 						_map217.Add(MakeKeyword("Issuer"), _map225)
// 						_map235 := EmptyArrayMap()
// 						_vec236 := EmptyVector
// 						for _, _elem236 := range (*_elem216).Subject.Country {
// 							_vec236 = _vec236.Conjoin(MakeString(_elem236))
// 						}
// 						_map235.Add(MakeKeyword("Country"), _vec236)
// 						_vec237 := EmptyVector
// 						for _, _elem237 := range (*_elem216).Subject.Organization {
// 							_vec237 = _vec237.Conjoin(MakeString(_elem237))
// 						}
// 						_map235.Add(MakeKeyword("Organization"), _vec237)
// 						_vec238 := EmptyVector
// 						for _, _elem238 := range (*_elem216).Subject.OrganizationalUnit {
// 							_vec238 = _vec238.Conjoin(MakeString(_elem238))
// 						}
// 						_map235.Add(MakeKeyword("OrganizationalUnit"), _vec238)
// 						_vec239 := EmptyVector
// 						for _, _elem239 := range (*_elem216).Subject.Locality {
// 							_vec239 = _vec239.Conjoin(MakeString(_elem239))
// 						}
// 						_map235.Add(MakeKeyword("Locality"), _vec239)
// 						_vec240 := EmptyVector
// 						for _, _elem240 := range (*_elem216).Subject.Province {
// 							_vec240 = _vec240.Conjoin(MakeString(_elem240))
// 						}
// 						_map235.Add(MakeKeyword("Province"), _vec240)
// 						_vec241 := EmptyVector
// 						for _, _elem241 := range (*_elem216).Subject.StreetAddress {
// 							_vec241 = _vec241.Conjoin(MakeString(_elem241))
// 						}
// 						_map235.Add(MakeKeyword("StreetAddress"), _vec241)
// 						_vec242 := EmptyVector
// 						for _, _elem242 := range (*_elem216).Subject.PostalCode {
// 							_vec242 = _vec242.Conjoin(MakeString(_elem242))
// 						}
// 						_map235.Add(MakeKeyword("PostalCode"), _vec242)
// 						_map235.Add(MakeKeyword("SerialNumber"), MakeString((*_elem216).Subject.SerialNumber))
// 						_map235.Add(MakeKeyword("CommonName"), MakeString((*_elem216).Subject.CommonName))
// 						_vec243 := EmptyVector
// 						for _, _elem243 := range (*_elem216).Subject.Names {
// 							_vec243 = _vec243.Conjoin(_elem243)
// 						}
// 						_map235.Add(MakeKeyword("Names"), _vec243)
// 						_vec244 := EmptyVector
// 						for _, _elem244 := range (*_elem216).Subject.ExtraNames {
// 							_vec244 = _vec244.Conjoin(_elem244)
// 						}
// 						_map235.Add(MakeKeyword("ExtraNames"), _vec244)
// 						_map217.Add(MakeKeyword("Subject"), _map235)
// 						_map217.Add(MakeKeyword("NotBefore"), NIL)
// 						_map217.Add(MakeKeyword("NotAfter"), NIL)
// 						_map217.Add(MakeKeyword("KeyUsage"), (*_elem216).KeyUsage)
// 						_vec247 := EmptyVector
// 						for _, _elem247 := range (*_elem216).Extensions {
// 							_map248 := EmptyArrayMap()
// 							_vec249 := EmptyVector
// 							for _, _elem249 := range _elem247.Id {
// 								_vec249 = _vec249.Conjoin(MakeInt(_elem249))
// 							}
// 							_map248.Add(MakeKeyword("Id"), _vec249)
// 							_map248.Add(MakeKeyword("Critical"), MakeBool(_elem247.Critical))
// 							_vec250 := EmptyVector
// 							for _, _elem250 := range _elem247.Value {
// 								_vec250 = _vec250.Conjoin(MakeInt(int(_elem250)))
// 							}
// 							_map248.Add(MakeKeyword("Value"), _vec250)
// 							_vec247 = _vec247.Conjoin(_map248)
// 						}
// 						_map217.Add(MakeKeyword("Extensions"), _vec247)
// 						_vec251 := EmptyVector
// 						for _, _elem251 := range (*_elem216).ExtraExtensions {
// 							_map252 := EmptyArrayMap()
// 							_vec253 := EmptyVector
// 							for _, _elem253 := range _elem251.Id {
// 								_vec253 = _vec253.Conjoin(MakeInt(_elem253))
// 							}
// 							_map252.Add(MakeKeyword("Id"), _vec253)
// 							_map252.Add(MakeKeyword("Critical"), MakeBool(_elem251.Critical))
// 							_vec254 := EmptyVector
// 							for _, _elem254 := range _elem251.Value {
// 								_vec254 = _vec254.Conjoin(MakeInt(int(_elem254)))
// 							}
// 							_map252.Add(MakeKeyword("Value"), _vec254)
// 							_vec251 = _vec251.Conjoin(_map252)
// 						}
// 						_map217.Add(MakeKeyword("ExtraExtensions"), _vec251)
// 						_vec255 := EmptyVector
// 						for _, _elem255 := range (*_elem216).UnhandledCriticalExtensions {
// 							_vec256 := EmptyVector
// 							for _, _elem256 := range _elem255 {
// 								_vec256 = _vec256.Conjoin(MakeInt(_elem256))
// 							}
// 							_vec255 = _vec255.Conjoin(_vec256)
// 						}
// 						_map217.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec255)
// 						_vec257 := EmptyVector
// 						for _, _elem257 := range (*_elem216).ExtKeyUsage {
// 							_vec257 = _vec257.Conjoin(_elem257)
// 						}
// 						_map217.Add(MakeKeyword("ExtKeyUsage"), _vec257)
// 						_vec258 := EmptyVector
// 						for _, _elem258 := range (*_elem216).UnknownExtKeyUsage {
// 							_vec259 := EmptyVector
// 							for _, _elem259 := range _elem258 {
// 								_vec259 = _vec259.Conjoin(MakeInt(_elem259))
// 							}
// 							_vec258 = _vec258.Conjoin(_vec259)
// 						}
// 						_map217.Add(MakeKeyword("UnknownExtKeyUsage"), _vec258)
// 						_map217.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem216).BasicConstraintsValid))
// 						_map217.Add(MakeKeyword("IsCA"), MakeBool((*_elem216).IsCA))
// 						_map217.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem216).MaxPathLen))
// 						_map217.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem216).MaxPathLenZero))
// 						_vec260 := EmptyVector
// 						for _, _elem260 := range (*_elem216).SubjectKeyId {
// 							_vec260 = _vec260.Conjoin(MakeInt(int(_elem260)))
// 						}
// 						_map217.Add(MakeKeyword("SubjectKeyId"), _vec260)
// 						_vec261 := EmptyVector
// 						for _, _elem261 := range (*_elem216).AuthorityKeyId {
// 							_vec261 = _vec261.Conjoin(MakeInt(int(_elem261)))
// 						}
// 						_map217.Add(MakeKeyword("AuthorityKeyId"), _vec261)
// 						_vec262 := EmptyVector
// 						for _, _elem262 := range (*_elem216).OCSPServer {
// 							_vec262 = _vec262.Conjoin(MakeString(_elem262))
// 						}
// 						_map217.Add(MakeKeyword("OCSPServer"), _vec262)
// 						_vec263 := EmptyVector
// 						for _, _elem263 := range (*_elem216).IssuingCertificateURL {
// 							_vec263 = _vec263.Conjoin(MakeString(_elem263))
// 						}
// 						_map217.Add(MakeKeyword("IssuingCertificateURL"), _vec263)
// 						_vec264 := EmptyVector
// 						for _, _elem264 := range (*_elem216).DNSNames {
// 							_vec264 = _vec264.Conjoin(MakeString(_elem264))
// 						}
// 						_map217.Add(MakeKeyword("DNSNames"), _vec264)
// 						_vec265 := EmptyVector
// 						for _, _elem265 := range (*_elem216).EmailAddresses {
// 							_vec265 = _vec265.Conjoin(MakeString(_elem265))
// 						}
// 						_map217.Add(MakeKeyword("EmailAddresses"), _vec265)
// 						_vec266 := EmptyVector
// 						for _, _elem266 := range (*_elem216).IPAddresses {
// 							_vec267 := EmptyVector
// 							for _, _elem267 := range _elem266 {
// 								_vec267 = _vec267.Conjoin(MakeInt(int(_elem267)))
// 							}
// 							_vec266 = _vec266.Conjoin(_vec267)
// 						}
// 						_map217.Add(MakeKeyword("IPAddresses"), _vec266)
// 						_vec268 := EmptyVector
// 						for _, _elem268 := range (*_elem216).URIs {
// 							var _obj_map269 Object
// 							if _elem268 != nil {
// 								_map269 := EmptyArrayMap()
// 								_map269.Add(MakeKeyword("Scheme"), MakeString((*_elem268).Scheme))
// 								_map269.Add(MakeKeyword("Opaque"), MakeString((*_elem268).Opaque))
// 								_map269.Add(MakeKeyword("User"), (*(*_elem268).User))
// 								_map269.Add(MakeKeyword("Host"), MakeString((*_elem268).Host))
// 								_map269.Add(MakeKeyword("Path"), MakeString((*_elem268).Path))
// 								_map269.Add(MakeKeyword("RawPath"), MakeString((*_elem268).RawPath))
// 								_map269.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem268).ForceQuery))
// 								_map269.Add(MakeKeyword("RawQuery"), MakeString((*_elem268).RawQuery))
// 								_map269.Add(MakeKeyword("Fragment"), MakeString((*_elem268).Fragment))
// 								_obj_map269 = Object(_map269)
// 							} else {
// 								_obj_map269 = NIL
// 							}
// 							_vec268 = _vec268.Conjoin(_obj_map269)
// 						}
// 						_map217.Add(MakeKeyword("URIs"), _vec268)
// 						_map217.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem216).PermittedDNSDomainsCritical))
// 						_vec270 := EmptyVector
// 						for _, _elem270 := range (*_elem216).PermittedDNSDomains {
// 							_vec270 = _vec270.Conjoin(MakeString(_elem270))
// 						}
// 						_map217.Add(MakeKeyword("PermittedDNSDomains"), _vec270)
// 						_vec271 := EmptyVector
// 						for _, _elem271 := range (*_elem216).ExcludedDNSDomains {
// 							_vec271 = _vec271.Conjoin(MakeString(_elem271))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedDNSDomains"), _vec271)
// 						_vec272 := EmptyVector
// 						for _, _elem272 := range (*_elem216).PermittedIPRanges {
// 							var _obj_map273 Object
// 							if _elem272 != nil {
// 								_map273 := EmptyArrayMap()
// 								_map273.Add(MakeKeyword("IP"), (*_elem272).IP)
// 								_map273.Add(MakeKeyword("Mask"), (*_elem272).Mask)
// 								_obj_map273 = Object(_map273)
// 							} else {
// 								_obj_map273 = NIL
// 							}
// 							_vec272 = _vec272.Conjoin(_obj_map273)
// 						}
// 						_map217.Add(MakeKeyword("PermittedIPRanges"), _vec272)
// 						_vec274 := EmptyVector
// 						for _, _elem274 := range (*_elem216).ExcludedIPRanges {
// 							var _obj_map275 Object
// 							if _elem274 != nil {
// 								_map275 := EmptyArrayMap()
// 								_map275.Add(MakeKeyword("IP"), (*_elem274).IP)
// 								_map275.Add(MakeKeyword("Mask"), (*_elem274).Mask)
// 								_obj_map275 = Object(_map275)
// 							} else {
// 								_obj_map275 = NIL
// 							}
// 							_vec274 = _vec274.Conjoin(_obj_map275)
// 						}
// 						_map217.Add(MakeKeyword("ExcludedIPRanges"), _vec274)
// 						_vec276 := EmptyVector
// 						for _, _elem276 := range (*_elem216).PermittedEmailAddresses {
// 							_vec276 = _vec276.Conjoin(MakeString(_elem276))
// 						}
// 						_map217.Add(MakeKeyword("PermittedEmailAddresses"), _vec276)
// 						_vec277 := EmptyVector
// 						for _, _elem277 := range (*_elem216).ExcludedEmailAddresses {
// 							_vec277 = _vec277.Conjoin(MakeString(_elem277))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedEmailAddresses"), _vec277)
// 						_vec278 := EmptyVector
// 						for _, _elem278 := range (*_elem216).PermittedURIDomains {
// 							_vec278 = _vec278.Conjoin(MakeString(_elem278))
// 						}
// 						_map217.Add(MakeKeyword("PermittedURIDomains"), _vec278)
// 						_vec279 := EmptyVector
// 						for _, _elem279 := range (*_elem216).ExcludedURIDomains {
// 							_vec279 = _vec279.Conjoin(MakeString(_elem279))
// 						}
// 						_map217.Add(MakeKeyword("ExcludedURIDomains"), _vec279)
// 						_vec280 := EmptyVector
// 						for _, _elem280 := range (*_elem216).CRLDistributionPoints {
// 							_vec280 = _vec280.Conjoin(MakeString(_elem280))
// 						}
// 						_map217.Add(MakeKeyword("CRLDistributionPoints"), _vec280)
// 						_vec281 := EmptyVector
// 						for _, _elem281 := range (*_elem216).PolicyIdentifiers {
// 							_vec282 := EmptyVector
// 							for _, _elem282 := range _elem281 {
// 								_vec282 = _vec282.Conjoin(MakeInt(_elem282))
// 							}
// 							_vec281 = _vec281.Conjoin(_vec282)
// 						}
// 						_map217.Add(MakeKeyword("PolicyIdentifiers"), _vec281)
// 						_obj_map217 = Object(_map217)
// 					} else {
// 						_obj_map217 = NIL
// 					}
// 					_vec216 = _vec216.Conjoin(_obj_map217)
// 				}
// 				_vec215 = _vec215.Conjoin(_vec216)
// 			}
// 			_map147.Add(MakeKeyword("VerifiedChains"), _vec215)
// 			_vec283 := EmptyVector
// 			for _, _elem283 := range (*(*_res1).TLS).SignedCertificateTimestamps {
// 				_vec284 := EmptyVector
// 				for _, _elem284 := range _elem283 {
// 					_vec284 = _vec284.Conjoin(MakeInt(int(_elem284)))
// 				}
// 				_vec283 = _vec283.Conjoin(_vec284)
// 			}
// 			_map147.Add(MakeKeyword("SignedCertificateTimestamps"), _vec283)
// 			_vec285 := EmptyVector
// 			for _, _elem285 := range (*(*_res1).TLS).OCSPResponse {
// 				_vec285 = _vec285.Conjoin(MakeInt(int(_elem285)))
// 			}
// 			_map147.Add(MakeKeyword("OCSPResponse"), _vec285)
// 			_vec286 := EmptyVector
// 			for _, _elem286 := range (*(*_res1).TLS).TLSUnique {
// 				_vec286 = _vec286.Conjoin(MakeInt(int(_elem286)))
// 			}
// 			_map147.Add(MakeKeyword("TLSUnique"), _vec286)
// 			_obj_map147 = Object(_map147)
// 		} else {
// 			_obj_map147 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map147)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http.Redirect:
// func redirect(w net/http.ResponseWriter, r *net/http.Request, url string, code int) Object {
// 	_http.Redirect(w, r, url, code)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.RedirectHandler:
// func redirectHandler(url string, code int) Object {
// 	return _http.RedirectHandler(url, code)
// }

GO FUNC net/http.ServeContent:
// func serveContent(w net/http.ResponseWriter, req *net/http.Request, name string, modtime time.Time, content io.ReadSeeker) Object {
// 	_http.ServeContent(w, req, name, modtime, content)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.ServeFile:
// func serveFile(w net/http.ResponseWriter, r *net/http.Request, name string) Object {
// 	_http.ServeFile(w, r, name)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.SetCookie:
// func setCookie(w net/http.ResponseWriter, cookie *net/http.Cookie) Object {
// 	_http.SetCookie(w, cookie)
// 	...ABEND675: TODO...
// }

GO FUNC net/http.StripPrefix:
// func stripPrefix(prefix string, h net/http.Handler) Object {
// 	return _http.StripPrefix(prefix, h)
// }

GO FUNC net/http.TimeoutHandler:
// func timeoutHandler(h net/http.Handler, dt time.Duration, msg string) Object {
// 	return _http.TimeoutHandler(h, dt, msg)
// }

GO FUNC net/http/cgi.Request:
// func request() Object {
// 	_res1, _res2 := _cgi.Request()
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		var _obj_map4 Object
// 		if (*_res1).MultipartForm != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Value"), (*(*_res1).MultipartForm).Value)
// 			_map4.Add(MakeKeyword("File"), (*(*_res1).MultipartForm).File)
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("MultipartForm"), _obj_map4)
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		var _obj_map5 Object
// 		if (*_res1).TLS != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("Version"), MakeInt(int((*(*_res1).TLS).Version)))
// 			_map5.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res1).TLS).HandshakeComplete))
// 			_map5.Add(MakeKeyword("DidResume"), MakeBool((*(*_res1).TLS).DidResume))
// 			_map5.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res1).TLS).CipherSuite)))
// 			_map5.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res1).TLS).NegotiatedProtocol))
// 			_map5.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res1).TLS).NegotiatedProtocolIsMutual))
// 			_map5.Add(MakeKeyword("ServerName"), MakeString((*(*_res1).TLS).ServerName))
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*(*_res1).TLS).PeerCertificates {
// 				var _obj_map7 Object
// 				if _elem6 != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*_elem6).Raw {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Raw"), _vec8)
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*_elem6).RawTBSCertificate {
// 						_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 					}
// 					_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem6).RawSubjectPublicKeyInfo {
// 						_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*_elem6).RawSubject {
// 						_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*_elem6).RawIssuer {
// 						_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 					}
// 					_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*_elem6).Signature {
// 						_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 					}
// 					_map7.Add(MakeKeyword("Signature"), _vec13)
// 					_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_elem6).SignatureAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem6).PublicKeyAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKey"), (*_elem6).PublicKey)
// 					_map7.Add(MakeKeyword("Version"), MakeInt((*_elem6).Version))
// 					_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map15 := EmptyArrayMap()
// 					_vec16 := EmptyVector
// 					for _, _elem16 := range (*_elem6).Issuer.Country {
// 						_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 					}
// 					_map15.Add(MakeKeyword("Country"), _vec16)
// 					_vec17 := EmptyVector
// 					for _, _elem17 := range (*_elem6).Issuer.Organization {
// 						_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 					}
// 					_map15.Add(MakeKeyword("Organization"), _vec17)
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*_elem6).Issuer.OrganizationalUnit {
// 						_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 					}
// 					_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 					_vec19 := EmptyVector
// 					for _, _elem19 := range (*_elem6).Issuer.Locality {
// 						_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 					}
// 					_map15.Add(MakeKeyword("Locality"), _vec19)
// 					_vec20 := EmptyVector
// 					for _, _elem20 := range (*_elem6).Issuer.Province {
// 						_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 					}
// 					_map15.Add(MakeKeyword("Province"), _vec20)
// 					_vec21 := EmptyVector
// 					for _, _elem21 := range (*_elem6).Issuer.StreetAddress {
// 						_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 					}
// 					_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 					_vec22 := EmptyVector
// 					for _, _elem22 := range (*_elem6).Issuer.PostalCode {
// 						_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 					}
// 					_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 					_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Issuer.SerialNumber))
// 					_map15.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Issuer.CommonName))
// 					_vec23 := EmptyVector
// 					for _, _elem23 := range (*_elem6).Issuer.Names {
// 						_vec23 = _vec23.Conjoin(_elem23)
// 					}
// 					_map15.Add(MakeKeyword("Names"), _vec23)
// 					_vec24 := EmptyVector
// 					for _, _elem24 := range (*_elem6).Issuer.ExtraNames {
// 						_vec24 = _vec24.Conjoin(_elem24)
// 					}
// 					_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 					_map7.Add(MakeKeyword("Issuer"), _map15)
// 					_map25 := EmptyArrayMap()
// 					_vec26 := EmptyVector
// 					for _, _elem26 := range (*_elem6).Subject.Country {
// 						_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 					}
// 					_map25.Add(MakeKeyword("Country"), _vec26)
// 					_vec27 := EmptyVector
// 					for _, _elem27 := range (*_elem6).Subject.Organization {
// 						_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 					}
// 					_map25.Add(MakeKeyword("Organization"), _vec27)
// 					_vec28 := EmptyVector
// 					for _, _elem28 := range (*_elem6).Subject.OrganizationalUnit {
// 						_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 					}
// 					_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 					_vec29 := EmptyVector
// 					for _, _elem29 := range (*_elem6).Subject.Locality {
// 						_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 					}
// 					_map25.Add(MakeKeyword("Locality"), _vec29)
// 					_vec30 := EmptyVector
// 					for _, _elem30 := range (*_elem6).Subject.Province {
// 						_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 					}
// 					_map25.Add(MakeKeyword("Province"), _vec30)
// 					_vec31 := EmptyVector
// 					for _, _elem31 := range (*_elem6).Subject.StreetAddress {
// 						_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 					}
// 					_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 					_vec32 := EmptyVector
// 					for _, _elem32 := range (*_elem6).Subject.PostalCode {
// 						_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 					}
// 					_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 					_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Subject.SerialNumber))
// 					_map25.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Subject.CommonName))
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem6).Subject.Names {
// 						_vec33 = _vec33.Conjoin(_elem33)
// 					}
// 					_map25.Add(MakeKeyword("Names"), _vec33)
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*_elem6).Subject.ExtraNames {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 					_map7.Add(MakeKeyword("Subject"), _map25)
// 					_map7.Add(MakeKeyword("NotBefore"), NIL)
// 					_map7.Add(MakeKeyword("NotAfter"), NIL)
// 					_map7.Add(MakeKeyword("KeyUsage"), (*_elem6).KeyUsage)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem6).Extensions {
// 						_map38 := EmptyArrayMap()
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range _elem37.Id {
// 							_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 						}
// 						_map38.Add(MakeKeyword("Id"), _vec39)
// 						_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range _elem37.Value {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map38.Add(MakeKeyword("Value"), _vec40)
// 						_vec37 = _vec37.Conjoin(_map38)
// 					}
// 					_map7.Add(MakeKeyword("Extensions"), _vec37)
// 					_vec41 := EmptyVector
// 					for _, _elem41 := range (*_elem6).ExtraExtensions {
// 						_map42 := EmptyArrayMap()
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range _elem41.Id {
// 							_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 						}
// 						_map42.Add(MakeKeyword("Id"), _vec43)
// 						_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 						_vec44 := EmptyVector
// 						for _, _elem44 := range _elem41.Value {
// 							_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 						}
// 						_map42.Add(MakeKeyword("Value"), _vec44)
// 						_vec41 = _vec41.Conjoin(_map42)
// 					}
// 					_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 					_vec45 := EmptyVector
// 					for _, _elem45 := range (*_elem6).UnhandledCriticalExtensions {
// 						_vec46 := EmptyVector
// 						for _, _elem46 := range _elem45 {
// 							_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 						}
// 						_vec45 = _vec45.Conjoin(_vec46)
// 					}
// 					_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 					_vec47 := EmptyVector
// 					for _, _elem47 := range (*_elem6).ExtKeyUsage {
// 						_vec47 = _vec47.Conjoin(_elem47)
// 					}
// 					_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 					_vec48 := EmptyVector
// 					for _, _elem48 := range (*_elem6).UnknownExtKeyUsage {
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range _elem48 {
// 							_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 						}
// 						_vec48 = _vec48.Conjoin(_vec49)
// 					}
// 					_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 					_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem6).BasicConstraintsValid))
// 					_map7.Add(MakeKeyword("IsCA"), MakeBool((*_elem6).IsCA))
// 					_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem6).MaxPathLen))
// 					_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem6).MaxPathLenZero))
// 					_vec50 := EmptyVector
// 					for _, _elem50 := range (*_elem6).SubjectKeyId {
// 						_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 					}
// 					_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 					_vec51 := EmptyVector
// 					for _, _elem51 := range (*_elem6).AuthorityKeyId {
// 						_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 					}
// 					_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 					_vec52 := EmptyVector
// 					for _, _elem52 := range (*_elem6).OCSPServer {
// 						_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 					}
// 					_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 					_vec53 := EmptyVector
// 					for _, _elem53 := range (*_elem6).IssuingCertificateURL {
// 						_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 					}
// 					_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 					_vec54 := EmptyVector
// 					for _, _elem54 := range (*_elem6).DNSNames {
// 						_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 					}
// 					_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 					_vec55 := EmptyVector
// 					for _, _elem55 := range (*_elem6).EmailAddresses {
// 						_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 					}
// 					_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 					_vec56 := EmptyVector
// 					for _, _elem56 := range (*_elem6).IPAddresses {
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range _elem56 {
// 							_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 						}
// 						_vec56 = _vec56.Conjoin(_vec57)
// 					}
// 					_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 					_vec58 := EmptyVector
// 					for _, _elem58 := range (*_elem6).URIs {
// 						var _obj_map59 Object
// 						if _elem58 != nil {
// 							_map59 := EmptyArrayMap()
// 							_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 							_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 							_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 							_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 							_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 							_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 							_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 							_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 							_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 							_obj_map59 = Object(_map59)
// 						} else {
// 							_obj_map59 = NIL
// 						}
// 						_vec58 = _vec58.Conjoin(_obj_map59)
// 					}
// 					_map7.Add(MakeKeyword("URIs"), _vec58)
// 					_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem6).PermittedDNSDomainsCritical))
// 					_vec60 := EmptyVector
// 					for _, _elem60 := range (*_elem6).PermittedDNSDomains {
// 						_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 					}
// 					_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 					_vec61 := EmptyVector
// 					for _, _elem61 := range (*_elem6).ExcludedDNSDomains {
// 						_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 					_vec62 := EmptyVector
// 					for _, _elem62 := range (*_elem6).PermittedIPRanges {
// 						var _obj_map63 Object
// 						if _elem62 != nil {
// 							_map63 := EmptyArrayMap()
// 							_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 							_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 							_obj_map63 = Object(_map63)
// 						} else {
// 							_obj_map63 = NIL
// 						}
// 						_vec62 = _vec62.Conjoin(_obj_map63)
// 					}
// 					_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 					_vec64 := EmptyVector
// 					for _, _elem64 := range (*_elem6).ExcludedIPRanges {
// 						var _obj_map65 Object
// 						if _elem64 != nil {
// 							_map65 := EmptyArrayMap()
// 							_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 							_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 							_obj_map65 = Object(_map65)
// 						} else {
// 							_obj_map65 = NIL
// 						}
// 						_vec64 = _vec64.Conjoin(_obj_map65)
// 					}
// 					_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 					_vec66 := EmptyVector
// 					for _, _elem66 := range (*_elem6).PermittedEmailAddresses {
// 						_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 					}
// 					_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 					_vec67 := EmptyVector
// 					for _, _elem67 := range (*_elem6).ExcludedEmailAddresses {
// 						_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 					_vec68 := EmptyVector
// 					for _, _elem68 := range (*_elem6).PermittedURIDomains {
// 						_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 					}
// 					_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 					_vec69 := EmptyVector
// 					for _, _elem69 := range (*_elem6).ExcludedURIDomains {
// 						_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 					_vec70 := EmptyVector
// 					for _, _elem70 := range (*_elem6).CRLDistributionPoints {
// 						_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 					}
// 					_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 					_vec71 := EmptyVector
// 					for _, _elem71 := range (*_elem6).PolicyIdentifiers {
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range _elem71 {
// 							_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 						}
// 						_vec71 = _vec71.Conjoin(_vec72)
// 					}
// 					_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_vec6 = _vec6.Conjoin(_obj_map7)
// 			}
// 			_map5.Add(MakeKeyword("PeerCertificates"), _vec6)
// 			_vec73 := EmptyVector
// 			for _, _elem73 := range (*(*_res1).TLS).VerifiedChains {
// 				_vec74 := EmptyVector
// 				for _, _elem74 := range _elem73 {
// 					var _obj_map75 Object
// 					if _elem74 != nil {
// 						_map75 := EmptyArrayMap()
// 						_vec76 := EmptyVector
// 						for _, _elem76 := range (*_elem74).Raw {
// 							_vec76 = _vec76.Conjoin(MakeInt(int(_elem76)))
// 						}
// 						_map75.Add(MakeKeyword("Raw"), _vec76)
// 						_vec77 := EmptyVector
// 						for _, _elem77 := range (*_elem74).RawTBSCertificate {
// 							_vec77 = _vec77.Conjoin(MakeInt(int(_elem77)))
// 						}
// 						_map75.Add(MakeKeyword("RawTBSCertificate"), _vec77)
// 						_vec78 := EmptyVector
// 						for _, _elem78 := range (*_elem74).RawSubjectPublicKeyInfo {
// 							_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec78)
// 						_vec79 := EmptyVector
// 						for _, _elem79 := range (*_elem74).RawSubject {
// 							_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubject"), _vec79)
// 						_vec80 := EmptyVector
// 						for _, _elem80 := range (*_elem74).RawIssuer {
// 							_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 						}
// 						_map75.Add(MakeKeyword("RawIssuer"), _vec80)
// 						_vec81 := EmptyVector
// 						for _, _elem81 := range (*_elem74).Signature {
// 							_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 						}
// 						_map75.Add(MakeKeyword("Signature"), _vec81)
// 						_map75.Add(MakeKeyword("SignatureAlgorithm"), (*_elem74).SignatureAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem74).PublicKeyAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKey"), (*_elem74).PublicKey)
// 						_map75.Add(MakeKeyword("Version"), MakeInt((*_elem74).Version))
// 						_map75.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map83 := EmptyArrayMap()
// 						_vec84 := EmptyVector
// 						for _, _elem84 := range (*_elem74).Issuer.Country {
// 							_vec84 = _vec84.Conjoin(MakeString(_elem84))
// 						}
// 						_map83.Add(MakeKeyword("Country"), _vec84)
// 						_vec85 := EmptyVector
// 						for _, _elem85 := range (*_elem74).Issuer.Organization {
// 							_vec85 = _vec85.Conjoin(MakeString(_elem85))
// 						}
// 						_map83.Add(MakeKeyword("Organization"), _vec85)
// 						_vec86 := EmptyVector
// 						for _, _elem86 := range (*_elem74).Issuer.OrganizationalUnit {
// 							_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 						}
// 						_map83.Add(MakeKeyword("OrganizationalUnit"), _vec86)
// 						_vec87 := EmptyVector
// 						for _, _elem87 := range (*_elem74).Issuer.Locality {
// 							_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 						}
// 						_map83.Add(MakeKeyword("Locality"), _vec87)
// 						_vec88 := EmptyVector
// 						for _, _elem88 := range (*_elem74).Issuer.Province {
// 							_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 						}
// 						_map83.Add(MakeKeyword("Province"), _vec88)
// 						_vec89 := EmptyVector
// 						for _, _elem89 := range (*_elem74).Issuer.StreetAddress {
// 							_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 						}
// 						_map83.Add(MakeKeyword("StreetAddress"), _vec89)
// 						_vec90 := EmptyVector
// 						for _, _elem90 := range (*_elem74).Issuer.PostalCode {
// 							_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 						}
// 						_map83.Add(MakeKeyword("PostalCode"), _vec90)
// 						_map83.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Issuer.SerialNumber))
// 						_map83.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Issuer.CommonName))
// 						_vec91 := EmptyVector
// 						for _, _elem91 := range (*_elem74).Issuer.Names {
// 							_vec91 = _vec91.Conjoin(_elem91)
// 						}
// 						_map83.Add(MakeKeyword("Names"), _vec91)
// 						_vec92 := EmptyVector
// 						for _, _elem92 := range (*_elem74).Issuer.ExtraNames {
// 							_vec92 = _vec92.Conjoin(_elem92)
// 						}
// 						_map83.Add(MakeKeyword("ExtraNames"), _vec92)
// 						_map75.Add(MakeKeyword("Issuer"), _map83)
// 						_map93 := EmptyArrayMap()
// 						_vec94 := EmptyVector
// 						for _, _elem94 := range (*_elem74).Subject.Country {
// 							_vec94 = _vec94.Conjoin(MakeString(_elem94))
// 						}
// 						_map93.Add(MakeKeyword("Country"), _vec94)
// 						_vec95 := EmptyVector
// 						for _, _elem95 := range (*_elem74).Subject.Organization {
// 							_vec95 = _vec95.Conjoin(MakeString(_elem95))
// 						}
// 						_map93.Add(MakeKeyword("Organization"), _vec95)
// 						_vec96 := EmptyVector
// 						for _, _elem96 := range (*_elem74).Subject.OrganizationalUnit {
// 							_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 						}
// 						_map93.Add(MakeKeyword("OrganizationalUnit"), _vec96)
// 						_vec97 := EmptyVector
// 						for _, _elem97 := range (*_elem74).Subject.Locality {
// 							_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 						}
// 						_map93.Add(MakeKeyword("Locality"), _vec97)
// 						_vec98 := EmptyVector
// 						for _, _elem98 := range (*_elem74).Subject.Province {
// 							_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 						}
// 						_map93.Add(MakeKeyword("Province"), _vec98)
// 						_vec99 := EmptyVector
// 						for _, _elem99 := range (*_elem74).Subject.StreetAddress {
// 							_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 						}
// 						_map93.Add(MakeKeyword("StreetAddress"), _vec99)
// 						_vec100 := EmptyVector
// 						for _, _elem100 := range (*_elem74).Subject.PostalCode {
// 							_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 						}
// 						_map93.Add(MakeKeyword("PostalCode"), _vec100)
// 						_map93.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Subject.SerialNumber))
// 						_map93.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Subject.CommonName))
// 						_vec101 := EmptyVector
// 						for _, _elem101 := range (*_elem74).Subject.Names {
// 							_vec101 = _vec101.Conjoin(_elem101)
// 						}
// 						_map93.Add(MakeKeyword("Names"), _vec101)
// 						_vec102 := EmptyVector
// 						for _, _elem102 := range (*_elem74).Subject.ExtraNames {
// 							_vec102 = _vec102.Conjoin(_elem102)
// 						}
// 						_map93.Add(MakeKeyword("ExtraNames"), _vec102)
// 						_map75.Add(MakeKeyword("Subject"), _map93)
// 						_map75.Add(MakeKeyword("NotBefore"), NIL)
// 						_map75.Add(MakeKeyword("NotAfter"), NIL)
// 						_map75.Add(MakeKeyword("KeyUsage"), (*_elem74).KeyUsage)
// 						_vec105 := EmptyVector
// 						for _, _elem105 := range (*_elem74).Extensions {
// 							_map106 := EmptyArrayMap()
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range _elem105.Id {
// 								_vec107 = _vec107.Conjoin(MakeInt(_elem107))
// 							}
// 							_map106.Add(MakeKeyword("Id"), _vec107)
// 							_map106.Add(MakeKeyword("Critical"), MakeBool(_elem105.Critical))
// 							_vec108 := EmptyVector
// 							for _, _elem108 := range _elem105.Value {
// 								_vec108 = _vec108.Conjoin(MakeInt(int(_elem108)))
// 							}
// 							_map106.Add(MakeKeyword("Value"), _vec108)
// 							_vec105 = _vec105.Conjoin(_map106)
// 						}
// 						_map75.Add(MakeKeyword("Extensions"), _vec105)
// 						_vec109 := EmptyVector
// 						for _, _elem109 := range (*_elem74).ExtraExtensions {
// 							_map110 := EmptyArrayMap()
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range _elem109.Id {
// 								_vec111 = _vec111.Conjoin(MakeInt(_elem111))
// 							}
// 							_map110.Add(MakeKeyword("Id"), _vec111)
// 							_map110.Add(MakeKeyword("Critical"), MakeBool(_elem109.Critical))
// 							_vec112 := EmptyVector
// 							for _, _elem112 := range _elem109.Value {
// 								_vec112 = _vec112.Conjoin(MakeInt(int(_elem112)))
// 							}
// 							_map110.Add(MakeKeyword("Value"), _vec112)
// 							_vec109 = _vec109.Conjoin(_map110)
// 						}
// 						_map75.Add(MakeKeyword("ExtraExtensions"), _vec109)
// 						_vec113 := EmptyVector
// 						for _, _elem113 := range (*_elem74).UnhandledCriticalExtensions {
// 							_vec114 := EmptyVector
// 							for _, _elem114 := range _elem113 {
// 								_vec114 = _vec114.Conjoin(MakeInt(_elem114))
// 							}
// 							_vec113 = _vec113.Conjoin(_vec114)
// 						}
// 						_map75.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec113)
// 						_vec115 := EmptyVector
// 						for _, _elem115 := range (*_elem74).ExtKeyUsage {
// 							_vec115 = _vec115.Conjoin(_elem115)
// 						}
// 						_map75.Add(MakeKeyword("ExtKeyUsage"), _vec115)
// 						_vec116 := EmptyVector
// 						for _, _elem116 := range (*_elem74).UnknownExtKeyUsage {
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range _elem116 {
// 								_vec117 = _vec117.Conjoin(MakeInt(_elem117))
// 							}
// 							_vec116 = _vec116.Conjoin(_vec117)
// 						}
// 						_map75.Add(MakeKeyword("UnknownExtKeyUsage"), _vec116)
// 						_map75.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem74).BasicConstraintsValid))
// 						_map75.Add(MakeKeyword("IsCA"), MakeBool((*_elem74).IsCA))
// 						_map75.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem74).MaxPathLen))
// 						_map75.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem74).MaxPathLenZero))
// 						_vec118 := EmptyVector
// 						for _, _elem118 := range (*_elem74).SubjectKeyId {
// 							_vec118 = _vec118.Conjoin(MakeInt(int(_elem118)))
// 						}
// 						_map75.Add(MakeKeyword("SubjectKeyId"), _vec118)
// 						_vec119 := EmptyVector
// 						for _, _elem119 := range (*_elem74).AuthorityKeyId {
// 							_vec119 = _vec119.Conjoin(MakeInt(int(_elem119)))
// 						}
// 						_map75.Add(MakeKeyword("AuthorityKeyId"), _vec119)
// 						_vec120 := EmptyVector
// 						for _, _elem120 := range (*_elem74).OCSPServer {
// 							_vec120 = _vec120.Conjoin(MakeString(_elem120))
// 						}
// 						_map75.Add(MakeKeyword("OCSPServer"), _vec120)
// 						_vec121 := EmptyVector
// 						for _, _elem121 := range (*_elem74).IssuingCertificateURL {
// 							_vec121 = _vec121.Conjoin(MakeString(_elem121))
// 						}
// 						_map75.Add(MakeKeyword("IssuingCertificateURL"), _vec121)
// 						_vec122 := EmptyVector
// 						for _, _elem122 := range (*_elem74).DNSNames {
// 							_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 						}
// 						_map75.Add(MakeKeyword("DNSNames"), _vec122)
// 						_vec123 := EmptyVector
// 						for _, _elem123 := range (*_elem74).EmailAddresses {
// 							_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 						}
// 						_map75.Add(MakeKeyword("EmailAddresses"), _vec123)
// 						_vec124 := EmptyVector
// 						for _, _elem124 := range (*_elem74).IPAddresses {
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range _elem124 {
// 								_vec125 = _vec125.Conjoin(MakeInt(int(_elem125)))
// 							}
// 							_vec124 = _vec124.Conjoin(_vec125)
// 						}
// 						_map75.Add(MakeKeyword("IPAddresses"), _vec124)
// 						_vec126 := EmptyVector
// 						for _, _elem126 := range (*_elem74).URIs {
// 							var _obj_map127 Object
// 							if _elem126 != nil {
// 								_map127 := EmptyArrayMap()
// 								_map127.Add(MakeKeyword("Scheme"), MakeString((*_elem126).Scheme))
// 								_map127.Add(MakeKeyword("Opaque"), MakeString((*_elem126).Opaque))
// 								_map127.Add(MakeKeyword("User"), (*(*_elem126).User))
// 								_map127.Add(MakeKeyword("Host"), MakeString((*_elem126).Host))
// 								_map127.Add(MakeKeyword("Path"), MakeString((*_elem126).Path))
// 								_map127.Add(MakeKeyword("RawPath"), MakeString((*_elem126).RawPath))
// 								_map127.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem126).ForceQuery))
// 								_map127.Add(MakeKeyword("RawQuery"), MakeString((*_elem126).RawQuery))
// 								_map127.Add(MakeKeyword("Fragment"), MakeString((*_elem126).Fragment))
// 								_obj_map127 = Object(_map127)
// 							} else {
// 								_obj_map127 = NIL
// 							}
// 							_vec126 = _vec126.Conjoin(_obj_map127)
// 						}
// 						_map75.Add(MakeKeyword("URIs"), _vec126)
// 						_map75.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem74).PermittedDNSDomainsCritical))
// 						_vec128 := EmptyVector
// 						for _, _elem128 := range (*_elem74).PermittedDNSDomains {
// 							_vec128 = _vec128.Conjoin(MakeString(_elem128))
// 						}
// 						_map75.Add(MakeKeyword("PermittedDNSDomains"), _vec128)
// 						_vec129 := EmptyVector
// 						for _, _elem129 := range (*_elem74).ExcludedDNSDomains {
// 							_vec129 = _vec129.Conjoin(MakeString(_elem129))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedDNSDomains"), _vec129)
// 						_vec130 := EmptyVector
// 						for _, _elem130 := range (*_elem74).PermittedIPRanges {
// 							var _obj_map131 Object
// 							if _elem130 != nil {
// 								_map131 := EmptyArrayMap()
// 								_map131.Add(MakeKeyword("IP"), (*_elem130).IP)
// 								_map131.Add(MakeKeyword("Mask"), (*_elem130).Mask)
// 								_obj_map131 = Object(_map131)
// 							} else {
// 								_obj_map131 = NIL
// 							}
// 							_vec130 = _vec130.Conjoin(_obj_map131)
// 						}
// 						_map75.Add(MakeKeyword("PermittedIPRanges"), _vec130)
// 						_vec132 := EmptyVector
// 						for _, _elem132 := range (*_elem74).ExcludedIPRanges {
// 							var _obj_map133 Object
// 							if _elem132 != nil {
// 								_map133 := EmptyArrayMap()
// 								_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 								_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 								_obj_map133 = Object(_map133)
// 							} else {
// 								_obj_map133 = NIL
// 							}
// 							_vec132 = _vec132.Conjoin(_obj_map133)
// 						}
// 						_map75.Add(MakeKeyword("ExcludedIPRanges"), _vec132)
// 						_vec134 := EmptyVector
// 						for _, _elem134 := range (*_elem74).PermittedEmailAddresses {
// 							_vec134 = _vec134.Conjoin(MakeString(_elem134))
// 						}
// 						_map75.Add(MakeKeyword("PermittedEmailAddresses"), _vec134)
// 						_vec135 := EmptyVector
// 						for _, _elem135 := range (*_elem74).ExcludedEmailAddresses {
// 							_vec135 = _vec135.Conjoin(MakeString(_elem135))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedEmailAddresses"), _vec135)
// 						_vec136 := EmptyVector
// 						for _, _elem136 := range (*_elem74).PermittedURIDomains {
// 							_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 						}
// 						_map75.Add(MakeKeyword("PermittedURIDomains"), _vec136)
// 						_vec137 := EmptyVector
// 						for _, _elem137 := range (*_elem74).ExcludedURIDomains {
// 							_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedURIDomains"), _vec137)
// 						_vec138 := EmptyVector
// 						for _, _elem138 := range (*_elem74).CRLDistributionPoints {
// 							_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 						}
// 						_map75.Add(MakeKeyword("CRLDistributionPoints"), _vec138)
// 						_vec139 := EmptyVector
// 						for _, _elem139 := range (*_elem74).PolicyIdentifiers {
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range _elem139 {
// 								_vec140 = _vec140.Conjoin(MakeInt(_elem140))
// 							}
// 							_vec139 = _vec139.Conjoin(_vec140)
// 						}
// 						_map75.Add(MakeKeyword("PolicyIdentifiers"), _vec139)
// 						_obj_map75 = Object(_map75)
// 					} else {
// 						_obj_map75 = NIL
// 					}
// 					_vec74 = _vec74.Conjoin(_obj_map75)
// 				}
// 				_vec73 = _vec73.Conjoin(_vec74)
// 			}
// 			_map5.Add(MakeKeyword("VerifiedChains"), _vec73)
// 			_vec141 := EmptyVector
// 			for _, _elem141 := range (*(*_res1).TLS).SignedCertificateTimestamps {
// 				_vec142 := EmptyVector
// 				for _, _elem142 := range _elem141 {
// 					_vec142 = _vec142.Conjoin(MakeInt(int(_elem142)))
// 				}
// 				_vec141 = _vec141.Conjoin(_vec142)
// 			}
// 			_map5.Add(MakeKeyword("SignedCertificateTimestamps"), _vec141)
// 			_vec143 := EmptyVector
// 			for _, _elem143 := range (*(*_res1).TLS).OCSPResponse {
// 				_vec143 = _vec143.Conjoin(MakeInt(int(_elem143)))
// 			}
// 			_map5.Add(MakeKeyword("OCSPResponse"), _vec143)
// 			_vec144 := EmptyVector
// 			for _, _elem144 := range (*(*_res1).TLS).TLSUnique {
// 				_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 			}
// 			_map5.Add(MakeKeyword("TLSUnique"), _vec144)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map5)
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res1).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cgi.RequestFromMap:
// func requestFromMap(params map[]) Object {
// 	_res1, _res2 := _cgi.RequestFromMap(params)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res1).Method))
// 		var _obj_map2 Object
// 		if (*_res1).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res1).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res1).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res1).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res1).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res1).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res1).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res1).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res1).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res1).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res1).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res1).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res1).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res1).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res1).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res1).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res1).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res1).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res1).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res1).PostForm)
// 		var _obj_map4 Object
// 		if (*_res1).MultipartForm != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Value"), (*(*_res1).MultipartForm).Value)
// 			_map4.Add(MakeKeyword("File"), (*(*_res1).MultipartForm).File)
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("MultipartForm"), _obj_map4)
// 		_map1.Add(MakeKeyword("Trailer"), (*_res1).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res1).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res1).RequestURI))
// 		var _obj_map5 Object
// 		if (*_res1).TLS != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("Version"), MakeInt(int((*(*_res1).TLS).Version)))
// 			_map5.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res1).TLS).HandshakeComplete))
// 			_map5.Add(MakeKeyword("DidResume"), MakeBool((*(*_res1).TLS).DidResume))
// 			_map5.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res1).TLS).CipherSuite)))
// 			_map5.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res1).TLS).NegotiatedProtocol))
// 			_map5.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res1).TLS).NegotiatedProtocolIsMutual))
// 			_map5.Add(MakeKeyword("ServerName"), MakeString((*(*_res1).TLS).ServerName))
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*(*_res1).TLS).PeerCertificates {
// 				var _obj_map7 Object
// 				if _elem6 != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*_elem6).Raw {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Raw"), _vec8)
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*_elem6).RawTBSCertificate {
// 						_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 					}
// 					_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem6).RawSubjectPublicKeyInfo {
// 						_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*_elem6).RawSubject {
// 						_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*_elem6).RawIssuer {
// 						_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 					}
// 					_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*_elem6).Signature {
// 						_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 					}
// 					_map7.Add(MakeKeyword("Signature"), _vec13)
// 					_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_elem6).SignatureAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem6).PublicKeyAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKey"), (*_elem6).PublicKey)
// 					_map7.Add(MakeKeyword("Version"), MakeInt((*_elem6).Version))
// 					_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map15 := EmptyArrayMap()
// 					_vec16 := EmptyVector
// 					for _, _elem16 := range (*_elem6).Issuer.Country {
// 						_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 					}
// 					_map15.Add(MakeKeyword("Country"), _vec16)
// 					_vec17 := EmptyVector
// 					for _, _elem17 := range (*_elem6).Issuer.Organization {
// 						_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 					}
// 					_map15.Add(MakeKeyword("Organization"), _vec17)
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*_elem6).Issuer.OrganizationalUnit {
// 						_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 					}
// 					_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 					_vec19 := EmptyVector
// 					for _, _elem19 := range (*_elem6).Issuer.Locality {
// 						_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 					}
// 					_map15.Add(MakeKeyword("Locality"), _vec19)
// 					_vec20 := EmptyVector
// 					for _, _elem20 := range (*_elem6).Issuer.Province {
// 						_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 					}
// 					_map15.Add(MakeKeyword("Province"), _vec20)
// 					_vec21 := EmptyVector
// 					for _, _elem21 := range (*_elem6).Issuer.StreetAddress {
// 						_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 					}
// 					_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 					_vec22 := EmptyVector
// 					for _, _elem22 := range (*_elem6).Issuer.PostalCode {
// 						_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 					}
// 					_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 					_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Issuer.SerialNumber))
// 					_map15.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Issuer.CommonName))
// 					_vec23 := EmptyVector
// 					for _, _elem23 := range (*_elem6).Issuer.Names {
// 						_vec23 = _vec23.Conjoin(_elem23)
// 					}
// 					_map15.Add(MakeKeyword("Names"), _vec23)
// 					_vec24 := EmptyVector
// 					for _, _elem24 := range (*_elem6).Issuer.ExtraNames {
// 						_vec24 = _vec24.Conjoin(_elem24)
// 					}
// 					_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 					_map7.Add(MakeKeyword("Issuer"), _map15)
// 					_map25 := EmptyArrayMap()
// 					_vec26 := EmptyVector
// 					for _, _elem26 := range (*_elem6).Subject.Country {
// 						_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 					}
// 					_map25.Add(MakeKeyword("Country"), _vec26)
// 					_vec27 := EmptyVector
// 					for _, _elem27 := range (*_elem6).Subject.Organization {
// 						_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 					}
// 					_map25.Add(MakeKeyword("Organization"), _vec27)
// 					_vec28 := EmptyVector
// 					for _, _elem28 := range (*_elem6).Subject.OrganizationalUnit {
// 						_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 					}
// 					_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 					_vec29 := EmptyVector
// 					for _, _elem29 := range (*_elem6).Subject.Locality {
// 						_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 					}
// 					_map25.Add(MakeKeyword("Locality"), _vec29)
// 					_vec30 := EmptyVector
// 					for _, _elem30 := range (*_elem6).Subject.Province {
// 						_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 					}
// 					_map25.Add(MakeKeyword("Province"), _vec30)
// 					_vec31 := EmptyVector
// 					for _, _elem31 := range (*_elem6).Subject.StreetAddress {
// 						_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 					}
// 					_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 					_vec32 := EmptyVector
// 					for _, _elem32 := range (*_elem6).Subject.PostalCode {
// 						_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 					}
// 					_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 					_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Subject.SerialNumber))
// 					_map25.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Subject.CommonName))
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem6).Subject.Names {
// 						_vec33 = _vec33.Conjoin(_elem33)
// 					}
// 					_map25.Add(MakeKeyword("Names"), _vec33)
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*_elem6).Subject.ExtraNames {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 					_map7.Add(MakeKeyword("Subject"), _map25)
// 					_map7.Add(MakeKeyword("NotBefore"), NIL)
// 					_map7.Add(MakeKeyword("NotAfter"), NIL)
// 					_map7.Add(MakeKeyword("KeyUsage"), (*_elem6).KeyUsage)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem6).Extensions {
// 						_map38 := EmptyArrayMap()
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range _elem37.Id {
// 							_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 						}
// 						_map38.Add(MakeKeyword("Id"), _vec39)
// 						_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range _elem37.Value {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map38.Add(MakeKeyword("Value"), _vec40)
// 						_vec37 = _vec37.Conjoin(_map38)
// 					}
// 					_map7.Add(MakeKeyword("Extensions"), _vec37)
// 					_vec41 := EmptyVector
// 					for _, _elem41 := range (*_elem6).ExtraExtensions {
// 						_map42 := EmptyArrayMap()
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range _elem41.Id {
// 							_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 						}
// 						_map42.Add(MakeKeyword("Id"), _vec43)
// 						_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 						_vec44 := EmptyVector
// 						for _, _elem44 := range _elem41.Value {
// 							_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 						}
// 						_map42.Add(MakeKeyword("Value"), _vec44)
// 						_vec41 = _vec41.Conjoin(_map42)
// 					}
// 					_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 					_vec45 := EmptyVector
// 					for _, _elem45 := range (*_elem6).UnhandledCriticalExtensions {
// 						_vec46 := EmptyVector
// 						for _, _elem46 := range _elem45 {
// 							_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 						}
// 						_vec45 = _vec45.Conjoin(_vec46)
// 					}
// 					_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 					_vec47 := EmptyVector
// 					for _, _elem47 := range (*_elem6).ExtKeyUsage {
// 						_vec47 = _vec47.Conjoin(_elem47)
// 					}
// 					_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 					_vec48 := EmptyVector
// 					for _, _elem48 := range (*_elem6).UnknownExtKeyUsage {
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range _elem48 {
// 							_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 						}
// 						_vec48 = _vec48.Conjoin(_vec49)
// 					}
// 					_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 					_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem6).BasicConstraintsValid))
// 					_map7.Add(MakeKeyword("IsCA"), MakeBool((*_elem6).IsCA))
// 					_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem6).MaxPathLen))
// 					_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem6).MaxPathLenZero))
// 					_vec50 := EmptyVector
// 					for _, _elem50 := range (*_elem6).SubjectKeyId {
// 						_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 					}
// 					_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 					_vec51 := EmptyVector
// 					for _, _elem51 := range (*_elem6).AuthorityKeyId {
// 						_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 					}
// 					_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 					_vec52 := EmptyVector
// 					for _, _elem52 := range (*_elem6).OCSPServer {
// 						_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 					}
// 					_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 					_vec53 := EmptyVector
// 					for _, _elem53 := range (*_elem6).IssuingCertificateURL {
// 						_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 					}
// 					_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 					_vec54 := EmptyVector
// 					for _, _elem54 := range (*_elem6).DNSNames {
// 						_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 					}
// 					_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 					_vec55 := EmptyVector
// 					for _, _elem55 := range (*_elem6).EmailAddresses {
// 						_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 					}
// 					_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 					_vec56 := EmptyVector
// 					for _, _elem56 := range (*_elem6).IPAddresses {
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range _elem56 {
// 							_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 						}
// 						_vec56 = _vec56.Conjoin(_vec57)
// 					}
// 					_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 					_vec58 := EmptyVector
// 					for _, _elem58 := range (*_elem6).URIs {
// 						var _obj_map59 Object
// 						if _elem58 != nil {
// 							_map59 := EmptyArrayMap()
// 							_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 							_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 							_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 							_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 							_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 							_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 							_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 							_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 							_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 							_obj_map59 = Object(_map59)
// 						} else {
// 							_obj_map59 = NIL
// 						}
// 						_vec58 = _vec58.Conjoin(_obj_map59)
// 					}
// 					_map7.Add(MakeKeyword("URIs"), _vec58)
// 					_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem6).PermittedDNSDomainsCritical))
// 					_vec60 := EmptyVector
// 					for _, _elem60 := range (*_elem6).PermittedDNSDomains {
// 						_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 					}
// 					_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 					_vec61 := EmptyVector
// 					for _, _elem61 := range (*_elem6).ExcludedDNSDomains {
// 						_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 					_vec62 := EmptyVector
// 					for _, _elem62 := range (*_elem6).PermittedIPRanges {
// 						var _obj_map63 Object
// 						if _elem62 != nil {
// 							_map63 := EmptyArrayMap()
// 							_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 							_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 							_obj_map63 = Object(_map63)
// 						} else {
// 							_obj_map63 = NIL
// 						}
// 						_vec62 = _vec62.Conjoin(_obj_map63)
// 					}
// 					_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 					_vec64 := EmptyVector
// 					for _, _elem64 := range (*_elem6).ExcludedIPRanges {
// 						var _obj_map65 Object
// 						if _elem64 != nil {
// 							_map65 := EmptyArrayMap()
// 							_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 							_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 							_obj_map65 = Object(_map65)
// 						} else {
// 							_obj_map65 = NIL
// 						}
// 						_vec64 = _vec64.Conjoin(_obj_map65)
// 					}
// 					_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 					_vec66 := EmptyVector
// 					for _, _elem66 := range (*_elem6).PermittedEmailAddresses {
// 						_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 					}
// 					_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 					_vec67 := EmptyVector
// 					for _, _elem67 := range (*_elem6).ExcludedEmailAddresses {
// 						_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 					_vec68 := EmptyVector
// 					for _, _elem68 := range (*_elem6).PermittedURIDomains {
// 						_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 					}
// 					_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 					_vec69 := EmptyVector
// 					for _, _elem69 := range (*_elem6).ExcludedURIDomains {
// 						_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 					_vec70 := EmptyVector
// 					for _, _elem70 := range (*_elem6).CRLDistributionPoints {
// 						_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 					}
// 					_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 					_vec71 := EmptyVector
// 					for _, _elem71 := range (*_elem6).PolicyIdentifiers {
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range _elem71 {
// 							_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 						}
// 						_vec71 = _vec71.Conjoin(_vec72)
// 					}
// 					_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_vec6 = _vec6.Conjoin(_obj_map7)
// 			}
// 			_map5.Add(MakeKeyword("PeerCertificates"), _vec6)
// 			_vec73 := EmptyVector
// 			for _, _elem73 := range (*(*_res1).TLS).VerifiedChains {
// 				_vec74 := EmptyVector
// 				for _, _elem74 := range _elem73 {
// 					var _obj_map75 Object
// 					if _elem74 != nil {
// 						_map75 := EmptyArrayMap()
// 						_vec76 := EmptyVector
// 						for _, _elem76 := range (*_elem74).Raw {
// 							_vec76 = _vec76.Conjoin(MakeInt(int(_elem76)))
// 						}
// 						_map75.Add(MakeKeyword("Raw"), _vec76)
// 						_vec77 := EmptyVector
// 						for _, _elem77 := range (*_elem74).RawTBSCertificate {
// 							_vec77 = _vec77.Conjoin(MakeInt(int(_elem77)))
// 						}
// 						_map75.Add(MakeKeyword("RawTBSCertificate"), _vec77)
// 						_vec78 := EmptyVector
// 						for _, _elem78 := range (*_elem74).RawSubjectPublicKeyInfo {
// 							_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec78)
// 						_vec79 := EmptyVector
// 						for _, _elem79 := range (*_elem74).RawSubject {
// 							_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubject"), _vec79)
// 						_vec80 := EmptyVector
// 						for _, _elem80 := range (*_elem74).RawIssuer {
// 							_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 						}
// 						_map75.Add(MakeKeyword("RawIssuer"), _vec80)
// 						_vec81 := EmptyVector
// 						for _, _elem81 := range (*_elem74).Signature {
// 							_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 						}
// 						_map75.Add(MakeKeyword("Signature"), _vec81)
// 						_map75.Add(MakeKeyword("SignatureAlgorithm"), (*_elem74).SignatureAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem74).PublicKeyAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKey"), (*_elem74).PublicKey)
// 						_map75.Add(MakeKeyword("Version"), MakeInt((*_elem74).Version))
// 						_map75.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map83 := EmptyArrayMap()
// 						_vec84 := EmptyVector
// 						for _, _elem84 := range (*_elem74).Issuer.Country {
// 							_vec84 = _vec84.Conjoin(MakeString(_elem84))
// 						}
// 						_map83.Add(MakeKeyword("Country"), _vec84)
// 						_vec85 := EmptyVector
// 						for _, _elem85 := range (*_elem74).Issuer.Organization {
// 							_vec85 = _vec85.Conjoin(MakeString(_elem85))
// 						}
// 						_map83.Add(MakeKeyword("Organization"), _vec85)
// 						_vec86 := EmptyVector
// 						for _, _elem86 := range (*_elem74).Issuer.OrganizationalUnit {
// 							_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 						}
// 						_map83.Add(MakeKeyword("OrganizationalUnit"), _vec86)
// 						_vec87 := EmptyVector
// 						for _, _elem87 := range (*_elem74).Issuer.Locality {
// 							_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 						}
// 						_map83.Add(MakeKeyword("Locality"), _vec87)
// 						_vec88 := EmptyVector
// 						for _, _elem88 := range (*_elem74).Issuer.Province {
// 							_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 						}
// 						_map83.Add(MakeKeyword("Province"), _vec88)
// 						_vec89 := EmptyVector
// 						for _, _elem89 := range (*_elem74).Issuer.StreetAddress {
// 							_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 						}
// 						_map83.Add(MakeKeyword("StreetAddress"), _vec89)
// 						_vec90 := EmptyVector
// 						for _, _elem90 := range (*_elem74).Issuer.PostalCode {
// 							_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 						}
// 						_map83.Add(MakeKeyword("PostalCode"), _vec90)
// 						_map83.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Issuer.SerialNumber))
// 						_map83.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Issuer.CommonName))
// 						_vec91 := EmptyVector
// 						for _, _elem91 := range (*_elem74).Issuer.Names {
// 							_vec91 = _vec91.Conjoin(_elem91)
// 						}
// 						_map83.Add(MakeKeyword("Names"), _vec91)
// 						_vec92 := EmptyVector
// 						for _, _elem92 := range (*_elem74).Issuer.ExtraNames {
// 							_vec92 = _vec92.Conjoin(_elem92)
// 						}
// 						_map83.Add(MakeKeyword("ExtraNames"), _vec92)
// 						_map75.Add(MakeKeyword("Issuer"), _map83)
// 						_map93 := EmptyArrayMap()
// 						_vec94 := EmptyVector
// 						for _, _elem94 := range (*_elem74).Subject.Country {
// 							_vec94 = _vec94.Conjoin(MakeString(_elem94))
// 						}
// 						_map93.Add(MakeKeyword("Country"), _vec94)
// 						_vec95 := EmptyVector
// 						for _, _elem95 := range (*_elem74).Subject.Organization {
// 							_vec95 = _vec95.Conjoin(MakeString(_elem95))
// 						}
// 						_map93.Add(MakeKeyword("Organization"), _vec95)
// 						_vec96 := EmptyVector
// 						for _, _elem96 := range (*_elem74).Subject.OrganizationalUnit {
// 							_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 						}
// 						_map93.Add(MakeKeyword("OrganizationalUnit"), _vec96)
// 						_vec97 := EmptyVector
// 						for _, _elem97 := range (*_elem74).Subject.Locality {
// 							_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 						}
// 						_map93.Add(MakeKeyword("Locality"), _vec97)
// 						_vec98 := EmptyVector
// 						for _, _elem98 := range (*_elem74).Subject.Province {
// 							_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 						}
// 						_map93.Add(MakeKeyword("Province"), _vec98)
// 						_vec99 := EmptyVector
// 						for _, _elem99 := range (*_elem74).Subject.StreetAddress {
// 							_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 						}
// 						_map93.Add(MakeKeyword("StreetAddress"), _vec99)
// 						_vec100 := EmptyVector
// 						for _, _elem100 := range (*_elem74).Subject.PostalCode {
// 							_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 						}
// 						_map93.Add(MakeKeyword("PostalCode"), _vec100)
// 						_map93.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Subject.SerialNumber))
// 						_map93.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Subject.CommonName))
// 						_vec101 := EmptyVector
// 						for _, _elem101 := range (*_elem74).Subject.Names {
// 							_vec101 = _vec101.Conjoin(_elem101)
// 						}
// 						_map93.Add(MakeKeyword("Names"), _vec101)
// 						_vec102 := EmptyVector
// 						for _, _elem102 := range (*_elem74).Subject.ExtraNames {
// 							_vec102 = _vec102.Conjoin(_elem102)
// 						}
// 						_map93.Add(MakeKeyword("ExtraNames"), _vec102)
// 						_map75.Add(MakeKeyword("Subject"), _map93)
// 						_map75.Add(MakeKeyword("NotBefore"), NIL)
// 						_map75.Add(MakeKeyword("NotAfter"), NIL)
// 						_map75.Add(MakeKeyword("KeyUsage"), (*_elem74).KeyUsage)
// 						_vec105 := EmptyVector
// 						for _, _elem105 := range (*_elem74).Extensions {
// 							_map106 := EmptyArrayMap()
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range _elem105.Id {
// 								_vec107 = _vec107.Conjoin(MakeInt(_elem107))
// 							}
// 							_map106.Add(MakeKeyword("Id"), _vec107)
// 							_map106.Add(MakeKeyword("Critical"), MakeBool(_elem105.Critical))
// 							_vec108 := EmptyVector
// 							for _, _elem108 := range _elem105.Value {
// 								_vec108 = _vec108.Conjoin(MakeInt(int(_elem108)))
// 							}
// 							_map106.Add(MakeKeyword("Value"), _vec108)
// 							_vec105 = _vec105.Conjoin(_map106)
// 						}
// 						_map75.Add(MakeKeyword("Extensions"), _vec105)
// 						_vec109 := EmptyVector
// 						for _, _elem109 := range (*_elem74).ExtraExtensions {
// 							_map110 := EmptyArrayMap()
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range _elem109.Id {
// 								_vec111 = _vec111.Conjoin(MakeInt(_elem111))
// 							}
// 							_map110.Add(MakeKeyword("Id"), _vec111)
// 							_map110.Add(MakeKeyword("Critical"), MakeBool(_elem109.Critical))
// 							_vec112 := EmptyVector
// 							for _, _elem112 := range _elem109.Value {
// 								_vec112 = _vec112.Conjoin(MakeInt(int(_elem112)))
// 							}
// 							_map110.Add(MakeKeyword("Value"), _vec112)
// 							_vec109 = _vec109.Conjoin(_map110)
// 						}
// 						_map75.Add(MakeKeyword("ExtraExtensions"), _vec109)
// 						_vec113 := EmptyVector
// 						for _, _elem113 := range (*_elem74).UnhandledCriticalExtensions {
// 							_vec114 := EmptyVector
// 							for _, _elem114 := range _elem113 {
// 								_vec114 = _vec114.Conjoin(MakeInt(_elem114))
// 							}
// 							_vec113 = _vec113.Conjoin(_vec114)
// 						}
// 						_map75.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec113)
// 						_vec115 := EmptyVector
// 						for _, _elem115 := range (*_elem74).ExtKeyUsage {
// 							_vec115 = _vec115.Conjoin(_elem115)
// 						}
// 						_map75.Add(MakeKeyword("ExtKeyUsage"), _vec115)
// 						_vec116 := EmptyVector
// 						for _, _elem116 := range (*_elem74).UnknownExtKeyUsage {
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range _elem116 {
// 								_vec117 = _vec117.Conjoin(MakeInt(_elem117))
// 							}
// 							_vec116 = _vec116.Conjoin(_vec117)
// 						}
// 						_map75.Add(MakeKeyword("UnknownExtKeyUsage"), _vec116)
// 						_map75.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem74).BasicConstraintsValid))
// 						_map75.Add(MakeKeyword("IsCA"), MakeBool((*_elem74).IsCA))
// 						_map75.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem74).MaxPathLen))
// 						_map75.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem74).MaxPathLenZero))
// 						_vec118 := EmptyVector
// 						for _, _elem118 := range (*_elem74).SubjectKeyId {
// 							_vec118 = _vec118.Conjoin(MakeInt(int(_elem118)))
// 						}
// 						_map75.Add(MakeKeyword("SubjectKeyId"), _vec118)
// 						_vec119 := EmptyVector
// 						for _, _elem119 := range (*_elem74).AuthorityKeyId {
// 							_vec119 = _vec119.Conjoin(MakeInt(int(_elem119)))
// 						}
// 						_map75.Add(MakeKeyword("AuthorityKeyId"), _vec119)
// 						_vec120 := EmptyVector
// 						for _, _elem120 := range (*_elem74).OCSPServer {
// 							_vec120 = _vec120.Conjoin(MakeString(_elem120))
// 						}
// 						_map75.Add(MakeKeyword("OCSPServer"), _vec120)
// 						_vec121 := EmptyVector
// 						for _, _elem121 := range (*_elem74).IssuingCertificateURL {
// 							_vec121 = _vec121.Conjoin(MakeString(_elem121))
// 						}
// 						_map75.Add(MakeKeyword("IssuingCertificateURL"), _vec121)
// 						_vec122 := EmptyVector
// 						for _, _elem122 := range (*_elem74).DNSNames {
// 							_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 						}
// 						_map75.Add(MakeKeyword("DNSNames"), _vec122)
// 						_vec123 := EmptyVector
// 						for _, _elem123 := range (*_elem74).EmailAddresses {
// 							_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 						}
// 						_map75.Add(MakeKeyword("EmailAddresses"), _vec123)
// 						_vec124 := EmptyVector
// 						for _, _elem124 := range (*_elem74).IPAddresses {
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range _elem124 {
// 								_vec125 = _vec125.Conjoin(MakeInt(int(_elem125)))
// 							}
// 							_vec124 = _vec124.Conjoin(_vec125)
// 						}
// 						_map75.Add(MakeKeyword("IPAddresses"), _vec124)
// 						_vec126 := EmptyVector
// 						for _, _elem126 := range (*_elem74).URIs {
// 							var _obj_map127 Object
// 							if _elem126 != nil {
// 								_map127 := EmptyArrayMap()
// 								_map127.Add(MakeKeyword("Scheme"), MakeString((*_elem126).Scheme))
// 								_map127.Add(MakeKeyword("Opaque"), MakeString((*_elem126).Opaque))
// 								_map127.Add(MakeKeyword("User"), (*(*_elem126).User))
// 								_map127.Add(MakeKeyword("Host"), MakeString((*_elem126).Host))
// 								_map127.Add(MakeKeyword("Path"), MakeString((*_elem126).Path))
// 								_map127.Add(MakeKeyword("RawPath"), MakeString((*_elem126).RawPath))
// 								_map127.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem126).ForceQuery))
// 								_map127.Add(MakeKeyword("RawQuery"), MakeString((*_elem126).RawQuery))
// 								_map127.Add(MakeKeyword("Fragment"), MakeString((*_elem126).Fragment))
// 								_obj_map127 = Object(_map127)
// 							} else {
// 								_obj_map127 = NIL
// 							}
// 							_vec126 = _vec126.Conjoin(_obj_map127)
// 						}
// 						_map75.Add(MakeKeyword("URIs"), _vec126)
// 						_map75.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem74).PermittedDNSDomainsCritical))
// 						_vec128 := EmptyVector
// 						for _, _elem128 := range (*_elem74).PermittedDNSDomains {
// 							_vec128 = _vec128.Conjoin(MakeString(_elem128))
// 						}
// 						_map75.Add(MakeKeyword("PermittedDNSDomains"), _vec128)
// 						_vec129 := EmptyVector
// 						for _, _elem129 := range (*_elem74).ExcludedDNSDomains {
// 							_vec129 = _vec129.Conjoin(MakeString(_elem129))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedDNSDomains"), _vec129)
// 						_vec130 := EmptyVector
// 						for _, _elem130 := range (*_elem74).PermittedIPRanges {
// 							var _obj_map131 Object
// 							if _elem130 != nil {
// 								_map131 := EmptyArrayMap()
// 								_map131.Add(MakeKeyword("IP"), (*_elem130).IP)
// 								_map131.Add(MakeKeyword("Mask"), (*_elem130).Mask)
// 								_obj_map131 = Object(_map131)
// 							} else {
// 								_obj_map131 = NIL
// 							}
// 							_vec130 = _vec130.Conjoin(_obj_map131)
// 						}
// 						_map75.Add(MakeKeyword("PermittedIPRanges"), _vec130)
// 						_vec132 := EmptyVector
// 						for _, _elem132 := range (*_elem74).ExcludedIPRanges {
// 							var _obj_map133 Object
// 							if _elem132 != nil {
// 								_map133 := EmptyArrayMap()
// 								_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 								_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 								_obj_map133 = Object(_map133)
// 							} else {
// 								_obj_map133 = NIL
// 							}
// 							_vec132 = _vec132.Conjoin(_obj_map133)
// 						}
// 						_map75.Add(MakeKeyword("ExcludedIPRanges"), _vec132)
// 						_vec134 := EmptyVector
// 						for _, _elem134 := range (*_elem74).PermittedEmailAddresses {
// 							_vec134 = _vec134.Conjoin(MakeString(_elem134))
// 						}
// 						_map75.Add(MakeKeyword("PermittedEmailAddresses"), _vec134)
// 						_vec135 := EmptyVector
// 						for _, _elem135 := range (*_elem74).ExcludedEmailAddresses {
// 							_vec135 = _vec135.Conjoin(MakeString(_elem135))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedEmailAddresses"), _vec135)
// 						_vec136 := EmptyVector
// 						for _, _elem136 := range (*_elem74).PermittedURIDomains {
// 							_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 						}
// 						_map75.Add(MakeKeyword("PermittedURIDomains"), _vec136)
// 						_vec137 := EmptyVector
// 						for _, _elem137 := range (*_elem74).ExcludedURIDomains {
// 							_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedURIDomains"), _vec137)
// 						_vec138 := EmptyVector
// 						for _, _elem138 := range (*_elem74).CRLDistributionPoints {
// 							_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 						}
// 						_map75.Add(MakeKeyword("CRLDistributionPoints"), _vec138)
// 						_vec139 := EmptyVector
// 						for _, _elem139 := range (*_elem74).PolicyIdentifiers {
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range _elem139 {
// 								_vec140 = _vec140.Conjoin(MakeInt(_elem140))
// 							}
// 							_vec139 = _vec139.Conjoin(_vec140)
// 						}
// 						_map75.Add(MakeKeyword("PolicyIdentifiers"), _vec139)
// 						_obj_map75 = Object(_map75)
// 					} else {
// 						_obj_map75 = NIL
// 					}
// 					_vec74 = _vec74.Conjoin(_obj_map75)
// 				}
// 				_vec73 = _vec73.Conjoin(_vec74)
// 			}
// 			_map5.Add(MakeKeyword("VerifiedChains"), _vec73)
// 			_vec141 := EmptyVector
// 			for _, _elem141 := range (*(*_res1).TLS).SignedCertificateTimestamps {
// 				_vec142 := EmptyVector
// 				for _, _elem142 := range _elem141 {
// 					_vec142 = _vec142.Conjoin(MakeInt(int(_elem142)))
// 				}
// 				_vec141 = _vec141.Conjoin(_vec142)
// 			}
// 			_map5.Add(MakeKeyword("SignedCertificateTimestamps"), _vec141)
// 			_vec143 := EmptyVector
// 			for _, _elem143 := range (*(*_res1).TLS).OCSPResponse {
// 				_vec143 = _vec143.Conjoin(MakeInt(int(_elem143)))
// 			}
// 			_map5.Add(MakeKeyword("OCSPResponse"), _vec143)
// 			_vec144 := EmptyVector
// 			for _, _elem144 := range (*(*_res1).TLS).TLSUnique {
// 				_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 			}
// 			_map5.Add(MakeKeyword("TLSUnique"), _vec144)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map5)
// 		_map1.Add(MakeKeyword("Cancel"), (*_res1).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res1).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/cookiejar.New:
// func new(o *net/http/cookiejar.Options) Object {
// 	_, _res2 := _cookiejar.New(o)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/fcgi.ProcessEnv:
// func processEnv(r *net/http.Request) Object {
// 	return _fcgi.ProcessEnv(r)
// }

GO FUNC net/http/httptest.NewRecorder:
// func newRecorder() Object {
// 	_res := _httptest.NewRecorder()
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Code"), MakeInt((*_res).Code))
// 		_map1.Add(MakeKeyword("HeaderMap"), (*_res).HeaderMap)
// 		_map1.Add(MakeKeyword("Body"), NIL)
// 		_map1.Add(MakeKeyword("Flushed"), MakeBool((*_res).Flushed))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewRequest:
// func newRequest(method string, target string, body io.Reader) Object {
// 	_res := _httptest.NewRequest(method, target, body)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Method"), MakeString((*_res).Method))
// 		var _obj_map2 Object
// 		if (*_res).URL != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Scheme"), MakeString((*(*_res).URL).Scheme))
// 			_map2.Add(MakeKeyword("Opaque"), MakeString((*(*_res).URL).Opaque))
// 			_map2.Add(MakeKeyword("User"), (*(*(*_res).URL).User))
// 			_map2.Add(MakeKeyword("Host"), MakeString((*(*_res).URL).Host))
// 			_map2.Add(MakeKeyword("Path"), MakeString((*(*_res).URL).Path))
// 			_map2.Add(MakeKeyword("RawPath"), MakeString((*(*_res).URL).RawPath))
// 			_map2.Add(MakeKeyword("ForceQuery"), MakeBool((*(*_res).URL).ForceQuery))
// 			_map2.Add(MakeKeyword("RawQuery"), MakeString((*(*_res).URL).RawQuery))
// 			_map2.Add(MakeKeyword("Fragment"), MakeString((*(*_res).URL).Fragment))
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("URL"), _obj_map2)
// 		_map1.Add(MakeKeyword("Proto"), MakeString((*_res).Proto))
// 		_map1.Add(MakeKeyword("ProtoMajor"), MakeInt((*_res).ProtoMajor))
// 		_map1.Add(MakeKeyword("ProtoMinor"), MakeInt((*_res).ProtoMinor))
// 		_map1.Add(MakeKeyword("Header"), (*_res).Header)
// 		_map1.Add(MakeKeyword("Body"), (*_res).Body)
// 		_map1.Add(MakeKeyword("GetBody"), (*_res).GetBody)
// 		_map1.Add(MakeKeyword("ContentLength"), MakeInt(int((*_res).ContentLength)))
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).TransferEncoding {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("TransferEncoding"), _vec3)
// 		_map1.Add(MakeKeyword("Close"), MakeBool((*_res).Close))
// 		_map1.Add(MakeKeyword("Host"), MakeString((*_res).Host))
// 		_map1.Add(MakeKeyword("Form"), (*_res).Form)
// 		_map1.Add(MakeKeyword("PostForm"), (*_res).PostForm)
// 		var _obj_map4 Object
// 		if (*_res).MultipartForm != nil {
// 			_map4 := EmptyArrayMap()
// 			_map4.Add(MakeKeyword("Value"), (*(*_res).MultipartForm).Value)
// 			_map4.Add(MakeKeyword("File"), (*(*_res).MultipartForm).File)
// 			_obj_map4 = Object(_map4)
// 		} else {
// 			_obj_map4 = NIL
// 		}
// 		_map1.Add(MakeKeyword("MultipartForm"), _obj_map4)
// 		_map1.Add(MakeKeyword("Trailer"), (*_res).Trailer)
// 		_map1.Add(MakeKeyword("RemoteAddr"), MakeString((*_res).RemoteAddr))
// 		_map1.Add(MakeKeyword("RequestURI"), MakeString((*_res).RequestURI))
// 		var _obj_map5 Object
// 		if (*_res).TLS != nil {
// 			_map5 := EmptyArrayMap()
// 			_map5.Add(MakeKeyword("Version"), MakeInt(int((*(*_res).TLS).Version)))
// 			_map5.Add(MakeKeyword("HandshakeComplete"), MakeBool((*(*_res).TLS).HandshakeComplete))
// 			_map5.Add(MakeKeyword("DidResume"), MakeBool((*(*_res).TLS).DidResume))
// 			_map5.Add(MakeKeyword("CipherSuite"), MakeInt(int((*(*_res).TLS).CipherSuite)))
// 			_map5.Add(MakeKeyword("NegotiatedProtocol"), MakeString((*(*_res).TLS).NegotiatedProtocol))
// 			_map5.Add(MakeKeyword("NegotiatedProtocolIsMutual"), MakeBool((*(*_res).TLS).NegotiatedProtocolIsMutual))
// 			_map5.Add(MakeKeyword("ServerName"), MakeString((*(*_res).TLS).ServerName))
// 			_vec6 := EmptyVector
// 			for _, _elem6 := range (*(*_res).TLS).PeerCertificates {
// 				var _obj_map7 Object
// 				if _elem6 != nil {
// 					_map7 := EmptyArrayMap()
// 					_vec8 := EmptyVector
// 					for _, _elem8 := range (*_elem6).Raw {
// 						_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 					}
// 					_map7.Add(MakeKeyword("Raw"), _vec8)
// 					_vec9 := EmptyVector
// 					for _, _elem9 := range (*_elem6).RawTBSCertificate {
// 						_vec9 = _vec9.Conjoin(MakeInt(int(_elem9)))
// 					}
// 					_map7.Add(MakeKeyword("RawTBSCertificate"), _vec9)
// 					_vec10 := EmptyVector
// 					for _, _elem10 := range (*_elem6).RawSubjectPublicKeyInfo {
// 						_vec10 = _vec10.Conjoin(MakeInt(int(_elem10)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec10)
// 					_vec11 := EmptyVector
// 					for _, _elem11 := range (*_elem6).RawSubject {
// 						_vec11 = _vec11.Conjoin(MakeInt(int(_elem11)))
// 					}
// 					_map7.Add(MakeKeyword("RawSubject"), _vec11)
// 					_vec12 := EmptyVector
// 					for _, _elem12 := range (*_elem6).RawIssuer {
// 						_vec12 = _vec12.Conjoin(MakeInt(int(_elem12)))
// 					}
// 					_map7.Add(MakeKeyword("RawIssuer"), _vec12)
// 					_vec13 := EmptyVector
// 					for _, _elem13 := range (*_elem6).Signature {
// 						_vec13 = _vec13.Conjoin(MakeInt(int(_elem13)))
// 					}
// 					_map7.Add(MakeKeyword("Signature"), _vec13)
// 					_map7.Add(MakeKeyword("SignatureAlgorithm"), (*_elem6).SignatureAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem6).PublicKeyAlgorithm)
// 					_map7.Add(MakeKeyword("PublicKey"), (*_elem6).PublicKey)
// 					_map7.Add(MakeKeyword("Version"), MakeInt((*_elem6).Version))
// 					_map7.Add(MakeKeyword("SerialNumber"), NIL)
// 					_map15 := EmptyArrayMap()
// 					_vec16 := EmptyVector
// 					for _, _elem16 := range (*_elem6).Issuer.Country {
// 						_vec16 = _vec16.Conjoin(MakeString(_elem16))
// 					}
// 					_map15.Add(MakeKeyword("Country"), _vec16)
// 					_vec17 := EmptyVector
// 					for _, _elem17 := range (*_elem6).Issuer.Organization {
// 						_vec17 = _vec17.Conjoin(MakeString(_elem17))
// 					}
// 					_map15.Add(MakeKeyword("Organization"), _vec17)
// 					_vec18 := EmptyVector
// 					for _, _elem18 := range (*_elem6).Issuer.OrganizationalUnit {
// 						_vec18 = _vec18.Conjoin(MakeString(_elem18))
// 					}
// 					_map15.Add(MakeKeyword("OrganizationalUnit"), _vec18)
// 					_vec19 := EmptyVector
// 					for _, _elem19 := range (*_elem6).Issuer.Locality {
// 						_vec19 = _vec19.Conjoin(MakeString(_elem19))
// 					}
// 					_map15.Add(MakeKeyword("Locality"), _vec19)
// 					_vec20 := EmptyVector
// 					for _, _elem20 := range (*_elem6).Issuer.Province {
// 						_vec20 = _vec20.Conjoin(MakeString(_elem20))
// 					}
// 					_map15.Add(MakeKeyword("Province"), _vec20)
// 					_vec21 := EmptyVector
// 					for _, _elem21 := range (*_elem6).Issuer.StreetAddress {
// 						_vec21 = _vec21.Conjoin(MakeString(_elem21))
// 					}
// 					_map15.Add(MakeKeyword("StreetAddress"), _vec21)
// 					_vec22 := EmptyVector
// 					for _, _elem22 := range (*_elem6).Issuer.PostalCode {
// 						_vec22 = _vec22.Conjoin(MakeString(_elem22))
// 					}
// 					_map15.Add(MakeKeyword("PostalCode"), _vec22)
// 					_map15.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Issuer.SerialNumber))
// 					_map15.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Issuer.CommonName))
// 					_vec23 := EmptyVector
// 					for _, _elem23 := range (*_elem6).Issuer.Names {
// 						_vec23 = _vec23.Conjoin(_elem23)
// 					}
// 					_map15.Add(MakeKeyword("Names"), _vec23)
// 					_vec24 := EmptyVector
// 					for _, _elem24 := range (*_elem6).Issuer.ExtraNames {
// 						_vec24 = _vec24.Conjoin(_elem24)
// 					}
// 					_map15.Add(MakeKeyword("ExtraNames"), _vec24)
// 					_map7.Add(MakeKeyword("Issuer"), _map15)
// 					_map25 := EmptyArrayMap()
// 					_vec26 := EmptyVector
// 					for _, _elem26 := range (*_elem6).Subject.Country {
// 						_vec26 = _vec26.Conjoin(MakeString(_elem26))
// 					}
// 					_map25.Add(MakeKeyword("Country"), _vec26)
// 					_vec27 := EmptyVector
// 					for _, _elem27 := range (*_elem6).Subject.Organization {
// 						_vec27 = _vec27.Conjoin(MakeString(_elem27))
// 					}
// 					_map25.Add(MakeKeyword("Organization"), _vec27)
// 					_vec28 := EmptyVector
// 					for _, _elem28 := range (*_elem6).Subject.OrganizationalUnit {
// 						_vec28 = _vec28.Conjoin(MakeString(_elem28))
// 					}
// 					_map25.Add(MakeKeyword("OrganizationalUnit"), _vec28)
// 					_vec29 := EmptyVector
// 					for _, _elem29 := range (*_elem6).Subject.Locality {
// 						_vec29 = _vec29.Conjoin(MakeString(_elem29))
// 					}
// 					_map25.Add(MakeKeyword("Locality"), _vec29)
// 					_vec30 := EmptyVector
// 					for _, _elem30 := range (*_elem6).Subject.Province {
// 						_vec30 = _vec30.Conjoin(MakeString(_elem30))
// 					}
// 					_map25.Add(MakeKeyword("Province"), _vec30)
// 					_vec31 := EmptyVector
// 					for _, _elem31 := range (*_elem6).Subject.StreetAddress {
// 						_vec31 = _vec31.Conjoin(MakeString(_elem31))
// 					}
// 					_map25.Add(MakeKeyword("StreetAddress"), _vec31)
// 					_vec32 := EmptyVector
// 					for _, _elem32 := range (*_elem6).Subject.PostalCode {
// 						_vec32 = _vec32.Conjoin(MakeString(_elem32))
// 					}
// 					_map25.Add(MakeKeyword("PostalCode"), _vec32)
// 					_map25.Add(MakeKeyword("SerialNumber"), MakeString((*_elem6).Subject.SerialNumber))
// 					_map25.Add(MakeKeyword("CommonName"), MakeString((*_elem6).Subject.CommonName))
// 					_vec33 := EmptyVector
// 					for _, _elem33 := range (*_elem6).Subject.Names {
// 						_vec33 = _vec33.Conjoin(_elem33)
// 					}
// 					_map25.Add(MakeKeyword("Names"), _vec33)
// 					_vec34 := EmptyVector
// 					for _, _elem34 := range (*_elem6).Subject.ExtraNames {
// 						_vec34 = _vec34.Conjoin(_elem34)
// 					}
// 					_map25.Add(MakeKeyword("ExtraNames"), _vec34)
// 					_map7.Add(MakeKeyword("Subject"), _map25)
// 					_map7.Add(MakeKeyword("NotBefore"), NIL)
// 					_map7.Add(MakeKeyword("NotAfter"), NIL)
// 					_map7.Add(MakeKeyword("KeyUsage"), (*_elem6).KeyUsage)
// 					_vec37 := EmptyVector
// 					for _, _elem37 := range (*_elem6).Extensions {
// 						_map38 := EmptyArrayMap()
// 						_vec39 := EmptyVector
// 						for _, _elem39 := range _elem37.Id {
// 							_vec39 = _vec39.Conjoin(MakeInt(_elem39))
// 						}
// 						_map38.Add(MakeKeyword("Id"), _vec39)
// 						_map38.Add(MakeKeyword("Critical"), MakeBool(_elem37.Critical))
// 						_vec40 := EmptyVector
// 						for _, _elem40 := range _elem37.Value {
// 							_vec40 = _vec40.Conjoin(MakeInt(int(_elem40)))
// 						}
// 						_map38.Add(MakeKeyword("Value"), _vec40)
// 						_vec37 = _vec37.Conjoin(_map38)
// 					}
// 					_map7.Add(MakeKeyword("Extensions"), _vec37)
// 					_vec41 := EmptyVector
// 					for _, _elem41 := range (*_elem6).ExtraExtensions {
// 						_map42 := EmptyArrayMap()
// 						_vec43 := EmptyVector
// 						for _, _elem43 := range _elem41.Id {
// 							_vec43 = _vec43.Conjoin(MakeInt(_elem43))
// 						}
// 						_map42.Add(MakeKeyword("Id"), _vec43)
// 						_map42.Add(MakeKeyword("Critical"), MakeBool(_elem41.Critical))
// 						_vec44 := EmptyVector
// 						for _, _elem44 := range _elem41.Value {
// 							_vec44 = _vec44.Conjoin(MakeInt(int(_elem44)))
// 						}
// 						_map42.Add(MakeKeyword("Value"), _vec44)
// 						_vec41 = _vec41.Conjoin(_map42)
// 					}
// 					_map7.Add(MakeKeyword("ExtraExtensions"), _vec41)
// 					_vec45 := EmptyVector
// 					for _, _elem45 := range (*_elem6).UnhandledCriticalExtensions {
// 						_vec46 := EmptyVector
// 						for _, _elem46 := range _elem45 {
// 							_vec46 = _vec46.Conjoin(MakeInt(_elem46))
// 						}
// 						_vec45 = _vec45.Conjoin(_vec46)
// 					}
// 					_map7.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec45)
// 					_vec47 := EmptyVector
// 					for _, _elem47 := range (*_elem6).ExtKeyUsage {
// 						_vec47 = _vec47.Conjoin(_elem47)
// 					}
// 					_map7.Add(MakeKeyword("ExtKeyUsage"), _vec47)
// 					_vec48 := EmptyVector
// 					for _, _elem48 := range (*_elem6).UnknownExtKeyUsage {
// 						_vec49 := EmptyVector
// 						for _, _elem49 := range _elem48 {
// 							_vec49 = _vec49.Conjoin(MakeInt(_elem49))
// 						}
// 						_vec48 = _vec48.Conjoin(_vec49)
// 					}
// 					_map7.Add(MakeKeyword("UnknownExtKeyUsage"), _vec48)
// 					_map7.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem6).BasicConstraintsValid))
// 					_map7.Add(MakeKeyword("IsCA"), MakeBool((*_elem6).IsCA))
// 					_map7.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem6).MaxPathLen))
// 					_map7.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem6).MaxPathLenZero))
// 					_vec50 := EmptyVector
// 					for _, _elem50 := range (*_elem6).SubjectKeyId {
// 						_vec50 = _vec50.Conjoin(MakeInt(int(_elem50)))
// 					}
// 					_map7.Add(MakeKeyword("SubjectKeyId"), _vec50)
// 					_vec51 := EmptyVector
// 					for _, _elem51 := range (*_elem6).AuthorityKeyId {
// 						_vec51 = _vec51.Conjoin(MakeInt(int(_elem51)))
// 					}
// 					_map7.Add(MakeKeyword("AuthorityKeyId"), _vec51)
// 					_vec52 := EmptyVector
// 					for _, _elem52 := range (*_elem6).OCSPServer {
// 						_vec52 = _vec52.Conjoin(MakeString(_elem52))
// 					}
// 					_map7.Add(MakeKeyword("OCSPServer"), _vec52)
// 					_vec53 := EmptyVector
// 					for _, _elem53 := range (*_elem6).IssuingCertificateURL {
// 						_vec53 = _vec53.Conjoin(MakeString(_elem53))
// 					}
// 					_map7.Add(MakeKeyword("IssuingCertificateURL"), _vec53)
// 					_vec54 := EmptyVector
// 					for _, _elem54 := range (*_elem6).DNSNames {
// 						_vec54 = _vec54.Conjoin(MakeString(_elem54))
// 					}
// 					_map7.Add(MakeKeyword("DNSNames"), _vec54)
// 					_vec55 := EmptyVector
// 					for _, _elem55 := range (*_elem6).EmailAddresses {
// 						_vec55 = _vec55.Conjoin(MakeString(_elem55))
// 					}
// 					_map7.Add(MakeKeyword("EmailAddresses"), _vec55)
// 					_vec56 := EmptyVector
// 					for _, _elem56 := range (*_elem6).IPAddresses {
// 						_vec57 := EmptyVector
// 						for _, _elem57 := range _elem56 {
// 							_vec57 = _vec57.Conjoin(MakeInt(int(_elem57)))
// 						}
// 						_vec56 = _vec56.Conjoin(_vec57)
// 					}
// 					_map7.Add(MakeKeyword("IPAddresses"), _vec56)
// 					_vec58 := EmptyVector
// 					for _, _elem58 := range (*_elem6).URIs {
// 						var _obj_map59 Object
// 						if _elem58 != nil {
// 							_map59 := EmptyArrayMap()
// 							_map59.Add(MakeKeyword("Scheme"), MakeString((*_elem58).Scheme))
// 							_map59.Add(MakeKeyword("Opaque"), MakeString((*_elem58).Opaque))
// 							_map59.Add(MakeKeyword("User"), (*(*_elem58).User))
// 							_map59.Add(MakeKeyword("Host"), MakeString((*_elem58).Host))
// 							_map59.Add(MakeKeyword("Path"), MakeString((*_elem58).Path))
// 							_map59.Add(MakeKeyword("RawPath"), MakeString((*_elem58).RawPath))
// 							_map59.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem58).ForceQuery))
// 							_map59.Add(MakeKeyword("RawQuery"), MakeString((*_elem58).RawQuery))
// 							_map59.Add(MakeKeyword("Fragment"), MakeString((*_elem58).Fragment))
// 							_obj_map59 = Object(_map59)
// 						} else {
// 							_obj_map59 = NIL
// 						}
// 						_vec58 = _vec58.Conjoin(_obj_map59)
// 					}
// 					_map7.Add(MakeKeyword("URIs"), _vec58)
// 					_map7.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem6).PermittedDNSDomainsCritical))
// 					_vec60 := EmptyVector
// 					for _, _elem60 := range (*_elem6).PermittedDNSDomains {
// 						_vec60 = _vec60.Conjoin(MakeString(_elem60))
// 					}
// 					_map7.Add(MakeKeyword("PermittedDNSDomains"), _vec60)
// 					_vec61 := EmptyVector
// 					for _, _elem61 := range (*_elem6).ExcludedDNSDomains {
// 						_vec61 = _vec61.Conjoin(MakeString(_elem61))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedDNSDomains"), _vec61)
// 					_vec62 := EmptyVector
// 					for _, _elem62 := range (*_elem6).PermittedIPRanges {
// 						var _obj_map63 Object
// 						if _elem62 != nil {
// 							_map63 := EmptyArrayMap()
// 							_map63.Add(MakeKeyword("IP"), (*_elem62).IP)
// 							_map63.Add(MakeKeyword("Mask"), (*_elem62).Mask)
// 							_obj_map63 = Object(_map63)
// 						} else {
// 							_obj_map63 = NIL
// 						}
// 						_vec62 = _vec62.Conjoin(_obj_map63)
// 					}
// 					_map7.Add(MakeKeyword("PermittedIPRanges"), _vec62)
// 					_vec64 := EmptyVector
// 					for _, _elem64 := range (*_elem6).ExcludedIPRanges {
// 						var _obj_map65 Object
// 						if _elem64 != nil {
// 							_map65 := EmptyArrayMap()
// 							_map65.Add(MakeKeyword("IP"), (*_elem64).IP)
// 							_map65.Add(MakeKeyword("Mask"), (*_elem64).Mask)
// 							_obj_map65 = Object(_map65)
// 						} else {
// 							_obj_map65 = NIL
// 						}
// 						_vec64 = _vec64.Conjoin(_obj_map65)
// 					}
// 					_map7.Add(MakeKeyword("ExcludedIPRanges"), _vec64)
// 					_vec66 := EmptyVector
// 					for _, _elem66 := range (*_elem6).PermittedEmailAddresses {
// 						_vec66 = _vec66.Conjoin(MakeString(_elem66))
// 					}
// 					_map7.Add(MakeKeyword("PermittedEmailAddresses"), _vec66)
// 					_vec67 := EmptyVector
// 					for _, _elem67 := range (*_elem6).ExcludedEmailAddresses {
// 						_vec67 = _vec67.Conjoin(MakeString(_elem67))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedEmailAddresses"), _vec67)
// 					_vec68 := EmptyVector
// 					for _, _elem68 := range (*_elem6).PermittedURIDomains {
// 						_vec68 = _vec68.Conjoin(MakeString(_elem68))
// 					}
// 					_map7.Add(MakeKeyword("PermittedURIDomains"), _vec68)
// 					_vec69 := EmptyVector
// 					for _, _elem69 := range (*_elem6).ExcludedURIDomains {
// 						_vec69 = _vec69.Conjoin(MakeString(_elem69))
// 					}
// 					_map7.Add(MakeKeyword("ExcludedURIDomains"), _vec69)
// 					_vec70 := EmptyVector
// 					for _, _elem70 := range (*_elem6).CRLDistributionPoints {
// 						_vec70 = _vec70.Conjoin(MakeString(_elem70))
// 					}
// 					_map7.Add(MakeKeyword("CRLDistributionPoints"), _vec70)
// 					_vec71 := EmptyVector
// 					for _, _elem71 := range (*_elem6).PolicyIdentifiers {
// 						_vec72 := EmptyVector
// 						for _, _elem72 := range _elem71 {
// 							_vec72 = _vec72.Conjoin(MakeInt(_elem72))
// 						}
// 						_vec71 = _vec71.Conjoin(_vec72)
// 					}
// 					_map7.Add(MakeKeyword("PolicyIdentifiers"), _vec71)
// 					_obj_map7 = Object(_map7)
// 				} else {
// 					_obj_map7 = NIL
// 				}
// 				_vec6 = _vec6.Conjoin(_obj_map7)
// 			}
// 			_map5.Add(MakeKeyword("PeerCertificates"), _vec6)
// 			_vec73 := EmptyVector
// 			for _, _elem73 := range (*(*_res).TLS).VerifiedChains {
// 				_vec74 := EmptyVector
// 				for _, _elem74 := range _elem73 {
// 					var _obj_map75 Object
// 					if _elem74 != nil {
// 						_map75 := EmptyArrayMap()
// 						_vec76 := EmptyVector
// 						for _, _elem76 := range (*_elem74).Raw {
// 							_vec76 = _vec76.Conjoin(MakeInt(int(_elem76)))
// 						}
// 						_map75.Add(MakeKeyword("Raw"), _vec76)
// 						_vec77 := EmptyVector
// 						for _, _elem77 := range (*_elem74).RawTBSCertificate {
// 							_vec77 = _vec77.Conjoin(MakeInt(int(_elem77)))
// 						}
// 						_map75.Add(MakeKeyword("RawTBSCertificate"), _vec77)
// 						_vec78 := EmptyVector
// 						for _, _elem78 := range (*_elem74).RawSubjectPublicKeyInfo {
// 							_vec78 = _vec78.Conjoin(MakeInt(int(_elem78)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubjectPublicKeyInfo"), _vec78)
// 						_vec79 := EmptyVector
// 						for _, _elem79 := range (*_elem74).RawSubject {
// 							_vec79 = _vec79.Conjoin(MakeInt(int(_elem79)))
// 						}
// 						_map75.Add(MakeKeyword("RawSubject"), _vec79)
// 						_vec80 := EmptyVector
// 						for _, _elem80 := range (*_elem74).RawIssuer {
// 							_vec80 = _vec80.Conjoin(MakeInt(int(_elem80)))
// 						}
// 						_map75.Add(MakeKeyword("RawIssuer"), _vec80)
// 						_vec81 := EmptyVector
// 						for _, _elem81 := range (*_elem74).Signature {
// 							_vec81 = _vec81.Conjoin(MakeInt(int(_elem81)))
// 						}
// 						_map75.Add(MakeKeyword("Signature"), _vec81)
// 						_map75.Add(MakeKeyword("SignatureAlgorithm"), (*_elem74).SignatureAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKeyAlgorithm"), (*_elem74).PublicKeyAlgorithm)
// 						_map75.Add(MakeKeyword("PublicKey"), (*_elem74).PublicKey)
// 						_map75.Add(MakeKeyword("Version"), MakeInt((*_elem74).Version))
// 						_map75.Add(MakeKeyword("SerialNumber"), NIL)
// 						_map83 := EmptyArrayMap()
// 						_vec84 := EmptyVector
// 						for _, _elem84 := range (*_elem74).Issuer.Country {
// 							_vec84 = _vec84.Conjoin(MakeString(_elem84))
// 						}
// 						_map83.Add(MakeKeyword("Country"), _vec84)
// 						_vec85 := EmptyVector
// 						for _, _elem85 := range (*_elem74).Issuer.Organization {
// 							_vec85 = _vec85.Conjoin(MakeString(_elem85))
// 						}
// 						_map83.Add(MakeKeyword("Organization"), _vec85)
// 						_vec86 := EmptyVector
// 						for _, _elem86 := range (*_elem74).Issuer.OrganizationalUnit {
// 							_vec86 = _vec86.Conjoin(MakeString(_elem86))
// 						}
// 						_map83.Add(MakeKeyword("OrganizationalUnit"), _vec86)
// 						_vec87 := EmptyVector
// 						for _, _elem87 := range (*_elem74).Issuer.Locality {
// 							_vec87 = _vec87.Conjoin(MakeString(_elem87))
// 						}
// 						_map83.Add(MakeKeyword("Locality"), _vec87)
// 						_vec88 := EmptyVector
// 						for _, _elem88 := range (*_elem74).Issuer.Province {
// 							_vec88 = _vec88.Conjoin(MakeString(_elem88))
// 						}
// 						_map83.Add(MakeKeyword("Province"), _vec88)
// 						_vec89 := EmptyVector
// 						for _, _elem89 := range (*_elem74).Issuer.StreetAddress {
// 							_vec89 = _vec89.Conjoin(MakeString(_elem89))
// 						}
// 						_map83.Add(MakeKeyword("StreetAddress"), _vec89)
// 						_vec90 := EmptyVector
// 						for _, _elem90 := range (*_elem74).Issuer.PostalCode {
// 							_vec90 = _vec90.Conjoin(MakeString(_elem90))
// 						}
// 						_map83.Add(MakeKeyword("PostalCode"), _vec90)
// 						_map83.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Issuer.SerialNumber))
// 						_map83.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Issuer.CommonName))
// 						_vec91 := EmptyVector
// 						for _, _elem91 := range (*_elem74).Issuer.Names {
// 							_vec91 = _vec91.Conjoin(_elem91)
// 						}
// 						_map83.Add(MakeKeyword("Names"), _vec91)
// 						_vec92 := EmptyVector
// 						for _, _elem92 := range (*_elem74).Issuer.ExtraNames {
// 							_vec92 = _vec92.Conjoin(_elem92)
// 						}
// 						_map83.Add(MakeKeyword("ExtraNames"), _vec92)
// 						_map75.Add(MakeKeyword("Issuer"), _map83)
// 						_map93 := EmptyArrayMap()
// 						_vec94 := EmptyVector
// 						for _, _elem94 := range (*_elem74).Subject.Country {
// 							_vec94 = _vec94.Conjoin(MakeString(_elem94))
// 						}
// 						_map93.Add(MakeKeyword("Country"), _vec94)
// 						_vec95 := EmptyVector
// 						for _, _elem95 := range (*_elem74).Subject.Organization {
// 							_vec95 = _vec95.Conjoin(MakeString(_elem95))
// 						}
// 						_map93.Add(MakeKeyword("Organization"), _vec95)
// 						_vec96 := EmptyVector
// 						for _, _elem96 := range (*_elem74).Subject.OrganizationalUnit {
// 							_vec96 = _vec96.Conjoin(MakeString(_elem96))
// 						}
// 						_map93.Add(MakeKeyword("OrganizationalUnit"), _vec96)
// 						_vec97 := EmptyVector
// 						for _, _elem97 := range (*_elem74).Subject.Locality {
// 							_vec97 = _vec97.Conjoin(MakeString(_elem97))
// 						}
// 						_map93.Add(MakeKeyword("Locality"), _vec97)
// 						_vec98 := EmptyVector
// 						for _, _elem98 := range (*_elem74).Subject.Province {
// 							_vec98 = _vec98.Conjoin(MakeString(_elem98))
// 						}
// 						_map93.Add(MakeKeyword("Province"), _vec98)
// 						_vec99 := EmptyVector
// 						for _, _elem99 := range (*_elem74).Subject.StreetAddress {
// 							_vec99 = _vec99.Conjoin(MakeString(_elem99))
// 						}
// 						_map93.Add(MakeKeyword("StreetAddress"), _vec99)
// 						_vec100 := EmptyVector
// 						for _, _elem100 := range (*_elem74).Subject.PostalCode {
// 							_vec100 = _vec100.Conjoin(MakeString(_elem100))
// 						}
// 						_map93.Add(MakeKeyword("PostalCode"), _vec100)
// 						_map93.Add(MakeKeyword("SerialNumber"), MakeString((*_elem74).Subject.SerialNumber))
// 						_map93.Add(MakeKeyword("CommonName"), MakeString((*_elem74).Subject.CommonName))
// 						_vec101 := EmptyVector
// 						for _, _elem101 := range (*_elem74).Subject.Names {
// 							_vec101 = _vec101.Conjoin(_elem101)
// 						}
// 						_map93.Add(MakeKeyword("Names"), _vec101)
// 						_vec102 := EmptyVector
// 						for _, _elem102 := range (*_elem74).Subject.ExtraNames {
// 							_vec102 = _vec102.Conjoin(_elem102)
// 						}
// 						_map93.Add(MakeKeyword("ExtraNames"), _vec102)
// 						_map75.Add(MakeKeyword("Subject"), _map93)
// 						_map75.Add(MakeKeyword("NotBefore"), NIL)
// 						_map75.Add(MakeKeyword("NotAfter"), NIL)
// 						_map75.Add(MakeKeyword("KeyUsage"), (*_elem74).KeyUsage)
// 						_vec105 := EmptyVector
// 						for _, _elem105 := range (*_elem74).Extensions {
// 							_map106 := EmptyArrayMap()
// 							_vec107 := EmptyVector
// 							for _, _elem107 := range _elem105.Id {
// 								_vec107 = _vec107.Conjoin(MakeInt(_elem107))
// 							}
// 							_map106.Add(MakeKeyword("Id"), _vec107)
// 							_map106.Add(MakeKeyword("Critical"), MakeBool(_elem105.Critical))
// 							_vec108 := EmptyVector
// 							for _, _elem108 := range _elem105.Value {
// 								_vec108 = _vec108.Conjoin(MakeInt(int(_elem108)))
// 							}
// 							_map106.Add(MakeKeyword("Value"), _vec108)
// 							_vec105 = _vec105.Conjoin(_map106)
// 						}
// 						_map75.Add(MakeKeyword("Extensions"), _vec105)
// 						_vec109 := EmptyVector
// 						for _, _elem109 := range (*_elem74).ExtraExtensions {
// 							_map110 := EmptyArrayMap()
// 							_vec111 := EmptyVector
// 							for _, _elem111 := range _elem109.Id {
// 								_vec111 = _vec111.Conjoin(MakeInt(_elem111))
// 							}
// 							_map110.Add(MakeKeyword("Id"), _vec111)
// 							_map110.Add(MakeKeyword("Critical"), MakeBool(_elem109.Critical))
// 							_vec112 := EmptyVector
// 							for _, _elem112 := range _elem109.Value {
// 								_vec112 = _vec112.Conjoin(MakeInt(int(_elem112)))
// 							}
// 							_map110.Add(MakeKeyword("Value"), _vec112)
// 							_vec109 = _vec109.Conjoin(_map110)
// 						}
// 						_map75.Add(MakeKeyword("ExtraExtensions"), _vec109)
// 						_vec113 := EmptyVector
// 						for _, _elem113 := range (*_elem74).UnhandledCriticalExtensions {
// 							_vec114 := EmptyVector
// 							for _, _elem114 := range _elem113 {
// 								_vec114 = _vec114.Conjoin(MakeInt(_elem114))
// 							}
// 							_vec113 = _vec113.Conjoin(_vec114)
// 						}
// 						_map75.Add(MakeKeyword("UnhandledCriticalExtensions"), _vec113)
// 						_vec115 := EmptyVector
// 						for _, _elem115 := range (*_elem74).ExtKeyUsage {
// 							_vec115 = _vec115.Conjoin(_elem115)
// 						}
// 						_map75.Add(MakeKeyword("ExtKeyUsage"), _vec115)
// 						_vec116 := EmptyVector
// 						for _, _elem116 := range (*_elem74).UnknownExtKeyUsage {
// 							_vec117 := EmptyVector
// 							for _, _elem117 := range _elem116 {
// 								_vec117 = _vec117.Conjoin(MakeInt(_elem117))
// 							}
// 							_vec116 = _vec116.Conjoin(_vec117)
// 						}
// 						_map75.Add(MakeKeyword("UnknownExtKeyUsage"), _vec116)
// 						_map75.Add(MakeKeyword("BasicConstraintsValid"), MakeBool((*_elem74).BasicConstraintsValid))
// 						_map75.Add(MakeKeyword("IsCA"), MakeBool((*_elem74).IsCA))
// 						_map75.Add(MakeKeyword("MaxPathLen"), MakeInt((*_elem74).MaxPathLen))
// 						_map75.Add(MakeKeyword("MaxPathLenZero"), MakeBool((*_elem74).MaxPathLenZero))
// 						_vec118 := EmptyVector
// 						for _, _elem118 := range (*_elem74).SubjectKeyId {
// 							_vec118 = _vec118.Conjoin(MakeInt(int(_elem118)))
// 						}
// 						_map75.Add(MakeKeyword("SubjectKeyId"), _vec118)
// 						_vec119 := EmptyVector
// 						for _, _elem119 := range (*_elem74).AuthorityKeyId {
// 							_vec119 = _vec119.Conjoin(MakeInt(int(_elem119)))
// 						}
// 						_map75.Add(MakeKeyword("AuthorityKeyId"), _vec119)
// 						_vec120 := EmptyVector
// 						for _, _elem120 := range (*_elem74).OCSPServer {
// 							_vec120 = _vec120.Conjoin(MakeString(_elem120))
// 						}
// 						_map75.Add(MakeKeyword("OCSPServer"), _vec120)
// 						_vec121 := EmptyVector
// 						for _, _elem121 := range (*_elem74).IssuingCertificateURL {
// 							_vec121 = _vec121.Conjoin(MakeString(_elem121))
// 						}
// 						_map75.Add(MakeKeyword("IssuingCertificateURL"), _vec121)
// 						_vec122 := EmptyVector
// 						for _, _elem122 := range (*_elem74).DNSNames {
// 							_vec122 = _vec122.Conjoin(MakeString(_elem122))
// 						}
// 						_map75.Add(MakeKeyword("DNSNames"), _vec122)
// 						_vec123 := EmptyVector
// 						for _, _elem123 := range (*_elem74).EmailAddresses {
// 							_vec123 = _vec123.Conjoin(MakeString(_elem123))
// 						}
// 						_map75.Add(MakeKeyword("EmailAddresses"), _vec123)
// 						_vec124 := EmptyVector
// 						for _, _elem124 := range (*_elem74).IPAddresses {
// 							_vec125 := EmptyVector
// 							for _, _elem125 := range _elem124 {
// 								_vec125 = _vec125.Conjoin(MakeInt(int(_elem125)))
// 							}
// 							_vec124 = _vec124.Conjoin(_vec125)
// 						}
// 						_map75.Add(MakeKeyword("IPAddresses"), _vec124)
// 						_vec126 := EmptyVector
// 						for _, _elem126 := range (*_elem74).URIs {
// 							var _obj_map127 Object
// 							if _elem126 != nil {
// 								_map127 := EmptyArrayMap()
// 								_map127.Add(MakeKeyword("Scheme"), MakeString((*_elem126).Scheme))
// 								_map127.Add(MakeKeyword("Opaque"), MakeString((*_elem126).Opaque))
// 								_map127.Add(MakeKeyword("User"), (*(*_elem126).User))
// 								_map127.Add(MakeKeyword("Host"), MakeString((*_elem126).Host))
// 								_map127.Add(MakeKeyword("Path"), MakeString((*_elem126).Path))
// 								_map127.Add(MakeKeyword("RawPath"), MakeString((*_elem126).RawPath))
// 								_map127.Add(MakeKeyword("ForceQuery"), MakeBool((*_elem126).ForceQuery))
// 								_map127.Add(MakeKeyword("RawQuery"), MakeString((*_elem126).RawQuery))
// 								_map127.Add(MakeKeyword("Fragment"), MakeString((*_elem126).Fragment))
// 								_obj_map127 = Object(_map127)
// 							} else {
// 								_obj_map127 = NIL
// 							}
// 							_vec126 = _vec126.Conjoin(_obj_map127)
// 						}
// 						_map75.Add(MakeKeyword("URIs"), _vec126)
// 						_map75.Add(MakeKeyword("PermittedDNSDomainsCritical"), MakeBool((*_elem74).PermittedDNSDomainsCritical))
// 						_vec128 := EmptyVector
// 						for _, _elem128 := range (*_elem74).PermittedDNSDomains {
// 							_vec128 = _vec128.Conjoin(MakeString(_elem128))
// 						}
// 						_map75.Add(MakeKeyword("PermittedDNSDomains"), _vec128)
// 						_vec129 := EmptyVector
// 						for _, _elem129 := range (*_elem74).ExcludedDNSDomains {
// 							_vec129 = _vec129.Conjoin(MakeString(_elem129))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedDNSDomains"), _vec129)
// 						_vec130 := EmptyVector
// 						for _, _elem130 := range (*_elem74).PermittedIPRanges {
// 							var _obj_map131 Object
// 							if _elem130 != nil {
// 								_map131 := EmptyArrayMap()
// 								_map131.Add(MakeKeyword("IP"), (*_elem130).IP)
// 								_map131.Add(MakeKeyword("Mask"), (*_elem130).Mask)
// 								_obj_map131 = Object(_map131)
// 							} else {
// 								_obj_map131 = NIL
// 							}
// 							_vec130 = _vec130.Conjoin(_obj_map131)
// 						}
// 						_map75.Add(MakeKeyword("PermittedIPRanges"), _vec130)
// 						_vec132 := EmptyVector
// 						for _, _elem132 := range (*_elem74).ExcludedIPRanges {
// 							var _obj_map133 Object
// 							if _elem132 != nil {
// 								_map133 := EmptyArrayMap()
// 								_map133.Add(MakeKeyword("IP"), (*_elem132).IP)
// 								_map133.Add(MakeKeyword("Mask"), (*_elem132).Mask)
// 								_obj_map133 = Object(_map133)
// 							} else {
// 								_obj_map133 = NIL
// 							}
// 							_vec132 = _vec132.Conjoin(_obj_map133)
// 						}
// 						_map75.Add(MakeKeyword("ExcludedIPRanges"), _vec132)
// 						_vec134 := EmptyVector
// 						for _, _elem134 := range (*_elem74).PermittedEmailAddresses {
// 							_vec134 = _vec134.Conjoin(MakeString(_elem134))
// 						}
// 						_map75.Add(MakeKeyword("PermittedEmailAddresses"), _vec134)
// 						_vec135 := EmptyVector
// 						for _, _elem135 := range (*_elem74).ExcludedEmailAddresses {
// 							_vec135 = _vec135.Conjoin(MakeString(_elem135))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedEmailAddresses"), _vec135)
// 						_vec136 := EmptyVector
// 						for _, _elem136 := range (*_elem74).PermittedURIDomains {
// 							_vec136 = _vec136.Conjoin(MakeString(_elem136))
// 						}
// 						_map75.Add(MakeKeyword("PermittedURIDomains"), _vec136)
// 						_vec137 := EmptyVector
// 						for _, _elem137 := range (*_elem74).ExcludedURIDomains {
// 							_vec137 = _vec137.Conjoin(MakeString(_elem137))
// 						}
// 						_map75.Add(MakeKeyword("ExcludedURIDomains"), _vec137)
// 						_vec138 := EmptyVector
// 						for _, _elem138 := range (*_elem74).CRLDistributionPoints {
// 							_vec138 = _vec138.Conjoin(MakeString(_elem138))
// 						}
// 						_map75.Add(MakeKeyword("CRLDistributionPoints"), _vec138)
// 						_vec139 := EmptyVector
// 						for _, _elem139 := range (*_elem74).PolicyIdentifiers {
// 							_vec140 := EmptyVector
// 							for _, _elem140 := range _elem139 {
// 								_vec140 = _vec140.Conjoin(MakeInt(_elem140))
// 							}
// 							_vec139 = _vec139.Conjoin(_vec140)
// 						}
// 						_map75.Add(MakeKeyword("PolicyIdentifiers"), _vec139)
// 						_obj_map75 = Object(_map75)
// 					} else {
// 						_obj_map75 = NIL
// 					}
// 					_vec74 = _vec74.Conjoin(_obj_map75)
// 				}
// 				_vec73 = _vec73.Conjoin(_vec74)
// 			}
// 			_map5.Add(MakeKeyword("VerifiedChains"), _vec73)
// 			_vec141 := EmptyVector
// 			for _, _elem141 := range (*(*_res).TLS).SignedCertificateTimestamps {
// 				_vec142 := EmptyVector
// 				for _, _elem142 := range _elem141 {
// 					_vec142 = _vec142.Conjoin(MakeInt(int(_elem142)))
// 				}
// 				_vec141 = _vec141.Conjoin(_vec142)
// 			}
// 			_map5.Add(MakeKeyword("SignedCertificateTimestamps"), _vec141)
// 			_vec143 := EmptyVector
// 			for _, _elem143 := range (*(*_res).TLS).OCSPResponse {
// 				_vec143 = _vec143.Conjoin(MakeInt(int(_elem143)))
// 			}
// 			_map5.Add(MakeKeyword("OCSPResponse"), _vec143)
// 			_vec144 := EmptyVector
// 			for _, _elem144 := range (*(*_res).TLS).TLSUnique {
// 				_vec144 = _vec144.Conjoin(MakeInt(int(_elem144)))
// 			}
// 			_map5.Add(MakeKeyword("TLSUnique"), _vec144)
// 			_obj_map5 = Object(_map5)
// 		} else {
// 			_obj_map5 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map5)
// 		_map1.Add(MakeKeyword("Cancel"), (*_res).Cancel)
// 		_map1.Add(MakeKeyword("Response"), (*(*_res).Response))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewServer:
// func newServer(handler net/http.Handler) Object {
// 	_res := _httptest.NewServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		var _obj_map2 Object
// 		if (*_res).TLS != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Rand"), (*(*_res).TLS).Rand)
// 			_map2.Add(MakeKeyword("Time"), (*(*_res).TLS).Time)
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*(*_res).TLS).Certificates {
// 				_vec3 = _vec3.Conjoin(_elem3)
// 			}
// 			_map2.Add(MakeKeyword("Certificates"), _vec3)
// 			_map2.Add(MakeKeyword("NameToCertificate"), (*(*_res).TLS).NameToCertificate)
// 			_map2.Add(MakeKeyword("GetCertificate"), (*(*_res).TLS).GetCertificate)
// 			_map2.Add(MakeKeyword("GetClientCertificate"), (*(*_res).TLS).GetClientCertificate)
// 			_map2.Add(MakeKeyword("GetConfigForClient"), (*(*_res).TLS).GetConfigForClient)
// 			_map2.Add(MakeKeyword("VerifyPeerCertificate"), (*(*_res).TLS).VerifyPeerCertificate)
// 			_map2.Add(MakeKeyword("RootCAs"), NIL)
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res).TLS).NextProtos {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map2.Add(MakeKeyword("NextProtos"), _vec5)
// 			_map2.Add(MakeKeyword("ServerName"), MakeString((*(*_res).TLS).ServerName))
// 			_map2.Add(MakeKeyword("ClientAuth"), (*(*_res).TLS).ClientAuth)
// 			_map2.Add(MakeKeyword("ClientCAs"), NIL)
// 			_map2.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*_res).TLS).InsecureSkipVerify))
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*(*_res).TLS).CipherSuites {
// 				_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 			}
// 			_map2.Add(MakeKeyword("CipherSuites"), _vec7)
// 			_map2.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*_res).TLS).PreferServerCipherSuites))
// 			_map2.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*_res).TLS).SessionTicketsDisabled))
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res).TLS).SessionTicketKey {
// 				_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 			}
// 			_map2.Add(MakeKeyword("SessionTicketKey"), _vec8)
// 			_map2.Add(MakeKeyword("ClientSessionCache"), (*(*_res).TLS).ClientSessionCache)
// 			_map2.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*_res).TLS).MinVersion)))
// 			_map2.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*_res).TLS).MaxVersion)))
// 			_vec9 := EmptyVector
// 			for _, _elem9 := range (*(*_res).TLS).CurvePreferences {
// 				_vec9 = _vec9.Conjoin(_elem9)
// 			}
// 			_map2.Add(MakeKeyword("CurvePreferences"), _vec9)
// 			_map2.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*_res).TLS).DynamicRecordSizingDisabled))
// 			_map2.Add(MakeKeyword("Renegotiation"), (*(*_res).TLS).Renegotiation)
// 			_map2.Add(MakeKeyword("KeyLogWriter"), (*(*_res).TLS).KeyLogWriter)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map2)
// 		var _obj_map10 Object
// 		if (*_res).Config != nil {
// 			_map10 := EmptyArrayMap()
// 			_map10.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map10.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			var _obj_map11 Object
// 			if (*(*_res).Config).TLSConfig != nil {
// 				_map11 := EmptyArrayMap()
// 				_map11.Add(MakeKeyword("Rand"), (*(*(*_res).Config).TLSConfig).Rand)
// 				_map11.Add(MakeKeyword("Time"), (*(*(*_res).Config).TLSConfig).Time)
// 				_vec12 := EmptyVector
// 				for _, _elem12 := range (*(*(*_res).Config).TLSConfig).Certificates {
// 					_vec12 = _vec12.Conjoin(_elem12)
// 				}
// 				_map11.Add(MakeKeyword("Certificates"), _vec12)
// 				_map11.Add(MakeKeyword("NameToCertificate"), (*(*(*_res).Config).TLSConfig).NameToCertificate)
// 				_map11.Add(MakeKeyword("GetCertificate"), (*(*(*_res).Config).TLSConfig).GetCertificate)
// 				_map11.Add(MakeKeyword("GetClientCertificate"), (*(*(*_res).Config).TLSConfig).GetClientCertificate)
// 				_map11.Add(MakeKeyword("GetConfigForClient"), (*(*(*_res).Config).TLSConfig).GetConfigForClient)
// 				_map11.Add(MakeKeyword("VerifyPeerCertificate"), (*(*(*_res).Config).TLSConfig).VerifyPeerCertificate)
// 				_map11.Add(MakeKeyword("RootCAs"), NIL)
// 				_vec14 := EmptyVector
// 				for _, _elem14 := range (*(*(*_res).Config).TLSConfig).NextProtos {
// 					_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 				}
// 				_map11.Add(MakeKeyword("NextProtos"), _vec14)
// 				_map11.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res).Config).TLSConfig).ServerName))
// 				_map11.Add(MakeKeyword("ClientAuth"), (*(*(*_res).Config).TLSConfig).ClientAuth)
// 				_map11.Add(MakeKeyword("ClientCAs"), NIL)
// 				_map11.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*(*_res).Config).TLSConfig).InsecureSkipVerify))
// 				_vec16 := EmptyVector
// 				for _, _elem16 := range (*(*(*_res).Config).TLSConfig).CipherSuites {
// 					_vec16 = _vec16.Conjoin(MakeInt(int(_elem16)))
// 				}
// 				_map11.Add(MakeKeyword("CipherSuites"), _vec16)
// 				_map11.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*(*_res).Config).TLSConfig).PreferServerCipherSuites))
// 				_map11.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).SessionTicketsDisabled))
// 				_vec17 := EmptyVector
// 				for _, _elem17 := range (*(*(*_res).Config).TLSConfig).SessionTicketKey {
// 					_vec17 = _vec17.Conjoin(MakeInt(int(_elem17)))
// 				}
// 				_map11.Add(MakeKeyword("SessionTicketKey"), _vec17)
// 				_map11.Add(MakeKeyword("ClientSessionCache"), (*(*(*_res).Config).TLSConfig).ClientSessionCache)
// 				_map11.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MinVersion)))
// 				_map11.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MaxVersion)))
// 				_vec18 := EmptyVector
// 				for _, _elem18 := range (*(*(*_res).Config).TLSConfig).CurvePreferences {
// 					_vec18 = _vec18.Conjoin(_elem18)
// 				}
// 				_map11.Add(MakeKeyword("CurvePreferences"), _vec18)
// 				_map11.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).DynamicRecordSizingDisabled))
// 				_map11.Add(MakeKeyword("Renegotiation"), (*(*(*_res).Config).TLSConfig).Renegotiation)
// 				_map11.Add(MakeKeyword("KeyLogWriter"), (*(*(*_res).Config).TLSConfig).KeyLogWriter)
// 				_obj_map11 = Object(_map11)
// 			} else {
// 				_obj_map11 = NIL
// 			}
// 			_map10.Add(MakeKeyword("TLSConfig"), _obj_map11)
// 			_map10.Add(MakeKeyword("ReadTimeout"), MakeInt(int((*(*_res).Config).ReadTimeout)))
// 			_map10.Add(MakeKeyword("ReadHeaderTimeout"), MakeInt(int((*(*_res).Config).ReadHeaderTimeout)))
// 			_map10.Add(MakeKeyword("WriteTimeout"), MakeInt(int((*(*_res).Config).WriteTimeout)))
// 			_map10.Add(MakeKeyword("IdleTimeout"), MakeInt(int((*(*_res).Config).IdleTimeout)))
// 			_map10.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map10.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map10.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map10.Add(MakeKeyword("ErrorLog"), NIL)
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map10)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewTLSServer:
// func newTLSServer(handler net/http.Handler) Object {
// 	_res := _httptest.NewTLSServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		var _obj_map2 Object
// 		if (*_res).TLS != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Rand"), (*(*_res).TLS).Rand)
// 			_map2.Add(MakeKeyword("Time"), (*(*_res).TLS).Time)
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*(*_res).TLS).Certificates {
// 				_vec3 = _vec3.Conjoin(_elem3)
// 			}
// 			_map2.Add(MakeKeyword("Certificates"), _vec3)
// 			_map2.Add(MakeKeyword("NameToCertificate"), (*(*_res).TLS).NameToCertificate)
// 			_map2.Add(MakeKeyword("GetCertificate"), (*(*_res).TLS).GetCertificate)
// 			_map2.Add(MakeKeyword("GetClientCertificate"), (*(*_res).TLS).GetClientCertificate)
// 			_map2.Add(MakeKeyword("GetConfigForClient"), (*(*_res).TLS).GetConfigForClient)
// 			_map2.Add(MakeKeyword("VerifyPeerCertificate"), (*(*_res).TLS).VerifyPeerCertificate)
// 			_map2.Add(MakeKeyword("RootCAs"), NIL)
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res).TLS).NextProtos {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map2.Add(MakeKeyword("NextProtos"), _vec5)
// 			_map2.Add(MakeKeyword("ServerName"), MakeString((*(*_res).TLS).ServerName))
// 			_map2.Add(MakeKeyword("ClientAuth"), (*(*_res).TLS).ClientAuth)
// 			_map2.Add(MakeKeyword("ClientCAs"), NIL)
// 			_map2.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*_res).TLS).InsecureSkipVerify))
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*(*_res).TLS).CipherSuites {
// 				_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 			}
// 			_map2.Add(MakeKeyword("CipherSuites"), _vec7)
// 			_map2.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*_res).TLS).PreferServerCipherSuites))
// 			_map2.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*_res).TLS).SessionTicketsDisabled))
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res).TLS).SessionTicketKey {
// 				_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 			}
// 			_map2.Add(MakeKeyword("SessionTicketKey"), _vec8)
// 			_map2.Add(MakeKeyword("ClientSessionCache"), (*(*_res).TLS).ClientSessionCache)
// 			_map2.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*_res).TLS).MinVersion)))
// 			_map2.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*_res).TLS).MaxVersion)))
// 			_vec9 := EmptyVector
// 			for _, _elem9 := range (*(*_res).TLS).CurvePreferences {
// 				_vec9 = _vec9.Conjoin(_elem9)
// 			}
// 			_map2.Add(MakeKeyword("CurvePreferences"), _vec9)
// 			_map2.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*_res).TLS).DynamicRecordSizingDisabled))
// 			_map2.Add(MakeKeyword("Renegotiation"), (*(*_res).TLS).Renegotiation)
// 			_map2.Add(MakeKeyword("KeyLogWriter"), (*(*_res).TLS).KeyLogWriter)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map2)
// 		var _obj_map10 Object
// 		if (*_res).Config != nil {
// 			_map10 := EmptyArrayMap()
// 			_map10.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map10.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			var _obj_map11 Object
// 			if (*(*_res).Config).TLSConfig != nil {
// 				_map11 := EmptyArrayMap()
// 				_map11.Add(MakeKeyword("Rand"), (*(*(*_res).Config).TLSConfig).Rand)
// 				_map11.Add(MakeKeyword("Time"), (*(*(*_res).Config).TLSConfig).Time)
// 				_vec12 := EmptyVector
// 				for _, _elem12 := range (*(*(*_res).Config).TLSConfig).Certificates {
// 					_vec12 = _vec12.Conjoin(_elem12)
// 				}
// 				_map11.Add(MakeKeyword("Certificates"), _vec12)
// 				_map11.Add(MakeKeyword("NameToCertificate"), (*(*(*_res).Config).TLSConfig).NameToCertificate)
// 				_map11.Add(MakeKeyword("GetCertificate"), (*(*(*_res).Config).TLSConfig).GetCertificate)
// 				_map11.Add(MakeKeyword("GetClientCertificate"), (*(*(*_res).Config).TLSConfig).GetClientCertificate)
// 				_map11.Add(MakeKeyword("GetConfigForClient"), (*(*(*_res).Config).TLSConfig).GetConfigForClient)
// 				_map11.Add(MakeKeyword("VerifyPeerCertificate"), (*(*(*_res).Config).TLSConfig).VerifyPeerCertificate)
// 				_map11.Add(MakeKeyword("RootCAs"), NIL)
// 				_vec14 := EmptyVector
// 				for _, _elem14 := range (*(*(*_res).Config).TLSConfig).NextProtos {
// 					_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 				}
// 				_map11.Add(MakeKeyword("NextProtos"), _vec14)
// 				_map11.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res).Config).TLSConfig).ServerName))
// 				_map11.Add(MakeKeyword("ClientAuth"), (*(*(*_res).Config).TLSConfig).ClientAuth)
// 				_map11.Add(MakeKeyword("ClientCAs"), NIL)
// 				_map11.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*(*_res).Config).TLSConfig).InsecureSkipVerify))
// 				_vec16 := EmptyVector
// 				for _, _elem16 := range (*(*(*_res).Config).TLSConfig).CipherSuites {
// 					_vec16 = _vec16.Conjoin(MakeInt(int(_elem16)))
// 				}
// 				_map11.Add(MakeKeyword("CipherSuites"), _vec16)
// 				_map11.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*(*_res).Config).TLSConfig).PreferServerCipherSuites))
// 				_map11.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).SessionTicketsDisabled))
// 				_vec17 := EmptyVector
// 				for _, _elem17 := range (*(*(*_res).Config).TLSConfig).SessionTicketKey {
// 					_vec17 = _vec17.Conjoin(MakeInt(int(_elem17)))
// 				}
// 				_map11.Add(MakeKeyword("SessionTicketKey"), _vec17)
// 				_map11.Add(MakeKeyword("ClientSessionCache"), (*(*(*_res).Config).TLSConfig).ClientSessionCache)
// 				_map11.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MinVersion)))
// 				_map11.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MaxVersion)))
// 				_vec18 := EmptyVector
// 				for _, _elem18 := range (*(*(*_res).Config).TLSConfig).CurvePreferences {
// 					_vec18 = _vec18.Conjoin(_elem18)
// 				}
// 				_map11.Add(MakeKeyword("CurvePreferences"), _vec18)
// 				_map11.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).DynamicRecordSizingDisabled))
// 				_map11.Add(MakeKeyword("Renegotiation"), (*(*(*_res).Config).TLSConfig).Renegotiation)
// 				_map11.Add(MakeKeyword("KeyLogWriter"), (*(*(*_res).Config).TLSConfig).KeyLogWriter)
// 				_obj_map11 = Object(_map11)
// 			} else {
// 				_obj_map11 = NIL
// 			}
// 			_map10.Add(MakeKeyword("TLSConfig"), _obj_map11)
// 			_map10.Add(MakeKeyword("ReadTimeout"), MakeInt(int((*(*_res).Config).ReadTimeout)))
// 			_map10.Add(MakeKeyword("ReadHeaderTimeout"), MakeInt(int((*(*_res).Config).ReadHeaderTimeout)))
// 			_map10.Add(MakeKeyword("WriteTimeout"), MakeInt(int((*(*_res).Config).WriteTimeout)))
// 			_map10.Add(MakeKeyword("IdleTimeout"), MakeInt(int((*(*_res).Config).IdleTimeout)))
// 			_map10.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map10.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map10.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map10.Add(MakeKeyword("ErrorLog"), NIL)
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map10)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptest.NewUnstartedServer:
// func newUnstartedServer(handler net/http.Handler) Object {
// 	_res := _httptest.NewUnstartedServer(handler)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("URL"), MakeString((*_res).URL))
// 		_map1.Add(MakeKeyword("Listener"), (*_res).Listener)
// 		var _obj_map2 Object
// 		if (*_res).TLS != nil {
// 			_map2 := EmptyArrayMap()
// 			_map2.Add(MakeKeyword("Rand"), (*(*_res).TLS).Rand)
// 			_map2.Add(MakeKeyword("Time"), (*(*_res).TLS).Time)
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*(*_res).TLS).Certificates {
// 				_vec3 = _vec3.Conjoin(_elem3)
// 			}
// 			_map2.Add(MakeKeyword("Certificates"), _vec3)
// 			_map2.Add(MakeKeyword("NameToCertificate"), (*(*_res).TLS).NameToCertificate)
// 			_map2.Add(MakeKeyword("GetCertificate"), (*(*_res).TLS).GetCertificate)
// 			_map2.Add(MakeKeyword("GetClientCertificate"), (*(*_res).TLS).GetClientCertificate)
// 			_map2.Add(MakeKeyword("GetConfigForClient"), (*(*_res).TLS).GetConfigForClient)
// 			_map2.Add(MakeKeyword("VerifyPeerCertificate"), (*(*_res).TLS).VerifyPeerCertificate)
// 			_map2.Add(MakeKeyword("RootCAs"), NIL)
// 			_vec5 := EmptyVector
// 			for _, _elem5 := range (*(*_res).TLS).NextProtos {
// 				_vec5 = _vec5.Conjoin(MakeString(_elem5))
// 			}
// 			_map2.Add(MakeKeyword("NextProtos"), _vec5)
// 			_map2.Add(MakeKeyword("ServerName"), MakeString((*(*_res).TLS).ServerName))
// 			_map2.Add(MakeKeyword("ClientAuth"), (*(*_res).TLS).ClientAuth)
// 			_map2.Add(MakeKeyword("ClientCAs"), NIL)
// 			_map2.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*_res).TLS).InsecureSkipVerify))
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*(*_res).TLS).CipherSuites {
// 				_vec7 = _vec7.Conjoin(MakeInt(int(_elem7)))
// 			}
// 			_map2.Add(MakeKeyword("CipherSuites"), _vec7)
// 			_map2.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*_res).TLS).PreferServerCipherSuites))
// 			_map2.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*_res).TLS).SessionTicketsDisabled))
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res).TLS).SessionTicketKey {
// 				_vec8 = _vec8.Conjoin(MakeInt(int(_elem8)))
// 			}
// 			_map2.Add(MakeKeyword("SessionTicketKey"), _vec8)
// 			_map2.Add(MakeKeyword("ClientSessionCache"), (*(*_res).TLS).ClientSessionCache)
// 			_map2.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*_res).TLS).MinVersion)))
// 			_map2.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*_res).TLS).MaxVersion)))
// 			_vec9 := EmptyVector
// 			for _, _elem9 := range (*(*_res).TLS).CurvePreferences {
// 				_vec9 = _vec9.Conjoin(_elem9)
// 			}
// 			_map2.Add(MakeKeyword("CurvePreferences"), _vec9)
// 			_map2.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*_res).TLS).DynamicRecordSizingDisabled))
// 			_map2.Add(MakeKeyword("Renegotiation"), (*(*_res).TLS).Renegotiation)
// 			_map2.Add(MakeKeyword("KeyLogWriter"), (*(*_res).TLS).KeyLogWriter)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("TLS"), _obj_map2)
// 		var _obj_map10 Object
// 		if (*_res).Config != nil {
// 			_map10 := EmptyArrayMap()
// 			_map10.Add(MakeKeyword("Addr"), MakeString((*(*_res).Config).Addr))
// 			_map10.Add(MakeKeyword("Handler"), (*(*_res).Config).Handler)
// 			var _obj_map11 Object
// 			if (*(*_res).Config).TLSConfig != nil {
// 				_map11 := EmptyArrayMap()
// 				_map11.Add(MakeKeyword("Rand"), (*(*(*_res).Config).TLSConfig).Rand)
// 				_map11.Add(MakeKeyword("Time"), (*(*(*_res).Config).TLSConfig).Time)
// 				_vec12 := EmptyVector
// 				for _, _elem12 := range (*(*(*_res).Config).TLSConfig).Certificates {
// 					_vec12 = _vec12.Conjoin(_elem12)
// 				}
// 				_map11.Add(MakeKeyword("Certificates"), _vec12)
// 				_map11.Add(MakeKeyword("NameToCertificate"), (*(*(*_res).Config).TLSConfig).NameToCertificate)
// 				_map11.Add(MakeKeyword("GetCertificate"), (*(*(*_res).Config).TLSConfig).GetCertificate)
// 				_map11.Add(MakeKeyword("GetClientCertificate"), (*(*(*_res).Config).TLSConfig).GetClientCertificate)
// 				_map11.Add(MakeKeyword("GetConfigForClient"), (*(*(*_res).Config).TLSConfig).GetConfigForClient)
// 				_map11.Add(MakeKeyword("VerifyPeerCertificate"), (*(*(*_res).Config).TLSConfig).VerifyPeerCertificate)
// 				_map11.Add(MakeKeyword("RootCAs"), NIL)
// 				_vec14 := EmptyVector
// 				for _, _elem14 := range (*(*(*_res).Config).TLSConfig).NextProtos {
// 					_vec14 = _vec14.Conjoin(MakeString(_elem14))
// 				}
// 				_map11.Add(MakeKeyword("NextProtos"), _vec14)
// 				_map11.Add(MakeKeyword("ServerName"), MakeString((*(*(*_res).Config).TLSConfig).ServerName))
// 				_map11.Add(MakeKeyword("ClientAuth"), (*(*(*_res).Config).TLSConfig).ClientAuth)
// 				_map11.Add(MakeKeyword("ClientCAs"), NIL)
// 				_map11.Add(MakeKeyword("InsecureSkipVerify"), MakeBool((*(*(*_res).Config).TLSConfig).InsecureSkipVerify))
// 				_vec16 := EmptyVector
// 				for _, _elem16 := range (*(*(*_res).Config).TLSConfig).CipherSuites {
// 					_vec16 = _vec16.Conjoin(MakeInt(int(_elem16)))
// 				}
// 				_map11.Add(MakeKeyword("CipherSuites"), _vec16)
// 				_map11.Add(MakeKeyword("PreferServerCipherSuites"), MakeBool((*(*(*_res).Config).TLSConfig).PreferServerCipherSuites))
// 				_map11.Add(MakeKeyword("SessionTicketsDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).SessionTicketsDisabled))
// 				_vec17 := EmptyVector
// 				for _, _elem17 := range (*(*(*_res).Config).TLSConfig).SessionTicketKey {
// 					_vec17 = _vec17.Conjoin(MakeInt(int(_elem17)))
// 				}
// 				_map11.Add(MakeKeyword("SessionTicketKey"), _vec17)
// 				_map11.Add(MakeKeyword("ClientSessionCache"), (*(*(*_res).Config).TLSConfig).ClientSessionCache)
// 				_map11.Add(MakeKeyword("MinVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MinVersion)))
// 				_map11.Add(MakeKeyword("MaxVersion"), MakeInt(int((*(*(*_res).Config).TLSConfig).MaxVersion)))
// 				_vec18 := EmptyVector
// 				for _, _elem18 := range (*(*(*_res).Config).TLSConfig).CurvePreferences {
// 					_vec18 = _vec18.Conjoin(_elem18)
// 				}
// 				_map11.Add(MakeKeyword("CurvePreferences"), _vec18)
// 				_map11.Add(MakeKeyword("DynamicRecordSizingDisabled"), MakeBool((*(*(*_res).Config).TLSConfig).DynamicRecordSizingDisabled))
// 				_map11.Add(MakeKeyword("Renegotiation"), (*(*(*_res).Config).TLSConfig).Renegotiation)
// 				_map11.Add(MakeKeyword("KeyLogWriter"), (*(*(*_res).Config).TLSConfig).KeyLogWriter)
// 				_obj_map11 = Object(_map11)
// 			} else {
// 				_obj_map11 = NIL
// 			}
// 			_map10.Add(MakeKeyword("TLSConfig"), _obj_map11)
// 			_map10.Add(MakeKeyword("ReadTimeout"), MakeInt(int((*(*_res).Config).ReadTimeout)))
// 			_map10.Add(MakeKeyword("ReadHeaderTimeout"), MakeInt(int((*(*_res).Config).ReadHeaderTimeout)))
// 			_map10.Add(MakeKeyword("WriteTimeout"), MakeInt(int((*(*_res).Config).WriteTimeout)))
// 			_map10.Add(MakeKeyword("IdleTimeout"), MakeInt(int((*(*_res).Config).IdleTimeout)))
// 			_map10.Add(MakeKeyword("MaxHeaderBytes"), MakeInt((*(*_res).Config).MaxHeaderBytes))
// 			_map10.Add(MakeKeyword("TLSNextProto"), (*(*_res).Config).TLSNextProto)
// 			_map10.Add(MakeKeyword("ConnState"), (*(*_res).Config).ConnState)
// 			_map10.Add(MakeKeyword("ErrorLog"), NIL)
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Config"), _obj_map10)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptrace.ContextClientTrace:
// func contextClientTrace(ctx context.Context) Object {
// 	_res := _httptrace.ContextClientTrace(ctx)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("GetConn"), (*_res).GetConn)
// 		_map1.Add(MakeKeyword("GotConn"), (*_res).GotConn)
// 		_map1.Add(MakeKeyword("PutIdleConn"), (*_res).PutIdleConn)
// 		_map1.Add(MakeKeyword("GotFirstResponseByte"), (*_res).GotFirstResponseByte)
// 		_map1.Add(MakeKeyword("Got100Continue"), (*_res).Got100Continue)
// 		_map1.Add(MakeKeyword("Got1xxResponse"), (*_res).Got1xxResponse)
// 		_map1.Add(MakeKeyword("DNSStart"), (*_res).DNSStart)
// 		_map1.Add(MakeKeyword("DNSDone"), (*_res).DNSDone)
// 		_map1.Add(MakeKeyword("ConnectStart"), (*_res).ConnectStart)
// 		_map1.Add(MakeKeyword("ConnectDone"), (*_res).ConnectDone)
// 		_map1.Add(MakeKeyword("TLSHandshakeStart"), (*_res).TLSHandshakeStart)
// 		_map1.Add(MakeKeyword("TLSHandshakeDone"), (*_res).TLSHandshakeDone)
// 		_map1.Add(MakeKeyword("WroteHeaderField"), (*_res).WroteHeaderField)
// 		_map1.Add(MakeKeyword("WroteHeaders"), (*_res).WroteHeaders)
// 		_map1.Add(MakeKeyword("Wait100Continue"), (*_res).Wait100Continue)
// 		_map1.Add(MakeKeyword("WroteRequest"), (*_res).WroteRequest)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/httptrace.WithClientTrace:
// func withClientTrace(ctx context.Context, trace *net/http/httptrace.ClientTrace) Object {
// 	return _httptrace.WithClientTrace(ctx, trace)
// }

GO FUNC net/http/httputil.DumpRequest:
// func dumpRequest(req *net/http.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequest(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpRequestOut:
// func dumpRequestOut(req *net/http.Request, body bool) Object {
// 	_res1, _res2 := _httputil.DumpRequestOut(req, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.DumpResponse:
// func dumpResponse(resp *net/http.Response, body bool) Object {
// 	_res1, _res2 := _httputil.DumpResponse(resp, body)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/http/httputil.NewChunkedReader:
// func newChunkedReader(r io.Reader) Object {
// 	return _httputil.NewChunkedReader(r)
// }

GO FUNC net/http/httputil.NewChunkedWriter:
// func newChunkedWriter(w io.Writer) Object {
// 	return _httputil.NewChunkedWriter(w)
// }

GO FUNC net/http/httputil.NewClientConn:
// func newClientConn(c net.Conn, r *bufio.Reader) Object {
// 	return _httputil.NewClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewProxyClientConn:
// func newProxyClientConn(c net.Conn, r *bufio.Reader) Object {
// 	return _httputil.NewProxyClientConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewServerConn:
// func newServerConn(c net.Conn, r *bufio.Reader) Object {
// 	return _httputil.NewServerConn(c, r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/http/httputil.NewSingleHostReverseProxy:
// func newSingleHostReverseProxy(target *net/url.URL) Object {
// 	_res := _httputil.NewSingleHostReverseProxy(target)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Director"), (*_res).Director)
// 		_map1.Add(MakeKeyword("Transport"), (*_res).Transport)
// 		_map1.Add(MakeKeyword("FlushInterval"), MakeInt(int((*_res).FlushInterval)))
// 		_map1.Add(MakeKeyword("ErrorLog"), NIL)
// 		_map1.Add(MakeKeyword("BufferPool"), (*_res).BufferPool)
// 		_map1.Add(MakeKeyword("ModifyResponse"), (*_res).ModifyResponse)
// 		_map1.Add(MakeKeyword("ErrorHandler"), (*_res).ErrorHandler)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC net/http/pprof.Cmdline:
// func cmdline(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_pprof.Cmdline(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Handler:
// func handler(name string) Object {
// 	return _pprof.Handler(name)
// }

GO FUNC net/http/pprof.Index:
// func index(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_pprof.Index(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Profile:
// func profile(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_pprof.Profile(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Symbol:
// func symbol(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_pprof.Symbol(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/http/pprof.Trace:
// func trace(w net/http.ResponseWriter, r *net/http.Request) Object {
// 	_pprof.Trace(w, r)
// 	...ABEND675: TODO...
// }

GO FUNC net/mail.ParseAddress:
func parseAddress(address string) Object {
	_res1, _res2 := _mail.ParseAddress(address)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("Address"), MakeString((*_res1).Address))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseAddressList:
func parseAddressList(list string) Object {
	_res1, _res2 := _mail.ParseAddressList(list)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		var _obj_map2 Object
		if _elem1 != nil {
			_map2 := EmptyArrayMap()
			_map2.Add(MakeKeyword("Name"), MakeString((*_elem1).Name))
			_map2.Add(MakeKeyword("Address"), MakeString((*_elem1).Address))
			_obj_map2 = Object(_map2)
		} else {
			_obj_map2 = NIL
		}
		_vec1 = _vec1.Conjoin(_obj_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ParseDate:
func parseDate(date string) Object {
	_, _res2 := _mail.ParseDate(date)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/mail.ReadMessage:
// func readMessage(r io.Reader) Object {
// 	msg, err := _mail.ReadMessage(r)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if msg != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Header"), (*msg).Header)
// 		_map1.Add(MakeKeyword("Body"), (*msg).Body)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC net/rpc.Accept:
// func accept(lis net.Listener) Object {
// 	_rpc.Accept(lis)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.Dial:
func dial(network string, address string) Object {
	_, _res2 := _rpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTP:
func dialHTTP(network string, address string) Object {
	_, _res2 := _rpc.DialHTTP(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.DialHTTPPath:
func dialHTTPPath(network string, address string, path string) Object {
	_, _res2 := _rpc.DialHTTPPath(network, address, path)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc.HandleHTTP:
// func handleHTTP() Object {
// 	_rpc.HandleHTTP()
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.NewClient:
// func newClient(conn io.ReadWriteCloser) Object {
// 	return _rpc.NewClient(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.NewClientWithCodec:
// func newClientWithCodec(codec net/rpc.ClientCodec) Object {
// 	return _rpc.NewClientWithCodec(codec)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.NewServer:
// func newServer() Object {
// 	return _rpc.NewServer()
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc.ServeCodec:
// func serveCodec(codec net/rpc.ServerCodec) Object {
// 	_rpc.ServeCodec(codec)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc.ServeConn:
// func serveConn(conn io.ReadWriteCloser) Object {
// 	_rpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/rpc/jsonrpc.Dial:
func dial(network string, address string) Object {
	_, _res2 := _jsonrpc.Dial(network, address)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/rpc/jsonrpc.NewClient:
// func newClient(conn io.ReadWriteCloser) Object {
// 	return _jsonrpc.NewClient(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/rpc/jsonrpc.NewClientCodec:
// func newClientCodec(conn io.ReadWriteCloser) Object {
// 	return _jsonrpc.NewClientCodec(conn)
// }

GO FUNC net/rpc/jsonrpc.NewServerCodec:
// func newServerCodec(conn io.ReadWriteCloser) Object {
// 	return _jsonrpc.NewServerCodec(conn)
// }

GO FUNC net/rpc/jsonrpc.ServeConn:
// func serveConn(conn io.ReadWriteCloser) Object {
// 	_jsonrpc.ServeConn(conn)
// 	...ABEND675: TODO...
// }

GO FUNC net/smtp.CRAMMD5Auth:
// func cRAMMD5Auth(username string, secret string) Object {
// 	return _smtp.CRAMMD5Auth(username, secret)
// }

GO FUNC net/smtp.Dial:
func dial(addr string) Object {
	_, _res2 := _smtp.Dial(addr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/smtp.NewClient:
// func newClient(conn net.Conn, host string) Object {
// 	_, _res2 := _smtp.NewClient(conn, host)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/smtp.PlainAuth:
// func plainAuth(identity string, username string, password string, host string) Object {
// 	return _smtp.PlainAuth(identity, username, password, host)
// }

GO FUNC net/textproto.Dial:
func dial(network string, addr string) Object {
	_, _res2 := _textproto.Dial(network, addr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/textproto.NewConn:
// func newConn(conn io.ReadWriteCloser) Object {
// 	return _textproto.NewConn(conn)
// 	ABEND124(no public information returned)
// }

GO FUNC net/textproto.NewReader:
// func newReader(r *bufio.Reader) Object {
// 	return _textproto.NewReader(r)
// 	ABEND124(no public information returned)
// }

GO FUNC net/textproto.NewWriter:
// func newWriter(w *bufio.Writer) Object {
// 	return _textproto.NewWriter(w)
// 	ABEND124(no public information returned)
// }

GO FUNC net/textproto.TrimBytes:
func trimBytes(b []byte) Object {
	_res := _textproto.TrimBytes(b)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC net/url.Parse:
func parse(rawurl string) Object {
	_res1, _res2 := _url.Parse(rawurl)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
		_map1.Add(MakeKeyword("User"), NIL)
		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.ParseQuery:
// func parseQuery(query string) Object {
// 	_res1, _res2 := _url.ParseQuery(query)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC net/url.ParseRequestURI:
func parseRequestURI(rawurl string) Object {
	_res1, _res2 := _url.ParseRequestURI(rawurl)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Scheme"), MakeString((*_res1).Scheme))
		_map1.Add(MakeKeyword("Opaque"), MakeString((*_res1).Opaque))
		_map1.Add(MakeKeyword("User"), NIL)
		_map1.Add(MakeKeyword("Host"), MakeString((*_res1).Host))
		_map1.Add(MakeKeyword("Path"), MakeString((*_res1).Path))
		_map1.Add(MakeKeyword("RawPath"), MakeString((*_res1).RawPath))
		_map1.Add(MakeKeyword("ForceQuery"), MakeBool((*_res1).ForceQuery))
		_map1.Add(MakeKeyword("RawQuery"), MakeString((*_res1).RawQuery))
		_map1.Add(MakeKeyword("Fragment"), MakeString((*_res1).Fragment))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.PathUnescape:
func pathUnescape(s string) Object {
	_res1, _res2 := _url.PathUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.QueryUnescape:
func queryUnescape(s string) Object {
	_res1, _res2 := _url.QueryUnescape(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC net/url.User:
// func user(username string) Object {
// 	return _url.User(username)
// 	ABEND124(no public information returned)
// }

GO FUNC net/url.UserPassword:
// func userPassword(username string, password string) Object {
// 	return _url.UserPassword(username, password)
// 	ABEND124(no public information returned)
// }

GO FUNC os.Clearenv:
// func clearenv() Object {
// 	_os.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC os.Create:
func create(name string) Object {
	_, _res2 := _os.Create(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Environ:
func environ() Object {
	_res := _os.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC os.Executable:
func executable() Object {
	_res1, _res2 := _os.Executable()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Exit:
// func exit(code int) Object {
// 	_os.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC os.FindProcess:
func findProcess(pid int) Object {
	_res1, _res2 := _os.FindProcess(pid)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Pid"), MakeInt((*_res1).Pid))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getgroups:
func getgroups() Object {
	_res1, _res2 := _os.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.Getwd:
func getwd() Object {
	dir, err := _os.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Hostname:
func hostname() Object {
	name, err := _os.Hostname()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(name))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.LookupEnv:
func lookupEnv(key string) Object {
	_res1, _res2 := _os.LookupEnv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(MakeBool(_res2))
	return _res
}

GO FUNC os.Lstat:
// func lstat(name string) Object {
// 	_res1, _res2 := _os.Lstat(name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.NewFile:
// func newFile(fd uintptr, name string) Object {
// 	return _os.NewFile(fd, name)
// 	ABEND124(no public information returned)
// }

GO FUNC os.Open:
func open(name string) Object {
	_, _res2 := _os.Open(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.OpenFile:
// func openFile(name string, flag int, perm os.FileMode) Object {
// 	_, _res2 := _os.OpenFile(name, flag, perm)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.Pipe:
func pipe() Object {
	_, _, err := _os.Pipe()
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC os.Readlink:
func readlink(name string) Object {
	_res1, _res2 := _os.Readlink(name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os.StartProcess:
// func startProcess(name string, argv []string, attr *os.ProcAttr) Object {
// 	_res1, _res2 := _os.StartProcess(name, argv, attr)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Pid"), MakeInt((*_res1).Pid))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.Stat:
// func stat(name string) Object {
// 	_res1, _res2 := _os.Stat(name)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC os.UserCacheDir:
func userCacheDir() Object {
	_res1, _res2 := _os.UserCacheDir()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/exec.Command:
// func command(name string, arg ...string) Object {
// 	_res := _exec.Command(name, arg)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Path"), MakeString((*_res).Path))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Args {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("Args"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).Env {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("Env"), _vec3)
// 		_map1.Add(MakeKeyword("Dir"), MakeString((*_res).Dir))
// 		_map1.Add(MakeKeyword("Stdin"), (*_res).Stdin)
// 		_map1.Add(MakeKeyword("Stdout"), (*_res).Stdout)
// 		_map1.Add(MakeKeyword("Stderr"), (*_res).Stderr)
// 		_map1.Add(MakeKeyword("ExtraFiles"), NIL)
// 		var _obj_map6 Object
// 		if (*_res).SysProcAttr != nil {
// 			_map6 := EmptyArrayMap()
// 			_map6.Add(MakeKeyword("Chroot"), MakeString((*(*_res).SysProcAttr).Chroot))
// 			_map6.Add(MakeKeyword("Credential"), (*(*(*_res).SysProcAttr).Credential))
// 			_map6.Add(MakeKeyword("Ptrace"), MakeBool((*(*_res).SysProcAttr).Ptrace))
// 			_map6.Add(MakeKeyword("Setsid"), MakeBool((*(*_res).SysProcAttr).Setsid))
// 			_map6.Add(MakeKeyword("Setpgid"), MakeBool((*(*_res).SysProcAttr).Setpgid))
// 			_map6.Add(MakeKeyword("Setctty"), MakeBool((*(*_res).SysProcAttr).Setctty))
// 			_map6.Add(MakeKeyword("Noctty"), MakeBool((*(*_res).SysProcAttr).Noctty))
// 			_map6.Add(MakeKeyword("Ctty"), MakeInt((*(*_res).SysProcAttr).Ctty))
// 			_map6.Add(MakeKeyword("Foreground"), MakeBool((*(*_res).SysProcAttr).Foreground))
// 			_map6.Add(MakeKeyword("Pgid"), MakeInt((*(*_res).SysProcAttr).Pgid))
// 			_map6.Add(MakeKeyword("Pdeathsig"), (*(*_res).SysProcAttr).Pdeathsig)
// 			_map6.Add(MakeKeyword("Cloneflags"), (*(*_res).SysProcAttr).Cloneflags)
// 			_map6.Add(MakeKeyword("Unshareflags"), (*(*_res).SysProcAttr).Unshareflags)
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*(*_res).SysProcAttr).UidMappings {
// 				_vec7 = _vec7.Conjoin(_elem7)
// 			}
// 			_map6.Add(MakeKeyword("UidMappings"), _vec7)
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res).SysProcAttr).GidMappings {
// 				_vec8 = _vec8.Conjoin(_elem8)
// 			}
// 			_map6.Add(MakeKeyword("GidMappings"), _vec8)
// 			_map6.Add(MakeKeyword("GidMappingsEnableSetgroups"), MakeBool((*(*_res).SysProcAttr).GidMappingsEnableSetgroups))
// 			_vec9 := EmptyVector
// 			for _, _elem9 := range (*(*_res).SysProcAttr).AmbientCaps {
// 				_vec9 = _vec9.Conjoin(_elem9)
// 			}
// 			_map6.Add(MakeKeyword("AmbientCaps"), _vec9)
// 			_obj_map6 = Object(_map6)
// 		} else {
// 			_obj_map6 = NIL
// 		}
// 		_map1.Add(MakeKeyword("SysProcAttr"), _obj_map6)
// 		var _obj_map10 Object
// 		if (*_res).Process != nil {
// 			_map10 := EmptyArrayMap()
// 			_map10.Add(MakeKeyword("Pid"), MakeInt((*(*_res).Process).Pid))
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Process"), _obj_map10)
// 		_map1.Add(MakeKeyword("ProcessState"), NIL)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC os/exec.CommandContext:
// func commandContext(ctx context.Context, name string, arg ...string) Object {
// 	_res := _exec.CommandContext(ctx, name, arg)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Path"), MakeString((*_res).Path))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res).Args {
// 			_vec2 = _vec2.Conjoin(MakeString(_elem2))
// 		}
// 		_map1.Add(MakeKeyword("Args"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res).Env {
// 			_vec3 = _vec3.Conjoin(MakeString(_elem3))
// 		}
// 		_map1.Add(MakeKeyword("Env"), _vec3)
// 		_map1.Add(MakeKeyword("Dir"), MakeString((*_res).Dir))
// 		_map1.Add(MakeKeyword("Stdin"), (*_res).Stdin)
// 		_map1.Add(MakeKeyword("Stdout"), (*_res).Stdout)
// 		_map1.Add(MakeKeyword("Stderr"), (*_res).Stderr)
// 		_map1.Add(MakeKeyword("ExtraFiles"), NIL)
// 		var _obj_map6 Object
// 		if (*_res).SysProcAttr != nil {
// 			_map6 := EmptyArrayMap()
// 			_map6.Add(MakeKeyword("Chroot"), MakeString((*(*_res).SysProcAttr).Chroot))
// 			_map6.Add(MakeKeyword("Credential"), (*(*(*_res).SysProcAttr).Credential))
// 			_map6.Add(MakeKeyword("Ptrace"), MakeBool((*(*_res).SysProcAttr).Ptrace))
// 			_map6.Add(MakeKeyword("Setsid"), MakeBool((*(*_res).SysProcAttr).Setsid))
// 			_map6.Add(MakeKeyword("Setpgid"), MakeBool((*(*_res).SysProcAttr).Setpgid))
// 			_map6.Add(MakeKeyword("Setctty"), MakeBool((*(*_res).SysProcAttr).Setctty))
// 			_map6.Add(MakeKeyword("Noctty"), MakeBool((*(*_res).SysProcAttr).Noctty))
// 			_map6.Add(MakeKeyword("Ctty"), MakeInt((*(*_res).SysProcAttr).Ctty))
// 			_map6.Add(MakeKeyword("Foreground"), MakeBool((*(*_res).SysProcAttr).Foreground))
// 			_map6.Add(MakeKeyword("Pgid"), MakeInt((*(*_res).SysProcAttr).Pgid))
// 			_map6.Add(MakeKeyword("Pdeathsig"), (*(*_res).SysProcAttr).Pdeathsig)
// 			_map6.Add(MakeKeyword("Cloneflags"), (*(*_res).SysProcAttr).Cloneflags)
// 			_map6.Add(MakeKeyword("Unshareflags"), (*(*_res).SysProcAttr).Unshareflags)
// 			_vec7 := EmptyVector
// 			for _, _elem7 := range (*(*_res).SysProcAttr).UidMappings {
// 				_vec7 = _vec7.Conjoin(_elem7)
// 			}
// 			_map6.Add(MakeKeyword("UidMappings"), _vec7)
// 			_vec8 := EmptyVector
// 			for _, _elem8 := range (*(*_res).SysProcAttr).GidMappings {
// 				_vec8 = _vec8.Conjoin(_elem8)
// 			}
// 			_map6.Add(MakeKeyword("GidMappings"), _vec8)
// 			_map6.Add(MakeKeyword("GidMappingsEnableSetgroups"), MakeBool((*(*_res).SysProcAttr).GidMappingsEnableSetgroups))
// 			_vec9 := EmptyVector
// 			for _, _elem9 := range (*(*_res).SysProcAttr).AmbientCaps {
// 				_vec9 = _vec9.Conjoin(_elem9)
// 			}
// 			_map6.Add(MakeKeyword("AmbientCaps"), _vec9)
// 			_obj_map6 = Object(_map6)
// 		} else {
// 			_obj_map6 = NIL
// 		}
// 		_map1.Add(MakeKeyword("SysProcAttr"), _obj_map6)
// 		var _obj_map10 Object
// 		if (*_res).Process != nil {
// 			_map10 := EmptyArrayMap()
// 			_map10.Add(MakeKeyword("Pid"), MakeInt((*(*_res).Process).Pid))
// 			_obj_map10 = Object(_map10)
// 		} else {
// 			_obj_map10 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Process"), _obj_map10)
// 		_map1.Add(MakeKeyword("ProcessState"), NIL)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC os/exec.LookPath:
func lookPath(file string) Object {
	_res1, _res2 := _exec.LookPath(file)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/signal.Ignore:
// func ignore(sig ...os.Signal) Object {
// 	_signal.Ignore(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Notify:
// func notify(c <-chan, sig ...os.Signal) Object {
// 	_signal.Notify(c, sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Reset:
// func reset(sig ...os.Signal) Object {
// 	_signal.Reset(sig)
// 	...ABEND675: TODO...
// }

GO FUNC os/signal.Stop:
// func stop(c <-chan) Object {
// 	_signal.Stop(c)
// 	...ABEND675: TODO...
// }

GO FUNC os/user.Current:
func current() Object {
	_res1, _res2 := _user.Current()
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Uid"), MakeString((*_res1).Uid))
		_map1.Add(MakeKeyword("Gid"), MakeString((*_res1).Gid))
		_map1.Add(MakeKeyword("Username"), MakeString((*_res1).Username))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("HomeDir"), MakeString((*_res1).HomeDir))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.Lookup:
func lookup(username string) Object {
	_res1, _res2 := _user.Lookup(username)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Uid"), MakeString((*_res1).Uid))
		_map1.Add(MakeKeyword("Gid"), MakeString((*_res1).Gid))
		_map1.Add(MakeKeyword("Username"), MakeString((*_res1).Username))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("HomeDir"), MakeString((*_res1).HomeDir))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroup:
func lookupGroup(name string) Object {
	_res1, _res2 := _user.LookupGroup(name)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Gid"), MakeString((*_res1).Gid))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupGroupId:
func lookupGroupId(gid string) Object {
	_res1, _res2 := _user.LookupGroupId(gid)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Gid"), MakeString((*_res1).Gid))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC os/user.LookupId:
func lookupId(uid string) Object {
	_res1, _res2 := _user.LookupId(uid)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Uid"), MakeString((*_res1).Uid))
		_map1.Add(MakeKeyword("Gid"), MakeString((*_res1).Gid))
		_map1.Add(MakeKeyword("Username"), MakeString((*_res1).Username))
		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
		_map1.Add(MakeKeyword("HomeDir"), MakeString((*_res1).HomeDir))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path.Match:
func match(pattern string, name string) Object {
	matched, err := _path.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path.Split:
func split(path string) Object {
	dir, file := _path.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

GO FUNC path/filepath.Abs:
func abs(path string) Object {
	_res1, _res2 := _filepath.Abs(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.EvalSymlinks:
func evalSymlinks(path string) Object {
	_res1, _res2 := _filepath.EvalSymlinks(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Glob:
func glob(pattern string) Object {
	matches, err := _filepath.Glob(pattern)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range matches {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Match:
func match(pattern string, name string) Object {
	matched, err := _filepath.Match(pattern, name)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC path/filepath.Rel:
func rel(basepath string, targpath string) Object {
	_res1, _res2 := _filepath.Rel(basepath, targpath)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC path/filepath.Split:
func split(path string) Object {
	dir, file := _filepath.Split(path)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(dir))
	_res = _res.Conjoin(MakeString(file))
	return _res
}

GO FUNC path/filepath.SplitList:
func splitList(path string) Object {
	_res := _filepath.SplitList(path)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC plugin.Open:
func open(path string) Object {
	_, _res2 := _plugin.Open(path)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC reflect.Append:
// func append(s reflect.Value, x ...reflect.Value) Object {
// 	return _reflect.Append(s, x)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.AppendSlice:
// func appendSlice(s reflect.Value, t reflect.Value) Object {
// 	return _reflect.AppendSlice(s, t)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.ArrayOf:
// func arrayOf(count int, elem reflect.Type) Object {
// 	return _reflect.ArrayOf(count, elem)
// }

GO FUNC reflect.ChanOf:
// func chanOf(dir reflect.ChanDir, t reflect.Type) Object {
// 	return _reflect.ChanOf(dir, t)
// }

GO FUNC reflect.FuncOf:
// func funcOf(in []reflect.Type, out []reflect.Type, variadic bool) Object {
// 	return _reflect.FuncOf(in, out, variadic)
// }

GO FUNC reflect.Indirect:
// func indirect(v reflect.Value) Object {
// 	return _reflect.Indirect(v)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeChan:
// func makeChan(typ reflect.Type, buffer int) Object {
// 	return _reflect.MakeChan(typ, buffer)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeFunc:
// func makeFunc(typ reflect.Type, fn func) Object {
// 	return _reflect.MakeFunc(typ, fn)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeMap:
// func makeMap(typ reflect.Type) Object {
// 	return _reflect.MakeMap(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeMapWithSize:
// func makeMapWithSize(typ reflect.Type, n int) Object {
// 	return _reflect.MakeMapWithSize(typ, n)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MakeSlice:
// func makeSlice(typ reflect.Type, len int, cap int) Object {
// 	return _reflect.MakeSlice(typ, len, cap)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.MapOf:
// func mapOf(key reflect.Type, elem reflect.Type) Object {
// 	return _reflect.MapOf(key, elem)
// }

GO FUNC reflect.New:
// func new(typ reflect.Type) Object {
// 	return _reflect.New(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.NewAt:
// func newAt(typ reflect.Type, p unsafe.Pointer) Object {
// 	return _reflect.NewAt(typ, p)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.PtrTo:
// func ptrTo(t reflect.Type) Object {
// 	return _reflect.PtrTo(t)
// }

GO FUNC reflect.Select:
// func select(cases []reflect.SelectCase) Object {
// 	chosen, _, recvOK := _reflect.Select(cases)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(chosen))
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(MakeBool(recvOK))
// 	return _res
// }

GO FUNC reflect.SliceOf:
// func sliceOf(t reflect.Type) Object {
// 	return _reflect.SliceOf(t)
// }

GO FUNC reflect.StructOf:
// func structOf(fields []reflect.StructField) Object {
// 	return _reflect.StructOf(fields)
// }

GO FUNC reflect.Swapper:
// func swapper(slice interface {}) Object {
// 	return _reflect.Swapper(slice)
// }

GO FUNC reflect.TypeOf:
// func typeOf(i interface {}) Object {
// 	return _reflect.TypeOf(i)
// }

GO FUNC reflect.ValueOf:
// func valueOf(i interface {}) Object {
// 	return _reflect.ValueOf(i)
// 	ABEND124(no public information returned)
// }

GO FUNC reflect.Zero:
// func zero(typ reflect.Type) Object {
// 	return _reflect.Zero(typ)
// 	ABEND124(no public information returned)
// }

GO FUNC regexp.Compile:
func compile(expr string) Object {
	_, _res2 := _regexp.Compile(expr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.CompilePOSIX:
func compilePOSIX(expr string) Object {
	_, _res2 := _regexp.CompilePOSIX(expr)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC regexp.Match:
func match(pattern string, b []byte) Object {
	matched, err := _regexp.Match(pattern, b)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC regexp.MatchReader:
// func matchReader(pattern string, r io.RuneReader) Object {
// 	matched, err := _regexp.MatchReader(pattern, r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(matched))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC regexp.MatchString:
func matchString(pattern string, s string) Object {
	matched, err := _regexp.MatchString(pattern, s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(matched))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC regexp.MustCompile:
// func mustCompile(str string) Object {
// 	return _regexp.MustCompile(str)
// 	ABEND124(no public information returned)
// }

GO FUNC regexp.MustCompilePOSIX:
// func mustCompilePOSIX(str string) Object {
// 	return _regexp.MustCompilePOSIX(str)
// 	ABEND124(no public information returned)
// }

GO FUNC regexp/syntax.Compile:
// func compile(re *regexp/syntax.Regexp) Object {
// 	_res1, _res2 := _syntax.Compile(re)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Inst {
// 			_map3 := EmptyArrayMap()
// 			_map3.Add(MakeKeyword("Op"), _elem2.Op)
// 			_map3.Add(MakeKeyword("Out"), MakeInt(int(_elem2.Out)))
// 			_map3.Add(MakeKeyword("Arg"), MakeInt(int(_elem2.Arg)))
// 			_vec4 := EmptyVector
// 			for _, _elem4 := range _elem2.Rune {
// 				_vec4 = _vec4.Conjoin(_elem4)
// 			}
// 			_map3.Add(MakeKeyword("Rune"), _vec4)
// 			_vec2 = _vec2.Conjoin(_map3)
// 		}
// 		_map1.Add(MakeKeyword("Inst"), _vec2)
// 		_map1.Add(MakeKeyword("Start"), MakeInt((*_res1).Start))
// 		_map1.Add(MakeKeyword("NumCap"), MakeInt((*_res1).NumCap))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC regexp/syntax.EmptyOpContext:
// func emptyOpContext(r1 rune, r2 rune) Object {
// 	return _syntax.EmptyOpContext(r1, r2)
// }

GO FUNC regexp/syntax.Parse:
// func parse(s string, flags regexp/syntax.Flags) Object {
// 	_res1, _res2 := _syntax.Parse(s, flags)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Op"), (*_res1).Op)
// 		_map1.Add(MakeKeyword("Flags"), MakeInt(int((*_res1).Flags)))
// 		_vec2 := EmptyVector
// 		for _, _elem2 := range (*_res1).Sub {
// 			_vec2 = _vec2.Conjoin()
// 		}
// 		_map1.Add(MakeKeyword("Sub"), _vec2)
// 		_vec3 := EmptyVector
// 		for _, _elem3 := range (*_res1).Sub0 {
// 			_vec3 = _vec3.Conjoin()
// 		}
// 		_map1.Add(MakeKeyword("Sub0"), _vec3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range (*_res1).Rune {
// 			_vec4 = _vec4.Conjoin(_elem4)
// 		}
// 		_map1.Add(MakeKeyword("Rune"), _vec4)
// 		_vec5 := EmptyVector
// 		for _, _elem5 := range (*_res1).Rune0 {
// 			_vec5 = _vec5.Conjoin(_elem5)
// 		}
// 		_map1.Add(MakeKeyword("Rune0"), _vec5)
// 		_map1.Add(MakeKeyword("Min"), MakeInt((*_res1).Min))
// 		_map1.Add(MakeKeyword("Max"), MakeInt((*_res1).Max))
// 		_map1.Add(MakeKeyword("Cap"), MakeInt((*_res1).Cap))
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res1).Name))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC runtime.BlockProfile:
// func blockProfile(p []runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.BlockProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.Breakpoint:
// func breakpoint() Object {
// 	_runtime.Breakpoint()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.CPUProfile:
func cPUProfile() Object {
	_res := _runtime.CPUProfile()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.Caller:
// func caller(skip int) Object {
// 	pc, file, line, ok := _runtime.Caller(skip)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(pc)
// 	_res = _res.Conjoin(MakeString(file))
// 	_res = _res.Conjoin(MakeInt(line))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.CallersFrames:
// func callersFrames(callers []uintptr) Object {
// 	return _runtime.CallersFrames(callers)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime.FuncForPC:
// func funcForPC(pc uintptr) Object {
// 	return _runtime.FuncForPC(pc)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime.GC:
// func gC() Object {
// 	_runtime.GC()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.Goexit:
// func goexit() Object {
// 	_runtime.Goexit()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.GoroutineProfile:
// func goroutineProfile(p []runtime.StackRecord) Object {
// 	n, ok := _runtime.GoroutineProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.Gosched:
// func gosched() Object {
// 	_runtime.Gosched()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.KeepAlive:
// func keepAlive(x interface {}) Object {
// 	_runtime.KeepAlive(x)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.LockOSThread:
// func lockOSThread() Object {
// 	_runtime.LockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.MemProfile:
// func memProfile(p []runtime.MemProfileRecord, inuseZero bool) Object {
// 	n, ok := _runtime.MemProfile(p, inuseZero)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.MutexProfile:
// func mutexProfile(p []runtime.BlockProfileRecord) Object {
// 	n, ok := _runtime.MutexProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.ReadMemStats:
// func readMemStats(m *runtime.MemStats) Object {
// 	_runtime.ReadMemStats(m)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ReadTrace:
func readTrace() Object {
	_res := _runtime.ReadTrace()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime.SetBlockProfileRate:
// func setBlockProfileRate(rate int) Object {
// 	_runtime.SetBlockProfileRate(rate)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCPUProfileRate:
// func setCPUProfileRate(hz int) Object {
// 	_runtime.SetCPUProfileRate(hz)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetCgoTraceback:
// func setCgoTraceback(version int, traceback unsafe.Pointer, context unsafe.Pointer, symbolizer unsafe.Pointer) Object {
// 	_runtime.SetCgoTraceback(version, traceback, context, symbolizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.SetFinalizer:
// func setFinalizer(obj interface {}, finalizer interface {}) Object {
// 	_runtime.SetFinalizer(obj, finalizer)
// 	...ABEND675: TODO...
// }

GO FUNC runtime.StopTrace:
// func stopTrace() Object {
// 	_runtime.StopTrace()
// 	...ABEND675: TODO...
// }

GO FUNC runtime.ThreadCreateProfile:
// func threadCreateProfile(p []runtime.StackRecord) Object {
// 	n, ok := _runtime.ThreadCreateProfile(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC runtime.UnlockOSThread:
// func unlockOSThread() Object {
// 	_runtime.UnlockOSThread()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.FreeOSMemory:
// func freeOSMemory() Object {
// 	_debug.FreeOSMemory()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.PrintStack:
// func printStack() Object {
// 	_debug.PrintStack()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.ReadGCStats:
// func readGCStats(stats *runtime/debug.GCStats) Object {
// 	_debug.ReadGCStats(stats)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.SetTraceback:
// func setTraceback(level string) Object {
// 	_debug.SetTraceback(level)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/debug.Stack:
func stack() Object {
	_res := _debug.Stack()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC runtime/debug.WriteHeapDump:
// func writeHeapDump(fd uintptr) Object {
// 	_debug.WriteHeapDump(fd)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.Do:
// func do(ctx context.Context, labels runtime/pprof.LabelSet, f func) Object {
// 	_pprof.Do(ctx, labels, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.ForLabels:
// func forLabels(ctx context.Context, f func) Object {
// 	_pprof.ForLabels(ctx, f)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.Label:
// func label(ctx context.Context, key string) Object {
// 	_res1, _res2 := _pprof.Label(ctx, key)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeString(_res1))
// 	_res = _res.Conjoin(MakeBool(_res2))
// 	return _res
// }

GO FUNC runtime/pprof.Labels:
// func labels(args ...string) Object {
// 	return _pprof.Labels(args)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime/pprof.Lookup:
// func lookup(name string) Object {
// 	return _pprof.Lookup(name)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime/pprof.NewProfile:
// func newProfile(name string) Object {
// 	return _pprof.NewProfile(name)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime/pprof.Profiles:
// func profiles() Object {
// 	return _pprof.Profiles()
// 	ABEND124(no public information returned)
// }

GO FUNC runtime/pprof.SetGoroutineLabels:
// func setGoroutineLabels(ctx context.Context) Object {
// 	_pprof.SetGoroutineLabels(ctx)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.StopCPUProfile:
// func stopCPUProfile() Object {
// 	_pprof.StopCPUProfile()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/pprof.WithLabels:
// func withLabels(ctx context.Context, labels runtime/pprof.LabelSet) Object {
// 	return _pprof.WithLabels(ctx, labels)
// }

GO FUNC runtime/trace.Log:
// func log(ctx context.Context, category string, message string) Object {
// 	_trace.Log(ctx, category, message)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.Logf:
// func logf(ctx context.Context, category string, format string, args ...interface {}) Object {
// 	_trace.Logf(ctx, category, format, args)
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.NewTask:
// func newTask(pctx context.Context, taskType string) Object {
// 	ctx, _ := _trace.NewTask(pctx, taskType)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ctx)
// 	_res = _res.Conjoin(NIL)
// 	return _res
// }

GO FUNC runtime/trace.StartRegion:
// func startRegion(ctx context.Context, regionType string) Object {
// 	return _trace.StartRegion(ctx, regionType)
// 	ABEND124(no public information returned)
// }

GO FUNC runtime/trace.Stop:
// func stop() Object {
// 	_trace.Stop()
// 	...ABEND675: TODO...
// }

GO FUNC runtime/trace.WithRegion:
// func withRegion(ctx context.Context, regionType string, fn func) Object {
// 	_trace.WithRegion(ctx, regionType, fn)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Float64s:
// func float64s(a []float64) Object {
// 	_sort.Float64s(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Ints:
// func ints(a []int) Object {
// 	_sort.Ints(a)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Reverse:
// func reverse(data sort.Interface) Object {
// 	return _sort.Reverse(data)
// }

GO FUNC sort.Slice:
// func slice(slice interface {}, less func) Object {
// 	_sort.Slice(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.SliceStable:
// func sliceStable(slice interface {}, less func) Object {
// 	_sort.SliceStable(slice, less)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Sort:
// func sort(data sort.Interface) Object {
// 	_sort.Sort(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Stable:
// func stable(data sort.Interface) Object {
// 	_sort.Stable(data)
// 	...ABEND675: TODO...
// }

GO FUNC sort.Strings:
// func strings(a []string) Object {
// 	_sort.Strings(a)
// 	...ABEND675: TODO...
// }

GO FUNC strconv.AppendBool:
func appendBool(dst []byte, b bool) Object {
	_res := _strconv.AppendBool(dst, b)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC strconv.AppendFloat:
// func appendFloat(dst []byte, f float64, fmt byte, prec int, bitSize int) Object {
// 	_res := _strconv.AppendFloat(dst, f, fmt, prec, bitSize)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendInt:
func appendInt(dst []byte, i int64, base int) Object {
	_res := _strconv.AppendInt(dst, i, base)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC strconv.AppendQuote:
func appendQuote(dst []byte, s string) Object {
	_res := _strconv.AppendQuote(dst, s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC strconv.AppendQuoteRune:
// func appendQuoteRune(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRune(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToASCII:
// func appendQuoteRuneToASCII(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToASCII(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteRuneToGraphic:
// func appendQuoteRuneToGraphic(dst []byte, r rune) Object {
// 	_res := _strconv.AppendQuoteRuneToGraphic(dst, r)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.AppendQuoteToASCII:
func appendQuoteToASCII(dst []byte, s string) Object {
	_res := _strconv.AppendQuoteToASCII(dst, s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC strconv.AppendQuoteToGraphic:
func appendQuoteToGraphic(dst []byte, s string) Object {
	_res := _strconv.AppendQuoteToGraphic(dst, s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC strconv.AppendUint:
// func appendUint(dst []byte, i uint64, base int) Object {
// 	_res := _strconv.AppendUint(dst, i, base)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC strconv.Atoi:
func atoi(s string) Object {
	_res1, _res2 := _strconv.Atoi(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseBool:
func parseBool(str string) Object {
	_res1, _res2 := _strconv.ParseBool(str)
	_res := EmptyVector
	_res = _res.Conjoin(MakeBool(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.ParseFloat:
// func parseFloat(s string, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseFloat(s, bitSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.ParseInt:
func parseInt(s string, base int, bitSize int) Object {
	i, err := _strconv.ParseInt(s, base, bitSize)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(i)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC strconv.ParseUint:
// func parseUint(s string, base int, bitSize int) Object {
// 	_res1, _res2 := _strconv.ParseUint(s, base, bitSize)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC strconv.Unquote:
func unquote(s string) Object {
	_res1, _res2 := _strconv.Unquote(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC strconv.UnquoteChar:
// func unquoteChar(s string, quote byte) Object {
// 	value, multibyte, tail, err := _strconv.UnquoteChar(s, quote)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(value)
// 	_res = _res.Conjoin(MakeBool(multibyte))
// 	_res = _res.Conjoin(MakeString(tail))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC strings.Fields:
func fields(s string) Object {
	_res := _strings.Fields(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.FieldsFunc:
// func fieldsFunc(s string, f func) Object {
// 	_res := _strings.FieldsFunc(s, f)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeString(_elem1))
// 	}
// 	return _vec1
// }

GO FUNC strings.NewReader:
// func newReader(s string) Object {
// 	return _strings.NewReader(s)
// 	ABEND124(no public information returned)
// }

GO FUNC strings.NewReplacer:
// func newReplacer(oldnew ...string) Object {
// 	return _strings.NewReplacer(oldnew)
// 	ABEND124(no public information returned)
// }

GO FUNC strings.Split:
func split(s string, sep string) Object {
	_res := _strings.Split(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfter:
func splitAfter(s string, sep string) Object {
	_res := _strings.SplitAfter(s, sep)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitAfterN:
func splitAfterN(s string, sep string, n int) Object {
	_res := _strings.SplitAfterN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC strings.SplitN:
func splitN(s string, sep string, n int) Object {
	_res := _strings.SplitN(s, sep, n)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC sync.NewCond:
// func newCond(l sync.Locker) Object {
// 	_res := _sync.NewCond(l)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("L"), (*_res).L)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC sync/atomic.AddUint64:
// func addUint64(addr *uint64, delta uint64) Object {
// 	return _atomic.AddUint64(addr, delta)
// }

GO FUNC sync/atomic.AddUintptr:
// func addUintptr(addr *uintptr, delta uintptr) Object {
// 	return _atomic.AddUintptr(addr, delta)
// }

GO FUNC sync/atomic.LoadPointer:
// func loadPointer(addr *unsafe.Pointer) Object {
// 	return _atomic.LoadPointer(addr)
// }

GO FUNC sync/atomic.LoadUint64:
// func loadUint64(addr *uint64) Object {
// 	return _atomic.LoadUint64(addr)
// }

GO FUNC sync/atomic.LoadUintptr:
// func loadUintptr(addr *uintptr) Object {
// 	return _atomic.LoadUintptr(addr)
// }

GO FUNC sync/atomic.StoreInt32:
// func storeInt32(addr *int32, val int32) Object {
// 	_atomic.StoreInt32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreInt64:
// func storeInt64(addr *int64, val int64) Object {
// 	_atomic.StoreInt64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StorePointer:
// func storePointer(addr *unsafe.Pointer, val unsafe.Pointer) Object {
// 	_atomic.StorePointer(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint32:
// func storeUint32(addr *uint32, val uint32) Object {
// 	_atomic.StoreUint32(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUint64:
// func storeUint64(addr *uint64, val uint64) Object {
// 	_atomic.StoreUint64(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.StoreUintptr:
// func storeUintptr(addr *uintptr, val uintptr) Object {
// 	_atomic.StoreUintptr(addr, val)
// 	...ABEND675: TODO...
// }

GO FUNC sync/atomic.SwapPointer:
// func swapPointer(addr *unsafe.Pointer, new unsafe.Pointer) Object {
// 	return _atomic.SwapPointer(addr, new)
// }

GO FUNC sync/atomic.SwapUint64:
// func swapUint64(addr *uint64, new uint64) Object {
// 	return _atomic.SwapUint64(addr, new)
// }

GO FUNC sync/atomic.SwapUintptr:
// func swapUintptr(addr *uintptr, new uintptr) Object {
// 	return _atomic.SwapUintptr(addr, new)
// }

GO FUNC syscall.Accept:
// func accept(fd int) Object {
// 	nfd, sa, err := _syscall.Accept(fd)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(nfd))
// 	_res = _res.Conjoin(sa)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Accept4:
// func accept4(fd int, flags int) Object {
// 	nfd, sa, err := _syscall.Accept4(fd, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(nfd))
// 	_res = _res.Conjoin(sa)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Adjtimex:
// func adjtimex(buf *syscall.Timex) Object {
// 	state, err := _syscall.Adjtimex(buf)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(state))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.BytePtrFromString:
func bytePtrFromString(s string) Object {
	_res1, _res2 := _syscall.BytePtrFromString(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int((*_res1))))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ByteSliceFromString:
func byteSliceFromString(s string) Object {
	_res1, _res2 := _syscall.ByteSliceFromString(s)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Clearenv:
// func clearenv() Object {
// 	_syscall.Clearenv()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.CloseOnExec:
// func closeOnExec(fd int) Object {
// 	_syscall.CloseOnExec(fd)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Creat:
func creat(path string, mode uint32) Object {
	fd, err := _syscall.Creat(path, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Dup:
func dup(oldfd int) Object {
	fd, err := _syscall.Dup(oldfd)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Environ:
func environ() Object {
	_res := _syscall.Environ()
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	return _vec1
}

GO FUNC syscall.EpollCreate:
func epollCreate(size int) Object {
	fd, err := _syscall.EpollCreate(size)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.EpollCreate1:
func epollCreate1(flag int) Object {
	fd, err := _syscall.EpollCreate1(flag)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.EpollWait:
// func epollWait(epfd int, events []syscall.EpollEvent, msec int) Object {
// 	n, err := _syscall.EpollWait(epfd, events, msec)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Exit:
// func exit(code int) Object {
// 	_syscall.Exit(code)
// 	...ABEND675: TODO...
// }

GO FUNC syscall.ForkExec:
// func forkExec(argv0 string, argv []string, attr *syscall.ProcAttr) Object {
// 	pid, err := _syscall.ForkExec(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getcwd:
func getcwd(buf []byte) Object {
	n, err := _syscall.Getcwd(buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getdents:
func getdents(fd int, buf []byte) Object {
	n, err := _syscall.Getdents(fd, buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getenv:
func getenv(key string) Object {
	value, found := _syscall.Getenv(key)
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(value))
	_res = _res.Conjoin(MakeBool(found))
	return _res
}

GO FUNC syscall.Getgroups:
func getgroups() Object {
	gids, err := _syscall.Getgroups()
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range gids {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpeername:
// func getpeername(fd int) Object {
// 	sa, err := _syscall.Getpeername(fd)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(sa)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Getpgid:
func getpgid(pid int) Object {
	pgid, err := _syscall.Getpgid(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pgid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getpriority:
func getpriority(which int, who int) Object {
	prio, err := _syscall.Getpriority(which, who)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(prio))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getsockname:
// func getsockname(fd int) Object {
// 	sa, err := _syscall.Getsockname(fd)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(sa)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.GetsockoptICMPv6Filter:
func getsockoptICMPv6Filter(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptICMPv6Filter(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).Data {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("Data"), _vec2)
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreq:
func getsockoptIPMreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreq(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).Multiaddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("Multiaddr"), _vec2)
		_vec3 := EmptyVector
		for _, _elem3 := range (*_res1).Interface {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map1.Add(MakeKeyword("Interface"), _vec3)
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPMreqn:
func getsockoptIPMreqn(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPMreqn(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).Multiaddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("Multiaddr"), _vec2)
		_vec3 := EmptyVector
		for _, _elem3 := range (*_res1).Address {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map1.Add(MakeKeyword("Address"), _vec3)
		_map1.Add(MakeKeyword("Ifindex"), MakeInt(int((*_res1).Ifindex)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6MTUInfo:
func getsockoptIPv6MTUInfo(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6MTUInfo(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map2 := EmptyArrayMap()
		_map2.Add(MakeKeyword("Family"), MakeInt(int((*_res1).Addr.Family)))
		_map2.Add(MakeKeyword("Port"), MakeInt(int((*_res1).Addr.Port)))
		_map2.Add(MakeKeyword("Flowinfo"), MakeInt(int((*_res1).Addr.Flowinfo)))
		_vec3 := EmptyVector
		for _, _elem3 := range (*_res1).Addr.Addr {
			_vec3 = _vec3.Conjoin(MakeInt(int(_elem3)))
		}
		_map2.Add(MakeKeyword("Addr"), _vec3)
		_map2.Add(MakeKeyword("Scope_id"), MakeInt(int((*_res1).Addr.Scope_id)))
		_map1.Add(MakeKeyword("Addr"), _map2)
		_map1.Add(MakeKeyword("Mtu"), MakeInt(int((*_res1).Mtu)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptIPv6Mreq:
func getsockoptIPv6Mreq(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptIPv6Mreq(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_vec2 := EmptyVector
		for _, _elem2 := range (*_res1).Multiaddr {
			_vec2 = _vec2.Conjoin(MakeInt(int(_elem2)))
		}
		_map1.Add(MakeKeyword("Multiaddr"), _vec2)
		_map1.Add(MakeKeyword("Interface"), MakeInt(int((*_res1).Interface)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.GetsockoptInet4Addr:
func getsockoptInet4Addr(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInet4Addr(fd, level, opt)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range value {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptInt:
func getsockoptInt(fd int, level int, opt int) Object {
	value, err := _syscall.GetsockoptInt(fd, level, opt)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(value))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.GetsockoptUcred:
func getsockoptUcred(fd int, level int, opt int) Object {
	_res1, _res2 := _syscall.GetsockoptUcred(fd, level, opt)
	_res := EmptyVector
	var _obj_map1 Object
	if _res1 != nil {
		_map1 := EmptyArrayMap()
		_map1.Add(MakeKeyword("Pid"), MakeInt(int((*_res1).Pid)))
		_map1.Add(MakeKeyword("Uid"), MakeInt(int((*_res1).Uid)))
		_map1.Add(MakeKeyword("Gid"), MakeInt(int((*_res1).Gid)))
		_obj_map1 = Object(_map1)
	} else {
		_obj_map1 = NIL
	}
	_res = _res.Conjoin(_obj_map1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Getwd:
func getwd() Object {
	wd, err := _syscall.Getwd()
	_res := EmptyVector
	_res = _res.Conjoin(MakeString(wd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Getxattr:
func getxattr(path string, attr string, dest []byte) Object {
	sz, err := _syscall.Getxattr(path, attr, dest)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(sz))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyAddWatch:
func inotifyAddWatch(fd int, pathname string, mask uint32) Object {
	watchdesc, err := _syscall.InotifyAddWatch(fd, pathname, mask)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(watchdesc))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyInit:
func inotifyInit() Object {
	fd, err := _syscall.InotifyInit()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyInit1:
func inotifyInit1(flags int) Object {
	fd, err := _syscall.InotifyInit1(flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.InotifyRmWatch:
func inotifyRmWatch(fd int, watchdesc uint32) Object {
	success, err := _syscall.InotifyRmWatch(fd, watchdesc)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(success))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Klogctl:
func klogctl(typ int, buf []byte) Object {
	n, err := _syscall.Klogctl(typ, buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Listxattr:
func listxattr(path string, dest []byte) Object {
	sz, err := _syscall.Listxattr(path, dest)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(sz))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.LsfJump:
// func lsfJump(code int, k int, jt int, jf int) Object {
// 	_res := _syscall.LsfJump(code, k, jt, jf)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Code"), MakeInt(int((*_res).Code)))
// 		_map1.Add(MakeKeyword("Jt"), (*_res).Jt)
// 		_map1.Add(MakeKeyword("Jf"), (*_res).Jf)
// 		_map1.Add(MakeKeyword("K"), MakeInt(int((*_res).K)))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC syscall.LsfSocket:
func lsfSocket(ifindex int, proto int) Object {
	_res1, _res2 := _syscall.LsfSocket(ifindex, proto)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(_res1))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.LsfStmt:
// func lsfStmt(code int, k int) Object {
// 	_res := _syscall.LsfStmt(code, k)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Code"), MakeInt(int((*_res).Code)))
// 		_map1.Add(MakeKeyword("Jt"), (*_res).Jt)
// 		_map1.Add(MakeKeyword("Jf"), (*_res).Jf)
// 		_map1.Add(MakeKeyword("K"), MakeInt(int((*_res).K)))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC syscall.Mmap:
func mmap(fd int, offset int64, length int, prot int, flags int) Object {
	data, err := _syscall.Mmap(fd, offset, length, prot, flags)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range data {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.NetlinkRIB:
func netlinkRIB(proto int, family int) Object {
	_res1, _res2 := _syscall.NetlinkRIB(proto, family)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.NsecToTimespec:
func nsecToTimespec(nsec int64) Object {
	_res := _syscall.NsecToTimespec(nsec)
	_map1 := EmptyArrayMap()
	_map1.Add(MakeKeyword("Sec"), MakeInt(int(_res.Sec)))
	_map1.Add(MakeKeyword("Nsec"), MakeInt(int(_res.Nsec)))
	return _map1
}

GO FUNC syscall.NsecToTimeval:
func nsecToTimeval(nsec int64) Object {
	_res := _syscall.NsecToTimeval(nsec)
	_map1 := EmptyArrayMap()
	_map1.Add(MakeKeyword("Sec"), MakeInt(int(_res.Sec)))
	_map1.Add(MakeKeyword("Usec"), MakeInt(int(_res.Usec)))
	return _map1
}

GO FUNC syscall.Open:
func open(path string, mode int, perm uint32) Object {
	fd, err := _syscall.Open(path, mode, perm)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Openat:
func openat(dirfd int, path string, flags int, mode uint32) Object {
	fd, err := _syscall.Openat(dirfd, path, flags, mode)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.ParseDirent:
func parseDirent(buf []byte, max int, names []string) Object {
	consumed, count, newnames := _syscall.ParseDirent(buf, max, names)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(consumed))
	_res = _res.Conjoin(MakeInt(count))
	_vec1 := EmptyVector
	for _, _elem1 := range newnames {
		_vec1 = _vec1.Conjoin(MakeString(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	return _res
}

GO FUNC syscall.ParseNetlinkMessage:
func parseNetlinkMessage(b []byte) Object {
	_res1, _res2 := _syscall.ParseNetlinkMessage(b)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_map2 := EmptyArrayMap()
		_map3 := EmptyArrayMap()
		_map3.Add(MakeKeyword("Len"), MakeInt(int(_elem1.Header.Len)))
		_map3.Add(MakeKeyword("Type"), MakeInt(int(_elem1.Header.Type)))
		_map3.Add(MakeKeyword("Flags"), MakeInt(int(_elem1.Header.Flags)))
		_map3.Add(MakeKeyword("Seq"), MakeInt(int(_elem1.Header.Seq)))
		_map3.Add(MakeKeyword("Pid"), MakeInt(int(_elem1.Header.Pid)))
		_map2.Add(MakeKeyword("Header"), _map3)
		_vec4 := EmptyVector
		for _, _elem4 := range _elem1.Data {
			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
		}
		_map2.Add(MakeKeyword("Data"), _vec4)
		_vec1 = _vec1.Conjoin(_map2)
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.ParseNetlinkRouteAttr:
// func parseNetlinkRouteAttr(m *syscall.NetlinkMessage) Object {
// 	_res1, _res2 := _syscall.ParseNetlinkRouteAttr(m)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_map2 := EmptyArrayMap()
// 		_map3 := EmptyArrayMap()
// 		_map3.Add(MakeKeyword("Len"), MakeInt(int(_elem1.Attr.Len)))
// 		_map3.Add(MakeKeyword("Type"), MakeInt(int(_elem1.Attr.Type)))
// 		_map2.Add(MakeKeyword("Attr"), _map3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range _elem1.Value {
// 			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 		}
// 		_map2.Add(MakeKeyword("Value"), _vec4)
// 		_vec1 = _vec1.Conjoin(_map2)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseSocketControlMessage:
// func parseSocketControlMessage(b []byte) Object {
// 	_res1, _res2 := _syscall.ParseSocketControlMessage(b)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_map2 := EmptyArrayMap()
// 		_map3 := EmptyArrayMap()
// 		_map3.Add(MakeKeyword("Len"), _elem1.Header.Len)
// 		_map3.Add(MakeKeyword("Level"), MakeInt(int(_elem1.Header.Level)))
// 		_map3.Add(MakeKeyword("Type"), MakeInt(int(_elem1.Header.Type)))
// 		_map2.Add(MakeKeyword("Header"), _map3)
// 		_vec4 := EmptyVector
// 		for _, _elem4 := range _elem1.Data {
// 			_vec4 = _vec4.Conjoin(MakeInt(int(_elem4)))
// 		}
// 		_map2.Add(MakeKeyword("Data"), _vec4)
// 		_vec1 = _vec1.Conjoin(_map2)
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseUnixCredentials:
// func parseUnixCredentials(m *syscall.SocketControlMessage) Object {
// 	_res1, _res2 := _syscall.ParseUnixCredentials(m)
// 	_res := EmptyVector
// 	var _obj_map1 Object
// 	if _res1 != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Pid"), MakeInt(int((*_res1).Pid)))
// 		_map1.Add(MakeKeyword("Uid"), MakeInt(int((*_res1).Uid)))
// 		_map1.Add(MakeKeyword("Gid"), MakeInt(int((*_res1).Gid)))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	_res = _res.Conjoin(_obj_map1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.ParseUnixRights:
// func parseUnixRights(m *syscall.SocketControlMessage) Object {
// 	_res1, _res2 := _syscall.ParseUnixRights(m)
// 	_res := EmptyVector
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res1 {
// 		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
// 	}
// 	_res = _res.Conjoin(_vec1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC syscall.Pread:
func pread(fd int, p []byte, offset int64) Object {
	n, err := _syscall.Pread(fd, p, offset)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.PtraceGetEventMsg:
func ptraceGetEventMsg(pid int) Object {
	msg, err := _syscall.PtraceGetEventMsg(pid)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(msg)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.PtracePeekData:
// func ptracePeekData(pid int, addr uintptr, out []byte) Object {
// 	count, err := _syscall.PtracePeekData(pid, addr, out)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePeekText:
// func ptracePeekText(pid int, addr uintptr, out []byte) Object {
// 	count, err := _syscall.PtracePeekText(pid, addr, out)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePokeData:
// func ptracePokeData(pid int, addr uintptr, data []byte) Object {
// 	count, err := _syscall.PtracePokeData(pid, addr, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.PtracePokeText:
// func ptracePokeText(pid int, addr uintptr, data []byte) Object {
// 	count, err := _syscall.PtracePokeText(pid, addr, data)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(count))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Pwrite:
func pwrite(fd int, p []byte, offset int64) Object {
	n, err := _syscall.Pwrite(fd, p, offset)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.RawSyscall:
// func rawSyscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall(trap, a1, a2, a3)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(err)
// 	return _res
// }

GO FUNC syscall.RawSyscall6:
// func rawSyscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.RawSyscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(err)
// 	return _res
// }

GO FUNC syscall.Read:
func read(fd int, p []byte) Object {
	n, err := _syscall.Read(fd, p)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.ReadDirent:
func readDirent(fd int, buf []byte) Object {
	n, err := _syscall.ReadDirent(fd, buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Readlink:
func readlink(path string, buf []byte) Object {
	n, err := _syscall.Readlink(path, buf)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Recvfrom:
// func recvfrom(fd int, p []byte, flags int) Object {
// 	n, from, err := _syscall.Recvfrom(fd, p, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(from)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Recvmsg:
// func recvmsg(fd int, p []byte, oob []byte, flags int) Object {
// 	n, oobn, recvflags, from, err := _syscall.Recvmsg(fd, p, oob, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(MakeInt(oobn))
// 	_res = _res.Conjoin(MakeInt(recvflags))
// 	_res = _res.Conjoin(from)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Seek:
func seek(fd int, offset int64, whence int) Object {
	off, err := _syscall.Seek(fd, offset, whence)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(off)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Select:
// func select(nfd int, r *syscall.FdSet, w *syscall.FdSet, e *syscall.FdSet, timeout *syscall.Timeval) Object {
// 	n, err := _syscall.Select(nfd, r, w, e, timeout)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Sendfile:
// func sendfile(outfd int, infd int, offset *int64, count int) Object {
// 	written, err := _syscall.Sendfile(outfd, infd, offset, count)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(written))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.SendmsgN:
// func sendmsgN(fd int, p []byte, oob []byte, to syscall.Sockaddr, flags int) Object {
// 	n, err := _syscall.SendmsgN(fd, p, oob, to, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(n))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Setsid:
func setsid() Object {
	pid, err := _syscall.Setsid()
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(pid))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.SlicePtrFromStrings:
func slicePtrFromStrings(ss []string) Object {
	_res1, _res2 := _syscall.SlicePtrFromStrings(ss)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range _res1 {
		_vec1 = _vec1.Conjoin(MakeInt(int((*_elem1))))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC syscall.Socket:
func socket(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socket(domain, typ, proto)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(fd))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Socketpair:
func socketpair(domain int, typ int, proto int) Object {
	fd, err := _syscall.Socketpair(domain, typ, proto)
	_res := EmptyVector
	_vec1 := EmptyVector
	for _, _elem1 := range fd {
		_vec1 = _vec1.Conjoin(MakeInt(_elem1))
	}
	_res = _res.Conjoin(_vec1)
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Splice:
// func splice(rfd int, roff *int64, wfd int, woff *int64, len int, flags int) Object {
// 	n, err := _syscall.Splice(rfd, roff, wfd, woff, len, flags)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(n)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.StartProcess:
// func startProcess(argv0 string, argv []string, attr *syscall.ProcAttr) Object {
// 	pid, handle, err := _syscall.StartProcess(argv0, argv, attr)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(pid))
// 	_res = _res.Conjoin(handle)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.StringByteSlice:
func stringByteSlice(s string) Object {
	_res := _syscall.StringByteSlice(s)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
	}
	return _vec1
}

GO FUNC syscall.StringSlicePtr:
func stringSlicePtr(ss []string) Object {
	_res := _syscall.StringSlicePtr(ss)
	_vec1 := EmptyVector
	for _, _elem1 := range _res {
		_vec1 = _vec1.Conjoin(MakeInt(int((*_elem1))))
	}
	return _vec1
}

GO FUNC syscall.Sync:
// func sync() Object {
// 	_syscall.Sync()
// 	...ABEND675: TODO...
// }

GO FUNC syscall.Syscall:
// func syscall(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall(trap, a1, a2, a3)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(err)
// 	return _res
// }

GO FUNC syscall.Syscall6:
// func syscall6(trap uintptr, a1 uintptr, a2 uintptr, a3 uintptr, a4 uintptr, a5 uintptr, a6 uintptr) Object {
// 	r1, r2, err := _syscall.Syscall6(trap, a1, a2, a3, a4, a5, a6)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	_res = _res.Conjoin(err)
// 	return _res
// }

GO FUNC syscall.Tee:
func tee(rfd int, wfd int, len int, flags int) Object {
	n, err := _syscall.Tee(rfd, wfd, len, flags)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(n)))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC syscall.Time:
// func time(t *syscall.Time_t) Object {
// 	tt, err := _syscall.Time(t)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(int(tt)))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Times:
// func times(tms *syscall.Tms) Object {
// 	ticks, err := _syscall.Times(tms)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(ticks)
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.UnixCredentials:
// func unixCredentials(ucred *syscall.Ucred) Object {
// 	_res := _syscall.UnixCredentials(ucred)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC syscall.UnixRights:
// func unixRights(fds ...int) Object {
// 	_res := _syscall.UnixRights(fds)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC syscall.Wait4:
// func wait4(pid int, wstatus *syscall.WaitStatus, options int, rusage *syscall.Rusage) Object {
// 	wpid, err := _syscall.Wait4(pid, wstatus, options, rusage)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeInt(wpid))
// 	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
// 	return _res
// }

GO FUNC syscall.Write:
func write(fd int, p []byte) Object {
	n, err := _syscall.Write(fd, p)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(n))
	_res = _res.Conjoin(func () Object { if (err) == nil { return NIL } else { return MakeError(err) } }())
	return _res
}

GO FUNC testing.AllocsPerRun:
// func allocsPerRun(runs int, f func) Object {
// 	return _testing.AllocsPerRun(runs, f)
// }

GO FUNC testing.Benchmark:
// func benchmark(f func) Object {
// 	_res := _testing.Benchmark(f)
// 	_map1 := EmptyArrayMap()
// 	_map1.Add(MakeKeyword("N"), MakeInt(_res.N))
// 	_map1.Add(MakeKeyword("T"), MakeInt(int(_res.T)))
// 	_map1.Add(MakeKeyword("Bytes"), MakeInt(int(_res.Bytes)))
// 	_map1.Add(MakeKeyword("MemAllocs"), _res.MemAllocs)
// 	_map1.Add(MakeKeyword("MemBytes"), _res.MemBytes)
// 	return _map1
// }

GO FUNC testing.Coverage:
// func coverage() Object {
// 	return _testing.Coverage()
// }

GO FUNC testing.Main:
// func main(matchString func, tests []testing.InternalTest, benchmarks []testing.InternalBenchmark, examples []testing.InternalExample) Object {
// 	_testing.Main(matchString, tests, benchmarks, examples)
// 	...ABEND675: TODO...
// }

GO FUNC testing.MainStart:
// func mainStart(deps testDeps, tests []testing.InternalTest, benchmarks []testing.InternalBenchmark, examples []testing.InternalExample) Object {
// 	return _testing.MainStart(deps, tests, benchmarks, examples)
// 	ABEND124(no public information returned)
// }

GO FUNC testing.RegisterCover:
// func registerCover(c testing.Cover) Object {
// 	_testing.RegisterCover(c)
// 	...ABEND675: TODO...
// }

GO FUNC testing.RunBenchmarks:
// func runBenchmarks(matchString func, benchmarks []testing.InternalBenchmark) Object {
// 	_testing.RunBenchmarks(matchString, benchmarks)
// 	...ABEND675: TODO...
// }

GO FUNC testing/iotest.DataErrReader:
// func dataErrReader(r io.Reader) Object {
// 	return _iotest.DataErrReader(r)
// }

GO FUNC testing/iotest.HalfReader:
// func halfReader(r io.Reader) Object {
// 	return _iotest.HalfReader(r)
// }

GO FUNC testing/iotest.NewReadLogger:
// func newReadLogger(prefix string, r io.Reader) Object {
// 	return _iotest.NewReadLogger(prefix, r)
// }

GO FUNC testing/iotest.NewWriteLogger:
// func newWriteLogger(prefix string, w io.Writer) Object {
// 	return _iotest.NewWriteLogger(prefix, w)
// }

GO FUNC testing/iotest.OneByteReader:
// func oneByteReader(r io.Reader) Object {
// 	return _iotest.OneByteReader(r)
// }

GO FUNC testing/iotest.TimeoutReader:
// func timeoutReader(r io.Reader) Object {
// 	return _iotest.TimeoutReader(r)
// }

GO FUNC testing/iotest.TruncateWriter:
// func truncateWriter(w io.Writer, n int64) Object {
// 	return _iotest.TruncateWriter(w, n)
// }

GO FUNC testing/quick.Value:
// func value(t reflect.Type, rand *math/rand.Rand) Object {
// 	_, ok := _quick.Value(t, rand)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC text/tabwriter.NewWriter:
// func newWriter(output io.Writer, minwidth int, tabwidth int, padding int, padchar byte, flags uint) Object {
// 	return _tabwriter.NewWriter(output, minwidth, tabwidth, padding, padchar, flags)
// 	ABEND124(no public information returned)
// }

GO FUNC text/template.HTMLEscape:
// func hTMLEscape(w io.Writer, b []byte) Object {
// 	_template.HTMLEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.IsTrue:
// func isTrue(val interface {}) Object {
// 	truth, ok := _template.IsTrue(val)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(MakeBool(truth))
// 	_res = _res.Conjoin(MakeBool(ok))
// 	return _res
// }

GO FUNC text/template.JSEscape:
// func jSEscape(w io.Writer, b []byte) Object {
// 	_template.JSEscape(w, b)
// 	...ABEND675: TODO...
// }

GO FUNC text/template.Must:
// func must(t *text/template.Template, err error) Object {
// 	return _template.Must(t, err)
// 	ABEND124(no public information returned)
// }

GO FUNC text/template.New:
// func new(name string) Object {
// 	return _template.New(name)
// 	ABEND124(no public information returned)
// }

GO FUNC text/template.ParseFiles:
// func parseFiles(filenames ...string) Object {
// 	_, _res2 := _template.ParseFiles(filenames)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC text/template.ParseGlob:
func parseGlob(pattern string) Object {
	_, _res2 := _template.ParseGlob(pattern)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC text/template/parse.New:
// func new(name string, funcs ...map[]) Object {
// 	_res := _parse.New(name, funcs)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Name"), MakeString((*_res).Name))
// 		_map1.Add(MakeKeyword("ParseName"), MakeString((*_res).ParseName))
// 		var _obj_map2 Object
// 		if (*_res).Root != nil {
// 			_map2 := EmptyArrayMap()
// 			_vec3 := EmptyVector
// 			for _, _elem3 := range (*(*_res).Root).Nodes {
// 				_vec3 = _vec3.Conjoin(_elem3)
// 			}
// 			_map2.Add(MakeKeyword("Nodes"), _vec3)
// 			_obj_map2 = Object(_map2)
// 		} else {
// 			_obj_map2 = NIL
// 		}
// 		_map1.Add(MakeKeyword("Root"), _obj_map2)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC text/template/parse.NewIdentifier:
// func newIdentifier(ident string) Object {
// 	_res := _parse.NewIdentifier(ident)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("Ident"), MakeString((*_res).Ident))
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC text/template/parse.Parse:
// func parse(name string, text string, leftDelim string, rightDelim string, funcs ...map[]) Object {
// 	_res1, _res2 := _parse.Parse(name, text, leftDelim, rightDelim, funcs)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(_res1)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.After:
// func after(d time.Duration) Object {
// 	return _time.After(d)
// }

GO FUNC time.AfterFunc:
// func afterFunc(d time.Duration, f func) Object {
// 	_res := _time.AfterFunc(d, f)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("C"), (*_res).C)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC time.Date:
// func date(year int, month time.Month, day int, hour int, min int, sec int, nsec int, loc *time.Location) Object {
// 	return _time.Date(year, month, day, hour, min, sec, nsec, loc)
// 	ABEND124(no public information returned)
// }

GO FUNC time.FixedZone:
// func fixedZone(name string, offset int) Object {
// 	return _time.FixedZone(name, offset)
// 	ABEND124(no public information returned)
// }

GO FUNC time.LoadLocation:
func loadLocation(name string) Object {
	_, _res2 := _time.LoadLocation(name)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.LoadLocationFromTZData:
func loadLocationFromTZData(name string, data []byte) Object {
	_, _res2 := _time.LoadLocationFromTZData(name, data)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.NewTicker:
// func newTicker(d time.Duration) Object {
// 	_res := _time.NewTicker(d)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("C"), (*_res).C)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC time.NewTimer:
// func newTimer(d time.Duration) Object {
// 	_res := _time.NewTimer(d)
// 	var _obj_map1 Object
// 	if _res != nil {
// 		_map1 := EmptyArrayMap()
// 		_map1.Add(MakeKeyword("C"), (*_res).C)
// 		_obj_map1 = Object(_map1)
// 	} else {
// 		_obj_map1 = NIL
// 	}
// 	return _obj_map1
// }

GO FUNC time.Now:
// func now() Object {
// 	return _time.Now()
// 	ABEND124(no public information returned)
// }

GO FUNC time.Parse:
func parse(layout string, value string) Object {
	_, _res2 := _time.Parse(layout, value)
	_res := EmptyVector
	_res = _res.Conjoin(NIL)
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseDuration:
func parseDuration(s string) Object {
	_res1, _res2 := _time.ParseDuration(s)
	_res := EmptyVector
	_res = _res.Conjoin(MakeInt(int(_res1)))
	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
	return _res
}

GO FUNC time.ParseInLocation:
// func parseInLocation(layout string, value string, loc *time.Location) Object {
// 	_, _res2 := _time.ParseInLocation(layout, value, loc)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(NIL)
// 	_res = _res.Conjoin(func () Object { if (_res2) == nil { return NIL } else { return MakeError(_res2) } }())
// 	return _res
// }

GO FUNC time.Sleep:
// func sleep(d time.Duration) Object {
// 	_time.Sleep(d)
// 	...ABEND675: TODO...
// }

GO FUNC time.Tick:
// func tick(d time.Duration) Object {
// 	return _time.Tick(d)
// }

GO FUNC time.Unix:
// func unix(sec int64, nsec int64) Object {
// 	return _time.Unix(sec, nsec)
// 	ABEND124(no public information returned)
// }

GO FUNC unicode.SimpleFold:
// func simpleFold(r rune) Object {
// 	return _unicode.SimpleFold(r)
// }

GO FUNC unicode.To:
// func to(_case int, r rune) Object {
// 	return _unicode.To(_case, r)
// }

GO FUNC unicode.ToLower:
// func toLower(r rune) Object {
// 	return _unicode.ToLower(r)
// }

GO FUNC unicode.ToTitle:
// func toTitle(r rune) Object {
// 	return _unicode.ToTitle(r)
// }

GO FUNC unicode.ToUpper:
// func toUpper(r rune) Object {
// 	return _unicode.ToUpper(r)
// }

GO FUNC unicode/utf16.Decode:
// func decode(s []uint16) Object {
// 	_res := _utf16.Decode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(_elem1)
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.DecodeRune:
// func decodeRune(r1 rune, r2 rune) Object {
// 	return _utf16.DecodeRune(r1, r2)
// }

GO FUNC unicode/utf16.Encode:
// func encode(s []rune) Object {
// 	_res := _utf16.Encode(s)
// 	_vec1 := EmptyVector
// 	for _, _elem1 := range _res {
// 		_vec1 = _vec1.Conjoin(MakeInt(int(_elem1)))
// 	}
// 	return _vec1
// }

GO FUNC unicode/utf16.EncodeRune:
// func encodeRune(r rune) Object {
// 	r1, r2 := _utf16.EncodeRune(r)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r1)
// 	_res = _res.Conjoin(r2)
// 	return _res
// }

GO FUNC unicode/utf8.DecodeLastRune:
// func decodeLastRune(p []byte) Object {
// 	r, size := _utf8.DecodeLastRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeLastRuneInString:
// func decodeLastRuneInString(s string) Object {
// 	r, size := _utf8.DecodeLastRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRune:
// func decodeRune(p []byte) Object {
// 	r, size := _utf8.DecodeRune(p)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unicode/utf8.DecodeRuneInString:
// func decodeRuneInString(s string) Object {
// 	r, size := _utf8.DecodeRuneInString(s)
// 	_res := EmptyVector
// 	_res = _res.Conjoin(r)
// 	_res = _res.Conjoin(MakeInt(size))
// 	return _res
// }

GO FUNC unsafe.Alignof:
// func alignof(x unsafe.ArbitraryType) Object {
// 	return _unsafe.Alignof(x)
// }

GO FUNC unsafe.Offsetof:
// func offsetof(x unsafe.ArbitraryType) Object {
// 	return _unsafe.Offsetof(x)
// }

GO FUNC unsafe.Sizeof:
// func sizeof(x unsafe.ArbitraryType) Object {
// 	return _unsafe.Sizeof(x)
// }

ABENDs: 904(732) 042(605) 883(464) 044(257) 043(251) 401(150) 675(129) 124(110) 907(85) 906(42) 947(26) 903(23) 885(16) 905(9) 908(6) 123(2) 902(2) 909(2) 901(1)
Totals: types=964 functions=7135 methods=5623 (78.81%) standalone=1512 (21.19%) generated=486 (32.14%)
